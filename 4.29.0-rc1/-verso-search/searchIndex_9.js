window.docContents[9].resolve({"/Basic-Types/#basic-types":{"contents":"Lean includes a number of built-in types that are specially supported by the compiler.\nSome, such as Nat, additionally have special support in the kernel.\nOther types don't have special compiler support per se, but rely in important ways on the internal representation of types for performance reasons.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"20. Basic Types","id":"/Basic-Types/#basic-types"},"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Transformations":{"contents":"Transforms a sum according to functions on each type.This function maps α ⊕ β to α' ⊕ β', sending α to α' and β to β'.\n\nSwaps the factors of a sum type.The constructor Sum.inl is replaced with Sum.inr, and vice versa.\n\n","context":"Lean Reference\u0009Basic Types\u0009Sum Types\u0009API Reference","header":"20.14.2.3. Transformations","id":"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Transformations"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-02-17_RPAR_--Library":{"contents":"* #11257 adds the definition of BitVec.cpop, which relies on the more\n  general BitVec.cpopNatRec, and build some theory around it. The name\n  cpop aligns with the RISCV ISA\n  nomenclature.* #11438 renames the namespace Std.Range to Std.Legacy.Range. Instead\n  of using Std.Range and [a:b] notation, the new range type Std.Rco\n  and its corresponding a...b notation should be used. There are also\n  other ranges with open/closed/infinite boundary shapes in\n  Std.Data.Range.Polymorphic and the new range notation also works for\n  Int, Int8, UInt8, Fin etc.* #11446 moves many constants of the iterator API from Std.Iterators to\n  the Std namespace in order to make them more convenient to use. These\n  constants include, but are not limited to, Iter, IterM and\n  IteratorLoop. This is a breaking change. If something breaks, try\n  adding open Std in order to make these constants available again. If\n  some constants in the Std.Iterators namespace cannot be found, they\n  can be found directly in Std now.* #11499 adds the Context type for cancellation with context\n  propagation. It works by storing a tree of forks of the main context,\n  providing a way to control cancellation.* #11532 adds the new operation MonadAttach.attach that attaches a\n  proof that a postcondition holds to the return value of a monadic\n  operation. Most non-CPS monads in the standard library support this\n  operation in a nontrivial way. The PR also changes the filterMapM,\n  mapM and flatMapM combinators so that they attach postconditions to\n  the user-provided monadic functions passed to them. This makes it\n  possible to prove termination for some of these for which it wasn't\n  possible before. Additionally, the PR adds many missing lemmas about\n  filterMap(M) and map(M) that were needed in the course of this PR.* #11693 makes it possible to verify loops over iterators. It provides\n  MPL spec lemmas about for loops over pure iterators. It also provides\n  spec lemmas that rewrite loops over mapM, filterMapM or filterM\n  iterator combinators into loops over their base iterator.* #11705 provides many lemmas about Int ranges, in analogy to those\n  about Nat ranges. A few necessary basic Int lemmas are added. The PR\n  also removes simp annotations on Rcc.toList_eq_toList_rco,\n  Nat.toList_rcc_eq_toList_rco and consorts.* #11706 removes the IteratorCollect type class and hereby simplifies\n  the iterator API. Its limited advantages did not justify the complexity\n  cost.* #11710 extends the get-elem tactic for ranges so that it supports\n  subarrays. Example:example {a : Array Nat} (h : a.size = 28) : Id Unit := do\n  let mut x := 0\n  for h : i in *...(3 : Nat) do\n    x := a[1...4][i]\n* #11716 adds more MPL spec lemmas for all combinations of for loops,\n  fold(M) and the filter(M)/filterMap(M)/map(M) iterator combinators.\n  These kinds of loops over these combinators (e.g. it.mapM) are first\n  transformed into loops over their base iterators (it), and if the base\n  iterator is of type Iter _ or IterM Id _, then another spec lemma\n  exists for proving Hoare triples about it using an invariant and the\n  underlying list (it.toList). The PR also fixes a bug that MPL always\n  assigns the default priority to spec lemmas if Std.Tactic.Do.Syntax is\n  not imported and a bug that low-priority lemmas are preferred about\n  high-priority ones.* #11724 adds more event_loop_locks to fix race conditions.* #11728 introduces some additional lemmas around BitVec.extractLsb'\n  and BitVec.extractLsb.* #11760 allows grind to use List.eq_nil_of_length_eq_zero (and\n  Array.eq_empty_of_size_eq_zero), but only when it has already proved\n  the length is zero.* #11761 adds some grind_pattern guard conditions to potentially\n  expensive theorems.* #11762 moves the grind pattern from Sublist.eq_of_length to the\n  slightly more general Sublist.eq_of_length_le, and adds a grind\n  pattern guard so it only activates if we have a proof of the hypothesis.* #11767 introduces two induction principles for bitvectors, based on the\n  concat and cons operations. We show how this principle can be useful to\n  reason about bitvectors by refactoring two population count lemmas\n  (cpopNatRec_zero_le and toNat_cpop_append) and introducing a new\n  lemma (toNat_cpop_not).\n  To use the induction principle we also move cpopNatRec_cons_of_le and\n  cpopNatRec_cons_of_lt earlier in the popcount section (they are the\n  building blocks enabling us to take advantage of the new induction\n  principle).* #11772 fixes a bug in the optimized and unsafe implementation of\n  Array.foldlM.* #11774 fixes a mismatch between the behavior of foldlM and\n  foldlMUnsafe in the three array\n  types. This mismatch is only exposed when manually specifying a stop\n  value greater than the size\n  of the array and only exploitable through native_decide.* #11779 fixes an oversight in the initial #11772 PR.* #11784 just adds an optional start position argument to\n  PersistentArray.forM* #11789 makes the FinitenessRelation structure, which is helpful when\n  proving the finiteness of iterators, part of the public API. Previously,\n  it was marked internal and experimental.* #11794 implements the function getMaxFVar? for implementing SymM\n  primitives.* #11834 adds num? parameter to mkPatternFromTheorem to control how\n  many leading quantifiers are stripped when creating a pattern. This\n  enables matching theorems where only some quantifiers should be\n  converted to pattern variables.* #11848 fixes a bug at Name.beq reported by\n  gasstationcodemanager@gmail.com* #11852 changes the definition of the iterator combinators takeWhileM\n  and dropWhileM so that they use MonadAttach. This is only relevant\n  in rare cases, but makes it sometimes possible to prove such combinators\n  finite when the finiteness depends on properties of the monadic\n  predicate.* #11901 adds gcd_left_comm lemmas for both Nat and Int:* Nat.gcd_left_comm: gcd m (gcd n k) = gcd n (gcd m k)* Int.gcd_left_comm: gcd a (gcd b c) = gcd b (gcd a c)* #11905 provides a Decidable instance for Nat.isPowerOfTwo based on\n  the formula (n ≠ 0) ∧ (n &&& (n - 1)) = 0.* #11907 implements PersistentHashMap.findKeyD and\n  PersistentHashSet.findD. The motivation is avoid two memory\n  allocations (Prod.mk and Option.some) when the collections contains\n  the key.* #11945 changes the runtime implementation of the Decidable (xs = #[])\n  and Decidable (#[] = xs) instances to use Array.isEmpty. Previously,\n  decide (xs = #[]) would first convert xs into a list and then\n  compare it against List.nil.* #11979 adds suggest_for annotations such that Int*.toNatClamp is\n  suggested for Int*.toNat.* #11989 removes a leftover example from\n  src/Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Clz.lean.* #11993 adds grind annotations to the lemmas about Subarray and\n  ListSlice.* #12058 implements iteration over ranges for Fin and Char.* #12139 adds «term_⁻¹» to the recommended_spelling for inv,\n  matching\n  the pattern used by all other operators which include both the function\n  and the syntax in their spelling lists.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0 (2026-02-17)","header":"Library","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-02-17_RPAR_--Library"}});