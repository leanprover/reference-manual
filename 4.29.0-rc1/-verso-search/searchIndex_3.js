window.docContents[3].resolve({"/Basic-Types/Linked-Lists/#List":{"contents":"Linked lists, implemented as the inductive type List, contain an ordered sequence of elements.\nUnlike arrays, Lean compiles lists according to the ordinary rules for inductive types; however, some operations on lists are replaced by tail-recursive equivalents in compiled code using the csimp mechanism.\nLean provides syntax for both literal lists and the constructor List.cons.\n\nLinked lists: ordered lists, in which each element has a reference to the next element.Most operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.List α is isomorphic to Array α, but they are useful for different things:* List α is easier for reasoning, and Array α is modeled as a wrapper around List α.* List α works well as a persistent data structure, when many copies of the tail are shared. When\nthe value is not shared, Array α will have better performance because it can do destructive\nupdates.The empty list, usually written [].Conventions for notations in identifiers:* The recommended spelling of [] in identifiers is nil.The list whose first element is head, where tail is the rest of the list.\nUsually written head :: tail.Conventions for notations in identifiers:* The recommended spelling of :: in identifiers is cons.* The recommended spelling of [a] in identifiers is singleton.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.15. Linked Lists","id":"/Basic-Types/Linked-Lists/#List"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Concepts-and-Terminology--Artifact-Caches--Mappings":{"contents":"When passed the -o option, build tracks the inputs used to generate each build product.\nThese are stored to a mappings file in JSON lines format, where each line of the file must be a valid JSON object.\nA mappings file tracks a single build, and includes all intermediate and final build products for the workspace's root package, but not for its dependencies.\nThis includes build products that were already up to date and not regenerated.\nThe cache put command uploads the build products in the mappings file to the remote from the local cache to the remote cache.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology\u0009Artifact Caches","header":"24.1.1.6.2. Mappings","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Concepts-and-Terminology--Artifact-Caches--Mappings"},"/Type-Classes/Instance-Declarations/#instance-declarations":{"contents":"The syntax of instance declarations is almost identical to that of definitions.\nThe only syntactic differences are that the keyword def is replaced by instance and the name is optional:\n\nInstance DeclarationsMost instances define each method using where syntax:However, type classes are inductive types, so instances can be constructed using any expression with an appropriate type:Instances may also be defined by cases; however, this feature is rarely used outside of Decidable instances:\n\nInstances defined with explicit terms often consist of either anonymous constructors (⟨...⟩) wrapping method implementations or of invocations of inferInstanceAs on definitionally equal types.\n\nElaboration of instances is almost identical to the elaboration of ordinary definitions, with the exception of the caveats documented below.\nIf no name is provided, then one is created automatically.\nIt is possible to refer to this generated name directly, but the algorithm used to generate the names has changed in the past and may change in the future.\nIt's better to explicitly name instances that will be referred to directly.\nAfter elaboration, the new instance is registered as a candidate for instance search.\nAdding the attribute instance to a name can be used to mark any other defined name as a candidate.\n\nInstance Name GenerationFollowing these declarations:structure NatWrapper where\n  val : Nat\n\ninstance : BEq NatWrapper where\n  beq\n    | ⟨x⟩, ⟨y⟩ => x == y\nthe name instBEqNatWrapper refers to the new instance.\n\nVariations in Instance DefinitionsGiven this structure type:structure NatWrapper where\n  val : Nat\nall of the following ways of defining a BEq instance are equivalent:instance : BEq NatWrapper where\n  beq\n    | ⟨x⟩, ⟨y⟩ => x == y\n\ninstance : BEq NatWrapper :=\n  ⟨fun x y => x.val == y.val⟩\n\ninstance : BEq NatWrapper :=\n  ⟨fun ⟨x⟩ ⟨y⟩ => x == y⟩\nAside from introducing different names into the environment, the following are also equivalent:@[instance]\ndef instBeqNatWrapper : BEq NatWrapper where\n  beq\n    | ⟨x⟩, ⟨y⟩ => x == y\n\ninstance : BEq NatWrapper :=\n  ⟨fun x y => x.val == y.val⟩\n\ninstance : BEq NatWrapper :=\n  ⟨fun ⟨x⟩ ⟨y⟩ => x == y⟩\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"10.2. Instance Declarations","id":"/Type-Classes/Instance-Declarations/#instance-declarations"},"/ValidatingProofs/#The-Lean-Language-Reference--Validating-a-Lean-Proof--Printing-Axioms--Significance":{"contents":"This command prints the set of axioms used by the theorem and the theorems it depends on.\nThe three axioms above are standard axioms of Lean's logic, and benign.\n\n* If sorryAx is reported, then this theorem or one of its dependencies uses sorry or is otherwise incomplete.* If Lean.trustCompiler is reported, then native evaluation is used; see below for a discussion.* Any other axiom means that a custom axiom was declared and used, and the theorem is only valid relative to the soundness of these axioms.\n\n","context":"Lean Reference\u0009Validating a Lean Proof\u0009Printing Axioms","header":"Significance","id":"/ValidatingProofs/#The-Lean-Language-Reference--Validating-a-Lean-Proof--Printing-Axioms--Significance"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Lake":{"contents":"* #7909 adds Lake support for building modules given their source file\npath. This is made use of in both the CLI and the server.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)\u0009Highlights","header":"Lake","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Lake"},"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Library":{"contents":"* #7450 implements Nat.dfold, a dependent analogue of Nat.fold.* #9096 removes some unnecessary Decidable* instance arguments by\nusing lemmas in the Classical namespace instead of the Decidable\nnamespace.* #9121 allows grind to case on the universe variants of Prod.* #9129 fixes simp lemmas about boolean equalities to say (!x) = y\ninstead of (!decide (x = y)) = true* #9135 allows the result type of forIn, foldM and fold on pure\niterators (Iter) to be in a different universe than the iterators.* #9142 changes Fin.reverseInduction from using well-founded recursion\nto using let rec, which makes it have better definitional equality.\nCo-authored by @digama0. See the test below:namespace Fin\n\n* #9145 fixes two typos.* #9176 makes mvcgen split ifs rather than applying specifications.\nDoing so fixes a bug reported by Rish.* #9194 makes the logic and tactics of Std.Do universe polymorphic, at\nthe cost of a few definitional properties arising from the switch from\nProp to ULift Prop in the base case SPred [].* #9249 adds theorem BitVec.clzAuxRec_eq_clzAuxRec_of_getLsbD_false as\na more general statement than BitVec.clzAuxRec_eq_clzAuxRec_of_le,\nreplacing the latter in the bitblaster too.* #9260 removes uses of Lean.RBMap in Lean itself.* #9263 fixes toISO8601String to produce a string that conforms to the\nISO 8601 format specification. The previous implementation separated the\nminutes and seconds fragments with a . instead of a : and included\ntimezone offsets without the hour and minute fragments separated by a\n:.* #9285 removes the unnecessary requirement of BEq α for\nArray.any_push, Array.any_push', Array.all_push, Array.all_push'\nas well as Vector.any_push and Vector.all_push.* #9301 adds a simp and a grind annotation on Zipper-related\ntheorems to improve reasoning about Std.Do invariants.* #9391 replaces the proof of the simplification lemma Nat.zero_mod\nwith\nrfl since it is, by design, a definitional equality. This solves an\nissue\nwhereby the lemma could not be used by the simplifier when in 'dsimp'\nmode.* #9441 fixes the behavior of String.prev, aligning the runtime\nimplementation with the reference implementation. In particular, the\nfollowing statements hold now:* (s.prev p).byteIdx is at least p.byteIdx - 4 and at most\np.byteIdx - 1* s.prev 0 = 0* s.prev is monotone* #9449 fix the behavior of String.next on the scalar boundary (2 ^ 63 - 1 on 64-bit platforms).* #9451 adds support in the mintro tactic for introducing let/have\nbinders in stateful targets, akin to intro. This is useful when\nspecifications introduce such let bindings.* #9454 introduces tactic mleave that leaves the SPred proof mode by\neta expanding through its abstractions and applying some mild\nsimplifications. This is useful to apply automation such as grind\nafterwards.* #9504 adds a few more *.by_wp \"adequacy theorems\" that allows to\nprove facts about programs in ReaderM and ExceptM using the Std.Do\nframework.* #9528 adds List.zipWithM and Array.zipWithM.* #9529 upstreams some helper instances for NameSet from Batteries.* #9538 adds two lemmas related to Iter.toArray.* #9577 adds lemmas about UIntX.toBitVec and UIntX.ofBitVec and ^.* #9586 adds componentwise algebraic operations on Vector α n, and\nrelevant instances.* #9594 optimizes Lean.Name.toString, giving a 10% instruction\nbenefit.* #9609 adds @[grind =] to Prod.lex_def. Note that omega has\nspecial handling for Prod.Lex, and this is needed for grind's cutsat\nmodule to achieve parity.* #9616 introduces checks to make sure that the IO functions produce\nerrors when inputs contain NUL bytes (instead of ignoring everything\nafter the first NUL byte).* #9620 adds the separate directions of\nList.pairwise_iff_forall_sublist as named lemmas.* #9621 renames Xor to XorOp, to match AndOp, etc.* #9622 adds a missing lemma about List.sum, and a grind annotation.* #9701 switches to a non-verloading local Std.Do.Triple notation in\nSpecLemmas.lean to work around a stage2 build failure.* #9721 tags more SInt and UInt lemmas with int_toBitVec so\nbv_decide\ncan handle casts between them and negation.* #9729 introduces a canonical way to endow a type with an order\nstructure. The basic operations (LE, LT, Min, Max, and in later\nPRs BEq, Ord, ...) and any higher-level property (a preorder, a\npartial order, a linear order etc.) are then put in relation to LE as\nnecessary. The PR provides IsLinearOrder instances for many core types\nand updates the signatures of some lemmas.* #9732 re-implements IO.waitAny using Lean instead of C++. This is to\nreduce the size and\ncomplexity of task_manager in order to ease future refactorings.* #9736 implements the option mvcgen +jp to employ a slightly lossy VC\nencoding for join points that prevents exponential VC blowup incurred by\nnaïve splitting on control flow.* #9739 removes the instance attribute from lexOrd that was\naccidentally applied in Std.Classes.Ord.Basic.* #9757 adds grind annotations for key Std.Do.SPred lemmas.* #9782 corrects the Inhabited instance of StdGen to use a valid\ninitial state for the pseudorandom number generator. Previously, the\ndefault generator had the property that Prod.snd (stdNext default) = default, so it would produce only constant sequences.* #9787 adds a simp lemma PostCond.const_apply.* #9792 adds @[expose] to two definitions with where clauses that\nBatteries proves theorems about.* #9799 fixes the #9410 issue.* #9805 improves the API for invariants and postconditions and as such\nintroduces a few breaking changes to the existing pre-release API around\nStd.Do. It also adds Markus Himmel's pairsSumToZero example as a\ntest case.* #9832 adds simp lemmas SPred.entails_<n> to replace\nSPred.entails_cons which was dysfunctional as a simp lemma due to\n#8074.* #9841 migrates the ⌜p⌝ notation for embedding pure p : Prop into\nSPred σs to expand into a simple, first-order expression SPred.pure p\nthat can be supported by E-matching in grind.* #9848 adds @[spec] lemmas for forIn and forIn' at Std.PRange.* #9850 adds a delaborator for Std.PRange notation.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.23.0 (2025-09-15)","header":"Library","id":"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Library"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Mvcgen-Invariants-Suggestions":{"contents":"#10456 and #10566\nimplement mvcgen invariants? to suggest concrete invariants\nbased on how invariants are used in VCs.\nThese suggestions are intentionally simplistic and boil down to \"this\nholds at the start of the loop and this must hold at the end of the\nloop\":\n\nimport Std.Tactic.Do\nopen Std Do\n\ndef mySum (l : List Nat) : Nat := Id.run do\n  let mut acc := 0\n  for x in l do\n    acc := acc + x\n  return acc\n\n/--\ninfo: Try this:\n  [apply] invariants\n  · ⇓⟨xs, letMuts⟩ => ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝\n-/\n#guard_msgs (info) in\ntheorem mySum_suggest_invariant (l : List Nat) : mySum l = l.sum := by\n  generalize h : mySum l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants?\n  all_goals admit\n\n\nWhen the loop body has an early return, it will helpfully suggest Invariant.withEarlyReturn ... as a skeleton:\n\nimport Std.Tactic.Do\nimport Std\n\nopen Std Do\n\ndef nodup (l : List Int) : Bool := Id.run do\n  let mut seen : HashSet Int := ∅\n  for x in l do\n    if x ∈ seen then\n      return false\n    seen := seen.insert x\n  return true\n\n/--\ninfo: Try this:\n  [apply] invariants\n  ·\n    Invariant.withEarlyReturn (onReturn := fun r letMuts => ⌜l.Nodup ∧ (r = true ↔ l.Nodup)⌝) (onContinue :=\n      fun xs letMuts => ⌜xs.prefix = [] ∧ letMuts = ∅ ∨ xs.suffix = [] ∧ l.Nodup⌝)\n-/\n-- #guard_msgs (info) in\ntheorem nodup_suggest_invariant (l : List Int) : nodup l ↔ l.Nodup := by\n  generalize h : nodup l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants?\n  all_goals admit\n\n\nIt still is the user's job to weaken this invariant such that it interpolates over all loop iterations,\nbut it is a good starting point for iterating. It is also useful because the user does not need to remember\nthe exact syntax.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Mvcgen Invariants Suggestions","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Mvcgen-Invariants-Suggestions"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-_LPAR_2026-01-24_RPAR_--Highlights--Error-Messages":{"contents":"This release contains a series of changes to error messages aimed at making them more helpful and actionable.\nSpecifically, some messages now have hints, suggestions, and links to explanations.\n\nPRs:\n#11119,\n#11245,\n#11346,\n#11347,\n#11456,\n#11482,\n#11518,\n#11554,\n#11555,\n#11621.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0 (2026-01-24)\u0009Highlights","header":"Error Messages","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-_LPAR_2026-01-24_RPAR_--Highlights--Error-Messages"}});