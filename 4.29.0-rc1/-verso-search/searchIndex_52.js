window.docContents[52].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Arithmetic--Roots":{"contents":"Computing the square root of a negative number yields NaN.\n\nComputes the square root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsqrt.\n\nComputes the square root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsqrtf.\n\nComputes the cube root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncbrt.\n\nComputes the cube root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncbrtf.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Arithmetic","header":"20.6.2.5.1. Roots","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Arithmetic--Roots"},"/Basic-Types/Integers/#int-syntax":{"contents":"\n\nThe OfNat Int instance allows numerals to be used as literals, both in expression and in pattern contexts.\n(OfNat.ofNat n : Int) reduces to the constructor application Int.ofNat n.\nThe Neg Int instance allows negation to be used as well.\n\n\n\nOn top of these instances, there is special syntax for the constructor Int.negSucc that is available when the Int namespace is opened.\nThe notation -[ n +1] is suggestive of -(n + 1), which is the meaning of Int.negSucc n.\n\nNegative Successor-[ n +1] is notation for Int.negSucc n.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers","header":"20.2.3. Syntax","id":"/Basic-Types/Integers/#int-syntax"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Byte-Position":{"contents":"Returns the character index that corresponds to the provided position (i.e. UTF-8 byte index) in a\nstring.If the position is at the end of the string, then the string's length in characters is returned. If\nthe position is invalid due to pointing at the middle of a UTF-8 byte sequence, then the character\nindex of the next character after the position is returned.Examples:* \"L∃∀N\".offsetOfPos ⟨0⟩ = 0* \"L∃∀N\".offsetOfPos ⟨1⟩ = 1* \"L∃∀N\".offsetOfPos ⟨2⟩ = 2* \"L∃∀N\".offsetOfPos ⟨4⟩ = 2* \"L∃∀N\".offsetOfPos ⟨5⟩ = 3* \"L∃∀N\".offsetOfPos ⟨50⟩ = 4\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"20.8.4.5.1. Byte Position","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Byte-Position"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates":{"contents":"The predicate transformer semantics of monadic programs is based on a logic in which propositions may mention the program's state.\nHere, “state” refers not only to mutable state, but also to read-only values such as those that are provided via ReaderT.\nDifferent monads have different state types available, but each individual state always has a type.\nGiven a list of state types, SPred is a type of predicates over these states.\n\nSPred is not inherently tied to the monadic verification framework.\nThe related Assertion computes a suitable SPred for a monad's state as expressed via its WP instance's PostShape output parameter.\n\nA predicate over states, where each state is defined by a list of component state types.Example:SPred [Nat, Bool] = (Nat → Bool → ULift Prop)\n\n\nOrdinary propositions that do not mention the state can be used as stateful predicates by adding a trivial universal quantification.\nThis is written with the syntax ⌜P⌝, which is syntactic sugar for SPred.pure.Notation for SPredEmbedding of pure Lean values into SVal. An alias for SPred.pure.\n\nA pure proposition P : Prop embedded into SPred.\nPrefer to use notation ⌜P⌝.\n\nStateful PredicatesThe predicate ItIsSecret expresses that a state of type String is \"secret\":def ItIsSecret : SPred [String] := fun s => ⌜s = \"secret\"⌝\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers","header":"17.2.1. Stateful Predicates","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates"},"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Tactics":{"contents":"* #11744 fixes a bug where lia was incorrectly solving goals involving\n  ordered types like Rat that it shouldn't handle. The lia tactic is\n  intended for linear integer arithmetic only.* #12152 adds simpArrowTelescope, a simproc that simplifies telescopes\n  of non-dependent arrows (p₁ → p₂ → ... → q) while avoiding quadratic\n  proof growth.* #12153 improves the simpArrowTelescope simproc that simplifies\n  non-dependent arrow telescopes: p₁ → p₂ → ... → q.* #12154 adds simpTelescope, a simproc that simplifies telescope\n  binders (have-expression values and arrow hypotheses) but not the\n  final body. This is useful for simplifying targets before introducing\n  hypotheses.* #12168 adds support for eta-reduction in SymM.* #12172 fixes how we determine whether a function parameter is an\n  instance.\n  Previously, we relied on binder annotations (e.g., [Ring A] vs {_ :\n  Ring A})\n  to make this determination. This is unreliable because users\n  legitimately use\n  {..} binders for class types when the instance is already available\n  from\n  context. For example:structure OrdSet (α : Type) [Hashable α] [BEq α] where\n  ...\n\ndef OrdSet.insert {_ : Hashable α} {_ : BEq α} (s : OrdSet α) (a : α) : OrdSet α :=\n  ...\nHere, Hashable and BEq are classes, but the {..} binder is intentional, the\n  instances come from OrdSet's parameters, so type class resolution is unnecessary.The fix checks the parameter's type using isClass? rather than its syntax, and\n  caches this information in FunInfo. This affects several subsystems:\n  discrimination trees, congruence lemma generation, and the grind canonicalizer.* #12176 fixes a bug where delayed E-match theorem instances could cause\n  uniqueId collisions in the instance tracking map.* #12195 ensures dsimp does not \"simplify\" instances by default. The\n  old behavior can be retrieved by usingset_option backward.dsimp.instances true\nApplying dsimp to instances creates non-standard instances, and this\n  creates all sorts of problems in Mathlib.\n  This modification is similar toset_option backward.dsimp.proofs true\n* #12205 adds mkBackwardRuleFromExpr to create backward rules from\n  expressions, complementing the existing mkBackwardRuleFromDecl which\n  only works with declaration names.* #12224 fixes a bug where grind? suggestions would not include\n  parameters using local variable dot notation (e.g.,\n  cs.getD_rightInvSeq where cs is a local variable). These parameters\n  were incorrectly filtered out because the code assumed all ident params\n  resolve to global declarations. In fact, local variable dot notation\n  produces anchors that need the original term to be loaded during replay,\n  so they must be preserved in the suggestion.* #12244 ensures simp does not \"simplify\" instances by default. The old\n  behavior can be retrieved by using simp +instances. is similar\n  to #12195, but for dsimp.\n  The backward compatibility flag for dsimp also deactivates this new\n  feature.* #12259 ensures we cache the result of unfold_definition definition in\n  the kernel type checker. We used to cache this information in a thread\n  local storage, but it was deleted during the Lean 3 to Lean 4\n  transition.* #12260 fixes a bug in the function instantiateRangeS' in the Sym\n  framework.* #12279 adds an experimental cbv tactic that can be invoked from\n  conv mode. The tactic is not suitable for production use and an\n  appropriate warning is displayed.* #12280 adds a benchmark based on Xavier Leroy's compiler verification\n  course to test call-by-value tactic.* #12287 fixes an issue where attribute [local simp] was incorrectly\n  rejected on a theorem from a private import* #12296 adds cbv_eval attribute that allows to evaluate functions in\n  cbv tactic using pre-registered theorems.* #12319 leverages the fact that expressions are type correct in grind\n  and the conclusion of extensionality theorems is of the form ?a = ?b.* #12345 adds two benchmarks (sieve of Eratosthenes, removing duplicates\n  from the list) and one test (a function with sublinear complexity\n  defined via well-founded recursion evaluated on large naturals with up\n  to 60 digits).* #12361 develops custom simprocs for dealing with ite/dite\n  expressions in cbv tactics, based on equivalent simprocs from\n  Sym.simp, with the difference that if the condition is not reduced to\n  True/False, we make use of the decidable instance and calculate to\n  what the condition reduces to.* #12370 fixes a proof construction bug in Sym.simp.* #12399 adds a custom simproc to handle Decidable.rec, where we force\n  the rewrite in the argument of the Decidable type, that normally is\n  not rewritten due to being a subsingleton.* #12406 implements two changes to LRAT checking in bv_decide:1. The LRAT trimmer previously used to drop delete instructions as we\n  did not act upon them in a meaningful way (as explained in 2). Now it\n  figures out the earliest point after which a clause may be deleted in\n  the trimmed LRAT proof and inserts a deletion there.2. The LRAT checker takes in an Array IntAction and explodes it into\n  an Array DefaultClauseAction before passing it into the checking loop.\n  DefaultClauseAction has a much larger memory footprint compared to\n  IntAction. Thus materializing the entire proof as\n  DefaultClauseAction upfront consumes a lot of memory. In the adapted\n  LRAT checker we take in an Array IntAction and only ever convert the\n  step we are currently working on to a DefaultClauseAction. In\n  combination with the fact that we now insert deletion instructions this\n  can drastically reduce memory consumption.* #12408 adds a user facing cbv tactic that can be used outside of the\n  conv mode.* #12411 adds a finishing decide_cbv tactic, which applies\n  of_decide_eq_true and then tries to discharge the remaining goal using\n  cbv.* #12415 improves the support for eta expanded terms in grind patterns.* #12417 refactors the main loop of the cbv tactic. Rather than using\n  multiple simprocs, a central pre simproc is introduced. Moreover, let\n  expressions are no longer immediately zeta-reduced due to performance on\n  one of the benchmarks (leroy.lean).* #12423 adds the attribute @[univ_out_params] for specifying which\n  universe levels should be treated as output parameters. By default, any\n  universe level that does not occur in any input parameter is considered\n  an output parameter.* #12467 adds a benchmark for cbv tactic for evaluating\n  Decidable.decide for a Decidable instance for a problem of checking\n  if a number is not a prime power.* #12473 fixes an assertion violation in grind reported at #12246 This\n  assertion fails when in examples containing heterogenous equalities with\n  elements of different types (e.g., Fin n and Fin m) attached to the\n  same theory solver.* #12474 fixes a panic in grind where sreifyCore? could encounter\n  power subterms not yet internalized in the E-graph during nested\n  propagation. The ring reifier (reifyCore?) already had a defensive\n  alreadyInternalized check before creating variables, but the semiring\n  reifier (sreifyCore?) was missing this guard. When propagatePower\n  decomposed a ^ (b₁ + b₂) into a^b₁ * a^b₂ and the resulting terms\n  triggered further propagation, the semiring reifier could be called on\n  subterms not yet in the E-graph, causing markTerm to fail.* #12475 fixes grind failing when hypotheses contain metavariables\n  (e.g., after refine). The root cause was that abstractMVars in\n  withProtectedMCtx only abstracted metavariables in the target, not in\n  hypotheses, creating a disconnect in grind's e-graph.* #12476 fixes #12245 where grind works on Fin n but fails on Fin (n\n  + 1).* #12477 fixes an internal grind error where mkEqProof is invoked\n  with terms of different types. When equivalence classes contain\n  heterogeneous equalities (e.g., 0 : Fin 3 and 0 : Fin 2 merged via\n  HEq), closeGoalWithValuesEq would call mkEqProof on terms with\n  incompatible types, triggering an internal error.* #12480 skips the relabeling step during AIG to CNF conversion, reducing\n  memory pressure.* #12483 adds support for higher-order Miller patterns in grind's\n  e-matching engine.* #12486 caches isDefEqI results in Sym. During symbolic computation\n  (e.g., VC generators), we find the same instances over and over again.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.29.0-rc1 (2026-02-17)","header":"Tactics","id":"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Tactics"},"/the-index/#The-Lean-Language-Reference--Index":{"contents":"\n\n","context":"Lean Reference","header":"Index","id":"/the-index/#The-Lean-Language-Reference--Index"}});