window.docContents[177].resolve({"/Basic-Types/Lazy-Computations/#Thunk":{"contents":"A thunk delays the computation of a value.\nIn particular, the Thunk type is used to delay the computation of a value in compiled code until it is explicitly requested—this request is called forcing the thunk.\nThe computed value is saved, so subsequent requests do not result in recomputation.\nComputing values at most once, when explicitly requested, is called lazy evaluation.\nThis caching is invisible to Lean's logic, in which Thunk is equivalent to a function from Unit.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.21. Lazy Computations","id":"/Basic-Types/Lazy-Computations/#Thunk"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key a or a key that is equal to a according\nto the comparator cmp. There is also a Prop-valued version\nof this: a ∈ t is equivalent to t.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for equality checks, while for tree maps, both use the given comparator cmp.\n\nGiven a proof that a mapping for the given key is present, retrieves the mapping for the given key.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, panicking if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning none if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\nReturns a list of all keys present in the tree map in ascending  order.\n\nReturns an array of all keys present in the tree map in ascending  order.\n\nReturns a list of all values present in the tree map in ascending  order.\n\nReturns an array of all values present in the tree map in ascending  order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"20.19.9.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Queries"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-02-17_RPAR_--Lake":{"contents":"* #11683 fixes an inconsistency in the way Lake and Lean view the\n  transitivity of a meta import. Lake now works as Lean expects and\n  includes the meta segment of all transitive imports of a meta import\n  in its transitive trace.* #11859 removes the need to write .ofNat for numeric options in\n  lakefile.lean. Note that lake translate-config incorrectly assumed\n  this was already legal in earlier revisions.* #11921 adds lake shake as a built-in Lake command, moving the shake\n  functionality from script/Shake.lean into the Lake CLI.* #12034 changes the default of enableArtifactCache to use the\n  workspace's enableArtifactCache setting if the package is a dependency\n  and LAKE_ARTIFACT_CACHE is not set. This means that dependencies of a\n  project with enableArtifactCache set will also, by default, use Lake's\n  local artifact cache.* #12037 fixes two Lake cache issues: a bug where a failed upload would\n  not produce an error and a mistake in the --wfail checks of the cache\n  commands.* #12076 adds additional debugging information to a run of lake build\n  --no-build via a .nobuild trace file. When a build fails due to\n  needing a rebuild, Lake emits the new expected trace next as .nobuild\n  file next to the build's old .trace. The inputs recorded in these\n  files can then be compared to debug what caused the mismatch.* #12086 fixes a bug where a lake build --no-build would exit with code\n  3 if the optional job to fetch a GitHub or Reservoir release for a\n  package failed (even if nothing else needed rebuilding).* #12105 fixes the lake query output for targets which produce an\n  Array or List of a value with a custom QueryText or QueryJson\n  instance (e.g., deps and transDeps).* #12112 revives the ability to specify modules in dependencies via the\n  basic +mod target key.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0 (2026-02-17)","header":"Lake","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-02-17_RPAR_--Lake"}});