window.docContents[146].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Modification":{"contents":"Inserts the given element into the set. If the hash set already contains an element that is\nequal (with regard to ==) to the given element, then the hash set is returned unchanged.Note: this non-replacement behavior is true for ExtHashSet and ExtHashSet.Raw.\nThe insert function on ExtHashMap, DExtHashMap, ExtHashMap.Raw and DExtHashMap.Raw behaves\ndifferently: it will overwrite an existing mapping.\n\nInserts multiple mappings into the hash set by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the first occurrence takes precedence.Note: this precedence behavior is true for ExtHashSet and ExtHashSet.Raw. The insertMany function on\nExtHashMap, DExtHashMap, ExtHashMap.Raw and DExtHashMap.Raw behaves differently: it will prefer the last\nappearance.\n\nRemoves the element if it exists.\n\nRemoves all elements from the hash set for which the given function returns false.\n\nChecks whether an element is present in a set and inserts the element if it was not found.\nIf the hash set already contains an element that is equal (with regard to ==) to the given\nelement, then the hash set is returned unchanged.Equivalent to (but potentially faster than) calling contains followed by insert.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Sets","header":"20.19.7.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Modification"},"/Notations-and-Macros/Macros/#quote-patterns":{"contents":"See AlsoNew syntax is defined using syntax extensions.\n\nQuasiquotations can be used in pattern matching to recognize syntax that matches a template.\nJust as antiquotations in a quotation that's used as a term are regions that are treated as ordinary non-quoted expressions, antiquotations in patterns are regions that are treated as ordinary Lean patterns.\nQuote patterns are compiled differently from other patterns, so they can't be intermixed with non-quote patterns in a single match expression.\nLike ordinary quotations, quote patterns are first processed by Lean's parser.\nThe parser's output is then compiled into code that determines whether there is a match.\nSyntax matching assumes that the syntax being matched was produced by Lean's parser, either via quotation or directly in user code, and uses this to omit some checks.\nFor example, if nothing but a particular keyword can be present in a given position, the check may be omitted.\n\nSyntax matches a quote pattern in the following cases:\n\n Atoms\n\nKeyword atoms (such as if or match) result in singleton nodes whose kind is token. followed by the atom.\n  In many cases, it is not necessary to check for specific atom values because the grammar allows only a single keyword, and no checking will be performed.\n  If the syntax of the term being matched requires the check, then the node kind is compared.Literals, such as string or numeric literals, are compared via their underlying string representation.\n  The pattern `(0x15) and the quotation `(21) do not match.\n\n Nodes\n\nIf both the pattern and the value being matched represent Syntax.node, there is a match when both have the same syntax kind, the same number of children, and each child pattern matches the corresponding child value.\n\n Identifiers\n\nIf both the pattern and the value being matched are identifiers, then their literal Name values are compared for equality modulo macro scopes.\n  Identifiers that “look” the same match, and it does not matter if they refer to the same binding.\n  This design choice allows quote pattern matching to be used in contexts that don't have access to a compile-time environment in which names can be compared by reference.\n\n\n\nBecause quotation pattern matching is based on the node kinds emitted by the parser, quotations that look identical may not match if they come from different syntax categories.\nIf in doubt, including the syntax category in the quotation can help.\n\nVariables bound by syntax pattern matches are of type TSyntax k, where k describes the potential syntax kinds.\nVariables in repetitions are of type TSyntaxArray k, or TSepArray k sep if the repetition is separated with the string sep.\nTSyntax is described in more detail in the section on typed syntax.\n\nSyntax Pattern MatchingList comprehensions are a notation for writing lists that is inspired by standard set builder notation.\nA list comprehension consists of square brackets that contain a result term followed by some nubmer of qualifiers; each qualifier either introduces a variable from some other list or imposes a condition that must be satisfied.\nQualifiers are nested: each new variable's value is evaluated for every prior value.syntax qbind := ident \"←\" term\n\nsyntax qpred := term\n\nsyntax qualifier := atomic(qbind) <|> qpred\n\nsyntax \"[\" term \"|\" qualifier,* \"]\" : term\nList comprehensions can be desugared to a sequence of calls to List.flatMap.\nVariable introductions are translated to a flatMap on the variable's value expression, while predicates are translated to a conditional that returns one or zero values if the predicate is true or false.\nThe body of the final flatMap is the result term.This desugaring can be implemented as a macro that uses quasiquotation patterns:macro_rules\n  | `(term|[$e | $qs,* ]) => do\n    let init ← `([$e])\n    qs.getElems.foldrM (β := Term) (init := init) fun\n      | `(qualifier|$x ← $e'), r =>\n        `(($e' : List _) |>.flatMap fun $x => $r)\n      | `(qualifier|$e':term), r =>\n        `((if $e' then [()] else []) |>.flatMap fun () => $r)\n      | other, _ =>\n        Macro.throwErrorAt other \"Unknown qualifier\"\nInitially, the sequence of qualifiers has type TSepArray `qualifier \",\", indicating that it represents a comma-separated sequence of qualifiers.\nTSepArray.getElems transforms it into a TSyntaxArray `qualifier, which is an abbreviation for Array (TSyntax `qualifier).\nThis allows generalized field notation to be used to call Array.foldrM.\nThe term annotation in the branch for predicates is required to prevent the matched value from having syntax kind `qualifier; one node must be unwrapped from the value.List comprehensions behave as expected:#eval [ s!\"{x}; {y}\" |\n  x ← (1...5).toList,\n  x % 2 = 0,\n  y ← [true, false]\n]\n[\"2; true\", \"2; false\", \"4; true\", \"4; false\"]\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros","header":"23.5.4. Matching Syntax","id":"/Notations-and-Macros/Macros/#quote-patterns"},"/Type-Classes/Instance-Synthesis/#instance-synth-parameters":{"contents":"The search process for instances is largely governed by class parameters.\nType classes take a certain number of parameters, and instances are tried during the search when their choice of parameters is compatible with those in the class type for which the instance is being synthesized.\n\nInstances themselves may also take parameters, but the role of instances' parameters in instance synthesis is very different.\nInstances' parameters represent either variables that may be instantiated by instance synthesis or further synthesis work to be done before the instance can be used.\nIn particular, parameters to instances may be explicit, implicit, or instance-implicit.\nIf they are instance implicit, then they induce further recursive instance searching, while explicit or implicit parameters must be solved by unification.\n\nImplicit and Explicit Parameters to InstancesWhile instances typically take parameters either implicitly or instance-implicitly, explicit parameters may be filled out as if they were implicit during instance synthesis.\nIn this example, aNonemptySumInstance is found by synthesis, applied explicitly to Nat, which is needed to make it type-correct.instance aNonemptySumInstance\n    (α : Type) {β : Type} [inst : Nonempty α] :\n    Nonempty (α ⊕ β) :=\n  let ⟨x⟩ := inst\n  ⟨.inl x⟩\nset_option pp.explicit true in\n#synth Nonempty (Nat ⊕ Empty)\nIn the output, both the explicit argument Nat and the implicit argument Empty were found by unification with the search goal, while the Nonempty Nat instance was found via recursive instance synthesis.@aNonemptySumInstance Nat Empty (@instNonemptyOfInhabited Nat instInhabitedNat)\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"10.3.4. Instance Parameters and Synthesis","id":"/Type-Classes/Instance-Synthesis/#instance-synth-parameters"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-_LPAR_2026-01-24_RPAR_--Highlights--New-Features-in-Grind--Supplying-Arbitrary-Parameters":{"contents":"#11268 implements support for arbitrary grind parameters. The feature\nis similar to the one available in simp, where a proof term is treated\nas a local universe-polymorphic lemma. This feature relies on grind -revert (see #11248).\nFor example, users can now write:\n\ndef snd (p : α × β) : β := p.2\ntheorem snd_eq (a : α) (b : β) : snd (a, b) = b := rfl\n\n/--\ntrace: [grind.ematch.instance] snd_eq (a + 1): snd (a + 1, Type) = Type\n[grind.ematch.instance] snd_eq (a + 1): snd (a + 1, true) = true\n-/\n#guard_msgs (trace) in\nset_option trace.grind.ematch.instance true in\nexample (a : Nat) :\n    (snd (a + 1, true), snd (a + 1, Type), snd (2, 2)) =\n    (true, Type, snd (2, 2)) := by\n  grind [snd_eq (a + 1)]\n\n\nNote that in the example above, snd_eq is instantiated only twice, but with different universe parameters.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0 (2026-01-24)\u0009Highlights\u0009New Features in Grind","header":"Supplying Arbitrary Parameters","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-_LPAR_2026-01-24_RPAR_--Highlights--New-Features-in-Grind--Supplying-Arbitrary-Parameters"}});