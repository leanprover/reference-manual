window.docContents[141].resolve({"/Basic-Types/Natural-Numbers/#nat-api-deceq":{"contents":"A decision procedure for equality of natural numbers, usually accessed via the DecidableEq Nat\ninstance.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.Examples:* Nat.decEq 5 5 = isTrue rfl* (if 3 = 4 then \"yes\" else \"no\") = \"no\"* show 12 = 12 by decide\n\nA decision procedure for non-strict inequality of natural numbers, usually accessed via the\nDecidableLE Nat instance.Examples:* (if 3 ≤ 4 then \"yes\" else \"no\") = \"yes\"* (if 6 ≤ 4 then \"yes\" else \"no\") = \"no\"* show 12 ≤ 12 by decide* show 5 ≤ 12 by decide\n\nA decision procedure for strict inequality of natural numbers, usually accessed via the\nDecidableLT Nat instance.Examples:* (if 3 < 4 then \"yes\" else \"no\") = \"yes\"* (if 4 < 4 then \"yes\" else \"no\") = \"no\"* (if 6 < 4 then \"yes\" else \"no\") = \"no\"* show 5 < 12 by decide\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Comparisons","header":"20.1.4.5.2. Decidable Equality","id":"/Basic-Types/Natural-Numbers/#nat-api-deceq"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Packages":{"contents":"Package ConfigurationThere can only be one package declaration per Lake configuration file.\nThe defined package configuration will be available for reference as _package.\n\nPost-Update HooksDeclare a post-lake update hook for the package.\nRuns the monadic action is after a successful lake update execution\nin this package or one of its downstream dependents.ExampleThis feature enables Mathlib to synchronize the Lean toolchain and run\ncache get after a lake update:lean_exe cache\npost_update pkg do\n  let wsToolchainFile := (← getRootPackage).dir / \"lean-toolchain\"\n  let mathlibToolchain ← IO.FS.readFile <| pkg.dir / \"lean-toolchain\"\n  IO.FS.writeFile wsToolchainFile mathlibToolchain\n  let exeFile ← runBuild cache.fetch\n  let exitCode ← env exeFile.toString #[\"get\"]\n  if exitCode ≠ 0 then\n    error s!\"{pkg.name}: failed to fetch cache\"\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"24.1.3.2.2. Packages","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Packages"},"/Interacting-with-Lean/#hash-print":{"contents":"The #print family of commands are used to query Lean for information about definitions.\n\nPrinting DefinitionsPrints the definition of a constant.\n\nPrinting a definition with #print prints the definition as a term.\nTheorems that were proved using tactics may be very large when printed as terms.\n\nPrinting StringsAdds the string literal to Lean's message log.\n\nPrinting AxiomsLists all axioms that the constant transitively relies on. See the documentation for axioms for more information.\n\nPrinting AxiomsThese two functions each swap the elements in a pair of bitvectors:def swap (x y : BitVec 32) : BitVec 32 × BitVec 32 :=\n  (y, x)\n\ndef swap' (x y : BitVec 32) : BitVec 32 × BitVec 32 :=\n  let x := x ^^^ y\n  let y := x ^^^ y\n  let x := x ^^^ y\n  (x, y)\nThey can be proven equal using function extensionality, the simplifier, and bv_decide:theorem swap_eq_swap' : swap = swap' := by\n  funext x y\n  simp only [swap, swap', Prod.mk.injEq]\n  bv_decide\nThe resulting proof makes use of a number of axioms:#print axioms swap_eq_swap'\n'swap_eq_swap'' depends on axioms: [propext, Classical.choice, Quot.sound, swap_eq_swap'._native.bv_decide.ax_3]\nThe axiom swap_eq_swap'._native.bv_decide.ax_3 was generated by bv_decide, showing that native code was used to translate an external proof certificate into a Lean proof term.\n\nPrinting EquationsThe command #print equations, which can be abbreviated #print eqns, displays the equational lemmas for a function.\n\nPrinting Equationsdef intersperse (x : α) : List α → List α\n  | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n  | xs => xs\n\n#print equations intersperse\nequations:\n@[defeq] theorem intersperse.eq_1.{u_1} : ∀ {α : Type u_1} (x y z : α) (zs : List α),\n  intersperse x (y :: z :: zs) = y :: x :: intersperse x (z :: zs)\ntheorem intersperse.eq_2.{u_1} : ∀ {α : Type u_1} (x : α) (x_1 : List α),\n  (∀ (y z : α) (zs : List α), x_1 = y :: z :: zs → False) → intersperse x x_1 = x_1\nIt does not print the defining equation, nor the unfolding equation:#check intersperse.eq_def\nintersperse.eq_def.{u_1} {α : Type u_1} (x : α) (x✝ : List α) :\n  intersperse x x✝ =\n    match x✝ with\n    | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n    | xs => xs\n#check intersperse.eq_unfold\nintersperse.eq_unfold.{u_1} :\n  @intersperse = fun {α} x x_1 =>\n    match x_1 with\n    | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n    | xs => xs\n\n\nScope Information#where gives a description of the state of the current scope scope.\nThis includes the current namespace, open namespaces, universe and variable commands,\nand options set with set_option.\n\nScope InformationThe #where command displays all the modifications made to the current section scope, both in the current scope and in the scopes in which it is nested.section\nopen Nat\n\nnamespace A\nvariable (n : Nat)\nnamespace B\n\nopen List\nset_option pp.funBinderTypes true\n\n#where\n\nend A.B\nend\nnamespace A.B\n\nopen Nat List\n\nvariable (n : Nat)\n\nset_option pp.funBinderTypes true\n\n\nChecking the Lean VersionShows the current Lean version. Prints Lean.versionString.\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.5. Querying the Context","id":"/Interacting-with-Lean/#hash-print"},"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Language":{"contents":"* #11963 activates getElem?_pos more aggressively, triggered by c[i].* #12028 gives a simpler semantics to noncomputable, improving\n  predictability as well as preparing codegen to be moved into a separate\n  build step without breaking immediate generation of error messages.* #12110 fixes a SIGFPE crash on x86_64 when evaluating (ISize.minValue\n  / -1 : ISize), filling an omission from #11624.* #12159 makes Std.Do's post macro universe polymorphic by expanding to\n  PUnit.unit instead of ().* #12160 removes calls to check that we expect to pass under normal\n  circumstances. This may be re-added later guarded by a debug option.* #12164 uses the .inj theorem in the proof of one direction of the\n  .injEq theorem.* #12179 ensures isDefEq does not increase the transparency mode to\n  .default when checking whether implicit arguments are definitionally\n  equal. The previous behavior was creating scalability problems in\n  Mathlib. That said, this is a very disruptive change. The previous\n  behavior can be restored using the commandset_option backward.isDefEq.respectTransparency false\n* #12184 ensures that the mspec tactic does not assign synthetic opaque\n  MVars occurring in the goal, just like the apply tactic.* #12190 adds the introSubstEq MetaM tactic, as an optimization over\n  intro h; subst h that avoids introducing h : a = b if it can be\n  avoided,\n  which is the case when b can be reverted without reverting anything\n  else. Speeds up the generation of injEq theorem.* #12217 implements RFC #12216: native computation (native_decide,\n  bv_decide) is represented in the logic as one axiom per computation,\n  asserting the equality that was obtained from the native computation.\n  #print axiom will no longer show Lean.trustCompiler, but rather the\n  auto-generated names of these axioms (with, for example,\n  ._native.bv_decide. in the name). See the RFC for more information.* #12219 fixes a unification issue that appeared in\n  Lean.Meta.MkIffOfInductiveProp machinery that was upstreamed from\n  Mathlib. Inside of toInductive, wrong free variables were passed,\n  which made it impossible to perform a unification in certain cases.* #12236 adds orElse combinator to simprocs of Sym.Simp.* #12243 fixes #12240, where deriving Ord failed with Unknown\n  identifier a✝.* #12247 adds the new transparency setting @[instance_reducible]. We\n  used to check whether a declaration had instance reducibility by using\n  the isInstance predicate. However, this was not a robust solution\n  because:* We have scoped instances, and isInstance returns true only if the\n  scope is active.* #12263 implements the second part of #12247.* #12269 refines upon #12106, by setting the isRecursive env extension\n  after adding the declaration, but before processing attributes like\n  macro_inline that want to look at the flag. Fixes #12268.* #12283 introduces cbv_opaque attribute that allows one to mark\n  definitions not to be unfolded by the cbv tactic.* #12285 implements a cache for the positions of class universe level\n  parameters that only appear in output parameter types.* #12286 ensures the type resolution cache properly caches results for\n  type classe containing output parameters.* #12324 adds a default Inhabited instance to Theorem type.* #12329 adds the option doc.verso.module. If set, it controls whether\n  module docstrings use Verso syntax. If not set, it defaults to the value\n  of the doc.verso option.* #12338 implements preparatory work for #12179. It implements a new\n  feature in isDefEq to ensure it does not increase the transparency\n  level to .default when checking definitionally equality of implicit\n  arguments. This transparency level bump was introduced in Lean 3, but it\n  is not a performance issue and is affecting Mathlib. adds the\n  new feature, but it is disabled by default.* #12339 fixes a diamond problem in delta deriving where\n  instance-implicit class parameters in the derived instance type were\n  using instances synthesized for the underlying type, not the alias type.* #12340 implements better support for unfolding class fields marked as\n  reducible. For example, we want to mark fields that are types such asMonadControlT.stM : Type u -> Type u\nThe motivation is similar to our heuristic that type definitions should\n  be abbreviations.\n  Now, suppose we want to unfold stM m (ExceptT ε m) α using the\n  .reducible transparency setting, we want the result to be stM m m\n  (MonadControl.stM m (ExceptT ε m) α) instead of\n  (instMonadControlTOfMonadControl m m (ExceptT ε m)).1 α. The latter\n  would defeat the intent of marking the field as reducible, since the\n  instance instMonadControlTOfMonadControl is [instance_reducible] and\n  the resulting term would be stuck when using .reducible transparency\n  mode.* #12353 ressurects the dead trace class Elab.resume by redirecting the\n  non-existant Elab.resuming to it.* #12355 adds isBoolTrueExpr and isBoolFalseExpr functions to SymM* #12391 makes simpCond public. It is needed to avoid code duplication\n  in #12361* #12395 adds mvcgen support for specifications in the local context.\n  Example:import Std.Tactic.Do\n\nopen Std.Do\n\nset_option mvcgen.warning false\n\ndef foo (x : Id Nat → Id Nat) : Id Nat := do\n  let r₁ ← x (pure 42)\n  let r₂ ← x (pure 26)\n  pure (r₁ + r₂)\n\ntheorem foo_spec\n    (x : Id Nat → Id Nat)\n    (x_spec : ∀ (k : Id Nat) (_ : ⦃⌜True⌝⦄ k ⦃⇓r => ⌜r % 2 = 0⌝⦄), ⦃⌜True⌝⦄ x k ⦃⇓r => ⌜r % 2 = 0⌝⦄) :\n    ⦃⌜True⌝⦄ foo x ⦃⇓r => ⌜r % 2 = 0⌝⦄ := by\n  mvcgen [foo, x_spec] <;> grind\n\ndef bar (k : Id Nat) : Id Nat := do\n  let r ← k\n  if r > 30 then return 12 else return r\n\nexample : ⦃⌜True⌝⦄ foo bar ⦃⇓r => ⌜r % 2 = 0⌝⦄ := by\n  mvcgen [foo_spec, bar]\n* #12407 is similar to #12403.* #12416 makes Sym.Simp.toBetaApp public. This is necessary for the\n  refactor of the main cbv simproc in #12417.* #12425 fixes a bug in mvcgen caused by incomplete match splitting.* #12427 makes mvcgen suggest to use -trivial when doing so avoids a\n  recursion depth error.* #12429 sets the irreducible attribute before generating the equations\n  for recursive definitions. This prevents these equations to be marked as\n  defeq, which could lead to simp generation proofs that do not type\n  check at default transparency.* #12460 fixes an AppBuilder exception in the cbv tactic when\n  simplifying projections whose projection function is dependent (closes\n  #12457).* #12507 fixes #12495 where equational theorem generation fails for\n  structurally recursive definitions using a Box-like wrapper around\n  nested inductives.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.29.0-rc1 (2026-02-17)","header":"Language","id":"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Language"}});