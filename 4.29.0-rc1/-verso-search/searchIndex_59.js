window.docContents[59].resolve({"/Basic-Types/Strings/#string-api-pos":{"contents":"A byte position in a String, according to its UTF-8 encoding.Character positions (counting the Unicode code points rather than bytes) are represented by plain\nNats. Indexing a String by a String.Pos.Raw takes constant time, while character positions need to\nbe translated internally to byte positions, which takes linear time.A byte position p is valid for a string s if 0 ≤ p ≤ s.rawEndPos and p lies on a UTF-8\ncharacter boundary, see String.Pos.IsValid.There is another type, String.Pos, which bundles the validity predicate. Using String.Pos\ninstead of String.Pos.Raw is recommended because it will lead to less error handling and fewer edge cases.Get the underlying byte index of a String.Pos.Raw\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"20.8.4.5. Raw Positions","id":"/Basic-Types/Strings/#string-api-pos"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers--Weakest-Preconditions":{"contents":"The weakest precondition semantics of a monad are provided by the WP type class.\nInstances of WP determine the monad's postcondition shape and provide the logical rules for interpreting the monad's operations as a predicate transformer in its postcondition shape.\n\nA weakest precondition interpretation of a monadic program x : m α in terms of a predicate\ntransformer PredTrans ps α. The monad m determines ps : PostShape.For practical reasoning, an instance of WPMonad m ps is typically needed in addition to WP m ps.Interpret a monadic program x : m α in terms of a predicate transformer PredTrans ps α.\n\nWeakest Preconditionswp⟦x⟧ Q is defined as (WP.wp x).apply Q.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Predicate Transformers","header":"17.2.3.1. Weakest Preconditions","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers--Weakest-Preconditions"},"/The--mvcgen--tactic/Predicate-Transformers/#mvcgen-adequacy":{"contents":"Monads that can be invoked from pure code typically provide a invocation operator that takes any required input state as a parameter and returns either a value paired with an output state or some kind of exceptional value.\nExamples include StateT.run, ExceptT.run, and Id.run.\nAdequacy lemmas provide a bridge between statements about invocations of monadic programs and those programs' weakest precondition semantics as given by their WP instances.\nThey show that a property about the invocation is true if its weakest precondition is true.\n\nAdequacy lemma for Id.run.\nUseful if you want to prove a property about an expression x defined as Id.run prog and you\nwant to use mvcgen to reason about prog.\n\nAdequacy lemma for StateM.run.\nUseful if you want to prove a property about an expression x defined as StateM.run prog s and\nyou want to use mvcgen to reason about prog.\n\nAdequacy lemma for StateM.run'.\nUseful if you want to prove a property about an expression x defined as StateM.run' prog s and\nyou want to use mvcgen to reason about prog.\n\nAdequacy lemma for ReaderM.run.\nUseful if you want to prove a property about an expression x defined as ReaderM.run prog r and\nyou want to use mvcgen to reason about prog.\n\nAdequacy lemma for Except.\nUseful if you want to prove a property about a complex expression prog : Except ε α that you have\ngeneralized to a variable x and you want to use mvcgen to reason about prog.\n\nAdequacy lemma for EStateM.run.\nUseful if you want to prove a property about an expression x defined as EStateM.run prog s and\nyou want to use mvcgen to reason about prog.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Predicate Transformers","header":"17.2.3.3. Adequacy Lemmas","id":"/The--mvcgen--tactic/Predicate-Transformers/#mvcgen-adequacy"}});