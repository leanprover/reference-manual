window.docContents[61].resolve({"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values","header":"20.12.2. API Reference","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Reasoning":{"contents":"An optional arbitrary element of a given type.If α is non-empty, then there exists some v : α and this arbitrary element is some v.\nOtherwise, it is none.\n\nGiven an optional value and a function that can be applied when the value is some, returns the\nresult of applying the function if this is possible.The function f is partial because it is only defined for the values a : α such that\no = some a. This restriction allows the function to use the fact that it can only be called when\no is not none: it can relate its argument to the optional value o. Its runtime behavior is\nequivalent to that of Option.bind.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pbind fun x h => some ⟨x, h⟩\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\nGiven an optional value and a function that can be applied when the value is some, returns the\nresult of applying the function if this is possible, or a fallback value otherwise.The function f is partial because it is only defined for the values a : α such that\no = some a. This restriction allows the function to use the fact that it can only be called when\no is not none: it can relate its argument to the optional value o. Its runtime behavior is\nequivalent to that of Option.elim.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pelim none fun x h => some ⟨x, h⟩\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\nGiven a function from the elements of α that satisfy p to β and a proof that an optional value\nsatisfies p if it's present, applies the function to the value.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pmap (fun a (h : a ∈ v) => ⟨_, h⟩) (fun _ h => h)\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"20.12.2.7. Reasoning","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Reasoning"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Adjustment":{"contents":"Returns the position in a string before a specified position, p. If p = ⟨0⟩, returns 0. If p\nis greater than rawEndPos, returns the position one byte before p. Otherwise, if p occurs in the\nmiddle of a multi-byte character, returns the beginning position of that character.For example, \"L∃∀N\".prev ⟨3⟩ is ⟨1⟩, since byte 3 occurs in the middle of the multi-byte\ncharacter '∃' that starts at byte 1.This is a legacy function. The recommended alternative is String.Pos.prev or one of its\nvariants like String.Pos.prev?, combined with String.pos or another means of obtaining\na String.Pos.Examples:* \"abc\".get (\"abc\".rawEndPos |> \"abc\".prev) = 'c'* \"L∃∀N\".get (\"L∃∀N\".rawEndPos |> \"L∃∀N\".prev |> \"L∃∀N\".prev |> \"L∃∀N\".prev) = '∃'\n\nReturns the next position in a string after position p. If p is not a valid position or\np = s.endPos, returns the position one byte after p.A run-time bounds check is performed to determine whether p is at the end of the string. If a\nbounds check has already been performed, use String.next' to avoid a repeated check.This is a legacy function. The recommended alternative is String.Pos.next or one of its\nvariants like String.Pos.next?, combined with String.pos or another means of obtaining\na String.ValisPos.Some examples of edge cases:* \"abc\".next ⟨3⟩ = ⟨4⟩, since 3 = \"abc\".endPos* \"L∃∀N\".next ⟨2⟩ = ⟨3⟩, since 2 points into the middle of a multi-byte UTF-8 characterExamples:* \"abc\".get (\"abc\".next 0) = 'b'* \"L∃∀N\".get (0 |> \"L∃∀N\".next |> \"L∃∀N\".next) = '∀'\n\nReturns the next position in a string after position p. The result is unspecified if p is not a\nvalid position.Requires evidence, h, that p is within bounds. No run-time bounds check is performed, as in\nString.next.A typical pattern combines String.next' with a dependent if-expression to avoid the overhead of\nan additional bounds check. For example:def next? (s : String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else s.get (s.next' p h)\nThis is a legacy function. The recommended alternative is String.Pos.next, combined with\nString.pos or another means of obtaining a String.Pos.Example:* let abc := \"abc\"; abc.get (abc.next' 0 (by decide)) = 'b'\n\nRepeatedly increments a position in a string, as if by String.Pos.Raw.next, while the predicate\np returns false for the character at the position. Stops incrementing at the end of\nthe string or when p returns true for the current character.Examples:* let s := \"   a  \"; (Pos.Raw.nextUntil s Char.isWhitespace 0).get s = ' '* let s := \"   a  \"; (Pos.Raw.nextUntil s Char.isAlpha 0).get s = 'a'* let s := \"a  \"; (Pos.Raw.nextUntil s Char.isWhitespace 0).get s = ' '\n\nRepeatedly increments a position in a string, as if by String.Pos.Raw.next, while the\npredicate p returns true for the character at the position. Stops incrementing at\nthe end of the string or when p returns false for the current character.Examples:* let s := \"   a  \"; ((0 : Pos.Raw).nextWhile s Char.isWhitespace).get s = 'a'* let s := \"a  \"; ((0 : Pos.Raw).nextWhile s Char.isWhitespace).get s = 'a'* let s := \"ba  \"; (Pos.Raw.nextWhile s Char.isWhitespace 0).get s = 'b'\n\nIncreases the byte offset of the position by 1. Not to be confused with Pos.next.\n\nAdvances p by n bytes. This is not an HAdd instance because it should be a relatively\nrare operation, so we use a name to make accidental use less likely. To add the size of a\ncharacter c or string s to a raw position p, you can use p + c resp. p + s.This should be seen as an \"advance\" or \"skip\".See also Pos.Raw.offsetBy, which turns relative positions into absolute positions.\n\nOffsets p by offset on the left. This is not an HAdd instance because it should be a\nrelatively rare operation, so we use a name to make accidental use less likely. To offset a position\nby the size of a character character c or string s, you can use c + p resp. s + p.This should be seen as an operation that converts relative positions into absolute positions.See also Pos.Raw.increaseBy, which is an \"advancing\" operation.\n\nDecreases the byte offset of the position by 1. Not to be confused with Pos.prev.\n\nMove the position p back by n bytes. This is not an HSub instance because it should be a\nrelatively rare operation, so we use a name to make accidental use less likely. To remove the size\nof a character c or string s from a raw position p, you can use p - c resp. p - s.This should be seen as the inverse of an \"advance\" or \"skip\".See also Pos.Raw.unoffsetBy, which turns absolute positions into relative positions.\n\nDecreases p by offset. This is not an HSub instance because it should be a relatively\nrare operation, so we use a name to make accidental use less likely. To unoffset a position\nby the size of a character c or string s, you can use p - c resp. p - s.This should be seen as an operation that converts absolute positions into relative positions.See also Pos.Raw.decreaseBy, which is an \"unadvancing\" operation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"20.8.4.5.5. Adjustment","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Adjustment"},"/IO/Timing/#io-timing":{"contents":"Pauses execution for the specified number of milliseconds.\n\nMonotonically increasing time since an unspecified past point in nanoseconds. There is no relation\nto wall clock time.\n\nMonotonically increasing time since an unspecified past point in milliseconds. There is no relation\nto wall clock time.\n\nReturns the number of heartbeats that have occurred during the current thread's execution. The\nheartbeat count is the number of \"small\" memory allocations performed in a thread.Heartbeats used to implement timeouts that are more deterministic across different hardware.\n\nAdjusts the heartbeat counter of the current thread by the given amount. This can be useful to give\nallocation-avoiding code additional “weight” and is also used to adjust the counter after resuming\nfrom a snapshot.Heartbeats are a means of implementing “deterministic” timeouts. The heartbeat counter is the number\nof “small” memory allocations performed on the current execution thread.\n\n","context":"Lean Reference\u0009IO","header":"21.8. Timing","id":"/IO/Timing/#io-timing"},"/Iterators/Reasoning-About-Iterators/#The-Lean-Language-Reference--Iterators--Reasoning-About-Iterators--Reasoning-About-Consumers":{"contents":"The iterator library provides a large number of useful lemmas.\nMost theorems about finite iterators can be proven by rewriting the statement to one about lists, using the fact that the correspondence between iterator combinators and corresponding list operations has already been proved.\nIn practice, many of these theorems are already registered as simp lemmas.\n\nThe lemmas have a very predictable naming system, and many are in the default simp set.\nSome of the most important include:* Consumer lemmas such as Iter.all_toList, Iter.any_toList, and Iter.foldl_toList that introduce lists as a model.* Simplification lemmas such as Iter.toList_map that Iter.toList_filter push the list model “inwards” in the goal.* Producer lemmas such as List.toList_iter and Array.toList_iter that replace a producer with a list model, removing iterators from the goal entirely.The latter two categories are typically automatic with simp.\n\nReasoning via ListsEvery element returned by an iterator that multiplies the numbers consumed some other iterator by two is even.\nTo prove this statement, Iter.all_toList, Iter.toList_map, and Array.toList_iter are used to replace the statement about iterators with one about lists, after which simp discharges the goal:example (l : Array Nat) :\n    (l.iter.map (· * 2)).all (· % 2 = 0) := by\n  rw [← Iter.all_toList]\n  rw [Iter.toList_map]\n  rw [Array.toList_iter]\n  simp\nIn fact, because most of the needed lemmas are in the default simp set, the proof can be quite short:example (l : Array Nat) :\n    (l.iter.map (· * 2)).all (· % 2 = 0) := by\n  simp [← Iter.all_toList]\n\n\n","context":"Lean Reference\u0009Iterators\u0009Reasoning About Iterators","header":"22.5.1. Reasoning About Consumers","id":"/Iterators/Reasoning-About-Iterators/#The-Lean-Language-Reference--Iterators--Reasoning-About-Iterators--Reasoning-About-Consumers"},"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Lists-and-Arrays":{"contents":"List and array literals contain comma-separated sequences of elements inside of brackets, with arrays prefixed by a hash mark (#).\nArray literals are interpreted as list literals wrapped in a call to a conversion.\nFor performance reasons, very large list and array literals are converted to sequences of local definitions, rather than just iterated applications of the list constructor.\n\nList Literals\n\nArray Literals\n\nLong List LiteralsThis list contains 32 elements.\nThe generated code is an iterated application of List.cons:#check\n  [1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1]\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] : List Nat\nWith 33 elements, the list literal becomes a sequence of local definitions:#check\n  [1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1]\nlet y :=\n  let y :=\n    let y := [1, 1, 1, 1, 1];\n    1 :: 1 :: 1 :: 1 :: y;\n  let y := 1 :: 1 :: 1 :: 1 :: y;\n  1 :: 1 :: 1 :: 1 :: y;\nlet y :=\n  let y := 1 :: 1 :: 1 :: 1 :: y;\n  1 :: 1 :: 1 :: 1 :: y;\nlet y := 1 :: 1 :: 1 :: 1 :: y;\n1 :: 1 :: 1 :: 1 :: y : List Nat\n\n\n","context":"Lean Reference\u0009Terms\u0009Numeric Literals","header":"13.5.4. Lists and Arrays","id":"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Lists-and-Arrays"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--New-math-project-template":{"contents":"#8866 upgrades the math template for lake init and\nlake new to meet rigorous Mathlib maintenance standards.\nIn comparison with the previous version (now available as lake new ... math-lax), the new template automatically provides:\n\n* Strict linting options matching Mathlib.* GitHub workflow for automatic upgrades to newer Lean and Mathlib releases.* Automatic release tagging for toolchain upgrades.* API documentation generated by doc-gen4 and hosted on github.io.* README with some GitHub-specific instructions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"New math project template","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--New-math-project-template"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Coinductive-Predicates":{"contents":"#10333 introduces a coinductive keyword, that can be used to define\ncoinductive predicates via a syntax identical to the one for inductive\nkeyword.\n\nFor example, infinite sequence of transitions in a relation can be given by the following:\n\nsection\nvariable (α : Type)\ncoinductive infSeq (r : α → α → Prop) : α → Prop where\n  | step : r a b → infSeq r b → infSeq r a\n\n/--\ninfo: infSeq.coinduct (α : Type) (r : α → α → Prop) (pred : α → Prop) (hyp : ∀ (a : α), pred a → ∃ b, r a b ∧ pred b)\n  (a✝ : α) : pred a✝ → infSeq α r a✝\n-/\n#guard_msgs in\n#check infSeq.coinduct\n\n/--\ninfo: infSeq.step (α : Type) (r : α → α → Prop) {a b : α} : r a b → infSeq α r b → infSeq α r a\n-/\n#guard_msgs in\n#check infSeq.step\nend\n\n\nThe machinery also supports mutual blocks, as well as mixing inductive and coinductive predicate definitions:\n\nmutual\n  coinductive tick : Prop where\n  | mk : ¬tock → tick\n\n  inductive tock : Prop where\n  | mk : ¬tick → tock\nend\n\n/--\ninfo: tick.mutual_induct (pred_1 pred_2 : Prop) (hyp_1 : pred_1 → pred_2 → False) (hyp_2 : (pred_1 → False) → pred_2) :\n  (pred_1 → tick) ∧ (tock → pred_2)\n-/\n#guard_msgs in\n#check tick.mutual_induct\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Coinductive Predicates","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Coinductive-Predicates"}});