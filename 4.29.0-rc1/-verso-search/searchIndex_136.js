window.docContents[136].resolve({"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Transformer":{"contents":"Adds exceptions of type ε to a monad m.\n\nRuns a computation from an underlying monad in the transformed monad with exceptions.\n\nUse a monadic action that may throw an exception as an action that may return an exception's value.This is the inverse of ExceptT.mk.\n\nReturns the value a without throwing exceptions or having any other effect.\n\nSequences two actions that may throw exceptions. Typically used via do-notation or the >>=\noperator.\n\nHandles exceptions thrown by an action that can have no effects other than throwing exceptions.\n\nHandles exceptions produced in the ExceptT ε transformer.\n\nUse a monadic action that may return an exception's value as an action in the transformed monad that\nmay throw the corresponding exception.This is the inverse of ExceptT.run.\n\nTransforms a successful computation's value using f. Typically used via the <$> operator.\n\nTransforms exceptions using the function f.This is the ExceptT version of Except.mapError.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Exceptions","header":"18.5.7.4. Transformer","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Transformer"},"/Run-Time-Code/Foreign-Function-Interface/#The-Lean-Language-Reference--Run-Time-Code--Foreign-Function-Interface--The-Lean-ABI":{"contents":"The Lean Application Binary Interface (ABI) describes how the signature of a Lean declaration is encoded in the platform-native calling convention.\nIt is based on the standard C ABI and calling convention of the target platform.\nLean declarations can be marked for interaction with foreign functions using either the attribute extern \"sym\", which causes compiled code to use the C declaration sym as the implementation, or the attribute export sym, which makes the declaration available as sym to C.In both cases, the C declaration's type is derived from the Lean type of the declaration with the attribute.\nLet α₁ → ... → αₙ → β be the declaration's normalized type.\nIf n is 0, the corresponding C declaration isextern s sym;\nwhere s is the C translation of β as specified in the next section.\nIn the case of a definition marked extern, the symbol's value is only guaranteed to be initialized after calling the Lean module's initializer or that of an importing module.\nThe section on initialization describes initializers in greater detail.If n is greater than 0, the corresponding C declaration iss sym(t₁, ..., tₙ);\nwhere the parameter types tᵢ are the C translations of the types αᵢ.\nIn the case of extern, all irrelevant types are removed first.\n\n\n\n\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Foreign Function Interface","header":"12.4.1. The Lean ABI","id":"/Run-Time-Code/Foreign-Function-Interface/#The-Lean-Language-Reference--Run-Time-Code--Foreign-Function-Interface--The-Lean-ABI"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Specification-Lemmas":{"contents":"Specification lemmas are designated theorems that associate Hoare triples with functions.\nWhen mvcgen encounters a function, it checks whether there are any registered specification lemmas and attempts to use them to discharge intermediate verification conditions.\nIf there is no applicable specification lemma, then the connection between the statement's pre- and postconditions will become a verification condition.\nSpecification lemmas allow compositional reasoning about libraries of monadic code.\n\nWhen applied to a theorem whose statement is a Hoare triple, the spec attribute registers the theorem as a specification lemma.\nThese lemmas are used in order of priority.\n\nThe spec attribute may also be applied to definitions.\nOn definitions, it indicates that the definition should be unfolded during verification condition generation.\n\nSpecification LemmasTheorems tagged with the spec attribute are used by the mspec and mvcgen tactics.* When used on a theorem foo_spec : Triple (foo a b c) P Q, then mspec and mvcgen will use\nfoo_spec as a specification for calls to foo.* Otherwise, when used on a definition that @[simp] would work on, it is added to the internal\nsimp set of mvcgen that is used within wp⟦·⟧ contexts to simplify match discriminants and\napplications of constants.\n\nUniversally-quantified variables in specification lemmas can be used to relate input states to output states and return values.\nThese variables are referred to as schematic variables.\n\nSchematic VariablesThe function double doubles the value of a Nat state:def double : StateM Nat Unit := do\n  modify (2 * ·)\nIts specification should relate the initial and final states, but it cannot know their precise values.\nThe specification uses a schematic variable to stand for the initial state:theorem double_spec :\n    ⦃ fun s => ⌜s = n⌝ ⦄ double ⦃ ⇓ () s => ⌜s = 2 * n⌝ ⦄ := by\n  simp [double]\n  mvcgen with grind\nThe assertion in the precondition is a function because the PostShape of StateM Nat is .arg Nat .pure, and Assertion (.arg Nat .pure) is SPred [Nat].\n\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers","header":"17.2.5. Specification Lemmas","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Specification-Lemmas"},"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Documentation":{"contents":"* #9093 adds a missing docstring for ToFormat.toFormat.* #9152 fixes an obsolete docstring for registerDerivingHandler* #9593 simplifies the docstring for propext significantly.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.23.0 (2025-09-15)","header":"Documentation","id":"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Documentation"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-_LPAR_2026-01-24_RPAR_--Highlights--Well-Founded-Recursion-on--Nat":{"contents":"Definitions that use well-founded recursion are generally irreducible.\nWith #7965, when the termination measure is of type Nat,\nsuch definitions can be reduced, and an explicit @[semireducible] annotation is accepted\nwithout the usual warning.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0 (2026-01-24)\u0009Highlights","header":"Well-Founded Recursion on  Nat","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-_LPAR_2026-01-24_RPAR_--Highlights--Well-Founded-Recursion-on--Nat"}});