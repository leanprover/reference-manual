window.docContents[195].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Arithmetic":{"contents":"Arithmetic operations on floating-point values are typically invoked via the Add Float, Sub Float, Mul Float, Div Float, and HomogeneousPow Float instances, along with the corresponding Float32 instances.\n\nAdds two 64-bit floating-point numbers according to IEEE 754. Typically used via the + operator.This function does not reduce in the kernel. It is compiled to the C addition operator.\n\nAdds two 32-bit floating-point numbers according to IEEE 754. Typically used via the + operator.This function does not reduce in the kernel. It is compiled to the C addition operator.\n\nSubtracts 64-bit floating-point numbers according to IEEE 754. Typically used via the - operator.This function does not reduce in the kernel. It is compiled to the C subtraction operator.\n\nSubtracts 32-bit floating-point numbers according to IEEE 754. Typically used via the - operator.This function does not reduce in the kernel. It is compiled to the C subtraction operator.\n\nMultiplies 64-bit floating-point numbers according to IEEE 754. Typically used via the * operator.This function does not reduce in the kernel. It is compiled to the C multiplication operator.\n\nMultiplies 32-bit floating-point numbers according to IEEE 754. Typically used via the * operator.This function does not reduce in the kernel. It is compiled to the C multiplication operator.\n\nDivides 64-bit floating-point numbers according to IEEE 754. Typically used via the / operator.In Lean, division by zero typically yields zero. For Float, it instead yields either Inf,\n-Inf, or NaN.This function does not reduce in the kernel. It is compiled to the C division operator.\n\nDivides 32-bit floating-point numbers according to IEEE 754. Typically used via the / operator.In Lean, division by zero typically yields zero. For Float32, it instead yields either Inf,\n-Inf, or NaN.This function does not reduce in the kernel. It is compiled to the C division operator.\n\nRaises one floating-point number to the power of another. Typically used via the ^ operator.This function does not reduce in the kernel. It is implemented in compiled code by the C function\npow.\n\nRaises one floating-point number to the power of another. Typically used via the ^ operator.This function does not reduce in the kernel. It is implemented in compiled code by the C function\npowf.\n\nComputes the exponential e^x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nexp.\n\nComputes the exponential e^x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nexpf.\n\nComputes the base-2 exponential 2^x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nexp2.\n\nComputes the base-2 exponential 2^x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nexp2f.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"20.6.2.5. Arithmetic","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Arithmetic"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Identity":{"contents":"The identity monad Id has no effects whatsoever.\nBoth Id and the corresponding implementation of pure are the identity function, and bind is reversed function application.\nThe identity monad has two primary use cases:\n\n1. It can be the type of a do block that implements a pure function with local effects.2. It can be placed at the bottom of a stack of monad transformers.\n\n\n\nThe identity function on types, used primarily for its Monad instance.The identity monad is useful together with monad transformers to construct monads for particular\npurposes. Additionally, it can be used with do-notation in order to use control structures such as\nlocal mutability, for-loops, and early returns in code that does not otherwise use monads.Examples:def containsFive (xs : List Nat) : Bool := Id.run do\n  for x in xs do\n    if x == 5 then return true\n  return false\n#eval containsFive [1, 3, 5, 7]\ntrue\n\n\nRuns a computation in the identity monad.This function is the identity function. Because its parameter has type Id Î±, it causes\ndo-notation in its arguments to use the Monad Id instance.\n\nLocal Effects with the Identity MonadThis code block implements a countdown procedure by using simulated local mutability in the identity monad.#eval Id.run do\n  let mut xs := []\n  for x in [0:10] do\n    xs := x :: xs\n  pure xs\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"18.5.3. Identity","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Identity"},"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Documentation":{"contents":"* #12157 updates #12137 with a link to the Lean reference manual.* #12174 fixes a typo in ExtractLetsConfig.merge doc comment.* #12253 adds a \"Stabilizing output\" section to the #guard_msgs\n  docstring, explaining how to use pp.mvars.anonymous and pp.mvars\n  options to stabilize output containing autogenerated metavariable names\n  like ?m.47.* #12271 adds and updates docstrings for syntax (and one for ranges).* #12439 improves docstrings for cbv and decide_cbv tactics* #12487 expands the docstring for @[univ_out_params] to explain:* How universe output parameters affect the typeclass resolution cache\n  (they are erased from cache keys, so queries differing only in output\n  universes share entries)* When a universe parameter should be considered an output (determined\n  by inputs) vs. not (part of the question being asked)\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.29.0-rc1 (2026-02-17)","header":"Documentation","id":"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Documentation"}});