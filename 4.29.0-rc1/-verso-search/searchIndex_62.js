window.docContents[62].resolve({"/Basic-Types/Floating-Point-Numbers/#Float":{"contents":"Floating-point numbers are a an approximation of the real numbers that are efficiently implemented in computer hardware.\nComputations that use floating-point numbers are very efficient; however, the nature of the way that they approximate the real numbers is complex, with many corner cases.\nThe IEEE 754 standard, which defines the floating-point format that is used on modern computers, allows hardware designers to make certain choices, and real systems differ in these small details.\nFor example, there are many distinct bit representations of NaN, the indicator that a result is undefined, and some platforms differ with respect to which NaN is returned from adding two NaNs.\n\nLean exposes the underlying platform's floating-point values for use in programming, but they are not encoded in Lean's logic.\nThey are represented by an opaque type.\nThis means that the kernel is not capable of computing with or reasoning about floating-point values without additional axioms.\nA consequence of this is that equality of floating-point numbers is not decidable.\nFurthermore, comparisons between floating-point values are decidable, but the code that does so is opaque; in practice, the decision procedure can only be used in compiled code.\n\nLean provides two floating-point types: Float represents 64-bit floating point values, while Float32 represents 32-bit floating point values.\nThe precision of Float does not vary based on the platform that Lean is running on.\n\n64-bit floating-point numbers.Float corresponds to the IEEE 754 binary64 format (double in C or f64 in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.Floating-point numbers include subnormal numbers.\nTheir special values are:* NaN, which denotes a class of “not a number” values that result from operations such as\ndividing zero by zero, and* Inf and -Inf, which represent positive and infinities that result from dividing non-zero\nvalues by zero.\n\n32-bit floating-point numbers.Float32 corresponds to the IEEE 754 binary32 format (float in C or f32 in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.Floating-point numbers include subnormal numbers.\nTheir special values are:* NaN, which denotes a class of “not a number” values that result from operations such as\ndividing zero by zero, and* Inf and -Inf, which represent positive and infinities that result from dividing non-zero\nvalues by zero.\n\nNo Kernel Reasoning About Floating-Point NumbersThe Lean kernel can compare expressions of type Float for syntactic equality, so 0.0 is definitionally equal to itself.example : (0.0 : Float) = (0.0 : Float) := by rfl\nTerms that require reduction to become syntactically equal cannot be checked by the kernel:example : (0.0 : Float) = (0.0 + 0.0 : Float) := by rfl\nTactic `rfl` failed: The left-hand side\n  0.0\nis not definitionally equal to the right-hand side\n  0.0 + 0.0\n\n⊢ 0.0 = 0.0 + 0.0\nSimilarly, the kernel cannot evaluate Bool-valued comparisons of floating-point numbers while checking definitional equality:theorem Float.zero_eq_zero_plus_zero :\n    ((0.0 : Float) == (0.0 + 0.0 : Float)) = true :=\n  by rfl\nTactic `rfl` failed: The left-hand side\n  0.0 == 0.0 + 0.0\nis not definitionally equal to the right-hand side\n  true\n\n⊢ (0.0 == 0.0 + 0.0) = true\nHowever, the native_decide tactic can invoke the underlying platform's floating-point primitives that are used by Lean for run-time programs:theorem Float.zero_eq_zero_plus_zero :\n    ((0.0 : Float) == (0.0 + 0.0 : Float)) = true := by\n  native_decide\nThis tactic executes a decision procedure as compiled native code.\nThis requires trusting the Lean compiler, interpreter and the low-level implementations of built-in operators in addition to the kernel.\nTo make this dependency precisely clear, the tactic creates the axiom Float.zero_eq_zero_plus_zero._native.native_decide.ax_1:#print axioms Float.zero_eq_zero_plus_zero\n'Float.zero_eq_zero_plus_zero' depends on axioms: [Classical.choice,\n Float.zero_eq_zero_plus_zero._native.native_decide.ax_1]\n\n\nFloating-Point Equality Is Not ReflexiveFloating-point operations may produce NaN values that indicate an undefined result.\nThese values are not comparable with each other; in particular, all comparisons involving NaN will return false, including equality.#eval ((0.0 : Float) / 0.0) == ((0.0 : Float) / 0.0)\n\n\nFloating-Point Equality Is Not a CongruenceApplying a function to two equal floating-point numbers may not result in equal numbers.\nIn particular, positive and negative zero are distinct values that are equated by floating-point equality, but division by positive or negative zero yields positive or negative infinite values.def neg0 : Float := -0.0\n\ndef pos0 : Float := 0.0\n\n#eval (neg0 == pos0, 1.0 / neg0 == 1.0 / pos0)\n(true, false)\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.6. Floating-Point Numbers","id":"/Basic-Types/Floating-Point-Numbers/#Float"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Language-server___-widgets___-and-IDE-extensions":{"contents":"* #4821 resolves two language server bugs that especially affect Windows users. (1) Editing the header could result in the watchdog not correctly restarting the file worker, which would lead to the file seemingly being processed forever. (2) On an especially slow Windows machine, we found that starting the language server would sometimes not succeed at all. This PR also resolves an issue where we would not correctly emit messages that we received while the file worker is being restarted to the corresponding file worker after the restart.* #5006 updates the user widget manual.* #5193 updates the quickstart guide with the new display name for the Lean 4 extension (\"Lean 4\").* #5185 fixes a bug where over time \"import out of date\" messages would accumulate.* #4900 improves ilean loading performance by about a factor of two. Optimizes the JSON parser and the conversion from JSON to Lean data structures; see PR description for details.* Other fixes or improvements* #5031 localizes an instance in Lsp.Diagnostics.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Language server, widgets, and IDE extensions","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Language-server___-widgets___-and-IDE-extensions"},"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Library":{"contents":"* #11811 proves that membership is preserved by eraseDups: an element\n  exists in the deduplicated list iff it was in the original.* #11832 uses an Array instead of a List to store the clauses in\n  Std.CNF. This reduces the memory footprint and pressure on the\n  allocator, leading to noticeable performance changes with gigantic CNFs.* #11936 provides Array operations analogous to List.min(?) and\n  List.max(?).* #11938 introduces projected minima and maxima, also known as\n  \"argmin/argmax\", for lists under the names List.minOn and\n  List.maxOn. It also introduces List.minIdxOn and List.maxIdxOn,\n  which return the index of the minimal or maximal element. Moreover,\n  there are variants with ? suffix that return an Option. The change\n  further introduces new instances for opposite orders, such as\n  LE.opposite, IsLinearOrder.opposite etc. The change also adds the\n  missing Std.lt_irrefl lemma.* #11943 introduces the theorem\n  BitVec.sshiftRight_eq_setWidth_extractLsb_signExtend theorem, proving\n  x.sshiftRight n is equivalent to first sign-extending x, extracting\n  the appropriate least significant bits, and then setting the width back\n  to w.* #11994 provides more lemmas about sums of lists/arrays/vectors,\n  especially sums of Nat or Int lists/arrays/vectors.* #12017 makes several small improvements to the list/array/vector API:* It fixes typos in Init.Core.* It adds List.isSome_min_iff and List.isSome_max_iff.* It adds grind and simp annotations to various previously\n  unannotated lemmas.* It adds lemmas for characterizing ∃ x ∈ xs, P x using indices as ∃\n  (i : Nat), ∃ hi, P (xs[i]), and similar universally quantified lemmas:\n  exists_mem_iff_exists_getElem and forall_mem_iff_forall_getElem.* It adds Vector.toList_zip.* It adds map_ofFn and ofFn_getElem for lists/arrays/vectors.* #12019 provides the Nat/Int lemmas x ≤ y * z ↔ (x + z - 1) / z ≤\n  y, x ≤ y * z ↔ (x + y - 1) / y ≤ z and x / z + y / z ≤ (x + y) / z.* #12108 adds prefix_map_iff_of_injective and\n  suffix_map_iff_of_injective lemmas to Init.Data.List.Nat.Sublist.* #12161 adds Option.of_wp_eq and Except.of_wp_eq, similar to the\n  existing Except.of_wp. Except.of_wp is deprecated because applying\n  it requires prior generalization, at which point it is more convenient\n  to use Except.of_wp_eq.* #12162 adds the function Std.Iter.first? and proves the specification\n  lemma Std.Iter.first?_eq_match_step if the iterator is productive.* #12170 adjusts the grind annotations for List.take/drop, and adds two\n  theorems.* #12181 adds two missing order instances for Int.* #12193 adds DecidableEq instances for Sigma and PSigma.* #12204 adds theorems showing the consistency between find? and the\n  various index-finding functions. The theorems establish bidirectional\n  relationships between finding elements and finding their indices.* #12212 adds the function Std.Iter.isEmpty and proves the\n  specification lemmas Std.Iter.isEmpty_eq_match_step and\n  Std.Iter.isEmpty_toList if the iterator is productive.* #12220 fixes a bug on Windows with IO.Process.spawn where setting an\n  environment variable to the empty string would not set the environment\n  variable on the subprocess.* #12234 introduces an Iter.step_eq lemma that fully unfolds an\n  Iter.step call, bypassing layers of unfolding.* #12249 adds some lemmas about the interaction of sum, min and max\n  about arrays that already exist for lists.* #12250 introduces the defining equality Triple.iff and uses that in\n  proofs instead of relying on definitional equality. It also introduces\n  Triple.iff_conseq that is useful for backward reasoning and introduces\n  verification conditions. Similarly, Triple.entails_wp_* theorems are\n  introduced for backward reasoning where the target is an stateful\n  entailment rather than a triple.* #12258 adds theorems that directly state that div and mod form an\n  injective pair: if a / n = b / n and a % n = b % n then a = b.\n  These complement existing div/mod lemmas and are useful for extension\n  arguments.* #12277 adds IO.FS.Metadata.numLinks, which contains the number of\n  hard links to a file.* #12281 changes the definition of Squash to use Quotient by\n  upstreaming\n  true_equivalence\n  (now equivalence_true) and\n  trueSetoid\n  (now Setoid.trivial). The new definition is def-eq to the old one, but\n  ensures that Squash can be used whenever a Quotient argument is\n  expected without having to explicitly provide the setoid.* #12282 fixes a platform inconsistency in IO.FS.removeFile where it\n  could not delete read-only files on Windows.* #12290 moves the PredTrans.apply structure field into a separate\n  def. Doing so improves kernel reduction speed because the kernel is\n  less likely to unfold definitions compared to structure field\n  projections. This causes minor shifts in simp normal forms.* #12301 introduces the functions (String|Slice).posGE and\n  (String|Slice).posGT will full verification and deprecates\n  Slice.findNextPos in favor of Slice.posGT.* #12305 adds various uninteresting lemmas about basic types, extracted\n  from the KMP verification.* #12311 exposes the chain and is_sup definitions such that other modules\n  can declare custom CCPO instances.* #12312 reverses the relationship between the ForwardPattern and\n  ToForwardSearcher classes.* #12318 avoids undefined behavior in String.Slice.hash on unaligned\n  substrings.\n  This could produce a SIGILL on some Arm platforms.* #12322 adds String.Slice.Subslice, which is an unbundled version of\n  String.Slice.* #12333 adds the basic typeclasses that will be used in the verification\n  of our string searching infrastructure.* #12341 adds a few unification hints that we will need after\n  backward.isDefEq.respectTransparency is true by default.* #12346 shows s == t ↔ s.copy = t.copy for s t : String.Slice and\n  establishes the right-hand side as the simp normal form.* #12349 builds on #12333 and proves that Char and Char -> Bool\n  patterns are lawful.* #12352 improves the slice API with lemmas for drop/take operations\n  on Subarray and more lemmas about Std.Slice.fold, Std.Slice.foldM\n  and Std.Slice.forIn. It also changes the simp and grind\n  annotations for Slice-related lemmas. Lemmas converting between slices\n  of different shapes are no longer simp/grind-annotated because they\n  often complicated lemmas and hindered automation.* #12358 improves the simp and grind rule framework for\n  PredTrans.apply and also renames the respective lemmas according to\n  convention.* #12359 deprecates extract_eq_drop_take in favor of the more correct\n  name extract_eq_take_drop, so that we'll be able to use the old name\n  for a lemma xs.extract start stop = (xs.take stop).drop start. Until\n  the deprecation deadline has passed, this new lemma will be called\n  extract_eq_drop_take'.* #12360 provides a LawfulForwardPatternModel instance for string\n  patterns, i.e., it proves correctness of the dropPrefix? and\n  startsWith functions for string patterns.* #12363 introduces iterators for vectors via Vector.iter and\n  Vector.iterM, together with the usual lemmas.* #12371 adds lemmas for simplifying situations involving Bool and\n  ite/dite.* #12412 introduces Rat.abs and adds missing lemmas about Int and\n  Rat.* #12419 adds LawfulOrderOrd instances for Nat, Int, and all\n  fixed-width integer types (Int8, Int16, Int32, Int64, ISize,\n  UInt8, UInt16, UInt32, UInt64, USize). These instances\n  establish that the Ord instances for these types are compatible with\n  their LE instances. Additionally, this PR adds a few missing lemmas\n  and grind patterns.* #12424 gives a proof of LawfulToForwardSearcherModel for Slice\n  patterns, which amounts to proving that our implementation of KMP is\n  correct.* #12426 adds the lemma Acc.inv_of_transGen, a generalization of\n  Acc.inv. While Acc.inv shows that Acc r x implies Acc r y given\n  that r y x, the new lemma shows that this also holds if y is only\n  transitively related to x.* #12432 adds the lemmas isSome_find? and isSome_findSome? to the API\n  of lists, arrays and vectors.* #12437 verifies the String.Slice.splitToSubslice function by relating\n  it to a model implementation Model.split based on a\n  ForwardPatternModel.* #12438 provides (1) lemmas showing that lists obtained from ranges have\n  no duplicates and (2) lemmas about forIn and foldl on slices.* #12442 derives DecidableEq instances for the types of ranges such as\n  a...b (in this case, Std.Rco).* #12449 marks String.toString_eq_singleton as a simp lemma.* #12450 moves the String.Slice/String iterators out into their own\n  file, in preparation for verification.* #12456 verifies all of the String iterators except for the bytes\n  iterator by relating them to String.toList.* #12504 makes the Rat.abs_* lemmas (abs_zero, abs_nonneg,\n  abs_of_nonneg, abs_of_nonpos, abs_neg, abs_sub_comm,\n  abs_eq_zero_iff, abs_pos_iff) protected, so they don't shadow the\n  general abs_* lemmas when the Rat namespace is opened in downstream\n  projects.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.29.0-rc1 (2026-02-17)","header":"Library","id":"/releases/v4.29.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___29___0-rc1-_LPAR_2026-02-17_RPAR_--Library"}});