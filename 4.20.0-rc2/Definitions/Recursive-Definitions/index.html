<!DOCTYPE html>
<html>
  <head>
<meta name="robots" content="noindex">
                        <link rel="canonical" href="https://lean-lang.org/doc/reference/4.20.0-rc2/Definitions/Recursive-Definitions/" />
                        
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Recursive Definitions</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "âŽ";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="current numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-definitions" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-definitions" checked="checked"></label><span class="number">7.</span>Â <span class=""><a href="Definitions/#definitions">Definitions</a></span></div>
              <table><tr class="numbered"><td class="num">7.1.</td><td><a href="Definitions/Modifiers/#declaration-modifiers">Modifiers</a></td></tr><tr class="numbered"><td class="num">7.2.</td><td><a href="Definitions/Headers-and-Signatures/#signature-syntax">Headers and Signatures</a></td></tr><tr class="numbered"><td class="num">7.3.</td><td><a href="Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">7.4.</td><td><a href="Definitions/Theorems/#The-Lean-Language-Reference--Definitions--Theorems">Theorems</a></td></tr><tr class="numbered"><td class="num">7.5.</td><td><a href="Definitions/Example-Declarations/#The-Lean-Language-Reference--Definitions--Example-Declarations">Example Declarations</a></td></tr><tr class="current numbered"><td class="num">7.6.</td><td><a href="Definitions/Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-recursive-definitions" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-recursive-definitions" checked="checked"></label><span class="number">7.6.</span>Â <span class="current"><a href="Definitions/Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Definitions/Recursive-Definitions/#mutual-syntax">Mutual Recursion</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="syntax"><span class="keyword">mutual</span><span class="ws"> </span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">end</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Definitions/Recursive-Definitions/#structural-recursion">Structural Recursion</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion">Explicit Structural Recursion</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Termination___terminationBy-next"><span class="syntax"><span class="keyword">termination_by</span><span class="ws"> </span><span class="keyword">structural</span><span class="ws"> </span><span class="meta">(</span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="Definitions/Recursive-Definitions/#mutual-structural-recursion">Mutual Structural Recursion</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.3.</span> <a href="Definitions/Recursive-Definitions/#inferring-structural-recursion">Inferring Structural Recursion</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.4.</span> <a href="Definitions/Recursive-Definitions/#elab-as-course-of-values">Elaboration Using Course-of-Values Recursion</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Definitions/Recursive-Definitions/#well-founded-recursion">Well-Founded Recursion</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Termination___terminationBy-next-next-next"><span class="syntax"><span class="keyword">termination_by</span><span class="ws"> </span><span class="meta">(</span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.1.</span> <a href="Definitions/Recursive-Definitions/#wf-rel">Well-Founded Relations</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><code>WellFoundedRelation</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.2.</span> <a href="Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Termination-proofs">Termination proofs</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.3.</span> <a href="Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic">Default Termination Proof Tactic</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#decreasing_tactic"><code class="tactic-name">decreasing_tactic</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#decreasing_trivial"><code class="tactic-name">decreasing_trivial</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.4.</span> <a href="Definitions/Recursive-Definitions/#inferring-well-founded-recursion">Inferring Well-Founded Recursion</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.5.</span> <a href="Definitions/Recursive-Definitions/#mutual-well-founded-recursion">Mutual Well-Founded Recursion</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.6.</span> <a href="Definitions/Recursive-Definitions/#well-founded-preprocessing">Preprocessing Function Definitions</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___wf_preprocess"><span class="syntax"><span class="keyword">wf_preprocess</span></span></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#wfParam"><code>wfParam</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#trace___Elab___definition___wf"><code>trace.Elab.definition.wf</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.7.</span> <a href="Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction">Theory and Construction</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#WellFounded___fix"><code>WellFounded.fix</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#invImage"><code>invImage</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#WellFounded___intro"><code>WellFounded</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Acc___intro"><code>Acc</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Definitions/Recursive-Definitions/#partial-fixpoint">Partial Fixpoint Recursion</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.1.</span> <a href="Definitions/Recursive-Definitions/#partial-fixpoint-tailrec">Tail-Recursive Functions</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.2.</span> <a href="Definitions/Recursive-Definitions/#partial-fixpoint-monadic">Monadic functions</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.3.</span> <a href="Definitions/Recursive-Definitions/#partial-correctness-theorem">Partial Correctness Theorems</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.4.</span> <a href="Definitions/Recursive-Definitions/#mutual-partial-fixpoint">Mutual Recursion with Partial Fixpoints</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.5.</span> <a href="Definitions/Recursive-Definitions/#partial-fixpoint-theory">Theory and Construction</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><code>PartialOrder</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><code>CCPO</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Order___monotone"><code>monotone</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><code>Lean.Order.fix</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Order___fix_eq"><code>fix_eq</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Definitions/Recursive-Definitions/#partial-unsafe">Partial and Unsafe Definitions</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.1.</span> <a href="Definitions/Recursive-Definitions/#partial-functions">Partial Functions</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.2.</span> <a href="Definitions/Recursive-Definitions/#unsafe">Unsafe Definitions</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#unsafeCast"><code>unsafeCast</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#ptrEq"><code>ptrEq</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#ptrEqList"><code>ptrEqList</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#ptrAddrUnsafe"><code>ptrAddrUnsafe</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#isExclusiveUnsafe"><code>isExclusiveUnsafe</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#unsafeIO"><code>unsafeIO</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#unsafeEIO"><code>unsafeEIO</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#unsafeBaseIO"><code>unsafeBaseIO</code></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___simple"><span class="syntax"><span class="keyword">implemented_by</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">6.</span> <a href="Definitions/Recursive-Definitions/#reducibility">Controlling Reduction</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___simple-next"><span class="syntax"><span class="keyword">reducible</span></span></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___simple-next-next"><span class="syntax"><span class="keyword">semireducible</span></span></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___simple-next-next-next"><span class="syntax"><span class="keyword">irreducible</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.1.</span> <a href="Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Reducibility-and-Tactics">Reducibility and Tactics</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.2.</span> <a href="Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Modifying-Reducibility">Modifying Reducibility</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___commandSeal__"><span class="syntax"><span class="keyword">seal</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#Lean___Parser___commandUnseal__"><span class="syntax"><span class="keyword">unseal</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.3.</span> <a href="Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Options">Options</a></span></li>
                <li>
                  <a href="Definitions/Recursive-Definitions/#allowUnsafeReducibility"><code>allowUnsafeReducibility</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Definitions/Example-Declarations/#The-Lean-Language-Reference--Definitions--Example-Declarations" rel="prev" title="7.5. Example Declarations"><span class="arrow">â†</span><span class="where">7.5. Example Declarations</span></a><a class="local-button active" href="Axioms/#axioms" rel="next" title="8. Axioms"><span class="where">8. Axioms</span><span class="arrow">â†’</span></a></nav>
          <section>
            <h1>
              7.6.Â Recursive Definitions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=recursive-definitions" title="Permalink">ðŸ”—</a></span></h1>
            <p>
              Allowing arbitrary recursive function definitions would make Lean's logic inconsistent.
General recursion makes it possible to write circular proofs: "<a class="technical-term" href="The-Type-System/Propositions/#--tech-term-Propositions">proposition</a> <code class="math inline">P</code> is true because proposition <code class="math inline">P</code> is true".
Outside of proofs, an infinite loop could be assigned the type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#Empty"><span class="const token" data-binding="const-Empty" data-verso-hover="265">Empty</span></a></code>, which can be used with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.nomatch : term</code><span class="sep"></span><code class="docstring">Empty match/ex falso. `nomatch e` is of arbitrary type `Î± : Sort u` if
Lean can show that an empty set of patterns is exhaustive given `e`'s type,
e.g. because it has no constructors.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><code class="kw">nomatch</code></a></span> or <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Empty.rec" data-verso-hover="878">Empty.rec</span></code> to prove any theorem.</p>
            <p>
              Banning recursive function definitions outright would render Lean far less useful: <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive types</a> are key to defining both predicates and data, and they have a recursive structure.
Furthermore, most useful recursive functions do not threaten soundness, and infinite loops usually indicate mistakes in definitions rather than intentional behavior.
Instead of banning recursive functions, Lean requires that each recursive function is defined safely.
While elaborating recursive definitions, the Lean elaborator also produces a justification that the function being defined is safe.<span class="marginalia"><span class="note">The section on <a href="Elaboration-and-Compilation/#elaboration-results">the elaborator's output</a> in the overview of elaboration contextualizes the elaboration of recursive definitions in the overall context of the elaborator.</span></span></p>
            <p>
              There are five main kinds of recursive functions that can be defined:</p>
            <dl><dt> Structurally recursive functions</dt><dd><p>
                  Structurally recursive functions take an argument such that the function makes recursive calls only on strict sub-components of said argument.<span class="marginalia"><span class="note">Strictly speaking, arguments whose types are <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-indexed-families">indexed families</a> are grouped together with their indices, with the whole collection considered as a unit.</span></span>
  The elaborator translates the recursion into uses of the argument's <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-recursor">recursor</a>.
  Because every type-correct use of a recursor is guaranteed to avoid infinite regress, this translation is evidence that the function terminates.
  Applications of functions defined via recursors are definitionally equal to the result of the recursion, and are typically relatively efficient inside the kernel.</p>
                </dd><dt> Recursion over well-founded relations</dt><dd><p>
                  Many functions are also difficult to convert to structural recursion; for instance, a function may terminate because the difference between an array index and the size of the array decreases as the index increases, but <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.rec" data-verso-hover="879">Nat.rec</span></code> isn't applicable because the index that increases is the function's argument.
  Here, there is a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> of termination that decreases at each recursive call, but the measure is not itself an argument to the function.
  In these cases, <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a> can be used to define the function.
  Well-founded recursion is a technique for systematically transforming recursive functions with a decreasing measure into recursive functions over proofs that every sequence of reductions to the measure eventually terminates at a minimum.
  Applications of functions defined via well-founded recursion are not necessarily definitionally equal to their return values, but this equality can be proved as a proposition.
  Even when definitional equalities exist, these functions are frequently slow to compute with because they require reducing proof terms that are often very large.</p>
                </dd><dt> Recursive functions as partial fixpoints</dt><dd><p>
                  The definition of a function can be understood as an equation that specifies its behavior.
  In certain cases, the existence of a function that satisfies this specification can be proven even when the recursive function does not necessarily terminate for all inputs.
  This strategy is even applicable in some cases where the function definition does not necessarily terminate for all inputs.
  These partial functions emerge as fixed points of these equations are called <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-partial-fixpoint"><em>partial fixpoints</em></a>.</p>
                <p>
                  In particular, any function whose return type is in certain monads (e.g. <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code>) can be defined using this strategy.
  Lean generates additional partial correctness theorems for these monadic functions.
  As with well-founded recursion, applications of functions defined as partial fixpoints are not definitionally equal to their return values, but Lean generates theorems that propositionally equate the function to its unfolding and to the reduction behavior specified in its definition.</p>
                </dd><dt> Partial functions with nonempty codomains</dt><dd><p>
                  For many applications, it's not important to reason about the implementation of certain functions.
  A recursive function might be used only as part of the implementation of proof automation steps, or it might be an ordinary program that will never be formally proved correct.
  In these cases, the Lean kernel does not need either definitional or propositional equalities to hold for the definition; it suffices that soundness is maintained.
  Functions marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span> are treated as opaque constants by the kernel and are neither unfolded nor reduced.
  All that is required for soundness is that their return type is inhabited.
  Partial functions may still be used in compiled code as usual, and they may appear in propositions and proofs; their equational theory in Lean's logic is simply very weak.</p>
                </dd><dt> Unsafe recursive definitions</dt><dd><p>
                  Unsafe definitions have none of the restrictions of partial definitions.
  They may freely make use of general recursion, and they may use features of Lean that break assumptions about its equational theory, such as primitives for casting (<code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#unsafeCast"><span class="const token" data-binding="const-unsafeCast" data-verso-hover="880">unsafeCast</span></a></code>), checking pointer equality (<code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#ptrAddrUnsafe"><span class="const token" data-binding="const-ptrAddrUnsafe" data-verso-hover="881">ptrAddrUnsafe</span></a></code>), and observing <a class="technical-term" href="Run-Time-Code/Reference-Counting/#--tech-term-reference-counting">reference counts</a> (<code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#isExclusiveUnsafe"><span class="const token" data-binding="const-isExclusiveUnsafe" data-verso-hover="882">isExclusiveUnsafe</span></a></code>).
  However, any declaration that refers to an unsafe definition must itself be marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">unsafe</code></span>, making it clear when logical soundness is not guaranteed.
  Unsafe operations can be used to replace the implementations of other functions with more efficient variants in compiled code, while the kernel still uses the original definition.
  The replaced function may be opaque, which results in the function name having a trivial equational theory in the logic, or it may be an ordinary function, in which case the function is used in the logic.
  Use this feature with care: logical soundness is not at risk, but the behavior of programs written in Lean may diverge from their verified logical models if the unsafe implementation is incorrect.</p>
                </dd></dl><p>
              As described in the <a href="Elaboration-and-Compilation/#elaboration-results">overview of the elaborator's output</a>, elaboration of recursive functions proceeds in two phases:</p>
            <ol start="1">
              <li>
                <p>
                  The definition is elaborated as if Lean's core type theory had recursive definitions.
    Aside from using recursion, this provisional definition is fully elaborated.
    The compiler generates code from these provisional definitions.</p>
                </li>
              <li>
                <p>
                  A termination analysis attempts to use the four techniques to justify the function to Lean's kernel.
    If the definition is marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">unsafe</code></span> or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span>, then that technique is used.
    If an explicit <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause is present, then the indicated technique is the only one attempted.
    If there is no such clause, then the elaborator performs a search, testing each parameter to the function as a candidate for structural recursion, and attempting to find a measure with a well-founded relation that decreases at each recursive call.</p>
                </li>
              </ol>
            <p>
              This section describes the rules that govern recursive functions.
After a description of mutual recursion, each of the five kinds of recursive definitions is specified, along with the tradeoffs between reasoning power and flexibility that go along with each.</p>
            <section>
              <h2 id="mutual-syntax">
                7.6.1.Â Mutual Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-syntax" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Just as a recursive definition is one that mentions the name being defined in the body of the definition, <span id="--tech-term-mutually-recursive" class="def-technical-term"><em>mutually recursive</em></span> definitions are definitions that may be recursive or mention one another.
To use mutual recursion between multiple declarations, they must be placed in a <span id="--tech-term-mutual-block" class="def-technical-term">mutual block</span>.</p>
              <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">Mutual Declaration Blocks</span><div class="text">
                  <p>
                    The general syntax for mutual recursion is:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___mutual"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.mutual"><span class="keyword">mutual</span>
        <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Command.declaration">declaration</span></span><span class="bnf">*</span>
      </span><span class="keyword">end</span></span></pre><p>
                    where the declarations must be definitions or theorems.</p>
                  </div>
                </div>
              <p>
                The declarations in a mutual block are not in scope in each others' signatures, but they are in scope in each others' bodies.
Even though the names are not in scope in signatures, they will not be inserted as auto-bound implicit parameters.</p>
              <details class="example"><summary class="description">Mutual Block Scope</summary><div class="example-content">
                  <p>
                    Names defined in a mutual block are not in scope in each others' signatures.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-9270">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.abbrev-9279">abbrev</span> <span class="const token" data-binding="const-NaturalNum" data-verso-hover="883">NaturalNum</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9313">def</span> <span class="const token" data-binding="const-n" data-verso-hover="884">n</span> <span class="unknown token" data-binding="">:</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'NaturalNum'</code></span></span><span class="unknown token" data-binding="">NaturalNum</span></span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="248">5</span>
<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-9270">end</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>unknown identifier 'NaturalNum'
</pre></div>
                  <p>
                    Without the mutual block, the definition succeeds:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.abbrev-9464">abbrev</span> <span class="const token" data-binding="const-NaturalNum" data-verso-hover="885">NaturalNum</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9496">def</span> <span class="const token" data-binding="const-n" data-verso-hover="886">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-NaturalNum" data-verso-hover="885">NaturalNum</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="887">5</span>
<span class="unknown token" data-binding=""></span></code></div>
                </details><details class="example"><summary class="description">Mutual Block Scope and Automatic Implicit Parameters</summary><div class="example-content">
                  <p>
                    Names defined in a mutual block are not in scope in each others' signatures.
Nonetheless, they cannot be used as automatic implicit parameters:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-9802">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.abbrev-9811">abbrev</span> <span class="const token" data-binding="const-Î±" data-verso-hover="888">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9837">def</span> <span class="const token" data-binding="const-identity" data-verso-hover="889">identity</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="248">x</span> <span class="unknown token" data-binding="">:</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'Î±'</code></span></span><span class="unknown token" data-binding="">Î±</span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'Î±'</code></span></span><span class="unknown token" data-binding="">Î±</span></span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="248">x</span>
<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-9802">end</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>unknown identifier 'Î±'
</pre></div>
                  <p>
                    With a different name, the implicit parameter is automatically added:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-10010">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.abbrev-10019">abbrev</span> <span class="const token" data-binding="const-Î±" data-verso-hover="888">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10045">def</span> <span class="const token" data-binding="const-identity" data-verso-hover="890">identity</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="185">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="127">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="127">Î²</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="185">x</span>
<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-10010">end</span></a>
<span class="unknown token" data-binding=""></span></code></div>
                </details><p>
                Elaborating recursive definitions always occurs at the granularity of mutual blocks, as if there were a singleton mutual block around every declaration that is not itself part of such a block.
Local definitions introduced via <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.letrec : term</code></code><code class="kw">let rec</code></span> and
 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> are lifted out of their context, introducing parameters for captured free variables as necessary, and treated as if they were separate definitions within the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><code class="kw">mutual</code></a></span> block as well. 
Thus, helpers defined in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> block may use mutual recursion both with one another and with the definition in which they occur, but they may not mention each other in their type signatures.</p>
              <p>
                After the first step of elaboration, in which definitions are still recursive, and before translating recursion using the techniques above, Lean identifies the actually (mutually) recursive cliques  among the definitions in the mutual block and processes them separately and in dependency order.</p>
              </section>
            <section>
              <h2 id="structural-recursion">
                7.6.2.Â Structural Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structural-recursion" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Structurally recursive functions are those in which each recursive call is on a structurally smaller term than the argument.
The same parameter must decrease in all recursive calls; this parameter is called the <span id="--tech-term-decreasing-parameter" class="def-technical-term"><em>decreasing parameter</em></span>.
Structural recursion is stronger than the primitive recursion that recursors provide, because the recursive call can use more deeply nested sub-terms of the argument, rather than only an immediate sub-term.
The constructions used to implement structural recursion are, however, implemented using the recursor; these helper constructions are described in the <a href="The-Type-System/Inductive-Types/#recursor-elaboration-helpers">section on inductive types</a>.</p>
              <p>
                The rules that govern structural recursion are fundamentally <em>syntactic</em> in nature.
There are many recursive definitions that exhibit structurally recursive computational behavior, but which are not accepted by these rules; this is a fundamental consequence of the analysis being fully automatic.
<a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">Well-founded recursion</a> provides a semantic approach to demonstrating termination that can be used in situations where a recursive function is not structurally recursive, but it can also be used when a function that computes according to structural recursion doesn't satisfy the syntactic requirements.</p>
              <details class="example"><summary class="description">Structural Recursion vs Subtraction</summary><div class="example-content">
                  <p>
                    The function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-countdown" data-verso-hover="891">countdown</span></code> is structurally recursive.
The parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">n</span></code> was matched against the pattern <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>, which means that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.80" data-verso-hover="7">n'</span></code> is a direct subterm of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.82" data-verso-hover="7">n</span></code> in the second branch of the pattern match:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2179">def</span> <span class="const token" data-binding="const-countdown" data-verso-hover="891">countdown</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2219" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2219" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown" data-verso-hover="891">countdown</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Replacing pattern matching with an equivalent Boolean test and subtraction results in an error:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2439">def</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">fail to show termination for
  countdown'
with errors
failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' n'


failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
n : Nat
hâœ : Â¬(n == 0) = true
n' : Nat := n - 1
âŠ¢ n - 1 &lt; n</code></span></span><span class="const token" data-binding="const-countdown'" data-verso-hover="892">countdown'</span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-2480" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">==</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-2480" data-verso-hover="137">then</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-2480" data-verso-hover="137">else</span></a>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2509" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.204" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="var token" data-binding="var-_uniq.204" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="892">countdown'</span> <span class="var token" data-binding="var-_uniq.204" data-verso-hover="7">n'</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>fail to show termination for
  countdown'
with errors
failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' n'


failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
n : Nat
hâœ : Â¬(n == 0) = true
n' : Nat := n - 1
âŠ¢ n - 1 &lt; n
</pre></div>
                  <p>
                    This is because there was no pattern matching on the parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.86" data-verso-hover="7">n</span></code>.
While this function indeed terminates, the argument that it does so is based on properties of if, the equality test, and subtraction, rather than being a generic feature of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> being an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive type</a>.
These arguments are expressed using <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, and a slight change to the function definition allows Lean's automatic support for well-founded recursion to construct an alternative termination proof.
This version branches on the decidability of <a class="technical-term" href="Basic-Propositions/Propositional-Equality/#--tech-term-Propositional-equality">propositional equality</a> for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> rather than the result of a Boolean equality test:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3752">def</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="892">countdown'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3793" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3793" data-verso-hover="137">then</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3793" data-verso-hover="137">else</span></a>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3821" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.109" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="var token" data-binding="var-_uniq.109" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="892">countdown'</span> <span class="var token" data-binding="var-_uniq.109" data-verso-hover="7">n'</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Here, Lean's automation automatically constructs a termination proof from facts about propositional equality and subtraction.
It uses well-founded recursion rather than structure recursion behind the scenes.</p>
                  </div>
                </details><p>
                Structural recursion may be used explicitly or automatically.
With explicit structural recursion, the function definition declares which parameter is the <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-decreasing-parameter">decreasing parameter</a>.
If no termination strategy is explicitly declared, Lean performs a search for a decreasing parameter as well as a decreasing measure for use with <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a>.
Explicitly annotating structural recursion has the following benefits:</p>
              <ul>
                <li>
                  <p>
                    It can speed up elaboration, because no search occurs.</p>
                  </li>
                <li>
                  <p>
                    It documents the termination argument for readers.</p>
                  </li>
                <li>
                  <p>
                    In situations where structural recursion is explicitly desired, it prevents the accidental use of well-founded recursion.</p>
                  </li>
                </ul>
              <section>
                <h3 id="The-Lean-Language-Reference--Definitions--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion">
                  7.6.2.1.Â Explicit Structural Recursion</h3>
                <p>
                  To explicitly use structural recursion, a function or theorem definition can be annotated with a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by structural</code></span> clause that specifies the <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-decreasing-parameter">decreasing parameter</a>.
The decreasing parameter may be a reference to a parameter named in the signature.
When the signature specifies a function type, the decreasing parameter may additionally be a parameter not named in the signature; in this case, names for the remaining parameters may be introduced by writing them before an arrow (<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">=&gt;</code></span>).</p>
                <details class="example"><summary class="description">Specifying Decreasing Parameters</summary><div class="example-content">
                    <p>
                      When the decreasing parameter is a named parameter to the function, it can be specified by referring to its name.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5590">def</span> <span class="const token" data-binding="const-half" data-verso-hover="893">half</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-5620" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-5620" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="893">half</span> <span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-5672" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-5687">structural</span> <span class="var token" data-binding="var-_uniq.238" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                      When the decreasing parameter is not named in the signature, a name can be introduced locally in the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5899">def</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-5961" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-5976">structural</span> <span class="var token" data-binding="var-_uniq.243" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.243" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><div class="namedocs" id="Lean___Parser___Termination___terminationBy">
                  <span class="label">syntax</span><span class="title">Explicit Structural Recursion</span><div class="text">
                    <p>
                      The <code>termination_by structural</code> clause introduces a decreasing parameter.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Termination___terminationBy-next"><span class="nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat â†’ Nat â†’ Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code>terminationBy</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat â†’ Nat â†’ Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code><span class="keyword">termination_by</span> <span class="from-nonterminal" data-kind="null"><span class="keyword">structural</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span> </span><span class="keyword">=&gt;</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      The identifiers before the optional <code>=&gt;</code> can bring function parameters into scope that are not
already bound in the declaration header, and the mandatory term must indicate one of the function's parameters, whether introduced in the header or locally in the clause.</p>
                    </div>
                  </div>
                <p>
                  The decreasing parameter must satisfy the following conditions:</p>
                <ul>
                  <li>
                    <p>
                      Its type must be an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive type</a>.</p>
                    </li>
                  <li>
                    <p>
                      If its type is an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-indexed-families">indexed family</a>, then all indices must be parameters of the function.</p>
                    </li>
                  <li>
                    <p>
                      If the inductive or indexed family of the decreasing parameter has data type parameters, then these data type parameters may themselves only depend on function parameters that are part of the <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-fixed-prefix">fixed prefix</a>.</p>
                    </li>
                  </ul>
                <p>
                  A <span id="--tech-term-fixed-parameter" class="def-technical-term"><em>fixed parameter</em></span> is a function parameter that is passed unmodified in all recursive calls and is not an index of the recursive parameter's type.
The <span id="--tech-term-fixed-prefix" class="def-technical-term"><em>fixed prefix</em></span> is the longest prefix of the function's parameters in which all are fixed.</p>
                <details class="example"><summary class="description">Ineligible decreasing parameters</summary><div class="example-content">
                    <p>
                      The decreasing parameter's type must be an inductive type.
In <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#notInductive"><span class="const token" data-binding="const-notInductive" data-verso-hover="896">notInductive</span></a></code>, a function is specified as the decreasing parameter:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7424">def</span> <span class="const token" data-binding="const-notInductive" data-verso-hover="896" id="notInductive">notInductive</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="897">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#notInductive"><span class="const token" data-binding="const-notInductive" data-verso-hover="896">notInductive</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-7482">fun</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="897">x</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">cannot use specified measure for structural recursion:
  its type is not an inductive</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-7500" data-verso-hover="894">termination_by</span></span> <span class="keyword token" data-binding="kw-occ-null-7515">structural</span> <span class="var token" data-binding="var-_uniq.79" data-verso-hover="897">x</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>cannot use specified measure for structural recursion:
  its type is not an inductive
</pre></div>
                    <p>
                      If the decreasing parameter is an indexed family, all the indices must be variables.
In <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-constantIndex" data-verso-hover="898">constantIndex</span></a></code>, the indexed family <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="899">Fin'</span></a></code> is instead applied to a constant value:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-7873" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Fin'" data-verso-hover="899" id="Fin______zero">Fin'</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-7903">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Fin'.zero" data-verso-hover="900" id="Fin______zero">zero</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="899">Fin'</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Fin'.succ" data-verso-hover="901" id="Fin______zero">succ</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="899">Fin'</span></a> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â†’</span> <a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="899">Fin'</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7965">def</span> <span class="const token" data-binding="const-constantIndex" data-verso-hover="898" id="Fin______zero">constantIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.495" data-verso-hover="902">x</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="899">Fin'</span></a> <span class="typed token" data-binding="" data-verso-hover="7">100</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-constantIndex" data-verso-hover="898">constantIndex</span></a> <a href="Definitions/Recursive-Definitions/#Fin______zero"><span class="const token" data-binding="const-Fin'.zero" data-verso-hover="900">.zero</span></a>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">cannot use specified measure for structural recursion:
  its type Fin' is an inductive family and indices are not variables
    Fin' 100</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-8027" data-verso-hover="894">termination_by</span></span> <span class="keyword token" data-binding="kw-occ-null-8042">structural</span> <span class="var token" data-binding="var-_uniq.502" data-verso-hover="902">x</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>cannot use specified measure for structural recursion:
  its type Fin' is an inductive family and indices are not variables
    Fin' 100
</pre></div>
                    <p>
                      The parameters of the decreasing parameter's type must not depend on function parameters that come after varying parameters or indices.
In <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WithParam______zero"><span class="const token" data-binding="const-afterVarying" data-verso-hover="903">afterVarying</span></a></code>, the <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-fixed-prefix">fixed prefix</a> is empty, because the first parameter <code>n</code> varies, so <code>p</code> is not part of the fixed prefix:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-8542" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-WithParam'" data-verso-hover="904" id="WithParam______zero">WithParam'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-8588">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-WithParam'.zero" data-verso-hover="905" id="WithParam______zero">zero</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="904">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-WithParam'.succ" data-verso-hover="906" id="WithParam______zero">succ</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="904">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="var token" data-binding="var-_uniq.86" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â†’</span> <a href="Definitions/Recursive-Definitions/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="904">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>

<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter x:
  failed to eliminate recursive application
    afterVarying (n + 1) p WithParam'.zero
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8674">def</span></span> <span class="const token" data-binding="const-afterVarying" data-verso-hover="903" id="WithParam______zero">afterVarying</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.549" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.551" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.553" data-verso-hover="907">x</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="904">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.551" data-verso-hover="7">p</span> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Definitions/Recursive-Definitions/#WithParam______zero"><span class="const token" data-binding="const-afterVarying" data-verso-hover="903">afterVarying</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.549" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.551" data-verso-hover="7">p</span> <a href="Definitions/Recursive-Definitions/#WithParam______zero"><span class="const token" data-binding="const-WithParam'.zero" data-verso-hover="905">.zero</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-8770" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-8785">structural</span> <span class="var token" data-binding="var-_uniq.640" data-verso-hover="907">x</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to infer structural recursion:
Cannot use parameter x:
  failed to eliminate recursive application
    afterVarying (n + 1) p WithParam'.zero
</pre></div>
                    </div>
                  </details><p>
                  Furthermore, every recursive call of the functions must be on a <span id="--tech-term-strict-sub-term" class="def-technical-term"><em>strict sub-term</em></span> of the decreasing
parameter.</p>
                <ul>
                  <li>
                    <p>
                      The decreasing parameter itself is a sub-term, but not a strict sub-term.</p>
                    </li>
                  <li>
                    <p>
                      If a sub-term is the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression or other pattern-matching syntax, the pattern that matches the discriminant is a sub-term in the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-right-hand-side">right-hand side</a> of each <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-alternatives">match alternative</a>.
   In particular, the rules of <a href="Terms/Pattern-Matching/#match-generalization">match generalization</a> are used to connect the discriminant to the occurrences of the pattern term in the right-hand side; thus, it respects <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitional equality</a>.
   The pattern is a <em>strict</em> sub-term if and only if the discriminant is a strict sub-term.</p>
                    </li>
                  <li>
                    <p>
                      If a sub-term is a constructor applied to arguments, then its recursive arguments are strict sub-terms.</p>
                    </li>
                  </ul>
                <details class="example"><summary class="description">Nested Patterns and Sub-Terms</summary><div class="example-content">
                    <p>
                      In the following example, the decreasing parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.104" data-verso-hover="7">n</span></code> is matched against the nested pattern <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.106" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span></code>. Therefore <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.109" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span></code> is a (non-strict) sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span></code>, and consequently  both <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span></code> are strict sub-terms, and the definition is accepted.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10372">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="908">fib</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>  <span class="const token" data-binding="const-fib" data-verso-hover="908">fib</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="908">fib</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-10455" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-10470">structural</span> <span class="var token" data-binding="var-_uniq.173" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.173" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                      For clarity, this example uses <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.121" data-verso-hover="7">n</span></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.124" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span></code> instead of the equivalent <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>-specific <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.129" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.194" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">2</span></code>.</p>
                    </div>
                  </details><details class="example"><summary class="description">Matching on Complex Expressions Can Prevent Elaboration</summary><div class="example-content">
                    <p>
                      In the following example, the decreasing parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.237" data-verso-hover="7">n</span></code> is not directly the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression.
Therefore, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">n'</span></code> is not considered a sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="7">n</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    half n'
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11241">def</span></span> <span class="const token" data-binding="const-half" data-verso-hover="893">half</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11271" data-verso-hover="52">match</span></a> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">Option.some</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11271" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">.some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="893">half</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-11341" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-11356">structural</span> <span class="var token" data-binding="var-_uniq.259" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    half n'
</pre></div>
                    <p>
                      Using <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, and explicitly connecting the discriminant to the pattern of the match, this definition can be accepted.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11672">def</span> <span class="const token" data-binding="const-half" data-verso-hover="893">half</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11702" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.104" data-verso-hover="909">h</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">Option.some</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11702" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">.some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="893">half</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-11776" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.287" data-verso-hover="7">n</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-11793" data-verso-hover="910">decreasing_by</span> <span class="tactic"><label for="tactic-state-18164188884838177273-11807-11815"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-11807" data-verso-hover="666">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18164188884838177273-11807-11815"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.371" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.393" data-verso-hover="7">n'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2251" data-verso-hover="911">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.371" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.393" data-verso-hover="7">n'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.393" data-verso-hover="7">n'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.393" data-verso-hover="7">n'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1</span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-11817-11822"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-11817" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-11817-11822"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      Similarly, the following example fails: although <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.269" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___tail"><span class="const token" data-binding="const-List.tail" data-verso-hover="912">tail</span></a></code> would reduce to a strict sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.283" data-verso-hover="51">xs</span></code>, this is not visible to Lean according to the rules above.
In particular, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.292" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___tail"><span class="const token" data-binding="const-List.tail" data-verso-hover="912">tail</span></a></code> is not <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally equal</a> to a strict sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.305" data-verso-hover="51">xs</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter #2:
  failed to eliminate recursive application
    listLen xs.tail
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12173">def</span></span> <span class="const token" data-binding="const-listLen" data-verso-hover="913" id="listLen">listLen</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#listLen"><span class="const token" data-binding="const-listLen" data-verso-hover="913">listLen</span></a> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___tail"><span class="const token" data-binding="const-List.tail" data-verso-hover="912">tail</span></a> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-12245" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-12260">structural</span> <span class="var token" data-binding="var-_uniq.177" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.177" data-verso-hover="51">xs</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Simultaneous Matching vs Matching Pairs for Structural Recursion</summary><div class="example-content">
                    <p>
                      An important consequence of the strategies that are used to prove termination is that <strong>simultaneous matching of two <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminants</a> is not equivalent to matching a pair</strong>.
Simultaneous matching maintains the connection between the discriminants and the patterns, allowing the pattern matching to refine the types of the assumptions in the local context as well as the expected type of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span>.
Essentially, the elaboration rules for <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> treat the discriminants specially, and changing discriminants in a way that preserves the run-time meaning of a program does not necessarily preserve the compile-time meaning.</p>
                    <p>
                      This function that finds the minimum of two natural numbers is defined by structural recursion on its first parameter:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13266">def</span> <span class="const token" data-binding="const-min'" data-verso-hover="914">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13298" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13298" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.183" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.184" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="914">min'</span> <span class="var token" data-binding="var-_uniq.183" data-verso-hover="7">n'</span> <span class="var token" data-binding="var-_uniq.184" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-13379" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-13394">structural</span> <span class="var token" data-binding="var-_uniq.369" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Replacing the simultaneous pattern match on both parameters with a match on a pair causes termination analysis to fail:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    min' n' k'
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13572">def</span></span> <span class="const token" data-binding="const-min'" data-verso-hover="914">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13604" data-verso-hover="52">match</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13604" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.220" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.221" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="914">min'</span> <span class="var token" data-binding="var-_uniq.220" data-verso-hover="7">n'</span> <span class="var token" data-binding="var-_uniq.221" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-13693" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-13708">structural</span> <span class="var token" data-binding="var-_uniq.428" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    min' n' k'
</pre></div>
                    <p>
                      This is because the analysis only considers direct pattern matching on parameters when matching recursive calls to strictly-smaller argument values.
Wrapping the discriminants in a pair breaks the connection.</p>
                    </div>
                  </details><details class="example"><summary class="description">Structural Recursion Under Pairs</summary><div class="example-content">
                    <p>
                      This function that finds the minimum of the two components of a pair can't be elaborated via structural recursion.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter nk:
  the type Nat Ã— Nat does not have a `.brecOn` recursor
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14305">def</span></span> <span class="const token" data-binding="const-min'" data-verso-hover="915">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="698">nk</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">Ã—</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14343" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="698">nk</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14343" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.215" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="915">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n'</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.215" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-14431" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-14446">structural</span> <span class="var token" data-binding="var-_uniq.425" data-verso-hover="698">nk</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to infer structural recursion:
Cannot use parameter nk:
  the type Nat Ã— Nat does not have a `.brecOn` recursor
</pre></div>
                    <p>
                      This is because the parameter's type, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">Prod</span></a></code>, is not recursive.
Thus, its constructor has no recursive parameters that can be exposed by pattern matching.</p>
                    <p>
                      This definition is accepted using <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, however:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14856">def</span> <span class="const token" data-binding="const-min'" data-verso-hover="915">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="698">nk</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">Ã—</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14894" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="698">nk</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14894" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.215" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="915">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n'</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.215" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-14982" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.425" data-verso-hover="698">nk</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Structural Recursion and Definitional Equality</summary><div class="example-content">
                    <p>
                      Even though the recursive occurrence of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-countdown" data-verso-hover="891">countdown</span></code> is applied to a term that is not a strict sub-term of the decreasing parameter, the following definition is accepted:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15312">def</span> <span class="const token" data-binding="const-countdown" data-verso-hover="891">countdown</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15352" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15352" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown" data-verso-hover="891">countdown</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-15416" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-15431">structural</span> <span class="var token" data-binding="var-_uniq.204" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                      This is because <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.316" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code> is <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally equal</a> to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.383" data-verso-hover="7">n'</span></code>, which is a strict sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.385" data-verso-hover="7">n</span></code>.
<a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-strict-sub-term">Sub-terms</a> that result from pattern matching are connected to the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> using the rules for <a href="Terms/Pattern-Matching/#match-generalization">match generalization</a>, which respect definitional equality.</p>
                    <p>
                      In <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-countdown'" data-verso-hover="892">countdown'</span></code>, the recursive occurrence is applied to <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="7">n'</span></code>, which is not definitionally equal to <code>n'</code> because addition on natural numbers is structurally recursive in its second parameter:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' (0 + n')
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16109">def</span></span> <span class="const token" data-binding="const-countdown'" data-verso-hover="892">countdown'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16150" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16150" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="892">countdown'</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n'</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-16215" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-16230">structural</span> <span class="var token" data-binding="var-_uniq.204" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' (0 + n')
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="mutual-structural-recursion">
                  7.6.2.2.Â Mutual Structural Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-structural-recursion" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  Lean supports the definition of <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutually-recursive">mutually recursive</a> functions using structural recursion.
Mutual recursion may be introduced using a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutual-block">mutual block</a>, but it also results from <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.letrec : term</code></code><code class="kw">let rec</code></span> expressions and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> blocks.
The rules for mutual structural recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the <a href="Definitions/Recursive-Definitions/#mutual-syntax">elaboration steps</a> for mutual groups.
If every function in the mutual group has a <code class="plain-keyword">termination_by structural</code> annotation indicating that functionâ€™s decreasing argument, then structural recursion is used to translate the definitions.</p>
                <p>
                  The requirements on the decreasing argument above are extended:</p>
                <ul>
                  <li>
                    <p>
                      All the types of all the decreasing arguments must be from the same inductive type, or more generally from the same <a href="The-Type-System/Inductive-Types/#mutual-inductive-types">mutual group of inductive types</a>.</p>
                    </li>
                  <li>
                    <p>
                      The parameters of the decreasing parameter's types must be the same for all functions, and may depend only on the <em>common</em> fixed prefix of function arguments.</p>
                    </li>
                  </ul>
                <p>
                  The functions do not have to be in a one-to-one correspondence to the mutual inductive types.
Multiple functions can have a decreasing argument of the same type, and not all types that are mutually recursive with the decreasing argument need have a corresponding function.</p>
                <details class="example"><summary class="description">Mutual Structural Recursion Over Non-Mutual Types</summary><div class="example-content">
                    <p>
                      The following example demonstrates mutual recursion over a non-mutual inductive data type:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18091">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18100">def</span> <span class="const token" data-binding="const-even" data-verso-hover="916" id="odd">even</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>
    <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.106" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#odd"><span class="const token" data-binding="const-odd" data-verso-hover="917">odd</span></a> <span class="var token" data-binding="var-_uniq.106" data-verso-hover="7">n</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18161" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18176">structural</span> <span class="var token" data-binding="var-_uniq.316" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.316" data-verso-hover="7">n</span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18197">def</span> <span class="const token" data-binding="const-odd" data-verso-hover="917" id="odd">odd</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>
    <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#odd"><span class="const token" data-binding="const-even" data-verso-hover="916">even</span></a> <span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">n</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18259" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18274">structural</span> <span class="var token" data-binding="var-_uniq.321" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.321" data-verso-hover="7">n</span>
<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18091">end</span></a>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Mutual Structural Recursion Over Mutual Types</summary><div class="example-content">
                    <p>
                      The following example demonstrates recursion over mutually inductive types.
The functions <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp.size" data-verso-hover="918">Exp.size</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App.size" data-verso-hover="919">App.size</span></a></code> are mutually recursive.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18526">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-18535" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Exp" data-verso-hover="920" id="Exp___app">Exp</span> <span class="keyword token" data-binding="kw-occ-null-18549">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Exp.var" data-verso-hover="921" id="Exp___app">var</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="920">Exp</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Exp.app" data-verso-hover="922" id="Exp___app">app</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="923">App</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="920">Exp</span></a>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-18609" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-App" data-verso-hover="923" id="Exp___app">App</span> <span class="keyword token" data-binding="kw-occ-null-18623">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-App.fn" data-verso-hover="924" id="Exp___app">fn</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="923">App</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-App.app" data-verso-hover="925" id="Exp___app">app</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="923">App</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="920">Exp</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="923">App</span></a>
<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18526">end</span></a>

<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18692">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18701">def</span> <span class="const token" data-binding="const-Exp.size" data-verso-hover="918" id="Exp___app">Exp.size</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="920">Exp</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
    <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp.var" data-verso-hover="921">.var</span></a> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp.app" data-verso-hover="922">.app</span></a> <span class="var token" data-binding="var-_uniq.1061" data-verso-hover="926">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1061" data-verso-hover="926">a</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App.size" data-verso-hover="919">size</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18771" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18786">structural</span> <span class="var token" data-binding="var-_uniq.1310" data-verso-hover="927">e</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1310" data-verso-hover="927">e</span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18807">def</span> <span class="const token" data-binding="const-App.size" data-verso-hover="919" id="Exp___app">App.size</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="923">App</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
    <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App.fn" data-verso-hover="924">.fn</span></a> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App.app" data-verso-hover="925">.app</span></a> <span class="var token" data-binding="var-_uniq.1153" data-verso-hover="926">a</span> <span class="var token" data-binding="var-_uniq.1154" data-verso-hover="927">e</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1153" data-verso-hover="926">a</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App.size" data-verso-hover="919">size</span></a> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.1154" data-verso-hover="927">e</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-Exp.size" data-verso-hover="918">size</span></a> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18891" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18906">structural</span> <span class="var token" data-binding="var-_uniq.1315" data-verso-hover="926">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1315" data-verso-hover="926">a</span>
<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18692">end</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      The definition of <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#App___numArgs"><span class="const token" data-binding="const-App.numArgs" data-verso-hover="928">App.numArgs</span></a></code> is structurally recursive over type <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="923">App</span></a></code>.
It demonstrates that not all inductive types in the mutual group need to be handled.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-19114">def</span> <span class="const token" data-binding="const-App.numArgs" data-verso-hover="928" id="App___numArgs">App.numArgs</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="923">App</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App.fn" data-verso-hover="924">.fn</span></a> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Exp___app"><span class="const token" data-binding="const-App.app" data-verso-hover="925">.app</span></a> <span class="var token" data-binding="var-_uniq.39" data-verso-hover="926">a</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.39" data-verso-hover="926">a</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#App___numArgs"><span class="const token" data-binding="const-App.numArgs" data-verso-hover="928">numArgs</span></a> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-19189" data-verso-hover="894">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-19204">structural</span> <span class="var token" data-binding="var-_uniq.173" data-verso-hover="926">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.173" data-verso-hover="926">a</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="inferring-structural-recursion">
                  7.6.2.3.Â Inferring Structural Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inferring-structural-recursion" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  If no <code class="plain-keyword">termination_by</code> clauses are present in a recursive or mutually recursive function definition, then Lean attempts to infer a suitable structurally decreasing argument, effectively by trying all suitable parameters in sequence.
If this search fails, Lean then attempts to infer <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a>.</p>
                <p>
                  For mutually recursive functions, all combinations of parameters are tried, up to a limit to avoid combinatorial explosion.
If only some of the mutually recursive functions have <code class="plain-keyword">termination_by structural</code> clauses, then only those parameters are considered, while for the other functions all parameters are considered for structural recursion.</p>
                <p>
                  A <code class="plain-keyword">termination_by?</code> clause causes the inferred termination annotation to be shown.
It can be automatically added to the source file using the offered suggestion or code action.</p>
                <details class="example"><summary class="description">Inferred Termination Annotations</summary><div class="example-content">
                    <p>
                      Lean automatically infers that the function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="895">half</span></code> is structurally recursive.
The <code class="plain-keyword">termination_by?</code> clause causes the inferred termination annotation to be displayed, and it can be automatically added to the source file with a single click.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20649">def</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by structural x =&gt; x</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-20711" data-verso-hover="894">termination_by?</span></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>Try this: termination_by structural x =&gt; x
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="elab-as-course-of-values">
                  7.6.2.4.Â Elaboration Using Course-of-Values Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=elab-as-course-of-values" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  In this section, the construction used to elaborate structurally recursive functions is explained in more detail.
This elaboration uses the <a href="The-Type-System/Inductive-Types/#recursor-elaboration-helpers"><code>below</code> and <code>brecOn</code> constructions</a> that are automatically generated from inductive types' recursors.</p>
                <details class="example"><summary class="description">Recursion vs Recursors</summary><div class="example-content">
                    <p>
                      Addition of natural numbers can be defined via recursion on the second argument.
This function is straightforwardly structurally recursive.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-642">def</span> <span class="const token" data-binding="const-add" data-verso-hover="929">add</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-add" data-verso-hover="929">add</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Defined using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.rec" data-verso-hover="879">Nat.rec</span></code>, it is much further from the notations that most people are used to.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-832">def</span> <span class="const token" data-binding="const-add'" data-verso-hover="931">add'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-Nat.rec" data-verso-hover="879">Nat.rec</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-875">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-900">fun</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="7">k</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="932">soFar</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="932">soFar</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Structural recursive calls made on data that isn't the immediate child of the function parameter requires either creativity or a complex yet systematic encoding.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1103">def</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.126" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="var token" data-binding="var-_uniq.126" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="unknown token" data-binding=""></span></code><p>
                      One way to think about this function is as a structural recursion that flips a bit at each call, only incrementing the result when the bit is set.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1324">def</span> <span class="const token" data-binding="const-helper" data-verso-hover="933" id="half___">helper</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-Nat.rec" data-verso-hover="879">Nat.rec</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1382">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1410">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1427">fun</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.57" data-verso-hover="934">soFar</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1448">fun</span> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="154">b</span> <span class="unknown token" data-binding="">=&gt;</span>
        <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-1466" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="154">b</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-1466" data-verso-hover="137">then</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-1466" data-verso-hover="137">else</span></a> <span class="const token" data-binding="const-id" data-verso-hover="213">id</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.57" data-verso-hover="934">soFar</span> <span class="unknown token" data-binding="">!</span><span class="var token" data-binding="var-_uniq.61" data-verso-hover="154">b</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1507">def</span> <span class="const token" data-binding="const-half'" data-verso-hover="935">half'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#half___"><span class="const token" data-binding="const-helper" data-verso-hover="933">helper</span></a> <span class="var token" data-binding="var-_uniq.190" data-verso-hover="7">n</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[0, 0, 1, 1, 2, 2, 3, 3, 4]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-1582" data-verso-hover="6">#eval</span></a></span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">4</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">6</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">7</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">8</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="const token" data-binding="const-half'" data-verso-hover="935">half'</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>[0, 0, 1, 1, 2, 2, 3, 3, 4]
</pre></div>
                    <p>
                      Instead of creativity, a general technique called <span id="--tech-term-course-of-values-recursion" class="def-technical-term">course-of-values recursion</span> can be used.
Course-of-values recursion uses helpers that can be systematically derived for every inductive type, defined in terms of the recursor; Lean derives them automatically.
For every <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">n</span></code>, the type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="936">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="937">mot</span><span class="unknown token" data-binding="">)</span></code> provides a value of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="937">mot</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="7">k</span></code> for all <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.57" data-verso-hover="7">n</span></code>, represented as an iterated  dependent pair type.
The course-of-values recursor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">Nat.brecOn</span></code> allows a function to use the result for any smaller <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.
Using it to define the function is inconvenient:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-2329">noncomputable</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2343">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="939">half''</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">Nat.brecOn</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2399">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2417">fun</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">k</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="940">soFar</span> <span class="unknown token" data-binding="">=&gt;</span>
      <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2438" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">k</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="940">soFar</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2438" data-verso-hover="52">with</span></a>
      <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="941">0</span>
      <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="var token" data-binding="var-_uniq.249" data-verso-hover="942">h</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">âŸ©</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="942">h</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="943">1</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The function is marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">noncomputable</code></span> because the compiler doesn't support generating code for course-of-values recursion, which is intended for reasoning rather that efficient code.
The kernel can still be used to test the function, however:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[0, 0, 1, 1, 2, 2, 3, 3, 4]</code></span></span><a href="Interacting-with-Lean/#Lean___reduceCmd"><span class="keyword token" data-binding="kw-occ-Lean.reduceCmd-2846" data-verso-hover="99">#reduce</span></a></span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">4</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">6</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">7</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">8</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="const token" data-binding="const-half''" data-verso-hover="939">half''</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>[0, 0, 1, 1, 2, 2, 3, 3, 4]
</pre></div>
                    <p>
                      The dependent pattern matching in the body of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half''" data-verso-hover="939">half''</span></code> can also be encoded using recursors (specifically, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="944">Nat.casesOn</span></code>), if necessary:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-3102">noncomputable</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3116">def</span> <span class="const token" data-binding="const-half'''" data-verso-hover="945" id="half_________">half'''</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">brecOn</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3169">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3187">fun</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="var token" data-binding="var-_uniq.33" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="944">casesOn</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3241">fun</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="936">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3284">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3329">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3350">fun</span> <span class="var token" data-binding="var-_uniq.93" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">=&gt;</span>
          <span class="var token" data-binding="var-_uniq.93" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="944">casesOn</span>
            <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
              <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3418">fun</span> <span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">k''</span> <span class="unknown token" data-binding="">=&gt;</span>
                <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">k''</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="936">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3472">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
                <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
            <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3525">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
            <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3550">fun</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.146" data-verso-hover="946">soFar</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.146" data-verso-hover="946">soFar</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      This definition still works.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[0, 0, 1, 1, 2, 2, 3, 3, 4]</code></span></span><a href="Interacting-with-Lean/#Lean___reduceCmd"><span class="keyword token" data-binding="kw-occ-Lean.reduceCmd-3644" data-verso-hover="99">#reduce</span></a></span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">4</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">6</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">7</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">8</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="const token" data-binding="const-half''" data-verso-hover="939">half''</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>[0, 0, 1, 1, 2, 2, 3, 3, 4]
</pre></div>
                    <p>
                      However, it is now far from the original definition and it has become difficult for most people to understand.
Recursors are an excellent logical foundation, but not an easy way to write programs or proofs.</p>
                    </div>
                  </details><p>
                  The structural recursion analysis attempts to translate the recursive <a class="technical-term" href="Elaboration-and-Compilation/#--tech-term-pre-definition">pre-definition</a> into a use of the appropriate structural recursion constructions.
At this step, pattern matching has already been translated into the use of matcher functions; these are treated specially by the termination checker.
Next, for each group of parameters, a translation using <code>brecOn</code> is attempted.</p>
                <details class="example"><summary class="description">Course-of-Values Tables</summary><div class="example-content">
                    <p>
                      This definition is equivalent to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.below" data-verso-hover="947">List.below</span></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-475">def</span> <span class="const token" data-binding="const-List.below'" data-verso-hover="948" id="List___below___">List.below'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-497" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-527" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-553" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-559">max</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">Ã—'</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="948">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      In other words, for a given <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-motive">motive</a>, <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="948">List.below'</span></a></code> is a type that contains a realization of the motive for all suffixes of the list.</p>
                    <p>
                      More recursive arguments require further nested iterations of the product type.
For instance, binary trees have two recursive occurrences.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-1109" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1130" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1140" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-1147">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="949">leaf</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.branch" data-verso-hover="950">branch</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="951">left</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="46">val</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="951">right</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Its corresponding course-of-values table contains the realizations of the motive for all subtrees:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1331">def</span> <span class="const token" data-binding="const-Tree.below'" data-verso-hover="952" id="Tree___below___">Tree.below'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1353" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-1383" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-1409" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-1415">max</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="949">.leaf</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.branch" data-verso-hover="950">.branch</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="951">left</span> <span class="var token" data-binding="var-_uniq.45" data-verso-hover="46">_val</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="951">right</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="951">left</span> <span class="unknown token" data-binding="">Ã—'</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="951">left</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="952">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">Ã—'</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="951">right</span> <span class="unknown token" data-binding="">Ã—'</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="951">right</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="952">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      For both lists and trees, the <code>brecOn</code> operator expects just a single case, rather than one per constructor.
This case accepts a list or tree along with a table of results for all smaller values; from this, it should satisfy the motive for the provided value.
Dependent case analysis of the provided value automatically refines the type of the memo table, providing everything needed.</p>
                    <p>
                      The following definitions are equivalent to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.brecOn" data-verso-hover="954">List.brecOn</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.brecOn" data-verso-hover="955">Tree.brecOn</span></code>, respectively.
The primitive recursive helpers <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#List___brecOnTable"><span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="956">List.brecOnTable</span></a></code>  and <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="957">Tree.brecOnTable</span></a></code> compute the course-of-values tables along with the final results, and the actual definitions of the <code>brecOn</code> operators simply project out the result.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2562">def</span> <span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="958" id="List___brecOnTable">List.brecOnTable</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-2589" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-2623" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="959">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="948">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">Ã—'</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="948">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2797" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2797" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ¨</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="959">step</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="961">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">,</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="961">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ©</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.107" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2877" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.129" data-verso-hover="962">res</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#List___brecOnTable"><span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="958">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="959">step</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2931" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.140" data-verso-hover="963">val</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="959">step</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.107" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.129" data-verso-hover="962">res</span>
    <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ¨</span><span class="var token" data-binding="var-_uniq.140" data-verso-hover="963">val</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">,</span> <span class="var token" data-binding="var-_uniq.129" data-verso-hover="962">res</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ©</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2993">def</span> <span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="964" id="Tree___brecOnTable">Tree.brecOnTable</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3020" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-3054" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="965">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">ys</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">ys</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="952">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">Ã—'</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">t</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="952">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-3225" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">t</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-3225" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="949">.leaf</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ¨</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="965">step</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="949">.leaf</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="961">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">,</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="961">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ©</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.branch" data-verso-hover="950">.branch</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="951">left</span> <span class="var token" data-binding="var-_uniq.104" data-verso-hover="46">val</span> <span class="var token" data-binding="var-_uniq.105" data-verso-hover="951">right</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3325" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.126" data-verso-hover="966">resLeft</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="951">left</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="964">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="965">step</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3385" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.143" data-verso-hover="967">resRight</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.105" data-verso-hover="951">right</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="964">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="965">step</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3447" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.147" data-verso-hover="968">branchRes</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ¨</span><span class="var token" data-binding="var-_uniq.126" data-verso-hover="966">resLeft</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">,</span> <span class="var token" data-binding="var-_uniq.143" data-verso-hover="967">resRight</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ©</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3492" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.154" data-verso-hover="969">val</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="965">step</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Tree.branch" data-verso-hover="950">.branch</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="951">left</span> <span class="var token" data-binding="var-_uniq.104" data-verso-hover="46">val</span> <span class="var token" data-binding="var-_uniq.105" data-verso-hover="951">right</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.147" data-verso-hover="968">branchRes</span>
    <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ¨</span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="969">val</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">,</span> <span class="var token" data-binding="var-_uniq.147" data-verso-hover="970">branchRes</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="960">âŸ©</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3581">def</span> <span class="const token" data-binding="const-List.brecOn'" data-verso-hover="971" id="List___brecOn___">List.brecOn'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3604" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-3638" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="959">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="948">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#List___brecOnTable"><span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="958">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="406">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="959">step</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3835">def</span> <span class="const token" data-binding="const-Tree.brecOn'" data-verso-hover="972" id="Tree___brecOn___">Tree.brecOn'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3858" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-3892" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="965">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">ys</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="133">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">ys</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="952">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">t</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="964">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="953">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="965">step</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  The <code>below</code> construction is a mapping from each value of a type to the results of some function call on <em>all</em> smaller values; it can be understood as a memoization table that already contains the results for all smaller values.
The notion of â€œsmaller valueâ€ that is expressed in the <code>below</code> construction corresponds directly to the definition of <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-strict-sub-term">strict sub-terms</a>.</p>
                <p>
                  Recursors expect an argument for each of the inductive type's constructors; these arguments are called with the constructor's arguments (and the result of recursion on recursive parameters) during <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-___-reduction">Î¹-reduction</a>.
The course-of-values recursion operator <code>brecOn</code>, on the other hand, expects just a single case that covers all constructors at once.
This case is provided with a value and a <code>below</code> table that contains the results of recursion on all values smaller than the given value; it should use the contents of the table to satisfy the motive for the provided value.
If the function is structurally recursive over a given parameter (or parameter group), then the results of all recursive calls will be present in this table already.</p>
                <p>
                  When the body of the recursive function is transformed into an invocation of <code>brecOn</code> on one of the function's parameters, the parameter and its course-of-values table are in scope.
The analysis traverses the body of the function, looking for recursive calls.
If the parameter is matched against, then its occurrences in the local context are <a href="Terms/Pattern-Matching/#match-generalization">generalized</a> and then instantiated with the pattern; this is also true for the type of the course-of-values table.
Typically, this pattern matching results in the type of the course-of-values table becoming more specific, which gives access to the recursive results for smaller values.
This generalization process implements the rule that patterns are <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-strict-sub-term">sub-terms</a> of match discriminants.
When an recursive occurrence of the function is detected, the course-of-values table is consulted to see whether it contains a result for the argument being checked.
If so, the recursive call can be replaced with a projection from the table.
If not, then the parameter in question doesn't support structural recursion.</p>
                <details class="example"><summary class="description">Elaboration Walkthrough</summary><div class="example-content">
                    <p>
                      The first step in walking through the elaboration of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="895">half</span></code> is to manually desugar it to a simpler form.
This doesn't match the way Lean works, but its output is much easier to read when there are fewer <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Literals/#OfNat___mk"><span class="const token" data-binding="const-OfNat" data-verso-hover="617">OfNat</span></a></code> instances present.
This readable definition:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24302">def</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="unknown token" data-binding=""></span></code><p>
                      can be rewritten to this somewhat lower-level version:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24447">def</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a> <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">|&gt;.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      The elaborator begins by elaborating a pre-definition in which recursion is still present but the definition is otherwise in Lean's core type theory.
Turning on the compiler's tracing of pre-definitions, as well as making the pretty printer more explicit, makes the resulting pre-definition visible:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25398" data-verso-hover="89">set_option</span> <span class="option token" data-binding="option-trace.Elab.definition.body" data-verso-hover="973">trace.Elab.definition.body</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25398" data-verso-hover="89">true</span> <a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-25398">in</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25444" data-verso-hover="89">set_option</span> <span class="option token" data-binding="option-pp.all" data-verso-hover="974">pp.all</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25444" data-verso-hover="89">true</span> <a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-25444">in</span></a>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[Elab.definition.body] half : Nat â†’ Nat :=
    fun (x : Nat) =&gt;
      half.match_1.{1} (fun (x : Nat) =&gt; Nat) x (fun (_ : Unit) =&gt; Nat.zero) (fun (_ : Unit) =&gt; Nat.zero)
        fun (n : Nat) =&gt; Nat.succ (half n)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25471">def</span></span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a> <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="895">half</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">|&gt;.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      The returned trace message is:</p>
                    <pre>[Elab.definition.body] half : Nat â†’ Nat :=
    fun (x : Nat) =&gt;
      half.match_1.{1} (fun (x : Nat) =&gt; Nat) x
        (fun (_ : Unit) =&gt; Nat.zero)
        (fun (_ : Unit) =&gt; Nat.zero)
        fun (n : Nat) =&gt; Nat.succ (half n)
</pre><p>
                      The auxiliary match function's definition is:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def half.match_1.{u_1} : (motive : Nat â†’ Sort u_1) â†’
  (x : Nat) â†’ (Unit â†’ motive Nat.zero) â†’ (Unit â†’ motive 1) â†’ ((n : Nat) â†’ motive n.succ.succ) â†’ motive x :=
fun motive x h_1 h_2 h_3 =&gt; Nat.casesOn x (h_1 ()) fun n =&gt; Nat.casesOn n (h_2 ()) fun n =&gt; h_3 n</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-26058">#print</span></span> <span class="const token" data-binding="const-half.match_1" data-verso-hover="975">half.match_1</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>def half.match_1.{u_1} : (motive : Nat â†’ Sort u_1) â†’
  (x : Nat) â†’ (Unit â†’ motive Nat.zero) â†’ (Unit â†’ motive 1) â†’ ((n : Nat) â†’ motive n.succ.succ) â†’ motive x :=
fun motive x h_1 h_2 h_3 =&gt; Nat.casesOn x (h_1 ()) fun n =&gt; Nat.casesOn n (h_2 ()) fun n =&gt; h_3 n
</pre></div>
                    <p>
                      Formatted more readably, this definition is:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-26494">def</span> <span class="const token" data-binding="const-half.match_1'" data-verso-hover="976">half.match_1'</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="937">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-26540" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="unknown token" data-binding="">(</span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="937">motive</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">Nat.zero</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="937">motive</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="937">motive</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="var token" data-binding="var-_uniq.5" data-verso-hover="937">motive</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-26686">fun</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="937">motive</span> <span class="var token" data-binding="var-_uniq.52" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="977">h_1</span> <span class="var token" data-binding="var-_uniq.59" data-verso-hover="978">h_2</span> <span class="var token" data-binding="var-_uniq.63" data-verso-hover="979">h_3</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="944">Nat.casesOn</span> <span class="var token" data-binding="var-_uniq.52" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.55" data-verso-hover="977">h_1</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-26741">fun</span> <span class="var token" data-binding="var-_uniq.91" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="944">Nat.casesOn</span> <span class="var token" data-binding="var-_uniq.91" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.59" data-verso-hover="978">h_2</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-26779">fun</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span>
        <span class="var token" data-binding="var-_uniq.63" data-verso-hover="979">h_3</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                      In other words, the specific configuration of patterns used in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="895">half</span></code> are captured in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half.match_1" data-verso-hover="975">half.match_1</span></code>.</p>
                    <p>
                      This definition is a more readable version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="895">half</span></code>'s pre-definition:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27006">def</span> <span class="const token" data-binding="const-half'" data-verso-hover="980">half'</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27035">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="const token" data-binding="const-half.match_1" data-verso-hover="975">half.match_1</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27080">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span>
      <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27103">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="981">0</span><span class="unknown token" data-binding="">)</span> -- Case for 0
      <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27136">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="982">0</span><span class="unknown token" data-binding="">)</span> -- Case for 1
      <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27169">fun</span> <span class="var token" data-binding="var-_uniq.45" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half'" data-verso-hover="980">half'</span> <span class="var token" data-binding="var-_uniq.45" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> -- Case for n + 2
<span class="unknown token" data-binding=""></span></code><p>
                      To elaborate it as a structurally recursive function, the first step is to establish the <code>bRecOn</code> invocation.
The definition must be marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">noncomputable</code></span> because Lean does not support code generation for recursors such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">Nat.brecOn</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-27548">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27562">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="983">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27592">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27622">fun</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="984">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
x n : Nat
table : Nat.below n
âŠ¢ Nat</code></span></span><span class="unknown token" data-binding="">_</span></span>
/- To translate:
    half.match_1 (motive := fun _ =&gt; Nat) x
      (fun _ =&gt; 0) -- Case for 0
      (fun _ =&gt; 0) -- Case for 1
      (fun n =&gt; Nat.succ (half' n)) -- Case for n + 2
-/
<span class="unknown token" data-binding=""></span></code><p>
                      The next step is to replace occurrences of <code>x</code> in the original function body with the <code>n</code> provided by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">brecOn</span></code>.
Because <code>table</code>'s type depends on <code>x</code>, it must also be generalized when splitting cases with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half.match_1" data-verso-hover="975">half.match_1</span></code>, leading to a motive with an extra parameter.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-28185">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28199">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="983">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28229">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28259">fun</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="984">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half.match_1" data-verso-hover="975">half.match_1</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28323">fun</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="936">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28363">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_1'
context:
x n : Nat
table : Nat.below n
âŠ¢ Unit â†’ (fun k =&gt; Nat.below k â†’ Nat) Nat.zero</code></span></span><span class="unknown token" data-binding="">_</span></span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_2'
context:
x n : Nat
table : Nat.below n
âŠ¢ Unit â†’ (fun k =&gt; Nat.below k â†’ Nat) 1</code></span></span><span class="unknown token" data-binding="">_</span></span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_3'
context:
x n : Nat
table : Nat.below n
âŠ¢ (n : Nat) â†’ (fun k =&gt; Nat.below k â†’ Nat) n.succ.succ</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="unknown token" data-binding="">)</span>
      <span class="var token" data-binding="var-_uniq.31" data-verso-hover="984">table</span>
/- To translate:
      (fun _ =&gt; 0) -- Case for 0
      (fun _ =&gt; 0) -- Case for 1
      (fun n =&gt; Nat.succ (half' n)) -- Case for n + 2
-/
<span class="unknown token" data-binding=""></span></code><p>
                      The three cases' placeholders expect the following types:</p>
                    <div class="error">
                      <pre>don't know how to synthesize placeholder for argument 'h_1'
context:
x n : Nat
table : Nat.below n
âŠ¢ Unit â†’ (fun k =&gt; Nat.below k â†’ Nat) Nat.zero
</pre></div>
                    <div class="error">
                      <pre>don't know how to synthesize placeholder for argument 'h_2'
context:
x n : Nat
table : Nat.below n
âŠ¢ Unit â†’ (fun k =&gt; Nat.below k â†’ Nat) 1
</pre></div>
                    <div class="error">
                      <pre>don't know how to synthesize placeholder for argument 'h_3'
context:
x n : Nat
table : Nat.below n
âŠ¢ (n : Nat) â†’ (fun k =&gt; Nat.below k â†’ Nat) n.succ.succ
</pre></div>
                    <p>
                      The first two cases in the pre-definition are constant functions, with no recursion to check:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-29353">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-29367">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="983">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29397">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29427">fun</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="984">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half.match_1" data-verso-hover="975">half.match_1</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29491">fun</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="936">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29531">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29585">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29613">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_3'
context:
x n : Nat
table : Nat.below n
âŠ¢ (n : Nat) â†’ (fun k =&gt; Nat.below k â†’ Nat) n.succ.succ</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="unknown token" data-binding="">)</span>
      <span class="var token" data-binding="var-_uniq.31" data-verso-hover="984">table</span>
/- To translate:
      (fun n =&gt; Nat.succ (half' n)) -- Case for n + 2
-/
<span class="unknown token" data-binding=""></span></code><p>
                      The final case contains a recursive call.
It should be translated into a lookup into the course-of-values table.
A more readable representation of the last hole's type is:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.509" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
<span class="const token" data-binding="const-Nat.below" data-verso-hover="936">Nat.below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29953">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.509" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a> <span class="unknown token" data-binding="">â†’</span>
<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code><p>
                      which is equivalent to</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.524" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">Ã—'</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">Ã—'</span> <span class="const token" data-binding="const-Nat.below" data-verso-hover="936">Nat.below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30078">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.524" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code><p>
                      The first <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> in the course-of-values table is the result of recursion on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.541" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>, and the second is the result of recursion on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.606" data-verso-hover="7">n</span></code>.
The recursive call can thus be replaced by a lookup, and the elaboration is successful:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-30655">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-30669">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="983">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30699">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="938">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30729">fun</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="984">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half.match_1" data-verso-hover="975">half.match_1</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30793">fun</span> <span class="var token" data-binding="var-_uniq.37" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="var token" data-binding="var-_uniq.37" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="936">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30833">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30887">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30915">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="930">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30943">fun</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="946">table</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="946">table</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span>
      <span class="var token" data-binding="var-_uniq.33" data-verso-hover="984">table</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unexpected end of input; expected ')', ',' or ':'</code></span></span><span class="unknown token" data-binding=""></span></span></code><p>
                      The actual elaborator keeps track of the relationship between the parameter being checked for structural recursion and the positions in the course-of-values tables by inserting sentinel types with fresh names into the motive.</p>
                    </div>
                  </details></section>
              </section>
            <section>
              <h2 id="well-founded-recursion">
                7.6.3.Â Well-Founded Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=well-founded-recursion" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Functions defined by <span id="--tech-term-well-founded-recursion-next" class="def-technical-term"><em>well-founded recursion</em></span> are those in which each recursive call has arguments that are <em>smaller</em> (in a <a href="Definitions/Recursive-Definitions/#wf-rel">suitable sense</a>) than the functions' parameters.
In contrast to <a href="Definitions/Recursive-Definitions/#structural-recursion">structural recursion</a>, in which recursive definitions must satisfy particular <em>syntactic</em> requirements, definitions that use well-founded recursion employ <em>semantic</em> arguments.
This allows a larger class of recursive definitions to be accepted.
Furthermore, when Lean's automation fails to construct a termination proof, it is possible to specify one manually.</p>
              <p>
                All definitions are treated identically by the Lean compiler.
In Lean's logic, definitions that use well-founded recursion typically do not reduce <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a>.
The reductions do hold as propositional equalities, however, and Lean automatically proves them.
This does not typically make it more difficult to prove properties of definitions that use well-founded recursion, because the propositional reductions can be used to reason about the behavior of the function.
It does mean, however, that using these functions in types typically does not work well.
Even when the reduction behavior happens to hold definitionally, it is often much slower than structurally recursive definitions in the kernel, which must unfold the termination proof along with the definition.
When possible, recursive function that are intended for use in types or in other situations where definitional equality is important should be defined with structural recursion.</p>
              <p>
                To explicitly use well-founded recursion, a function or theorem definition can be annotated with a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause that specifies the <span id="--tech-term-measure-next" class="def-technical-term"><em>measure</em></span> by which the function terminates.
The measure should be a term that decreases at each recursive call; it may be one of the function's parameters or a tuple of the parameters, but it may also be any other term.
The measure's type must be equipped with a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-relation">well-founded relation</a>, which determines what it means for the measure to decrease.</p>
              <div class="namedocs" id="Lean___Parser___Termination___terminationBy-next-next">
                <span class="label">syntax</span><span class="title">Explicit Well-Founded Recursion</span><div class="text">
                  <p>
                    The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause introduces the termination argument.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Termination___terminationBy-next-next-next"><span class="nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat â†’ Nat â†’ Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code>terminationBy</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat â†’ Nat â†’ Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code><span class="keyword">termination_by</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span> </span><span class="keyword">=&gt;</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                    The identifiers before the optional <code>=&gt;</code> can bring function parameters into scope that are not
already bound in the declaration header, and the mandatory term must indicate one of the function's parameters, whether introduced in the header or locally in the clause.</p>
                  </div>
                </div>
              <details class="example"><summary class="description">Division by Iterated Subtraction</summary><div class="example-content">
                  <p>
                    Division can be specified as the number of times the divisor can be subtracted from the dividend.
This operation cannot be elaborated using structural recursion because subtraction is not pattern matching.
The value of <code>n</code> does decrease with each recursive call, so well-founded recursion can be used to justify the definition of division by iterated subtraction.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3616">def</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3647" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3647" data-verso-hover="137">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3647" data-verso-hover="137">else</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3670" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3670" data-verso-hover="137">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3670" data-verso-hover="137">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-3711" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.178" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code></div>
                </details><section>
                <h3 id="wf-rel">
                  7.6.3.1.Â Well-Founded Relations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=wf-rel" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  A relation <code>â‰º</code> is a <span id="--tech-term-well-founded-relation" class="def-technical-term"><em>well-founded relation</em></span> if there exists no infinitely descending chain</p>
                <p>
                  <code class="math display"> x_0 â‰» x_1 â‰» \cdots</code></p>
                <p>
                  In Lean, types that are equipped with a canonical well-founded relation are instances of the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="986">WellFoundedRelation</span></a></code> type class.</p>
                <div class="namedocs" id="WellFoundedRelation___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=WellFoundedRelation.wf" title="Permalink">ðŸ”—</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only">WellFoundedRelation.{u} (<span class="var token" data-binding="var-_uniq.21" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>) : <span class="sort token" data-binding="" data-verso-hover="169">Sort (max 1 u)</span></div><div class="narrow-only">WellFoundedRelation.{u} (<span class="var token" data-binding="var-_uniq.21" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>) :
  <span class="sort token" data-binding="" data-verso-hover="169">Sort (max 1 u)</span></div></pre><div class="text">
                    <p>
                      A type that has a standard well-founded relation.</p>
                    <p>
                      Instances are used to prove that functions terminate using well-founded recursion by showing that
recursive calls reduce some measure according to a well-founded relation. This relation can combine
well-founded relations on the recursive function's parameters.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.mk" data-verso-hover="987">WellFoundedRelation.mk</span></a>.{u}</pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="988">rel</span> : <span class="var token" data-binding="var-_uniq.6" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.6" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="docs">
                        <p>
                          A well-founded relation on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.23" data-verso-hover="168">Î±</span></code>.</p>
                        </div>
                      </section>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-WellFoundedRelation.wf" data-verso-hover="989">wf</span> : <a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a> <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="991">WellFoundedRelation.rel</span></a></pre><div class="docs">
                        <p>
                          A proof that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.28" data-verso-hover="498">rel</span></code> is, in fact, well-founded.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <p>
                  The most important instances are:</p>
                <ul>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, ordered by <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">)</span></code>.</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">Prod</span></a></code>, ordered lexicographically: <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.138" data-verso-hover="46">aâ‚</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.142" data-verso-hover="185">bâ‚</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â‰º</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.140" data-verso-hover="46">aâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.144" data-verso-hover="185">bâ‚‚</span><span class="unknown token" data-binding="">)</span></code> if and only if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.198" data-verso-hover="46">aâ‚</span> <span class="unknown token" data-binding="">â‰º</span> <span class="var token" data-binding="var-_uniq.200" data-verso-hover="46">aâ‚‚</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.232" data-verso-hover="46">aâ‚</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.234" data-verso-hover="46">aâ‚‚</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.265" data-verso-hover="185">bâ‚</span> <span class="unknown token" data-binding="">â‰º</span> <span class="var token" data-binding="var-_uniq.267" data-verso-hover="185">bâ‚‚</span></code>.</p>
                    </li>
                  <li>
                    <p>
                      Every type that is an instance of the <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a></code> type class, which provides a method <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">SizeOf.sizeOf</span></a></code>, has a well-founded relation.
  For these types, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.370" data-verso-hover="993">xâ‚</span> <span class="unknown token" data-binding="">â‰º</span> <span class="var token" data-binding="var-_uniq.372" data-verso-hover="993">xâ‚‚</span></code> if and only if <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.408" data-verso-hover="993">xâ‚</span> <span class="unknown token" data-binding="">&lt;</span> <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.410" data-verso-hover="993">xâ‚‚</span></code>. For <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive types</a>, a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a></code> instance is automatically derived by Lean.</p>
                    </li>
                  </ul>
                <p>
                  Note that there exists a low-priority instance <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-instSizeOfDefault" data-verso-hover="994">instSizeOfDefault</span></code> that provides a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a></code> instance for any type, and always returns <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span></code>.
This instance cannot be used to prove that a function terminates using well-founded recursion because <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">&lt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code> is false.</p>
                <details class="example"><summary class="description">Default Size Instance</summary><div class="example-content">
                    <p>
                      Function types in general do not have a well-founded relation that's useful for termination proofs.
<a href="Type-Classes/Instance-Synthesis/#instance-synth">Instance synthesis</a> thus selects <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-instSizeOfDefault" data-verso-hover="994">instSizeOfDefault</span></code> and the corresponding well-founded relation.
If the measure is a function, the default <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a></code> instance is selected and the proof cannot succeed.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5897">def</span> <span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="const token" data-binding="const-fooInst" data-verso-hover="995" id="fooInst">fooInst</span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="996">b</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#fooInst"><span class="const token" data-binding="const-fooInst" data-verso-hover="995">fooInst</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="996">b</span> <span class="unknown token" data-binding="">âˆ˜</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="996">b</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-5957" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="996">b</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-5974" data-verso-hover="910">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-760021752356068850-5990-6075"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-5990" data-verso-hover="997">guard_target</span></a> <span class="unknown token" data-binding="">=</span>
    <span class="unknown token" data-binding="">@</span><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-instSizeOfDefault" data-verso-hover="994">instSizeOfDefault</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span> <span class="unknown token" data-binding="">âˆ˜</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;</span> <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-760021752356068850-5990-6075"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <a href="The-Type-System/Functions/#Function___comp"><span class="const token" data-binding="const-Function.comp" data-verso-hover="181">(</span></a><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span><a href="The-Type-System/Functions/#Function___comp"><span class="const token" data-binding="const-Function.comp" data-verso-hover="181"> âˆ˜ </span></a><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span><a href="The-Type-System/Functions/#Function___comp"><span class="const token" data-binding="const-Function.comp" data-verso-hover="181">)</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18106933795060064560-6078-6112"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-6078" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-6083">only</span> <span class="unknown token" data-binding="">[</span><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-default.sizeOf" data-verso-hover="998">default.sizeOf</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18106933795060064560-6078-6112"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18106933795060064560-6115-6135"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-6115" data-verso-hover="997">guard_target</span></a> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">&lt;</span> <span class="typed token" data-binding="" data-verso-hover="999">0</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18106933795060064560-6115-6135"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-11062093090351597211-6138-6142"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-6138" data-verso-hover="36">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11062093090351597211-6138-6142"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-11062093090351597211-6145-6165"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-6145" data-verso-hover="997">guard_target</span></a> <span class="unknown token" data-binding="">=</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11062093090351597211-6145-6165"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="996">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-6168-6173"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-6168" data-verso-hover="11">sorry</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6168-6173"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Termination-proofs">
                  7.6.3.2.Â Termination proofs</h3>
                <p>
                  Once a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> is specified and its <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-relation">well-founded relation</a> is determined, Lean determines the termination proof obligation for every recursive call.</p>
                <p>
                  The proof obligation for each recursive call is of the form <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.633" data-verso-hover="1000">g</span> <span class="var token" data-binding="var-_uniq.638" data-verso-hover="46">aâ‚</span> <span class="var token" data-binding="var-_uniq.642" data-verso-hover="1001">aâ‚‚</span> <span class="unknown token" data-binding="">â€¦</span> <span class="unknown token" data-binding="">â‰º</span> <span class="var token" data-binding="var-_uniq.633" data-verso-hover="1000">g</span> <span class="var token" data-binding="var-_uniq.640" data-verso-hover="46">pâ‚</span> <span class="var token" data-binding="var-_uniq.644" data-verso-hover="1002">pâ‚‚</span> <span class="unknown token" data-binding="">â€¦</span></code>, where:</p>
                <ul>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.695" data-verso-hover="1000">g</span></code> is the measure as a function of the parameters,</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="991">â‰º</span></a></code> is the inferred well-founded relation,</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.869" data-verso-hover="46">aâ‚</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.926" data-verso-hover="1001">aâ‚‚</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">â€¦</span></code> are the arguments of the recursive call and</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1030" data-verso-hover="46">pâ‚</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1087" data-verso-hover="1002">pâ‚‚</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">â€¦</span></code> are the parameters of the function definition.</p>
                    </li>
                  </ul>
                <p>
                  The context of the proof obligation is the local context of the recursive call.
In particular, local assumptions (such as those introduced by <code>if h : _</code>, <code>match h : _ with </code> or <code>have</code>) are available.
If a function parameter is the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a pattern match (e.g. by a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression), then this parameter is refined to the matched pattern in the proof obligation.</p>
                <p>
                  The overall termination proof obligation consists of one goal for each recursive call.
By default, the tactic <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1003">decreasing_trivial</span></a></code> is used to prove each proof obligation.
A custom tactic script can be provided using the optional <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause, which comes after the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause.
This tactic script is run once, with one goal for each proof obligation, rather than separately on each proof obligation.</p>
                <details class="example"><summary class="description">Termination Proof Obligations</summary><div class="example-content">
                    <p>
                      The following recursive definition of the Fibonacci numbers has two recursive calls, which results in two goals in the termination proof.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8426">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-8449" data-verso-hover="1005">if</span></a> <span class="var token" data-binding="var-_uniq.58" data-verso-hover="1006">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-8449" data-verso-hover="1005">then</span></a>
    <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-8449" data-verso-hover="1005">else</span></a>
    <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-8512" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.353" data-verso-hover="7">n</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
h : Â¬n â‰¤ 1
âŠ¢ n - 1 &lt; n

n : Nat
h : Â¬n â‰¤ 1
âŠ¢ n - 2 &lt; n</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-8529" data-verso-hover="910">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-15030898698996344131-8545-8549"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-8545" data-verso-hover="1007">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15030898698996344131-8545-8549"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.507" data-verso-hover="1008">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.507" data-verso-hover="1008">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1293" data-verso-hover="1008">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1293" data-verso-hover="1008">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1290" data-verso-hover="7">n</span></span></span></span></div>
                      </div>
                    <p>
                      Here, the <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> is simply the parameter itself, and the well-founded order is the less-than relation on natural numbers.
The first proof goal requires the user to prove that the argument of the first recursive call, namely <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1303" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>, is strictly smaller than the function's parameter, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1343" data-verso-hover="7">n</span></code>.</p>
                    <p>
                      Both termination proofs can be easily discharged using the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="" data-verso-hover="386">omega</span></a></code> tactic.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9348">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-9371" data-verso-hover="1005">if</span></a> <span class="var token" data-binding="var-_uniq.58" data-verso-hover="1006">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-9371" data-verso-hover="1005">then</span></a>
    <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-9371" data-verso-hover="1005">else</span></a>
    <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-9434" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.353" data-verso-hover="7">n</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-9451" data-verso-hover="910">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-3452783141316455114-9467-9469"><span class="unknown token" data-binding="">Â·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3452783141316455114-9467-9469"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.507" data-verso-hover="1008">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-9470-9475"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-9470" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9470-9475"><span class="tactic-state">All goals completed! ðŸ™</span></span>
  <span class="tactic"><label for="tactic-state-5931188903526885698-9478-9480"><span class="unknown token" data-binding="">Â·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5931188903526885698-9478-9480"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.507" data-verso-hover="1008">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.505" data-verso-hover="7">n</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-9481-9486"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-9481" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9481-9486"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Refined Parameters</summary><div class="example-content">
                    <p>
                      If a parameter of the function is the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a pattern match, then the proof obligations mention the refined parameter.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9786">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="908">fib</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-fib" data-verso-hover="908">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.48" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="908">fib</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="7">n</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-9866" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.209" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.209" data-verso-hover="7">n</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
âŠ¢ n + 1 &lt; n.succ.succ

n : Nat
âŠ¢ n &lt; n.succ.succ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-9888" data-verso-hover="910">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-6135012683526989706-9904-9908"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-9904" data-verso-hover="1007">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6135012683526989706-9904-9908"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.338" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.338" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.338" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.338" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.338" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.338" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1428" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1428" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1428" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1428" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1428" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1428" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></div>
                      </div>
                    </div>
                  </details><div class="paragraph">
                  <p>
                    Additionally, the context is enriched with additional assumptions that can make it easier to prove termination.
Some examples include:</p>
                  <ul>
                    <li>
                      <p>
                        In the branches of an <a href="Terms/Conditionals/#if-then-else">if-then-else</a> expression, a hypothesis that asserts the current branch's condition is added, much as if the dependent if-then-else syntax had been used.</p>
                      </li>
                    <li>
                      <p>
                        In the function argument to certain higher-order functions, the context of the function's body is enriched with assumptions about the argument.</p>
                      </li>
                    </ul>
                  <p>
                    This list is not exhaustive, and the mechanism is extensible.
It is described in detail in <a href="Definitions/Recursive-Definitions/#well-founded-preprocessing">the section on preprocessing</a>.</p>
                  </div>
                <details class="example"><summary class="description">Enriched Proof Obligation Contexts</summary><div class="example-content">
                    <p>
                      Here, the <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> does not add a local assumption about the condition (that is, whether <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1443" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>) to the local contexts in the branches.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11260">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11283" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11283" data-verso-hover="137">then</span></a>
    <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11283" data-verso-hover="137">else</span></a>
    <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1004">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-11342" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.322" data-verso-hover="7">n</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
hâœ : Â¬n â‰¤ 1
âŠ¢ n - 1 &lt; n

n : Nat
hâœ : Â¬n â‰¤ 1
âŠ¢ n - 2 &lt; n</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-11359" data-verso-hover="910">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-451876702722473469-11375-11379"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-11375" data-verso-hover="1007">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-451876702722473469-11375-11379"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.562" data-verso-hover="1008">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.562" data-verso-hover="1008">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="7">n</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      Nevertheless, the assumptions are available in the context of the termination proof:</p>
                    <div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1620" data-verso-hover="1008">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1620" data-verso-hover="1008">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1617" data-verso-hover="7">n</span></span></span></span></div>
                      </div>
                    <p>
                      Termination proof obligations in body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>â€‹<code>â€¦</code>â€‹<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span> loop are also enriched, in this case with a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Std.Range" data-verso-hover="1009">Std.Range</span></code> membership hypothesis:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12148">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1010">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="158">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id___run"><span class="const token" data-binding="const-Id.run" data-verso-hover="1011">Id.run</span></a> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-12187">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-12192">let</span> <span class="keyword token" data-binding="kw-occ-null-12196">mut</span> <span class="var token" data-binding="var-_uniq.201" data-verso-hover="7">s</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="158">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___sum"><span class="const token" data-binding="const-Array.sum" data-verso-hover="1012">sum</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-12214" data-verso-hover="1013">for</span> <span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">i</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-12218">in</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="158">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-12214" data-verso-hover="1013">do</span>
    <span class="var token" data-binding="var-_uniq.201" data-verso-hover="7">s</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.201" data-verso-hover="7">s</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-f" data-verso-hover="1010">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="158">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___take"><span class="const token" data-binding="const-Array.take" data-verso-hover="1014">take</span></a> <span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">i</span><span class="unknown token" data-binding="">)</span>
  <a href="Functors___-Monads-and--do--Notation/#Pure___mk"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1015">pure</span></a> <span class="var token" data-binding="var-_uniq.201" data-verso-hover="7">s</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-12273" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.421" data-verso-hover="158">xs</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
xs : Array Nat
i : Nat
hâœ : i âˆˆ { stop := xs.size, step_pos := Nat.zero_lt_one }
âŠ¢ sizeOf (xs.take i) &lt; sizeOf xs</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-12291" data-verso-hover="910">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-9943712708038578850-12307-12311"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-12307" data-verso-hover="1007">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9943712708038578850-12307-12311"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.856" data-verso-hover="158">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.859" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.860" data-verso-hover="1016">hâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.859" data-verso-hover="7">i</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018">{ </span><span class="const token" data-binding="const-Std.Range.stop" data-verso-hover="366">stop</span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018"> := </span><span class="var token" data-binding="var-_uniq.856" data-verso-hover="158">xs</span>.<a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018">, </span><span class="const token" data-binding="const-Std.Range.step_pos" data-verso-hover="1019">step_pos</span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018"> := </span><span class="const token" data-binding="const-Nat.zero_lt_one" data-verso-hover="1020">Nat.zero_lt_one</span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018"> }</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> (<span class="var token" data-binding="var-_uniq.856" data-verso-hover="158">xs</span>.<a href="Basic-Types/Arrays/#Array___take"><span class="const token" data-binding="const-Array.take" data-verso-hover="1014">take</span></a> <span class="var token" data-binding="var-_uniq.859" data-verso-hover="7">i</span>)<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.856" data-verso-hover="158">xs</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1746" data-verso-hover="158">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1747" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="1016">hâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1747" data-verso-hover="7">i</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018">{ </span><span class="const token" data-binding="const-Std.Range.stop" data-verso-hover="366">stop</span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018"> := </span><span class="var token" data-binding="var-_uniq.1746" data-verso-hover="158">xs</span>.<a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018">, </span><span class="const token" data-binding="const-Std.Range.step_pos" data-verso-hover="1019">step_pos</span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018"> := </span><span class="const token" data-binding="const-Nat.zero_lt_one" data-verso-hover="1020">Nat.zero_lt_one</span><span class="const token" data-binding="const-Std.Range.mk" data-verso-hover="1018"> }</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> (<span class="var token" data-binding="var-_uniq.1746" data-verso-hover="158">xs</span>.<a href="Basic-Types/Arrays/#Array___take"><span class="const token" data-binding="const-Array.take" data-verso-hover="1014">take</span></a> <span class="var token" data-binding="var-_uniq.1747" data-verso-hover="7">i</span>)<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.1746" data-verso-hover="158">xs</span></span></span></span></div>
                      </div>
                    <p>
                      Similarly, in the following (contrived) example, the termination proof contains an additional assumption showing that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1752" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">âˆˆ</span> <span class="var token" data-binding="var-_uniq.1755" data-verso-hover="1021">xs</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12957">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1022">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="1021">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Basic-Types/Linked-Lists/#List___sum"><span class="const token" data-binding="const-List.sum" data-verso-hover="1023">List.sum</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="1021">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13018">fun</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-f" data-verso-hover="1022">f</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-13036" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.70" data-verso-hover="1021">xs</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
xs : List Nat
x : Nat
hâœ : x âˆˆ xs
âŠ¢ sizeOf [] &lt; sizeOf xs</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-13054" data-verso-hover="910">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-6646084732562436574-13070-13074"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-13070" data-verso-hover="1007">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6646084732562436574-13070-13074"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.387" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.388" data-verso-hover="1021">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.419" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.420" data-verso-hover="1024">hâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.419" data-verso-hover="7">x</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="var token" data-binding="var-_uniq.388" data-verso-hover="1021">xs</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.388" data-verso-hover="1021">xs</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1842" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1843" data-verso-hover="1021">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1845" data-verso-hover="1024">hâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="7">x</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="var token" data-binding="var-_uniq.1843" data-verso-hover="1021">xs</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.1843" data-verso-hover="1021">xs</span></span></span></span></div>
                      </div>
                    <p>
                      This feature requires special setup for the higher-order function under which the recursive call is nested, as described in <a href="Definitions/Recursive-Definitions/#well-founded-preprocessing">the section on preprocessing</a>.
In the following definition, identical to the one above except using a custom, equivalent function instead of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">List.map</span></a></code>, the proof obligation context is not enriched:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13905">def</span> <span class="const token" data-binding="const-List.myMap" data-verso-hover="1025" id="f-next-next">List.myMap</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">@</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">List.map</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13933">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1022">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="1021">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Basic-Types/Linked-Lists/#List___sum"><span class="const token" data-binding="const-List.sum" data-verso-hover="1023">List.sum</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="1021">xs</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#f-next-next"><span class="const token" data-binding="const-List.myMap" data-verso-hover="1025">myMap</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13996">fun</span> <span class="var token" data-binding="var-_uniq.63" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-f" data-verso-hover="1022">f</span> <span class="var token" data-binding="var-_uniq.63" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-14014" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="1021">xs</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
xs : List Nat
x : Nat
âŠ¢ sizeOf [] &lt; sizeOf xs</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-14032" data-verso-hover="910">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-9239374172531275093-14048-14052"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-14048" data-verso-hover="1007">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9239374172531275093-14048-14052"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.269" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.270" data-verso-hover="1021">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.275" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.270" data-verso-hover="1021">xs</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1889" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1890" data-verso-hover="1021">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1891" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.1890" data-verso-hover="1021">xs</span></span></span></span></div>
                      </div>
                    </div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic">
                  7.6.3.3.Â Default Termination Proof Tactic</h3>
                <p>
                  If no <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause is given, then the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1026">decreasing_tactic</span></a></code> is used implicitly, and applied to each proof obligation separately.</p>
                <div class="namedocs" id="decreasing_tactic">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticDecreasing_tactic" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1026">decreasing_tactic</span></a></pre><div class="text">
                    <p>
                      The tactic <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1026">decreasing_tactic</span></a></code> mainly deals with lexicographic ordering of tuples, applying <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1027">Prod.Lex.right</span></code> if the left components of the product are <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally equal</a>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1028">Prod.Lex.left</span></code> otherwise.
After preprocessing tuples this way, it calls the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1003">decreasing_trivial</span></a></code> tactic.</p>
                    </div>
                  </div>
                <div class="namedocs" id="decreasing_trivial">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticDecreasing_trivial" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1003">decreasing_trivial</span></a></pre><div class="text">
                    <p>
                      Extensible helper tactic for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_tactic-0" data-verso-hover="1026">decreasing_tactic</span></a></code>. This handles the "base case"
reasoning after applying lexicographic order lemmas.
It can be extended by adding more macro definitions, e.g.</p>
                    <pre>macro_rules | `(tactic| decreasing_trivial) =&gt; `(tactic| linarith)
</pre><p>
                      The tactic <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1003">decreasing_trivial</span></a></code> is an extensible tactic that applies a few common heuristics to solve a termination goal.
In particular, it tries the following tactics and theorems:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith"><span class="keyword token" data-binding="" data-verso-hover="723">simp_arith</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="" data-verso-hover="1029">assumption</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          theorems <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.sub_succ_lt_self" data-verso-hover="1030">Nat.sub_succ_lt_self</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.pred_lt_of_lt" data-verso-hover="1031">Nat.pred_lt_of_lt</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.pred_lt" data-verso-hover="1032">Nat.pred_lt</span></code>, which handle common arithmetic goals</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="" data-verso-hover="386">omega</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1033">array_get_dec</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1034">array_mem_dec</span></code>, which prove that the size of array elements is less than the size of the array</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1035">sizeOf_list_dec</span></code> that the size of list elements is less than the size of the list</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String.Iterator.sizeOf_next_lt_of_hasNext" data-verso-hover="1036">String.Iterator.sizeOf_next_lt_of_hasNext</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String.Iterator.sizeOf_next_lt_of_atEnd" data-verso-hover="1037">String.Iterator.sizeOf_next_lt_of_atEnd</span></code>, to handle iteration through a string using  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span></p>
                        </li>
                      </ul>
                    <p>
                      This tactic is intended to be extended with further heuristics using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span>.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">No Backtracking of Lexicographic Order</summary><div class="example-content">
                    <p>
                      A classic example of a recursive function that needs a more complex <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> is the Ackermann function:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16515">def</span> <span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span>     <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-16641" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.424" data-verso-hover="1039">m</span> <span class="var token" data-binding="var-_uniq.427" data-verso-hover="1040">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.424" data-verso-hover="1039">m</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.427" data-verso-hover="1040">n</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The measure is a tuple, so every recursive call has to be on arguments that are lexicographically smaller than the parameters.
The default <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1026">decreasing_tactic</span></a></code> can handle this.</p>
                    <p>
                      In particular, note that the third recursive call has a second argument that is smaller than the second parameter and a first argument that is definitionally equal to the first parameter.
This allowed  <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1026">decreasing_tactic</span></a></code> to apply <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1027">Prod.Lex.right</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1027">Prod.Lex.right</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="498">ra</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1041">rb</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="187">Î²</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="187">Î²</span> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="185">bâ‚</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="185">bâ‚‚</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1042">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1041">rb</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="185">bâ‚</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="185">bâ‚‚</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1043">Prod.Lex</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="498">ra</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1041">rb</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="46">a</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="185">bâ‚</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="46">a</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="185">bâ‚‚</span><span class="unknown token" data-binding="">)</span></code><p>
                      It fails, however, with the following modified function definition, where the third recursive call's first argument is provably smaller or equal to the first parameter, but not syntactically equal:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-17561">def</span> <span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span>     <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
âŠ¢ m / 2 + 1 &lt; m + 1</code></span></span><span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-17703" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.487" data-verso-hover="7">m</span> <span class="var token" data-binding="var-_uniq.490" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.487" data-verso-hover="7">m</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.490" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
âŠ¢ m / 2 + 1 &lt; m + 1
</pre></div>
                    <p>
                      Because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1027">Prod.Lex.right</span></code> is not applicable, the tactic used <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1028">Prod.Lex.left</span></code>, which resulted in the unprovable goal above.</p>
                    <p>
                      This function definition may require a manual proof that uses the more general theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1045">Prod.Lex.right'</span></code>, which allows the first component of the tuple (which must be of type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>) to be less or equal instead of strictly equal:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1045">Prod.Lex.right'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î²</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1041">rb</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î²</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î²</span> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">aâ‚‚</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="185">bâ‚‚</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î²</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">aâ‚</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="185">bâ‚</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î²</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1046">hâ‚</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">aâ‚</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">aâ‚‚</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1042">hâ‚‚</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1041">rb</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="185">bâ‚</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="185">bâ‚‚</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1043">Prod.Lex</span> <a href="Basic-Types/Natural-Numbers/#Nat___lt"><span class="const token" data-binding="const-Nat.lt" data-verso-hover="1047">Nat.lt</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1041">rb</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">aâ‚</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="185">bâ‚</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">aâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="185">bâ‚‚</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18703">def</span> <span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-synack" data-verso-hover="1044">synack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18833" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.487" data-verso-hover="7">m</span> <span class="var token" data-binding="var-_uniq.490" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.487" data-verso-hover="7">m</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.490" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-18862" data-verso-hover="910">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-6230227203465208792-18878-18880"><span class="unknown token" data-binding="">Â·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6230227203465208792-18878-18880"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.820" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1043">Prod.Lex</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6732" data-verso-hover="7">aâ‚</span> <span class="var token" data-binding="var-_uniq.6733" data-verso-hover="7">aâ‚‚</span> =&gt; <span class="var token" data-binding="var-_uniq.6732" data-verso-hover="7">aâ‚</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6733" data-verso-hover="7">aâ‚‚</span>) (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6739" data-verso-hover="7">aâ‚</span> <span class="var token" data-binding="var-_uniq.6740" data-verso-hover="7">aâ‚‚</span> =&gt; <span class="var token" data-binding="var-_uniq.6739" data-verso-hover="7">aâ‚</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6740" data-verso-hover="7">aâ‚‚</span>) <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.820" data-verso-hover="7">m</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a> <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.820" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a>0<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-14363851864684790544-18881-18900"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-18881" data-verso-hover="692">apply</span></a> <span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1028">Prod.Lex.left</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14363851864684790544-18881-18900"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-121" checked="checked"><span for="--verso-unique-121" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.820" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.820" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.820" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-7-18905-18910"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-18905" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-18905-18910"><span class="tactic-state">All goals completed! ðŸ™</span></span>
  -- the next goal corresponds to the third recursive call
  <span class="tactic"><label for="tactic-state-16538175241761048616-18972-18974"><span class="unknown token" data-binding="">Â·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16538175241761048616-18972-18974"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1043">Prod.Lex</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6732" data-verso-hover="7">aâ‚</span> <span class="var token" data-binding="var-_uniq.6733" data-verso-hover="7">aâ‚‚</span> =&gt; <span class="var token" data-binding="var-_uniq.6732" data-verso-hover="7">aâ‚</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6733" data-verso-hover="7">aâ‚‚</span>) (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6739" data-verso-hover="7">aâ‚</span> <span class="var token" data-binding="var-_uniq.6740" data-verso-hover="7">aâ‚‚</span> =&gt; <span class="var token" data-binding="var-_uniq.6739" data-verso-hover="7">aâ‚</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6740" data-verso-hover="7">aâ‚‚</span>) <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1048"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a> <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-1557003394229330834-18975-18996"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-18975" data-verso-hover="692">apply</span></a> <span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1045">Prod.Lex.right'</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1557003394229330834-18975-18996"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-123" checked="checked"><span for="--verso-unique-123" class="goal-name">hâ‚</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1048"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-124"><span for="--verso-unique-124" class="goal-name">hâ‚‚</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-13305429934174659675-19001-19003"><span class="unknown token" data-binding="">Â·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13305429934174659675-19001-19003"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-125" checked="checked"><span for="--verso-unique-125" class="goal-name">hâ‚</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1048"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-19004-19009"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-19004" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19004-19009"><span class="tactic-state">All goals completed! ðŸ™</span></span>
    <span class="tactic"><label for="tactic-state-8318780627992542542-19014-19016"><span class="unknown token" data-binding="">Â·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8318780627992542542-19014-19016"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-126" checked="checked"><span for="--verso-unique-126" class="goal-name">hâ‚‚</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-19017-19022"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-19017" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19017-19022"><span class="tactic-state">All goals completed! ðŸ™</span></span>
  <span class="tactic"><label for="tactic-state-6062697537809409718-19025-19027"><span class="unknown token" data-binding="">Â·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6062697537809409718-19025-19027"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.827" data-verso-hover="1049">xâœ</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.6726" data-verso-hover="1050">y</span> : (_ : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) Ã—' <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) â†’
  (<a href="Definitions/Recursive-Definitions/#invImage"><span class="const token" data-binding="const-invImage" data-verso-hover="1051">invImage</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6729" data-verso-hover="1050">x</span> =&gt; <span class="const token" data-binding="const-PSigma.casesOn" data-verso-hover="1052">PSigma.casesOn</span> <span class="var token" data-binding="var-_uniq.6729" data-verso-hover="1050">x</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6746" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.6747" data-verso-hover="7">a_1</span> =&gt; <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.6746" data-verso-hover="7">a</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a><span class="var token" data-binding="var-_uniq.6747" data-verso-hover="7">a_1</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a>) <span class="const token" data-binding="const-Prod.instWellFoundedRelation" data-verso-hover="1053">Prod.instWellFoundedRelation</span>).1 <span class="var token" data-binding="var-_uniq.6726" data-verso-hover="1050">y</span> <a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">, </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">âŸ©</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1043">Prod.Lex</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6732" data-verso-hover="7">aâ‚</span> <span class="var token" data-binding="var-_uniq.6733" data-verso-hover="7">aâ‚‚</span> =&gt; <span class="var token" data-binding="var-_uniq.6732" data-verso-hover="7">aâ‚</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6733" data-verso-hover="7">aâ‚‚</span>) (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6739" data-verso-hover="7">aâ‚</span> <span class="var token" data-binding="var-_uniq.6740" data-verso-hover="7">aâ‚‚</span> =&gt; <span class="var token" data-binding="var-_uniq.6739" data-verso-hover="7">aâ‚</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6740" data-verso-hover="7">aâ‚‚</span>) <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a><span class="var token" data-binding="var-_uniq.827" data-verso-hover="1049">xâœ</span> <a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1048"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">, </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span><a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">âŸ©</span></a> â‹¯<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a> <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-17736609326066673867-19028-19047"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-19028" data-verso-hover="692">apply</span></a> <span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1028">Prod.Lex.left</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17736609326066673867-19028-19047"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-128" checked="checked"><span for="--verso-unique-128" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.827" data-verso-hover="1049">xâœ</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.6726" data-verso-hover="1050">y</span> : (_ : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) Ã—' <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) â†’
  (<a href="Definitions/Recursive-Definitions/#invImage"><span class="const token" data-binding="const-invImage" data-verso-hover="1051">invImage</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6729" data-verso-hover="1050">x</span> =&gt; <span class="const token" data-binding="const-PSigma.casesOn" data-verso-hover="1052">PSigma.casesOn</span> <span class="var token" data-binding="var-_uniq.6729" data-verso-hover="1050">x</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6746" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.6747" data-verso-hover="7">a_1</span> =&gt; <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">(</span></a><span class="var token" data-binding="var-_uniq.6746" data-verso-hover="7">a</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">, </span></a><span class="var token" data-binding="var-_uniq.6747" data-verso-hover="7">a_1</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="530">)</span></a>) <span class="const token" data-binding="const-Prod.instWellFoundedRelation" data-verso-hover="1053">Prod.instWellFoundedRelation</span>).1 <span class="var token" data-binding="var-_uniq.6726" data-verso-hover="1050">y</span> <a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">, </span></a><span class="var token" data-binding="var-_uniq.826" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma.mk" data-verso-hover="1054">âŸ©</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.825" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-7-19052-19057"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-19052" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19052-19057"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      The <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1026">decreasing_tactic</span></a></code> tactic does not use the stronger <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1045">Prod.Lex.right'</span></code> because it would require backtracking on failure.</p>
                    </div>
                  </details></section>
              <section>
                <h3 id="inferring-well-founded-recursion">
                  7.6.3.4.Â Inferring Well-Founded Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inferring-well-founded-recursion" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  If a recursive function definition does not indicate a termination <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a>, Lean will attempt to discover one automatically.
If neither <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> nor <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> is provided, Lean will try to <a href="Definitions/Recursive-Definitions/#inferring-structural-recursion">infer structural recursion</a> before attempting well-founded recursion.
If a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause is present, only well-founded recursion is attempted.</p>
                <p>
                  To infer a suitable termination <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a>, Lean considers multiple <span id="--tech-term-basic-termination-measures" class="def-technical-term"><em>basic termination measures</em></span>, which are termination measures of type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, and then tries all tuples of these measures.</p>
                <p>
                  The basic termination measures considered are:</p>
                <ul>
                  <li>
                    <p>
                      all parameters whose type have a non-trivial <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a></code> instance</p>
                    </li>
                  <li>
                    <p>
                      the expression <code>eâ‚‚ - eâ‚</code> whenever the local context of a recursive call has an assumption of type <code>eâ‚ &lt; eâ‚‚</code> or <code>eâ‚ â‰¤ eâ‚‚</code>, where <code>eâ‚</code> and <code>eâ‚‚</code> are of type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> and depend only on the function's parameters. <span class="marginalia"><span class="note">This approach is based on work by <span class="citation">Panagiotis Manolios and Daron Vroon,Â 2006. <a href="https://doi.org/10.1007/11817963_36">â€œTermination Analysis with Calling Context Graphsâ€</a>. InÂ <em>Proceedings of the International Conference on Computer Aided Verification (CAV 2006).</em> (LNCS 4144)</span>.</span></span></p>
                    </li>
                  <li>
                    <p>
                      in a mutual group, an additional basic measure is used to distinguish between recursive calls to other functions in the group and recursive calls to the function being defined (for details, see <a href="Definitions/Recursive-Definitions/#mutual-well-founded-recursion">the section on mutual well-founded recursion</a>)</p>
                    </li>
                  </ul>
                <p>
                  <span id="--tech-term-Candidate-measures" class="def-technical-term"><em>Candidate measures</em></span> are basic measures or tuples of basic measures.
If any of the candidate measures allow all proof obligations to be discharged by the termination proof tactic (that is, the tactic specified by <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span>, or <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1003">decreasing_trivial</span></a></code> if there is no <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause), then an arbitrary such candidate measure is selected as the automatic termination measure.</p>
                <p>
                  A <code class="plain-keyword">termination_by?</code> clause causes the inferred termination annotation to be shown.
It can be automatically added to the source file using the offered suggestion or code action.</p>
                <p>
                  To avoid the combinatorial explosion of trying all tuples of measures, Lean first tabulates all <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-basic-termination-measures">basic termination measures</a>, determining whether the basic measure is decreasing, strictly decreasing, or non-decreasing.
A decreasing measure is smaller for at least one recursive call and never increases at any recursive call, while a strictly decreasing measure is smaller at all recursive calls.
A non-decreasing measure is one that the termination tactic could not show to be decreasing or strictly decreasing.
A suitable tuple is chosen based on the table.<span class="marginalia"><span class="note">This approach is based on <span class="citation">Lukas Bulwahn, Alexander Krauss,  and Tobias Nipkow,Â 2007. <a href="https://doi.org/10.1007/978-3-540-74591-4_5">â€œFinding Lexicographic Orders for Termination Proofs in Isabelle/HOLâ€</a>. InÂ <em>Proceedings of the International Conference on Theorem Proving in Higher Order Logics (TPHOLS 2007).</em> (LNTCS 4732)</span>.</span></span>
This table shows up in the error message when no automatic measure could be found.</p>
                <details class="example"><summary class="description">Termination failure</summary><div class="example-content">
                    <p>
                      If there is no <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause, Lean attempts to infer a measure for well-founded recursion.
If it fails, then it prints the table mentioned above.
In this example, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause simply prevents Lean from also attempting structural recursion; this keeps the error message specific.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, â‰¤, =: relation proved, ? all proofs failed, _: no proof attempted)
           n m l
1) 32:6-25 = = =
2) 33:6-23 = &lt; _
3) 34:6-23 &lt; _ _
Please use `termination_by` to specify a decreasing measure.</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1021">def</span></span> <span class="const token" data-binding="const-f" data-verso-hover="1055">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">m</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">l</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.208" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.209" data-verso-hover="7">m</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.210" data-verso-hover="7">l</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span>
      <span class="const token" data-binding="const-f" data-verso-hover="1055">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.208" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="7">m</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.210" data-verso-hover="7">l</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
      <span class="const token" data-binding="const-f" data-verso-hover="1055">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.208" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="7">m</span><span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.210" data-verso-hover="7">l</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
      <span class="const token" data-binding="const-f" data-verso-hover="1055">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.208" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>   <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="7">m</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.210" data-verso-hover="7">l</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___sum"><span class="const token" data-binding="const-List.sum" data-verso-hover="1023">sum</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-1173" data-verso-hover="910">decreasing_by</span> <a href="Tactic-Proofs/The-Tactic-Language/#all_goals"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-1187" data-verso-hover="385">all_goals</span></a> <a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_tactic-1197" data-verso-hover="1026">decreasing_tactic</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, â‰¤, =: relation proved, ? all proofs failed, _: no proof attempted)
           n m l
1) 32:6-25 = = =
2) 33:6-23 = &lt; _
3) 34:6-23 &lt; _ _
Please use `termination_by` to specify a decreasing measure.
</pre></div>
                    <p>
                      The three recursive calls are identified by their source positions.
This message conveys the following facts:</p>
                    <ul>
                      <li>
                        <p>
                          In the first recursive call, all arguments are (provably) equal to the parameters</p>
                        </li>
                      <li>
                        <p>
                          In the second recursive call, the first argument is equal to the first parameter and the second argument is provably smaller than the second parameter.
  The third parameter was not checked for this recursive call, because it was not necessary to determine that no suitable termination argument exists.</p>
                        </li>
                      <li>
                        <p>
                          In the third recursive call, the first argument decreases strictly, and the other arguments were not checked.</p>
                        </li>
                      </ul>
                    <p>
                      When termination proofs fail in this manner, a good technique to discover the problem is to explicitly indicate the expected termination argument using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span>.
This will surface the messages from the failing tactic.</p>
                    </div>
                  </details><details class="example"><summary class="description">Array Indexing</summary><div class="example-content">
                    <p>
                      The purpose of considering expressions of the form <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2194" data-verso-hover="7">eâ‚‚</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.2192" data-verso-hover="7">eâ‚</span></code> as measures is to support the common idiom of counting up to some upper bound, in particular when traversing arrays in possibly interesting ways.
In the following function, which performs binary search on a sorted array, this heuristic helps Lean to find the <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2245" data-verso-hover="7">j</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.2243" data-verso-hover="7">i</span></code> measure.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22666">def</span> <span class="const token" data-binding="const-binarySearch" data-verso-hover="1056" id="binarySearch">binarySearch</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="337">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1057">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1058">go</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1057">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.whereDecls-22741">where</span>
  <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1058">go</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="1059">hj</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1057">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-22784">by</span> <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-22790" data-verso-hover="386">omega</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
    <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22804" data-verso-hover="1005">if</span></a> <span class="var token" data-binding="var-_uniq.68" data-verso-hover="1060">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22804" data-verso-hover="1005">then</span></a>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-22828" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.161" data-verso-hover="7">mid</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-22857" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.219" data-verso-hover="337">y</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1057">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.161" data-verso-hover="7">mid</span><span class="unknown token" data-binding="">]</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22880" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="337">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.219" data-verso-hover="337">y</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22880" data-verso-hover="137">then</span></a>
        <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.161" data-verso-hover="7">mid</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22880" data-verso-hover="137">else</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22922" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="337">x</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.219" data-verso-hover="337">y</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22922" data-verso-hover="137">then</span></a>
        <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1058">go</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="var token" data-binding="var-_uniq.161" data-verso-hover="7">mid</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22922" data-verso-hover="137">else</span></a>
        <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1058">go</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.161" data-verso-hover="7">mid</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span>
    <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22804" data-verso-hover="1005">else</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by (j, j - i)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-23009" data-verso-hover="894">termination_by?</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      The fact that the inferred termination argument uses some arbitrary measure, rather than an optimal or minimal one, is visible in the inferred measure, which contains a redundant <code>j</code>:</p>
                    <div class="information">
                      <pre>Try this: termination_by (j, j - i)
</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">Termination Proof Tactics During Inference</summary><div class="example-content">
                    <p>
                      The tactic indicated by <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> is used slightly differently when inferring the termination <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> than it is in the actual termination proof.</p>
                    <ul>
                      <li>
                        <p>
                          During inference, it is applied to a <em>single</em> goal, attempting to prove <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630">&lt;</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376">â‰¤</span></a></code> on <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.</p>
                        </li>
                      <li>
                        <p>
                          During the termination proof, it is applied to many simultaneous goals (one per recursive call), and the goals may involve the lexicographic ordering of pairs.</p>
                        </li>
                      </ul>
                    <p>
                      A consequence is that a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> block that addresses goals individually and which works successfully with an explicit termination argument can cause inference of the termination measure to fail:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, â‰¤, =: relation proved, ? all proofs failed, _: no proof attempted)
             x1 x2
1) 631:16-23  ?  ?
2) 632:27-40  _  _
3) 632:20-41  _  _
Please use `termination_by` to specify a decreasing measure.</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24158">def</span></span> <span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ack" data-verso-hover="1038">ack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-24272" data-verso-hover="910">decreasing_by</span>
  <span class="unknown token" data-binding="">Â·</span> <a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-24291" data-verso-hover="692">apply</span></a> <span class="unknown token" data-binding="">Prod.Lex.left</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24315" data-verso-hover="386">omega</span></a>
  <span class="unknown token" data-binding="">Â·</span> <a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-24326" data-verso-hover="692">apply</span></a> <span class="unknown token" data-binding="">Prod.Lex.right</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24351" data-verso-hover="386">omega</span></a>
  <span class="unknown token" data-binding="">Â·</span> <a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-24362" data-verso-hover="692">apply</span></a> <span class="unknown token" data-binding="">Prod.Lex.left</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24386" data-verso-hover="386">omega</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      It is advisable to always include a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause whenever an explicit <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> proof is given.</p>
                    </div>
                  </details><details class="example"><summary class="description">Inference too powerful</summary><div class="example-content">
                    <p>
                      Because <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1026">decreasing_tactic</span></a></code> avoids the need to backtrack by being incomplete with regard to lexicographic ordering, Lean may infer a termination <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> that leads to goals that the tactic cannot prove.
In this case, the error message is the one that results from the failing tactic rather than the one that results from being unable to find a measure.
This is what happens in <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1061">notAck</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25092">def</span> <span class="const token" data-binding="const-notAck" data-verso-hover="1061" id="notAck">notAck</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1061">notAck</span></a> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1061">notAck</span></a> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1061">notAck</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.273" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-25222" data-verso-hover="910">decreasing_by</span> <a href="Tactic-Proofs/The-Tactic-Language/#all_goals"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-25236" data-verso-hover="385">all_goals</span></a> <span class="tactic"><label for="tactic-state-7-25246-25263"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
âŠ¢ m / 2 + 1 &lt; m + 1</code></span></span><a href="Definitions/Recursive-Definitions/#decreasing_tactic"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_tactic-25246" data-verso-hover="1026">decreasing_tactic</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-25246-25263"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
âŠ¢ m / 2 + 1 &lt; m + 1
</pre></div>
                    <p>
                      In this case, explicitly stating the termination <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> helps.</p>
                    </div>
                  </details></section>
              <section>
                <h3 id="mutual-well-founded-recursion">
                  7.6.3.5.Â Mutual Well-Founded Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-well-founded-recursion" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  Lean supports the definition of <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutually-recursive">mutually recursive</a> functions using <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a>.
Mutual recursion may be introduced using a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutual-block">mutual block</a>, but it also results from <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.letrec : term</code></code><code class="kw">let rec</code></span> expressions and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> blocks.
The rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the <a href="Definitions/Recursive-Definitions/#mutual-syntax">elaboration steps</a> for mutual groups.</p>
                <p>
                  If any function in the mutual group has a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause, well-founded recursion is attempted.
If a termination <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> is specified using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> for <em>any</em> function in the mutual group, then <em>all</em> functions in the group must specify a termination measure, and they have to have the same type.</p>
                <p>
                  If no termination argument is specified, the termination argument is <a href="Definitions/Recursive-Definitions/#inferring-well-founded-recursion">inferred, as described above</a>. In the case of mutual recursion, a third class of basic measures is considered during inference, namely for each function in the mutual group the measure that is <code>1</code> for that function and <code>0</code> for the others. This allows Lean to order the functions so that some calls from one function to another are allowed even if the parameters do not decrease.</p>
                <details class="example"><summary class="description">Mutual recursion without parameter decrease</summary><div class="example-content">
                    <p>
                      In the following mutual function definitions, the parameter does not decrease in the call from <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-g" data-verso-hover="1062">g</span></code> to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-f" data-verso-hover="1063">f</span></code>.
Nonetheless, the definition is accepted due to the ordering imposed on the functions themselves by the additional basic measure.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27559">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27568">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1063">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-g" data-verso-hover="1062">g</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span>
  <span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by n =&gt; (n, 0)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-27626" data-verso-hover="894">termination_by?</span></span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27645">def</span> <span class="const token" data-binding="const-g" data-verso-hover="1062">g</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-f" data-verso-hover="1063">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by (n, 1)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-27682" data-verso-hover="894">termination_by?</span></span>
<a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27559">end</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      The inferred termination argument for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-f" data-verso-hover="1063">f</span></code> is:</p>
                    <div class="information">
                      <pre>Try this: termination_by n =&gt; (n, 0)
</pre></div>
                    <p>
                      The inferred termination argument for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-g" data-verso-hover="1062">g</span></code> is:</p>
                    <div class="information">
                      <pre>Try this: termination_by (n, 1)
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="well-founded-preprocessing">
                  7.6.3.6.Â Preprocessing Function Definitions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=well-founded-preprocessing" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  Lean <em>preprocesses</em> the function's body before determining the proof obligations at each call site, transforming it into an equivalent definition that may include additional information.
This preprocessing step is primarily used to enrich the local context with additional assumptions that may be necessary in order to solve the termination proof obligations, freeing users from the need to perform equivalent transformations by hand.
Preprocessing uses the <a href="The-Simplifier/#the-simplifier">simplifier</a> and is extensible by the user.</p>
                <div class="paragraph">
                  <p>
                    The preprocessing happens in three steps:</p>
                  <ol start="1">
                    <li>
                      <p>
                        Lean annotates occurrences of a function's parameter, or a subterm of a parameter, with the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> <a class="technical-term" href="Type-Classes/Class-Declarations/#--tech-term-gadgets">gadget</a>.</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="127">Î±</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="127">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="127">Î±</span></code><p>
                        More precisely, every occurrence of the function's parameters is wrapped in <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code>.
    Whenever a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression has <em>any</em> discriminant wrapped in <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code>, the gadget is removed and every occurrence of a pattern match variable (regardless of whether it comes from the discriminant with the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> gadget) is wrapped in <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code>.
    The <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> gadget is additionally floated out of <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-projection-function">projection function</a> applications.</p>
                      </li>
                    <li>
                      <p>
                        The annotated function body is simplified using <a href="The-Simplifier/#the-simplifier">the simplifier</a>, using only simplification rules from the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1065">wf_preprocess</span></code> <a class="technical-term" href="The-Simplifier/Simp-sets/#--tech-term-Custom-simp-sets">custom simp set</a>.</p>
                      </li>
                    <li>
                      <p>
                        Finally, any left-over <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> markers are removed.</p>
                      </li>
                    </ol>
                  <p>
                    Annotating function parameters that are used for well-founded recursion allows the preprocessing simplification rules to distinguish between parameters and other terms.</p>
                  </div>
                <div class="namedocs" id="attr">
                  <span class="label">attribute</span><span class="title">Preprocessing Simp Set for Well-Founded Recursion</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___wf_preprocess"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Attr.wf_preprocess"><code class="hover-info"><code class="docstring">Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined
by well-founded recursion. They are applied to the function's body to add additional hypotheses,
such as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with
`xs.attach.map`. Also see `wfParam`.
</code></code><span class="keyword">wf_preprocess</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      Theorems tagged with the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___wf_preprocess"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.wf_preprocess-0" data-verso-hover="1066">wf_preprocess</span></a></code> attribute are used during the processing of functions defined
by well-founded recursion. They are applied to the function's body to add additional hypotheses,
such as replacing <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-0" data-verso-hover="1067">if</span></a> <span class="unknown token" data-binding="">c</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-0" data-verso-hover="1067">then</span></a> <span class="unknown token" data-binding="">_</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-0" data-verso-hover="1067">else</span></a> <span class="unknown token" data-binding="">_</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacDepIfThenElse-0" data-verso-hover="1068">if</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">c</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacDepIfThenElse-0" data-verso-hover="1068">then</span></a> <span class="unknown token" data-binding="">_</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacDepIfThenElse-0" data-verso-hover="1068">else</span></a> <span class="unknown token" data-binding="">_</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">xs.map</span></code> with
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">xs.attach.map</span></code>. Also see <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="wfParam">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=wfParam" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">wfParam.{u} {<span class="var token" data-binding="var-_uniq.2337" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} (<span class="var token" data-binding="var-_uniq.2338" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2337" data-verso-hover="168">Î±</span>) : <span class="var token" data-binding="var-_uniq.2337" data-verso-hover="168">Î±</span></div><div class="narrow-only">wfParam.{u} {<span class="var token" data-binding="var-_uniq.2337" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} (<span class="var token" data-binding="var-_uniq.2338" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2337" data-verso-hover="168">Î±</span>) : <span class="var token" data-binding="var-_uniq.2337" data-verso-hover="168">Î±</span></div></pre><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> gadget is used internally during the construction of recursive functions by
wellfounded recursion, to keep track of the parameter for which the automatic introduction
of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1069">List.attach</span></a></code> (or similar) is plausible.</p>
                    </div>
                  </div>
                <p>
                  Some rewrite rules in the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1065">wf_preprocess</span></code> simp set apply generally, without heeding the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> marker.
In particular, the theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ite_eq_dite" data-verso-hover="1070">ite_eq_dite</span></code> is used to extend the context of an <a href="Terms/Conditionals/#if-then-else">if-then-else</a> expression branch with an assumption about the condition:<span class="marginalia"><span class="note">This assumption's name should be an inaccessible name based on <code>h</code>, as is indicated by using <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a></code> with the term <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code>. Binder name hints are described in the <a href="Tactic-Proofs/Naming-Bound-Variables/#bound-variable-name-hints">tactic language reference</a>.</span></span></p>
                <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-ite_eq_dite" data-verso-hover="1070">ite_eq_dite</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">P</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="168">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-30483" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">b</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="168">Î±</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">P</span><span class="unknown token" data-binding="">]</span>  <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-30522" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">P</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-30522" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="46">a</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-30522" data-verso-hover="137">else</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-30546" data-verso-hover="1005">if</span></a> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="209">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">P</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-30546" data-verso-hover="1005">then</span></a>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="209">h</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="46">a</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-30546" data-verso-hover="1005">else</span></a>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="1072">h</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">b</span></code><div class="paragraph">
                  <p>
                    Other rewrite rules use the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> marker to restrict their applicability; they are used only when a function (like <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">List.map</span></a></code>) is applied to a parameter or subterm of a parameter, but not otherwise.
This is typically done in two steps:</p>
                  <ol start="1">
                    <li>
                      <p>
                        A theorem such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.map_wfParam" data-verso-hover="1073">List.map_wfParam</span></code> recognizes a call of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">List.map</span></a></code> on a function parameter (or subterm), and uses <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1069">List.attach</span></a></code> to enrich the type of the list elements with the assertion that they are indeed elements of that list:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.map_wfParam" data-verso-hover="1073">List.map_wfParam</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1069">attach</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___unattach"><span class="const token" data-binding="const-List.unattach" data-verso-hover="1074">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="180">f</span></code></li>
                    <li>
                      <p>
                        A theorem such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.map_unattach" data-verso-hover="1075">List.map_unattach</span></code> makes that assertion available to the function parameter of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">List.map</span></a></code>.</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.map_unattach" data-verso-hover="1075">List.map_unattach</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="471">P</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="1076">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="unknown token" data-binding="">{</span> <span class="var token" data-binding="var-_uniq.34" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">//</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="471">P</span> <span class="var token" data-binding="var-_uniq.34" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.41" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="var token" data-binding="var-_uniq.37" data-verso-hover="1076">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___unattach"><span class="const token" data-binding="const-List.unattach" data-verso-hover="1074">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.37" data-verso-hover="1076">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-31653">fun</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="var token" data-binding="var-_uniq.139" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.140" data-verso-hover="1077">h</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.139" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">&lt;|</span>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.140" data-verso-hover="1077">h</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span>
    <span class="var token" data-binding="var-_uniq.41" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="var token" data-binding="var-_uniq.139" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span></code><p>
                        This theorem uses the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a></code> gadget to preserve a user-chosen binder name, should <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2714" data-verso-hover="180">f</span></code> be a lambda expression.</p>
                      </li>
                    </ol>
                  <p>
                    By separating the introduction of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1069">List.attach</span></a></code> from the propagation of the introduced assumption, the desired the <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2787" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">âˆˆ</span> <span class="var token" data-binding="var-_uniq.2777" data-verso-hover="51">xs</span></code> assumption is made available to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2832" data-verso-hover="180">f</span></code> even in chains such as <code>(xs.reverse.filter p).map f</code>.</p>
                  </div>
                <p>
                  This preprocessing can be disabled by setting the option <code class="hl lean inline" data-lean-context="examples"><span class="option token" data-binding="option-wf.preprocess" data-verso-hover="1078">wf.preprocess</span></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code>.
To see the preprocessed function definition, before and after the removal of <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a></code> markers, set the option <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#trace___Elab___definition___wf"><span class="option token" data-binding="option-trace.Elab.definition.wf" data-verso-hover="1079">trace.Elab.definition.wf</span></a></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>.</p>
                <div class="namedocs" id="trace___Elab___definition___wf">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&name=trace.Elab.definition.wf" title="Permalink">ðŸ”—</a></span><span class="label">option</span><pre class="signature hl lean block">trace.Elab.definition.wf</pre><div class="text">
                    <p>
                      Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code></p>
                    <p>
                      enable/disable tracing for the given module and submodules</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Preprocessing for a custom data type</summary><div class="example-content">
                    <p>
                      This example demonstrates what is necessary to enable automatic well-founded recursion for a custom container type.
The structure type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span></code> is a homogeneous pair: it contains precisely two elements, both of which have the same type.
It can be thought of as being similar to a list or array that always contains precisely two elements.</p>
                    <p>
                      As a container, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span></code> can support a <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a></code> operation.
To support well-founded recursion in which recursive calls occur in the body of a function being mapped over a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span></code>, some additional definitions are required, including a membership predicate, a theorem that relates the size of a member to the size of the containing pair, helpers to introduce and eliminate assumptions about membership, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1065">wf_preprocess</span></code> rules to insert these helpers, and an extension to the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1003">decreasing_trivial</span></a></code> tactic.
Each of these steps makes it easier to work with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span></code>, but none are strictly necessary; there's no need to immediately implement all steps for every type.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="doc-comment token" data-binding="">/-- A homogeneous pair -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-1746">structure</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1767" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-1775">where</span>
  <span class="const token" data-binding="const-Pair.fst" data-verso-hover="361">fst</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span>
  <span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span>

<span class="doc-comment token" data-binding="">/-- Mapping a function over the elements of a pair -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1858">def</span> <span class="const token" data-binding="const-Pair.map" data-verso-hover="1081" id="Pair___fst">Pair.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.425" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.415" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.421" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.428" data-verso-hover="1082">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.415" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.421" data-verso-hover="187">Î²</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-1911">where</span>
  <span class="const token" data-binding="const-Pair.fst" data-verso-hover="1083">fst</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.425" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.428" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="361">fst</span>
  <span class="const token" data-binding="const-Pair.snd" data-verso-hover="1083">snd</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.425" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.428" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Defining a nested inductive data type of binary trees that uses <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span></code> and attempting to define its <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">map</span></code> function demonstrates the need for preprocessing rules.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="doc-comment token" data-binding="">/-- A binary tree defined using `Pair` -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-2190" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-2211" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-2219">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.node" data-verso-hover="1087" id="Tree___node">node</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span>
<span class="unknown token" data-binding=""></span></code><p>
                      A straightforward definition of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">map</span></code> function fails:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2424">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="187">Î²</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="1088">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1088">p</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2527">fun</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="951">t'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
Î± : Type u_1
p : Pair (Tree Î±)
t' : Tree Î±
âŠ¢ sizeOf t' &lt; 1 + sizeOf p</code></span></span><span class="var token" data-binding="var-_uniq.74" data-verso-hover="951">t'</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">map</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-2548" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="951">t</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
Î± : Type u_1
p : Pair (Tree Î±)
t' : Tree Î±
âŠ¢ sizeOf t' &lt; 1 + sizeOf p
</pre></div>
                    <div class="paragraph">
                      <p>
                        Clearly the proof obligation is not solvable, because nothing connects <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.30" data-verso-hover="951">t'</span></code> to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.46" data-verso-hover="1088">p</span></code>.</p>
                      </div>
                    <p>
                      The standard idiom to enable this kind of function definition is to have a function that enriches each element of a collection with a proof that they are, in fact, elements of the collection.
Stating this property requires a membership predicate.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-3438" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1089" id="Pair___Mem___snd">Pair.Mem</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-3485">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Pair.Mem.fst" data-verso-hover="1090" id="Pair___Mem___snd">fst</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1089">Mem</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="361">fst</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Pair.Mem.snd" data-verso-hover="1091" id="Pair___Mem___snd">snd</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1089">Mem</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-3536">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Membership" data-verso-hover="1092">Membership</span> <span class="var token" data-binding="var-_uniq.68" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.68" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-3571">where</span>
  <span class="const token" data-binding="const-Membership.mem" data-verso-hover="1093">mem</span> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1089">Pair.Mem</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      Every inductive type automatically has a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a></code> instance.
An element of a collection should be smaller than the collection, but this fact must be proved before it can be used to construct a termination proof:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-3826">theorem</span> <span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1094" id="Pair___sizeOf_lt_of_mem">Pair.sizeOf_lt_of_mem</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">]</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.61" data-verso-hover="1095">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">âˆˆ</span> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">&lt;</span> <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11162777865742542912-3943-3945"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3943" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11162777865742542912-3943-3945"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.61" data-verso-hover="1095">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-2905430778187623168-3948-3955"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-3948" data-verso-hover="383">cases</span></a> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="1095">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2905430778187623168-3948-3955"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-130" checked="checked"><span for="--verso-unique-130" class="goal-name">fst</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span>.<span class="const token" data-binding="const-Pair.fst" data-verso-hover="361">fst</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-131"><span for="--verso-unique-131" class="goal-name">snd</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span>.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-2905430778187623168-3956-3959"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2905430778187623168-3956-3959"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-132" checked="checked"><span for="--verso-unique-132" class="goal-name">fst</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span>.<span class="const token" data-binding="const-Pair.fst" data-verso-hover="361">fst</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-133"><span for="--verso-unique-133" class="goal-name">snd</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span>.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-1219023128247078073-3960-3967"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-3960" data-verso-hover="383">cases</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1082">p</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1219023128247078073-3960-3967"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-134" checked="checked"><span for="--verso-unique-134" class="goal-name">snd.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">sndâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span>.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-10102633851271580244-3968-3971"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10102633851271580244-3968-3971"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-135" checked="checked"><span for="--verso-unique-135" class="goal-name">fst.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.233" data-verso-hover="46">fstâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.234" data-verso-hover="46">sndâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.234" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span>.<span class="const token" data-binding="const-Pair.fst" data-verso-hover="361">fst</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.234" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-136"><span for="--verso-unique-136" class="goal-name">snd.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">sndâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span>.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span></span></span></span></span></span></span> <span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-11220709837769981134-3973-3977"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-3973" data-verso-hover="36">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11220709837769981134-3973-3977"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-137" checked="checked"><span for="--verso-unique-137" class="goal-name">snd.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1096">instâœ</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="457">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">sndâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fstâœ</span></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-3979-3984"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-3979" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3979-3984"><span class="tactic-state">All goals completed! ðŸ™</span></span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The next step is to define <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">attach</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a></code> functions that enrich the elements of the pair with a proof that they are elements of the pair, or remove said proof.
Here, the type of <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">Pair.unattach</span></a></code> is more general and can be used with any <a href="Basic-Types/Subtypes/#Subtype">subtype</a>; this is a typical pattern.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4341">def</span> <span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099" id="Pair___attach">Pair.attach</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">//</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">âˆˆ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">}</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-4398">where</span>
  <span class="const token" data-binding="const-Pair.fst" data-verso-hover="1101">fst</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ¨</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="361">fst</span><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="470">,</span> <a href="Definitions/Recursive-Definitions/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem.fst" data-verso-hover="1090">.fst</span></a><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ©</span>
  <span class="const token" data-binding="const-Pair.snd" data-verso-hover="1101">snd</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ¨</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="362">snd</span><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="470">,</span> <a href="Definitions/Recursive-Definitions/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem.snd" data-verso-hover="1091">.snd</span></a><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ©</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4459">def</span> <span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100" id="Pair___attach">Pair.unattach</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="471">P</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.98" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">//</span> <span class="var token" data-binding="var-_uniq.91" data-verso-hover="471">P</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="46">x</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">Pair.map</span></a> <a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">Subtype.val</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">Tree.map</span></code> can now be defined by using <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">Pair.attach</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1094">Pair.sizeOf_lt_of_mem</span></a></code> explicitly:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4710">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="187">Î²</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="1088">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1088">p</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">attach</span></a><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-4820">fun</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="951">t'</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="951">t'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">map</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-4850" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.252" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.252" data-verso-hover="951">t</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-4872" data-verso-hover="910">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-6125066352409592158-4888-4925"><a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-4888" data-verso-hover="1102">have</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1094">Pair.sizeOf_lt_of_mem</span></a> <span class="unknown token" data-binding="">â€¹</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">â€º</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6125066352409592158-4888-4925"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.398" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.398" data-verso-hover="44">Î±</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.398" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.495" data-verso-hover="1103">propertyâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1138" data-verso-hover="1104">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> (<a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span>)</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7650466587323862383-4928-4943"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-4928" data-verso-hover="666">simp_all</span></a> <span class="unknown token" data-binding="">+</span><a href="The-Simplifier/Configuring-Simplification/#Lean___Meta___Simp___Config___mk"><span class="const token" data-binding="const-Lean.Meta.Simp.Config.arith" data-verso-hover="663">arith</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7650466587323862383-4928-4943"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.398" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.398" data-verso-hover="44">Î±</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.398" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.495" data-verso-hover="1103">propertyâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1138" data-verso-hover="1104">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.494" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.473" data-verso-hover="1088">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-4946-4951"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-4946" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-4946-4951"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      This transformation can be made fully automatic.
The preprocessing feature of well-founded recursion can be used to automate the introduction of the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">Pair.attach</span></a></code> function.
This is done in two stages.
First, when <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">Pair.map</span></a></code> is applied to one of the function's parameters, it is rewritten to an <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">attach</span></a></code>/<code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a></code> composition.
Then, when a function is mapped over the result of <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">Pair.unattach</span></a></code>, the function is rewritten to accept the proof of membership and bring it into scope.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">@[</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___wf_preprocess"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.wf_preprocess-5503" data-verso-hover="1066">wf_preprocess</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-5518">theorem</span> <span class="const token" data-binding="const-Pair.map_wfParam" data-verso-hover="1105" id="Pair___map_unattach">Pair.map_wfParam</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1082">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1082">p</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">attach</span></a><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-9978747095505919204-5626-5628"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5626" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9978747095505919204-5626-5628"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.64" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.65" data-verso-hover="187">Î²</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.64" data-verso-hover="44">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.65" data-verso-hover="187">Î²</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1082">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="var token" data-binding="var-_uniq.64" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> (<a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1082">p</span>)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1082">p</span>.<a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">attach</span></a>.<a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-10559819793063846502-5631-5638"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-5631" data-verso-hover="383">cases</span></a> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1082">p</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10559819793063846502-5631-5638"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-141" checked="checked"><span for="--verso-unique-141" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.64" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.65" data-verso-hover="187">Î²</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.64" data-verso-hover="44">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.65" data-verso-hover="187">Î²</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="46">fstâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.64" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.95" data-verso-hover="46">sndâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.64" data-verso-hover="44">Î±</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> (<a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span>)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1098">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="46">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1098">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="46">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span>.<a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">attach</span></a>.<a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-5641-5693"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-5641" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a><span class="unknown token" data-binding="">,</span> <a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1099">Pair.attach</span></a><span class="unknown token" data-binding="">,</span> <a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">Pair.unattach</span></a><span class="unknown token" data-binding="">,</span> <a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">Pair.map</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-5641-5693"><span class="tactic-state">All goals completed! ðŸ™</span></span>

<span class="unknown token" data-binding="">@[</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Attr___wf_preprocess"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.wf_preprocess-5697" data-verso-hover="1066">wf_preprocess</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-5712">theorem</span> <span class="const token" data-binding="const-Pair.map_unattach" data-verso-hover="1106" id="Pair___map_unattach">Pair.map_unattach</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.1672" data-verso-hover="471">P</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.1650" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1680" data-verso-hover="1107">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="469">Subtype</span></a> <span class="var token" data-binding="var-_uniq.1672" data-verso-hover="471">P</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.1650" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.1668" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.1680" data-verso-hover="1107">p</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">=</span>
    <span class="var token" data-binding="var-_uniq.1680" data-verso-hover="1107">p</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-5834">fun</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="var token" data-binding="var-_uniq.1778" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.1779" data-verso-hover="1077">h</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">=&gt;</span>
      <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.1778" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">&lt;|</span>
      <span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="var token" data-binding="var-_uniq.1778" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11044458741295227599-5903-5905"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5903" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11044458741295227599-5903-5905"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1845" data-verso-hover="187">Î²</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1672" data-verso-hover="471">P</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="44">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1680" data-verso-hover="1107">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> (<a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="469">Subtype</span></a> <span class="var token" data-binding="var-_uniq.1672" data-verso-hover="471">P</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="44">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.1845" data-verso-hover="187">Î²</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.1680" data-verso-hover="1107">p</span>.<a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a>
    (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.3252" data-verso-hover="1108">x</span> =&gt;
      <span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.3252" data-verso-hover="1108">x</span> <span class="keyword token" data-binding="">with</span>
      | <a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.3260" data-verso-hover="46">x</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.3261" data-verso-hover="1077">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ©</span></a> =&gt; <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.3255" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> (<span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> (<a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="var token" data-binding="var-_uniq.3255" data-verso-hover="46">x</span>)))
    <span class="var token" data-binding="var-_uniq.1680" data-verso-hover="1107">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-2447542363882837087-5908-5915"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-5908" data-verso-hover="383">cases</span></a> <span class="var token" data-binding="var-_uniq.1680" data-verso-hover="1107">p</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2447542363882837087-5908-5915"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-143" checked="checked"><span for="--verso-unique-143" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1845" data-verso-hover="187">Î²</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1672" data-verso-hover="471">P</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="44">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1844" data-verso-hover="44">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.1845" data-verso-hover="187">Î²</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1875" data-verso-hover="1108">fstâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="469">Subtype</span></a> <span class="var token" data-binding="var-_uniq.1672" data-verso-hover="471">P</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1876" data-verso-hover="1108">sndâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="469">Subtype</span></a> <span class="var token" data-binding="var-_uniq.1672" data-verso-hover="471">P</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1109">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.1875" data-verso-hover="1108">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1109">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.1876" data-verso-hover="1108">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span>.<a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">unattach</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a>
    (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.3252" data-verso-hover="1108">x</span> =&gt;
      <span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.3252" data-verso-hover="1108">x</span> <span class="keyword token" data-binding="">with</span>
      | <a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.3260" data-verso-hover="46">x</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.3261" data-verso-hover="1077">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">âŸ©</span></a> =&gt; <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1071">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.3255" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> (<span class="var token" data-binding="var-_uniq.1684" data-verso-hover="180">f</span> (<a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a> <span class="var token" data-binding="var-_uniq.3255" data-verso-hover="46">x</span>)))
    <span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">{ </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="1109">fst</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.1875" data-verso-hover="1108">fstâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097">, </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="1109">snd</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> := </span><span class="var token" data-binding="var-_uniq.1876" data-verso-hover="1108">sndâœ</span><span class="const token" data-binding="const-Pair.mk" data-verso-hover="1097"> }</span></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-5917-5956"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-5917" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="Definitions/Recursive-Definitions/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1064">wfParam</span></a><span class="unknown token" data-binding="">,</span> <a href="Definitions/Recursive-Definitions/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1100">Pair.unattach</span></a><span class="unknown token" data-binding="">,</span> <a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">Pair.map</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-5917-5956"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      Now the function body can be written without extra considerations, and the membership assumption is still available to the termination proof.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6129">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="187">Î²</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="1088">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1088">p</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6232">fun</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="951">t'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="951">t'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">map</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="180">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-6253" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="951">t</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-6275" data-verso-hover="910">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-9033489264411129752-6291-6328"><a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-6291" data-verso-hover="1102">have</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1094">Pair.sizeOf_lt_of_mem</span></a> <span class="unknown token" data-binding="">â€¹</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">â€º</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9033489264411129752-6291-6328"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">Î±</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.550" data-verso-hover="1103">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1193" data-verso-hover="1104">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> (<a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span>)</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-6503270613439897333-6331-6339"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-6331" data-verso-hover="666">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6503270613439897333-6331-6339"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1080">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">Î±</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.550" data-verso-hover="1103">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1017"> âˆˆ </span><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1193" data-verso-hover="1104">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="951">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="992">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1088">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-6342-6347"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-6342" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6342-6347"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      The proof can be made fully automatic by adding <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1094">sizeOf_lt_of_mem</span></a></code> to the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1003">decreasing_trivial</span></a></code> tactic, as is done for similar built-in theorems.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro-6543">macro</span></a> <span class="literal string token" data-binding="" data-verso-hover="1110">"sizeOf_pair_dec"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="1111">tactic</span> <span class="unknown token" data-binding="">=&gt;</span>
  <span class="unknown token" data-binding="">`(tactic|</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.withReducible-6591" data-verso-hover="1112">with_reducible</span>
    <a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-6610" data-verso-hover="1102">have</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">Pair.sizeOf_lt_of_mem</span> <span class="unknown token" data-binding="">â€¹</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">â€º</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-6652" data-verso-hover="386">omega</span></a>
    <a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-6662" data-verso-hover="1113">done</span></a><span class="unknown token" data-binding="">)</span>

<a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-6669">macro_rules</span></a> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">`(tactic|</span> <a href="Definitions/Recursive-Definitions/#decreasing_trivial"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_trivial-6693" data-verso-hover="1003">decreasing_trivial</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">`(tactic|</span> <span class="keyword token" data-binding="kw-occ-tacticSizeOf_pair_dec-6726">sizeOf_pair_dec</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6744">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1258" data-verso-hover="180">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.1248" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.1254" data-verso-hover="187">Î²</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.1248" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1085">Tree</span> <span class="var token" data-binding="var-_uniq.1254" data-verso-hover="187">Î²</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="var token" data-binding="var-_uniq.1285" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1086">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1258" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.1285" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="var token" data-binding="var-_uniq.1303" data-verso-hover="1088">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Definitions/Recursive-Definitions/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1087">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1303" data-verso-hover="1088">p</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1081">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6847">fun</span> <span class="var token" data-binding="var-_uniq.1317" data-verso-hover="951">t'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1317" data-verso-hover="951">t'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1084">map</span> <span class="var token" data-binding="var-_uniq.1258" data-verso-hover="180">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-6868" data-verso-hover="894">termination_by</span> <span class="var token" data-binding="var-_uniq.1399" data-verso-hover="951">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1399" data-verso-hover="951">t</span>
<span class="unknown token" data-binding=""></span></code><p>
                      To keep the example short, the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">sizeOf_pair_dec</span></code> tactic is tailored to this particular recursion pattern and isn't really general enough for a general-purpose container library.
It does, however, demonstrate that libraries can be just as convenient in practice as the container types in the standard library.</p>
                    </div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction">
                  7.6.3.7.Â Theory and Construction</h3>
                <p>
                  This section gives a very brief glimpse into the mathematical constructions that underlie termination proofs via <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, which may surface occasionally.
The elaboration of functions defined by well-founded recursion is based on the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">WellFounded.fix</span></a></code> operator.</p>
                <div class="namedocs" id="WellFounded___fix">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=WellFounded.fix" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">WellFounded.fix.{u, v} {<span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} {<span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>} {<span class="var token" data-binding="var-_uniq.2875" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>}
  (<span class="var token" data-binding="var-_uniq.2876" data-verso-hover="1115">hwf</span> : <a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a> <span class="var token" data-binding="var-_uniq.2875" data-verso-hover="498">r</span>) (<span class="var token" data-binding="var-_uniq.2883" data-verso-hover="1116">F</span> : (<span class="var token" data-binding="var-_uniq.2878" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span>) â†’ ((<span class="var token" data-binding="var-_uniq.2881" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span>) â†’ <span class="var token" data-binding="var-_uniq.2875" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.2881" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.2878" data-verso-hover="46">x</span> â†’ <span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> <span class="var token" data-binding="var-_uniq.2881" data-verso-hover="46">y</span>) â†’ <span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> <span class="var token" data-binding="var-_uniq.2878" data-verso-hover="46">x</span>)
  (<span class="var token" data-binding="var-_uniq.2884" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span>) : <span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> <span class="var token" data-binding="var-_uniq.2884" data-verso-hover="46">x</span></div><div class="narrow-only">WellFounded.fix.{u, v} {<span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>}
  {<span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>} {<span class="var token" data-binding="var-_uniq.2875" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>}
  (<span class="var token" data-binding="var-_uniq.2876" data-verso-hover="1115">hwf</span> : <a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a> <span class="var token" data-binding="var-_uniq.2875" data-verso-hover="498">r</span>)
  (<span class="var token" data-binding="var-_uniq.2883" data-verso-hover="1116">F</span> :
    (<span class="var token" data-binding="var-_uniq.2878" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span>) â†’
      ((<span class="var token" data-binding="var-_uniq.2881" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span>) â†’ <span class="var token" data-binding="var-_uniq.2875" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.2881" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.2878" data-verso-hover="46">x</span> â†’ <span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> <span class="var token" data-binding="var-_uniq.2881" data-verso-hover="46">y</span>) â†’ <span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> <span class="var token" data-binding="var-_uniq.2878" data-verso-hover="46">x</span>)
  (<span class="var token" data-binding="var-_uniq.2884" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.2869" data-verso-hover="168">Î±</span>) : <span class="var token" data-binding="var-_uniq.2871" data-verso-hover="170">C</span> <span class="var token" data-binding="var-_uniq.2884" data-verso-hover="46">x</span></div></pre><div class="text">
                    <p>
                      A well-founded fixpoint. If satisfying the motive <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2857" data-verso-hover="170">C</span></code> for all values that are smaller according to a
well-founded relation allows it to be satisfied for the current value, then it is satisfied for all
values.</p>
                    <p>
                      This function is used as part of the elaboration of well-founded recursion.</p>
                    </div>
                  </div>
                <p>
                  The type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2886" data-verso-hover="55">Î±</span></code> is instantiated with the function's (varying) parameters, packed into one type using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma" data-verso-hover="1117">PSigma</span></a></code>.
The <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a></code> relation is constructed from the termination <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-measure-next">measure</a> via <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#invImage"><span class="const token" data-binding="const-invImage" data-verso-hover="1051">invImage</span></a></code>.</p>
                <div class="namedocs" id="invImage">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=invImage" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">invImage.{u_1, u_2} {<span class="var token" data-binding="var-_uniq.2910" data-verso-hover="127">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_1</span>} {<span class="var token" data-binding="var-_uniq.2911" data-verso-hover="296">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_2</span>} (<span class="var token" data-binding="var-_uniq.2913" data-verso-hover="180">f</span> : <span class="var token" data-binding="var-_uniq.2910" data-verso-hover="127">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.2911" data-verso-hover="296">Î²</span>)
  (<span class="var token" data-binding="var-_uniq.2914" data-verso-hover="1118">h</span> : <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="986">WellFoundedRelation</span></a> <span class="var token" data-binding="var-_uniq.2911" data-verso-hover="296">Î²</span>) : <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="986">WellFoundedRelation</span></a> <span class="var token" data-binding="var-_uniq.2910" data-verso-hover="127">Î±</span></div><div class="narrow-only">invImage.{u_1, u_2} {<span class="var token" data-binding="var-_uniq.2910" data-verso-hover="127">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_1</span>}
  {<span class="var token" data-binding="var-_uniq.2911" data-verso-hover="296">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_2</span>} (<span class="var token" data-binding="var-_uniq.2913" data-verso-hover="180">f</span> : <span class="var token" data-binding="var-_uniq.2910" data-verso-hover="127">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.2911" data-verso-hover="296">Î²</span>)
  (<span class="var token" data-binding="var-_uniq.2914" data-verso-hover="1118">h</span> : <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="986">WellFoundedRelation</span></a> <span class="var token" data-binding="var-_uniq.2911" data-verso-hover="296">Î²</span>) :
  <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="986">WellFoundedRelation</span></a> <span class="var token" data-binding="var-_uniq.2910" data-verso-hover="127">Î±</span></div></pre><div class="text">
                    <p>
                      The inverse image of a well-founded relation is well-founded.</p>
                    </div>
                  </div>
                <p>
                  The function's body is passed to <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">WellFounded.fix</span></a></code>, with parameters suitably packed and unpacked, and recursive calls are replaced with a call to the value provided by <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">WellFounded.fix</span></a></code>.
The termination proofs generated by the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> tactics are inserted in the right place.</p>
                <p>
                  Finally, the equational and unfolding theorems for the recursive function are proved from <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1119">WellFounded.fix_eq</span></code>.
These theorems hide the details of packing and unpacking arguments and describe the function's behavior in terms of the original definition.</p>
                <p>
                  In the case of mutual recursion, an equivalent non-mutual function is constructed by combining the function's arguments using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Sum-Types/#PSum___inl"><span class="const token" data-binding="const-PSum" data-verso-hover="1120">PSum</span></a></code>, and pattern-matching on that sum type in the result type and the body.</p>
                <p>
                  The definition of <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a></code> builds on the notion of <em>accessible elements</em> of the relation:</p>
                <div class="namedocs" id="WellFounded___intro">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=WellFounded" title="Permalink">ðŸ”—</a></span><span class="label">inductive predicate</span><pre class="signature hl lean block"><div class="wide-only">WellFounded.{u} {<span class="var token" data-binding="var-_uniq.3038" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} (<span class="var token" data-binding="var-_uniq.3042" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.3038" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3038" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) : <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only">WellFounded.{u} {<span class="var token" data-binding="var-_uniq.3038" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>}
  (<span class="var token" data-binding="var-_uniq.3042" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.3038" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3038" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) : <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      A relation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3012" data-verso-hover="498">r</span></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a></code> if all elements of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3011" data-verso-hover="168">Î±</span></code> are accessible within <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3012" data-verso-hover="498">r</span></code>.
If a relation is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a></code>, it does not allow for an infinite descent along the relation.</p>
                    <p>
                      If the arguments of the recursive calls in a function definition decrease according to
a well founded relation, then the function terminates.
Well-founded relations are sometimes called <em>Artinian</em> or said to satisfy the â€œdescending chain conditionâ€.</p>
                    <h1>
                      Constructors</h1>
                    <div class="constructor">
                      <pre class="name-and-type hl lean">intro.{u} {<span class="var token" data-binding="var-_uniq.3029" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} {<span class="var token" data-binding="var-_uniq.3033" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.3029" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3029" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>}
  (<span class="var token" data-binding="var-_uniq.3035" data-verso-hover="1121">h</span> : âˆ€ (<span class="var token" data-binding="var-_uniq.3034" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.3029" data-verso-hover="168">Î±</span>), <a href="Definitions/Recursive-Definitions/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1122">Acc</span></a> <span class="var token" data-binding="var-_uniq.3033" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.3034" data-verso-hover="46">a</span>) : <a href="Definitions/Recursive-Definitions/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="990">WellFounded</span></a> <span class="var token" data-binding="var-_uniq.3033" data-verso-hover="498">r</span></pre><div class="docs">
                        <p>
                          If all elements are accessible via <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3046" data-verso-hover="498">r</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3046" data-verso-hover="498">r</span></code> is well-founded.</p>
                        </div>
                      </div>
                    </div>
                  </div>
                <div class="namedocs" id="Acc___intro">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Acc.intro" title="Permalink">ðŸ”—</a></span><span class="label">inductive predicate</span><pre class="signature hl lean block"><div class="wide-only">Acc.{u} {<span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} (<span class="var token" data-binding="var-_uniq.3141" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) : <span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only">Acc.{u} {<span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} (<span class="var token" data-binding="var-_uniq.3141" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) :
  <span class="var token" data-binding="var-_uniq.3137" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1122">Acc</span></a></code> is the accessibility predicate. Given some relation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3053" data-verso-hover="498">r</span></code> (e.g. <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span></code>) and a value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3092" data-verso-hover="1123">x</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1122">Acc</span></a> <span class="var token" data-binding="var-_uniq.3053" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.3092" data-verso-hover="46">x</span></code> means that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3092" data-verso-hover="46">x</span></code> is accessible through <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3053" data-verso-hover="498">r</span></code>:</p>
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> is accessible if there exists no infinite sequence <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">yâ‚‚</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">yâ‚</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">yâ‚€</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">x</span></code>.</p>
                    <h1>
                      Constructors</h1>
                    <div class="constructor">
                      <pre class="name-and-type hl lean">intro.{u} {<span class="var token" data-binding="var-_uniq.3124" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} {<span class="var token" data-binding="var-_uniq.3128" data-verso-hover="498">r</span> : <span class="var token" data-binding="var-_uniq.3124" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3124" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>} (<span class="var token" data-binding="var-_uniq.3129" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.3124" data-verso-hover="168">Î±</span>)
  (<span class="var token" data-binding="var-_uniq.3133" data-verso-hover="1124">h</span> : âˆ€ (<span class="var token" data-binding="var-_uniq.3131" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.3124" data-verso-hover="168">Î±</span>), <span class="var token" data-binding="var-_uniq.3128" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.3131" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.3129" data-verso-hover="46">x</span> â†’ <a href="Definitions/Recursive-Definitions/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1122">Acc</span></a> <span class="var token" data-binding="var-_uniq.3128" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.3131" data-verso-hover="46">y</span>) : <a href="Definitions/Recursive-Definitions/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1122">Acc</span></a> <span class="var token" data-binding="var-_uniq.3128" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.3129" data-verso-hover="46">x</span></pre><div class="docs">
                        <p>
                          A value is accessible if for all <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3163" data-verso-hover="1125">y</span></code> such that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3148" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.3163" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.3149" data-verso-hover="46">x</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3163" data-verso-hover="46">y</span></code> is also accessible.
Note that if there exists no <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3163" data-verso-hover="46">y</span></code> such that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3148" data-verso-hover="498">r</span> <span class="var token" data-binding="var-_uniq.3163" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.3149" data-verso-hover="46">x</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3149" data-verso-hover="46">x</span></code> is accessible. Such an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3149" data-verso-hover="46">x</span></code> is called a
<em>base case</em>.</p>
                        </div>
                      </div>
                    </div>
                  </div>
                <details class="example"><summary class="description">Division by Iterated Subtraction: Termination Proof</summary><div class="example-content">
                    <p>
                      The definition of division by iterated subtraction can be written explicitly using well-founded recursion.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-34335">noncomputable</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34349">def</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">(</span><a href="Type-Classes/Instance-Synthesis/#inferInstanceAs"><span class="const token" data-binding="const-inferInstanceAs" data-verso-hover="1126">inferInstanceAs</span></a> <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="986">WellFoundedRelation</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.wf" data-verso-hover="1127">wf</span></a><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-34436">fun</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="1128">r</span> <span class="unknown token" data-binding="">=&gt;</span>
      <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34453" data-verso-hover="1005">if</span></a> <span class="var token" data-binding="var-_uniq.90" data-verso-hover="1129">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34453" data-verso-hover="1005">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
      <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34453" data-verso-hover="1005">else</span></a> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34484" data-verso-hover="1005">if</span></a> <span class="var token" data-binding="var-_uniq.130" data-verso-hover="1130">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34484" data-verso-hover="1005">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
      <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34484" data-verso-hover="1005">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.47" data-verso-hover="1128">r</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span> <span class="tactic"><label for="tactic-state-15182234035332568544-34533-34535"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-34533" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15182234035332568544-34533-34535"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.47" data-verso-hover="1128">r</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.744" data-verso-hover="7">y</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) â†’ <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="991">WellFoundedRelation.rel</span></a> <span class="var token" data-binding="var-_uniq.744" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1131">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.130" data-verso-hover="1132">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="991">WellFoundedRelation.rel</span></a> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span></span></span>
        <span class="tactic"><label for="tactic-state-10140118948777471755-34544-34560"><a href="Tactic-Proofs/Tactic-Reference/#show"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticShow_-34544" data-verso-hover="1134">show</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10140118948777471755-34544-34560"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.47" data-verso-hover="1128">r</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.744" data-verso-hover="7">y</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) â†’ <a href="Definitions/Recursive-Definitions/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="991">WellFoundedRelation.rel</span></a> <span class="var token" data-binding="var-_uniq.744" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1131">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.130" data-verso-hover="1132">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span></span></span>
        <span class="tactic"><label for="tactic-state-7-34569-34574"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-34569" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-34569-34574"><span class="tactic-state">All goals completed! ðŸ™</span></span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
    <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The definition must be marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">noncomputable</code></span> because well-founded recursion is not supported by the compiler.
Like <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-recursor">recursors</a>, it is part of Lean's logic.</p>
                    <p>
                      The definition of division should satisfy the following equations:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">âˆ€</span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3167" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3169" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3169" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.3167" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3169" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">âˆ€</span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3223" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3225" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3225" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.3223" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.3223" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3225" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">âˆ€</span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3258" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3260" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3260" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">â‰ </span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â¬</span> <span class="var token" data-binding="var-_uniq.3260" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.3258" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.3258" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3260" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3258" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.3260" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.3260" data-verso-hover="7">k</span></code></p>
                        </li>
                      </ul>
                    <p>
                      This reduction behavior does not hold <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35192">theorem</span> <span class="const token" data-binding="const-div.eq0" data-verso-hover="1135">div.eq0</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">n</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5449894293515897433-35225-35227"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35225" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5449894293515897433-35225-35227"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span> <span class="tactic"><label for="tactic-state-5449894293515897433-35228-35231"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">tactic 'rfl' failed, the left-hand side
  div n 0
is not definitionally equal to the right-hand side
  0
n : Nat
âŠ¢ div n 0 = 0</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-35228" data-verso-hover="14">rfl</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5449894293515897433-35228-35231"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>tactic 'rfl' failed, the left-hand side
  div n 0
is not definitionally equal to the right-hand side
  0
n : Nat
âŠ¢ div n 0 = 0
</pre></div>
                    <p>
                      However, using <code>WellFounded.fix_eq</code> to unfold the well-founded recursion, the three equations can be proved to hold:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35515">theorem</span> <span class="const token" data-binding="const-div.eq0" data-verso-hover="1135">div.eq0</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">n</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5449894293515897433-35548-35550"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35548" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5449894293515897433-35548-35550"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-11125293433003331971-35553-35563"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-35553" data-verso-hover="770">unfold</span></a> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11125293433003331971-35553-35563"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.117" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : 0<span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.117" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a>0<a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <span class="var token" data-binding="var-_uniq.39" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-35566-35590"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-35566" data-verso-hover="692">apply</span></a> <span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1119">WellFounded.fix_eq</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-35566-35590"><span class="tactic-state">All goals completed! ðŸ™</span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35592">theorem</span> <span class="const token" data-binding="const-div.eq1" data-verso-hover="1137" id="div___eq2">div.eq1</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.100" data-verso-hover="1040">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.106" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.106" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.100" data-verso-hover="1040">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-9706833320884242727-35635-35637"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35635" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9706833320884242727-35635-35637"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span> â†’ <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7657319647417207033-35640-35647"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-35640" data-verso-hover="662">intro</span></a> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="1130">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7657319647417207033-35640-35647"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1130">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-12715970610315038571-35650-35660"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-35650" data-verso-hover="770">unfold</span></a> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12715970610315038571-35650-35660"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1130">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1539" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1541" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.1539" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1541" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1539" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-16940329486092674663-35663-35686"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-35663" data-verso-hover="1138">rw</span></a> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1119">WellFounded.fix_eq</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16940329486092674663-35663-35686"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1130">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">(<span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0
  <span class="keyword token" data-binding="">else</span>
    <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0
    <span class="keyword token" data-binding="">else</span>
      1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> +
        </span></a>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1540" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.1542" data-verso-hover="1139">x</span> =&gt; <span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1565" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1567" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.1565" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1567" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1565" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <span class="var token" data-binding="var-_uniq.1540" data-verso-hover="7">y</span>)
          <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-12344369792222395009-35689-35752"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-35689" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-35694">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-gt_iff_lt" data-verso-hover="1140">gt_iff_lt</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-dite_eq_ite" data-verso-hover="1141">dite_eq_ite</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-ite_eq_left_iff" data-verso-hover="1142">ite_eq_left_iff</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Nat.not_lt" data-verso-hover="1143">Nat.not_lt</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12344369792222395009-35689-35752"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1130">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 â†’
  <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span> â†’ 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1554" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1556" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1554" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1556" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1554" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-12075153119183770139-35755-35761"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-35755" data-verso-hover="379">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12075153119183770139-35755-35761"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1130">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1426" data-verso-hover="1131">aâœÂ¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1427" data-verso-hover="1144">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1551" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1553" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1551" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1553" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1551" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.160" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-35763-35768"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-35763" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-35763-35768"><span class="tactic-state">All goals completed! ðŸ™</span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35770">theorem</span> <span class="const token" data-binding="const-div.eq2" data-verso-hover="1145" id="div___eq2">div.eq2</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">Â¬</span> <span class="var token" data-binding="var-_uniq.1524" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">Â¬</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1524" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.1556" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.1556" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1524" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1556" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.1524" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.1524" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-2061149827759679795-35855-35857"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35855" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2061149827759679795-35855-35857"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 â†’ <a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span> â†’ <span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-16711679257976590035-35860-35866"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-35860" data-verso-hover="379">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16711679257976590035-35860-35866"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1725" data-verso-hover="1131">aâœÂ¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1726" data-verso-hover="1132">aâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div" data-verso-hover="985">div</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-4754458926339738883-35869-35879"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-35869" data-verso-hover="770">unfold</span></a> <span class="const token" data-binding="const-div" data-verso-hover="985">div</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4754458926339738883-35869-35879"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1725" data-verso-hover="1131">aâœÂ¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1726" data-verso-hover="1132">aâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7808" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.7810" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.7808" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7810" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.7808" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7863" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.7865" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.7863" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.7863" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-1374489250839704902-35882-35905"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-35882" data-verso-hover="1138">rw</span></a> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1119">WellFounded.fix_eq</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1374489250839704902-35882-35905"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1725" data-verso-hover="1131">aâœÂ¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1726" data-verso-hover="1132">aâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">(<span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0
  <span class="keyword token" data-binding="">else</span>
    <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0
    <span class="keyword token" data-binding="">else</span>
      1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> +
        </span></a>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7809" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.7811" data-verso-hover="1139">x</span> =&gt; <span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7834" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.7836" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.7834" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7836" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.7834" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <span class="var token" data-binding="var-_uniq.7809" data-verso-hover="7">y</span>)
          <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7893" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.7895" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1133"> &gt; </span><span class="var token" data-binding="var-_uniq.7893" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7895" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.7893" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-1639961710028056423-35908-36015"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-35908" data-verso-hover="666">simp_all</span></a> <span class="keyword token" data-binding="kw-occ-null-35917">only</span> <span class="unknown token" data-binding="">[</span>
    <span class="const token" data-binding="const-gt_iff_lt" data-verso-hover="1140">gt_iff_lt</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Nat.not_lt" data-verso-hover="1143">Nat.not_lt</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-dite_false" data-verso-hover="1146">dite_false</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-dite_eq_ite" data-verso-hover="1141">dite_eq_ite</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-ite_false" data-verso-hover="1147">ite_false</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-ite_eq_right_iff" data-verso-hover="1148">ite_eq_right_iff</span>
  <span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1639961710028056423-35908-36015"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1725" data-verso-hover="1131">aâœÂ¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7689" data-verso-hover="1144">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="376"> â‰¤ </span></a><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span> â†’ 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div._proof_2" data-verso-hover="1136">_proof_2</span>.<a href="Definitions/Recursive-Definitions/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1114">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7821" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.7823" data-verso-hover="1128">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.7821" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7823" data-verso-hover="1128">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.7821" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a> â‹¯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">(</span></a><span class="var token" data-binding="var-_uniq.1723" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614"> - </span></a><span class="var token" data-binding="var-_uniq.1722" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="614">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-36018-36023"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-36018" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-36018-36023"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              </section>
            <section>
              <h2 id="partial-fixpoint">
                7.6.4.Â Partial Fixpoint Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                All definitions are fundamentally equations: the new constant being defined is equal to the right-hand side of the definition.
For functions defined by <a href="Definitions/Recursive-Definitions/#structural-recursion">structural recursion</a>, this equation holds <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a>, and there is a unique value returned by application of the function.
For functions defined by <a href="Definitions/Recursive-Definitions/#well-founded-recursion">well-founded recursion</a>, the equation may hold only <a class="technical-term" href="The-Type-System/Propositions/#--tech-term-Propositions">propositionally</a>, but all type-correct applications of the function to arguments are equal to the respective values prescribed by the definition.
In both cases, the fact that the function terminates for all inputs means that the value computed by applying the function is always uniquely determined.</p>
              <p>
                In some cases where a function does not terminate for all arguments, the equation may not <em>uniquely</em> determine the function's return value for each input, but there are nonetheless functions for which the defining equation holds.
In these cases, a definition as a <span id="--tech-term-partial-fixpoint" class="def-technical-term"><em>partial fixpoint</em></span> may still be possible.
Any function that satisfies the defining equation can be used to demonstrate that the equation does not create a logical contradiction, and the equation can then be proven as a theorem about this function.
As with the other strategies for defining recursive functions, compiled code uses the function as it was originally written; like definitions in terms of eliminators or recursion over accessibility proofs, the function used to define the partial fixpoint is used only to justify the function's equations in Lean's logic for purposes of mathematical reasoning.</p>
              <p>
                The term <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-partial-fixpoint"><em>partial fixpoint</em></a> is specific to Lean.
Functions declared <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span> do not require termination proofs, so long as the type of their return values is inhabited, but they are completely opaque from the perspective of Lean's logic.
Partial fixpoints, on the other hand, can be rewritten using their defining equations while writing proofs.
Logically speaking, partial fixpoints are total functions that don't reduce <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a> when applied, but for which equational rewrite rule are provided.
They are <em>partial</em> in the sense that the defining equation does not necessarily specify a value for all possible arguments.</p>
              <p>
                While partial fixpoints do allow functions to be defined that cannot be expressed using structural or well-founded recursion, the technique is also useful in other cases.
Even in cases where the defining equation fully describes the function's behavior and a termination proof using <a href="Definitions/Recursive-Definitions/#well-founded-recursion">well-founded recursion</a> would be possible, it may simply be more convenient to define the function as a partial fixpoint to avoid a having to write a termination proof.</p>
              <p>
                Defining recursive functions as partial fixpoints only occurs when explicitly requested by annotating the definition with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span>.</p>
              <div class="paragraph">
                <p>
                  There are two classes of functions that can be defined as partial fixpoints:</p>
                <ul>
                  <li>
                    <p>
                      Tail-recursive functions whose return type is inhabited type</p>
                    </li>
                  <li>
                    <p>
                      Functions that return values in a suitable monad, such as the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> monad</p>
                    </li>
                  </ul>
                <p>
                  Both classes are backed by the same theory and construction: least fixpoints of monotone equations in chain-complete partial orders.</p>
                </div>
              <p>
                Just as with structural and well-founded recursion, Lean allows <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutually-recursive">mutually recursive</a> functions to be defined as partial fixpoints.
To use this feature, every function definition in a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutual-block">mutual block</a> must be annotated with the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span> modifier.</p>
              <details class="example"><summary class="description">Definition by Partial Fixpoint</summary><div class="example-content">
                  <p>
                    The following function finds the least natural number for which the predicate <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.5" data-verso-hover="1149">p</span></code> holds.
If <code>p</code> never holds, then this equation does not specify the behavior: the function <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#find"><span class="const token" data-binding="const-find" data-verso-hover="1150">find</span></a></code> could return <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">42</span></code> or any other <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> in that case and still satisfy the equation.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4647">def</span> <span class="const token" data-binding="const-find" data-verso-hover="1150" id="find">find</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1149">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1151">i</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-4701" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1149">p</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="1151">i</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-4701" data-verso-hover="137">then</span></a>
    <span class="var token" data-binding="var-_uniq.22" data-verso-hover="1151">i</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-4701" data-verso-hover="137">else</span></a>
    <a href="Definitions/Recursive-Definitions/#find"><span class="const token" data-binding="const-find" data-verso-hover="1150">find</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1149">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1151">i</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-4745" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                    The elaborator can prove that functions satisfying the equation exist.
Within Lean's logic, <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#find"><span class="const token" data-binding="const-find" data-verso-hover="1150">find</span></a></code> is defined to be an arbitrary such function.</p>
                  </div>
                </details><section>
                <h3 id="partial-fixpoint-tailrec">
                  7.6.4.1.Â Tail-Recursive Functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint-tailrec" title="Permalink">ðŸ”—</a></span></h3>
                <div class="paragraph">
                  <p>
                    A recursive function can be defined as a partial fixpoint if the following two conditions hold:</p>
                  <ol start="1">
                    <li>
                      <p>
                        The function's return type is inhabited (as with <a href="Definitions/Recursive-Definitions/#partial-unsafe">functions marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span></a>) - either a <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Nonempty___intro"><span class="const token" data-binding="const-Nonempty" data-verso-hover="777">Nonempty</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a></code> instance works.</p>
                      </li>
                    <li>
                      <p>
                        All recursive calls are in <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-tail-position">tail position</a> of the function.</p>
                      </li>
                    </ol>
                  <p>
                    An expression is in <span id="--tech-term-tail-position" class="def-technical-term"><em>tail position</em></span> in the function body if it is:</p>
                  <ul>
                    <li>
                      <p>
                        the function body itself,</p>
                      </li>
                    <li>
                      <p>
                        the branches of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression that is in tail position,</p>
                      </li>
                    <li>
                      <p>
                        the branches of an <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> expression that is in tail position, and</p>
                      </li>
                    <li>
                      <p>
                        the body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.let : term</code><span class="sep"></span><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat Ã— Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></code><code class="kw">let</code></span> expression that is in tail position.</p>
                      </li>
                    </ul>
                  <p>
                    In particular, the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression, the condition of an <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> expression and the arguments of functions are not tail positions.</p>
                  </div>
                <details class="example"><summary class="description">Loops are Tail Recursive Functions</summary><div class="example-content">
                    <p>
                      Because the function body itself is a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-tail-position">tail position</a>, the infinitely looping function <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#loop"><span class="const token" data-binding="const-loop" data-verso-hover="1153">loop</span></a></code> is tail recursive.
It can be defined as a partial fixpoint.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6570">def</span> <span class="const token" data-binding="const-loop" data-verso-hover="1153" id="loop">loop</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#loop"><span class="const token" data-binding="const-loop" data-verso-hover="1153">loop</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-6611" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Tail Recursion with Branching</summary><div class="example-content">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Array___find"><span class="const token" data-binding="const-Array.find" data-verso-hover="1154">Array.find</span></a></code> could also be constructed using well-founded recursion with a termination proof, but may be more convenient to define using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span>, where no termination proof is needed.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6935">def</span> <span class="const token" data-binding="const-Array.find" data-verso-hover="1154" id="Array___find">Array.find</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="303">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1151">i</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-7020" data-verso-hover="1005">if</span></a> <span class="var token" data-binding="var-_uniq.66" data-verso-hover="160">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="1151">i</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="303">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-7020" data-verso-hover="1005">then</span></a>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7048" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="303">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1151">i</span><span class="unknown token" data-binding="">]</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7048" data-verso-hover="137">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="303">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1151">i</span><span class="unknown token" data-binding="">]</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7048" data-verso-hover="137">else</span></a>
      <a href="Definitions/Recursive-Definitions/#Array___find"><span class="const token" data-binding="const-Array.find" data-verso-hover="1154">Array.find</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="303">xs</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1151">i</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-7020" data-verso-hover="1005">else</span></a>
    <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-7136" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                      If the result of the recursive call is not just returned, but passed to another function, it is not in tail position and this definition fails.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7364">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1155">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-7427" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-7427" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="337">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.68" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.69" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7471" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.68" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7471" data-verso-hover="137">then</span></a>
      <span class="typed token" data-binding="" data-verso-hover="337">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7471" data-verso-hover="137">else</span></a>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-7506">have</span> <span class="var token" data-binding="var-_uniq.177" data-verso-hover="337">r</span> <span class="unknown token" data-binding="">:=</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    let_fun r := ysâœ.findIndex p;
    if r = -1 then -1 else r + 1
  </code></span></span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1155">List.findIndex</span></span> <span class="var token" data-binding="var-_uniq.69" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7542" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.177" data-verso-hover="337">r</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="337">1</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7542" data-verso-hover="137">then</span></a> <span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="337">1</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7542" data-verso-hover="137">else</span></a> <span class="var token" data-binding="var-_uniq.177" data-verso-hover="337">r</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="337">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-7571" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The error message on the recursive call is:</p>
                    <div class="error">
                      <pre>Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    let_fun r := ysâœ.findIndex p;
    if r = -1 then -1 else r + 1
  
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="partial-fixpoint-monadic">
                  7.6.4.2.Â Monadic functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint-monadic" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  Defining a function as a partial fixpoint is more powerful if the function's return type is a monad that is an instance of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.MonoBind" data-verso-hover="1156">Lean.Order.MonoBind</span></code>, such as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code>.
In this case, recursive call are not restricted to tail-positions, but may also occur inside higher-order monadic functions such as <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1157">bind</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1158">List.mapM</span></a></code>.</p>
                <p>
                  The set of higher-order functions for which this works is <a href="Definitions/Recursive-Definitions/#partial-fixpoint-theory">extensible</a>, so no exhaustive list is given here.
The aspiration is that a monadic recursive function definition that is built using abstract monadic operations like <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1157">bind</span></a></code>, but that does not open the abstraction of the monad (e.g. by matching on the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> value), is accepted.
In particular, using <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a> should work.</p>
                <details class="example"><summary class="description">Monadic functions</summary><div class="example-content">
                    <p>
                      The following function implements the Ackermann function in the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> monad, and is accepted without an (explicit or implicit) termination proof:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8972">def</span> <span class="const token" data-binding="const-ack" data-verso-hover="1159">ack</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span>   <span class="var token" data-binding="var-_uniq.38" data-verso-hover="7">y</span>   <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="7">y</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.167" data-verso-hover="7">x</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>   <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1159">ack</span> <span class="var token" data-binding="var-_uniq.167" data-verso-hover="7">x</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.277" data-verso-hover="7">x</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.278" data-verso-hover="7">y</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-9076">do</span></a> <span class="const token" data-binding="const-ack" data-verso-hover="1159">ack</span> <span class="var token" data-binding="var-_uniq.277" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-ack" data-verso-hover="1159">ack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.277" data-verso-hover="7">x</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.278" data-verso-hover="7">y</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-9103" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Recursive calls may also occur within higher-order functions such as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1158">List.mapM</span></a></code>, if they are set up appropriately, and <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-9330">structure</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1160">Tree</span> <span class="keyword token" data-binding="kw-occ-null-9345">where</span> <span class="const token" data-binding="const-Tree.cs" data-verso-hover="1161" id="Tree___rev___">cs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="const token" data-binding="const-Tree" data-verso-hover="1160">Tree</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9367">def</span> <span class="const token" data-binding="const-Tree.rev" data-verso-hover="1162" id="Tree___rev___">Tree.rev</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.482" data-verso-hover="1163">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1160">Tree</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <span class="const token" data-binding="const-Tree" data-verso-hover="1160">Tree</span> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-9408">do</span></a>
  <span class="const token" data-binding="const-Tree.mk" data-verso-hover="1164">Tree.mk</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <span class="var token" data-binding="var-_uniq.482" data-verso-hover="1163">t</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___rev___"><span class="const token" data-binding="const-Tree.cs" data-verso-hover="1161">cs</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___reverse"><span class="const token" data-binding="const-List.reverse" data-verso-hover="182">reverse</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1158">mapM</span></a> <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#Tree___rev___"><span class="const token" data-binding="const-Tree.rev" data-verso-hover="1162">Tree.rev</span></a> <span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-9459" data-verso-hover="1152">partial_fixpoint</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9477">def</span> <span class="const token" data-binding="const-Tree.rev'" data-verso-hover="1165" id="Tree___rev___">Tree.rev'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1044" data-verso-hover="1163">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1160">Tree</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <span class="const token" data-binding="const-Tree" data-verso-hover="1160">Tree</span> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-9519">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-9524">let</span> <span class="keyword token" data-binding="kw-occ-null-9528">mut</span> <span class="var token" data-binding="var-_uniq.1200" data-verso-hover="1166">cs</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-9543" data-verso-hover="1013">for</span> <span class="var token" data-binding="var-_uniq.1194" data-verso-hover="1163">c</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-9547">in</span> <span class="var token" data-binding="var-_uniq.1044" data-verso-hover="1163">t</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___rev___"><span class="const token" data-binding="const-Tree.cs" data-verso-hover="1161">cs</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-9543" data-verso-hover="1013">do</span>
    <span class="var token" data-binding="var-_uniq.1200" data-verso-hover="1166">cs</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <span class="var token" data-binding="var-_uniq.1194" data-verso-hover="1163">c</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___rev___"><span class="const token" data-binding="const-Tree.rev'" data-verso-hover="1165">rev'</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.1200" data-verso-hover="1166">cs</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-9591" data-verso-hover="231">return</span> <span class="const token" data-binding="const-Tree.mk" data-verso-hover="1164">Tree.mk</span> <span class="var token" data-binding="var-_uniq.1200" data-verso-hover="1166">cs</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-9609" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Pattern matching on the result of the recursive call will prevent the definition by partial fixpoint from going through:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9813">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9883" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9883" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-9929" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-9929" data-verso-hover="137">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-9929" data-verso-hover="137">else</span></a>
      <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9969" data-verso-hover="52">match</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    match ysâœ.findIndex p with
    | none =&gt; none
    | some r =&gt; some (r + 1)
  </code></span></span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span></span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9969" data-verso-hover="52">with</span></a>
      <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
      <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.184" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-10052" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    match ysâœ.findIndex p with
    | none =&gt; none
    | some r =&gt; some (r + 1)
  
</pre></div>
                    <p>
                      In this particular case, using <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168">Functor.map</span></a></code> instead of explicit pattern matching helps:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10427">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-10497" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-10497" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-10543" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-10543" data-verso-hover="137">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-10543" data-verso-hover="137">else</span></a>
      <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-10616" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="partial-correctness-theorem">
                  7.6.4.3.Â Partial Correctness Theorems<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-correctness-theorem" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  For every function defined as a partial fixpoint, Lean proves that the defining equation is satisfied.
This enables proofs by rewriting.
However, these equational theorems are not sufficient for reasoning about the behavior of the function on arguments for which the function specification does not terminate.
Code paths that lead to infinite recursion at runtime would end up as infinite chains of rewrites in a potential proof.</p>
                <p>
                  Partial fixpoints in suitable monads, on the other hand, provide additional theorems that map the undefined values from non-termination to suitable values in the monad.
In the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> monad, then partial fixpoint equals <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">Option.none</span></a></code> on all function inputs for which the defining equation specifies non-termination.
From this fact, Lean proves a <span id="--tech-term-partial-correctness-theorem" class="def-technical-term"><em>partial correctness theorem</em></span> for the function which allows facts to be concluded when the function's result is <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">Option.some</span></a></code>.</p>
                <details class="example"><summary class="description">Partial Correctness Theorem</summary><div class="example-content">
                    <p>
                      Recall <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span></code> from an earlier example:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11761">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11831" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11831" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11877" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11877" data-verso-hover="137">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11877" data-verso-hover="137">else</span></a>
      <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="241">p</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-11950" data-verso-hover="1152">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                      With this function definition, Lean automatically proves the following partial correctness theorem:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex.partial_correctness" data-verso-hover="1169">List.findIndex.partial_correctness</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u_1</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-12133" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u_1</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1170">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.276" data-verso-hover="1171">h</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1172">findIndex</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
      <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1170">motive</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">r</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
        <span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.42" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
          <span class="unknown token" data-binding="">(</span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-12383" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.40" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-12383" data-verso-hover="52">with</span></a>
              <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
              <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.81" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
                <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12467" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.81" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12467" data-verso-hover="137">then</span></a> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
                <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12467" data-verso-hover="137">else</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-12515">fun</span> <span class="var token" data-binding="var-_uniq.138" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.138" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">â†’</span>
            <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1170">motive</span> <span class="var token" data-binding="var-_uniq.40" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="7">r</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.279" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.281" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="var token" data-binding="var-_uniq.279" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">findIndex</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.281" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1170">motive</span> <span class="var token" data-binding="var-_uniq.279" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.281" data-verso-hover="7">r</span></code><div class="paragraph">
                      <p>
                        Here, the motive is a relation between the parameter and return types of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span></code>, with the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> removed from the return type.
If, when given an arbitrary partial function with a signature that's compatible with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span></code>, the following hold:</p>
                      <ul>
                        <li>
                          <p>
                            the motive is satisfied for all inputs for which the arbitrary function returns a value (rather than <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a></code>),</p>
                          </li>
                        <li>
                          <p>
                            taking one rewriting step with the defining equation, in which the recursive calls are replaced by the arbitrary function, also implies the satisfaction of the motive</p>
                          </li>
                        </ul>
                      <p>
                        then the motive is satsified for all inputs for which the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">List.findIndex</span></code> returns <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a></code>.</p>
                      </div>
                    <p>
                      The partial correctness theorem is a reasoning principle.
It can be used to prove that the resulting number is a valid index in the list and that the predicate holds for that index:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-13552">theorem</span> <span class="const token" data-binding="const-List.findIndex_implies_pred" data-verso-hover="1173" id="List___findIndex_implies_pred">List.findIndex_implies_pred</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">findIndex</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="unknown token" data-binding="">âˆƒ</span><span class="var token" data-binding="var-_uniq.86" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">i</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.86" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">âˆ§</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.86" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3378775133195564665-13696-13698"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-13696" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3378775133195564665-13696-13698"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span>.<span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">findIndex</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-519700894703025599-13701-13806"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-13701" data-verso-hover="692">apply</span></a> <span class="const token" data-binding="const-List.findIndex.partial_correctness" data-verso-hover="1169">List.findIndex.partial_correctness</span>
          <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13763">fun</span> <span class="var token" data-binding="var-_uniq.271" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.274" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">âˆƒ</span> <span class="var token" data-binding="var-_uniq.279" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.271" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.274" data-verso-hover="7">i</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.279" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">âˆ§</span> <span class="var token" data-binding="var-_uniq.268" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.279" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-519700894703025599-13701-13806"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-164" checked="checked"><span for="--verso-unique-164" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="1172">findIndex</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>),
  (âˆ€ (<span class="var token" data-binding="var-_uniq.11847" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11849" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11847" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11849" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11851" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11847" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11851" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11851" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>) â†’
    âˆ€ (<span class="var token" data-binding="var-_uniq.11780" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11782" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>),
      (<span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="51">xs</span> <span class="keyword token" data-binding="">with</span>
          | <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a> =&gt; <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
          | <span class="var token" data-binding="var-_uniq.11838" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.11839" data-verso-hover="51">ys</span> =&gt; <span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11800" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.11819" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.11819" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11801" data-verso-hover="51">ys</span>)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
          </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11782" data-verso-hover="7">r</span> â†’
        <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11784" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11782" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11784" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11784" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-17089949819858075006-13809-13838"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-13809" data-verso-hover="662">intro</span></a> <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span> <span class="var token" data-binding="var-_uniq.494" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span> <span class="var token" data-binding="var-_uniq.500" data-verso-hover="1177">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17089949819858075006-13809-13838"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-165" checked="checked"><span for="--verso-unique-165" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.494" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.500" data-verso-hover="1177">hsome</span></span><span class="colon">:</span><span class="type">(<span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.494" data-verso-hover="51">xs</span> <span class="keyword token" data-binding="">with</span>
  | <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a> =&gt; <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  | <span class="var token" data-binding="var-_uniq.11817" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.11818" data-verso-hover="51">ys</span> =&gt; <span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11779" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.11798" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.11798" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="51">ys</span>)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.494" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-4337908586389760410-13841-13855"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-13841" data-verso-hover="632">split</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-13847" data-verso-hover="695">at</span> <span class="var token" data-binding="var-_uniq.500" data-verso-hover="1177">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4337908586389760410-13841-13855"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-166" checked="checked"><span for="--verso-unique-166" class="goal-name">h.h_1</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.671" data-verso-hover="1178">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-167"><span for="--verso-unique-167" class="goal-name">h.h_2</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">xâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ysâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.674" data-verso-hover="1179">hsome</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">xâœ</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.11792" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.11792" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ysâœ</span><span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">xâœ</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ysâœ</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
  <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Â«tacticNext_=>_Â»-13858" data-verso-hover="1180">next</span></a> <span class="tactic"><label for="tactic-state-4966550787009799056-13863-13865"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4966550787009799056-13863-13865"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.671" data-verso-hover="1178">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-13866-13879"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-13866" data-verso-hover="1181">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13866-13879"><span class="tactic-state">All goals completed! ðŸ™</span></span>
  <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Â«tacticNext_=>_Â»-13882" data-verso-hover="1180">next</span></a> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span> <span class="tactic"><label for="tactic-state-16279374108120480620-13892-13894"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16279374108120480620-13892-13894"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.674" data-verso-hover="1182">hsome</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.11792" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.11792" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-9127331090553039954-13899-13913"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-13899" data-verso-hover="632">split</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-13905" data-verso-hover="695">at</span> <span class="var token" data-binding="var-_uniq.674" data-verso-hover="1182">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9127331090553039954-13899-13913"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-170" checked="checked"><span for="--verso-unique-170" class="goal-name">isTrue</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.702" data-verso-hover="1183">hâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.956" data-verso-hover="1184">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-171"><span for="--verso-unique-171" class="goal-name">isFalse</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.697" data-verso-hover="1185">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1226" data-verso-hover="1186">hsome</span></span><span class="colon">:</span><span class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.11790" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.11790" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
    <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Â«tacticNext_=>_Â»-13918" data-verso-hover="1180">next</span></a> <span class="tactic"><label for="tactic-state-18299304774060407056-13923-13925"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18299304774060407056-13923-13925"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.702" data-verso-hover="1183">hâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.956" data-verso-hover="1184">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
      <a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-13932" data-verso-hover="1102">have</span></a> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3378775133195564665-13948-13950"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-13948" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3378775133195564665-13948-13950"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span>.<span class="const token" data-binding="const-List.findIndex" data-verso-hover="1167">findIndex</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-13951-13959"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-13951" data-verso-hover="666">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13951-13959"><span class="tactic-state">All goals completed! ðŸ™</span></span>
      <span class="tactic"><label for="tactic-state-7-13966-13974"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-13966" data-verso-hover="666">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13966-13974"><span class="tactic-state">All goals completed! ðŸ™</span></span>
    <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Â«tacticNext_=>_Â»-13979" data-verso-hover="1180">next</span></a> <span class="tactic"><label for="tactic-state-12152458651906725365-13984-13986"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12152458651906725365-13984-13986"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.697" data-verso-hover="1185">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1226" data-verso-hover="1186">hsome</span></span><span class="colon">:</span><span class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.11790" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.11790" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-9895990532757945385-13993-14052"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-13993" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-13998">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Option.map_eq_map" data-verso-hover="1187">Option.map_eq_map</span><span class="unknown token" data-binding="">,</span> <span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">`Option.map_eq_some'` has been deprecated: use `Option.map_eq_some_iff` instead</code></span></span><span class="const token" data-binding="const-Option.map_eq_some'" data-verso-hover="1188">Option.map_eq_some'</span></span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-14044" data-verso-hover="695">at</span> <span class="var token" data-binding="var-_uniq.1226" data-verso-hover="1186">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9895990532757945385-13993-14052"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.697" data-verso-hover="1185">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9198" data-verso-hover="1189">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="7">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="7">a</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.497" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-13197410477054612749-14059-14092"><a href="Tactic-Proofs/Tactic-Reference/#obtain"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-14059" data-verso-hover="1190">obtain</span></a> <span class="unknown token" data-binding="">âŸ¨</span><span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.9250" data-verso-hover="1191">hr</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.9251" data-verso-hover="1192">rfl</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.9198" data-verso-hover="1189">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13197410477054612749-14059-14092"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-176" checked="checked"><span for="--verso-unique-176" class="goal-name">intro.intro</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span>) (<span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span> â†’ <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.11776" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.11778" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11780" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.697" data-verso-hover="1185">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9250" data-verso-hover="1191">hr</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-17246071985832916431-14099-14119"><a href="Tactic-Proofs/Tactic-Reference/#specialize"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.specialize-14099" data-verso-hover="1193">specialize</span></a> <span class="var token" data-binding="var-_uniq.491" data-verso-hover="1176">ih</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.9250" data-verso-hover="1191">hr</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17246071985832916431-14099-14119"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-177" checked="checked"><span for="--verso-unique-177" class="goal-name">intro.intro</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span> â†’ <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.511" data-verso-hover="51">xsâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.697" data-verso-hover="1185">hâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9250" data-verso-hover="1191">hr</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="1172">findIndex</span> <span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9272" data-verso-hover="1194">ih</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">âˆƒ</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174"> </span></a><span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">(</span></a><span class="var token" data-binding="var-_uniq.560" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.561" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">[</span></a><span class="var token" data-binding="var-_uniq.9228" data-verso-hover="7">r'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1175">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="241">p</span> <span class="var token" data-binding="var-_uniq.11775" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-7-14126-14131"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-14126" data-verso-hover="1195">simpa</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-14126-14131"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="mutual-partial-fixpoint">
                  7.6.4.4.Â Mutual Recursion with Partial Fixpoints<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-partial-fixpoint" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  Lean supports the definition of <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutually-recursive">mutually recursive</a> functions using <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-partial-fixpoint">partial fixpoint</a>.
Mutual recursion may be introduced using a <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-mutual-block">mutual block</a>, but it also results from <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.letrec : term</code></code><code class="kw">let rec</code></span> expressions and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> blocks.
The rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the <a href="Definitions/Recursive-Definitions/#mutual-syntax">elaboration steps</a> for mutual groups.</p>
                <p>
                  If all functions in the mutual group have the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span> clause, then this strategy is used.</p>
                </section>
              <section>
                <h3 id="partial-fixpoint-theory">
                  7.6.4.5.Â Theory and Construction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint-theory" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  The construction builds on a variant of the Knasterâ€“Tarski theorem: In a chain-complete partial order, every monotone function has a least fixed point.</p>
                <p>
                  The necessary theory is found in the <code>Lean.Order</code> namespace.
This is not meant to be a general purpose library of order theoretic results.
Instead, the definitions and theorems in <code>Lean.Order</code> are only intended as implementation details of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span> feature, and they should be considered a private API that may change without notice.</p>
                <p>
                  The notion of a partial order, and that of a chain-complete partial order, are represented by the type classes <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">Lean.Order.PartialOrder</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1197">Lean.Order.CCPO</span></a></code>, respectively.</p>
                <div class="namedocs" id="Lean___Order___PartialOrder___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.PartialOrder.mk" title="Permalink">ðŸ”—</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only">Lean.Order.PartialOrder.{u} (<span class="var token" data-binding="var-_uniq.217" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>) : <span class="sort token" data-binding="" data-verso-hover="169">Sort (max 1 u)</span></div><div class="narrow-only">Lean.Order.PartialOrder.{u} (<span class="var token" data-binding="var-_uniq.217" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>) :
  <span class="sort token" data-binding="" data-verso-hover="169">Sort (max 1 u)</span></div></pre><div class="text">
                    <p>
                      A partial order is a reflexive, transitive and antisymmetric relation.</p>
                    <p>
                      This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.mk" data-verso-hover="1198">Lean.Order.PartialOrder.mk</span></a>.{u}</pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1199">rel</span> : <span class="var token" data-binding="var-_uniq.145" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.145" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="docs">
                        <p>
                          A â€œless-or-equal-toâ€ or â€œapproximatesâ€ relation.</p>
                        <p>
                          This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                        </div>
                      </section>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel_refl" data-verso-hover="1200">rel_refl</span> : âˆ€ {<span class="var token" data-binding="var-_uniq.150" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.145" data-verso-hover="168">Î±</span>}, <span class="var token" data-binding="var-_uniq.150" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.150" data-verso-hover="46">x</span></pre><div class="docs">
                        <p>
                          The â€œless-or-equal-toâ€ or â€œapproximatesâ€ relation is reflexive.</p>
                        </div>
                      </section>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel_trans" data-verso-hover="1202">rel_trans</span> : âˆ€ {<span class="var token" data-binding="var-_uniq.156" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.158" data-verso-hover="46">y </span><span class="var token" data-binding="var-_uniq.160" data-verso-hover="46">z</span> : <span class="var token" data-binding="var-_uniq.145" data-verso-hover="168">Î±</span>}, <span class="var token" data-binding="var-_uniq.156" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.158" data-verso-hover="46">y</span> â†’ <span class="var token" data-binding="var-_uniq.158" data-verso-hover="46">y</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.160" data-verso-hover="46">z</span> â†’ <span class="var token" data-binding="var-_uniq.156" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.160" data-verso-hover="46">z</span></pre><div class="docs">
                        <p>
                          The â€œless-or-equal-toâ€ or â€œapproximatesâ€ relation is transitive.</p>
                        </div>
                      </section>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel_antisymm" data-verso-hover="1203">rel_antisymm</span> : âˆ€ {<span class="var token" data-binding="var-_uniq.177" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.179" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.145" data-verso-hover="168">Î±</span>}, <span class="var token" data-binding="var-_uniq.177" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.179" data-verso-hover="46">y</span> â†’ <span class="var token" data-binding="var-_uniq.179" data-verso-hover="46">y</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.177" data-verso-hover="46">x</span> â†’ <span class="var token" data-binding="var-_uniq.177" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.179" data-verso-hover="46">y</span></pre><div class="docs">
                        <p>
                          The â€œless-or-equal-toâ€ or â€œapproximatesâ€ relation is antisymmetric.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Order___CCPO___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.CCPO" title="Permalink">ðŸ”—</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only">Lean.Order.CCPO.{u} (<span class="var token" data-binding="var-_uniq.361" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>) : <span class="sort token" data-binding="" data-verso-hover="169">Sort (max 1 u)</span></div><div class="narrow-only">Lean.Order.CCPO.{u} (<span class="var token" data-binding="var-_uniq.361" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>) :
  <span class="sort token" data-binding="" data-verso-hover="169">Sort (max 1 u)</span></div></pre><div class="text">
                    <p>
                      A chain-complete partial order (CCPO) is a partial order where every chain has a least upper bound.</p>
                    <p>
                      This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used
otherwise.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO.mk" data-verso-hover="1204">Lean.Order.CCPO.mk</span></a>.{u}</pre><div class="docs"></div>
                      </section>
                    <h1>
                      Extends</h1>
                    <ul class="extends">
                      <li>
                        <input type="checkbox" id="0-Lean.Order.PartialOrder-Lean.Order.CCPO" checked="checked" data-parent-idx="0"><label for="0-Lean.Order.PartialOrder-Lean.Order.CCPO"><code class="hl lean inline"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="168">Î±</span></code></label></li>
                      </ul>
                    <h1>
                      Methods</h1>
                    <section class="subdocs" data-inherited-from="0">
                      <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel</span> : <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="inheritance docs" data-inherited-from="0">
                        Inherited from <ol>
                          <li>
                            <code class="hl lean inline"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="168">Î±</span></code></li>
                          </ol>
                        </div>
                      <div class="docs"></div>
                      </section>
                    <section class="subdocs" data-inherited-from="0">
                      <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel_refl</span> : âˆ€ {<span class="var token" data-binding="var-_uniq.260" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span>}, <span class="var token" data-binding="var-_uniq.260" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.260" data-verso-hover="46">x</span></pre><div class="inheritance docs" data-inherited-from="0">
                        Inherited from <ol>
                          <li>
                            <code class="hl lean inline"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="168">Î±</span></code></li>
                          </ol>
                        </div>
                      <div class="docs"></div>
                      </section>
                    <section class="subdocs" data-inherited-from="0">
                      <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel_trans</span> : âˆ€ {<span class="var token" data-binding="var-_uniq.267" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.269" data-verso-hover="46">y </span><span class="var token" data-binding="var-_uniq.271" data-verso-hover="46">z</span> : <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span>}, <span class="var token" data-binding="var-_uniq.267" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.269" data-verso-hover="46">y</span> â†’ <span class="var token" data-binding="var-_uniq.269" data-verso-hover="46">y</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.271" data-verso-hover="46">z</span> â†’ <span class="var token" data-binding="var-_uniq.267" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.271" data-verso-hover="46">z</span></pre><div class="inheritance docs" data-inherited-from="0">
                        Inherited from <ol>
                          <li>
                            <code class="hl lean inline"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="168">Î±</span></code></li>
                          </ol>
                        </div>
                      <div class="docs"></div>
                      </section>
                    <section class="subdocs" data-inherited-from="0">
                      <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel_antisymm</span> : âˆ€ {<span class="var token" data-binding="var-_uniq.289" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.291" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span>}, <span class="var token" data-binding="var-_uniq.289" data-verso-hover="46">x</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.291" data-verso-hover="46">y</span> â†’ <span class="var token" data-binding="var-_uniq.291" data-verso-hover="46">y</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.289" data-verso-hover="46">x</span> â†’ <span class="var token" data-binding="var-_uniq.289" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.291" data-verso-hover="46">y</span></pre><div class="inheritance docs" data-inherited-from="0">
                        Inherited from <ol>
                          <li>
                            <code class="hl lean inline"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="168">Î±</span></code></li>
                          </ol>
                        </div>
                      <div class="docs"></div>
                      </section>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.CCPO.csup" data-verso-hover="1205">csup</span> : (<span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) â†’ <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span></pre><div class="docs">
                        <p>
                          The least upper bound of a chain.</p>
                        <p>
                          This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used
otherwise.</p>
                        </div>
                      </section>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.CCPO.csup_spec" data-verso-hover="1206">csup_spec</span> : âˆ€ {<span class="var token" data-binding="var-_uniq.307" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span>} {<span class="var token" data-binding="var-_uniq.309" data-verso-hover="471">c</span> : <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>}, <span class="const token" data-binding="const-Lean.Order.chain" data-verso-hover="1207">chain</span> <span class="var token" data-binding="var-_uniq.309" data-verso-hover="471">c</span> â†’ <a href="Basic-Propositions/Logical-Connectives/#Iff___intro"><span class="const token" data-binding="const-Iff" data-verso-hover="205">(</span></a><span class="const token" data-binding="const-Lean.Order.CCPO.csup" data-verso-hover="1208">CCPO.csup</span> <span class="var token" data-binding="var-_uniq.309" data-verso-hover="471">c</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.307" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#Iff___intro"><span class="const token" data-binding="const-Iff" data-verso-hover="205"> â†” </span></a>âˆ€ (<span class="var token" data-binding="var-_uniq.323" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.253" data-verso-hover="168">Î±</span>), <span class="var token" data-binding="var-_uniq.309" data-verso-hover="471">c</span> <span class="var token" data-binding="var-_uniq.323" data-verso-hover="46">y</span> â†’ <span class="var token" data-binding="var-_uniq.323" data-verso-hover="46">y</span><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201"> âŠ‘ </span></a><span class="var token" data-binding="var-_uniq.307" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#Iff___intro"><span class="const token" data-binding="const-Iff" data-verso-hover="205">)</span></a></pre><div class="docs">
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.375" data-verso-hover="1209">csup</span> <span class="var token" data-binding="var-_uniq.381" data-verso-hover="471">c</span></code> is the least upper bound of the chain <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.381" data-verso-hover="471">c</span></code> when all elements <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> that are at
least as large as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.375" data-verso-hover="1209">csup</span> <span class="var token" data-binding="var-_uniq.381" data-verso-hover="471">c</span></code> are at least as large as all elements of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.381" data-verso-hover="471">c</span></code>, and vice versa.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <p>
                  A function is monotone if it preserves partial orders.
That is, if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.410" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">âŠ‘</span> <span class="var token" data-binding="var-_uniq.412" data-verso-hover="46">y</span></code> then <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.436" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.438" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">âŠ‘</span> <span class="var token" data-binding="var-_uniq.436" data-verso-hover="180">f</span> <span class="var token" data-binding="var-_uniq.440" data-verso-hover="46">y</span></code>.
The operator <code>âŠ‘</code> represent <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1201">Lean.Order.PartialOrder.rel</span></a></code>.</p>
                <div class="namedocs" id="Lean___Order___monotone">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.monotone" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Order.monotone.{u, v} {<span class="var token" data-binding="var-_uniq.487" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} [<a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.487" data-verso-hover="168">Î±</span>] {<span class="var token" data-binding="var-_uniq.490" data-verso-hover="177">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>}
  [<a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.490" data-verso-hover="177">Î²</span>] (<span class="var token" data-binding="var-_uniq.494" data-verso-hover="180">f</span> : <span class="var token" data-binding="var-_uniq.487" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.490" data-verso-hover="177">Î²</span>) : <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only">Lean.Order.monotone.{u, v} {<span class="var token" data-binding="var-_uniq.487" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>}
  [<a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.487" data-verso-hover="168">Î±</span>] {<span class="var token" data-binding="var-_uniq.490" data-verso-hover="177">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>}
  [<a href="Definitions/Recursive-Definitions/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1196">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.490" data-verso-hover="177">Î²</span>] (<span class="var token" data-binding="var-_uniq.494" data-verso-hover="180">f</span> : <span class="var token" data-binding="var-_uniq.487" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.490" data-verso-hover="177">Î²</span>) : <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      A function is monotone if it maps related elements to related elements.</p>
                    <p>
                      This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                    </div>
                  </div>
                <p>
                  The fixpoint of a monotone function can be taken using <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1210">fix</span></a></code>, which indeed constructs a fixpoint, as shown by <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___fix_eq"><span class="const token" data-binding="const-Lean.Order.fix_eq" data-verso-hover="1211">fix_eq</span></a></code>,</p>
                <div class="namedocs" id="Lean___Order___fix">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.fix" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Order.fix.{u} {<span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} [<a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1197">CCPO</span></a> <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span>] (<span class="var token" data-binding="var-_uniq.632" data-verso-hover="1212">f</span> : <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span>)
  (<span class="var token" data-binding="var-_uniq.638" data-verso-hover="1213">hmono</span> : <a href="Definitions/Recursive-Definitions/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1214">monotone</span></a> <span class="var token" data-binding="var-_uniq.632" data-verso-hover="1212">f</span>) : <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span></div><div class="narrow-only">Lean.Order.fix.{u} {<span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} [<a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1197">CCPO</span></a> <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span>]
  (<span class="var token" data-binding="var-_uniq.632" data-verso-hover="1212">f</span> : <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span>) (<span class="var token" data-binding="var-_uniq.638" data-verso-hover="1213">hmono</span> : <a href="Definitions/Recursive-Definitions/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1214">monotone</span></a> <span class="var token" data-binding="var-_uniq.632" data-verso-hover="1212">f</span>) : <span class="var token" data-binding="var-_uniq.628" data-verso-hover="168">Î±</span></div></pre><div class="text">
                    <p>
                      The least fixpoint of a monotone function is the least upper bound of its transfinite iteration.</p>
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1214">monotone</span></a> <span class="var token" data-binding="var-_uniq.572" data-verso-hover="1212">f</span></code> assumption is not strictly necessarily for the definition, but without this the
definition is not very meaningful and it simplifies applying theorems like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___fix_eq"><span class="const token" data-binding="const-Lean.Order.fix_eq" data-verso-hover="1211">fix_eq</span></a></code> if every use of
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1210">fix</span></a></code> already has the monotonicty requirement.</p>
                    <p>
                      This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Order___fix_eq">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.fix_eq" title="Permalink">ðŸ”—</a></span><span class="label">theorem</span><pre class="signature hl lean block"><div class="wide-only">Lean.Order.fix_eq.{u} {<span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} [<a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1197">CCPO</span></a> <span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span>] {<span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> : <span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span>}
  (<span class="var token" data-binding="var-_uniq.657" data-verso-hover="1213">hf</span> : <a href="Definitions/Recursive-Definitions/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1214">monotone</span></a> <span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span>) : <a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1210">fix</span></a> <span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> <span class="var token" data-binding="var-_uniq.657" data-verso-hover="1213">hf</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> (<a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1210">fix</span></a> <span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> <span class="var token" data-binding="var-_uniq.657" data-verso-hover="1213">hf</span>)</div><div class="narrow-only">Lean.Order.fix_eq.{u} {<span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>}
  [<a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1197">CCPO</span></a> <span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span>] {<span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> : <span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.647" data-verso-hover="168">Î±</span>} (<span class="var token" data-binding="var-_uniq.657" data-verso-hover="1213">hf</span> : <a href="Definitions/Recursive-Definitions/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1214">monotone</span></a> <span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span>) :
  <a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1210">fix</span></a> <span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> <span class="var token" data-binding="var-_uniq.657" data-verso-hover="1213">hf</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> (<a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1210">fix</span></a> <span class="var token" data-binding="var-_uniq.651" data-verso-hover="1212">f</span> <span class="var token" data-binding="var-_uniq.657" data-verso-hover="1213">hf</span>)</div></pre><div class="text">
                    <p>
                      The main fixpoint theorem for fixedpoints of monotone functions in chain-complete partial orders.</p>
                    <p>
                      This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                    </div>
                  </div>
                <div class="paragraph">
                  <p>
                    To construct the partial fixpoint, Lean first synthesizes a suitable <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1197">CCPO</span></a></code> instance.</p>
                  <ul>
                    <li>
                      <p>
                        If the function's result type has a dedicated instance, like <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> has with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.instCCPOOption" data-verso-hover="1215">instCCPOOption</span></code>, this is used together with the instance for the function type, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.instCCPOPi" data-verso-hover="1216">instCCPOPi</span></code>, to construct an instance for the whole function's type.</p>
                      </li>
                    <li>
                      <p>
                        Otherwise, if the function's type can be shown to be inhabited by a witness <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.831" data-verso-hover="46">w</span></code>, then the instance <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.FlatOrder.instCCPO" data-verso-hover="1217">FlatOrder.instCCPO</span></code> for the wrapper type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.FlatOrder" data-verso-hover="1218">FlatOrder</span> <span class="var token" data-binding="var-_uniq.904" data-verso-hover="46">w</span></code> is used. In this order, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.940" data-verso-hover="46">w</span></code> is a least element and all other elements are incomparable.</p>
                      </li>
                    </ul>
                  </div>
                <p>
                  Next, the recursive calls in the right-hand side of the function definitions are abstracted; this turns into the argument <code>f</code> of <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1210">fix</span></a></code>. The monotonicity requirement is solved by the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1219">monotonicity</span></code> tactic, which applies compositional monotonicity lemmas in a syntax-driven way.</p>
                <p>
                  The tactic solves goals of the form <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1214">monotone</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-17747">fun</span> <span class="var token" data-binding="var-_uniq.1013" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">â€¦</span> <span class="var token" data-binding="var-_uniq.1013" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">â€¦</span><span class="unknown token" data-binding="">)</span></code> using the following steps:</p>
                <ul>
                  <li>
                    <p>
                      Applying <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_const" data-verso-hover="1220">monotone_const</span></code> when there is no dependency on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1112" data-verso-hover="46">x</span></code> left.</p>
                    </li>
                  <li>
                    <p>
                      Splitting on <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expressions.</p>
                    </li>
                  <li>
                    <p>
                      Splitting on <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> expressions.</p>
                    </li>
                  <li>
                    <p>
                      Moving <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.let : term</code><span class="sep"></span><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat Ã— Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></code><code class="kw">let</code></span> expression to the context, if the value and type do not depend on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1147" data-verso-hover="46">x</span></code>.</p>
                    </li>
                  <li>
                    <p>
                      Zeta-reducing a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.let : term</code><span class="sep"></span><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat Ã— Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></code><code class="kw">let</code></span> expression when value and type do depend on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1182" data-verso-hover="46">x</span></code>.</p>
                    </li>
                  <li>
                    <p>
                      Applying lemmas annotated with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1221">partial_fixpoint_monotone</span></code></p>
                    </li>
                  </ul>
                <p>
                  The following monotonicity lemmas are registered, and should allow recursive calls under the given higher-order functions in the arguments indicated by <code>Â·</code> (but not the other arguments, shown as <code>_</code>).</p>
                <style>
table#--monotonicity-lemma-table {
  border-collapse: collapse;
}
table#--monotonicity-lemma-table th {
  text-align: center;
}
table#--monotonicity-lemma-table th, table#--monotonicity-lemma-table th p {
  font-family: var(--verso-structure-font-family);
}
table#--monotonicity-lemma-table td:first-child {
  padding-bottom: 0.25em;
  padding-top: 0.25em;
  padding-left: 0;
  padding-right: 1.5em;
}
  </style><table class="tabular" id="--monotonicity-lemma-table"><tr><th><p>
                        Theorem</p>
                      </th><th><p>
                        Pattern</p>
                      </th></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_allM" data-verso-hover="1222">monotone_allM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___allM"><span class="const token" data-binding="const-Array.allM" data-verso-hover="1223">Array.allM</span></a> Â· _ _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_anyM" data-verso-hover="1224">monotone_anyM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___anyM"><span class="const token" data-binding="const-Array.anyM" data-verso-hover="1225">Array.anyM</span></a> Â· _ _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_anyM_loop" data-verso-hover="1226">monotone_anyM_loop</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.anyM.loop" data-verso-hover="1227">Array.anyM.loop</span> Â· _ _ â‹¯ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_array_filterMapM" data-verso-hover="1228">monotone_array_filterMapM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___filterMapM"><span class="const token" data-binding="const-Array.filterMapM" data-verso-hover="1229">Array.filterMapM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_array_forM" data-verso-hover="1230">monotone_array_forM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___forM"><span class="const token" data-binding="const-Array.forM" data-verso-hover="1231">Array.forM</span></a> Â· _ _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_array_forRevM" data-verso-hover="1232">monotone_array_forRevM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___forRevM"><span class="const token" data-binding="const-Array.forRevM" data-verso-hover="1233">Array.forRevM</span></a> Â· _ _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findIdxM?" data-verso-hover="1234">monotone_findIdxM?</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findIdxM___"><span class="const token" data-binding="const-Array.findIdxM?" data-verso-hover="1235">Array.findIdxM?</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findM?" data-verso-hover="1236">monotone_findM?</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findM___"><span class="const token" data-binding="const-Array.findM?" data-verso-hover="1237">Array.findM?</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findRevM?" data-verso-hover="1238">monotone_findRevM?</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findRevM___"><span class="const token" data-binding="const-Array.findRevM?" data-verso-hover="1239">Array.findRevM?</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findSomeM?" data-verso-hover="1240">monotone_findSomeM?</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findSomeM___"><span class="const token" data-binding="const-Array.findSomeM?" data-verso-hover="1241">Array.findSomeM?</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findSomeRevM?" data-verso-hover="1242">monotone_findSomeRevM?</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findSomeRevM___"><span class="const token" data-binding="const-Array.findSomeRevM?" data-verso-hover="1243">Array.findSomeRevM?</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_flatMapM" data-verso-hover="1244">monotone_flatMapM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___flatMapM"><span class="const token" data-binding="const-Array.flatMapM" data-verso-hover="1245">Array.flatMapM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldlM" data-verso-hover="1246">monotone_foldlM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___foldlM"><span class="const token" data-binding="const-Array.foldlM" data-verso-hover="1247">Array.foldlM</span></a> Â· _ _ _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldlM_loop" data-verso-hover="1248">monotone_foldlM_loop</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.foldlM.loop" data-verso-hover="1249">Array.foldlM.loop</span> Â· _ _ â‹¯ _ _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldrM" data-verso-hover="1250">monotone_foldrM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___foldrM"><span class="const token" data-binding="const-Array.foldrM" data-verso-hover="1251">Array.foldrM</span></a> Â· _ _ _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldrM_fold" data-verso-hover="1252">monotone_foldrM_fold</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.foldrM.fold" data-verso-hover="1253">Array.foldrM.fold</span> Â· _ _ _ â‹¯ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_forIn" data-verso-hover="1254">monotone_forIn</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1255">forIn</span></a> _ _ Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_forIn'" data-verso-hover="1256">monotone_forIn'</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1257">forIn'</span></a> _ _ Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_forIn'_loop" data-verso-hover="1258">monotone_forIn'_loop</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.forIn'.loop" data-verso-hover="1259">Array.forIn'.loop</span> _ Â· _ â‹¯ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_mapFinIdxM" data-verso-hover="1260">monotone_mapFinIdxM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Arrays/#Array___mapFinIdxM"><span class="const token" data-binding="const-Array.mapFinIdxM" data-verso-hover="1261">mapFinIdxM</span></a> Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_mapM" data-verso-hover="1262">monotone_mapM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___mapM"><span class="const token" data-binding="const-Array.mapM" data-verso-hover="1263">Array.mapM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_modifyM" data-verso-hover="1264">monotone_modifyM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Arrays/#Array___modifyM"><span class="const token" data-binding="const-Array.modifyM" data-verso-hover="1265">modifyM</span></a> _ Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Functor.monotone_map" data-verso-hover="1266">monotone_map</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">_<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1168"> &lt;$&gt; </span></a>Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_allM" data-verso-hover="1267">monotone_allM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___allM"><span class="const token" data-binding="const-List.allM" data-verso-hover="1268">List.allM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_anyM" data-verso-hover="1269">monotone_anyM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___anyM"><span class="const token" data-binding="const-List.anyM" data-verso-hover="1270">List.anyM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_filterAuxM" data-verso-hover="1271">monotone_filterAuxM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.filterAuxM" data-verso-hover="1272">List.filterAuxM</span> Â· _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_filterM" data-verso-hover="1273">monotone_filterM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___filterM"><span class="const token" data-binding="const-List.filterM" data-verso-hover="1274">List.filterM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_filterRevM" data-verso-hover="1275">monotone_filterRevM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___filterRevM"><span class="const token" data-binding="const-List.filterRevM" data-verso-hover="1276">List.filterRevM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_findM?" data-verso-hover="1277">monotone_findM?</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___findM___"><span class="const token" data-binding="const-List.findM?" data-verso-hover="1278">List.findM?</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_findSomeM?" data-verso-hover="1279">monotone_findSomeM?</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___findSomeM___"><span class="const token" data-binding="const-List.findSomeM?" data-verso-hover="1280">List.findSomeM?</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_foldlM" data-verso-hover="1281">monotone_foldlM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___foldlM"><span class="const token" data-binding="const-List.foldlM" data-verso-hover="1282">List.foldlM</span></a> Â· _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_foldrM" data-verso-hover="1283">monotone_foldrM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___foldrM"><span class="const token" data-binding="const-List.foldrM" data-verso-hover="1284">List.foldrM</span></a> Â· _ _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forIn" data-verso-hover="1285">monotone_forIn</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1255">forIn</span></a> _ _ Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forIn'" data-verso-hover="1286">monotone_forIn'</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1257">forIn'</span></a> _ _ Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forIn'_loop" data-verso-hover="1287">monotone_forIn'_loop</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.forIn'.loop" data-verso-hover="1288">List.forIn'.loop</span> _ Â· _ _ â‹¯</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forM" data-verso-hover="1289">monotone_forM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Linked-Lists/#List___forM"><span class="const token" data-binding="const-List.forM" data-verso-hover="1290">forM</span></a> Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_mapM" data-verso-hover="1291">monotone_mapM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1158">List.mapM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_bindM" data-verso-hover="1292">monotone_bindM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___bindM"><span class="const token" data-binding="const-Option.bindM" data-verso-hover="1293">Option.bindM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_elimM" data-verso-hover="1294">monotone_elimM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___elimM"><span class="const token" data-binding="const-Option.elimM" data-verso-hover="1295">Option.elimM</span></a> Â· Â· Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_getDM" data-verso-hover="1296">monotone_getDM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Optional-Values/#Option___getDM"><span class="const token" data-binding="const-Option.getDM" data-verso-hover="1297">getDM</span></a> Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_mapM" data-verso-hover="1298">monotone_mapM</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___mapM"><span class="const token" data-binding="const-Option.mapM" data-verso-hover="1299">Option.mapM</span></a> Â· _</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.PProd.monotone_fst" data-verso-hover="1300">monotone_fst</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â·.<a href="Basic-Types/Tuples/#PProd___mk"><span class="const token" data-binding="const-PProd.fst" data-verso-hover="1301">fst</span></a></code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.PProd.monotone_mk" data-verso-hover="1302">monotone_mk</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">âŸ¨Â·, Â·âŸ©</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.PProd.monotone_snd" data-verso-hover="1303">monotone_snd</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â·.<a href="Basic-Types/Tuples/#PProd___mk"><span class="const token" data-binding="const-PProd.snd" data-verso-hover="1304">snd</span></a></code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Seq.monotone_seq" data-verso-hover="1305">monotone_seq</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â· &lt;*&gt; Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.SeqLeft.monotone_seqLeft" data-verso-hover="1306">monotone_seqLeft</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â· &lt;* Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.SeqRight.monotone_seqRight" data-verso-hover="1307">monotone_seqRight</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â· *&gt; Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.coind_monotone_and" data-verso-hover="1308">coind_monotone_and</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â·<a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a>Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.coind_monotone_exists" data-verso-hover="1309">coind_monotone_exists</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">Exists</span></a> Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.coind_monotone_or" data-verso-hover="1310">coind_monotone_or</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â·<a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="378"> âˆ¨ </span></a>Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.implication_order_monotone_and" data-verso-hover="1311">implication_order_monotone_and</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â·<a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="114"> âˆ§ </span></a>Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.implication_order_monotone_exists" data-verso-hover="1312">implication_order_monotone_exists</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1174">Exists</span></a> Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.implication_order_monotone_or" data-verso-hover="1313">implication_order_monotone_or</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â·<a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="378"> âˆ¨ </span></a>Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_bind" data-verso-hover="1314">monotone_bind</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples">Â·<a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1157"> &gt;&gt;= </span></a>Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_dite" data-verso-hover="1315">monotone_dite</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dite" data-verso-hover="1316">dite</span> _ Â· Â·</code></p>
                      </td></tr><tr><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_ite" data-verso-hover="1317">monotone_ite</span></code></p>
                      </td><td><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span>_<span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span>Â·<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>Â·</code></p>
                      </td></tr></table></section>
              </section>
            <section>
              <h2 id="partial-unsafe">
                7.6.5.Â Partial and Unsafe Definitions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-unsafe" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                While most Lean functions can be reasoned about in Lean's type theory as well as compiled and run, definitions marked <code class="plain-keyword">partial</code> or <code class="plain-keyword">unsafe</code> cannot be meaningfully reasoned about.
From the perspective of the logic, <code class="plain-keyword">partial</code> functions are opaque constants, and theorems that refer to <code class="plain-keyword">unsafe</code> definitions are summarily rejected.
In exchange for the inability to use these functions for reasoning, there are far fewer requirements placed on them; this can make it possible to write programs that would be impractical or cost-prohibitive to prove anything about, while not giving up formal reasoning for the rest.
In essence, the <code class="plain-keyword">partial</code> subset of Lean is a traditional functional programming language that is nonetheless deeply integrated with the theorem proving features, and the <code class="plain-keyword">unsafe</code> subset features the ability to break Lean's runtime invariants in certain rare situations, at the cost of less integration with Lean's theorem-proving features.
Analogously, <code class="plain-keyword">noncomputable</code> definitions may use features that don't make sense in programs, but are meaningful in the logic.</p>
              <section>
                <h3 id="partial-functions">
                  7.6.5.1.Â Partial Functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-functions" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  The <code class="plain-keyword">partial</code> modifier may only be applied to function definitions.
Partial functions are not required to demonstrate termination, and Lean does not attempt to do so.
These functions are â€œpartialâ€ in the sense that they do not necessarily specify a mapping from each element of the domain to an element of the codomain, because they might fail to terminate for some or all elements of the domain.
They are elaborated into <a class="technical-term" href="Elaboration-and-Compilation/#--tech-term-pre-definition">pre-definitions</a> that contain explicit recursion, and type checked using the kernel; however, they are subsequently treated as opaque constants by the logic.</p>
                <p>
                  The function's return type must be inhabited; this ensures soundness.
Otherwise, a partial function could have a type such as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/The-Empty-Type/#Empty"><span class="const token" data-binding="const-Empty" data-verso-hover="265">Empty</span></a></code>.
Together with <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#Empty___elim"><span class="const token" data-binding="const-Empty.elim" data-verso-hover="1318">Empty.elim</span></a></code>, the existence of such a function could be used to prove <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> even if it does not reduce.</p>
                <p>
                  With partial definitions, the kernel is responsible for the following:</p>
                <ul>
                  <li>
                    <p>
                      It ensures that the pre-definition's type is indeed a well-formed type.</p>
                    </li>
                  <li>
                    <p>
                      It checks that the pre-definition's type is a function type.</p>
                    </li>
                  <li>
                    <p>
                      It ensures that the function's codomain is inhabited by demanding a <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Nonempty___intro"><span class="const token" data-binding="const-Nonempty" data-verso-hover="777">Nonempty</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a></code> instance.</p>
                    </li>
                  <li>
                    <p>
                      It checks that the resulting term would be type-correct if Lean had recursive definitions.</p>
                    </li>
                  </ul>
                <p>
                  Even though recursive definitions are not part of the kernel's type theory, the kernel can still be used to check that the body of the definition has the right type.
This works the same way as in other functional languages: uses of recursion are type checked by checking the body in an environment in which the definition is already associated with its type.
Having ensured that it type checks, the body is discarded and only the opaque constant is retained by the kernel.
As with all Lean functions, the compiler generates code from the elaborated <a class="technical-term" href="Elaboration-and-Compilation/#--tech-term-pre-definition">pre-definition</a>.</p>
                <p>
                  Even though partial functions are not unfolded by the kernel, it is still possible to reason about other functions that call them so long as this reasoning doesn't depend on the implementation of the partial function itself.</p>
                <details class="example"><summary class="description">Partial Functions in Proofs</summary><div class="example-content">
                    <p>
                      The recursive function <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a></code> inefficiently computes the next prime number after a given number by repeatedly testing candidates with trial division.
Because there are infinitely many prime numbers, it always terminates; however, formulating this proof would be nontrivial.
It is thus marked <code class="plain-keyword">partial</code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15162">def</span> <span class="const token" data-binding="const-isPrime" data-verso-hover="1320" id="nextPrime">isPrime</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id___run"><span class="const token" data-binding="const-Id.run" data-verso-hover="1011">Id.run</span></a> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-15201">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-15206" data-verso-hover="1013">for</span> <span class="var token" data-binding="var-_uniq.182" data-verso-hover="7">i</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-15210">in</span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-15206" data-verso-hover="1013">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-15228">if</span> <span class="var token" data-binding="var-_uniq.182" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.182" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-15228">then</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-15246" data-verso-hover="231">return</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-15262">if</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">%</span> <span class="var token" data-binding="var-_uniq.182" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-15262">then</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-15280" data-verso-hover="231">return</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-15295" data-verso-hover="231">return</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.partial-15308">partial</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15316">def</span> <span class="const token" data-binding="const-nextPrime" data-verso-hover="1319" id="nextPrime">nextPrime</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.909" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-15351" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.970" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.909" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-15368" data-verso-hover="137">if</span></a> <a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-isPrime" data-verso-hover="1320">isPrime</span></a> <span class="var token" data-binding="var-_uniq.970" data-verso-hover="7">n</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-15368" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.970" data-verso-hover="7">n</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-15368" data-verso-hover="137">else</span></a> <a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a> <span class="var token" data-binding="var-_uniq.970" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                      It is nonetheless possible to prove that the following two functions are equal:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15499">def</span> <span class="const token" data-binding="const-answerUser" data-verso-hover="1321" id="answerUser">answerUser</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-termS!_-15538">s!</span><span class="unknown token" data-binding="">"The next prime is {</span><a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">}"</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15575">def</span> <span class="const token" data-binding="const-answerOtherUser" data-verso-hover="1322" id="answerUser">answerOtherUser</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.80" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="literal string token" data-binding="" data-verso-hover="1323">" "</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___intercalate"><span class="const token" data-binding="const-String.intercalate" data-verso-hover="1324">intercalate</span></a> <span class="unknown token" data-binding="">[</span>
    <span class="literal string token" data-binding="" data-verso-hover="1325">"The"</span><span class="unknown token" data-binding="">,</span>
    <span class="literal string token" data-binding="" data-verso-hover="1326">"next"</span><span class="unknown token" data-binding="">,</span>
    <span class="literal string token" data-binding="" data-verso-hover="1327">"prime"</span><span class="unknown token" data-binding="">,</span>
    <span class="literal string token" data-binding="" data-verso-hover="1328">"is"</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-ToString.toString" data-verso-hover="623">toString</span> <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a> <span class="var token" data-binding="var-_uniq.80" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The proof contains two <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="" data-verso-hover="36">simp</span></a></code> steps to demonstrate that the two functions are not syntactically identical.
In particular, the desugaring of string interpolation resulted in an extra <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString.toString" data-verso-hover="623">toString</span> <span class="literal string token" data-binding="" data-verso-hover="327">""</span></code> at the end of <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerUser" data-verso-hover="1321">answerUser</span></a></code>'s result.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-15979">theorem</span> <span class="const token" data-binding="const-answer_eq_other" data-verso-hover="1329" id="answer_eq_other">answer_eq_other</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerUser" data-verso-hover="1321">answerUser</span></a> <span class="unknown token" data-binding="">=</span> <a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerOtherUser" data-verso-hover="1322">answerOtherUser</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-7339054371843264470-16037-16039"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16037" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7339054371843264470-16037-16039"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerUser" data-verso-hover="1321">answerUser</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerOtherUser" data-verso-hover="1322">answerOtherUser</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-13589446267918520655-16042-16050"><a href="Tactic-Proofs/Tactic-Reference/#funext-next"><span class="keyword token" data-binding="kw-occ-tacticFunext___-16042" data-verso-hover="111">funext</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13589446267918520655-16042-16050"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-179" checked="checked"><span for="--verso-unique-179" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerUser" data-verso-hover="1321">answerUser</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerOtherUser" data-verso-hover="1322">answerOtherUser</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18422619542958225755-16053-16092"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-16053" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-16058">only</span> <span class="unknown token" data-binding="">[</span><a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerUser" data-verso-hover="1321">answerUser</span></a><span class="unknown token" data-binding="">,</span> <a href="Definitions/Recursive-Definitions/#answerUser"><span class="const token" data-binding="const-answerOtherUser" data-verso-hover="1322">answerOtherUser</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18422619542958225755-16053-16092"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-180" checked="checked"><span for="--verso-unique-180" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-ToString.toString" data-verso-hover="623">toString</span> <span class="literal string token" data-binding="" data-verso-hover="1330">"The next prime is "</span><a href="Type-Classes/Basic-Classes/#HAppend___mk"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="1331"> ++ </span></a><span class="const token" data-binding="const-ToString.toString" data-verso-hover="623">toString</span> (<a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span>)<a href="Type-Classes/Basic-Classes/#HAppend___mk"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="1331"> ++ </span></a><span class="const token" data-binding="const-ToString.toString" data-verso-hover="623">toString</span> <span class="literal string token" data-binding="" data-verso-hover="327">""</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a><span class="literal string token" data-binding="" data-verso-hover="1323">" "</span>.<a href="Basic-Types/Strings/#String___intercalate"><span class="const token" data-binding="const-String.intercalate" data-verso-hover="1324">intercalate</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">[</span></a><span class="literal string token" data-binding="" data-verso-hover="1325">"The"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a><span class="literal string token" data-binding="" data-verso-hover="1326">"next"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a><span class="literal string token" data-binding="" data-verso-hover="1327">"prime"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a><span class="literal string token" data-binding="" data-verso-hover="1328">"is"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a><span class="const token" data-binding="const-ToString.toString" data-verso-hover="623">toString</span> (<a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span>)<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">]</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-16583587626204225890-16095-16136"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-16095" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-16100">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-ToString.toString" data-verso-hover="623">toString</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-String.append_empty" data-verso-hover="1332">String.append_empty</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16583587626204225890-16095-16136"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-181" checked="checked"><span for="--verso-unique-181" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="literal string token" data-binding="" data-verso-hover="1330">"The next prime is "</span><a href="Type-Classes/Basic-Classes/#HAppend___mk"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="1331"> ++ </span></a>(<a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span>).<a href="Basic-Types/Natural-Numbers/#Nat___repr"><span class="const token" data-binding="const-Nat.repr" data-verso-hover="1333">repr</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="literal string token" data-binding="" data-verso-hover="1323">" "</span>.<a href="Basic-Types/Strings/#String___intercalate"><span class="const token" data-binding="const-String.intercalate" data-verso-hover="1324">intercalate</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">[</span></a><span class="literal string token" data-binding="" data-verso-hover="1325">"The"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a><span class="literal string token" data-binding="" data-verso-hover="1326">"next"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a><span class="literal string token" data-binding="" data-verso-hover="1327">"prime"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a><span class="literal string token" data-binding="" data-verso-hover="1328">"is"</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">, </span></a>(<a href="Definitions/Recursive-Definitions/#nextPrime"><span class="const token" data-binding="const-nextPrime" data-verso-hover="1319">nextPrime</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span>).<a href="Basic-Types/Natural-Numbers/#Nat___repr"><span class="const token" data-binding="const-Nat.repr" data-verso-hover="1333">repr</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405">]</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-16139-16142"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-16139" data-verso-hover="14">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-16139-16142"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="unsafe">
                  7.6.5.2.Â Unsafe Definitions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=unsafe" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  Unsafe definitions have even fewer safeguards than partial functions.
Their codomains do not need to be inhabited, they are not restricted to function definitions, and they have access to features of Lean that might violate internal invariants or break abstractions.
As a result, they cannot be used at all as part of mathematical reasoning.</p>
                <p>
                  While partial functions are treated as opaque constants by the type theory, unsafe definitions may only be referenced from other unsafe definitions.
As a consequence, any function that calls an unsafe function must be unsafe itself.
Theorems are not allowed to be declared unsafe.</p>
                <p>
                  In addition to unrestricted use of recursion, unsafe functions can cast from one type to another, check whether two values are the very same object in memory, retrieve pointer values, and run <code class="hl lean inline" data-lean-context="examples"><a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a></code> actions from otherwise-pure code.
Using these operators requires a thorough understanding of the Lean implementation.</p>
                <div class="namedocs" id="unsafeCast">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=unsafeCast" title="Permalink">ðŸ”—</a></span><span class="label">unsafe def</span><pre class="signature hl lean block"><div class="wide-only">unsafeCast.{u, v} {<span class="var token" data-binding="var-_uniq.2931" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>} {<span class="var token" data-binding="var-_uniq.2932" data-verso-hover="177">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>} (<span class="var token" data-binding="var-_uniq.2933" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2931" data-verso-hover="168">Î±</span>) : <span class="var token" data-binding="var-_uniq.2932" data-verso-hover="177">Î²</span></div><div class="narrow-only">unsafeCast.{u, v} {<span class="var token" data-binding="var-_uniq.2931" data-verso-hover="168">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>}
  {<span class="var token" data-binding="var-_uniq.2932" data-verso-hover="177">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>} (<span class="var token" data-binding="var-_uniq.2933" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2931" data-verso-hover="168">Î±</span>) : <span class="var token" data-binding="var-_uniq.2932" data-verso-hover="177">Î²</span></div></pre><div class="text">
                    <p>
                      This function will cast a value of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.39" data-verso-hover="168">Î±</span></code> to type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40" data-verso-hover="177">Î²</span></code>, and is a no-op in the
compiler. This function is <strong>extremely dangerous</strong> because there is no guarantee
that types <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.39" data-verso-hover="168">Î±</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40" data-verso-hover="177">Î²</span></code> have the same data representation, and this can lead to
memory unsafety. It is also logically unsound, since you could just cast
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>. For all those reasons this function is marked as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">unsafe</span></code>.</p>
                    <p>
                      It is implemented by lifting both <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.42" data-verso-hover="168">Î±</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.43" data-verso-hover="177">Î²</span></code> into a common universe, and then
using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">cast</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">lcProof</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ULift</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">PLift</span> <span class="unknown token" data-binding="">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">ULift</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">PLift</span> <span class="unknown token" data-binding="">Î²</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code> to actually perform
the cast. All these operations are no-ops in the compiler.</p>
                    <p>
                      Using this function correctly requires some knowledge of the data representation
of the source and target types. Some general classes of casts which are safe in
the current runtime:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <span class="var token" data-binding="var-_uniq.154" data-verso-hover="177">Î²</span></code> where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.154" data-verso-hover="177">Î²</span></code> have compatible representations,
or more generally for other inductive types.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Quotients/#Quot"><span class="const token" data-binding="const-Quot" data-verso-hover="152">Quot</span></a> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span> <span class="unknown token" data-binding="">r</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code>.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="469">Subtype</span></a> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span> <span class="var token" data-binding="var-_uniq.1545" data-verso-hover="471">p</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code>, or generally any structure containing only one
non-<code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code> field of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code>.</p>
                        </li>
                      <li>
                        <p>
                          Casting <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code> to/from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-NonScalar" data-verso-hover="1334">NonScalar</span></code> when <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code> is a boxed generic type
(i.e. a function that accepts an arbitrary type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="168">Î±</span></code> and is not specialized to
a scalar type like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Fixed-Precision-Integers/#UInt8___ofBitVec"><span class="const token" data-binding="const-UInt8" data-verso-hover="460">UInt8</span></a></code>).</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="ptrEq">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ptrEq" title="Permalink">ðŸ”—</a></span><span class="label">unsafe def</span><pre class="signature hl lean block"><div class="wide-only">ptrEq.{u_1} {<span class="var token" data-binding="var-_uniq.2940" data-verso-hover="44">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span>} (<span class="var token" data-binding="var-_uniq.2941" data-verso-hover="46">a </span><span class="var token" data-binding="var-_uniq.2942" data-verso-hover="46">b</span> : <span class="var token" data-binding="var-_uniq.2940" data-verso-hover="44">Î±</span>) : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only">ptrEq.{u_1} {<span class="var token" data-binding="var-_uniq.2940" data-verso-hover="44">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span>} (<span class="var token" data-binding="var-_uniq.2941" data-verso-hover="46">a </span><span class="var token" data-binding="var-_uniq.2942" data-verso-hover="46">b</span> : <span class="var token" data-binding="var-_uniq.2940" data-verso-hover="44">Î±</span>) :
  <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Compares two objects for pointer equality.</p>
                    <p>
                      Two objects are pointer-equal if, at runtime, they are allocated at exactly the same address. This
function is unsafe because it can distinguish between definitionally equal values.</p>
                    </div>
                  </div>
                <div class="namedocs" id="ptrEqList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ptrEqList" title="Permalink">ðŸ”—</a></span><span class="label">unsafe def</span><pre class="signature hl lean block"><div class="wide-only">ptrEqList.{u_1} {<span class="var token" data-binding="var-_uniq.2949" data-verso-hover="44">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span>} (<span class="var token" data-binding="var-_uniq.2950" data-verso-hover="51">as </span><span class="var token" data-binding="var-_uniq.2951" data-verso-hover="51">bs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2949" data-verso-hover="44">Î±</span>) : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only">ptrEqList.{u_1} {<span class="var token" data-binding="var-_uniq.2949" data-verso-hover="44">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span>}
  (<span class="var token" data-binding="var-_uniq.2950" data-verso-hover="51">as </span><span class="var token" data-binding="var-_uniq.2951" data-verso-hover="51">bs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2949" data-verso-hover="44">Î±</span>) : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Compares two lists of objects for element-wise pointer equality. Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code> if both lists are
the same length and the objects at the corresponding indices of each list are pointer-equal.</p>
                    <p>
                      Two objects are pointer-equal if, at runtime, they are allocated at exactly the same address. This
function is unsafe because it can distinguish between definitionally equal values.</p>
                    </div>
                  </div>
                <div class="namedocs" id="ptrAddrUnsafe">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ptrAddrUnsafe" title="Permalink">ðŸ”—</a></span><span class="label">unsafe opaque</span><pre class="signature hl lean block"><div class="wide-only">ptrAddrUnsafe.{u} {<span class="var token" data-binding="var-_uniq.2956" data-verso-hover="55">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>} (<span class="var token" data-binding="var-_uniq.2957" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2956" data-verso-hover="55">Î±</span>) : <a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec"><span class="const token" data-binding="const-USize" data-verso-hover="464">USize</span></a></div><div class="narrow-only">ptrAddrUnsafe.{u} {<span class="var token" data-binding="var-_uniq.2956" data-verso-hover="55">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>} (<span class="var token" data-binding="var-_uniq.2957" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2956" data-verso-hover="55">Î±</span>) :
  <a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec"><span class="const token" data-binding="const-USize" data-verso-hover="464">USize</span></a></div></pre><div class="text">
                    <p>
                      Returns the address at which an object is allocated.</p>
                    <p>
                      This function is unsafe because it can distinguish between definitionally equal values.</p>
                    </div>
                  </div>
                <div class="namedocs" id="isExclusiveUnsafe">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=isExclusiveUnsafe" title="Permalink">ðŸ”—</a></span><span class="label">unsafe opaque</span><pre class="signature hl lean block"><div class="wide-only">isExclusiveUnsafe.{u} {<span class="var token" data-binding="var-_uniq.2962" data-verso-hover="55">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>} (<span class="var token" data-binding="var-_uniq.2963" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2962" data-verso-hover="55">Î±</span>) : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only">isExclusiveUnsafe.{u} {<span class="var token" data-binding="var-_uniq.2962" data-verso-hover="55">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>}
  (<span class="var token" data-binding="var-_uniq.2963" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2962" data-verso-hover="55">Î±</span>) : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2959" data-verso-hover="46">a</span></code> is an exclusive object.</p>
                    <p>
                      An object is exclusive if it is single-threaded and its reference counter is 1. This function is
unsafe because it can distinguish between definitionally equal values.</p>
                    </div>
                  </div>
                <div class="namedocs" id="unsafeIO">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=unsafeIO" title="Permalink">ðŸ”—</a></span><span class="label">unsafe def</span><pre class="signature hl lean block"><div class="wide-only">unsafeIO {<span class="var token" data-binding="var-_uniq.2981" data-verso-hover="162">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type</span>} (<span class="var token" data-binding="var-_uniq.2982" data-verso-hover="1335">fn</span> : <a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <span class="var token" data-binding="var-_uniq.2981" data-verso-hover="162">Î±</span>) : <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except" data-verso-hover="1336">Except</span></a> <a href="IO/Logical-Model/#IO___Error___alreadyExists"><span class="const token" data-binding="const-IO.Error" data-verso-hover="1337">IO.Error</span></a> <span class="var token" data-binding="var-_uniq.2981" data-verso-hover="162">Î±</span></div><div class="narrow-only">unsafeIO {<span class="var token" data-binding="var-_uniq.2981" data-verso-hover="162">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type</span>} (<span class="var token" data-binding="var-_uniq.2982" data-verso-hover="1335">fn</span> : <a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <span class="var token" data-binding="var-_uniq.2981" data-verso-hover="162">Î±</span>) :
  <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except" data-verso-hover="1336">Except</span></a> <a href="IO/Logical-Model/#IO___Error___alreadyExists"><span class="const token" data-binding="const-IO.Error" data-verso-hover="1337">IO.Error</span></a> <span class="var token" data-binding="var-_uniq.2981" data-verso-hover="162">Î±</span></div></pre><div class="text">
                    <p>
                      A monad that can have side effects on the external world or throw exceptions of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Îµ</span></code>.</p>
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Logical-Model/#BaseIO"><span class="const token" data-binding="const-BaseIO" data-verso-hover="1338">BaseIO</span></a></code> is a version of this monad that cannot throw exceptions. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a></code> sets the exception type to
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Logical-Model/#IO___Error___alreadyExists"><span class="const token" data-binding="const-IO.Error" data-verso-hover="1337">IO.Error</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="unsafeEIO">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=unsafeEIO" title="Permalink">ðŸ”—</a></span><span class="label">unsafe def</span><pre class="signature hl lean block"><div class="wide-only">unsafeEIO {<span class="var token" data-binding="var-_uniq.2995" data-verso-hover="162">Îµ </span><span class="var token" data-binding="var-_uniq.2996" data-verso-hover="162">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type</span>} (<span class="var token" data-binding="var-_uniq.2997" data-verso-hover="1339">fn</span> : <a href="IO/Logical-Model/#EIO"><span class="const token" data-binding="const-EIO" data-verso-hover="1340">EIO</span></a> <span class="var token" data-binding="var-_uniq.2995" data-verso-hover="162">Îµ</span> <span class="var token" data-binding="var-_uniq.2996" data-verso-hover="162">Î±</span>) : <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except" data-verso-hover="1336">Except</span></a> <span class="var token" data-binding="var-_uniq.2995" data-verso-hover="162">Îµ</span> <span class="var token" data-binding="var-_uniq.2996" data-verso-hover="162">Î±</span></div><div class="narrow-only">unsafeEIO {<span class="var token" data-binding="var-_uniq.2995" data-verso-hover="162">Îµ </span><span class="var token" data-binding="var-_uniq.2996" data-verso-hover="162">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type</span>} (<span class="var token" data-binding="var-_uniq.2997" data-verso-hover="1339">fn</span> : <a href="IO/Logical-Model/#EIO"><span class="const token" data-binding="const-EIO" data-verso-hover="1340">EIO</span></a> <span class="var token" data-binding="var-_uniq.2995" data-verso-hover="162">Îµ</span> <span class="var token" data-binding="var-_uniq.2996" data-verso-hover="162">Î±</span>) :
  <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except" data-verso-hover="1336">Except</span></a> <span class="var token" data-binding="var-_uniq.2995" data-verso-hover="162">Îµ</span> <span class="var token" data-binding="var-_uniq.2996" data-verso-hover="162">Î±</span></div></pre><div class="text">
                    <p>
                      Executes arbitrary side effects in a pure context, with exceptions indicated via <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except" data-verso-hover="1336">Except</span></a></code>. This a
<strong>dangerous</strong> operation that can easily undermine important assumptions about the meaning of Lean
programs, and it should only be used with great care and a thorough understanding of compiler
internals, and even then only to implement observationally pure operations.</p>
                    <p>
                      This function is not a good way to convert an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Logical-Model/#EIO"><span class="const token" data-binding="const-EIO" data-verso-hover="1340">EIO</span></a> <span class="var token" data-binding="var-_uniq.2989" data-verso-hover="162">Î±</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <span class="var token" data-binding="var-_uniq.2989" data-verso-hover="162">Î±</span></code> into an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2989" data-verso-hover="162">Î±</span></code>. Instead, use
<a href="https://lean-lang.org/doc/reference/4.20.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation"><code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code>-notation</a>.</p>
                    <p>
                      Because the resulting value is treated as a side-effect-free term, the compiler may re-order,
duplicate, or delete calls to this function. The side effect may even be hoisted into a constant,
causing the side effect to occur at initialization time, even if it would otherwise never be called.</p>
                    </div>
                  </div>
                <div class="namedocs" id="unsafeBaseIO">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=unsafeBaseIO" title="Permalink">ðŸ”—</a></span><span class="label">unsafe def</span><pre class="signature hl lean block"><div class="wide-only">unsafeBaseIO {<span class="var token" data-binding="var-_uniq.3004" data-verso-hover="162">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type</span>} (<span class="var token" data-binding="var-_uniq.3005" data-verso-hover="1341">fn</span> : <a href="IO/Logical-Model/#BaseIO"><span class="const token" data-binding="const-BaseIO" data-verso-hover="1338">BaseIO</span></a> <span class="var token" data-binding="var-_uniq.3004" data-verso-hover="162">Î±</span>) : <span class="var token" data-binding="var-_uniq.3004" data-verso-hover="162">Î±</span></div><div class="narrow-only">unsafeBaseIO {<span class="var token" data-binding="var-_uniq.3004" data-verso-hover="162">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type</span>} (<span class="var token" data-binding="var-_uniq.3005" data-verso-hover="1341">fn</span> : <a href="IO/Logical-Model/#BaseIO"><span class="const token" data-binding="const-BaseIO" data-verso-hover="1338">BaseIO</span></a> <span class="var token" data-binding="var-_uniq.3004" data-verso-hover="162">Î±</span>) :
  <span class="var token" data-binding="var-_uniq.3004" data-verso-hover="162">Î±</span></div></pre><div class="text">
                    <p>
                      Executes arbitrary side effects in a pure context. This a <strong>dangerous</strong> operation that can easily
undermine important assumptions about the meaning of Lean programs, and it should only be used with
great care and a thorough understanding of compiler internals, and even then only to implement
observationally pure operations.</p>
                    <p>
                      This function is not a good way to convert a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Logical-Model/#BaseIO"><span class="const token" data-binding="const-BaseIO" data-verso-hover="1338">BaseIO</span></a> <span class="var token" data-binding="var-_uniq.3000" data-verso-hover="162">Î±</span></code> into an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3000" data-verso-hover="162">Î±</span></code>. Instead, use
<a href="https://lean-lang.org/doc/reference/4.20.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation"><code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code>-notation</a>.</p>
                    <p>
                      Because the resulting value is treated as a side-effect-free term, the compiler may re-order,
duplicate, or delete calls to this function. The side effect may even be hoisted into a constant,
causing the side effect to occur at initialization time, even if it would otherwise never be called.</p>
                    </div>
                  </div>
                <p>
                  Frequently, unsafe operators are used to write fast code that takes advantage of low-level details.
Just as Lean code may be replaced at runtime with C code via the FFI, safe Lean code may be replaced with unsafe Lean code for runtime programs.
This is accomplished by adding the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="876">implemented_by</span></code> attribute to the function that is to be replaced, which is often an <code class="plain-keyword">opaque</code> definition.
While this does not threaten Lean's soundness as a logic because the constant to be replaced has already been checked by the kernel and the unsafe replacement is only used in run-time code, it is still risky.
Both C code and unsafe code may execute arbitrary side effects.</p>
                <div class="namedocs" id="attr-next">
                  <span class="label">attribute</span><span class="title">Replacing Run-Time Implementations</span><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="876">implemented_by</span></code> attribute instructs the compiler to replace one constant with another in compiled code.
The replacement constant may be unsafe.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">implemented_by</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Checking Equality with Pointers</summary><div class="example-content">
                    <p>
                      Ordinarily, a <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1342">BEq</span></a></code> instance's equality predicate must fully traverse both of its arguments to determine whether they are equal.
If they are, in fact, the very same object in memory, this is wasteful indeed.
A pointer equality test can be used prior to the traversal to catch this case.</p>
                    <p>
                      The type being compared is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree" data-verso-hover="1343">Tree</span></code>, a type of binary trees.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-18773" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1343">Tree</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="127">Î±</span> <span class="keyword token" data-binding="kw-occ-null-18791">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.empty" data-verso-hover="1344" id="Tree___empty">empty</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.branch" data-verso-hover="1345">branch</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="951">left</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1343">Tree</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="127">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="46">val</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="127">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">right</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1343">Tree</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="127">Î±</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      An unsafe function may use pointer equality to terminate the structural equality test more quickly, falling back to structural checks when pointer equality fails.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.unsafe-19040">unsafe</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-19047">def</span> <span class="const token" data-binding="const-Tree.fastBEq" data-verso-hover="1346" id="Tree___fastBEq">Tree.fastBEq</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1342">BEq</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="951">t1</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">t2</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1343">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19103" data-verso-hover="137">if</span></a> <a href="Definitions/Recursive-Definitions/#ptrEq"><span class="const token" data-binding="const-ptrEq" data-verso-hover="1347">ptrEq</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="951">t1</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">t2</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19103" data-verso-hover="137">then</span></a>
    <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19103" data-verso-hover="137">else</span></a>
    <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-19143" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="951">t1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">t2</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-19143" data-verso-hover="52">with</span></a>
    <span class="unknown token" data-binding="">|</span> <a href="Definitions/Recursive-Definitions/#Tree___empty"><span class="const token" data-binding="const-Tree.empty" data-verso-hover="1344">.empty</span></a><span class="unknown token" data-binding="">,</span> <a href="Definitions/Recursive-Definitions/#Tree___empty"><span class="const token" data-binding="const-Tree.empty" data-verso-hover="1344">.empty</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.branch" data-verso-hover="1345">.branch</span> <span class="var token" data-binding="var-_uniq.162" data-verso-hover="951">l1</span> <span class="var token" data-binding="var-_uniq.163" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.164" data-verso-hover="951">r1</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Tree.branch" data-verso-hover="1345">.branch</span> <span class="var token" data-binding="var-_uniq.165" data-verso-hover="951">l2</span> <span class="var token" data-binding="var-_uniq.166" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.167" data-verso-hover="951">r2</span> <span class="unknown token" data-binding="">=&gt;</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19238" data-verso-hover="137">if</span></a> <a href="Definitions/Recursive-Definitions/#ptrEq"><span class="const token" data-binding="const-ptrEq" data-verso-hover="1347">ptrEq</span></a> <span class="var token" data-binding="var-_uniq.163" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.166" data-verso-hover="46">y</span> <span class="unknown token" data-binding="">||</span> <span class="var token" data-binding="var-_uniq.163" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">==</span> <span class="var token" data-binding="var-_uniq.166" data-verso-hover="46">y</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19238" data-verso-hover="137">then</span></a>
        <span class="var token" data-binding="var-_uniq.162" data-verso-hover="951">l1</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___fastBEq"><span class="const token" data-binding="const-Tree.fastBEq" data-verso-hover="1346">fastBEq</span></a> <span class="var token" data-binding="var-_uniq.165" data-verso-hover="951">l2</span> <span class="unknown token" data-binding="">&&</span> <span class="var token" data-binding="var-_uniq.164" data-verso-hover="951">r1</span><span class="unknown token" data-binding="">.</span><a href="Definitions/Recursive-Definitions/#Tree___fastBEq"><span class="const token" data-binding="const-Tree.fastBEq" data-verso-hover="1346">fastBEq</span></a> <span class="var token" data-binding="var-_uniq.167" data-verso-hover="951">r2</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19238" data-verso-hover="137">else</span></a> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      An <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="876">implemented_by</span></code> attribute on an opaque definition bridges the worlds of safe and unsafe code.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">implemented_by</span> <a href="Definitions/Recursive-Definitions/#Tree___fastBEq"><span class="const token" data-binding="const-Tree.fastBEq" data-verso-hover="1346">Tree.fastBEq</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.opaque-19490">opaque</span> <span class="const token" data-binding="const-Tree.beq" data-verso-hover="1348" id="Tree___beq">Tree.beq</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1342">BEq</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="951">t1</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="951">t2</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1343">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-19541">instance</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1342">BEq</span></a> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1342">BEq</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Tree" data-verso-hover="1343">Tree</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-19575">where</span>
  <a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1349">beq</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#Tree___beq"><span class="const token" data-binding="const-Tree.beq" data-verso-hover="1348">Tree.beq</span></a>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Taking Advantage of Run-Time Representations</summary><div class="example-content">
                    <p>
                      Because a <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a></code> is represented identically to its underlying <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">List.map</span></a> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.val" data-verso-hover="854">Fin.val</span></a></code> can be replaced by <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#unsafeCast"><span class="const token" data-binding="const-unsafeCast" data-verso-hover="880">unsafeCast</span></a></code> to avoid a linear-time traversal that, in practice, does nothing:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.unsafe-19885">unsafe</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-19892">def</span> <span class="const token" data-binding="const-unFinImpl" data-verso-hover="1350" id="unFin">unFinImpl</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Definitions/Recursive-Definitions/#unsafeCast"><span class="const token" data-binding="const-unsafeCast" data-verso-hover="880">unsafeCast</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span>

<span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">implemented_by</span> <a href="Definitions/Recursive-Definitions/#unFin"><span class="const token" data-binding="const-unFinImpl" data-verso-hover="1350">unFinImpl</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-19985">def</span> <span class="const token" data-binding="const-unFin" data-verso-hover="1352" id="unFin">unFin</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="1351">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="var token" data-binding="var-_uniq.29" data-verso-hover="1351">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">map</span></a> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.val" data-verso-hover="854">Fin.val</span></a>
<span class="unknown token" data-binding=""></span></code><div class="paragraph">
                      <p>
                        From the perspective of the Lean kernel, <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#unFin"><span class="const token" data-binding="const-unFin" data-verso-hover="1352">unFin</span></a></code> is defined using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="199">List.map</span></a></code>:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-20162">theorem</span> <span class="const token" data-binding="const-unFin_length_eq_length" data-verso-hover="1353" id="unFin_length_eq_length">unFin_length_eq_length</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><a href="Definitions/Recursive-Definitions/#unFin"><span class="const token" data-binding="const-unFin" data-verso-hover="1352">unFin</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1354">length</span></a> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1354">length</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-1194760214075920063-20252-20254"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-20252" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1194760214075920063-20252-20254"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> (<a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span>)</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">(<a href="Definitions/Recursive-Definitions/#unFin"><span class="const token" data-binding="const-unFin" data-verso-hover="1352">unFin</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span>).<a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1354">length</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1351">xs</span>.<a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1354">length</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-20257-20269"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-20257" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="Definitions/Recursive-Definitions/#unFin"><span class="const token" data-binding="const-unFin" data-verso-hover="1352">unFin</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-20257-20269"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                        In compiled code, there is no traversal of the list.</p>
                      </div>
                    <p>
                      This kind of replacement is risky: the correspondence between the proof and the compiled code depends fully on the equivalence of the two implementations, which cannot be proved in Lean.
The correspondence relies on details of Lean's implementation.
These â€œescape hatchesâ€ should be used very carefully.</p>
                    </div>
                  </details></section>
              </section>
            <section>
              <h2 id="reducibility">
                7.6.6.Â Controlling Reduction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=reducibility" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                While checking proofs and programs, Lean takes <span id="--tech-term-reducibility" class="def-technical-term"><em>reducibility</em></span>, also known as <em>transparency</em>, into account.
A definition's reducibility controls the contexts in which it is unfolded during elaboration and proof execution.</p>
              <p>
                There are three levels of reducibility:</p>
              <dl><dt> <span id="--tech-term-Reducible" class="def-technical-term">Reducible</span></dt><dd><p>
                    Reducible definitions are unfolded essentially everywhere, on demand.
  Type class instance synthesis, definitional equality checks, and the rest of the language treat the definition as being essentially an abbreviation.
  This is the setting applied by the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">abbrev</code></span> command.</p>
                  </dd><dt> <span id="--tech-term-Semireducible" class="def-technical-term">Semireducible</span></dt><dd><p>
                    Semireducible definitions are not unfolded by potentially expensive automation such as type class instance synthesis or <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="" data-verso-hover="36">simp</span></a></code>, but they are unfolded while checking definitional equality and while resolving <a class="technical-term" href="Terms/Function-Application/#--tech-term-generalized-field-notation">generalized field notation</a>.
  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">def</code></span> command generally creates semireducible definitions unless a different reducibility level is specified with an attribute; however, definitions that use <a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion-next">well-founded recursion</a> are irreducible by default.</p>
                  </dd><dt> <span id="--tech-term-Irreducible" class="def-technical-term">Irreducible</span></dt><dd><p>
                    Irreducible definitions are not unfolded at all during elaboration.
  Definitions can be made irreducible by applying the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1355">irreducible</span></code> attribute.</p>
                  </dd></dl><details class="example"><summary class="description">Reducibility and Instance Synthesis</summary><div class="example-content">
                  <p>
                    These three aliasees for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></code> are respectively reducible, semireducible, and irreducible.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.abbrev-22226">abbrev</span> <span class="const token" data-binding="const-Phrase" data-verso-hover="1356" id="Clause">Phrase</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22251">def</span> <span class="const token" data-binding="const-Clause" data-verso-hover="1357" id="Clause">Clause</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>

<span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22288">def</span> <span class="const token" data-binding="const-Utterance" data-verso-hover="1358" id="Clause">Utterance</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    The reducible and semireducible aliases are unfolded during the elaborator's definitional equality check, causing them to be considered equivalent to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22491">def</span> <span class="const token" data-binding="const-hello" data-verso-hover="1359">hello</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Phrase" data-verso-hover="1356">Phrase</span></a> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="148">"Hello"</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22522">def</span> <span class="const token" data-binding="const-goodMorning" data-verso-hover="1360" id="hello-next">goodMorning</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Clause" data-verso-hover="1357">Clause</span></a> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="1361">"Good morning"</span>
<span class="unknown token" data-binding=""></span></code><p>
                    The irreducible alias, on the other hand, is rejected as the type for a string, because the elaborator's definitional equality test does not unfold it:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22761">def</span> <span class="const token" data-binding="const-goodEvening" data-verso-hover="1362" id="goodEvening">goodEvening</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Utterance" data-verso-hover="1358">Utterance</span></a> <span class="unknown token" data-binding="">:=</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type mismatch
  "Good evening"
has type
  String : Type
but is expected to have type
  Utterance : Type</code></span></span><span class="literal string token" data-binding="" data-verso-hover="1363">"Good evening"</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>type mismatch
  "Good evening"
has type
  String : Type
but is expected to have type
  Utterance : Type
</pre></div>
                  <p>
                    Because <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Phrase" data-verso-hover="1356">Phrase</span></a></code> is reducible, the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></code> instance can be used as a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Phrase" data-verso-hover="1356">Phrase</span></a></code> instance:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">instToStringString</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___synth"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.synth-23073">#synth</span></a></span> <span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Phrase" data-verso-hover="1356">Phrase</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    However, <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Clause" data-verso-hover="1357">Clause</span></a></code> is semireducible, so the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></code> instance cannot be used:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to synthesize
  ToString Clause

Additional diagnostic information may be available using the `set_option diagnostics true` command.</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___synth"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.synth-23248">#synth</span></a></span> <span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Clause" data-verso-hover="1357">Clause</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>failed to synthesize
  ToString Clause

Additional diagnostic information may be available using the `set_option diagnostics true` command.
</pre></div>
                  <p>
                    The instance can be explicitly enabled by creating a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Clause" data-verso-hover="1357">Clause</span></a></code> instance that reduces to the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></code> instance.
This example works because semireducible definitions are unfolded while checking definitional equality:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-23701">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Definitions/Recursive-Definitions/#Clause"><span class="const token" data-binding="const-Clause" data-verso-hover="1357">Clause</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Type-Classes/Instance-Synthesis/#inferInstanceAs"><span class="const token" data-binding="const-inferInstanceAs" data-verso-hover="1126">inferInstanceAs</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></div>
                </details><details class="example"><summary class="description">Reducibility and Generalized Field Notation</summary><div class="example-content">
                  <p>
                    <a class="technical-term" href="Terms/Function-Application/#--tech-term-generalized-field-notation">Generalized field notation</a> unfolds reducible and semireducible declarations while searching for matching names.
Given the semireducible alias <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence" data-verso-hover="1364">Sequence</span></a></code> for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24025">def</span> <span class="const token" data-binding="const-Sequence" data-verso-hover="1364" id="Sequence___ofList">Sequence</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24047">def</span> <span class="const token" data-binding="const-Sequence.ofList" data-verso-hover="1365" id="Sequence___ofList">Sequence.ofList</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="44">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence" data-verso-hover="1364">Sequence</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="44">Î±</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">xs</span>
<span class="unknown token" data-binding=""></span></code><p>
                    generalized field notation allows <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___reverse"><span class="const token" data-binding="const-List.reverse" data-verso-hover="182">List.reverse</span></a></code> to be accessed from a term of type <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence" data-verso-hover="1364">Sequence</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">let xs := Sequence.ofList [1, 2, 3];
List.reverse xs : List Nat</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-24226">#check</span></a></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-24233" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="1366">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence" data-verso-hover="1364">Sequence</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence.ofList" data-verso-hover="1365">.ofList</span></a> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">;</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="1366">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___reverse"><span class="const token" data-binding="const-List.reverse" data-verso-hover="182">reverse</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    However, declaring <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence" data-verso-hover="1364">Sequence</span></a></code> to be irreducible prevents the unfolding:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Attributes/#Lean___Parser___Command___attribute"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.attribute-24412">attribute</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span> <a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence" data-verso-hover="1364">Sequence</span></a>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">let xs := Sequence.ofList [1, 2, 3];
sorry : ?m.42</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-24446">#check</span></a></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-24453" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="1366">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence" data-verso-hover="1364">Sequence</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Definitions/Recursive-Definitions/#Sequence___ofList"><span class="const token" data-binding="const-Sequence.ofList" data-verso-hover="1365">.ofList</span></a> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">;</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid field 'reverse', the environment does not contain 'Sequence.reverse'
  xs
has type
  Sequence Nat</code></span></span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="1366">xs</span></span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">reverse</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>invalid field 'reverse', the environment does not contain 'Sequence.reverse'
  xs
has type
  Sequence Nat
</pre></div>
                  </div>
                </details><div class="namedocs" id="attr-next-next">
                <span class="label">attribute</span><span class="title">Reducibility Annotations</span><div class="text">
                  <p>
                    A definition's reducibility can be set using one of the three reducibility attributes:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">reducible</span><span class="from-nonterminal" data-kind="null"></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">semireducible</span><span class="from-nonterminal" data-kind="null"></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">irreducible</span><span class="from-nonterminal" data-kind="null"></span></pre><p>
                    These attributes can only be applied globally in the same file as the definition being modified, but they may be <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.attrKind</code></code><code class="kw">local</code></span>ly applied anywhere.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Reducibility-and-Tactics">
                  7.6.6.1.Â Reducibility and Tactics</h3>
                <p>
                  The tactics <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1112">with_reducible</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1367">with_reducible_and_instances</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1368">with_unfolding_all</span></code> control which definitions are unfolded by most tactics.</p>
                <details class="example"><summary class="description">Reducibility and Tactics</summary><div class="example-content">
                    <p>
                      The functions <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plus" data-verso-hover="1369">plus</span></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-sum" data-verso-hover="1370">sum</span></a></code>, and <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a></code> are all synonyms for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1372">Nat.add</span></a></code> that are respectively reducible, semireducible, and irreducible:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.abbrev-25476">abbrev</span> <span class="const token" data-binding="const-plus" data-verso-hover="1369">plus</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1372">Nat.add</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25500">def</span> <span class="const token" data-binding="const-sum" data-verso-hover="1370" id="tally">sum</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1372">Nat.add</span></a>

<span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25535">def</span> <span class="const token" data-binding="const-tally" data-verso-hover="1371" id="tally">tally</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1372">Nat.add</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      The reducible synonym is unfolded by <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="" data-verso-hover="36">simp</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-25622">theorem</span> <span class="const token" data-binding="const-plus_eq_add" data-verso-hover="1373" id="plus_eq_add">plus_eq_add</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-plus" data-verso-hover="1369">plus</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12568511986380980595-25664-25666"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-25664" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12568511986380980595-25664-25666"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-plus" data-verso-hover="1369">plus</span> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-25667-25671"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-25667" data-verso-hover="36">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-25667-25671"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      The semireducible synonym is not, however, unfolded by <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="" data-verso-hover="36">simp</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-25807">theorem</span> <span class="const token" data-binding="const-sum_eq_add" data-verso-hover="1374">sum_eq_add</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-sum" data-verso-hover="1370">sum</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-15608356999946813020-25847-25849"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-25847" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15608356999946813020-25847-25849"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-sum" data-verso-hover="1370">sum</span></a> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-15608356999946813020-25850-25854"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">simp made no progress</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-25850" data-verso-hover="36">simp</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15608356999946813020-25850-25854"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-sum" data-verso-hover="1370">sum</span></a> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      Nonetheless, the definitional equality check induced by <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="" data-verso-hover="14">rfl</span></a></code> unfolds the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-sum" data-verso-hover="1370">sum</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-25962">theorem</span> <span class="const token" data-binding="const-sum_eq_add" data-verso-hover="1374">sum_eq_add</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-sum" data-verso-hover="1370">sum</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-15608356999946813020-26002-26004"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-26002" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15608356999946813020-26002-26004"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-sum" data-verso-hover="1370">sum</span></a> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-26005-26008"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-26005" data-verso-hover="14">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-26005-26008"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      The irreducible <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a></code>, however, is not reduced by definitional equality.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-26152">theorem</span> <span class="const token" data-binding="const-tally_eq_add" data-verso-hover="1375">tally_eq_add</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5700573180375587135-26196-26198"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-26196" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5700573180375587135-26196-26198"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-5700573180375587135-26199-26202"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">tactic 'rfl' failed, the left-hand side
  tally x y
is not definitionally equal to the right-hand side
  x + y
x y : Nat
âŠ¢ tally x y = x + y</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-26199" data-verso-hover="14">rfl</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5700573180375587135-26199-26202"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      The <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="" data-verso-hover="36">simp</span></a></code> tactic can unfold any definition, even irreducible ones, when they are explicitly provided:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-26362">theorem</span> <span class="const token" data-binding="const-tally_eq_add" data-verso-hover="1375">tally_eq_add</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5700573180375587135-26406-26408"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-26406" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5700573180375587135-26406-26408"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-26409-26421"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-26409" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-26409-26421"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      Similarly, part of a proof can be instructed to ignore irreducibility by placing it in a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1368">with_unfolding_all</span></code> block:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-26559">theorem</span> <span class="const token" data-binding="const-tally_eq_add" data-verso-hover="1375">tally_eq_add</span> <span class="unknown token" data-binding="">:</span> <a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">y</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5700573180375587135-26603-26605"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-26603" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5700573180375587135-26603-26605"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Definitions/Recursive-Definitions/#tally"><span class="const token" data-binding="const-tally" data-verso-hover="1371">tally</span></a> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.55" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.56" data-verso-hover="7">y</span></span></span></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.withUnfoldingAll-26606" data-verso-hover="1368">with_unfolding_all</span> <span class="tactic"><label for="tactic-state-7-26625-26628"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-26625" data-verso-hover="14">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-26625-26628"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Modifying-Reducibility">
                  7.6.6.2.Â Modifying Reducibility</h3>
                <p>
                  The reducibility of a definition can be globally modified in the module in which it is defined by applying the appropriate attribute with the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.attribute : command</code></code><a href="Attributes/#Lean___Parser___Command___attribute"><code class="kw">attribute</code></a></span> command.
In other modules, the reducibility of imported definitions can be modified by applying the attribute with the <code class="plain-keyword">local</code> modifier.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.commandSeal__ : command</code><span class="sep"></span><code class="docstring">The `seal foo` command ensures that the definition of `foo` is sealed, meaning it is marked as `[irreducible]`.
This command is particularly useful in contexts where you want to prevent the reduction of `foo` in proofs.

In terms of functionality, `seal foo` is equivalent to `attribute [local irreducible] foo`.
This attribute specifies that `foo` should be treated as irreducible only within the local scope,
which helps in maintaining the desired abstraction level without affecting global settings.
</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___commandSeal__"><code class="kw">seal</code></a></span> and  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.commandUnseal__ : command</code><span class="sep"></span><code class="docstring">The `unseal foo` command ensures that the definition of `foo` is unsealed, meaning it is marked as `[semireducible]`, the
default reducibility setting. This command is useful when you need to allow some level of reduction of `foo` in proofs.

Functionally, `unseal foo` is equivalent to `attribute [local semireducible] foo`.
Applying this attribute makes `foo` semireducible only within the local scope.
</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___commandUnseal__"><code class="kw">unseal</code></a></span> commands are a shorthand for this process.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Local Irreducibility</span><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">seal</span> <span class="unknown token" data-binding="">foo</span></code> command ensures that the definition of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> is sealed, meaning it is marked as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span></code>.
This command is particularly useful in contexts where you want to prevent the reduction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> in proofs.</p>
                    <p>
                      In terms of functionality, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">seal</span> <span class="unknown token" data-binding="">foo</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">attribute</span> <span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-null-0">local</span> <span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">foo</span></code>.
This attribute specifies that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> should be treated as irreducible only within the local scope,
which helps in maintaining the desired abstraction level without affecting global settings.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___commandSeal__"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.commandSeal__"><code class="hover-info"><code class="docstring">The `seal foo` command ensures that the definition of `foo` is sealed, meaning it is marked as `[irreducible]`.
This command is particularly useful in contexts where you want to prevent the reduction of `foo` in proofs.

In terms of functionality, `seal foo` is equivalent to `attribute [local irreducible] foo`.
This attribute specifies that `foo` should be treated as irreducible only within the local scope,
which helps in maintaining the desired abstraction level without affecting global settings.
</code></code><span class="keyword">seal</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Local Reducibility</span><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">unseal</span> <span class="unknown token" data-binding="">foo</span></code> command ensures that the definition of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> is unsealed, meaning it is marked as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">semireducible</span><span class="unknown token" data-binding="">]</span></code>, the
default reducibility setting. This command is useful when you need to allow some level of reduction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> in proofs.</p>
                    <p>
                      Functionally, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">unseal</span> <span class="unknown token" data-binding="">foo</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">attribute</span> <span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-null-0">local</span> <span class="unknown token" data-binding="">semireducible</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">foo</span></code>.
Applying this attribute makes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> semireducible only within the local scope.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___commandUnseal__"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.commandUnseal__"><code class="hover-info"><code class="docstring">The `unseal foo` command ensures that the definition of `foo` is unsealed, meaning it is marked as `[semireducible]`, the
default reducibility setting. This command is useful when you need to allow some level of reduction of `foo` in proofs.

Functionally, `unseal foo` is equivalent to `attribute [local semireducible] foo`.
Applying this attribute makes `foo` semireducible only within the local scope.
</code></code><span class="keyword">unseal</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Options">
                  7.6.6.3.Â Options</h3>
                <p>
                  For performance, the elaborator and many tactics construct indices and caches.
Many of these take reducibility into account, and there's no way to invalidate and regenerate them if reducibility changes globally.
Unsafe changes to reducibility settings that could have unpredictable results are disallowed by default, but they can be enabled by using the <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#allowUnsafeReducibility"><span class="option token" data-binding="option-allowUnsafeReducibility" data-verso-hover="1376">allowUnsafeReducibility</span></a></code> option.</p>
                <div class="namedocs" id="allowUnsafeReducibility">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&name=allowUnsafeReducibility" title="Permalink">ðŸ”—</a></span><span class="label">option</span><pre class="signature hl lean block">allowUnsafeReducibility</pre><div class="text">
                    <p>
                      Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code></p>
                    <p>
                      enables users to modify the reducibility settings for declarations even when such changes are deemed potentially hazardous. For example, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code> and type class resolution maintain term indices where reducible declarations are expanded.</p>
                    </div>
                  </div>
                </section>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Definitions/Example-Declarations/#The-Lean-Language-Reference--Definitions--Example-Declarations" rel="prev" title="7.5. Example Declarations"><span class="arrow">â†</span><span class="where">7.5. Example Declarations</span></a><a class="local-button active" href="Axioms/#axioms" rel="next" title="8. Axioms"><span class="where">8. Axioms</span><span class="arrow">â†’</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

