<!DOCTYPE html>
<html>
  <head>
<meta name="robots" content="noindex">
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Defining New Syntax</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: 0.75rem;
  margin-top: 0.75rem;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: 1.5rem;
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 1.5rem 1.5rem;
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "âŽ";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="current numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-language-extension" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-language-extension" checked="checked"></label><span class="number">19.</span>Â <span class=""><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></span></div>
              <table><tr class="numbered"><td class="num">19.1.</td><td><a href="Notations-and-Macros/Custom-Operators/#operators">Custom Operators</a></td></tr><tr class="numbered"><td class="num">19.2.</td><td><a href="Notations-and-Macros/Precedence/#precedence">Precedence</a></td></tr><tr class="numbered"><td class="num">19.3.</td><td><a href="Notations-and-Macros/Notations/#notations">Notations</a></td></tr><tr class="current numbered"><td class="num">19.4.</td><td><a href="Notations-and-Macros/Defining-New-Syntax/#syntax-ext">Defining New Syntax</a></td></tr><tr class="numbered"><td class="num">19.5.</td><td><a href="Notations-and-Macros/Macros/#macros">Macros</a></td></tr><tr class="numbered"><td class="num">19.6.</td><td><a href="Notations-and-Macros/Elaborators/#elaborators">Elaborators</a></td></tr><tr class="numbered"><td class="num">19.7.</td><td><a href="Notations-and-Macros/Extending-Lean___s-Output/#unexpand-and-delab">Extending Lean's Output</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-syntax-ext" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-syntax-ext" checked="checked"></label><span class="number">19.4.</span>Â <span class="current"><a href="Notations-and-Macros/Defining-New-Syntax/#syntax-ext">Defining New Syntax</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-data">Syntax Model</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><code>Syntax</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Preresolved___namespace"><code>Preresolved</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Syntax-Node-Kinds">Syntax Node Kinds</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><code>SyntaxNodeKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___isOfKind"><code>isOfKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___getKind"><code>getKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___setKind"><code>setKind</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Token-and-Literal-Kinds">Token and Literal Kinds</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___identKind"><code>identKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___strLitKind"><code>strLitKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___interpolatedStrKind"><code>interpolatedStrKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___interpolatedStrLitKind"><code>interpolatedStrLitKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___charLitKind"><code>charLitKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___numLitKind"><code>numLitKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___scientificLitKind"><code>scientificLitKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___nameLitKind"><code>nameLitKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___fieldIdxKind"><code>fieldIdxKind</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Internal-Kinds">Internal Kinds</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___groupKind"><code>groupKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___nullKind"><code>nullKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___choiceKind"><code>choiceKind</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___hygieneInfoKind"><code>hygieneInfoKind</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#source-info">Source Positions</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><code>SourceInfo</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">6.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Inspecting-Syntax">Inspecting Syntax</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">7.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#typed-syntax">Typed Syntax</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><code>TSyntax</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKinds"><code>SyntaxNodeKinds</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntaxArray"><code>TSyntaxArray</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___TSepArray___mk"><code>TSepArray</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">8.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases">Aliases</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Term"><code>Term</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Command"><code>Command</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Level"><code>Level</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Tactic"><code>Tactic</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Prec"><code>Prec</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Prio"><code>Prio</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Ident"><code>Ident</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___StrLit"><code>StrLit</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___CharLit"><code>CharLit</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___NameLit"><code>NameLit</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___NumLit"><code>NumLit</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___ScientificLit"><code>ScientificLit</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___HygieneInfo"><code>HygieneInfo</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">9.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#typed-syntax-helpers">Helpers for Typed Syntax</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getId"><code>getId</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getName"><code>getName</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getNat"><code>getNat</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getScientific"><code>getScientific</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getString"><code>getString</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getChar"><code>getChar</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getHygieneInfo"><code>getHygieneInfo</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">10.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-categories">Syntax Categories</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntaxCat"><span class="syntax"><span class="keyword">declare_syntax_cat</span><span class="ws"> </span><span class="meta">â€¦</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">behavior</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span><span class="meta">)?</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___LeadingIdentBehavior___default"><code>LeadingIdentBehavior</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">11.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-rules">Syntax Rules</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="syntax"><span class="keyword">syntax</span><span class="meta">(</span><span class="keyword">:</span><span class="meta">â€¦</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">name</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">priority</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">*</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___nonReserved"><span class="syntax"><span class="keyword">&</span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___cat"><span class="syntax"><span class="meta">â€¦</span><span class="meta">(</span><span class="keyword">:</span><span class="meta">â€¦</span><span class="meta">)?</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx_____FLQQ_"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">*</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx_____FLQQ_-next"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">+</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#stx____"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">?</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___unary"><span class="syntax"><span class="literalIdent">optional</span><span class="keyword">(</span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx________FLQQ_"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">,*</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx________FLQQ_-next"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">,+</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx______________FLQQ_"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">,*,?</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx______________FLQQ_-next"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">,+,?</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx__LT_____GT___FLQQ_"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">&lt;|&gt;</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___binary"><span class="syntax"><span class="literalIdent">orelse</span><span class="keyword">(</span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#stx____-next"><span class="syntax"><span class="keyword">!</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___paren"><span class="syntax"><span class="keyword">(</span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___unary-next"><span class="syntax"><span class="literalIdent">many</span><span class="keyword">(</span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___unary-next-next"><span class="syntax"><span class="literalIdent">many1</span><span class="keyword">(</span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___sepBy"><span class="syntax"><span class="keyword">sepBy(</span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___sepBy-next"><span class="syntax"><span class="keyword">sepBy(</span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___sepBy-next-next"><span class="syntax"><span class="keyword">sepBy(</span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="keyword">allowTrailingSep</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___sepBy1"><span class="syntax"><span class="keyword">sepBy1(</span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___sepBy1-next"><span class="syntax"><span class="keyword">sepBy1(</span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Syntax___sepBy1-next-next"><span class="syntax"><span class="keyword">sepBy1(</span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">,</span><span class="ws"> </span><span class="keyword">allowTrailingSep</span><span class="keyword">)</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">12.</span> <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-indentation">Indentation</a></span></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Notations-and-Macros/Notations/#notations" rel="prev" title="19.3. Notations"><span class="arrow">â†</span><span class="where">19.3. Notations</span></a><a class="local-button active" href="Notations-and-Macros/Macros/#macros" rel="next" title="19.5. Macros"><span class="where">19.5. Macros</span><span class="arrow">â†’</span></a></nav>
          <section>
            <h1>
              19.4.Â Defining New Syntax<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=syntax-ext" title="Permalink">ðŸ”—</a></span></h1>
            <p>
              Lean's uniform representation of syntax is very general and flexible.
This means that extensions to Lean's parser do not require extensions to the representation of parsed syntax.</p>
            <section>
              <h2 id="syntax-data">
                19.4.1.Â Syntax Model<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=syntax-data" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Lean's parser produces a concrete syntax tree, of type <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></code>.
<code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></code> is an inductive type that represents all of Lean's syntax, including commands, terms, tactics, and any custom extensions.
All of these are represented by a few basic building blocks:</p>
              <dl><dt> <span id="--tech-term-Atoms" class="def-technical-term">Atoms</span></dt><dd><p>
                    Atoms are the fundamental terminals of the grammar, including literals (such as those for characters and numbers), parentheses, operators, and keywords.</p>
                  </dd><dt> <span id="--tech-term-Identifiers" class="def-technical-term">Identifiers</span></dt><dd><p>
                    Identifiers represent names, such as <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, or <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1358">Nat.add</span></a></code>.
  Identifier syntax includes a list of pre-resolved names that the identifier might refer to.</p>
                  </dd><dt> <span id="--tech-term-Nodes" class="def-technical-term">Nodes</span></dt><dd><p>
                    Nodes represent the parsing of nonterminals.
  Nodes contain a <span id="--tech-term-syntax-kind" class="def-technical-term"><em>syntax kind</em></span>, which identifies the syntax rule that the node results from, along with an array of child <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> values.</p>
                  </dd><dt> Missing Syntax</dt><dd><p>
                    When the parser encounters an error, it returns a partial result, so Lean can provide some feedback about partially-written programs or programs that contain mistakes.
  Partial results contain one or more instances of missing syntax.</p>
                  </dd></dl><p>
                Atoms and identifiers are collectively referred to as <span id="--tech-term-tokens" class="def-technical-term"><em>tokens</em></span>.</p>
              <div class="namedocs" id="Lean___Syntax___missing">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.atom" title="Permalink">ðŸ”—</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Lean syntax trees.</p>
                  <p>
                    Syntax trees are used pervasively throughout Lean: they are produced by the parser, transformed by
the macro expander, and elaborated. They are also produced by the delaborator and presented to
users.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">missing : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></pre><div class="docs">
                      <p>
                        A portion of the syntax tree that is missing because of a parse error.</p>
                      <p>
                        The indexing operator on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> also returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.missing" data-verso-hover="31">Syntax.missing</span></a></code> when the index is out of bounds.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">node (<span class="var token" data-binding="var-_uniq.15" data-verso-hover="4697">info</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo" data-verso-hover="32">Lean.SourceInfo</span></a>) (<span class="var token" data-binding="var-_uniq.16" data-verso-hover="4698">kind</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a>)
  (<span class="var token" data-binding="var-_uniq.17" data-verso-hover="4590">args</span> : <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a>) : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></pre><div class="docs">
                      <p>
                        A node in the syntax tree that may have further syntax as child nodes. The node's <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.25" data-verso-hover="4700">kind</span></code>
determines its interpretation.</p>
                      <p>
                        For nodes produced by the parser, the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="4701">info</span></code> field is typically <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo.none" data-verso-hover="35">Lean.SourceInfo.none</span></a></code>, and source
information is stored in the corresponding fields of identifiers and atoms. This field is used in
two ways:</p>
                      <ol start="1">
                        <li>
                          <p>
                            The delaborator uses it to associate nodes with metadata that are used to implement
interactive features.</p>
                          </li>
                        <li>
                          <p>
                            Nodes created by quotations use the field to mark the syntax as synthetic (storing the result
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.SourceInfo.fromRef" data-verso-hover="4702">Lean.SourceInfo.fromRef</span></code>) even when its leading or trailing tokens are not.</p>
                          </li>
                        </ol>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">atom (<span class="var token" data-binding="var-_uniq.18" data-verso-hover="4697">info</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo" data-verso-hover="32">Lean.SourceInfo</span></a>) (<span class="var token" data-binding="var-_uniq.19" data-verso-hover="310">val</span> : <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>) : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></pre><div class="docs">
                      <p>
                        A non-identifier atomic component of syntax.</p>
                      <p>
                        All of the following are atoms:</p>
                      <ul>
                        <li>
                          <p>
                            keywords, such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">def</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">inductive</span></code></p>
                          </li>
                        <li>
                          <p>
                            literals, such as numeric or string literals</p>
                          </li>
                        <li>
                          <p>
                            punctuation and delimiters, such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="4703">(</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">)</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=&gt;</span></code>.</p>
                          </li>
                        </ul>
                      <p>
                        Identifiers are represented by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.ident" data-verso-hover="4704">Lean.Syntax.ident</span></a></code> constructor. Atoms also correspond to
quoted strings inside <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Manual.syntax" data-verso-hover="4705">syntax</span></code> declarations.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">ident (<span class="var token" data-binding="var-_uniq.20" data-verso-hover="4697">info</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo" data-verso-hover="32">Lean.SourceInfo</span></a>) (<span class="var token" data-binding="var-_uniq.21" data-verso-hover="4052">rawVal</span> : <a href="Basic-Types/Strings/#Substring___mk"><span class="const token" data-binding="const-Substring" data-verso-hover="3940">Substring</span></a>)
  (<span class="var token" data-binding="var-_uniq.22" data-verso-hover="3273">val</span> : <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span>)
  (<span class="var token" data-binding="var-_uniq.23" data-verso-hover="4706">preresolved</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Preresolved___namespace"><span class="const token" data-binding="const-Lean.Syntax.Preresolved" data-verso-hover="4707">Lean.Syntax.Preresolved</span></a>) : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></pre><div class="docs">
                      <p>
                        An identifier.</p>
                      <p>
                        In addition to source information, identifiers have the following fields:</p>
                      <ul>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.56" data-verso-hover="4052">rawVal</span></code> is the literal substring from the input file</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.57" data-verso-hover="1691">val</span></code> is the parsed Lean name, potentially including macro scopes.</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.58" data-verso-hover="4708">preresolved</span></code> is the list of possible declarations this could refer to, populated by
<a href="https://lean-lang.org/doc/reference/4.19.0/find/?domain=Verso.Genre.Manual.section&name=quasiquotation">quotations</a>.</p>
                          </li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___Preresolved___namespace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Preresolved" title="Permalink">ðŸ”—</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Preresolved : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Preresolved : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    A possible binding of an identifier in the context in which it was quoted.</p>
                  <p>
                    Identifiers in quotations may refer to either global declarations or to namespaces that are in scope
at the site of the quotation. These are saved in the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.ident</span></code> constructor and are part of the
implementation of hygienic macros.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">Â«namespaceÂ» (<span class="var token" data-binding="var-_uniq.68" data-verso-hover="3273">ns</span> : <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span>) : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Preresolved___namespace"><span class="const token" data-binding="const-Lean.Syntax.Preresolved" data-verso-hover="4707">Lean.Syntax.Preresolved</span></a></pre><div class="docs">
                      <p>
                        A potential namespace reference</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">decl (<span class="var token" data-binding="var-_uniq.69" data-verso-hover="3273">n</span> : <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span>) (<span class="var token" data-binding="var-_uniq.70" data-verso-hover="3063">fields</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>) :
  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Preresolved___namespace"><span class="const token" data-binding="const-Lean.Syntax.Preresolved" data-verso-hover="4707">Lean.Syntax.Preresolved</span></a></pre><div class="docs">
                      <p>
                        A potential global constant or section variable reference, with additional field accesses</p>
                      </div>
                    </div>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Syntax-Node-Kinds">
                19.4.2.Â Syntax Node Kinds</h2>
              <p>
                Syntax node kinds typically identify the parser that produced the node.
This is one place where the names given to operators or notations (or their automatically-generated internal names) occur.
While only nodes contain a field that identifies their kind, identifiers have the kind <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___identKind"><span class="const token" data-binding="const-Lean.identKind" data-verso-hover="4709">identKind</span></a></code> by convention, while atoms have their internal string as their kind by convention.
Lean's parser wraps each keyword atom <code>KW</code> in a singleton node whose kind is <code>`token.KW</code>.
The kind of a syntax value can be extracted using <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___getKind"><span class="const token" data-binding="const-Lean.Syntax.getKind" data-verso-hover="4710">Syntax.getKind</span></a></code>.</p>
              <div class="namedocs" id="Lean___SyntaxNodeKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.SyntaxNodeKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.SyntaxNodeKind : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.SyntaxNodeKind : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Specifies the interpretation of a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> value. An abbreviation for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Name</span></code>.</p>
                  <p>
                    Node kinds may be any name, and do not need to refer to declarations in the environment.
Conventionally, however, a node's kind corresponds to the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Parser</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ParserDesc</span></code> declaration that
produces it. There are also a number of built-in node kinds that are used by the parsing
infrastructure, such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">nullKind</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">choiceKind</span></code>; these do not correspond to parser declarations.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___isOfKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.isOfKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.isOfKind (<span class="var token" data-binding="var-_uniq.169" data-verso-hover="1435">stx</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a>) (<span class="var token" data-binding="var-_uniq.170" data-verso-hover="4698">k</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a>) :
  <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only">Lean.Syntax.isOfKind (<span class="var token" data-binding="var-_uniq.169" data-verso-hover="1435">stx</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a>)
  (<span class="var token" data-binding="var-_uniq.170" data-verso-hover="4698">k</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a>) : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                  <p>
                    Checks whether syntax has the given kind or pseudo-kind.</p>
                  <p>
                    â€œPseudo-kindsâ€ are kinds that are assigned by convention to non-<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> values:
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">identKind</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.ident</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`missing</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.missing</span></code>, and the atom's string literal
for atoms.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___getKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.getKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.getKind (<span class="var token" data-binding="var-_uniq.227" data-verso-hover="1435">stx</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a>) : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.Syntax.getKind (<span class="var token" data-binding="var-_uniq.227" data-verso-hover="1435">stx</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a>) :
  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    Gets the kind of a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> value, or the pseudo-kind of any other <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax</span></code> value.</p>
                  <p>
                    â€œPseudo-kindsâ€ are kinds that are assigned by convention to non-<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> values:
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">identKind</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.ident</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`missing</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.missing</span></code>, and the atom's string literal
for atoms.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___setKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.setKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.setKind (<span class="var token" data-binding="var-_uniq.250" data-verso-hover="1435">stx</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a>) (<span class="var token" data-binding="var-_uniq.251" data-verso-hover="4698">k</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a>) :
  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></div><div class="narrow-only">Lean.Syntax.setKind (<span class="var token" data-binding="var-_uniq.250" data-verso-hover="1435">stx</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a>)
  (<span class="var token" data-binding="var-_uniq.251" data-verso-hover="4698">k</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a>) : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></div></pre><div class="text">
                  <p>
                    Changes the kind at the root of a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.229" data-verso-hover="4698">k</span></code>.</p>
                  <p>
                    Returns all other <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax</span></code> values unchanged.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Token-and-Literal-Kinds">
                19.4.3.Â Token and Literal Kinds</h2>
              <p>
                A number of named kinds are associated with the basic tokens produced by the parser.
Typically, single-token syntax productions consist of a <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="4711">node</span></a></code> that contains a single <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.atom" data-verso-hover="4712">atom</span></a></code>; the kind saved in the node allows the value to be recognized.
Atoms for literals are not interpreted by the parser: string atoms include their leading and trailing double-quote characters along with any escape sequences contained within, and hexadecimal numerals are saved as a string that begins with <code class="hl lean inline" data-lean-context="examples"><span class="literal string token" data-binding="" data-verso-hover="4713">"0x"</span></code>.
<a href="Notations-and-Macros/Defining-New-Syntax/#typed-syntax-helpers">Helpers</a> such as <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getString"><span class="const token" data-binding="const-Lean.TSyntax.getString" data-verso-hover="4714">Lean.TSyntax.getString</span></a></code> are provided to perform this decoding on demand.</p>
              <div class="namedocs" id="Lean___identKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.identKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.identKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.identKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    The pseudo-kind assigned to identifiers: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`ident</span></code>.</p>
                  <p>
                    The name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`ident</span></code> is not actually used as a kind for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> values. It is used by
convention as the kind of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.ident</span></code> values.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___strLitKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.strLitKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.strLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.strLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`str</span></code> is the node kind of string literals like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="literal string token" data-binding="" data-verso-hover="2492">"foo"</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___interpolatedStrKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.interpolatedStrKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.interpolatedStrKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.interpolatedStrKind :
  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`interpolatedStrKind</span></code> is the node kind of an interpolated string literal like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="literal string token" data-binding="" data-verso-hover="4715">"value = {x}"</span></code>
in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">s!</span><span class="literal string token" data-binding="" data-verso-hover="4715">"value = {x}"</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___interpolatedStrLitKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.interpolatedStrLitKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.interpolatedStrLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.interpolatedStrLitKind :
  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`interpolatedStrLitKind</span></code> is the node kind of interpolated string literal
fragments like <code>"value = {</code> and <code>}"</code> in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">s!</span><span class="literal string token" data-binding="" data-verso-hover="4715">"value = {x}"</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___charLitKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.charLitKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.charLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.charLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`char</span></code> is the node kind of character literals like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">'A'</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___numLitKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.numLitKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.numLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.numLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`num</span></code> is the node kind of number literals like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="7">42</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___scientificLitKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.scientificLitKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.scientificLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.scientificLitKind :
  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`scientific</span></code> is the node kind of floating point literals like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">1.23e-3</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___nameLitKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.nameLitKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.nameLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.nameLitKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`name</span></code> is the node kind of name literals like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`foo</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___fieldIdxKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.fieldIdxKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.fieldIdxKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.fieldIdxKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    `` <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">fieldIdx</span></code> is the node kind of projection indices like the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="7">2</span></code> in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span></code>.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Internal-Kinds">
                19.4.4.Â Internal Kinds</h2>
              <div class="namedocs" id="Lean___groupKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.groupKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.groupKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.groupKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`group</span></code> kind is used for nodes that result from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Parser.group" data-verso-hover="4716">Lean.Parser.group</span></code>. This avoids confusion
with the null kind when used inside <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/API-Reference/#optional"><span class="const token" data-binding="const-optional" data-verso-hover="4717">optional</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___nullKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.nullKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.nullKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.nullKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`null</span></code> is the â€œfallbackâ€ kind, used when no other kind applies. Null nodes result from
repetition operators, and empty null nodes represent the failure of an optional parse.</p>
                  <p>
                    The null kind is used for raw list parsers like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Manual.many" data-verso-hover="4718">many</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___choiceKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.choiceKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.choiceKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.choiceKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`choice</span></code> kind is used to represent ambiguous parse results.</p>
                  <p>
                    The parser prioritizes longer matches over shorter ones, but there is not always a unique longest
match. All the parse results are saved, and the determination of which to use is deferred
until typing information is available.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___hygieneInfoKind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.hygieneInfoKind" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.hygieneInfoKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div><div class="narrow-only">Lean.hygieneInfoKind : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKind"><span class="const token" data-binding="const-Lean.SyntaxNodeKind" data-verso-hover="4699">Lean.SyntaxNodeKind</span></a></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">`hygieneInfo</span></code> is the node kind of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Parser.hygieneInfo" data-verso-hover="4719">Lean.Parser.hygieneInfo</span></code> parser, which produces an
â€œinvisible tokenâ€ that captures the hygiene information at the current point without parsing
anything.</p>
                  <p>
                    They can be used to generate identifiers (with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.HygieneInfo.mkIdent" data-verso-hover="4720">Lean.HygieneInfo.mkIdent</span></code>) as if they were
introduced in a macro's input, rather than by its implementation.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="source-info">
                19.4.5.Â Source Positions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=source-info" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Atoms, identifiers, and nodes optionally contain <span id="--tech-term-source-information" class="def-technical-term">source information</span> that tracks their correspondence with the original file.
The parser saves source information for all tokens, but not for nodes; position information for parsed nodes is reconstructed from their first and last tokens.
Not all <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> data results from the parser: it may be the result of <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-macro-expansion">macro expansion</a>, in which case it typically contains a mix of generated and parsed syntax, or it may be the result of <a class="technical-term" href="Notations-and-Macros/Extending-Lean___s-Output/#--tech-term-delaborators">delaborating</a> an internal term to display it to a user.
In these use cases, nodes may themselves contain source information.</p>
              <p>
                Source information comes in two varieties:</p>
              <dl><dt> <span id="--tech-term-Original" class="def-technical-term">Original</span></dt><dd><p>
                    Original source information comes from the parser.
  In addition to the original source location, it also contains leading and trailing whitespace that was skipped by the parser, which allows the original string to be reconstructed.
  This whitespace is saved as offsets into the string representation of the original source code (that is, as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Strings/#Substring___mk"><span class="const token" data-binding="const-Substring" data-verso-hover="3940">Substring</span></a></code>) to avoid having to allocate copies of substrings.</p>
                  </dd><dt> <span id="--tech-term-Synthetic" class="def-technical-term">Synthetic</span></dt><dd><p>
                    Synthetic source information comes from metaprograms (including macros) or from Lean's internals.
  Because there is no original string to be reconstructed, it does not save leading and trailing whitespace.
  Synthetic source positions are used to provide accurate feedback even when terms have been automatically transformed, as well as to track the correspondence between elaborated expressions and their presentation in Lean's output.
  A synthetic position may be marked <span id="--tech-term-canonical" class="def-technical-term"><em>canonical</em></span>, in which case some operations that would ordinarily ignore synthetic positions will treat it as if it were not.</p>
                  </dd></dl><div class="namedocs" id="Lean___SourceInfo___original">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.SourceInfo.synthetic" title="Permalink">ðŸ”—</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only">Lean.SourceInfo : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.SourceInfo : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Source information that relates syntax to the context that it came from.</p>
                  <p>
                    The primary purpose of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">SourceInfo</span></code> is to relate the output of the parser and the macro expander to
the original source file. When produced by the parser, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> does not carry source info; the
parser associates it only with atoms and identifiers. If a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> is introduced by a
quotation, then it has synthetic source info that both associates it with an original reference
position and indicates that the original atoms in it may not originate from the Lean file under
elaboration.</p>
                  <p>
                    Source info is also used to relate Lean's output to the internal data that it represents; this is
the basis for many interactive features. When used this way, it can occur on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax.node</span></code> as well.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">original (<span class="var token" data-binding="var-_uniq.2051" data-verso-hover="4052">leading</span> : <a href="Basic-Types/Strings/#Substring___mk"><span class="const token" data-binding="const-Substring" data-verso-hover="3940">Substring</span></a>) (<span class="var token" data-binding="var-_uniq.2052" data-verso-hover="3895">pos</span> : <a href="Basic-Types/Strings/#String___Pos___mk"><span class="const token" data-binding="const-String.Pos" data-verso-hover="3837">String.Pos</span></a>)
  (<span class="var token" data-binding="var-_uniq.2053" data-verso-hover="4052">trailing</span> : <a href="Basic-Types/Strings/#Substring___mk"><span class="const token" data-binding="const-Substring" data-verso-hover="3940">Substring</span></a>) (<span class="var token" data-binding="var-_uniq.2054" data-verso-hover="3895">endPos</span> : <a href="Basic-Types/Strings/#String___Pos___mk"><span class="const token" data-binding="const-String.Pos" data-verso-hover="3837">String.Pos</span></a>) :
  <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo" data-verso-hover="32">Lean.SourceInfo</span></a></pre><div class="docs">
                      <p>
                        A token produced by the parser from original input that includes both leading and trailing
whitespace as well as position information.</p>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2062" data-verso-hover="4052">leading</span></code> whitespace is inferred after parsing by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Syntax.updateLeading" data-verso-hover="4721">Syntax.updateLeading</span></code>. This is because the
â€œpreceding tokenâ€ is not well-defined during parsing, especially in the presence of backtracking.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">synthetic (<span class="var token" data-binding="var-_uniq.2055" data-verso-hover="3895">pos </span><span class="var token" data-binding="var-_uniq.2056" data-verso-hover="3895">endPos</span> : <a href="Basic-Types/Strings/#String___Pos___mk"><span class="const token" data-binding="const-String.Pos" data-verso-hover="3837">String.Pos</span></a>)
  (<span class="var token" data-binding="var-_uniq.2057" data-verso-hover="3218">canonical</span> : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> := <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a>) : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo" data-verso-hover="32">Lean.SourceInfo</span></a></pre><div class="docs">
                      <p>
                        Synthetic syntax is syntax that was produced by a metaprogram or by Lean itself (e.g. by a
quotation). Synthetic syntax is annotated with a source span from the original syntax, which
relates it to the source file.</p>
                      <p>
                        The delaborator uses this constructor to store an encoded indicator of which core language
expression gave rise to the syntax.</p>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2076" data-verso-hover="3218">canonical</span></code> flag on synthetic syntax is enabled for syntax that is not literally part of the
original input syntax but should be treated â€œas ifâ€ the user really wrote it for the purpose of
hovers and error messages. This is usually used on identifiers in order to connect the binding
site to the user's original syntax even if the name of the identifier changes during expansion, as
well as on tokens that should receive targeted messages.</p>
                      <p>
                        Generally speaking, a macro expansion should only use a given piece of input syntax in a single
canonical token. An exception to this rule is when the same identifier is used to declare two
binders, as in the macro expansion for dependent if:</p>
                      <pre>`(if $h : $cond then $t else $e) ~&gt;
`(dite $cond (fun $h =&gt; $t) (fun $h =&gt; $t))
</pre><p>
                        In these cases, if the user hovers over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> they will see information about both binding sites.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">none : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo" data-verso-hover="32">Lean.SourceInfo</span></a></pre><div class="docs">
                      <p>
                        A synthesized token without position information.</p>
                      </div>
                    </div>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Inspecting-Syntax">
                19.4.6.Â Inspecting Syntax</h2>
              <p>
                There are three primary ways to inspect <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> values:</p>
              <dl><dt> The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Repr" data-verso-hover="66">Repr</span></code> Instance</dt><dd><p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Repr" data-verso-hover="66">Repr</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> instance produces a very detailed representation of syntax in terms of the constructors of the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> type.</p>
                  </dd><dt> The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span></code> Instance</dt><dd><p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> instance produces a compact view, representing certain syntax kinds with particular conventions that can make it easier to read at a glance.
  This instance suppresses source position information.</p>
                  </dd><dt> The Pretty Printer</dt><dd><p>
                    Lean's pretty printer attempts to render the syntax as it would look in a source file, but fails if the nesting structure of the syntax doesn't match the expected shape.</p>
                  </dd></dl><details class="example"><summary class="description">Representing Syntax as Constructors</summary><div class="example-content">
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Repr" data-verso-hover="66">Repr</span></code> instance's representation of syntax can be inspected by quoting it in the context of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.eval : command</code><span class="sep"></span><code class="docstring">`#eval e` evaluates the expression `e` by compiling and evaluating it.

* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.
* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`
  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.
  Users can define `MonadEval` instances to extend the list of supported monads.

The `#eval` command gracefully degrades in capability depending on what is imported.
Importing the `Lean.Elab.Command` module provides full capabilities.

Due to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,
since the presence of `sorry` can lead to runtime instability and crashes.
This check can be overridden with the `#eval! e` command.

Options:
* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the
  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.
* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.
* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance
  when there is no other way to print the result.

See also: `#reduce e` for evaluation by term reduction.
</code></code><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><code class="kw">#eval</code></a></span>, which can run actions in the command elaboration monad <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="74">CommandElabM</span></code>.
To reduce the size of the example output, the helper <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#removeSourceInfo"><span class="const token" data-binding="const-removeSourceInfo" data-verso-hover="4722">removeSourceInfo</span></a></code> is used to remove source information prior to display.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.partial-7606">partial</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7614">def</span> <span class="const token" data-binding="const-removeSourceInfo" data-verso-hover="4722" id="removeSourceInfo">removeSourceInfo</span> <span class="unknown token" data-binding="">:</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.atom" data-verso-hover="4723">.atom</span></a> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="310">str</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.atom" data-verso-hover="4723">.atom</span></a> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo.none" data-verso-hover="35">.none</span></a> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="310">str</span>
  <span class="unknown token" data-binding="">|</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.ident" data-verso-hover="4724">.ident</span></a> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="4052">str</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="1691">x</span> <span class="var token" data-binding="var-_uniq.43" data-verso-hover="4725">pre</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.ident" data-verso-hover="4724">.ident</span></a> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo.none" data-verso-hover="35">.none</span></a> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="4052">str</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="1691">x</span> <span class="var token" data-binding="var-_uniq.43" data-verso-hover="4725">pre</span>
  <span class="unknown token" data-binding="">|</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="4726">.node</span></a> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="4700">k</span> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="4727">children</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="4726">.node</span></a> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original"><span class="const token" data-binding="const-Lean.SourceInfo.none" data-verso-hover="35">.none</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="4700">k</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.61" data-verso-hover="4727">children</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___map"><span class="const token" data-binding="const-Array.map" data-verso-hover="4567">map</span></a> <a href="Notations-and-Macros/Defining-New-Syntax/#removeSourceInfo"><span class="const token" data-binding="const-removeSourceInfo" data-verso-hover="4722">removeSourceInfo</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.missing" data-verso-hover="31">.missing</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.missing" data-verso-hover="31">.missing</span></a>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Lean.Syntax.node
  (Lean.SourceInfo.none)
  `Â«term_+_Â»
  #[Lean.Syntax.node (Lean.SourceInfo.none) `num #[Lean.Syntax.atom (Lean.SourceInfo.none) "2"],
    Lean.Syntax.atom (Lean.SourceInfo.none) "+", Lean.Syntax.missing]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-7868" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-7874">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-7879">let</span> <span class="var token" data-binding="var-_uniq.1380" data-verso-hover="4728">stx</span> <span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="const-Lean.TSyntax.mk" data-verso-hover="4729">âŸ¨</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.missing" data-verso-hover="31">.missing</span></a><span class="unknown token" data-binding="const-Lean.TSyntax.mk" data-verso-hover="4729">âŸ©</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4730">logInfo</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-repr" data-verso-hover="4731">repr</span> <span class="unknown token" data-binding="">(</span><a href="Notations-and-Macros/Defining-New-Syntax/#removeSourceInfo"><span class="const token" data-binding="const-removeSourceInfo" data-verso-hover="4722">removeSourceInfo</span></a> <span class="var token" data-binding="var-_uniq.1380" data-verso-hover="4728">stx</span><span class="unknown token" data-binding="">.</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><span class="const token" data-binding="const-Lean.TSyntax.raw" data-verso-hover="4732">raw</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>Lean.Syntax.node
  (Lean.SourceInfo.none)
  `Â«term_+_Â»
  #[Lean.Syntax.node (Lean.SourceInfo.none) `num #[Lean.Syntax.atom (Lean.SourceInfo.none) "2"],
    Lean.Syntax.atom (Lean.SourceInfo.none) "+", Lean.Syntax.missing]
</pre></div>
                  <p>
                    In the second example, <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-macro-scopes">macro scopes</a> inserted by quotation are visible on the call to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1340">List.length</span></a></code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Lean.Syntax.node
  (Lean.SourceInfo.none)
  `Lean.Parser.Term.app
  #[Lean.Syntax.ident
      (Lean.SourceInfo.none)
      "List.length".toSubstring
      (Lean.Name.mkNum `List.length._@.Manual.NotationsMacros.SyntaxDef._hyg 2)
      [Lean.Syntax.Preresolved.decl `List.length [], Lean.Syntax.Preresolved.namespace `List.length],
    Lean.Syntax.node
      (Lean.SourceInfo.none)
      `null
      #[Lean.Syntax.node
          (Lean.SourceInfo.none)
          `Â«term[_]Â»
          #[Lean.Syntax.atom (Lean.SourceInfo.none) "[",
            Lean.Syntax.node
              (Lean.SourceInfo.none)
              `null
              #[Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) "\"Rose\""],
                Lean.Syntax.atom (Lean.SourceInfo.none) ",",
                Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) "\"Daffodil\""],
                Lean.Syntax.atom (Lean.SourceInfo.none) ",",
                Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) "\"Lily\""]],
            Lean.Syntax.atom (Lean.SourceInfo.none) "]"]]]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-8357" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8363">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-8368">let</span> <span class="var token" data-binding="var-_uniq.1382" data-verso-hover="4728">stx</span> <span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">List.length</span> <span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="4733">"Rose"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4734">"Daffodil"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4735">"Lily"</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4730">logInfo</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-repr" data-verso-hover="4731">repr</span> <span class="unknown token" data-binding="">(</span><a href="Notations-and-Macros/Defining-New-Syntax/#removeSourceInfo"><span class="const token" data-binding="const-removeSourceInfo" data-verso-hover="4722">removeSourceInfo</span></a> <span class="var token" data-binding="var-_uniq.1382" data-verso-hover="4728">stx</span><span class="unknown token" data-binding="">.</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><span class="const token" data-binding="const-Lean.TSyntax.raw" data-verso-hover="4732">raw</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                    The contents of the <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-pre-resolved-identifiers">pre-resolved identifier</a> <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1340">List.length</span></a></code> are visible here:</p>
                  <div class="information">
                    <pre>Lean.Syntax.node
  (Lean.SourceInfo.none)
  `Lean.Parser.Term.app
  #[Lean.Syntax.ident
      (Lean.SourceInfo.none)
      "List.length".toSubstring
      (Lean.Name.mkNum `List.length._@.Manual.NotationsMacros.SyntaxDef._hyg 2)
      [Lean.Syntax.Preresolved.decl `List.length [], Lean.Syntax.Preresolved.namespace `List.length],
    Lean.Syntax.node
      (Lean.SourceInfo.none)
      `null
      #[Lean.Syntax.node
          (Lean.SourceInfo.none)
          `Â«term[_]Â»
          #[Lean.Syntax.atom (Lean.SourceInfo.none) "[",
            Lean.Syntax.node
              (Lean.SourceInfo.none)
              `null
              #[Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) "\"Rose\""],
                Lean.Syntax.atom (Lean.SourceInfo.none) ",",
                Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) "\"Daffodil\""],
                Lean.Syntax.atom (Lean.SourceInfo.none) ",",
                Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) "\"Lily\""]],
            Lean.Syntax.atom (Lean.SourceInfo.none) "]"]]]
</pre></div>
                  </div>
                </details><p>
                The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ToString" data-verso-hover="67">ToString</span></code> instance represents the constructors of <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Syntax</span></a></code> as follows:</p>
              <ul>
                <li>
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.ident" data-verso-hover="4736">ident</span></a></code> constructor is represented as the underlying name. Source information and pre-resolved names are not shown.</p>
                  </li>
                <li>
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.atom" data-verso-hover="4712">atom</span></a></code> constructor is represented as a string.</p>
                  </li>
                <li>
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.missing" data-verso-hover="4737">missing</span></a></code> constructor is represented by <code>&lt;missing&gt;</code>.</p>
                  </li>
                <li>
                  <p>
                    The representation of the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="4711">node</span></a></code> constructor depends on the kind.
   If the kind is <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">`null</span></code>, then the node is represented by its child nodes order in square brackets.
   Otherwise, the node is represented by its kind followed by its child nodes, both surrounded by parentheses.</p>
                  </li>
                </ul>
              <details class="example"><summary class="description">Syntax as Strings</summary><div class="example-content">
                  <p>
                    The string representation of syntax can be inspected by quoting it in the context of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.eval : command</code><span class="sep"></span><code class="docstring">`#eval e` evaluates the expression `e` by compiling and evaluating it.

* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.
* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`
  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.
  Users can define `MonadEval` instances to extend the list of supported monads.

The `#eval` command gracefully degrades in capability depending on what is imported.
Importing the `Lean.Elab.Command` module provides full capabilities.

Due to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,
since the presence of `sorry` can lead to runtime instability and crashes.
This check can be overridden with the `#eval! e` command.

Options:
* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the
  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.
* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.
* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance
  when there is no other way to print the result.

See also: `#reduce e` for evaluation by term reduction.
</code></code><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><code class="kw">#eval</code></a></span>, which can run actions in the command elaboration monad <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="74">CommandElabM</span></code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(Â«term_+_Â» (num "2") "+" &lt;missing&gt;)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-10745" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10751">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10756">let</span> <span class="var token" data-binding="var-_uniq.1347" data-verso-hover="4728">stx</span> <span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="const-Lean.TSyntax.mk" data-verso-hover="4729">âŸ¨</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.missing" data-verso-hover="31">.missing</span></a><span class="unknown token" data-binding="const-Lean.TSyntax.mk" data-verso-hover="4729">âŸ©</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4730">logInfo</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ToString.toString" data-verso-hover="620">toString</span> <span class="var token" data-binding="var-_uniq.1347" data-verso-hover="4728">stx</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>(Â«term_+_Â» (num "2") "+" &lt;missing&gt;)
</pre></div>
                  <p>
                    In the second example, <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-macro-scopes">macro scopes</a> inserted by quotation are visible on the call to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1340">List.length</span></a></code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(Term.app
 `List.length._@.Manual.NotationsMacros.SyntaxDef._hyg.2
 [(Â«term[_]Â» "[" [(str "\"Rose\"") "," (str "\"Daffodil\"") "," (str "\"Lily\"")] "]")])</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11037" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-11043">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-11048">let</span> <span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4728">stx</span> <span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">List.length</span> <span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="4733">"Rose"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4734">"Daffodil"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4735">"Lily"</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4730">logInfo</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ToString.toString" data-verso-hover="620">toString</span> <span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4728">stx</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>(Term.app
 `List.length._@.Manual.NotationsMacros.SyntaxDef._hyg.2
 [(Â«term[_]Â» "[" [(str "\"Rose\"") "," (str "\"Daffodil\"") "," (str "\"Lily\"")] "]")])
</pre></div>
                  </div>
                </details><p>
                Pretty printing syntax is typically most useful when including it in a message to a user.
Normally, Lean automatically invokes the pretty printer when necessary.
However, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.ppTerm" data-verso-hover="4738">ppTerm</span></code> can be explicitly invoked if needed.</p>
              <details class="example"><summary class="description">Pretty-Printed Syntax</summary><div class="example-content">
                  <p>
                    The string representation of syntax can be inspected by quoting it in the context of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.eval : command</code><span class="sep"></span><code class="docstring">`#eval e` evaluates the expression `e` by compiling and evaluating it.

* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.
* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`
  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.
  Users can define `MonadEval` instances to extend the list of supported monads.

The `#eval` command gracefully degrades in capability depending on what is imported.
Importing the `Lean.Elab.Command` module provides full capabilities.

Due to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,
since the presence of `sorry` can lead to runtime instability and crashes.
This check can be overridden with the `#eval! e` command.

Options:
* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the
  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.
* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.
* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance
  when there is no other way to print the result.

See also: `#reduce e` for evaluation by term reduction.
</code></code><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><code class="kw">#eval</code></a></span>, which can run actions in the command elaboration monad <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="74">CommandElabM</span></code>.
Because new syntax declarations also equip the pretty printer with instructions for displaying them, the pretty printer requires a configuration object.
This context can be constructed with a helper:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12096">def</span> <span class="const token" data-binding="const-getPPContext" data-verso-hover="4739" id="getPPContext">getPPContext</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="74">CommandElabM</span> <span class="const token" data-binding="const-Lean.PPContext" data-verso-hover="4740">PPContext</span> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-12141">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-12146" data-verso-hover="230">return</span> <span class="unknown token" data-binding="">{</span>
    <span class="const token" data-binding="const-Lean.PPContext.env" data-verso-hover="4741">env</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-Lean.MonadEnv.getEnv" data-verso-hover="1712">getEnv</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-Lean.PPContext.opts" data-verso-hover="4742">opts</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-Lean.MonadOptions.getOptions" data-verso-hover="4743">getOptions</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-Lean.PPContext.currNamespace" data-verso-hover="4744">currNamespace</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-Lean.MonadResolveName.getCurrNamespace" data-verso-hover="4745">getCurrNamespace</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-Lean.PPContext.openDecls" data-verso-hover="4746">openDecls</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-Lean.MonadResolveName.getOpenDecls" data-verso-hover="4747">getOpenDecls</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">}</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">2 + 5</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-12325" data-verso-hover="6">#eval</span></a></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-12331">show</span> <span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="74">CommandElabM</span> <a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-12354">from</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-12359">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-12364">let</span> <span class="var token" data-binding="var-_uniq.332" data-verso-hover="4728">stx</span> <span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">5</span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-12387">let</span> <span class="var token" data-binding="var-_uniq.514" data-verso-hover="4748">fmt</span> <span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-Lean.ppTerm" data-verso-hover="4749">ppTerm</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <a href="Notations-and-Macros/Defining-New-Syntax/#getPPContext"><span class="const token" data-binding="const-getPPContext" data-verso-hover="4739">getPPContext</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.332" data-verso-hover="4728">stx</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4730">logInfo</span> <span class="var token" data-binding="var-_uniq.514" data-verso-hover="4748">fmt</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>2 + 5
</pre></div>
                  <p>
                    In the second example, the <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-macro-scopes">macro scopes</a> inserted on <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1340">List.length</span></a></code> by quotation cause it to be displayed with a dagger (<code>âœ</code>).</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">List.lengthâœ ["Rose", "Daffodil", "Lily"]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-12645" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-12651">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-12656">let</span> <span class="var token" data-binding="var-_uniq.405" data-verso-hover="4728">stx</span> <span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">List.length</span> <span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="4733">"Rose"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4734">"Daffodil"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4735">"Lily"</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-12714">let</span> <span class="var token" data-binding="var-_uniq.599" data-verso-hover="4748">fmt</span> <span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-Lean.ppTerm" data-verso-hover="4749">ppTerm</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <a href="Notations-and-Macros/Defining-New-Syntax/#getPPContext"><span class="const token" data-binding="const-getPPContext" data-verso-hover="4739">getPPContext</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.405" data-verso-hover="4728">stx</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4730">logInfo</span> <span class="var token" data-binding="var-_uniq.599" data-verso-hover="4748">fmt</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>List.lengthâœ ["Rose", "Daffodil", "Lily"]
</pre></div>
                  <p>
                    Pretty printing wraps lines and inserts indentation automatically.
A <a class="technical-term" href="Coercions/#--tech-term-coercion">coercion</a> typically converts the pretty printer's output to the type expected by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4750">logInfo</span></code>, using a default layout width.
The width can be controlled by explicitly calling <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Std.Format.pretty" data-verso-hover="4751">pretty</span></code> with a named argument.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">List.lengthâœ
  ["Rose", "Daffodil", "Lily", "Rose",
    "Daffodil", "Lily", "Rose",
    "Daffodil", "Lily"]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-13179" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-13185">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-13190">let</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="2751">flowers</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">#[</span><span class="literal string token" data-binding="" data-verso-hover="4733">"Rose"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4734">"Daffodil"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4735">"Lily"</span><span class="unknown token" data-binding="">]</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-13237">let</span> <span class="var token" data-binding="var-_uniq.93" data-verso-hover="2751">manyFlowers</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="2751">flowers</span> <span class="unknown token" data-binding="">++</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="2751">flowers</span> <span class="unknown token" data-binding="">++</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="2751">flowers</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-13288">let</span> <span class="var token" data-binding="var-_uniq.589" data-verso-hover="4728">stx</span> <span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">List.length</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="2751">manyFlowers</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___map"><span class="const token" data-binding="const-Array.map" data-verso-hover="4567">map</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Quote.quote" data-verso-hover="1727">quote</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">k</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">`term</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-13361">let</span> <span class="var token" data-binding="var-_uniq.783" data-verso-hover="4748">fmt</span> <span class="unknown token" data-binding="">â†</span> <span class="const token" data-binding="const-Lean.ppTerm" data-verso-hover="4749">ppTerm</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">â†</span> <a href="Notations-and-Macros/Defining-New-Syntax/#getPPContext"><span class="const token" data-binding="const-getPPContext" data-verso-hover="4739">getPPContext</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.589" data-verso-hover="4728">stx</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="4730">logInfo</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.783" data-verso-hover="4748">fmt</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Std.Format.pretty" data-verso-hover="4752">pretty</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">width</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">40</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>List.lengthâœ
  ["Rose", "Daffodil", "Lily", "Rose",
    "Daffodil", "Lily", "Rose",
    "Daffodil", "Lily"]
</pre></div>
                  </div>
                </details></section>
            <section>
              <h2 id="typed-syntax">
                19.4.7.Â Typed Syntax<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=typed-syntax" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Syntax may additionally be annotated with a type that specifies which <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-categories">syntax category</a> it belongs to.

The <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1969">TSyntax</span></a></code> structure contains a type-level list of syntax categories along with a syntax tree.
The list of syntax categories typically contains precisely one element, in which case the list structure itself is not shown.</p>
              <div class="namedocs" id="Lean___TSyntax___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax" title="Permalink">ðŸ”—</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax (<span class="var token" data-binding="var-_uniq.2172" data-verso-hover="4753">ks</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKinds"><span class="const token" data-binding="const-Lean.SyntaxNodeKinds" data-verso-hover="4754">Lean.SyntaxNodeKinds</span></a>) : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.TSyntax (<span class="var token" data-binding="var-_uniq.2172" data-verso-hover="4753">ks</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKinds"><span class="const token" data-binding="const-Lean.SyntaxNodeKinds" data-verso-hover="4754">Lean.SyntaxNodeKinds</span></a>) :
  <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Typed syntax, which tracks the potential kinds of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax</span></code> it contains.</p>
                  <p>
                    While syntax quotations produce or expect <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TSyntax</span></code> values of the correct kinds, this is not
otherwise enforced; it can easily be circumvented by direct use of the constructor.</p>
                  <h1>
                    Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><span class="const token" data-binding="const-Lean.TSyntax.mk" data-verso-hover="4755">Lean.TSyntax.mk</span></a></pre><div class="docs"></div>
                    </section>
                  <h1>
                    Fields</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.TSyntax.raw" data-verso-hover="4756">raw</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></pre><div class="docs">
                      <p>
                        The underlying <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax</span></code> value.</p>
                      </div>
                    </section>
                  </div>
                </div>
              <div class="namedocs" id="Lean___SyntaxNodeKinds">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.SyntaxNodeKinds" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.SyntaxNodeKinds : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.SyntaxNodeKinds : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">SyntaxNodeKinds</span></code> is a set of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">SyntaxNodeKind</span></code>, implemented as a list.</p>
                  <p>
                    Singleton <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">SyntaxNodeKinds</span></code> are extremely common. They are written as name literals, rather than as
lists; list syntax is required only for empty or non-singleton sets of kinds.</p>
                  </div>
                </div>
              <p>
                <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-Quasiquotation">Quasiquotations</a> prevent the substitution of typed syntax that does not come from the correct syntactic category.
For many of Lean's built-in syntactic categories, there is a set of <a class="technical-term" href="Coercions/#--tech-term-coercion">coercions</a> that appropriately wrap one kind of syntax for another category, such as a coercion from the syntax of string literals to the syntax of terms.
Additionally, many helper functions that are only valid on some syntactic categories are defined for the appropriate typed syntax only.</p>
              <p>
                The constructor of <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1969">TSyntax</span></a></code> is public, and nothing prevents users from constructing values that break internal invariants.
The use of <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1969">TSyntax</span></a></code> should be seen as a way to reduce common mistakes, rather than rule them out entirely.</p>
              <p>
                In addition to <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1969">TSyntax</span></a></code>, there are types that represent arrays of syntax, with or without separators.
These correspond to  repeated elements in syntax declarations or antiquotations.</p>
              <div class="namedocs" id="Lean___TSyntaxArray">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntaxArray" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntaxArray (<span class="var token" data-binding="var-_uniq.2216" data-verso-hover="4753">ks</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKinds"><span class="const token" data-binding="const-Lean.SyntaxNodeKinds" data-verso-hover="4754">Lean.SyntaxNodeKinds</span></a>) : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.TSyntaxArray
  (<span class="var token" data-binding="var-_uniq.2216" data-verso-hover="4753">ks</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKinds"><span class="const token" data-binding="const-Lean.SyntaxNodeKinds" data-verso-hover="4754">Lean.SyntaxNodeKinds</span></a>) : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    An array of syntaxes of kind <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2215" data-verso-hover="4753">ks</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___TSepArray___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.TSepArray.elemsAndSeps" title="Permalink">ðŸ”—</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.TSepArray (<span class="var token" data-binding="var-_uniq.2272" data-verso-hover="4753">ks</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKinds"><span class="const token" data-binding="const-Lean.SyntaxNodeKinds" data-verso-hover="4754">Lean.SyntaxNodeKinds</span></a>) (<span class="var token" data-binding="var-_uniq.2273" data-verso-hover="310">sep</span> : <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>) : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.TSepArray
  (<span class="var token" data-binding="var-_uniq.2272" data-verso-hover="4753">ks</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SyntaxNodeKinds"><span class="const token" data-binding="const-Lean.SyntaxNodeKinds" data-verso-hover="4754">Lean.SyntaxNodeKinds</span></a>)
  (<span class="var token" data-binding="var-_uniq.2273" data-verso-hover="310">sep</span> : <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>) : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    An array of syntax elements that alternate with the given separator. Each syntax element has a kind
drawn from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2217" data-verso-hover="4753">ks</span></code>.</p>
                  <p>
                    Separator arrays result from repetition operators such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">,*</span></code>.
<a href="https://lean-lang.org/doc/reference/4.19.0/find/?domain=Verso.Genre.Manual.section&name=coercions">Coercions</a> to and from <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">TSyntax</span> <span class="unknown token" data-binding="">ks</span><span class="unknown token" data-binding="">)</span></code> insert or remove
separators as required. The untyped equivalent is <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Syntax.SepArray" data-verso-hover="4757">Lean.Syntax.SepArray</span></code>.</p>
                  <h1>
                    Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___TSepArray___mk"><span class="const token" data-binding="const-Lean.Syntax.TSepArray.mk" data-verso-hover="4758">Lean.Syntax.TSepArray.mk</span></a></pre><div class="docs"></div>
                    </section>
                  <h1>
                    Fields</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Syntax.TSepArray.elemsAndSeps" data-verso-hover="4759">elemsAndSeps</span> : <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a> <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="30">Lean.Syntax</span></a></pre><div class="docs">
                      <p>
                        The array of elements and separators, ordered like
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">#[</span><span class="var token" data-binding="var-_uniq.2312" data-verso-hover="4760">el1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2354" data-verso-hover="4760">sep1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2398" data-verso-hover="4760">el2</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2445" data-verso-hover="4760">sep2</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2495" data-verso-hover="4760">el3</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </div>
                    </section>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases">
                19.4.8.Â Aliases</h2>
              <p>
                A number of aliases are provided for commonly-used typed syntax varieties.
These aliases allow code to be written at a higher level of abstraction.</p>
              <div class="namedocs" id="Lean___Syntax___Term">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Term" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Term : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Term : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a Lean term.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___Command">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Command" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Command : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Command : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a command.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___Level">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Level" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Level : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Level : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a universe level.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___Tactic">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Tactic" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Tactic : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Tactic : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a tactic.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___Prec">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Prec" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Prec : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Prec : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a precedence (e.g. for an operator).</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___Prio">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Prio" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Prio : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Prio : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a priority (e.g. for an instance declaration).</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___Ident">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.Ident" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.Ident : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.Ident : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents an identifier.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___StrLit">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.StrLit" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.StrLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.StrLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a string literal.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___CharLit">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.CharLit" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.CharLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.CharLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a character literal.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___NameLit">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.NameLit" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.NameLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.NameLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a quoted name literal that begins with a back-tick.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___NumLit">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.NumLit" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.NumLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.NumLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a numeric literal.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___ScientificLit">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.ScientificLit" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.ScientificLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.ScientificLit : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents a scientific numeric literal that may have decimal and exponential parts.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Syntax___HygieneInfo">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Syntax.HygieneInfo" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Syntax.HygieneInfo : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Syntax.HygieneInfo : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Syntax that represents macro hygiene info.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="typed-syntax-helpers">
                19.4.9.Â Helpers for Typed Syntax<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=typed-syntax-helpers" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                For literals, Lean's parser produces a singleton node that contains an <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.atom" data-verso-hover="4712">atom</span></a></code>.
The inner atom contains a string with source information, while the node's kind specifies how the atom is to be interpreted.
This may involve decoding string escape sequences or interpreting base-16 numeric literals.
The helpers in this section perform the correct interpretation.</p>
              <div class="namedocs" id="Lean___TSyntax___getId">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax.getId" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax.getId (<span class="var token" data-binding="var-_uniq.2539" data-verso-hover="4761">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Ident"><span class="const token" data-binding="const-Lean.Syntax.Ident" data-verso-hover="1973">Lean.Ident</span></a>) : <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span></div><div class="narrow-only">Lean.TSyntax.getId (<span class="var token" data-binding="var-_uniq.2539" data-verso-hover="4761">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Ident"><span class="const token" data-binding="const-Lean.Syntax.Ident" data-verso-hover="1973">Lean.Ident</span></a>) :
  <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span></div></pre><div class="text">
                  <p>
                    Extracts the parsed name from the syntax of an identifier.</p>
                  <p>
                    Returns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Name.anonymous</span></code> if the syntax is malformed.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___TSyntax___getName">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax.getName" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax.getName (<span class="var token" data-binding="var-_uniq.2542" data-verso-hover="4762">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___NameLit"><span class="const token" data-binding="const-Lean.Syntax.NameLit" data-verso-hover="4763">Lean.NameLit</span></a>) : <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span></div><div class="narrow-only">Lean.TSyntax.getName (<span class="var token" data-binding="var-_uniq.2542" data-verso-hover="4762">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___NameLit"><span class="const token" data-binding="const-Lean.Syntax.NameLit" data-verso-hover="4763">Lean.NameLit</span></a>) :
  <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span></div></pre><div class="text">
                  <p>
                    Decodes a quoted name literal, returning the name.</p>
                  <p>
                    Returns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Name.anonymous" data-verso-hover="4764">Lean.Name.anonymous</span></code> if the syntax is malformed.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___TSyntax___getNat">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax.getNat" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax.getNat (<span class="var token" data-binding="var-_uniq.2566" data-verso-hover="4765">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___NumLit"><span class="const token" data-binding="const-Lean.Syntax.NumLit" data-verso-hover="4766">Lean.NumLit</span></a>) : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only">Lean.TSyntax.getNat (<span class="var token" data-binding="var-_uniq.2566" data-verso-hover="4765">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___NumLit"><span class="const token" data-binding="const-Lean.Syntax.NumLit" data-verso-hover="4766">Lean.NumLit</span></a>) :
  <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                  <p>
                    Interprets a numeric literal as a natural number.</p>
                  <p>
                    Returns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span></code> if the syntax is malformed.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___TSyntax___getScientific">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax.getScientific" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax.getScientific (<span class="var token" data-binding="var-_uniq.5962" data-verso-hover="4767">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___ScientificLit"><span class="const token" data-binding="const-Lean.Syntax.ScientificLit" data-verso-hover="4768">Lean.ScientificLit</span></a>) : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> Ã— </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> Ã— </span></a><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only">Lean.TSyntax.getScientific
  (<span class="var token" data-binding="var-_uniq.5962" data-verso-hover="4767">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___ScientificLit"><span class="const token" data-binding="const-Lean.Syntax.ScientificLit" data-verso-hover="4768">Lean.ScientificLit</span></a>) :
  <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> Ã— </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> Ã— </span></a><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                  <p>
                    Extracts the components of a scientific numeric literal.</p>
                  <p>
                    Returns a triple <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2582" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2598" data-verso-hover="154">sign</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2614" data-verso-hover="7">e</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">Ã—</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a> <span class="unknown token" data-binding="">Ã—</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>; the number's value is given by:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.3314" data-verso-hover="204">sign</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.3993" data-verso-hover="4769">n</span> <span class="unknown token" data-binding="">*</span> <span class="typed token" data-binding="" data-verso-hover="7">10</span> <span class="unknown token" data-binding="">^</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="var token" data-binding="var-_uniq.4709" data-verso-hover="335">e</span><span class="unknown token" data-binding="">)</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="137">else</span></a> <span class="var token" data-binding="var-_uniq.3993" data-verso-hover="4769">n</span> <span class="unknown token" data-binding="">*</span> <span class="typed token" data-binding="" data-verso-hover="7">10</span> <span class="unknown token" data-binding="">^</span> <span class="var token" data-binding="var-_uniq.4709" data-verso-hover="335">e</span></code><p>
                    Returns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span></code> if the syntax is malformed.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___TSyntax___getString">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax.getString" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax.getString (<span class="var token" data-binding="var-_uniq.5965" data-verso-hover="4770">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___StrLit"><span class="const token" data-binding="const-Lean.Syntax.StrLit" data-verso-hover="4771">Lean.StrLit</span></a>) : <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></div><div class="narrow-only">Lean.TSyntax.getString (<span class="var token" data-binding="var-_uniq.5965" data-verso-hover="4770">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___StrLit"><span class="const token" data-binding="const-Lean.Syntax.StrLit" data-verso-hover="4771">Lean.StrLit</span></a>) :
  <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></div></pre><div class="text">
                  <p>
                    Decodes a string literal, removing quotation marks and unescaping escaped characters.</p>
                  <p>
                    Returns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="literal string token" data-binding="" data-verso-hover="325">""</span></code> if the syntax is malformed.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___TSyntax___getChar">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax.getChar" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax.getChar (<span class="var token" data-binding="var-_uniq.6123" data-verso-hover="4772">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___CharLit"><span class="const token" data-binding="const-Lean.Syntax.CharLit" data-verso-hover="4773">Lean.CharLit</span></a>) : <a href="Basic-Types/Characters/#Char___mk"><span class="const token" data-binding="const-Char" data-verso-hover="176">Char</span></a></div><div class="narrow-only">Lean.TSyntax.getChar (<span class="var token" data-binding="var-_uniq.6123" data-verso-hover="4772">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___CharLit"><span class="const token" data-binding="const-Lean.Syntax.CharLit" data-verso-hover="4773">Lean.CharLit</span></a>) :
  <a href="Basic-Types/Characters/#Char___mk"><span class="const token" data-binding="const-Char" data-verso-hover="176">Char</span></a></div></pre><div class="text">
                  <p>
                    Decodes a character literal.</p>
                  <p>
                    Returns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited.default" data-verso-hover="1434">default</span></a> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Characters/#Char___mk"><span class="const token" data-binding="const-Char" data-verso-hover="176">Char</span></a><span class="unknown token" data-binding="">)</span></code> if the syntax is malformed.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___TSyntax___getHygieneInfo">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.TSyntax.getHygieneInfo" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.TSyntax.getHygieneInfo (<span class="var token" data-binding="var-_uniq.6125" data-verso-hover="4774">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___HygieneInfo"><span class="const token" data-binding="const-Lean.Syntax.HygieneInfo" data-verso-hover="4775">Lean.HygieneInfo</span></a>) : <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span></div><div class="narrow-only">Lean.TSyntax.getHygieneInfo
  (<span class="var token" data-binding="var-_uniq.6125" data-verso-hover="4774">s</span> : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___HygieneInfo"><span class="const token" data-binding="const-Lean.Syntax.HygieneInfo" data-verso-hover="4775">Lean.HygieneInfo</span></a>) : <span class="const token" data-binding="const-Lean.Name" data-verso-hover="1482">Lean.Name</span></div></pre><div class="text">
                  <p>
                    Decodes macro hygiene information.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="syntax-categories">
                19.4.10.Â Syntax Categories<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=syntax-categories" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Lean's parser contains a table of <span id="--tech-term-syntax-categories" class="def-technical-term"><em>syntax categories</em></span>, which correspond to nonterminals in a context-free grammar.
Some of the most important categories are terms, commands, universe levels, priorities, precedences, and the categories that represent tokens such as literals.
Typically, each <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-kind">syntax kind</a> corresponds to a category.
New categories can be declared using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.syntaxCat : command</code></code><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntaxCat"><code class="kw">declare_syntax_cat</code></a></span>.</p>
              <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">Declaring Syntactic Categories</span><div class="text">
                  <p>
                    Declares a new syntactic category.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___syntaxCat"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.syntaxCat"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><a href="Definitions/Modifiers#Lean___Parser___Command___docComment"><span class="nonterminal documented" data-kind="Lean.Parser.Command.docComment"><code class="hover-info"><code class="docstring">A `docComment` parses a "documentation comment" like `/-- foo -/`. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.

A `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this
example. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. </code></code>docComment</span></a></span><span class="bnf">?</span>
      </span><span class="keyword">declare_syntax_cat</span> <span class="nonterminal" data-kind="ident">ident</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">(</span><span class="keyword">behavior</span> <span class="keyword">:=</span> <span class="bnf">(</span><span class="nonterminal" data-kind="Lean.Parser.Command.catBehaviorBoth">catBehaviorBoth</span> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Command.catBehaviorSymbol">catBehaviorSymbol</span><span class="bnf">)</span><span class="keyword">)</span></span><span class="bnf">)?</span></span></span></pre></div>
                </div>
              <p>
                The leading identifier behavior is an advanced feature that usually does not need to be modified.
It controls the behavior of the parser when it encounters an identifier, and can sometimes cause the identifier to be treated as a non-reserved keyword instead.
This is used to avoid turning the name of every <a href="Tactic-Proofs/#tactics">tactic</a> into a reserved keyword.</p>
              <div class="namedocs" id="Lean___Parser___LeadingIdentBehavior___default">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Parser.LeadingIdentBehavior.default" title="Permalink">ðŸ”—</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only">Lean.Parser.LeadingIdentBehavior : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Parser.LeadingIdentBehavior : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Specifies how the parsing table lookup function behaves for identifiers.</p>
                  <p>
                    The function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Parser.prattParser" data-verso-hover="4776">Lean.Parser.prattParser</span></code> uses two tables: one each for leading and trailing parsers.
These tables map tokens to parsers. Because keyword tokens are distinct from identifier tokens,
keywords and identifiers cannot be confused, even when they are syntactically identical.
Specifying an alternative leading identifier behavior allows greater flexiblity and makes it
possible to avoid reserved keywords in some situations.</p>
                  <p>
                    When the leading token is syntactically an identifier, the current syntax category's
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LeadingIdentBehavior</span></code> specifies how the parsing table lookup function behaves, and allows
controlled â€œpunningâ€ between identifiers and keywords. This feature is used to avoid creating a
reserved symbol for each built-in tactic (e.g., <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="689">apply</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1025">assumption</span></a></code>). As a result, tactic names
can be used as identifiers.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">default : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___LeadingIdentBehavior___default"><span class="const token" data-binding="const-Lean.Parser.LeadingIdentBehavior" data-verso-hover="4777">Lean.Parser.LeadingIdentBehavior</span></a></pre><div class="docs">
                      <p>
                        If the leading token is an identifier, then the parser just executes the parsers associated
with the auxiliary token â€œidentâ€, which parses identifiers.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">symbol : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___LeadingIdentBehavior___default"><span class="const token" data-binding="const-Lean.Parser.LeadingIdentBehavior" data-verso-hover="4777">Lean.Parser.LeadingIdentBehavior</span></a></pre><div class="docs">
                      <p>
                        If the leading token is an identifier <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">foo</span><span class="unknown token" data-binding="">&gt;</span></code>, and there are parsers <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">P</span></code> associated with the token
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">foo</span><span class="unknown token" data-binding="">&gt;</span></code>, then the parser executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">P</span></code>. Otherwise, it executes only the parsers associated with the
auxiliary token â€œidentâ€, which parses identifiers.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">both : <a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___LeadingIdentBehavior___default"><span class="const token" data-binding="const-Lean.Parser.LeadingIdentBehavior" data-verso-hover="4777">Lean.Parser.LeadingIdentBehavior</span></a></pre><div class="docs">
                      <p>
                        If the leading token is an identifier <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">foo</span><span class="unknown token" data-binding="">&gt;</span></code>, then it executes the parsers associated with token
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">foo</span><span class="unknown token" data-binding="">&gt;</span></code> and parsers associated with the auxiliary token â€œidentâ€, which parses identifiers.</p>
                      </div>
                    </div>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="syntax-rules">
                19.4.11.Â Syntax Rules<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=syntax-rules" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Each <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-categories">syntax category</a> is associated with a set of <span id="--tech-term-syntax-rules" class="def-technical-term"><em>syntax rules</em></span>, which correspond to productions in a context-free grammar.
Syntax rules can be defined using the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.syntax : command</code></code><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><code class="kw">syntax</code></a></span> command.</p>
              <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">Syntax Rules</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___syntax"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.syntax"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><a href="Definitions/Modifiers#Lean___Parser___Command___docComment"><span class="nonterminal documented" data-kind="Lean.Parser.Command.docComment"><code class="hover-info"><code class="docstring">A `docComment` parses a "documentation comment" like `/-- foo -/`. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.

A `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this
example. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. </code></code>docComment</span></a></span><span class="bnf">?</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><a href="Attributes#Lean___Parser___Term___attributes-next"><span class="nonterminal" data-kind="Lean.Parser.Term.attributes">attributes</span></a></span><span class="bnf">?</span>
      </span><span class="nonterminal documented" data-kind="Lean.Parser.Term.attrKind"><code class="hover-info"><code class="docstring">`attrKind` matches `("scoped" &lt;|&gt; "local")?`, used before an attribute like `@[local simp]`. </code></code>attrKind</span>
      <span class="keyword">syntax</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.precedence"><span class="keyword">:</span><span class="nonterminal" data-kind="prec.pseudo">prec</span></span></span><span class="bnf">)?</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.namedName"><span class="keyword">(</span><span class="keyword">name</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="ident">ident</span><span class="keyword">)</span></span></span><span class="bnf">)?</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.namedPrio"><span class="keyword">(</span><span class="keyword">priority</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="prio.pseudo">prio</span><span class="keyword">)</span></span></span><span class="bnf">)?</span> </span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal documented" data-kind="Â«stx_*Â»"><code class="hover-info"><code class="docstring">`p*` is shorthand for `many(p)`. It uses parser `p` 0 or more times, and produces a
`nullNode` containing the array of parsed results. This parser has arity 1.

If `p` has arity more than 1, it is auto-grouped in the items generated by the parser.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span><a href="Notations-and-Macros/Defining-New-Syntax/#_FLQQ_stx_____FLQQ_"><span class="keyword">*</span></a> </span></span><span class="keyword">:</span> <span class="nonterminal" data-kind="ident">ident</span></span></pre></div>
                </div>
              <p>
                As with operator and notation declarations, the contents of the documentation comments are shown to users while they interact with the new syntax.
Attributes may be added to invoke compile-time metaprograms on the resulting definition.</p>
              <p>
                Syntax rules interact with <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-section-scope">section scopes</a> in the same manner as attributes, operators, and notations.
By default, syntax rules are available to the parser in any module that transitively imports the one in which they are established, but they may be declared <code>scoped</code> or <code>local</code> to restrict their availability either to contexts in which the current namespace has been opened or to the current <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-section-scope">section scope</a>, respectively.</p>
              <p>
                When multiple syntax rules for a category can match the current input, the <a class="technical-term" href="Notations-and-Macros/Custom-Operators/#--tech-term-local-longest-match-rule">local longest-match rule</a> is used to select one of them.
Like notations and operators, if there is a tie for the longest match then the declared priorities are used to determine which parse result applies.
If this still does not resolve the ambiguity, then all the results that tied are saved.
The elaborator is expected to attempt all of them, succeeding when exactly one can be elaborated.</p>
              <p>
                The syntax rule's precedence, written immediately after the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.syntax : command</code></code><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><code class="kw">syntax</code></a></span> keyword, restricts the parser to use this new syntax only when the precedence context is at least the provided value.

Just as with operators and notations, syntax rules may be manually provided with a name; if they are not, an otherwise-unused name is generated.
Whether provided or generated, this name is used as the syntax kind in the resulting <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="4711">node</span></a></code>.</p>
              <p>
                The body of a syntax declaration is even more flexible than that of a notation.
String literals specify atoms to match.
Subterms may be drawn from any syntax category, rather than just terms, and they may be optional or repeated, with or without interleaved comma separators.
Identifiers in syntax rules indicate syntax categories, rather than naming subterms as they do in notations.</p>
              <p>
                Finally, the syntax rule specifies which syntax category it extends.
It is an error to declare a syntax rule in a nonexistent category.</p>
              <div class="namedocs" id="stx">
                <span class="label">syntax</span><span class="title">Syntax Specifiers</span><div class="text">
                  <p>
                    The syntactic category <code>stx</code> is the grammar of specifiers that may occur in the body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.syntax : command</code></code><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><code class="kw">syntax</code></a></span> command.</p>
                  <p>
                    String literals are parsed as <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-Atoms">atoms</a> (including both keywords such as <code>if</code>, <code>#eval</code>, or <code>where</code>):</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___atom"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span>
    <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.atom"><span class="nonterminal" data-kind="str">str</span></span></pre><p>
                    Leading and trailing spaces in the strings do not affect parsing, but they cause Lean to insert spaces in the corresponding position when displaying the syntax in <a class="technical-term" href="Tactic-Proofs/#--tech-term-proof-state">proof states</a> and error messages.
Ordinarily, valid identifiers occurring as atoms in syntax rules become reserved keywords.
Preceding a string literal with an ampersand (<code>&</code>) suppresses this behavior:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___nonReserved"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.nonReserved"><span class="keyword">&</span><span class="nonterminal" data-kind="str">str</span></span></pre><p>
                    Identifiers specify the syntactic category expected in a given position, and may optionally provide a precedence:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___cat"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.cat"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.precedence"><span class="keyword">:</span><span class="nonterminal" data-kind="prec.pseudo">prec</span></span></span><span class="bnf">)?</span></span></span></pre><p>
                    The <code>*</code> modifier is the Kleene star, matching zero or more repetitions of the preceding syntax.
It can also be written using <code>many</code>.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_stx_____FLQQ_"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Â«stx_*Â»"><code class="hover-info"><code class="docstring">`p*` is shorthand for `many(p)`. It uses parser `p` 0 or more times, and produces a
`nullNode` containing the array of parsed results. This parser has arity 1.

If `p` has arity more than 1, it is auto-grouped in the items generated by the parser.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">*</span></span></pre><p>
                    The <code>+</code> modifier matches one or more repetitions of the preceding syntax.
It can also be written using <code>many1</code>.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_stx_____FLQQ_-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Â«stx_+Â»"><code class="hover-info"><code class="docstring">`p+` is shorthand for `many1(p)`. It uses parser `p` 1 or more times, and produces a
`nullNode` containing the array of parsed results. This parser has arity 1.

If `p` has arity more than 1, it is auto-grouped in the items generated by the parser.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">+</span></span></pre><p>
                    The <code>?</code> modifier makes a subterm optional, and matches zero or one, but not more, repetitions of the preceding syntax.
It can also be written as <code>optional</code>.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="stx____"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="stx_?"><code class="hover-info"><code class="docstring">`(p)?` is shorthand for `optional(p)`. It uses parser `p` 0 or 1 times, and produces a
`nullNode` containing the array of parsed results. This parser has arity 1.

`p` is allowed to have arity n &gt; 1 (in which case the node will have either 0 or n children),
but if it has arity 0 then the result will be ambiguous.

Because `?` is an identifier character, `ident?` will not work as intended.
You have to write either `ident ?` or `(ident)?` for it to parse as the `?` combinator
applied to the `ident` parser.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">?</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___unary"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.unary"><span class="literal-ident">optional</span><span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">)</span></span></pre><p>
                    The <code>,*</code> modifier matches zero or more repetitions of the preceding syntax with interleaved commas.
It can also be written using <code>sepBy</code>.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_stx________FLQQ_"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Â«stx_,*Â»"><code class="hover-info"><code class="docstring">`p,*` is shorthand for `sepBy(p, ",")`. It parses 0 or more occurrences of
`p` separated by `,`, that is: `empty | p | p,p | p,p,p | ...`.

It produces a `nullNode` containing a `SepArray` with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">,*</span></span></pre><p>
                    The <code>,+</code> modifier matches one or more repetitions of the preceding syntax with interleaved commas.
It can also be written using <code>sepBy1</code>.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_stx________FLQQ_-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Â«stx_,+Â»"><code class="hover-info"><code class="docstring">`p,+` is shorthand for `sepBy(p, ",")`. It parses 1 or more occurrences of
`p` separated by `,`, that is: `p | p,p | p,p,p | ...`.

It produces a `nullNode` containing a `SepArray` with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">,+</span></span></pre><p>
                    The <code>,*,?</code> modifier matches zero or more repetitions of the preceding syntax with interleaved commas, allowing an optional trailing comma after the final repetition.
It can also be written using <code>sepBy</code> with the <code>allowTrailingSep</code> modifier.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_stx______________FLQQ_"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Â«stx_,*,?Â»"><code class="hover-info"><code class="docstring">`p,*,?` is shorthand for `sepBy(p, ",", allowTrailingSep)`.
It parses 0 or more occurrences of `p` separated by `,`, possibly including
a trailing `,`, that is: `empty | p | p, | p,p | p,p, | p,p,p | ...`.

It produces a `nullNode` containing a `SepArray` with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">,*,?</span></span></pre><p>
                    The <code>,+,?</code> modifier matches one or more repetitions of the preceding syntax with interleaved commas, allowing an optional trailing comma after the final repetition.
It can also be written using <code>sepBy1</code> with the <code>allowTrailingSep</code> modifier.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_stx______________FLQQ_-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Â«stx_,+,?Â»"><code class="hover-info"><code class="docstring">`p,+,?` is shorthand for `sepBy1(p, ",", allowTrailingSep)`.
It parses 1 or more occurrences of `p` separated by `,`, possibly including
a trailing `,`, that is: `p | p, | p,p | p,p, | p,p,p | ...`.

It produces a `nullNode` containing a `SepArray` with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">,+,?</span></span></pre><p>
                    The <code>&lt;|&gt;</code> operator, which can be written <code>orelse</code>, matches either syntax.
However, if the first branch consumes any tokens, then it is committed to, and failures will not be backtracked:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_stx__LT_____GT___FLQQ_"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Â«stx_<|>_Â»"><code class="hover-info"><code class="docstring">`p1 &lt;|&gt; p2` is shorthand for `orelse(p1, p2)`, and parses either `p1` or `p2`.
It does not backtrack, meaning that if `p1` consumes at least one token then
`p2` will not be tried. Therefore, the parsers should all differ in their first
token. The `atomic(p)` parser combinator can be used to locally backtrack a parser.
(For full backtracking, consider using extensible syntax classes instead.)

On success, if the inner parser does not generate exactly one node, it will be
automatically wrapped in a `group` node, so the result will always be arity 1.

The `&lt;|&gt;` combinator does not generate a node of its own, and in particular
does not tag the inner parsers to distinguish them, which can present a problem
when reconstructing the parse. A well formed `&lt;|&gt;` parser should use disjoint
node kinds for `p1` and `p2`.
</code></code><span class="nonterminal" data-kind="stx.pseudo">stx</span> <span class="keyword">&lt;|&gt;</span> <span class="nonterminal" data-kind="stx.pseudo">stx</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___binary"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.binary"><span class="literal-ident">orelse</span><span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">,</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">)</span></span></pre><p>
                    The <code>!</code> operator matches the complement of its argument.
If its argument fails, then it succeeds, resetting the parsing state.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="stx____-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="stx!_"><code class="hover-info"><code class="docstring">`!p` parses the negation of `p`. That is, it fails if `p` succeeds, and
otherwise parses nothing. It has arity 0.
</code></code><span class="keyword">!</span> <span class="nonterminal" data-kind="stx.pseudo">stx</span></span></pre><p>
                    Syntax specifiers may be grouped using parentheses.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___paren"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.paren"><span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">)</span></span></pre><p>
                    Repetitions may be defined using <code>many</code> and <code>many1</code>.
The latter requires at least one instance of the repeated syntax.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___unary-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.unary"><span class="literal-ident">many</span><span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">)</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___unary-next-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.unary"><span class="literal-ident">many1</span><span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">)</span></span></pre><p>
                    Repetitions with separators may be defined using <code>sepBy</code> and <code>sepBy1</code>, which respectively match zero or more occurrences and one or more occurrences, separated by some other syntax.
They come in three varieties:</p>
                  <ul>
                    <li>
                      <p>
                        The two-parameter version uses the atom provided in the string literal to parse the separators, and does not allow trailing separators.</p>
                      </li>
                    <li>
                      <p>
                        The three-parameter version uses the third parameter to parse the separators, using the atom for pretty-printing.</p>
                      </li>
                    <li>
                      <p>
                        The four-parameter version optionally allows the separator to occur an extra time at the end of the sequence.
    The fourth argument must always literally be the keyword <code>allowTrailingSep</code>.</p>
                      </li>
                    </ul>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___sepBy"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.sepBy"><span class="keyword">sepBy(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">,</span> <span class="nonterminal" data-kind="str">str</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">)</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___sepBy-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.sepBy"><span class="keyword">sepBy(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">,</span> <span class="nonterminal" data-kind="str">str</span><span class="from-nonterminal" data-kind="null"><span class="keyword">,</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">)</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___sepBy-next-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.sepBy"><span class="keyword">sepBy(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">,</span> <span class="nonterminal" data-kind="str">str</span><span class="from-nonterminal" data-kind="null"><span class="keyword">,</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span></span><span class="from-nonterminal" data-kind="null"><span class="keyword">,</span> <span class="keyword">allowTrailingSep</span></span><span class="keyword">)</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___sepBy1"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.sepBy1"><span class="keyword">sepBy1(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">,</span> <span class="nonterminal" data-kind="str">str</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">)</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___sepBy1-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.sepBy1"><span class="keyword">sepBy1(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">,</span> <span class="nonterminal" data-kind="str">str</span><span class="from-nonterminal" data-kind="null"><span class="keyword">,</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">)</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Syntax___sepBy1-next-next"><span class="nonterminal" data-kind="stx">stx</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Syntax.sepBy1"><span class="keyword">sepBy1(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span><span class="keyword">,</span> <span class="nonterminal" data-kind="str">str</span><span class="from-nonterminal" data-kind="null"><span class="keyword">,</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="stx.pseudo">stx</span></span></span><span class="from-nonterminal" data-kind="null"><span class="keyword">,</span> <span class="keyword">allowTrailingSep</span></span><span class="keyword">)</span></span></pre></div>
                </div>
              <details class="example"><summary class="description">Parsing Matched Parentheses and Brackets</summary><div class="example-content">
                  <p>
                    A language that consists of matched parentheses and brackets can be defined using syntax rules.
The first step is to declare a new <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-categories">syntax category</a>:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntaxCat"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntaxCat-24578">declare_syntax_cat</span></a> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Next, rules can be added for parentheses and square brackets.
To rule out empty strings, the base cases consist of empty pairs.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-24746">syntax</span></a> <span class="literal string token" data-binding="" data-verso-hover="4779">"("</span> <span class="literal string token" data-binding="" data-verso-hover="4780">")"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span>
<a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-24772">syntax</span></a> <span class="literal string token" data-binding="" data-verso-hover="4781">"["</span> <span class="literal string token" data-binding="" data-verso-hover="4782">"]"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span>
<a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-24798">syntax</span></a> <span class="literal string token" data-binding="" data-verso-hover="4779">"("</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span> <span class="literal string token" data-binding="" data-verso-hover="4780">")"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span>
<a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-24833">syntax</span></a> <span class="literal string token" data-binding="" data-verso-hover="4781">"["</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span> <span class="literal string token" data-binding="" data-verso-hover="4782">"]"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span>
<a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-24868">syntax</span></a> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span>
<span class="unknown token" data-binding=""></span></code><p>
                    In order to invoke Lean's parser on these rules, there must also be an embedding from the new syntax category into one that may already be parsed:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-25064">syntax</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedName-25071">name</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-termBalanced" data-verso-hover="4783">termBalanced</span><span class="unknown token" data-binding="">)</span> <span class="literal string token" data-binding="" data-verso-hover="4784">"balanced "</span> <span class="const token" data-binding="const-Lean.Parser.Category.balanced" data-verso-hover="4778">balanced</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="4785">term</span>
<span class="unknown token" data-binding=""></span></code><p>
                    These terms cannot be elaborated, but reaching an elaboration error indicates that parsing succeeded:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="doc-comment token" data-binding="">/--
error: elaboration function for 'termBalanced' has not been implemented
  balanced ()
-/</span>
<a href="Interacting-with-Lean/#Lean___guardMsgsCmd"><span class="keyword token" data-binding="kw-occ-Lean.guardMsgsCmd-25237" data-verso-hover="126">#guard_msgs</span></a> <a href="Interacting-with-Lean/#Lean___guardMsgsCmd"><span class="keyword token" data-binding="kw-occ-Lean.guardMsgsCmd-25237" data-verso-hover="126">in</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-25345">example</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termBalanced-25356">balanced</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span>

<span class="doc-comment token" data-binding="">/--
error: elaboration function for 'termBalanced' has not been implemented
  balanced []
-/</span>
<a href="Interacting-with-Lean/#Lean___guardMsgsCmd"><span class="keyword token" data-binding="kw-occ-Lean.guardMsgsCmd-25369" data-verso-hover="126">#guard_msgs</span></a> <a href="Interacting-with-Lean/#Lean___guardMsgsCmd"><span class="keyword token" data-binding="kw-occ-Lean.guardMsgsCmd-25369" data-verso-hover="126">in</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-25477">example</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termBalanced-25488">balanced</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>

<span class="doc-comment token" data-binding="">/--
error: elaboration function for 'termBalanced' has not been implemented
  balanced [[]()([])]
-/</span>
<a href="Interacting-with-Lean/#Lean___guardMsgsCmd"><span class="keyword token" data-binding="kw-occ-Lean.guardMsgsCmd-25501" data-verso-hover="126">#guard_msgs</span></a> <a href="Interacting-with-Lean/#Lean___guardMsgsCmd"><span class="keyword token" data-binding="kw-occ-Lean.guardMsgsCmd-25501" data-verso-hover="126">in</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-25617">example</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termBalanced-25628">balanced</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Similarly, parsing fails when they are mismatched:</p>
                  <pre class="syntax-error hl lean"><code class="line">example := balanced [() (<span class="parse-message has-info error"><code class="hover-info">unexpected token ']'; expected ')' or balanced</code>]</span>]</code></pre><div class="error">
                    <pre>&lt;example&gt;:1:25-1:26: unexpected token ']'; expected ')' or balanced</pre></div>
                  </div>
                </details><details class="example"><summary class="description">Parsing Comma-Separated Repetitions</summary><div class="example-content">
                  <p>
                    A variant of list literals that requires double square brackets and allows a trailing comma can be added with the following syntax:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-26068">syntax</span></a> <span class="literal string token" data-binding="" data-verso-hover="4786">"[["</span> <span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="4785">term</span><span class="unknown token" data-binding="">,*,?</span> <span class="literal string token" data-binding="" data-verso-hover="4787">"]]"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="4785">term</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Adding a <span id="--tech-term-macro" class="def-technical-term">macro</span> that describes how to translate it into an ordinary list literal allows it to be used in tests.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-26236">macro_rules</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">`(</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="4785">term</span><span class="unknown token" data-binding="">|</span><span class="unknown token" data-binding="">[[</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.53" data-verso-hover="4788">e</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-26263">term</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.53" data-verso-hover="4788">e</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">["Dandelion", "Thistle"]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-26322" data-verso-hover="6">#eval</span></a></span> <span class="unknown token" data-binding="">[[</span><span class="literal string token" data-binding="" data-verso-hover="4789">"Dandelion"</span><span class="unknown token" data-binding="">,</span> <span class="literal string token" data-binding="" data-verso-hover="4790">"Thistle"</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">]]</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>["Dandelion", "Thistle"]
</pre></div>
                  </div>
                </details></section>
            <section>
              <h2 id="syntax-indentation">
                19.4.12.Â Indentation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=syntax-indentation" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Internally, the parser maintains a saved source position.
Syntax rules may include instructions that interact with these saved positions, causing parsing to fail when a condition is not met.
Indentation-sensitive constructs, such as <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>, save a source position, parse their constituent parts while taking this saved position into account, and then restore the original position.</p>
              <p>
                In particular, Indentation-sensitvity is specified by combining <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Parser.withPosition" data-verso-hover="4791">withPosition</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Parser.withPositionAfterLinebreak" data-verso-hover="4792">withPositionAfterLinebreak</span></code>, which save the source position at the start of parsing some other syntax, with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Parser.checkColGt" data-verso-hover="4793">colGt</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Parser.checkColGe" data-verso-hover="4794">colGe</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Parser.checkColEq" data-verso-hover="4795">colEq</span></code>, which compare the current column with the column from the most recently-saved position.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Parser.checkLineEq" data-verso-hover="4796">lineEq</span></code> can also be used to ensure that two positions are on the same line in the source file.</p>
              <div class="namedocs" id="withPosition">
                <span class="permalink-widget block"><a href="find/?domain=Manual.parserAlias&name=withPosition" title="Permalink">ðŸ”—</a></span><span class="label">parser alias</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="4797">withPosition</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="unknown token" data-binding="">)</span></pre><div class="text">
                  <p>
                    Arity is sum of arguments' arities</p>
                  <p>
                    <code>withPosition(p)</code> runs <code>p</code> while setting the "saved position" to the current position.
This has no effect on its own, but various other parsers access this position to achieve some
composite effect:</p>
                  <ul>
                    <li>
                      <p>
                        <code>colGt</code>, <code>colGe</code>, <code>colEq</code> compare the column of the saved position to the current position,
used to implement Python-style indentation sensitive blocks</p>
                      </li>
                    <li>
                      <p>
                        <code>lineEq</code> ensures that the current position is still on the same line as the saved position,
used to implement composite tokens</p>
                      </li>
                    </ul>
                  <p>
                    The saved position is only available in the read-only state, which is why this is a scoping parser:
after the <code>withPosition(..)</code> block the saved position will be restored to its original value.</p>
                  <p>
                    This parser has the same arity as <code>p</code> - it just forwards the results of <code>p</code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="withoutPosition">
                <span class="permalink-widget block"><a href="find/?domain=Manual.parserAlias&name=withoutPosition" title="Permalink">ðŸ”—</a></span><span class="label">parser alias</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="4798">withoutPosition</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="unknown token" data-binding="">)</span></pre><div class="text">
                  <p>
                    Arity is sum of arguments' arities</p>
                  <p>
                    <code>withoutPosition(p)</code> runs <code>p</code> without the saved position, meaning that position-checking
parsers like <code>colGt</code> will have no effect. This is usually used by bracketing constructs like
<code>(...)</code> so that the user can locally override whitespace sensitivity.</p>
                  <p>
                    This parser has the same arity as <code>p</code> - it just forwards the results of <code>p</code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="withPositionAfterLinebreak">
                <span class="permalink-widget block"><a href="find/?domain=Manual.parserAlias&name=withPositionAfterLinebreak" title="Permalink">ðŸ”—</a></span><span class="label">parser alias</span><pre class="signature hl lean block"><span class="keyword token" data-binding="">withPositionAfterLinebreak</span></pre><div class="text">
                  <ul>
                    <li>
                      Arity: 1</li>
                    <li>
                      Automatically wraps arguments in a <code>null</code> node unless there's exactly one</li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="colGt">
                <span class="permalink-widget block"><a href="find/?domain=Manual.parserAlias&name=colGt" title="Permalink">ðŸ”—</a></span><span class="label">parser alias</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="4799">colGt</span></pre><div class="text">
                  <ul>
                    <li>
                      Arity: 0</li>
                    <li>
                      Automatically wraps arguments in a <code>null</code> node unless there's exactly one</li>
                    </ul>
                  <p>
                    The <code>colGt</code> parser requires that the next token starts a strictly greater column than the saved
position (see <code>withPosition</code>). This can be used for whitespace sensitive syntax for the arguments
to a tactic, to ensure that the following tactic is not interpreted as an argument.</p>
                  <pre>example (x : False) : False := by
  revert x
  exact id
</pre><p>
                    Here, the <code>revert</code> tactic is followed by a list of <code>colGt ident</code>, because otherwise it would
interpret <code>exact</code> as an identifier and try to revert a variable named <code>exact</code>.</p>
                  <p>
                    This parser has arity 0 - it does not capture anything.</p>
                  </div>
                </div>
              <div class="namedocs" id="colGe">
                <span class="permalink-widget block"><a href="find/?domain=Manual.parserAlias&name=colGe" title="Permalink">ðŸ”—</a></span><span class="label">parser alias</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="4800">colGe</span></pre><div class="text">
                  <ul>
                    <li>
                      Arity: 0</li>
                    <li>
                      Automatically wraps arguments in a <code>null</code> node unless there's exactly one</li>
                    </ul>
                  <p>
                    The <code>colGe</code> parser requires that the next token starts from at least the column of the saved
position (see <code>withPosition</code>), but allows it to be more indented.
This can be used for whitespace sensitive syntax to ensure that a block does not go outside a
certain indentation scope. For example it is used in the lean grammar for <code>else if</code>, to ensure
that the <code>else</code> is not less indented than the <code>if</code> it matches with.</p>
                  <p>
                    This parser has arity 0 - it does not capture anything.</p>
                  </div>
                </div>
              <div class="namedocs" id="colEq">
                <span class="permalink-widget block"><a href="find/?domain=Manual.parserAlias&name=colEq" title="Permalink">ðŸ”—</a></span><span class="label">parser alias</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="4801">colEq</span></pre><div class="text">
                  <ul>
                    <li>
                      Arity: 0</li>
                    <li>
                      Automatically wraps arguments in a <code>null</code> node unless there's exactly one</li>
                    </ul>
                  <p>
                    The <code>colEq</code> parser ensures that the next token starts at exactly the column of the saved
position (see <code>withPosition</code>). This can be used to do whitespace sensitive syntax like
a <code>by</code> block or <code>do</code> block, where all the lines have to line up.</p>
                  <p>
                    This parser has arity 0 - it does not capture anything.</p>
                  </div>
                </div>
              <div class="namedocs" id="lineEq">
                <span class="permalink-widget block"><a href="find/?domain=Manual.parserAlias&name=lineEq" title="Permalink">ðŸ”—</a></span><span class="label">parser alias</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="4802">lineEq</span></pre><div class="text">
                  <ul>
                    <li>
                      Arity: 0</li>
                    <li>
                      Automatically wraps arguments in a <code>null</code> node unless there's exactly one</li>
                    </ul>
                  <p>
                    The <code>lineEq</code> parser requires that the current token is on the same line as the saved position
(see <code>withPosition</code>). This can be used to ensure that composite tokens are not "broken up" across
different lines. For example, <code>else if</code> is parsed using <code>lineEq</code> to ensure that the two tokens
are on the same line.</p>
                  <p>
                    This parser has arity 0 - it does not capture anything.</p>
                  </div>
                </div>
              <details class="example"><summary class="description">Aligned Columns</summary><div class="example-content">
                  <p>
                    This syntax for saving notes takes a bulleted list of items, each of which must be aligned at the same column.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-27871">syntax</span></a> <span class="literal string token" data-binding="" data-verso-hover="4803">"note "</span> <span class="const token" data-binding="const-Lean.Parser.ppLine" data-verso-hover="4804">ppLine</span> <span class="const token" data-binding="const-Lean.Parser.withPosition" data-verso-hover="4791">withPosition</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Parser.checkColEq" data-verso-hover="4795">colEq</span> <span class="literal string token" data-binding="" data-verso-hover="4805">"â€¢ "</span> <span class="const token" data-binding="const-Lean.Parser.strLit" data-verso-hover="4806">str</span> <span class="const token" data-binding="const-Lean.Parser.ppLine" data-verso-hover="4804">ppLine</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="4785">term</span>
<span class="unknown token" data-binding=""></span></code><p>
                    There is no elaborator or macro associated with this syntax, but the following example is accepted by the parser:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-28102">#check</span></a>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">elaboration function for 'Â«termNote__â€¢__Â»' has not been implemented
  note
    â€¢ "One"
    â€¢ "Two"
    </code></span></span><span class="keyword token" data-binding="kw-occ-Â«termNote__â€¢__Â»-28111">note</span></span>
    <span class="unknown token" data-binding="">â€¢</span> <span class="literal string token" data-binding="" data-verso-hover="4807">"One"</span>
    <span class="unknown token" data-binding="">â€¢</span> <span class="literal string token" data-binding="" data-verso-hover="4808">"Two"</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>elaboration function for 'Â«termNote__â€¢__Â»' has not been implemented
  note
    â€¢ "One"
    â€¢ "Two"
    
</pre></div>
                  <p>
                    The syntax does not require that the list is indented with respect to the opening token, which would require an extra <code>withPosition</code> and a <code>colGt</code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-28473">#check</span></a>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">elaboration function for 'Â«termNote__â€¢__Â»' has not been implemented
  note
    â€¢ "One"
    â€¢ "Two"
    </code></span></span><span class="keyword token" data-binding="kw-occ-Â«termNote__â€¢__Â»-28482">note</span></span>
<span class="unknown token" data-binding="">â€¢</span> <span class="literal string token" data-binding="" data-verso-hover="4807">"One"</span>
<span class="unknown token" data-binding="">â€¢</span> <span class="literal string token" data-binding="" data-verso-hover="4808">"Two"</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>elaboration function for 'Â«termNote__â€¢__Â»' has not been implemented
  note
    â€¢ "One"
    â€¢ "Two"
    
</pre></div>
                  <p>
                    The following examples are not syntactically valid because the columns of the bullet points do not match.</p>
                  <pre class="syntax-error hl lean"><code class="line">#check</code><code class="line">  note</code><code class="line">    â€¢ "One"</code><code class="line">   <span class="parse-message has-info error"><code class="hover-info">expected end of input</code>â€¢</span> "Two"</code></pre><div class="error">
                    <pre>&lt;example&gt;:4:3-4:4: expected end of input</pre></div>
                  <pre class="syntax-error hl lean"><code class="line">#check</code><code class="line">  note</code><code class="line">   â€¢ "One"</code><code class="line">     <span class="parse-message has-info error"><code class="hover-info">expected end of input</code>â€¢</span> "Two"</code></pre><div class="error">
                    <pre>&lt;example&gt;:4:5-4:6: expected end of input</pre></div>
                  </div>
                </details></section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Notations-and-Macros/Notations/#notations" rel="prev" title="19.3. Notations"><span class="arrow">â†</span><span class="where">19.3. Notations</span></a><a class="local-button active" href="Notations-and-Macros/Macros/#macros" rel="next" title="19.5. Macros"><span class="where">19.5. Macros</span><span class="arrow">â†’</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

