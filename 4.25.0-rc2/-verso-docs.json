{"999":
 "<code>map.{u, v} {α : Type u} {β : Type v} (f : α → β) (xs : List α) : List β</code>",
 "998": "<code>mustBeEqual (n k : Nat) : n = k → String</code>",
 "997": "<code>add (n k : Nat) : Nat</code>",
 "996":
 "<code>p_all {p : Nat → Prop} (pZero : p 0) (pStep : ∀ (n : Nat), p n → p (n + 1)) (n : Nat) : p n</code>",
 "995":
 "<code class=\"docstring\">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it\ncan also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in\nwhich case all instance variables that unify with the given type are omitted. `omit` should usually\nonly be used in conjunction with `in` in order to keep the section structure simple.\n</code>",
 "994":
 "<code>p_all {p : Nat → Prop} (pFifteen : p 15) {p✝ : Nat → Prop} (pZero : p✝ 0) (pStep : ∀ (n : Nat), p✝ n → p✝ (n + 1))\n  (n : Nat) : p✝ n</code>",
 "993": "<code>p✝ 15</code>",
 "992":
 "<code class=\"docstring\">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all\ntheorems in the remainder of the current section, differing from the default behavior of\nconditionally including variables based on use in the theorem header. Other commands are\nnot affected. `include` is usually followed by `in theorem ...` to limit the inclusion\nto the subsequent declaration.\n</code>",
 "991": "<code>p n✝</code>",
 "990": "<code>p_all {p : Nat → Prop} (n : Nat) : p n</code>",
 "99":
 "<code>MonadEval.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w}\n  (monadEval : {α : Type u} → m α → n α) : MonadEval m n</code>",
 "989": "<code>p 15</code>",
 "988": "<code>∀ (n : Nat), p n → p (n + 1)</code>",
 "987": "<code>p 0</code>",
 "986": "<code>Nat → Prop</code>",
 "985":
 "<code>addAll.{u} {α : Type u} (xs : List α) [Zero α] [Add α] : α</code>",
 "984":
 "<code>List.foldr.{u, v} {α : Type u} {β : Type v} (f : α → β → β) (init : β) (l : List α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a list from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in reverse order, using `f`.\n\n`O(|l|)`. Replaced at runtime with `List.foldrTR`.\n\nExamples:\n * `[a, b, c].foldr f init  = f a (f b (f c init))`\n * `[1, 2, 3].foldr (toString · ++ ·) \"\" = \"123\"`\n * `[1, 2, 3].foldr (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"`\n</code>",
 "983": "<code>addAll.{u_1, u_2} (lst : List sorry) : sorry</code>",
 "982":
 "<code>Zero.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type with a zero element. </code>",
 "981":
 "<code><span class=\"literal string\">\"delicious\"</span> : String</code>",
 "980": "<code>Dessert.cupcake : String</code>",
 "98": "<code>Type u → Type u_1</code>",
 "979": "<code>Greetings.english : String</code>",
 "978":
 "<code class=\"docstring\">Adds names from other namespaces to the current namespace.\n\nThe command `export Some.Namespace (name₁ name₂)` makes `name₁` and `name₂`:\n\n- visible in the current namespace without prefix `Some.Namespace`, like `open`, and\n- visible from outside the current namespace `N` as `N.name₁` and `N.name₂`.\n\n## Examples\n\n```lean\nnamespace Morning.Sky\n  def star := \"venus\"\nend Morning.Sky\n\nnamespace Evening.Sky\n  export Morning.Sky (star)\n  -- `star` is now in scope\n  #check star\nend Evening.Sky\n\n-- `star` is visible in `Evening.Sky`\n#check Evening.Sky.star\n```\n</code>",
 "977": "<code>Veg.Leafy.cabbage : Leafy</code>",
 "976": "<code>Veg.Leafy.spinach : Leafy</code>",
 "975": "<code>Veg.Leafy.cabbage : Veg.Leafy</code>",
 "974": "<code>Veg.Leafy.spinach : Veg.Leafy</code>",
 "973": "<code>Veg.Leafy : Type</code>",
 "972":
 "<code>MonadState.get.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] : m σ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the current value of the monad's mutable state.\n</code>",
 "971": "<code><span class=\"literal string\">\"pear\"</span> : String</code>",
 "970": "<code>x : String × String</code>",
 "97": "<code>Type u → Type w</code>",
 "969": "<code>NS.three : Nat</code>",
 "968": "<code><span class=\"literal string\">\"}!}\"</span> : String</code>",
 "967": "<code>Lean.TSyntax `term</code>",
 "966": "<code><span class=\"literal string\">\"{!{\"</span> : String</code>",
 "965": "<code>C.a6 : Nat</code>",
 "964": "<code>B.C.a5 : Nat</code>",
 "963": "<code>B.a4 : Nat</code>",
 "962": "<code>A.B.C.a3 : Nat</code>",
 "961": "<code>A.B.a2 : Nat</code>",
 "960": "<code>A.a1 : Nat</code>",
 "96":
 "<code>semiOutParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n</code>",
 "959": "<code><span class=\"literal string\">\"juice\"</span> : String</code>",
 "958": "<code><span class=\"literal string\">\"water\"</span> : String</code>",
 "957": "<code>ColdDrink.toString : ColdDrink → String</code>",
 "956": "<code>HotDrink.toString : HotDrink → String</code>",
 "955": "<code>ColdDrink.juice : ColdDrink</code>",
 "954": "<code>ColdDrink.water : ColdDrink</code>",
 "953": "<code>ColdDrink : Type</code>",
 "952": "<code><span class=\"literal string\">\"cocoa\"</span> : String</code>",
 "951": "<code><span class=\"literal string\">\"tea\"</span> : String</code>",
 "950":
 "<code><span class=\"literal string\">\"coffee\"</span> : String</code>",
 "95": "<code>semiOutParam (Type u → Type v)</code>",
 "949": "<code>HotDrink.ofString? : String → Option HotDrink</code>",
 "948": "<code>HotDrink : Type</code>",
 "947": "<code>HotDrink.cocoa : HotDrink</code>",
 "946": "<code>HotDrink.tea : HotDrink</code>",
 "945": "<code>HotDrink.coffee : HotDrink</code>",
 "944":
 "<code><span class=\"literal string\">\"Ripe lemons are yellow, not green\"</span> : String</code>",
 "943": "<code>_root_.color : String</code>",
 "942": "<code>Forest.nextStatement : String</code>",
 "941":
 "<code><span class=\"literal string\">\"Lemons are green\"</span> : String</code>",
 "940": "<code><span class=\"literal string\">\"green\"</span> : String</code>",
 "94":
 "<code>MonadLift.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Computations in the monad `m` can be run in the monad `n`. These translations are inserted\nautomatically by the compiler.\n\nUsually, `n` consists of some number of monad transformers applied to `m`, but this is not\nmandatory.\n\nNew instances should use this class, `MonadLift`. Clients that require one monad to be liftable into\nanother should instead request `MonadLiftT`, which is the reflexive, transitive closure of\n`MonadLift`.\n</code>",
 "939":
 "<code><span class=\"literal string\">\"yellow\"</span> : String</code>",
 "938": "<code>color : String</code>",
 "937": "<code>Forest.statement : String</code>",
 "936": "<code>Forest.color : String</code>",
 "935":
 "<code>Squash.mk.{u} {α : Sort u} (x : α) : Squash α</code><span class=\"sep\"></span><code class=\"docstring\">Places a value into its squash type, in which it cannot be distinguished from any other.\n</code>",
 "934": "<code>∀ (a : α), motive (Squash.mk a)</code>",
 "933": "<code>Squash α → Prop</code>",
 "932": "<code>Squash α</code>",
 "931":
 "<code>Nonempty.rec.{u} {α : Sort u} {motive : Nonempty α → Prop} (intro : ∀ (val : α), motive ⋯) (t : Nonempty α) : motive t</code>",
 "930":
 "<code>Squash.lift.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} [Subsingleton β] (s : Squash α) (f : α → β) : β</code><span class=\"sep\"></span><code class=\"docstring\">Extracts a squashed value into any subsingleton type.\n\nIf `β` is a subsingleton, a function `α → β` cannot distinguish between elements of `α` and thus\nautomatically respects the universal relation that `Squash` quotients with.\n</code>",
 "93":
 "<code class=\"docstring\">`set_option &lt;id&gt; &lt;value&gt;` sets the option `&lt;id&gt;` to `&lt;value&gt;`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `&lt;id&gt;` to list available options.\n\n`set_option &lt;id&gt; &lt;value&gt; in &lt;command&gt;` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option &lt;id&gt; &lt;value&gt; in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n</code>",
 "929":
 "<code>Nonempty.{u} (α : Sort u) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nonempty α` is a typeclass that says that `α` is not an empty type,\nthat is, there exists an element in the type. It differs from `Inhabited α`\nin that `Nonempty α` is a `Prop`, which means that it does not actually carry\nan element of `α`, only a proof that *there exists* such an element.\nGiven `Nonempty α`, you can construct an element of `α` *nonconstructively*\nusing `Classical.choice`.\n</code>",
 "928":
 "<code>Squash.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">The quotient of `α` by the universal relation. The elements of `Squash α` are those of `α`, but all\nof them are equal and cannot be distinguished.\n\n`Squash α` is a `Subsingleton`: it is empty if `α` is empty, otherwise it has just one element. It\nis the “universal `Subsingleton`” mapped from `α`.\n\n`Nonempty α` also has these properties. It is a proposition, which means that its elements (i.e.\nproofs) are erased from compiled code and represented by a dummy value. `Squash α` is a `Type u`,\nand its representation in compiled code is identical to that of `α`.\n\nConsequently, `Squash.lift` may extract an `α` value into any subsingleton type `β`, while\n`Nonempty.rec` can only do the same when `β` is a proposition.\n</code>",
 "927":
 "<code>congrArg.{u, v} {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function argument: if `a₁ = a₂` then `f a₁ = f a₂` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`&lt;something containing a₁&gt; = &lt;something containing a₂&gt;`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "926": "<code>Quot.mk extEq f = Quot.mk extEq g</code>",
 "925": "<code>(fun x =&gt; f x) = fun x =&gt; g x</code>",
 "924":
 "<code class=\"docstring\">The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n</code>",
 "923": "<code>(x : _fvar.2) → @_fvar.6 x</code>",
 "922": "<code>_fvar.2</code>",
 "921":
 "<code>(fun x =&gt; Quot.lift (fun x_1 =&gt; x_1 x) ⋯ (Quot.mk extEq f)) = fun x =&gt; Quot.lift (fun x_1 =&gt; x_1 x) ⋯ (Quot.mk extEq g)</code>",
 "920":
 "<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n</code>",
 "92": "<code>Quadrant.ne : Quadrant</code>",
 "919": "<code></code>",
 "918": "<code>extApp (Quot.mk extEq f) = extApp (Quot.mk extEq g)</code>",
 "917":
 "<code class=\"docstring\">Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n </code>",
 "916":
 "<code>funext'.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : ∀ (x : α), f x = g x) : f = g</code>",
 "915": "<code>extEq x✝¹ x✝</code>",
 "914":
 "<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>",
 "913": "<code>extEq g g'</code>",
 "912": "<code>ExtFun α β</code>",
 "911":
 "<code>extApp.{u, v} {α : Sort u} {β : α → Sort v} (f : ExtFun α β) (x : α) : β x</code>",
 "910":
 "<code>ExtFun.{u, v} (α : Sort u) (β : α → Sort v) : Sort (imax u v)</code>",
 "91": "<code>Quadrant.se : Quadrant</code>",
 "909":
 "<code>extEq.{u, v} {α : Sort u} {β : α → Sort v} (f g : (x : α) → β x) : Prop</code>",
 "908": "<code>∀ (a b : α), r a b → f a ≍ f b</code>",
 "907":
 "<code>Quot.recOn.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (q : Quot r)\n  (f : (a : α) → motive (Quot.mk r a)) (h : ∀ (a b : α) (p : r a b), ⋯ ▸ f a = f b) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quot` that takes the quotient first. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n * `Quot.lift` is useful for defining non-dependent functions.\n * `Quot.ind` is useful for proving theorems about quotients.\n * `Quot.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quot.hrecOn` uses [heterogeneous equality](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=HEq) instead of rewriting with\n   `Quot.sound`.\n\n`Quot.rec` is a version of this recursor that takes the quotient parameter last.\n</code>",
 "906":
 "<code>Quot.hrecOn.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (q : Quot r)\n  (f : (a : α) → motive (Quot.mk r a)) (c : ∀ (a b : α), r a b → f a ≍ f b) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quot` that uses [heterogeneous\nequality](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=HEq), analogous to a [recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for\na structure.\n\n`Quot.recOn` is a version of this recursor that uses `Eq` instead of `HEq`.\n</code>",
 "905":
 "<code>Quot.recOnSubsingleton.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v}\n  [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] (q : Quot r) (f : (a : α) → motive (Quot.mk r a)) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">An alternative induction principle for quotients that can be used when the target type is a\nsubsingleton, in which all elements are equal.\n\nIn these cases, the proof that the function respects the quotient's relation is trivial, so any\nfunction can be lifted.\n\n`Quot.rec` does not assume that the type is a subsingleton.\n</code>",
 "904": "<code>r a b</code>",
 "903": "<code>∀ (a b : α) (p : r a b), ⋯ ▸ f a = f b</code>",
 "902": "<code>(a : α) → motive (Quot.mk r a)</code>",
 "901": "<code>∀ (a : α), Subsingleton (motive (Quot.mk r a))</code>",
 "900": "<code>Quot r → Sort v</code>",
 "90": "<code>Quadrant.sw : Quadrant</code>",
 "9": "<code>Nat</code>",
 "899":
 "<code>Quot.liftOn.{u, v} {α : Sort u} {β : Sort v} {r : α → α → Prop} (q : Quot r) (f : α → β)\n  (c : ∀ (a b : α), r a b → f a = f b) : β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.\n\nGiven a relation `r : α → α → Prop` and a quotient's value `q : Quot r`, applying a `f : α → β`\nrequires a proof `c` that `f` respects `r`. In this case, `Quot.liftOn q f h : β` evaluates\nto the result of applying `f` to the underlying value in `α` from `q`.\n\n`Quot.liftOn` is a version of the built-in primitive `Quot.lift` with its parameters re-ordered.\n\n[Quotient types](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=quotients) are described in more detail in the Lean Language\nReference.\n</code>",
 "898": "<code>List (SetTree α)</code>",
 "897":
 "<code>RoseTree.branch.{u} {α : Type u} : List (RoseTree α) → RoseTree α</code>",
 "896": "<code>RoseTree.leaf.{u} {α : Type u} : α → RoseTree α</code>",
 "895": "<code>RoseTree.{u} (α : Type u) : Type u</code>",
 "894": "<code>Sort ?u.26</code>",
 "893": "<code>Sort ?u.19</code>",
 "892": "<code>∀ (x y : α), r x y → f x = f y</code>",
 "891":
 "<code>Quot.rec.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (f : (a : α) → motive (Quot.mk r a))\n  (h : ∀ (a b : α) (p : r a b), ⋯ ▸ f a = f b) (q : Quot r) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quot`. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n * `Quot.lift` is useful for defining non-dependent functions.\n * `Quot.ind` is useful for proving theorems about quotients.\n * `Quot.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quot.hrecOn` uses [heterogeneous equality](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=HEq) instead of rewriting with\n   `Quot.sound`.\n\n`Quot.recOn` is a version of this recursor that takes the quotient parameter first.\n</code>",
 "890": "<code>∀ (a : α), β (Quot.mk r a)</code>",
 "89": "<code>Quadrant.nw : Quadrant</code>",
 "889": "<code>Quot r → Prop</code>",
 "888": "<code>Quot r</code>",
 "887": "<code>∀ (a b : α), r a b → f a = f b</code>",
 "886": "<code>Sort ?u.17993</code>",
 "885": "<code>Quot r → β</code>",
 "884":
 "<code>Quot.ind.{u} {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} (mk : ∀ (a : α), β (Quot.mk r a)) (q : Quot r) : β q</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quot.mk`.\n\n`Quot.rec` is analogous to the [recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can\nbe used when the resulting type is not necessarily a proposition.\n\n`Quot.ind` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n</code>",
 "883":
 "<code>Quot.lift.{u, v} {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) (a : ∀ (a b : α), r a b → f a = f b) :\n  Quot r → β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.\n\nGiven a relation `r : α → α → Prop` and a quotient `Quot r`, applying a function `f : α → β`\nrequires a proof `a` that `f` respects `r`. In this case, `Quot.lift f a : Quot r → β` computes the\nsame values as `f`.\n\nLean's type theory includes a [definitional reduction](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=type-theory) from\n`Quot.lift f h (Quot.mk r v)` to `f v`.\n\n`Quot.lift` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.sound` asserts the equality of elements related by `r`\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`; it is analogous to the [recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for a\n   structure.\n</code>",
 "882":
 "<code>Quot.mk.{u} {α : Sort u} (r : α → α → Prop) (a : α) : Quot r</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to the provided relation.\n\nGiven `v : α` and relation `r : α → α → Prop`, `Quot.mk r v : Quot r` is like `v`, except all\nobservations of `v`'s value must respect `r`.\n\n`Quot.mk` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`.\n</code>",
 "881":
 "<code>Quotient.exact.{u} {α : Sort u} {s : Setoid α} {a b : α} : Quotient.mk s a = Quotient.mk s b → a ≈ b</code><span class=\"sep\"></span><code class=\"docstring\">If two values are equal in a quotient, then they are related by its equivalence relation.\n</code>",
 "880":
 "<code>HEq.{u} {α : Sort u} : α → {β : Sort u} → β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Heterogeneous equality. `a ≍ b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\n\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `Eq`, because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\npublic important non-theorem is the analogue of `congr`: If `f ≍ g` and `x ≍ y`\nand `f x` and `g y` are well typed it does not follow that `f x ≍ g y`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `a ≍ b` are equivalent.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≍` in identifiers is `heq`.</code>",
 "88": "<code>Quadrant : Type</code>",
 "879": "<code>∀ (a b : α), a ≈ b → f a ≍ f b</code>",
 "878":
 "<code>Quotient.ind.{u} {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} :\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q✝ : Quotient s), motive q✝</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quotient.mk`.\n</code>",
 "877":
 "<code>Eq.ndrec.{u1, u2} {α : Sort u2} {a : α} {motive : α → Sort u1} (m : motive a) {b : α} (h : a = b) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">Non-dependent recursor for the equality type. </code>",
 "876": "<code>∀ (a b : α) (p : a ≈ b), ⋯ ▸ f a = f b</code>",
 "875":
 "<code>Quotient.hrecOn.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v} (q : Quotient s)\n  (f : (a : α) → motive (Quotient.mk s a)) (c : ∀ (a b : α), a ≈ b → f a ≍ f b) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quotient` that uses [heterogeneous\nequality](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=HEq), analogous to a [recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for\na structure.\n\n`Quotient.recOn` is a version of this recursor that uses `Eq` instead of `HEq`.\n</code>",
 "874":
 "<code>Quotient.recOn.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v} (q : Quotient s)\n  (f : (a : α) → motive (Quotient.mk s a)) (h : ∀ (a b : α) (p : a ≈ b), ⋯ ▸ f a = f b) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quotient`. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n\n * `Quotient.lift` is useful for defining non-dependent functions.\n * `Quotient.ind` is useful for proving theorems about quotients.\n * `Quotient.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quotient.hrecOn` uses heterogeneous equality instead of rewriting with `Quotient.sound`.\n\n`Quotient.rec` is a version of this recursor that takes the quotient parameter last.\n</code>",
 "873": "<code>Z.add_neg_inverse (n : Z) : n + -n = 0</code>",
 "872":
 "<code class=\"docstring\">`simp_arith` has been deprecated. It was a shorthand for `simp +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "871": "<code>Quotient s → Prop</code>",
 "870":
 "<code>Quot.sound.{u} {α : Sort u} {r : α → α → Prop} {a b : α} : r a b → Quot.mk r a = Quot.mk r b</code><span class=\"sep\"></span><code class=\"docstring\">The **quotient axiom**, which asserts the equality of elements related by the quotient's relation.\n\nThe relation `r` does not need to be an equivalence relation to use this axiom. When `r` is not an\nequivalence relation, the quotient is with respect to the equivalence relation generated by `r`.\n\n`Quot.sound` is part of the built-in primitive quotient type:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`; it is analogous to the [recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for a\n   structure.\n\n[Quotient types](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=quotients) are described in more detail in the Lean Language\nReference.\n</code>",
 "87":
 "<code>Lean.ToExpr.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">We use the `ToExpr` type class to convert values of type `α` into\nexpressions that denote these values in Lean.\n\nExamples:\n```\ntoExpr true = .const ``Bool.true []\n\ntoTypeExpr Bool = .const ``Bool []\n```\n\nSee also `ToLevel` for representing universe levels as `Level` expressions.\n</code>",
 "869":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n</code>",
 "868":
 "<code>(a : α) → (b : β) → motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)</code>",
 "867":
 "<code>∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))</code>",
 "866": "<code>Quotient s₁ → Quotient s₂ → Sort uC</code>",
 "865":
 "<code>Quotient.rec.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v} (f : (a : α) → motive (Quotient.mk s a))\n  (h : ∀ (a b : α) (p : a ≈ b), ⋯ ▸ f a = f b) (q : Quotient s) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quotient`. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n\n * `Quotient.lift` is useful for defining non-dependent functions.\n * `Quotient.ind` is useful for proving theorems about quotients.\n * `Quotient.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quotient.hrecOn` uses heterogeneous equality instead of rewriting with `Quotient.sound`.\n\n`Quotient.recOn` is a version of this recursor that takes the quotient parameter first.\n</code>",
 "864": "<code>(a : α) → motive (Quotient.mk s a)</code>",
 "863":
 "<code>Subsingleton.{u} (α : Sort u) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A _subsingleton_ is a type with at most one element. It is either empty or has a unique element.\n\nAll propositions are subsingletons because of proof irrelevance: false propositions are empty, and\nall proofs of a true proposition are equal to one another. Some non-propositional types are also\nsubsingletons.\n</code>",
 "862": "<code>∀ (a : α), Subsingleton (motive (Quotient.mk s a))</code>",
 "861": "<code>Quotient s → Sort v</code>",
 "860":
 "<code>Quotient.recOnSubsingleton₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β}\n  {motive : Quotient s₁ → Quotient s₂ → Sort uC}\n  [s : ∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))] (q₁ : Quotient s₁)\n  (q₂ : Quotient s₂) (g : (a : α) → (b : β) → motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)) : motive q₁ q₂</code><span class=\"sep\"></span><code class=\"docstring\">An alternative induction or recursion operator for defining binary operations on quotients that can\nbe used when the target type is a subsingleton.\n\nIn these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.\n</code>",
 "86":
 "<code>MonadEvalT.monadEval.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [self : MonadEvalT m n] {α : Type u} :\n  m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Evaluates a value from monad `m` into monad `n`. </code>",
 "859":
 "<code>Quotient.recOnSubsingleton.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v}\n  [h : ∀ (a : α), Subsingleton (motive (Quotient.mk s a))] (q : Quotient s) (f : (a : α) → motive (Quotient.mk s a)) :\n  motive q</code><span class=\"sep\"></span><code class=\"docstring\">An alternative recursion or induction principle for quotients that can be used when the target type\nis a subsingleton, in which all elements are equal.\n\nIn these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.\n\n`Quotient.rec` does not assume that the target type is a subsingleton.\n</code>",
 "858": "<code>fst✝² + snd✝ = snd✝² + fst✝</code>",
 "857": "<code>fst✝³ + snd✝¹ = snd✝³ + fst✝¹</code>",
 "856": "<code>(fst✝³, snd✝³) ≈ (fst✝¹, snd✝¹)</code>",
 "855": "<code>(fst✝², snd✝²) ≈ (fst✝, snd✝)</code>",
 "854": "<code>(fst✝¹, snd✝¹) ≈ k'</code>",
 "853": "<code>(fst✝, snd✝) ≈ k'</code>",
 "852": "<code>(fst✝¹, snd✝¹) ≈ n'</code>",
 "851": "<code>(fst✝, snd✝) ≈ n'</code>",
 "850": "<code>k ≈ k'</code>",
 "85":
 "<code>MonadLiftT.monadLift.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [self : MonadLiftT m n] {α : Type u} :\n  m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "849": "<code>n ≈ n'</code>",
 "848":
 "<code>Z → Quotient Z.instSetoid → Z</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "847": "<code>Nat × Nat</code>",
 "846": "<code>add' (n k : Nat × Nat) : Z</code>",
 "845": "<code>n.fst + k.snd = n.snd + k.fst</code>",
 "844":
 "<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>",
 "843":
 "<code>Prod.fst.{u, v} {α : Type u} {β : Type v} (self : α × β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "842":
 "<code>Prod.snd.{u, v} {α : Type u} {β : Type v} (self : α × β) : β</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "841":
 "<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>",
 "840": "<code>n ≈ k</code>",
 "84":
 "<code>MonadEvalT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The transitive closure of `MonadEval`. </code>",
 "839":
 "<code>Quotient Z.instSetoid → Z</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "838": "<code>neg' : Z' → Z</code>",
 "837": "<code>Quotient s₂</code>",
 "836": "<code>Quotient s₁</code>",
 "835":
 "<code>∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂</code>",
 "834": "<code>α → β → φ</code>",
 "833": "<code>Setoid β</code>",
 "832": "<code>Sort uC</code>",
 "831": "<code>Sort uB</code>",
 "830": "<code>Sort uA</code>",
 "83":
 "<code>MonadLiftT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Computations in the monad `m` can be run in the monad `n`. These translations are inserted\nautomatically by the compiler.\n\nUsually, `n` consists of some number of monad transformers applied to `m`, but this is not\nmandatory.\n\nThis is the reflexive, transitive closure of `MonadLift`. Clients that require one monad to be\nliftable into another should request an instance of `MonadLiftT`. New instances should instead be\ndefined for `MonadLift` itself.\n</code>",
 "829": "<code>Manual.c : Verso.Doc.Elab.CodeBlockExpanderOf Unit</code>",
 "828": "<code>Quotient s</code>",
 "827": "<code>∀ (a b : α), a ≈ b → f a = f b</code>",
 "826":
 "<code>Quotient.liftOn₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β}\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂) (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) : φ</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.\n\n`Quotient.liftOn` is a version of this operation for unary functions. `Quotient.lift₂` is a version\nthat take the quotient parameters last.\n</code>",
 "825":
 "<code>Quotient.liftOn.{u, v} {α : Sort u} {β : Sort v} {s : Setoid α} (q : Quotient s) (f : α → β)\n  (c : ∀ (a b : α), a ≈ b → f a = f b) : β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.\n\nGiven `s : Setoid α` and a quotient value `q : Quotient s`, applying a function `f : α → β` requires\na proof `c` that `f` respects the equivalence relation `s.r`. In this case, the term\n`Quotient.liftOn q f h : β` reduces to the result of applying `f` to the underlying `α` value.\n\n`Quotient.lift` is a version of this operation that takes the quotient value last, rather than\nfirst.\n</code>",
 "824":
 "<code>Quotient.lift₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) (q₁ : Quotient s₁)\n  (q₂ : Quotient s₂) : φ</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.\n\n`Quotient.lift` is a version of this operation for unary functions. `Quotient.liftOn₂` is a version\nthat take the quotient parameters first.\n</code>",
 "823": "<code>Z.mk (n : Z') : Z</code>",
 "822":
 "<code>Equivalence eq</code><span class=\"sep\"></span><code class=\"docstring\">The relation `x ≈ y` is an equivalence relation. </code>",
 "821":
 "<code>Z' → Z' → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "820": "<code>Z.instSetoid : Setoid Z'</code>",
 "82": "<code>Type → Type</code>",
 "819": "<code>x' + y'' = y' + x''</code>",
 "818": "<code>eq (x', y') (x'', y'')</code>",
 "817":
 "<code>∀ {x y z : Z'}, eq x y → eq y z → eq x z</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is transitive: `r x y` and `r y z` implies `r x z` </code>",
 "816": "<code>x + y' = y + x'</code>",
 "815":
 "<code class=\"docstring\">`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n</code>",
 "814": "<code>eq (x, y) (x', y')</code>",
 "813":
 "<code>∀ {x y : Z'}, eq x y → eq y x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is symmetric: `r x y` implies `r y x` </code>",
 "812":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), simplifies simple arithmetic expressions. </code>",
 "811":
 "<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`. It is equivalent to `intro _`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, given a type ascription, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side\n  is a variable.\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>",
 "810":
 "<code>∀ (x : Z'), eq x x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is reflexive: `r x x` </code>",
 "81":
 "<code>Lean.Core.CoreM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">CoreM is a monad for manipulating the Lean environment.\nIt is the base monad for `MetaM`.\nThe main features it provides are:\n- name generator state\n- environment state\n- Lean options context\n- the current open namespace\n</code>",
 "809": "<code>Z.eq.eqv : Equivalence eq</code>",
 "808": "<code>Z'</code>",
 "807": "<code>Z' : Type</code>",
 "806": "<code>Z.eq (n k : Z') : Prop</code>",
 "805":
 "<code>Quotient.mk'.{u} {α : Sort u} [s : Setoid α] (a : α) : Quotient s</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to an equivalence\nrelation.\n\nThe equivalence relation is found by synthesizing a `Setoid` instance. `Quotient.mk` instead expects\nthe instance to be provided explicitly.\n\nGiven `v : α`, `Quotient.mk' v : Quotient s` is like `v`, except all observations of `v`'s value\nmust respect `s.r`. `Quotient.lift` allows values in a quotient to be mapped to other types, so long\nas the mapping respects `s.r`.\n\n</code>",
 "804":
 "<code>inferInstance.{u} {α : Sort u} [i : α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n</code>",
 "803":
 "<code>∀ {x y z : α}, r x y → r y z → r x z</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is transitive: `r x y` and `r y z` implies `r x z` </code>",
 "802":
 "<code>∀ {x y : α}, r x y → r y x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is symmetric: `r x y` implies `r y x` </code>",
 "801":
 "<code>∀ (x : α), r x x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is reflexive: `r x x` </code>",
 "800":
 "<code>Equivalence.mk.{u} {α : Sort u} {r : α → α → Prop} (refl : ∀ (x : α), r x x) (symm : ∀ {x y : α}, r x y → r y x)\n  (trans : ∀ {x y z : α}, r x y → r y z → r x z) : Equivalence r</code>",
 "80":
 "<code>Lean.Meta.MetaM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The `MetaM` monad is a core component of Lean's metaprogramming framework, facilitating the\nconstruction and manipulation of expressions (`Lean.Expr`) within Lean.\n\nIt builds on top of `CoreM` and additionally provides:\n- A `LocalContext` for managing free variables.\n- A `MetavarContext` for managing metavariables.\n- A `Cache` for caching results of the key `MetaM` operations.\n\nThe key operations provided by `MetaM` are:\n- `inferType`, which attempts to automatically infer the type of a given expression.\n- `whnf`, which reduces an expression to the point where the outermost part is no longer reducible\n  but the inside may still contain unreduced expression.\n- `isDefEq`, which determines whether two expressions are definitionally equal, possibly assigning\n  meta variables in the process.\n- `forallTelescope` and `lambdaTelescope`, which make it possible to automatically move into\n  (nested) binders while updating the local context.\n\nThe following is a small example that demonstrates how to obtain and manipulate the type of a\n`Fin` expression:\n```\npublic import Lean\n\nopen Lean Meta\n\ndef getFinBound (e : Expr) : MetaM (Option Expr) := do\n  let type ← whnf (← inferType e)\n  let_expr Fin bound := type | return none\n  return bound\n\ndef a : Fin 100 := 42\n\nrun_meta\n  match ← getFinBound (.const ``a []) with\n  | some limit =&gt; IO.println (← ppExpr limit)\n  | none =&gt; IO.println \"no limit found\"\n```\n</code>",
 "8":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "799": "<code>?m.5</code>",
 "798":
 "<code>α → α → Sort v</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≈` in identifiers is `equiv`.</code>",
 "797":
 "<code>HasEquiv.mk.{u, v} {α : Sort u} (Equiv : α → α → Sort v) : HasEquiv α</code>",
 "796":
 "<code>HasEquiv.{u, v} (α : Sort u) : Sort (max u (v + 1))</code><span class=\"sep\"></span><code class=\"docstring\">`HasEquiv α` is the typeclass which supports the notation `x ≈ y` where `x y : α`.</code>",
 "795": "<code>b ≈ c</code>",
 "794": "<code>a ≈ b</code>",
 "793":
 "<code>HasEquiv.Equiv.{u, v} {α : Sort u} [self : HasEquiv α] : α → α → Sort v</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≈` in identifiers is `equiv`.</code>",
 "792":
 "<code>Equivalence.{u} {α : Sort u} (r : α → α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation `r : α → α → Prop` is a relation that is\n\n* reflexive: `r x x`,\n* symmetric: `r x y` implies `r y x`, and\n* transitive: `r x y` and `r y z` implies `r x z`.\n\nEquality is an equivalence relation, and equivalence relations share many of the properties of\nequality.\n</code>",
 "791":
 "<code>Equivalence Setoid.r</code><span class=\"sep\"></span><code class=\"docstring\">The relation `x ≈ y` is an equivalence relation. </code>",
 "790":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "79": "<code>Lean.Elab.Term.TermElabM (α : Type) : Type</code>",
 "789":
 "<code>Setoid.mk.{u} {α : Sort u} (r : α → α → Prop) (iseqv : Equivalence r) : Setoid α</code>",
 "788": "<code>¬n' &lt; k'</code>",
 "787": "<code>n' &lt; k'</code>",
 "786": "<code>¬n = k</code>",
 "785": "<code>n = k</code>",
 "784":
 "<code>Not (a : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `¬` in identifiers is `not`.</code>",
 "783": "<code>¬n &lt; k</code>",
 "782": "<code>n &lt; k</code>",
 "781":
 "<code class=\"docstring\">The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed using the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n</code>",
 "780":
 "<code>Neg.neg.{u} {α : Type u} [self : Neg α] : α → α</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "78": "<code>Lean.Elab.Command.CommandElabM (α : Type) : Type</code>",
 "779":
 "<code>ite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "778":
 "<code>toInt_sound {n k' k n' : Nat} : n + k' = k + n' ↔ toInt n k = toInt n' k'</code>",
 "777":
 "<code>Int.subNatNat (m n : Nat) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Non-truncating subtraction of two natural numbers.\n\nExamples:\n* `Int.subNatNat 5 2 = 3`\n* `Int.subNatNat 2 5 = -3`\n* `Int.subNatNat 0 13 = -13`\n</code>",
 "776": "<code>toInt (n k : Nat) : Int</code>",
 "775":
 "<code>Z → Z → Z</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "774":
 "<code>ToString.toString.{u} {α : Type u} [self : ToString α] : α → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>",
 "773": "<code><span class=\"literal string\">\"0\"</span> : String</code>",
 "772":
 "<code>Z → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>",
 "771":
 "<code>Z</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "770": "<code>Z</code>",
 "77":
 "<code class=\"docstring\">The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n</code>",
 "769":
 "<code>Z → Z</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "768":
 "<code>Neg.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for negation.\nThis enables the notation `-a : α` where `a : α`.\n</code>",
 "767":
 "<code>Z_mk'_respects_eq {n k n' k' : Nat} : Z.mk' n k = Z.mk' n' k' ↔ n + k' = n' + k</code>",
 "766":
 "<code>HSub.hSub.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HSub α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>",
 "765": "<code>n - k = 0 ∨ k - n = 0</code>",
 "764": "<code>Z.mk' (n k : Nat) : Z</code>",
 "763": "<code>Z.canonical (self : Z) : self.a = 0 ∨ self.b = 0</code>",
 "762": "<code>Z.b (self : Z) : Nat</code>",
 "761": "<code>Z.a (self : Z) : Nat</code>",
 "760": "<code>Z : Type</code>",
 "76":
 "<code>eval.derive.repr</code><span class=\"sep\"></span><code class=\"docstring\">('#eval' command) enables auto-deriving 'Repr' instances as a fallback</code>",
 "759":
 "<code>Quotient.ind.{u} {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} :\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q : Quotient s), motive q</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quotient.mk`.\n</code>",
 "758":
 "<code>Quotient.sound.{u} {α : Sort u} {s : Setoid α} {a b : α} : a ≈ b → Quotient.mk s a = Quotient.mk s b</code><span class=\"sep\"></span><code class=\"docstring\">The **quotient axiom**, which asserts the equality of elements related in the setoid.\n\nBecause `Quotient` is built on a lower-level type `Quot`, `Quotient.sound` is implemented as a\ntheorem. It is derived from `Quot.sound`, the soundness axiom for the lower-level quotient type\n`Quot`.\n</code>",
 "757":
 "<code>Quotient.mk.{u} {α : Sort u} (s : Setoid α) (a : α) : Quotient s</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to an equivalence\nrelation.\n\nThe setoid instance is provided explicitly. `Quotient.mk'` uses instance synthesis instead.\n\nGiven `v : α`, `Quotient.mk s v : Quotient s` is like `v`, except all observations of `v`'s value\nmust respect `s.r`. `Quotient.lift` allows values in a quotient to be mapped to other types, so long\nas the mapping respects `s.r`.\n</code>",
 "756":
 "<code>Quotient.lift.{u, v} {α : Sort u} {β : Sort v} {s : Setoid α} (f : α → β) :\n  (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.\n\nGiven `s : Setoid α` and a quotient `Quotient s`, applying a function `f : α → β` requires a proof\n`h` that `f` respects the equivalence relation `s.r`. In this case, the function\n`Quotient.lift f h : Quotient s → β` computes the same values as `f`.\n\n`Quotient.liftOn` is a version of this operation that takes the quotient value as its first explicit\nparameter.\n</code>",
 "755": "<code>Sort ?u.481</code>",
 "754": "<code>Quotient s → β</code>",
 "753":
 "<code>Setoid.r.{u} {α : Sort u} [self : Setoid α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "752":
 "<code>Quotient.{u} {α : Sort u} (s : Setoid α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Quotient types coarsen the propositional equality for a type so that terms related by some\nequivalence relation are considered equal. The equivalence relation is given by an instance of\n`Setoid`.\n\nSet-theoretically, `Quotient s` can seen as the set of equivalence classes of `α` modulo the\n`Setoid` instance's relation `s.r`. Functions from `Quotient s` must prove that they respect `s.r`:\nto define a function `f : Quotient s → β`, it is necessary to provide `f' : α → β` and prove that\nfor all `x : α` and `y : α`, `s.r x y → f' x = f' y`. `Quotient.lift` implements this operation.\n\nThe key quotient operators are:\n * `Quotient.mk` places elements of the underlying type `α` into the quotient.\n * `Quotient.lift` allows the definition of functions from the quotient to some other type.\n * `Quotient.sound` asserts the equality of elements related by `r`\n * `Quotient.ind` is used to write proofs about quotients by assuming that all elements are\n   constructed with `Quotient.mk`.\n\n`Quotient` is built on top of the primitive quotient type `Quot`, which does not require a proof\nthat the relation is an equivalence relation. `Quotient` should be used instead of `Quot` for\nrelations that actually are equivalence relations.\n</code>",
 "751":
 "<code>Setoid.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A setoid is a type with a distinguished equivalence relation, denoted `≈`.\n\nThe `Quotient` type constructor requires a `Setoid` instance.\n</code>",
 "750": "<code>Setoid α</code>",
 "75":
 "<code>eval.type</code><span class=\"sep\"></span><code class=\"docstring\">('#eval' command) enables pretty printing the type of the result</code>",
 "749":
 "<code>OptONat.of_to_eq_id (o : OptONat) : OptONat.ofOption o.toOption = o</code>",
 "748": "<code>(motive2 ∘ OptONat.toOption) pred</code>",
 "747":
 "<code>ONat'.rec.{u} {motive_1 : ONat' → Sort u} {motive_2 : OptONat → Sort u}\n  (mk : (pred : OptONat) → motive_2 pred → motive_1 (ONat'.mk pred)) (none : motive_2 OptONat.none)\n  (some : (a : ONat') → motive_1 a → motive_2 (OptONat.some a)) (t : ONat') : motive_1 t</code>",
 "746": "<code>(o : ONat) → motive1 o → motive2 (some o)</code>",
 "745": "<code>motive2 none</code>",
 "744": "<code>(pred : Option ONat) → motive2 pred → motive1 (mk pred)</code>",
 "743":
 "<code>ONat.rec.{u} {motive1 : ONat → Sort u} {motive2 : Option ONat → Sort u}\n  (h1 : (pred : Option ONat) → motive2 pred → motive1 (mk pred)) (h2 : motive2 none)\n  (h3 : (o : ONat) → motive1 o → motive2 (some o)) (t : ONat) : motive1 t</code>",
 "742":
 "<code>OptONat.of_to_eq_id (o : OptONat) : ofOption o.toOption = o</code>",
 "741":
 "<code>OptONat.to_of_eq_id (o : Option ONat) : (ofOption o).toOption = o</code>",
 "740": "<code>ONat'</code>",
 "74":
 "<code>eval.pp</code><span class=\"sep\"></span><code class=\"docstring\">('#eval' command) enables using 'ToExpr' instances to pretty print the result, otherwise uses 'Repr' or 'ToString' instances</code>",
 "739": "<code>OptONat.toOption : OptONat → Option ONat</code>",
 "738": "<code>OptONat.ofOption : Option ONat → OptONat</code>",
 "737": "<code>OptONat.some : ONat' → OptONat</code>",
 "736": "<code>OptONat.none : OptONat</code>",
 "735": "<code>OptONat : Type</code>",
 "734": "<code>OptONat</code>",
 "733": "<code>ONat'.mk (pred : OptONat) : ONat'</code>",
 "732": "<code>ONat' : Type</code>",
 "731": "<code>ONat</code>",
 "730": "<code>(val : ONat) → @val val → motive_2 (Option.some val)</code>",
 "73":
 "<code>MonadEval.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Typeclass used for adapting monads. This is similar to `MonadLift`, but instances are allowed to\nmake use of default state for the purpose of synthesizing such an instance, if necessary.\nEvery `MonadLift` instance gives a `MonadEval` instance.\n\nThe purpose of this class is for the `#eval` command,\nwhich looks for a `MonadEval m CommandElabM` or `MonadEval m IO` instance.\n</code>",
 "729": "<code>motive_2 Option.none</code>",
 "728":
 "<code>(pred : Option ONat) → motive_2 pred → @pred (ONat.mk pred)</code>",
 "727": "<code>Option ONat → Sort u</code>",
 "726": "<code>ONat → Sort u</code>",
 "725":
 "<code>ONat.rec.{u} {motive_1 : ONat → Sort u} {motive_2 : Option ONat → Sort u}\n  (mk : (pred : Option ONat) → motive_2 pred → motive_1 (ONat.mk pred)) (none : motive_2 none)\n  (some : (val : ONat) → motive_1 val → motive_2 (some val)) (t : ONat) : motive_1 t</code>",
 "724": "<code>Palindrome α xs</code>",
 "723":
 "<code>Palindrome.cons {α : Type} {xs : List α} (x : α) (p : Palindrome α xs) : Palindrome α (x :: xs ++ [x])</code>",
 "722": "<code>Palindrome.single {α : Type} {x : α} : Palindrome α [x]</code>",
 "721": "<code>Palindrome.nil {α : Type} : Palindrome α []</code>",
 "720": "<code>Palindrome (α : Type) : List α → Prop</code>",
 "72": "<code>?m.1</code>",
 "719": "<code>BRTree : sorry</code>",
 "718": "<code>List (BRTree branches α)</code>",
 "717": "<code>Nat → Type u → Type u</code>",
 "716": "<code>@_nested.List_1 branches α</code>",
 "715":
 "<code>List.length.{u_1} {α : Type u_1} : List α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The length of a list.\n\nThis function is overridden in the compiler to `lengthTR`, which uses constant stack space.\n\nExamples:\n* `([] : List String).length = 0`\n* `[\"green\", \"brown\"].length = 2`\n</code>",
 "714": "<code>Option WithCheck → Bool</code>",
 "713": "<code>List (DRTree α n)</code>",
 "712": "<code>Type u → Nat → Type u</code>",
 "711": "<code>Children (RTree α)</code>",
 "710": "<code>Type u → Type u</code>",
 "71":
 "<code>ToString.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Types that can be converted into a string for display.\n\nThere is no expectation that the resulting string can be parsed back to the original data (see\n`Repr` for a similar class with this expectation).\n</code>",
 "709": "<code>Children.{u_1} (α : Type u_1) : Type u_1</code>",
 "708": "<code>List (RTree α)</code>",
 "707":
 "<code>RTree.node.{u} {α : Type u} (val : α) (children : List (RTree α)) : RTree α</code>",
 "706": "<code>RTree.empty.{u} {α : Type u} : RTree α</code>",
 "705": "<code>RTree.{u} (α : Type u) : Type u</code>",
 "704": "<code>Option ONat</code>",
 "703": "<code>ONat.mk (pred : Option ONat) : ONat</code>",
 "702": "<code>ONat : Type</code>",
 "701": "<code>Two α</code>",
 "700": "<code>(a a_1 : α) → motive_1 (Two.mk a a_1)</code>",
 "70":
 "<code>Repr.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The standard way of turning values of some type into `Format`.\n\nWhen rendered this `Format` should be as close as possible to something that can be parsed as the\ninput value.\n</code>",
 "7":
 "<code><span class=\"literal string\">\"The answer is 4\"</span> : String</code>",
 "699": "<code>Three α → Sort u</code>",
 "698": "<code>Two α → Sort u</code>",
 "697":
 "<code>Two.rec.{u} {α : Type} {motive_1 : Two α → Sort u} {motive_2 : Three α → Sort u}\n  (mk : (a a_1 : α) → motive_1 (Two.mk a a_1)) :\n  ((a a_1 a_2 : α) → motive_2 (Three.mk a a_1 a_2)) → (t : Two α) → motive_1 t</code>",
 "696": "<code>Three.mk {α : Type} : α → α → α → Three α</code>",
 "695": "<code>Two.mk {α : Type} : α → α → Two α</code>",
 "694": "<code>Three (α : Type) : Type</code>",
 "693": "<code>Two (α : Type) : Type</code>",
 "692": "<code>Odd a</code>",
 "691":
 "<code>Odd.rec {motive_1 : (a : Nat) → Even a → Prop} {motive_2 : (a : Nat) → Odd a → Prop} (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) ⋯) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) ⋯) → ∀ {a : Nat} (t : Odd a), motive_2 a t</code>",
 "690": "<code>Even a</code>",
 "69": "<code>Lean.MessageSeverity.error : Lean.MessageSeverity</code>",
 "689": "<code>Even n</code>",
 "688": "<code>Odd n</code>",
 "687":
 "<code>∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) ⋯</code>",
 "686": "<code>motive_1 0 Even.zero</code>",
 "685": "<code>(a : Nat) → Odd a → Prop</code>",
 "684": "<code>(a : Nat) → Even a → Prop</code>",
 "683":
 "<code>Even.rec {motive_1 : (a : Nat) → Even a → Prop} {motive_2 : (a : Nat) → Odd a → Prop} (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) ⋯) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) ⋯) → ∀ {a : Nat} (t : Even a), motive_1 a t</code>",
 "682": "<code>Odd.succ {n : Nat} : Even n → Odd (n + 1)</code>",
 "681": "<code>Odd : Nat → Prop</code>",
 "680": "<code>Even.succ {n : Nat} : Odd n → Even (n + 1)</code>",
 "68": "<code>Lean.MessageSeverity.warning : Lean.MessageSeverity</code>",
 "679": "<code>List LocatedStx</code>",
 "678": "<code>Stx.node (kind : String) (args : List LocatedStx) : Stx</code>",
 "677": "<code>Stx.atom (str : String) : Stx</code>",
 "676": "<code>Stx</code>",
 "675": "<code>LocatedStx.mk (line col : Nat) (val : Stx) : LocatedStx</code>",
 "674": "<code>Stx : Type</code>",
 "673": "<code>LocatedStx : Type</code>",
 "672": "<code>NonZero [(1, 2), (2, 2), (3, 1), (1, 3)]</code>",
 "671":
 "<code>RunsMatch [(1, 2), (2, 2), (3, 1), (1, 3)] [1, 1, 2, 2, 3, 1, 1, 1]</code>",
 "670": "<code>NoRepeats [(1, 2), (2, 2), (3, 1), (1, 3)]</code>",
 "67": "<code>Lean.MessageSeverity.information : Lean.MessageSeverity</code>",
 "669": "<code>List (Nat × Nat)</code>",
 "668":
 "<code>RLE.nonZero.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : NonZero self.rle</code>",
 "667":
 "<code>RLE.runsMatch.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : RunsMatch self.rle xs</code>",
 "666": "<code>RunLengths α</code>",
 "665":
 "<code>RLE.noRepeats.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : NoRepeats self.rle</code>",
 "664":
 "<code>RLE.rle.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : RunLengths α</code>",
 "663": "<code>RLE.{u_1} {α : Type u_1} (xs : List α) : Type u_1</code>",
 "662": "<code>NonZero.{u_1} {α : Type u_1} : RunLengths α → Prop</code>",
 "661":
 "<code>List.replicate.{u} {α : Type u} (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a list that contains `n` copies of `a`.\n\n* `List.replicate 5 \"five\" = [\"five\", \"five\", \"five\", \"five\", \"five\"]`\n* `List.replicate 0 \"zero\" = []`\n* `List.replicate 2 ' ' = [' ', ' ']`\n</code>",
 "660":
 "<code>List.take.{u} {α : Type u} (n : Nat) (xs : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the first `n` elements of `xs`, or the whole list if `n` is greater than `xs.length`.\n\n`O(min n |xs|)`.\n\nExamples:\n* `[a, b, c, d, e].take 0 = []`\n* `[a, b, c, d, e].take 3 = [a, b, c]`\n* `[a, b, c, d, e].take 6 = [a, b, c, d, e]`\n</code>",
 "66":
 "<code>everyOther.eq_3.{u_1} {α : Type u_1} (x_1 head : α) (xs : List α) :\n  everyOther (x_1 :: head :: xs) = x_1 :: everyOther xs</code>",
 "659":
 "<code>RunsMatch.{u_1} {α : Type u_1} : RunLengths α → List α → Prop</code>",
 "658": "<code>List (α × Nat)</code>",
 "657": "<code>NoRepeats.{u_1} {α : Type u_1} : RunLengths α → Prop</code>",
 "656": "<code>RunLengths.{u_1} (α : Type u_1) : Type u_1</code>",
 "655": "<code>Type ?u.24</code>",
 "654": "<code>Type ?u.9</code>",
 "653":
 "<code>Ne.{u} {α : Sort u} (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.</code>",
 "652": "<code>List ?m.37</code>",
 "651": "<code>?m.37</code>",
 "650":
 "<code>PrefixRunOf.succ {α : Type} {n : Nat} {x : α} {xs ys : List α} :\n  PrefixRunOf n x xs ys → PrefixRunOf (n + 1) x (x :: xs) ys</code>",
 "65":
 "<code>everyOther.eq_2.{u_1} {α : Type u_1} (x_1 : α) : everyOther [x_1] = [x_1]</code>",
 "649": "<code>?m.19</code>",
 "648": "<code>List ?m.19</code>",
 "647": "<code>autoParam (¬∃ zs, xs = x :: zs) _auto✝</code>",
 "646":
 "<code>PrefixRunOf.zero {α : Type} {xs : List α} {x : α} (noMore : ¬∃ zs, xs = x :: zs := by simp) : PrefixRunOf 0 x xs xs</code>",
 "645":
 "<code>PrefixRunOf {α : Type} : Nat → α → List α → List α → Type</code>",
 "644":
 "<code>RLE.run {α : Type} {xs ys : List α} (x : α) (n : Nat) : n ≠ 0 → PrefixRunOf n x xs ys → RLE ys → RLE xs</code>",
 "643": "<code>RLE.nil {α : Type} : RLE []</code>",
 "642": "<code>RLE {α : Type} : List α → Type</code>",
 "641": "<code>Sort ?u.16</code>",
 "640": "<code>α → sorry → Prop</code>",
 "64": "<code>everyOther.eq_1.{u_1} {α : Type u_1} : everyOther [] = []</code>",
 "639": "<code>α → α → Prop</code>",
 "638": "<code><span class=\"literal string\">\"z\"</span> : String</code>",
 "637": "<code><span class=\"literal string\">\"y\"</span> : String</code>",
 "636": "<code><span class=\"literal string\">\"x\"</span> : String</code>",
 "635":
 "<code>OddList.cons.{u} {α : Type u} : α → EvenList α → OddList α</code>",
 "634":
 "<code>EvenList.cons.{u} {α : Type u} : α → OddList α → EvenList α</code>",
 "633": "<code>EvenList.nil.{u} {α : Type u} : EvenList α</code>",
 "632": "<code>OddList.{u} (α : Type u) : Type u</code>",
 "631": "<code>EvenList.{u} (α : Type u) : Type u</code>",
 "630": "<code>S.sc16_2 (self : S) : UInt16</code>",
 "63":
 "<code>everyOther.eq_def.{u_1} {α : Type u_1} (x✝ : List α) :\n  everyOther x✝ =\n    match x✝ with\n    | [] =&gt; []\n    | [x] =&gt; [x]\n    | x :: head :: xs =&gt; x :: everyOther xs</code>",
 "629": "<code>S.sc32_1 (self : S) : UInt32</code>",
 "628": "<code>S.ptr_3 (self : S) : Char</code>",
 "627": "<code>S.usize_2 (self : S) : USize</code>",
 "626": "<code>S.sc64_3 (self : S) : UInt64</code>",
 "625": "<code>S.sc8_2 (self : S) : UInt8</code>",
 "624":
 "<code>UInt16 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Unsigned 16-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 16-bit value\nrather than wrapping a `BitVec 16`.\n</code>",
 "623": "<code>S.sc16_1 (self : S) : UInt16</code>",
 "622": "<code>S.sc8_1 (self : S) : Bool</code>",
 "621": "<code>S.sc64_2 (self : S) : Float</code>",
 "620": "<code>UInt64</code>",
 "62":
 "<code>everyOther.eq_unfold.{u_1} :\n  @everyOther = fun {α} x =&gt;\n    match x with\n    | [] =&gt; []\n    | [x] =&gt; [x]\n    | x :: head :: xs =&gt; x :: everyOther xs</code>",
 "619": "<code>S.ptr_2 (self : S) : { x // x &gt; 0 }</code>",
 "618": "<code>S.sc64_1 (self : S) : UInt64</code>",
 "617": "<code>S.usize_1 (self : S) : USize</code>",
 "616": "<code>S.ptr_1 (self : S) : Array Nat</code>",
 "615":
 "<code>ISize : Type</code><span class=\"sep\"></span><code class=\"docstring\">Signed integers that are the size of a word on the platform's architecture.\n\nOn a 32-bit architecture, `ISize` is equivalent to `Int32`. On a 64-bit machine, it is equivalent to\n`Int64`. This type has special support in the compiler so it can be represented by an unboxed value.\n</code>",
 "614":
 "<code>Subtype.val.{u} {α : Sort u} {p : α → Prop} (self : Subtype p) : α</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "613": "<code>p val</code>",
 "612": "<code>α → Prop</code>",
 "611":
 "<code>Subtype.mk.{u} {α : Sort u} {p : α → Prop} (val : α) (property : p val) : Subtype p</code>",
 "610":
 "<code>Subtype.{u} {α : Sort u} (p : α → Prop) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">All the elements of a type that satisfy a predicate.\n\n`Subtype p`, usually written `{ x : α // p x }` or `{ x // p x }`, contains all elements `x : α` for\nwhich `p x` is true. Its constructor is a pair of the value and the proof that it satisfies the\npredicate. In run-time code, `{ x : α // p x }` is represented identically to `α`.\n\nThere is a coercion from `{ x : α // p x }` to `α`, so elements of a subtype may be used where the\nunderlying type is expected.\n\nExamples:\n * `{ n : Nat // n % 2 = 0 }` is the type of even numbers.\n * `{ xs : Array String // xs.size = 5 }` is the type of arrays with five `String`s.\n * Given `xs : List α`, `List { x : α // x ∈ xs }` is the type of lists in which all elements are\n   contained in `xs`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{ x // p x }` in identifiers is `subtype`.</code>",
 "61": "<code>everyOther.{u_1} {α : Type u_1} : List α → List α</code>",
 "6091":
 "<code>trace.Meta.isDefEq</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "6090":
 "<code class=\"docstring\">(module system) Make bodies of definitions available to importing modules.</code>",
 "609":
 "<code>Fin (n : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>",
 "6089":
 "<code>Std.HashSet.ofList.{u} {α : Type u} [BEq α] [Hashable α] (l : List α) : Std.HashSet α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a hash set from a list of elements. Note that unlike repeatedly calling `insert`, if the\ncollection contains multiple elements that are equal (with regard to `==`), then the last element\nin the collection will be present in the returned hash set.\n</code>",
 "6088":
 "<code><span class=\"literal string\">\"bananas\"</span> : String</code>",
 "6087":
 "<code><span class=\"literal string\">\"apples\"</span> : String</code>",
 "6086":
 "<code>Exists.elim.{u} {α : Sort u} {p : α → Prop} {b : Prop} (h₁ : ∃ x, p x) (h₂ : ∀ (a : α), p a → b) : b</code>",
 "6085": "<code>Manual.example : DirectiveExpander</code>",
 "6084": "<code>x✝</code>",
 "6083": "<code>shell</code>",
 "6082": "<code>command</code>",
 "6081": "<code>path</code>",
 "6080": "<code>local-name</code>",
 "608":
 "<code>Fin.mk {n : Nat} (val : Nat) (isLt : val &lt; n) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `Fin n` from `i : Nat` and a proof that `i &lt; n`. </code>",
 "6079": "<code>toolchain</code>",
 "6078":
 "<code>Lake.ExternLib : Type</code><span class=\"sep\"></span><code class=\"docstring\">An external library -- its package plus its configuration. </code>",
 "6077":
 "<code>Lake.LeanLib : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean library -- its package plus its configuration. </code>",
 "6076":
 "<code>Lake.LeanExe : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean executable -- its package plus its configuration. </code>",
 "6075":
 "<code>Lake.Module : Type</code><span class=\"sep\"></span><code class=\"docstring\">A buildable Lean module of a `LeanLib`. </code>",
 "6074":
 "<code>Lake.NPackage (n : Lean.Name) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A package with a name known at type-level. </code>",
 "6073":
 "<code>Lake.Package : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lake package -- its location plus its configuration. </code>",
 "6072":
 "<code>Lake.Workspace : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lake workspace -- the top-level package directory. </code>",
 "6071":
 "<code>m Lake.Workspace</code><span class=\"sep\"></span><code class=\"docstring\">Gets the current Lake workspace. </code>",
 "6070":
 "<code>Lake.MonadWorkspace.mk.{u} {m : Type → Type u} (getWorkspace : m Lake.Workspace) : Lake.MonadWorkspace m</code>",
 "607": "<code>α : Prop</code>",
 "6069":
 "<code>Lake.LakeM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a `Lake.Context`. </code>",
 "6068": "<code>Manual.lake : Verso.Doc.Elab.DirectiveExpander</code>",
 "6067":
 "<code>Lake.LakeInstall : Type</code><span class=\"sep\"></span><code class=\"docstring\">Path information about the local Lake installation. </code>",
 "6066":
 "<code>Lake.LeanInstall : Type</code><span class=\"sep\"></span><code class=\"docstring\">Path information about the local Lean installation. </code>",
 "6065":
 "<code>Lake.ElanInstall : Type</code><span class=\"sep\"></span><code class=\"docstring\">Information about the local Elan setup. </code>",
 "6064": "<code>System.SearchPath : Type</code>",
 "6063":
 "<code>Lake.MonadBuild.{u} (m : Type → Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a Lake build context. </code>",
 "6062":
 "<code>Lake.Env : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lake environment. </code>",
 "6061":
 "<code>Lake.MonadLakeEnv.{u} (m : Type → Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a (read-only) detected environment for Lake. </code>",
 "6060":
 "<code>Lake.MonadWorkspace.{u} (m : Type → Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a (read-only) Lake `Workspace`. </code>",
 "606":
 "<code>Decidable (p : Prop) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Either a proof that `p` is true or a proof that `p` is false. This is equivalent to a `Bool` paired\nwith a proof that the `Bool` is `true` if and only if `p` is true.\n\n`Decidable` instances are primarily used via `if`-expressions and the tactic `decide`. In\nconditional expressions, the `Decidable` instance for the proposition is used to select a branch. At\nrun time, this case distinction code is identical to that which would be generated for a\n`Bool`-based conditional. In proofs, the tactic `decide` synthesizes an instance of `Decidable p`,\nattempts to reduce it to `isTrue h`, and then succeeds with the proof `h` if it can.\n\nBecause `Decidable` carries data, when writing `@[simp]` lemmas which include a `Decidable` instance\non the LHS, it is best to use `{_ : Decidable p}` rather than `[Decidable p]` so that non-canonical\ninstances can be found via unification rather than instance synthesis.\n</code>",
 "6059":
 "<code>Lean.LeanOptionValue : Type</code><span class=\"sep\"></span><code class=\"docstring\">Restriction of `DataValue` that covers exactly those cases that Lean is able to handle when passed via the `-D` flag. </code>",
 "6058":
 "<code>Lean.LeanOptionValue</code><span class=\"sep\"></span><code class=\"docstring\">The option's value. </code>",
 "6057":
 "<code>Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The option's name. </code>",
 "6056":
 "<code>Lean.LeanOption.mk (name : Lean.Name) (value : Lean.LeanOptionValue) : Lean.LeanOption</code>",
 "6055":
 "<code>Lake.BuildType.release : BuildType</code><span class=\"sep\"></span><code class=\"docstring\">High optimization level and no debug info, code, or asserts\n(e.g., passes `-O3 -DNDEBUG` when compiling C code).\n</code>",
 "6054":
 "<code>Lake.nameToStaticLib (name : String) (libPrefixOnWindows : Bool := false) : String</code><span class=\"sep\"></span><code class=\"docstring\">Convert a library name into its static library file name for the `Platform`. </code>",
 "6053":
 "<code>Lake.PackageConfig.precompileModules {p n : Lean.Name} (self : Lake.PackageConfig p n) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether to compile each of the package's module into a native shared library\nthat is loaded whenever the module is imported. This speeds up evaluation of\nmetaprograms and enables the interpreter to run functions marked `@[extern]`.\n\nDefaults to `false`.\n</code>",
 "6052":
 "<code>Lake.Job.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A Lake job. </code>",
 "6051":
 "<code>Lake.FetchM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The top-level monad for Lake build functions. </code>",
 "6050":
 "<code>Bool → Array (Lake.ModuleFacet System.FilePath)</code><span class=\"sep\"></span><code class=\"docstring\">The module facets to build and combine into the executable.\nIf `shouldExport` is true, the module facets should export any symbols\na user may expect to lookup in the executable. For example, the Lean\ninterpreter will use exported symbols in the executable. Thus, `shouldExport`\nwill be `true` if `supportInterpreter := true`.\n\nDefaults to a singleton of `Module.oExportFacet` (if `shouldExport`) or\n`Module.oFacet`. That is, the  object file compiled from the Lean source,\npotentially with exported Lean symbols.\n</code>",
 "605":
 "<code>USize : Type</code><span class=\"sep\"></span><code class=\"docstring\">Unsigned integers that are the size of a word on the platform's architecture.\n\nOn a 32-bit architecture, `USize` is equivalent to `UInt32`. On a 64-bit machine, it is equivalent\nto `UInt64`.\n</code>",
 "6049":
 "<code>Lean.Elab.runFrontend (input : String) (opts : Lean.Options) (fileName : String) (mainModuleName : Lean.Name)\n  (trustLevel : UInt32 := 0) (oleanFileName? ileanFileName? : Option System.FilePath := none)\n  (jsonOutput : Bool := false) (errorOnKinds : Array Lean.Name := #[]) (plugins : Array System.FilePath := #[])\n  (printStats : Bool := false) (setup? : Option Lean.ModuleSetup := none) : IO (Option Lean.Environment)</code>",
 "6048":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Enables the executable to interpret Lean files (e.g., via\n`Lean.Elab.runFrontend`) by exposing symbols within the  executable\nto the Lean interpreter.\n\nImplementation-wise, on Windows, the Lean shared libraries are linked\nto the executable and, on other systems, the executable is linked with\n`-rdynamic`. This increases the size of the binary on Linux and, on Windows,\nrequires `libInit_shared.dll` and `libleanshared.dll` to  be co-located\nwith the executable or part of `PATH` (e.g., via `lake exe`). Thus, this\nfeature should only be enabled when necessary.\n\nDefaults to `false`.\n</code>",
 "6047":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">**Deprecated. Use `needs` instead.**\nAn `Array` of target names to build before the executable's modules.\n</code>",
 "6046":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The name of the binary executable.\nDefaults to the target name with any `.` replaced with a `-`.\n</code>",
 "6045":
 "<code>Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The root module of the binary executable.\nShould include a `main` definition that will serve\nas the entry point of the program.\n\nThe root is built by recursively building its\nlocal imports (i.e., fellow modules of the workspace).\n\nDefaults to the name of the target.\n</code>",
 "6044":
 "<code>System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The subdirectory of the package's source directory containing the executable's\nLean source file. Defaults simply to said `srcDir`.\n\n(This will be passed to `lean` as the `-R` option.)\n</code>",
 "6043":
 "<code>Lake.LeanExeConfig.mk {name : Lean.Name} (toLeanConfig : Lake.LeanConfig) (srcDir : System.FilePath) (root : Lean.Name)\n  (exeName : String) (needs : Array Lake.PartialBuildKey) (extraDepTargets : Array Lean.Name)\n  (supportInterpreter : Bool) (nativeFacets : Bool → Array (Lake.ModuleFacet System.FilePath)) : Lake.LeanExeConfig name</code>",
 "6042":
 "<code>Lake.LeanExeConfig (name : Lean.Name) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean executable's declarative configuration. </code>",
 "6041":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether downstream packages can `import all` modules of this library.\n\nIf enabled, downstream users will be able to access the `private` internals of modules,\nincluding definition bodies not marked as `@[expose]`.\nThis may also, in the future, prevent compiler optimization which rely on `private`\ndefinitions being inaccessible outside their own package.\n\nDefaults to `false`.\n</code>",
 "6040":
 "<code>Lake.ModuleFacet (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A module facet name along with proof of its data type. </code>",
 "604":
 "<code>Int64 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Signed 64-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 64-bit value.\n</code>",
 "6039":
 "<code>Bool → Array (Lake.ModuleFacet System.FilePath)</code><span class=\"sep\"></span><code class=\"docstring\">The module facets to build and combine into the library's static\nand shared libraries. If `shouldExport` is true, the module facets should\nexport any symbols a user may expect to lookup in the library. For example,\nthe Lean interpreter will use exported symbols in linked libraries.\n\nDefaults to a singleton of `Module.oExportFacet` (if `shouldExport`) or\n`Module.oFacet`. That is, the  object files compiled from the Lean sources,\npotentially with exported Lean symbols.\n</code>",
 "6038":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">An `Array` of library facets to build on a bare `lake build` of the library.\nFor example, `#[LeanLib.sharedLib]` will build the shared library facet.\n</code>",
 "6037":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether to compile each of the library's modules into a native shared library\nthat is loaded whenever the module is imported. This speeds up evaluation of\nmetaprograms and enables the interpreter to run functions marked `@[extern]`.\n\nDefaults to `false`.\n</code>",
 "6036": "<code>Array Lake.PartialBuildKey</code>",
 "6035":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">**Deprecated. Use `needs` instead.**\nAn `Array` of target names to build before the library's modules.\n</code>",
 "6034":
 "<code>Lake.PartialBuildKey : Type</code><span class=\"sep\"></span><code class=\"docstring\">A build key with some missing info.\n\n* Package names may be elided (replaced by `Name.anonymous`).\n* Facet names are unqualified (they do not include the input target kind)\n  and may also be ellided.\n* Module package targets are supported via a fake `packageTarget` with\n  a target name ending in `moduleTargetIndicator`.\n</code>",
 "6033":
 "<code>Array Lake.PartialBuildKey</code><span class=\"sep\"></span><code class=\"docstring\">An `Array` of targets to build before the executable's modules. </code>",
 "6032":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether static and shared binaries of this library should be prefixed with `lib` on Windows.\n\nUnlike Unix, Windows does not require native libraries to start with `lib` and,\nby convention, they usually do not. However, for consistent naming across all platforms,\nusers may wish to enable this.\n\nDefaults to `false`.\n</code>",
 "6031":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The name of the library artifact.\nUsed as a base for the file names of its static and dynamic binaries.\nDefaults to the mangled name of the target.\n</code>",
 "6030": "<code>Array Lean.Name</code>",
 "603":
 "<code>Int8 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Signed 8-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 8-bit value.\n</code>",
 "6029":
 "<code>Lake.Glob : Type</code><span class=\"sep\"></span><code class=\"docstring\">A specification of a set of module names. </code>",
 "6028":
 "<code>Array Lake.Glob</code><span class=\"sep\"></span><code class=\"docstring\">An `Array` of module `Glob`s to build for the library.\nDefaults to a `Glob.one` of each of the library's  `roots`.\n\nSubmodule globs build every source file within their directory.\nLocal imports of glob'ed files (i.e., fellow modules of the workspace) are\nalso recursively built.\n</code>",
 "6027":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The root module(s) of the library.\nSubmodules of these roots (e.g., `Lib.Foo` of `Lib`) are considered\npart of the library.\nDefaults to a single root of the target's name.\n</code>",
 "6026":
 "<code>Verso.Genre.Manual.InlineLean.lean : Verso.Doc.Elab.CodeBlockExpanderOf LeanBlockConfig</code><span class=\"sep\"></span><code class=\"docstring\">Elaborates the provided Lean command in the context of the current Verso module.\n</code>",
 "6025":
 "<code>System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The subdirectory of the package's source directory containing the library's\nLean source files. Defaults simply to said `srcDir`.\n\n(This will be passed to `lean` as the `-R` option.)\n</code>",
 "6024":
 "<code>Lake.Backend : Type</code><span class=\"sep\"></span><code class=\"docstring\">Compiler backend with which to compile Lean.\n</code>",
 "6023":
 "<code>Lake.Dynlib : Type</code><span class=\"sep\"></span><code class=\"docstring\">A dynamic/shared library artifact for linking. </code>",
 "6022":
 "<code>Lake.TargetArray (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Shorthand for `Array (Target α)` that supports\ndot notation for Lake-specific operations (e.g., `fetch`).\n</code>",
 "6021":
 "<code>Lean.LeanOption : Type</code><span class=\"sep\"></span><code class=\"docstring\">An option that is used by Lean as if it was passed using `-D`. </code>",
 "6020":
 "<code>Lake.BuildType : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lake equivalent of CMake's\n[`CMAKE_BUILD_TYPE`](https://stackoverflow.com/a/59314670).\n</code>",
 "602":
 "<code>UInt64 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Unsigned 64-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 64-bit value\nrather than wrapping a `BitVec 64`.\n</code>",
 "6019":
 "<code>Lake.LeanConfig : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration options common to targets that build modules. </code>",
 "6018":
 "<code>Lake.LeanLibConfig.mk {name : Lean.Name} (toLeanConfig : Lake.LeanConfig) (srcDir : System.FilePath)\n  (roots : Array Lean.Name) (globs : Array Lake.Glob) (libName : String) (libPrefixOnWindows : Bool)\n  (needs : Array Lake.PartialBuildKey) (extraDepTargets : Array Lean.Name) (precompileModules : Bool)\n  (defaultFacets : Array Lean.Name) (nativeFacets : Bool → Array (Lake.ModuleFacet System.FilePath))\n  (allowImportAll : Bool) : Lake.LeanLibConfig name</code>",
 "6017":
 "<code>Lake.LeanLibConfig (name : Lean.Name) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean library's declarative configuration. </code>",
 "6016": "<code>Lean.NameMap (α : Type) : Type</code>",
 "6015":
 "<code>Lake.PackageConfig.version {p n : Lean.Name} (self : Lake.PackageConfig p n) : Lake.StdVer</code><span class=\"sep\"></span><code class=\"docstring\">The package version. Versions have the form:\n\n```\nv!\"&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;[-&lt;specialDescr&gt;]\"\n```\n\nA version with a `-` suffix is considered a \"prerelease\".\n\nLake suggest the following guidelines for incrementing versions:\n\n* **Major version increment** *(e.g., v1.3.0 → v2.0.0)*\n  Indicates significant breaking changes in the package.\n  Package users are not expected to update to the new version\n  without manual intervention.\n\n* **Minor version increment** *(e.g., v1.3.0 → v1.4.0)*\n  Denotes notable changes that are expected to be\n  generally backwards compatible.\n  Package users are expected to update to this version automatically\n  and should be able to fix any breakages and/or warnings easily.\n\n* **Patch version increment** *(e.g., v1.3.0 → v1.3.1)*\n  Reserved for bug fixes and small touchups.\n  Package users are expected to update automatically and should not expect\n  significant breakage, except in the edge case of users relying on the\n  behavior of patched bugs.\n\n**Note that backwards-incompatible changes may occur at any version increment.**\nThe is because the current nature of Lean (e.g., transitive imports,\nrich metaprogramming, reducibility in proofs), makes it infeasible to\ndefine a completely stable interface for a package.\nInstead, the different version levels indicate a change's intended significance\nand how difficult migration is expected to be.\n\nVersions of form the `0.x.x` are considered development versions prior to\nfirst official release. Like prerelease, they are not expected to closely\nfollow the above guidelines.\n\nPackages without a defined version default to `0.0.0`.\n</code>",
 "6014": "<code>main : List String → IO UInt32</code>",
 "6013": "<code>out-file</code>",
 "6012": "<code>lang</code>",
 "6011": "<code>&lt;target-triple&gt;</code>",
 "6010": "<code>&lt;name&gt;</code>",
 "601":
 "<code>α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The \"size\" of an element, a natural number which decreases on fields of\neach inductive type. </code>",
 "6009": "<code>&lt;github-repo&gt;</code>",
 "6008": "<code>&lt;remote-scope&gt;</code>",
 "6007": "<code>scope-option</code>",
 "6006": "<code>remote-scope</code>",
 "6005": "<code>target-triple</code>",
 "6004": "<code>github-repo</code>",
 "6003": "<code>commit-hash</code>",
 "6002": "<code>cn</code>",
 "6001": "<code>archive.tgz</code>",
 "6000": "<code>archive.tar.gz</code>",
 "600": "<code>SizeOf.mk.{u} {α : Sort u} (sizeOf : α → Nat) : SizeOf α</code>",
 "60":
 "<code>thirdOfFive.eq_2.{u_1} {α : Type u_1} (x✝ : List α)\n  (x_2 : ∀ (head head_1 x head_2 head_3 : α), x✝ = [head, head_1, x, head_2, head_3] → False) : thirdOfFive x✝ = none</code>",
 "6":
 "<code><span class=\"literal string\">\"Hello, world!\"</span> : String</code>",
 "5999": "<code>tag</code>",
 "5998": "<code>script</code>",
 "5997": "<code>file</code>",
 "5996": "<code>cmd</code>",
 "5995": "<code>packages</code>",
 "5994": "<code>args</code>",
 "5993": "<code>exe-target</code>",
 "5992": "<code>facet</code>",
 "5991": "<code>module</code>",
 "5990": "<code>target</code>",
 "599":
 "<code>SizeOf.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">`SizeOf` is a typeclass automatically derived for every inductive type,\nwhich equips the type with a \"size\" function to `Nat`.\nThe default instance defines each constructor to be `1` plus the sum of the\nsizes of all the constructor fields.\n\nThis is used for proofs by well-founded induction, since every field of the\nconstructor has a smaller size than the constructor itself,\nand in many cases this will suffice to do the proof that a recursive function\nis only called on smaller values.\nIf the default proof strategy fails, it is recommended to supply a custom\nsize measure using the `termination_by` argument on the function definition.\n</code>",
 "5989": "<code>package</code>",
 "5988": "<code>mappings</code>",
 "5987": "<code>targets</code>",
 "5986": "<code>language</code>",
 "5985": "<code>template</code>",
 "5984": "<code>name</code>",
 "5983":
 "<code>Lake.ScriptM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of a `Script`'s monad.\n\nIt is an `IO` monad equipped information about the Lake configuration.\n</code>",
 "5982":
 "<code class=\"docstring\">initialization procedure for global references</code>",
 "5981": "<code>Sort ?u.5491</code>",
 "5980": "<code>Sort ?u.5490</code>",
 "598": "<code>Sort u</code>",
 "5979": "<code>Sort ?u.5485</code>",
 "5978": "<code class=\"docstring\">name to be used by code generators</code>",
 "5977": "<code class=\"docstring\">builtin and foreign functions</code>",
 "5976": "<code>discardElems.{u_1} {α : Type u_1} : List α → List Unit</code>",
 "5975":
 "<code>String.Pos.Raw.set : String → String.Pos.Raw → Char → String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the character at a specified position in a string with a new character. If the position is\ninvalid, the string is returned unchanged.\n\nIf both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.\n\nThis is a legacy function. The recommended alternative is `String.ValidPos.set`, combined with\n`String.pos` or another means of obtaining a `String.ValidPos`.\n\nExamples:\n* `\"abc\".set ⟨1⟩ 'B' = \"aBc\"`\n* `\"abc\".set ⟨3⟩ 'D' = \"abc\"`\n* `\"L∃∀N\".set ⟨4⟩ 'X' = \"L∃XN\"`\n* `\"L∃∀N\".set ⟨2⟩ 'X' = \"L∃∀N\"` because `'∃'` is a multi-byte character, so the byte index `2` is an\n  invalid position.\n</code>",
 "5974": "<code>process' (str : String) : String × String</code>",
 "5973": "<code>process (str : String) : String × String</code>",
 "5972":
 "<code>trace.compiler.ir.result</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "5971":
 "<code><span class=\"literal string\">\"Original input:\"</span> : String</code>",
 "5970": "<code>line.startValidPos ≠ line.endValidPos</code>",
 "597": "<code>Lean.Parser.Command.structure : Lean.Parser.Parser</code>",
 "5969":
 "<code><span class=\"literal string\">\"String update\"</span> : String</code>",
 "5968": "<code>str.startValidPos ≠ str.endValidPos</code>",
 "5967":
 "<code>process (str : String) (h : str.startValidPos ≠ str.endValidPos) : IO Unit</code>",
 "5966":
 "<code>dbgTraceIfShared.{u} {α : Type u} (s : String) (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Display the given message if `a` is shared, that is, RC(a) &gt; 1 </code>",
 "5965":
 "<code>Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody {α : Type} {m : Type → Type} [Monad m]\n  [MonadReaderOf Lean.SubExpr m] [MonadWithReaderOf Lean.SubExpr m] [MonadControlT Lean.MetaM m] (n : Lean.Name)\n  (x : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Assumes the `SubExpr` is a lambda or forall.\nCreates a local declaration for this binder using the name `n`, enters the binding body, and evaluates `x`.\n</code>",
 "5964":
 "<code>Lean.PrettyPrinter.Delaborator.SubExpr.withAppFnArgs {α : Type} {m : Type → Type} [Monad m]\n  [MonadReaderOf Lean.SubExpr m] [MonadWithReaderOf Lean.SubExpr m] (xf : m α) (xa : α → m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Uses `xa` to compute the fold across the arguments of an application,\nwhere `xf` provides the initial value and is evaluated in the context of the head of the application.\n</code>",
 "5963":
 "<code>Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg {α : Type} {m : Type → Type} [Monad m] [MonadReaderOf Lean.SubExpr m]\n  [MonadWithReaderOf Lean.SubExpr m] (x : m α) : m α</code>",
 "5962":
 "<code>Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn {α : Type} {m : Type → Type} [Monad m] [MonadReaderOf Lean.SubExpr m]\n  [MonadWithReaderOf Lean.SubExpr m] (x : m α) : m α</code>",
 "5961":
 "<code>Lean.PrettyPrinter.Delaborator.SubExpr.getExpr {m : Type → Type} [Monad m] [MonadReaderOf Lean.SubExpr m] : m Expr</code>",
 "5960":
 "<code>Lean.Expr.mdata (data : Lean.MData) (expr : Expr) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">Metadata (aka annotations).\n\nWe use annotations to provide hints to the pretty-printer,\nstore references to `Syntax` nodes, position information, and save information for\nelaboration procedures (e.g., we use the `inaccessible` annotation during elaboration to\nmark `Expr`s that correspond to inaccessible patterns).\n\nNote that `Expr.mdata data e` is definitionally equal to `e`.\n</code>",
 "596":
 "<code>Lean.Parser.Command.inductive : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List α` is the list of elements of type `α`, and is defined as follows:\n```\ninductive List (α : Type u) where\n| nil\n| cons (head : α) (tail : List α)\n```\nA list of elements of type `α` is either the empty list, `nil`,\nor an element `head : α` followed by a list `tail : List α`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>",
 "5959": "<code class=\"docstring\">Register a delaborator</code>",
 "5958": "<code>Lean.PrettyPrinter.Delaborator.DelabM (α : Type) : Type</code>",
 "5957": "<code>Lean.PrettyPrinter.Delaborator.Delab : Type</code>",
 "5956": "<code>unexpandListCursor : Unexpander</code>",
 "5955": "<code>List Nat</code>",
 "5954":
 "<code>Lean.Syntax.TSepArray (ks : Lean.SyntaxNodeKinds) (sep : String) : Type</code><span class=\"sep\"></span><code class=\"docstring\">An array of syntax elements that alternate with the given separator. Each syntax element has a kind\ndrawn from `ks`.\n\nSeparator arrays result from repetition operators such as `,*`.\n[Coercions](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=coercions) to and from `Array (TSyntax ks)` insert or remove\nseparators as required. The untyped equivalent is `Lean.Syntax.SepArray`.\n</code>",
 "5953": "<code><span class=\"literal string\">\" 🚩 \"</span> : String</code>",
 "5952":
 "<code>ListCursor.fastForward.{u_1} {α : Type u_1} : ListCursor α → ListCursor α</code>",
 "5951": "<code>ListCursor α</code>",
 "5950":
 "<code>ListCursor.rewind.{u_1} {α : Type u_1} : ListCursor α → ListCursor α</code>",
 "595":
 "<code>bootstrap.inductiveCheckResultingUniverse</code><span class=\"sep\"></span><code class=\"docstring\">by default the `inductive`/`structure` commands report an error if the resulting universe is not zero, but may be zero for some universe parameters. Reason: unless this type is a subsingleton, it is hardly what the user wants since it can only eliminate into `Prop`. In the `Init` package, we define subsingletons, and we use this option to disable the check. This option may be deleted in the future after we improve the validator</code>",
 "5949":
 "<code>ListCursor.right.{u_1} {α : Type u_1} : ListCursor α → Option (ListCursor α)</code>",
 "5948":
 "<code>ListCursor.mk.{u_1} {α : Type u_1} (before after : List α) : ListCursor α</code>",
 "5947":
 "<code>ListCursor.left.{u_1} {α : Type u_1} : ListCursor α → Option (ListCursor α)</code>",
 "5946":
 "<code>ListCursor.after.{u_1} {α : Type u_1} (self : ListCursor α) : List α</code>",
 "5945":
 "<code>ListCursor.before.{u_1} {α : Type u_1} (self : ListCursor α) : List α</code>",
 "5944": "<code>ListCursor.{u_1} (α : Type u_1) : Type u_1</code>",
 "5943": "<code>unexpandSolo : Unexpander</code>",
 "5942": "<code>Solo</code>",
 "5941": "<code><span class=\"literal string\">\"›\"</span> : String</code>",
 "5940": "<code><span class=\"literal string\">\"‹\"</span> : String</code>",
 "594":
 "<code>PEmpty.{u} : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">The universe-polymorphic empty type, with no constructors.\n\n`PEmpty` can be used in any universe, but this flexibility can lead to worse error messages and more\nchallenges with universe level unification. Prefer the type `Empty` or the proposition `False` when\npossible.\n</code>",
 "5939": "<code>Solo.mk : Solo</code>",
 "5938":
 "<code class=\"docstring\">Register an unexpander for applications of a given constant.</code>",
 "5937":
 "<code>Lean.PrettyPrinter.UnexpandM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The unexpander monad, essentially `Syntax → Option α`. The `Syntax` is the `ref`,\nand it has the possibility of failure without an error message.\n</code>",
 "5936":
 "<code>Lean.PrettyPrinter.Unexpander : Type</code><span class=\"sep\"></span><code class=\"docstring\">Function that tries to reverse macro expansions as a post-processing step of delaboration.\nWhile less general than an arbitrary delaborator, it can be declared without importing `Lean`.\nUsed by the `[app_unexpander]` attribute.\n</code>",
 "5935":
 "<code>pp.notation</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) disable/enable notation (infix, mixfix, postfix operators and unicode characters)</code>",
 "5934":
 "<code><span class=\"literal string\">\"It was \"</span> : String</code>",
 "5933":
 "<code><span class=\"literal string\">\"It was y\"</span> : String</code>",
 "5932":
 "<code class=\"docstring\">Macro for throwing error exceptions. The argument can be an interpolated string.\nIt is a convenient way of building `MessageData` objects.\nThe result of `getRef` is used as position information.\nRecall that `getRef` returns the current \"reference\" syntax.\n</code>",
 "5931":
 "<code>Lean.getLocalHyps {m : Type → Type} [Monad m] [MonadLCtx m] : m (Array Expr)</code><span class=\"sep\"></span><code class=\"docstring\">Return local hypotheses which are not \"implementation detail\", as `Expr`s. </code>",
 "5930": "<code>Array Expr</code>",
 "593": "<code>Fix : (Type → Type) → Type</code>",
 "5929":
 "<code><span class=\"literal string\">\"anything!\"</span> : String</code>",
 "5928":
 "<code>Lean.getLocalHyps {m : Type → Type} [Monad m] [Lean.MonadLCtx m] : m (Array Lean.Expr)</code><span class=\"sep\"></span><code class=\"docstring\">Return local hypotheses which are not \"implementation detail\", as `Expr`s. </code>",
 "5927":
 "<code><span class=\"literal string\">\"not a type\"</span> : String</code>",
 "5926":
 "<code class=\"docstring\">Macro for throwing error exceptions. The argument can be an interpolated string.\nIt is a convenient way of building `MessageData` objects.\nThe first argument must be a `Syntax` that provides position information for\nthe error message.\n`throwErrorAt ref msg` is equivalent to `withRef ref &lt;| throwError msg`\n</code>",
 "5925":
 "<code>Lean.Meta.isDefEq (t s : Expr) : MetaM Bool</code><span class=\"sep\"></span><code class=\"docstring\">Determines whether two expressions are definitionally equal to each other.\n\nTo control how metavariables are assigned and unified, metavariables and their context have a \"depth\".\nGiven a metavariable `?m` and a `MetavarContext` `mctx`, `?m` is not assigned if `?m.depth != mctx.depth`.\nThe combinator `withNewMCtxDepth x` will bump the depth while executing `x`.\nSo, `withNewMCtxDepth (isDefEq a b)` is `isDefEq` without any mvar assignment happening\nwhereas `isDefEq a b` will assign any metavariables of the current depth in `a` and `b` to unify them.\n\nFor matching (where only mvars in `b` should be assigned), we create the term inside the `withNewMCtxDepth`.\nFor an example, see [Lean.Meta.Simp.tryTheoremWithExtraArgs?](https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Tactic/Simp/Rewrite.lean#L100-L106)\n</code>",
 "5924":
 "<code>Lean.Meta.inferType : Expr → MetaM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns the inferred type of the given expression. Assumes the expression is type-correct.\n\nThe type inference algorithm does not do general type checking.\nType inference only looks at subterms that are necessary for determining an expression's type,\nand as such if `inferType` succeeds it does *not* mean the term is type-correct.\nIf an expression is sufficiently ill-formed that it prevents `inferType` from computing a type,\nthen it will fail with a type error.\n\nFor typechecking during elaboration, see `Lean.Meta.check`.\n(Note that we do not guarantee that the elaborator typechecker is as correct or as efficient as\nthe kernel typechecker. The kernel typechecker is invoked when a definition is added to the environment.)\n\nHere are examples of type-incorrect terms for which `inferType` succeeds:\n```lean\npublic import Lean\n\npublic section\n\nopen Lean Meta\n\n/--\n`@id.{1} Bool Nat.zero`.\nIn general, the type of `@id α x` is `α`.\n-/\ndef e1 : Expr := mkApp2 (.const ``id [1]) (.const ``Bool []) (.const ``Nat.zero [])\n#eval inferType e1\n-- Lean.Expr.const `Bool []\n#eval check e1\n-- error: application type mismatch\n\n/--\n`let x : Int := Nat.zero; true`.\nIn general, the type of `let x := v; e`, if `e` does not reference `x`, is the type of `e`.\n-/\ndef e2 : Expr := .letE `x (.const ``Int []) (.const ``Nat.zero []) (.const ``true []) false\n#eval inferType e2\n-- Lean.Expr.const `Bool []\n#eval check e2\n-- error: invalid let declaration\n```\nHere is an example of a type-incorrect term that makes `inferType` fail:\n```lean\n/--\n`Nat.zero Nat.zero`\n-/\ndef e3 : Expr := .app (.const ``Nat.zero []) (.const ``Nat.zero [])\n#eval inferType e3\n-- error: function expected\n```\n\nSee `Lean.Meta.inferTypeImp` for the implementation of `inferType`.\n</code>",
 "5923":
 "<code>Lean.Elab.Term.elabTerm (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone implicitLambda : Bool := true) :\n  TermElabM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Main function for elaborating terms.\nIt extracts the elaboration methods from the environment using the node kind.\nRecall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.\nIt creates a fresh macro scope for executing the elaboration method.\nAll unlogged trace messages produced by the elaboration method are logged using\nthe position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,\nthe error is logged and a synthetic sorry expression is returned.\nIf the elaboration throws `Exception.postpone` and `catchExPostpone == true`,\na new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,\nand returned.\nThe option `catchExPostpone == false` is used to implement `resumeElabTerm`\nto prevent the creation of another synthetic metavariable when resuming the elaboration.\n\nIf `implicitLambda == false`, then disable implicit lambdas feature for the given syntax, but not for its subterms.\nWe use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.\n</code>",
 "5922":
 "<code>Lean.Elab.Term.elabType (stx : Syntax) : TermElabM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Elaborate `stx` and ensure result is a type. </code>",
 "5921":
 "<code>Lean.Elab.throwUnsupportedSyntax.{u_1, u_2} {m : Type u_1 → Type u_2} {α : Type u_1} [MonadExceptOf Exception m] : m α</code>",
 "5920": "<code>elabNotType : TermElab</code>",
 "592": "<code>Type u → Type u</code>",
 "5919": "<code><span class=\"literal string\">\" !: \"</span> : String</code>",
 "5918": "<code>notType : ParserDescr</code>",
 "5917":
 "<code>Lean.Meta.isDefEq (t s : Lean.Expr) : Lean.MetaM Bool</code><span class=\"sep\"></span><code class=\"docstring\">Determines whether two expressions are definitionally equal to each other.\n\nTo control how metavariables are assigned and unified, metavariables and their context have a \"depth\".\nGiven a metavariable `?m` and a `MetavarContext` `mctx`, `?m` is not assigned if `?m.depth != mctx.depth`.\nThe combinator `withNewMCtxDepth x` will bump the depth while executing `x`.\nSo, `withNewMCtxDepth (isDefEq a b)` is `isDefEq` without any mvar assignment happening\nwhereas `isDefEq a b` will assign any metavariables of the current depth in `a` and `b` to unify them.\n\nFor matching (where only mvars in `b` should be assigned), we create the term inside the `withNewMCtxDepth`.\nFor an example, see [Lean.Meta.Simp.tryTheoremWithExtraArgs?](https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Tactic/Simp/Rewrite.lean#L100-L106)\n</code>",
 "5916":
 "<code>Lean.Meta.inferType : Lean.Expr → Lean.MetaM Lean.Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns the inferred type of the given expression. Assumes the expression is type-correct.\n\nThe type inference algorithm does not do general type checking.\nType inference only looks at subterms that are necessary for determining an expression's type,\nand as such if `inferType` succeeds it does *not* mean the term is type-correct.\nIf an expression is sufficiently ill-formed that it prevents `inferType` from computing a type,\nthen it will fail with a type error.\n\nFor typechecking during elaboration, see `Lean.Meta.check`.\n(Note that we do not guarantee that the elaborator typechecker is as correct or as efficient as\nthe kernel typechecker. The kernel typechecker is invoked when a definition is added to the environment.)\n\nHere are examples of type-incorrect terms for which `inferType` succeeds:\n```lean\npublic import Lean\n\npublic section\n\nopen Lean Meta\n\n/--\n`@id.{1} Bool Nat.zero`.\nIn general, the type of `@id α x` is `α`.\n-/\ndef e1 : Expr := mkApp2 (.const ``id [1]) (.const ``Bool []) (.const ``Nat.zero [])\n#eval inferType e1\n-- Lean.Expr.const `Bool []\n#eval check e1\n-- error: application type mismatch\n\n/--\n`let x : Int := Nat.zero; true`.\nIn general, the type of `let x := v; e`, if `e` does not reference `x`, is the type of `e`.\n-/\ndef e2 : Expr := .letE `x (.const ``Int []) (.const ``Nat.zero []) (.const ``true []) false\n#eval inferType e2\n-- Lean.Expr.const `Bool []\n#eval check e2\n-- error: invalid let declaration\n```\nHere is an example of a type-incorrect term that makes `inferType` fail:\n```lean\n/--\n`Nat.zero Nat.zero`\n-/\ndef e3 : Expr := .app (.const ``Nat.zero []) (.const ``Nat.zero [])\n#eval inferType e3\n-- error: function expected\n```\n\nSee `Lean.Meta.inferTypeImp` for the implementation of `inferType`.\n</code>",
 "5915":
 "<code>Lean.Elab.Term.elabType (stx : Lean.Syntax) : Lean.Elab.TermElabM Lean.Expr</code><span class=\"sep\"></span><code class=\"docstring\">Elaborate `stx` and ensure result is a type. </code>",
 "5914": "<code class=\"docstring\">term elaborator</code>",
 "5913": "<code>Lean.Elab.Term.TermElab : Type</code>",
 "5912":
 "<code><span class=\"literal string\">\"Another one\"</span> : String</code>",
 "5911": "<code>NS.interestingName : String</code>",
 "5910": "<code>interestingName : Nat</code>",
 "591": "<code>(Type u → Type u) → Type u</code>",
 "5909":
 "<code>Lean.logInfoAt {m : Type → Type} [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m] (ref : Syntax)\n  (msgData : MessageData) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Log a new information message using the given message data. The position is provided by `ref`. </code>",
 "5908": "<code>Lean.Name.isSuffixOf : Name → Name → Bool</code>",
 "5907":
 "<code>Lean.Environment.constants (env : Environment) : ConstMap</code><span class=\"sep\"></span><code class=\"docstring\">Mapping from constant name to `ConstantInfo`. It contains all constants (definitions, theorems,\naxioms, etc) that have been already type checked by the kernel.\n</code>",
 "5906":
 "<code>Lean.TSyntax.getId (s : Ident) : Name</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the parsed name from the syntax of an identifier.\n\nReturns `Name.anonymous` if the syntax is malformed.\n</code>",
 "5905": "<code>TSyntax `ident</code>",
 "5904": "<code>Syntax</code>",
 "5903":
 "<code>Lean.Parser.Category.command : Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`command` is the syntax category for things that appear at the top level\nof a lean file. For example, `def foo := 1` is a `command`, as is\n`namespace Foo` and `end Foo`. Commands generally have an effect on the state of\nadding something to the environment (like a new definition), as well as\ncommands like `variable` which modify future commands within a scope. </code>",
 "5902":
 "<code>Lean.Parser.ident : Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `ident` parses a single identifier, possibly with namespaces, such as `foo` or\n`bar.baz`. The identifier must not be a declared token, so for example it will not match `\"def\"`\nbecause `def` is a keyword token. Tokens are implicitly declared by using them in string literals\nin parser declarations, so `syntax foo := \"bla\"` will make `bla` no longer legal as an identifier.\n\nIdentifiers can contain special characters or keywords if they are escaped using the `«»` characters:\n`«def»` is an identifier named `def`, and `«x»` is treated the same as `x`. This is useful for\nusing disallowed characters in identifiers such as `«foo.bar».baz` or `«hello world»`.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getId` to extract the name from the resulting syntax object. </code>",
 "5901":
 "<code><span class=\"literal string\">\"#count_constants \"</span> : String</code>",
 "5900":
 "<code>Lean.logInfoAt {m : Type → Type} [Monad m] [Lean.MonadLog m] [Lean.AddMessageContext m] [Lean.MonadOptions m]\n  (ref : Lean.Syntax) (msgData : Lean.MessageData) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Log a new information message using the given message data. The position is provided by `ref`. </code>",
 "590": "<code>Bad.bad : (Bad → Bad) → Bad</code>",
 "59": "<code class=\"docstring\">The universe parameter u</code>",
 "5899":
 "<code>Lean.Environment.constants (env : Lean.Environment) : Lean.ConstMap</code><span class=\"sep\"></span><code class=\"docstring\">Mapping from constant name to `ConstantInfo`. It contains all constants (definitions, theorems,\naxioms, etc) that have been already type checked by the kernel.\n</code>",
 "5898": "<code>Lean.MonadEnv (m : Type → Type) : Type</code>",
 "5897":
 "<code>Lean.MonadEnv.getEnv {m : Type → Type} [self : Lean.MonadEnv m] : m Lean.Environment</code>",
 "5896": "<code class=\"docstring\">command elaborator</code>",
 "5895": "<code>Lean.Elab.Command.CommandElab : Type</code>",
 "5894":
 "<code>Lean.Expr : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lean expressions. This data structure is used in the kernel and\nelaborator. However, expressions sent to the kernel should not\ncontain metavariables.\n\nRemark: we use the `E` suffix (short for `Expr`) to avoid collision with keywords.\nWe considered using «...», but it is too inconvenient to use.\n</code>",
 "5893":
 "<code>Lean.TSyntax.getNat (s : NumLit) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a numeric literal as a natural number.\n\nReturns `0` if the syntax is malformed.\n</code>",
 "5892":
 "<code>Array.mkArray.{u} {α : Type u} (n : Nat) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Creates an array that contains `n` repetitions of `v`.\n\nThe corresponding `List` function is `List.replicate`.\n\nExamples:\n* `Array.mkArray 2 true = #[true, true]`\n* `Array.mkArray 3 () = #[(), (), ()]`\n* `Array.mkArray 0 \"anything\" = #[]`\n</code>",
 "5891":
 "<code>Lean.Macro : Type</code><span class=\"sep\"></span><code class=\"docstring\">A `macro` has type `Macro`, which is a `Syntax → MacroM Syntax`: it\nreceives an input syntax and is supposed to \"expand\" it into another piece of\nsyntax.\n</code>",
 "5890": "<code>expandRep : Macro</code>",
 "589": "<code>Bad : Type</code>",
 "5889":
 "<code><span class=\"literal string\">\" !!! \"</span> : String</code>",
 "5888":
 "<code>Lean.Parser.numLit : Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `num` parses a numeric literal in several bases:\n\n* Decimal: `129`\n* Hexadecimal: `0xdeadbeef`\n* Octal: `0o755`\n* Binary: `0b1101`\n\nThis parser has arity 1: it produces a `numLitKind` node containing an atom with the text of the\nliteral.\nYou can use `TSyntax.getNat` to extract the number from the resulting syntax object. </code>",
 "5887":
 "<code>rep : ParserDescr</code><span class=\"sep\"></span><code class=\"docstring\">Generate a list based on N syntactic copies of a term </code>",
 "5886":
 "<code>Lean.Name.anonymous : Name</code><span class=\"sep\"></span><code class=\"docstring\">The \"anonymous\" name. </code>",
 "5885":
 "<code><span class=\"literal string\">\"arbitrary! \"</span> : String</code>",
 "5884": "<code>«arbitrary!» : Lean.ParserDescr</code>",
 "5883":
 "<code>Lean.Syntax.getHeadInfo (stx : Syntax) : Lean.SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">Retrieve the left-most leaf's info in the Syntax tree, or `none` if there is no token. </code>",
 "5882":
 "<code>Lean.Syntax.mkNumLit (val : String) (info : Lean.SourceInfo := Lean.SourceInfo.none) : Lean.NumLit</code>",
 "5881":
 "<code>Lean.Macro.throwUnsupported {α : Type} : MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an `unsupportedSyntax` exception. </code>",
 "5880":
 "<code>Lean.TSyntax.getNat (s : Lean.NumLit) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a numeric literal as a natural number.\n\nReturns `0` if the syntax is malformed.\n</code>",
 "588": "<code>Prop</code>",
 "5879": "<code>Lean.TSyntax `num</code>",
 "5878":
 "<code>addFirstThird.{u_1} {α : Type u_1} [Add α] (xs : List α) : Option α</code>",
 "5877": "<code>Lean.TSyntaxArray `term</code>",
 "5876": "<code>idiom : Lean.ParserDescr</code>",
 "5875": "<code>Option Term</code>",
 "5874":
 "<code>mkStx {m : Type → Type} [Monad m] [MonadQuotation m] (e : Option Term) : m Term</code>",
 "5873": "<code><span class=\"literal string\">\" |⟩\"</span> : String</code>",
 "5872": "<code><span class=\"literal string\">\"⟨| \"</span> : String</code>",
 "5871": "<code>Syntax.TSepArray `num \"**\"</code>",
 "5870": "<code>Syntax.TSepArray `num \"—\"</code>",
 "587": "<code>Spurious (α : Type 5) : Type</code>",
 "5869": "<code><span class=\"literal string\">\" ** \"</span> : String</code>",
 "5868": "<code><span class=\"literal string\">\"⟧\"</span> : String</code>",
 "5867": "<code><span class=\"literal string\">\" — \"</span> : String</code>",
 "5866":
 "<code>Lean.Parser.numLit : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `num` parses a numeric literal in several bases:\n\n* Decimal: `129`\n* Hexadecimal: `0xdeadbeef`\n* Octal: `0o755`\n* Binary: `0b1101`\n\nThis parser has arity 1: it produces a `numLitKind` node containing an atom with the text of the\nliteral.\nYou can use `TSyntax.getNat` to extract the number from the resulting syntax object. </code>",
 "5865": "<code><span class=\"literal string\">\"⟦\"</span> : String</code>",
 "5864": "<code>ex3 (size : Nat) : CommandElabM Unit</code>",
 "5863": "<code>Array (TSyntax `term)</code>",
 "5862":
 "<code>ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Array (TSyntax `term)) : m (TSyntax `term)</code>",
 "5861": "<code><span class=\"literal string\">\",\"</span> : String</code>",
 "5860":
 "<code>Lean.Syntax.TSepArray (ks : SyntaxNodeKinds) (sep : String) : Type</code><span class=\"sep\"></span><code class=\"docstring\">An array of syntax elements that alternate with the given separator. Each syntax element has a kind\ndrawn from `ks`.\n\nSeparator arrays result from repetition operators such as `,*`.\n[Coercions](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=coercions) to and from `Array (TSyntax ks)` insert or remove\nseparators as required. The untyped equivalent is `Lean.Syntax.SepArray`.\n</code>",
 "586": "<code>CanRepr.mk.{u} (α : Type u) [Repr α] : CanRepr</code>",
 "5859": "<code>Syntax.TSepArray `term \",\"</code>",
 "5858":
 "<code>ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Syntax.TSepArray `term \",\") : m (TSyntax `term)</code>",
 "5857":
 "<code>Lean.Syntax.node3 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ a₂ a₃ : Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 3 children </code>",
 "5856":
 "<code>Lean.TSyntax.raw {ks : Lean.SyntaxNodeKinds} (self : Lean.TSyntax ks) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "5855":
 "<code>Lean.Syntax.node2 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ a₂ : Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 2 children </code>",
 "5854":
 "<code>Lean.Syntax.node1 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ : Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 1 child </code>",
 "5853":
 "<code>f {m : Type → Type} [Monad m] [Lean.MonadQuotation m] (x : Lean.Term) (n : Nat) : m Syntax</code>",
 "5852":
 "<code>Lean.TSyntax.raw {ks : Lean.SyntaxNodeKinds} (self : Lean.TSyntax ks) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "5851":
 "<code>Lean.Syntax.node3 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 3 children </code>",
 "5850":
 "<code><span class=\"literal string\">\"=&gt;\"</span> : String</code>",
 "585": "<code>CanRepr.{u} : Type (u + 1)</code>",
 "5849":
 "<code>Array.mkArray0.{u} {α : Type u} : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Create array `#[]` </code>",
 "5848":
 "<code>Lean.Syntax.node (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (args : Array Syntax) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A node in the syntax tree that may have further syntax as child nodes. The node's `kind`\ndetermines its interpretation.\n\nFor nodes produced by the parser, the `info` field is typically `Lean.SourceInfo.none`, and source\ninformation is stored in the corresponding fields of identifiers and atoms. This field is used in\ntwo ways:\n 1. The delaborator uses it to associate nodes with metadata that are used to implement\n    interactive features.\n 2. Nodes created by quotations use the field to mark the syntax as synthetic (storing the result\n    of `Lean.SourceInfo.fromRef`) even when its leading or trailing tokens are not.\n</code>",
 "5847":
 "<code>Lean.addMacroScope (ctx n : Lean.Name) (scp : Lean.MacroScope) : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">Add a new macro scope onto the name `n`, in the given `ctx`. </code>",
 "5846":
 "<code>String.toSubstring' (s : String) : Substring</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `String` into a `Substring` that denotes the entire string.\n\nThis is a version of `String.toSubstring` that doesn't have an `@[inline]` annotation.\n</code>",
 "5845": "<code><span class=\"literal string\">\"k\"</span> : String</code>",
 "5844":
 "<code>Lean.Syntax.ident (info : Lean.SourceInfo) (rawVal : Substring) (val : Lean.Name)\n  (preresolved : List Syntax.Preresolved) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">An identifier.\n\nIn addition to source information, identifiers have the following fields:\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed Lean name, potentially including macro scopes.\n* `preresolved` is the list of possible declarations this could refer to, populated by\n  [quotations](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=quasiquotation).\n</code>",
 "5843":
 "<code>Lean.Syntax.node1 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ : Syntax) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 1 child </code>",
 "5842":
 "<code>Lean.Syntax.node4 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ a₂ a₃ a₄ : Syntax) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 4 children </code>",
 "5841": "<code><span class=\"literal string\">\"fun\"</span> : String</code>",
 "5840":
 "<code>Lean.Syntax.atom (info : Lean.SourceInfo) (val : String) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A non-identifier atomic component of syntax.\n\nAll of the following are atoms:\n * keywords, such as `def`, `fun`, and `inductive`\n * literals, such as numeric or string literals\n * punctuation and delimiters, such as `(`, `)`, and `=&gt;`.\n\nIdentifiers are represented by the `Lean.Syntax.ident` constructor. Atoms also correspond to\nquoted strings inside `syntax` declarations.\n</code>",
 "584":
 "<code>Either.inr.{u, v} {α : Type u} {β : Type v} : β → Either α β</code>",
 "5839":
 "<code>Lean.Syntax.node2 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 2 children </code>",
 "5838":
 "<code>Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "5837":
 "<code>Lean.TSyntax.mk {ks : Lean.SyntaxNodeKinds} (raw : Syntax) : Lean.TSyntax ks</code>",
 "5836":
 "<code>Lean.MonadQuotation.getContext {m : Type → Type} [self : Lean.MonadQuotation m] : m Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">Get the context name used in Note `Macro Scope Representation`. </code>",
 "5835":
 "<code>Lean.MonadQuotation.getCurrMacroScope {m : Type → Type} [self : Lean.MonadQuotation m] : m Lean.MacroScope</code><span class=\"sep\"></span><code class=\"docstring\">Get the fresh scope of the current macro invocation </code>",
 "5834": "<code>Lean.MacroScope</code>",
 "5833":
 "<code>Lean.MonadRef.mkInfoFromRefPos {m : Type → Type} [Monad m] [Lean.MonadRef m] : m Lean.SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">Construct a synthetic `SourceInfo` from the `ref` in the monad state. </code>",
 "5832": "<code>Lean.Term</code>",
 "5831":
 "<code>f {m : Type → Type} [Monad m] [MonadQuotation m] (x : Term) (n : Nat) : m Syntax</code>",
 "5830":
 "<code>f {m : Type → Type} [Monad m] [Lean.MonadQuotation m] (x : Lean.Term) (n : Nat) : m Lean.Syntax</code>",
 "583":
 "<code>Either.inl.{u, v} {α : Type u} {β : Type v} : α → Either α β</code>",
 "5829": "<code>TSyntax `num</code>",
 "5828":
 "<code>ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `num) : m (TSyntax `term)</code>",
 "5827":
 "<code>ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `term) : m (TSyntax `term)</code>",
 "5826": "<code>Term</code>",
 "5825":
 "<code>Lean.Quote.quote {α : Type} {k : optParam Lean.SyntaxNodeKind `term} [self : Lean.Quote α k] : α → Lean.TSyntax k</code>",
 "5824": "<code>SyntaxNodeKinds</code>",
 "5823":
 "<code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class=\"sep\"></span><code class=\"docstring\">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.\nThis is used to keep track of the location where we are working; if an exception\nis thrown, the `ref` gives the location where the error will be reported,\nassuming no more specific location is provided.\n</code>",
 "5822":
 "<code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class=\"sep\"></span><code class=\"docstring\">A monad that supports syntax quotations. Syntax quotations (in term\nposition) are monadic values that when executed retrieve the current \"macro\nscope\" from the monad and apply it to every identifier they introduce\n(independent of whether this identifier turns out to be a reference to an\nexisting declaration, or an actually fresh binding during further\nelaboration). We also apply the position of the result of `getRef` to each\nintroduced symbol, which results in better error positions than not applying\nany position. </code>",
 "5821":
 "<code><span class=\"literal string\">\"hello!\"</span> : String</code>",
 "5820": "<code>Lean.MacroM α</code>",
 "582": "<code>x = y</code>",
 "5819":
 "<code>Verso.Genre.Manual.ref : Verso.Doc.Elab.RoleExpanderOf RoleArgs</code><span class=\"sep\"></span><code class=\"docstring\">Inserts a reference to the provided tag.\n</code>",
 "5818":
 "<code>Lean.Macro.Exception : Type</code><span class=\"sep\"></span><code class=\"docstring\">An exception in the `MacroM` monad. </code>",
 "5817":
 "<code>Lean.Macro.throwErrorAt {α : Type} (ref : Lean.Syntax) (msg : String) : Lean.MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an error with the given message and location information. </code>",
 "5816":
 "<code>Lean.Macro.throwError {α : Type} (msg : String) : Lean.MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an error with the given message,\nusing the `ref` for the location information.\n</code>",
 "5815":
 "<code><span class=\"literal string\">\"'5' is not allowed here\"</span> : String</code>",
 "5814":
 "<code>Lean.Macro.throwError {α : Type} (msg : String) : MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an error with the given message,\nusing the `ref` for the location information.\n</code>",
 "5813":
 "<code>Lean.Parser.Category.term : Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`term` is the builtin syntax category for terms. A term denotes an expression\nin lean's type theory, for example `2 + 2` is a term. The difference between\n`Term` and `Expr` is that the former is a kind of syntax, while the latter is\nthe result of elaboration. For example `by simp` is also a `Term`, but it elaborates\nto different `Expr`s depending on the context. </code>",
 "5812":
 "<code><span class=\"literal string\">\"notFive\"</span> : String</code>",
 "5811":
 "<code>Lean.Macro.Exception.unsupportedSyntax : Lean.Macro.Exception</code><span class=\"sep\"></span><code class=\"docstring\">An unsupported syntax exception. We keep this separate because it is\nused for control flow: if one macro does not support a syntax then we try\nthe next one. </code>",
 "5810":
 "<code>Lean.MacroM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The `MacroM` monad is the main monad for macro expansion. It has the\ninformation needed to handle hygienic name generation, and is the monad that\n`macro` definitions live in.\n\nNotably, this is a (relatively) pure monad: there is no `IO` and no access to\nthe `Environment`. That means that things like declaration lookup are\nimpossible here, as well as `IO.Ref` or other side-effecting operations.\nFor more capabilities, macros can instead be written as `elab` using `adaptExpander`.\n</code>",
 "581": "<code>motive x ⋯</code>",
 "5809": "<code><span class=\"literal string\">\"Two\"</span> : String</code>",
 "5808": "<code><span class=\"literal string\">\"One\"</span> : String</code>",
 "5807":
 "<code>Lean.Parser.strLit : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `str` parses a string literal, such as `\"foo\"` or `\"\\r\\n\"`. Strings can contain\nC-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters like `∈`.\nNewlines in a string are interpreted literally.\n\nThis parser has arity 1: it produces a `strLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getString` to decode the string from the resulting syntax object. </code>",
 "5806": "<code><span class=\"literal string\">\"◦ \"</span> : String</code>",
 "5805":
 "<code>Lean.Parser.ppLine : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">No-op parser that advises the pretty printer to emit a hard line break. </code>",
 "5804":
 "<code><span class=\"literal string\">\"note \"</span> : String</code>",
 "5803":
 "<code class=\"docstring\">The `lineEq` parser requires that the current token is on the same line as the saved position\n(see `withPosition`). This can be used to ensure that composite tokens are not \"broken up\" across\ndifferent lines. For example, `else if` is parsed using `lineEq` to ensure that the two tokens\nare on the same line.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "5802":
 "<code class=\"docstring\">The `colEq` parser ensures that the next token starts at exactly the column of the saved\nposition (see `withPosition`). This can be used to do whitespace sensitive syntax like\na `by` block or `do` block, where all the lines have to line up.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "5801":
 "<code class=\"docstring\">The `colGe` parser requires that the next token starts from at least the column of the saved\nposition (see `withPosition`), but allows it to be more indented.\nThis can be used for whitespace sensitive syntax to ensure that a block does not go outside a\ncertain indentation scope. For example it is used in the lean grammar for `else if`, to ensure\nthat the `else` is not less indented than the `if` it matches with.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "5800":
 "<code class=\"docstring\">The `colGt` parser requires that the next token starts a strictly greater column than the saved\nposition (see `withPosition`). This can be used for whitespace sensitive syntax for the arguments\nto a tactic, to ensure that the following tactic is not interpreted as an argument.\n```\nexample (x : False) : False := by\n  revert x\n  exact id\n```\nHere, the `revert` tactic is followed by a list of `colGt ident`, because otherwise it would\ninterpret `exact` as an identifier and try to revert a variable named `exact`.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "580": "<code>(y : α) → x = y → Sort u</code>",
 "58": "<code>Type u</code>",
 "5799":
 "<code class=\"docstring\">`withoutPosition(p)` runs `p` without the saved position, meaning that position-checking\nparsers like `colGt` will have no effect. This is usually used by bracketing constructs like\n`(...)` so that the user can locally override whitespace sensitivity.\n\nThis parser has the same arity as `p` - it just forwards the results of `p`. </code>",
 "5798":
 "<code class=\"docstring\">`withPosition(p)` runs `p` while setting the \"saved position\" to the current position.\nThis has no effect on its own, but various other parsers access this position to achieve some\ncomposite effect:\n\n* `colGt`, `colGe`, `colEq` compare the column of the saved position to the current position,\n  used to implement Python-style indentation sensitive blocks\n* `lineEq` ensures that the current position is still on the same line as the saved position,\n  used to implement composite tokens\n\nThe saved position is only available in the read-only state, which is why this is a scoping parser:\nafter the `withPosition(..)` block the saved position will be restored to its original value.\n\nThis parser has the same arity as `p` - it just forwards the results of `p`. </code>",
 "5797":
 "<code>Lean.Parser.checkLineEq (errorMsg : String := \"checkLineEq\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `lineEq` parser requires that the current token is on the same line as the saved position\n(see `withPosition`). This can be used to ensure that composite tokens are not \"broken up\" across\ndifferent lines. For example, `else if` is parsed using `lineEq` to ensure that the two tokens\nare on the same line.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "5796":
 "<code>Lean.Parser.checkColEq (errorMsg : String := \"checkColEq\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `colEq` parser ensures that the next token starts at exactly the column of the saved\nposition (see `withPosition`). This can be used to do whitespace sensitive syntax like\na `by` block or `do` block, where all the lines have to line up.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "5795":
 "<code>Lean.Parser.checkColGe (errorMsg : String := \"checkColGe\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `colGe` parser requires that the next token starts from at least the column of the saved\nposition (see `withPosition`), but allows it to be more indented.\nThis can be used for whitespace sensitive syntax to ensure that a block does not go outside a\ncertain indentation scope. For example it is used in the lean grammar for `else if`, to ensure\nthat the `else` is not less indented than the `if` it matches with.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "5794":
 "<code>Lean.Parser.checkColGt (errorMsg : String := \"checkColGt\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `colGt` parser requires that the next token starts a strictly greater column than the saved\nposition (see `withPosition`). This can be used for whitespace sensitive syntax for the arguments\nto a tactic, to ensure that the following tactic is not interpreted as an argument.\n```\nexample (x : False) : False := by\n  revert x\n  exact id\n```\nHere, the `revert` tactic is followed by a list of `colGt ident`, because otherwise it would\ninterpret `exact` as an identifier and try to revert a variable named `exact`.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "5793":
 "<code>Lean.Parser.withPositionAfterLinebreak : Lean.Parser.Parser → Lean.Parser.Parser</code>",
 "5792":
 "<code>Lean.Parser.withPosition : Lean.Parser.Parser → Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">`withPosition(p)` runs `p` while setting the \"saved position\" to the current position.\nThis has no effect on its own, but various other parsers access this position to achieve some\ncomposite effect:\n\n* `colGt`, `colGe`, `colEq` compare the column of the saved position to the current position,\n  used to implement Python-style indentation sensitive blocks\n* `lineEq` ensures that the current position is still on the same line as the saved position,\n  used to implement composite tokens\n\nThe saved position is only available in the read-only state, which is why this is a scoping parser:\nafter the `withPosition(..)` block the saved position will be restored to its original value.\n\nThis parser has the same arity as `p` - it just forwards the results of `p`. </code>",
 "5791":
 "<code><span class=\"literal string\">\"Thistle\"</span> : String</code>",
 "5790":
 "<code><span class=\"literal string\">\"Dandelion\"</span> : String</code>",
 "579":
 "<code>Eq.rec.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} (refl : motive a✝ ⋯) {a✝¹ : α}\n  (t : a✝ = a✝¹) : motive a✝¹ t</code>",
 "5789": "<code>Lean.Syntax.TSepArray `term \",\"</code>",
 "5788": "<code><span class=\"literal string\">\"]]\"</span> : String</code>",
 "5787": "<code><span class=\"literal string\">\"[[\"</span> : String</code>",
 "5786":
 "<code>Lean.Parser.Category.term : Lean.Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`term` is the builtin syntax category for terms. A term denotes an expression\nin lean's type theory, for example `2 + 2` is a term. The difference between\n`Term` and `Expr` is that the former is a kind of syntax, while the latter is\nthe result of elaboration. For example `by simp` is also a `Term`, but it elaborates\nto different `Expr`s depending on the context. </code>",
 "5785":
 "<code><span class=\"literal string\">\"balanced \"</span> : String</code>",
 "5784": "<code>termBalanced : Lean.ParserDescr</code>",
 "5783": "<code>Lean.Parser.Category.balanced : Lean.Parser.Category</code>",
 "5782":
 "<code>Lean.Parser.LeadingIdentBehavior : Type</code><span class=\"sep\"></span><code class=\"docstring\">Specifies how the parsing table lookup function behaves for identifiers.\n\nThe function `Lean.Parser.prattParser` uses two tables: one each for leading and trailing parsers.\nThese tables map tokens to parsers. Because keyword tokens are distinct from identifier tokens,\nkeywords and identifiers cannot be confused, even when they are syntactically identical.\nSpecifying an alternative leading identifier behavior allows greater flexibility and makes it\npossible to avoid reserved keywords in some situations.\n\nWhen the leading token is syntactically an identifier, the current syntax category's\n`LeadingIdentBehavior` specifies how the parsing table lookup function behaves, and allows\ncontrolled “punning” between identifiers and keywords. This feature is used to avoid creating a\nreserved symbol for each built-in tactic (e.g., `apply` or `assumption`). As a result, tactic names\ncan be used as identifiers.\n</code>",
 "5781":
 "<code>Lean.Parser.prattParser (kind : Lean.Name) (tables : Lean.Parser.PrattParsingTables)\n  (behavior : Lean.Parser.LeadingIdentBehavior) (antiquotParser : Lean.Parser.ParserFn) : Lean.Parser.ParserFn</code><span class=\"sep\"></span><code class=\"docstring\">Implements a variant of Pratt's algorithm. In Pratt's algorithms tokens have a right and left binding power.\nIn our implementation, parsers have precedence instead. This method selects a parser (or more, via\n`longestMatchFn`) from `leadingTable` based on the current token. Note that the unindexed `leadingParsers` parsers\nare also tried. We have the unindexed `leadingParsers` because some parsers do not have a \"first token\". Example:\n```\nsyntax term:51 \"≤\" ident \"&lt;\" term \"|\" term : index\n```\nExample, in principle, the set of first tokens for this parser is any token that can start a term, but this set\nis always changing. Thus, this parsing rule is stored as an unindexed leading parser at `leadingParsers`.\nAfter processing the leading parser, we chain with parsers from `trailingTable`/`trailingParsers` that have precedence\nat least `c.prec` where `c` is the `ParsingContext`. Recall that `c.prec` is set by `categoryParser`.\n\nNote that in the original Pratt's algorithm, precedences are only checked before calling trailing parsers. In our\nimplementation, leading *and* trailing parsers check the precedence. We claim our algorithm is more flexible,\nmodular and easier to understand.\n\n`antiquotParser` should be a `mkAntiquot` parser (or always fail) and is tried before all other parsers.\nIt should not be added to the regular leading parsers because it would heavily\noverlap with antiquotation parsers nested inside them. </code>",
 "5780":
 "<code>Lean.Syntax.HygieneInfo : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents macro hygiene info.\n</code>",
 "578":
 "<code>Eq.refl.{u_1} {α : Sort u_1} (a : α) : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`Eq.refl a : a = a` is reflexivity, the unique constructor of the\nequality type. See also `rfl`, which is usually used instead. </code>",
 "5779": "<code>Lean.HygieneInfo</code>",
 "5778":
 "<code>Lean.Syntax.CharLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a character literal.\n</code>",
 "5777": "<code>Lean.CharLit</code>",
 "5776":
 "<code>Lean.Syntax.StrLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a string literal.\n</code>",
 "5775": "<code>Lean.StrLit</code>",
 "5774":
 "<code>Lean.Syntax.ScientificLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a scientific numeric literal that may have decimal and exponential parts.\n</code>",
 "5773": "<code>Lean.ScientificLit</code>",
 "5772":
 "<code>Lean.Syntax.NumLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a numeric literal.\n</code>",
 "5771": "<code>Lean.NumLit</code>",
 "5770":
 "<code>Lean.Name.anonymous : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The \"anonymous\" name. </code>",
 "577": "<code>a ∨ b</code>",
 "5769":
 "<code>Lean.Syntax.NameLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a quoted name literal that begins with a back-tick.\n</code>",
 "5768": "<code>Lean.NameLit</code>",
 "5767": "<code>Lean.Ident</code>",
 "5766":
 "<code>Array Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The array of elements and separators, ordered like\n`#[el1, sep1, el2, sep2, el3]`. </code>",
 "5765":
 "<code>Lean.Syntax.TSepArray.mk {ks : Lean.SyntaxNodeKinds} {sep : String} (elemsAndSeps : Array Lean.Syntax) :\n  Lean.Syntax.TSepArray ks sep</code>",
 "5764":
 "<code>Lean.Syntax.SepArray (sep : String) : Type</code><span class=\"sep\"></span><code class=\"docstring\">An array of syntax elements interspersed with the given separators.\n\nSeparator arrays result from repetition operators such as `,*`.\n[Coercions](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=coercions) to and from `Array Syntax` insert or remove separators\nas required.\n\nThe typed equivalent is `Lean.Syntax.TSepArray`.\n</code>",
 "5763":
 "<code>Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "5762":
 "<code>Lean.TSyntax.mk {ks : Lean.SyntaxNodeKinds} (raw : Lean.Syntax) : Lean.TSyntax ks</code>",
 "5761":
 "<code>Lean.SyntaxNodeKinds : Type</code><span class=\"sep\"></span><code class=\"docstring\">`SyntaxNodeKinds` is a set of `SyntaxNodeKind`, implemented as a list.\n\nSingleton `SyntaxNodeKinds` are extremely common. They are written as name literals, rather than as\nlists; list syntax is required only for empty or non-singleton sets of kinds.\n</code>",
 "5760": "<code>Lean.SyntaxNodeKinds</code>",
 "576":
 "<code>Or.inr {a b : Prop} (h : b) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a ∨ b`. </code>",
 "5759":
 "<code>Std.Format.pretty (f : Format) (width : Nat := Std.Format.defWidth) (indent column : Nat := 0) : String</code><span class=\"sep\"></span><code class=\"docstring\">Renders a `Format` to a string.\n* `width`: the total width\n* `indent`: the initial indentation to use for wrapped lines\n  (subsequent wrapping may increase the indentation)\n* `column`: begin the first line wrap `column` characters earlier than usual\n  (this is useful when the output String will be printed starting at `column`)\n</code>",
 "5758":
 "<code>Lean.logInfo {m : Type → Type} [Monad m] [Lean.MonadLog m] [Lean.AddMessageContext m] [Lean.MonadOptions m]\n  (msgData : Lean.MessageData) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Log a new information message using the given message data. The position is provided by `getRef`. </code>",
 "5757":
 "<code>Lean.ppTerm (ctx : PPContext) (stx : Term) : BaseIO Format</code>",
 "5756":
 "<code>Lean.MonadResolveName.getOpenDecls {m : Type → Type} [self : MonadResolveName m] : m (List OpenDecl)</code>",
 "5755": "<code>List OpenDecl</code>",
 "5754":
 "<code>Lean.MonadResolveName.getCurrNamespace {m : Type → Type} [self : MonadResolveName m] : m Name</code>",
 "5753": "<code>Name</code>",
 "5752":
 "<code>Lean.MonadOptions.getOptions {m : Type → Type} [self : MonadOptions m] : m Options</code>",
 "5751": "<code>Options</code>",
 "5750": "<code>Environment</code>",
 "575": "<code>∀ (h : b), motive ⋯</code>",
 "5749": "<code>Lean.PPContext : Type</code>",
 "5748": "<code>getPPContext : CommandElabM PPContext</code>",
 "5747":
 "<code>Lean.ppTerm (ctx : Lean.PPContext) (stx : Lean.Term) : BaseIO Std.Format</code>",
 "5746":
 "<code>Lean.Syntax.missing : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A portion of the syntax tree that is missing because of a parse error.\n\nThe indexing operator on `Syntax` also returns `Syntax.missing` when the index is out of bounds.\n</code>",
 "5745":
 "<code>Lean.Syntax.ident (info : Lean.SourceInfo) (rawVal : Substring) (val : Lean.Name)\n  (preresolved : List Lean.Syntax.Preresolved) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">An identifier.\n\nIn addition to source information, identifiers have the following fields:\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed Lean name, potentially including macro scopes.\n* `preresolved` is the list of possible declarations this could refer to, populated by\n  [quotations](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=quasiquotation).\n</code>",
 "5744": "<code><span class=\"literal string\">\"Lily\"</span> : String</code>",
 "5743":
 "<code><span class=\"literal string\">\"Daffodil\"</span> : String</code>",
 "5742": "<code><span class=\"literal string\">\"Rose\"</span> : String</code>",
 "5741":
 "<code>Lean.TSyntax.raw {ks : SyntaxNodeKinds} (self : TSyntax ks) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "5740":
 "<code>repr.{u_1} {α : Type u_1} [Repr α] (a : α) : Format</code><span class=\"sep\"></span><code class=\"docstring\">Turns `a` into a `Format` using its `Repr` instance. The precedence level is initially set to 0.\n</code>",
 "574":
 "<code>Or.inl {a b : Prop} (h : a) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ∨ b`. </code>",
 "5739":
 "<code>Lean.logInfo {m : Type → Type} [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m] (msgData : MessageData) :\n  m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Log a new information message using the given message data. The position is provided by `getRef`. </code>",
 "5738":
 "<code>Lean.TSyntax.mk {ks : SyntaxNodeKinds} (raw : Syntax) : TSyntax ks</code>",
 "5737": "<code>TSyntax `term</code>",
 "5736": "<code>Array Syntax</code>",
 "5735":
 "<code>Lean.Syntax.node (info : SourceInfo) (kind : SyntaxNodeKind) (args : Array Syntax) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A node in the syntax tree that may have further syntax as child nodes. The node's `kind`\ndetermines its interpretation.\n\nFor nodes produced by the parser, the `info` field is typically `Lean.SourceInfo.none`, and source\ninformation is stored in the corresponding fields of identifiers and atoms. This field is used in\ntwo ways:\n 1. The delaborator uses it to associate nodes with metadata that are used to implement\n    interactive features.\n 2. Nodes created by quotations use the field to mark the syntax as synthetic (storing the result\n    of `Lean.SourceInfo.fromRef`) even when its leading or trailing tokens are not.\n</code>",
 "5734": "<code>List Syntax.Preresolved</code>",
 "5733":
 "<code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">An identifier.\n\nIn addition to source information, identifiers have the following fields:\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed Lean name, potentially including macro scopes.\n* `preresolved` is the list of possible declarations this could refer to, populated by\n  [quotations](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=quasiquotation).\n</code>",
 "5732":
 "<code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A non-identifier atomic component of syntax.\n\nAll of the following are atoms:\n * keywords, such as `def`, `fun`, and `inductive`\n * literals, such as numeric or string literals\n * punctuation and delimiters, such as `(`, `)`, and `=&gt;`.\n\nIdentifiers are represented by the `Lean.Syntax.ident` constructor. Atoms also correspond to\nquoted strings inside `syntax` declarations.\n</code>",
 "5731": "<code>removeSourceInfo : Syntax → Syntax</code>",
 "5730":
 "<code>Lean.Syntax.updateLeading : Syntax → Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Set `SourceInfo.leading` according to the trailing stop of the preceding token.\nThe result is a round-tripping syntax tree IF, in the input syntax tree,\n* all leading stops, atom contents, and trailing starts are correct\n* trailing stops are between the trailing start and the next leading stop.\n\nRemark: after parsing, all `SourceInfo.leading` fields are empty.\nThe `Syntax` argument is the output produced by the parser for `source`.\nThis function \"fixes\" the `source.leading` field.\n\nAdditionally, we try to choose \"nicer\" splits between leading and trailing stops\naccording to some heuristics so that e.g. comments are associated to the (intuitively)\ncorrect token.\n\nNote that the `SourceInfo.trailing` fields must be correct.\nThe implementation of this Function relies on this property. </code>",
 "573": "<code>∀ (h : a), motive ⋯</code>",
 "5729":
 "<code>Lean.HygieneInfo.mkIdent (s : Lean.HygieneInfo) (val : Lean.Name) (canonical : Bool := false) : Lean.Ident</code>",
 "5728":
 "<code>Lean.Parser.hygieneInfo : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `hygieneInfo` parses no text, but creates a `hygieneInfoKind` node\ncontaining an anonymous identifier as if it were parsed at the current position.\nThis identifier is modified by syntax quotations to add macro scopes like a regular identifier.\n\nThis is used to implement `have := ...` syntax: the `hygieneInfo` between the `have` and `:=`\ncollects macro scopes, which we can apply to `this` when expanding to `have this := ...`.\nSee [the language reference](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=macro-hygiene) for more information about\nmacro hygiene.\n\nThis is also used to implement cdot functions such as `(1 + ·)`. The opening parenthesis contains\na `hygieneInfo` node as does the cdot, which lets cdot expansion hygienically associate parentheses to cdots.\n\nThis parser has arity 1: it produces a `hygieneInfoKind` node containing an anonymous `Syntax.ident`.\nYou can use `HygieneInfo.mkIdent` to create an `Ident` from the syntax object,\nbut you can also use `TSyntax.getHygieneInfo` to get the raw name from the identifier. </code>",
 "5727":
 "<code>Manual.many.{u_1, u_2} {f : Type u_1 → Type u_2} {α : Type u_1} [Inhabited (f (List α))] [Applicative f] [Alternative f]\n  (x : f α) : f (List α)</code>",
 "5726":
 "<code>optional.{u, v} {f : Type u → Type v} [Alternative f] {α : Type u} (x : f α) : f (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns `some x` if `f` succeeds with value `x`, else returns `none`.\n</code>",
 "5725":
 "<code>Lean.Parser.group (p : Lean.Parser.Parser) : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `group(p)` parses the same thing as `p`, but it wraps the results in a `groupKind`\nnode.\n\nThis parser always has arity 1, even if `p` does not. Parsers like `p*` are automatically\nrewritten to `group(p)*` if `p` does not have arity 1, so that the results from separate invocations\nof `p` can be differentiated. </code>",
 "5724":
 "<code><span class=\"literal string\">\"value = {x}\"</span> : String</code>",
 "5723":
 "<code>Lean.TSyntax.getString (s : Lean.StrLit) : String</code><span class=\"sep\"></span><code class=\"docstring\">Decodes a string literal, removing quotation marks and unescaping escaped characters.\n\nReturns `\"\"` if the syntax is malformed.\n</code>",
 "5722": "<code><span class=\"literal string\">\"0x\"</span> : String</code>",
 "5721":
 "<code>Lean.Syntax.atom (info : Lean.SourceInfo) (val : String) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A non-identifier atomic component of syntax.\n\nAll of the following are atoms:\n * keywords, such as `def`, `fun`, and `inductive`\n * literals, such as numeric or string literals\n * punctuation and delimiters, such as `(`, `)`, and `=&gt;`.\n\nIdentifiers are represented by the `Lean.Syntax.ident` constructor. Atoms also correspond to\nquoted strings inside `syntax` declarations.\n</code>",
 "5720":
 "<code>Lean.Syntax.node (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (args : Array Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A node in the syntax tree that may have further syntax as child nodes. The node's `kind`\ndetermines its interpretation.\n\nFor nodes produced by the parser, the `info` field is typically `Lean.SourceInfo.none`, and source\ninformation is stored in the corresponding fields of identifiers and atoms. This field is used in\ntwo ways:\n 1. The delaborator uses it to associate nodes with metadata that are used to implement\n    interactive features.\n 2. Nodes created by quotations use the field to mark the syntax as synthetic (storing the result\n    of `Lean.SourceInfo.fromRef`) even when its leading or trailing tokens are not.\n</code>",
 "572": "<code>a ∨ b → Prop</code>",
 "5719":
 "<code>Lean.Syntax.getKind (stx : Lean.Syntax) : Lean.SyntaxNodeKind</code><span class=\"sep\"></span><code class=\"docstring\">Gets the kind of a `Syntax.node` value, or the pseudo-kind of any other `Syntax` value.\n\n“Pseudo-kinds” are kinds that are assigned by convention to non-`Syntax.node` values:\n`identKind` for `Syntax.ident`, `` `missing `` for `Syntax.missing`, and the atom's string literal\nfor atoms.\n</code>",
 "5718":
 "<code>Lean.identKind : Lean.SyntaxNodeKind</code><span class=\"sep\"></span><code class=\"docstring\">The pseudo-kind assigned to identifiers: `` `ident ``.\n\nThe name `` `ident `` is not actually used as a kind for `Syntax.node` values. It is used by\nconvention as the kind of `Syntax.ident` values.\n</code>",
 "5717": "<code>List Preresolved</code>",
 "5716":
 "<code>Lean.Syntax.Preresolved : Type</code><span class=\"sep\"></span><code class=\"docstring\">A possible binding of an identifier in the context in which it was quoted.\n\nIdentifiers in quotations may refer to either global declarations or to namespaces that are in scope\nat the site of the quotation. These are saved in the `Syntax.ident` constructor and are part of the\nimplementation of hygienic macros.\n</code>",
 "5715": "<code>List Lean.Syntax.Preresolved</code>",
 "5714":
 "<code>Manual.syntax : Verso.Doc.Elab.DirectiveExpander</code><span class=\"sep\"></span><code class=\"docstring\">Display actual Lean syntax, validated by the parser.\n</code>",
 "5713":
 "<code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Preresolved) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">An identifier.\n\nIn addition to source information, identifiers have the following fields:\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed Lean name, potentially including macro scopes.\n* `preresolved` is the list of possible declarations this could refer to, populated by\n  [quotations](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=quasiquotation).\n</code>",
 "5712":
 "<code class=\"docstring\">`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n</code>",
 "5711":
 "<code>Lean.SourceInfo.fromRef (ref : Syntax) (canonical : Bool := false) : SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a synthetic `SourceInfo` using a `ref : Syntax` for the span. </code>",
 "5710": "<code>SourceInfo</code>",
 "571":
 "<code>Or.rec {a b : Prop} {motive : a ∨ b → Prop} (inl : ∀ (h : a), motive ⋯) (inr : ∀ (h : b), motive ⋯) (t : a ∨ b) :\n  motive t</code>",
 "5709": "<code>SyntaxNodeKind</code>",
 "5708":
 "<code>Lean.SyntaxNodeKind : Type</code><span class=\"sep\"></span><code class=\"docstring\">Specifies the interpretation of a `Syntax.node` value. An abbreviation for `Name`.\n\nNode kinds may be any name, and do not need to refer to declarations in the environment.\nConventionally, however, a node's kind corresponds to the `Parser` or `ParserDesc` declaration that\nproduces it. There are also a number of built-in node kinds that are used by the parsing\ninfrastructure, such as `nullKind` and `choiceKind`; these do not correspond to parser declarations.\n</code>",
 "5707": "<code>Lean.SyntaxNodeKind</code>",
 "5706": "<code>Lean.SourceInfo</code>",
 "5705": "<code>e : Nat × Int</code>",
 "5704": "<code><span class=\"literal string\">\"dup!\"</span> : String</code>",
 "5703": "<code>dup : Lean.ParserDescr</code>",
 "5702":
 "<code><span class=\"literal string\">\"whatever\"</span> : String</code>",
 "5701":
 "<code class=\"docstring\">Precedence used for application arguments (`do`, `by`, ...). </code>",
 "5700":
 "<code><span class=\"literal string\">\"ignore \"</span> : String</code>",
 "570": "<code>a ∧ b</code>",
 "57":
 "<code>thirdOfFive.eq_1.{u_1} {α : Type u_1} (head head_1 x_1 head_2 head_3 : α) :\n  thirdOfFive [head, head_1, x_1, head_2, head_3] = some x_1</code>",
 "5699": "<code>«ignore» : Lean.ParserDescr</code>",
 "5698": "<code><span class=\"literal string\">\"‽\"</span> : String</code>",
 "5697":
 "<code class=\"docstring\">`postfix:prec \"op\" =&gt; f` is equivalent to `notation:prec x:prec \"op\" =&gt; f x`.\n</code>",
 "5696": "<code>fact : Nat → Nat</code>",
 "5695": "<code>perhapsFactorial (n : Nat) : Option Nat</code>",
 "5694":
 "<code class=\"docstring\">The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. </code>",
 "5693": "<code><span class=\"literal string\">\" + \"</span> : String</code>",
 "5692": "<code>getDOp : Lean.TrailingParserDescr</code>",
 "5691": "<code>«term_⤴_» : Lean.TrailingParserDescr</code>",
 "5690": "<code><span class=\"literal string\">\" ⤴ \"</span> : String</code>",
 "569":
 "<code>And.intro {a b : Prop} (left : a) (right : b) : a ∧ b</code><span class=\"sep\"></span><code class=\"docstring\">`And.intro : a → b → a ∧ b` is the constructor for the And operation. </code>",
 "5689":
 "<code class=\"docstring\">`infix:prec \"op\" =&gt; f` is equivalent to `notation:prec x:prec1 \"op\" y:prec1 =&gt; f x y`, where `prec1 := prec + 1`.\n</code>",
 "5688":
 "<code class=\"docstring\">inherit documentation from a specified declaration</code>",
 "5687": "<code>B : Prop</code>",
 "5686": "<code>A : Prop</code>",
 "5685": "<code>α → Thunk β</code>",
 "5684": "<code>Thunk α</code>",
 "5683": "<code><span class=\"literal string\">\"ys\"</span> : String</code>",
 "5682": "<code><span class=\"literal string\">\"xs\"</span> : String</code>",
 "5681": "<code>ys : LazyList Nat</code>",
 "5680": "<code>xs : LazyList Nat</code>",
 "568": "<code>b</code>",
 "5679": "<code>observe {n : Nat} (tag : String) (i : Fin n) : Nat</code>",
 "5678":
 "<code>LazyList.append.{u_1} {α : Type u_1} (xs ys : LazyList α) : LazyList α</code>",
 "5677":
 "<code>LazyList.ofFn.{u_1} {n : Nat} {α : Type u_1} (f : Fin n → α) : LazyList α</code>",
 "5676":
 "<code>LazyList.take.{u_1} {α : Type u_1} : Nat → LazyList α → LazyList α</code>",
 "5675": "<code>Thunk (LazyList α)</code>",
 "5674": "<code>LazyList α</code>",
 "5673":
 "<code>LazyList.toList.{u_1} {α : Type u_1} : LazyList α → List α</code>",
 "5672":
 "<code>LazyList.cons.{u} {α : Type u} : α → LazyList α → LazyList α</code>",
 "5671": "<code>LazyList.nil.{u} {α : Type u} : LazyList α</code>",
 "5670": "<code>LazyList.{u} (α : Type u) : Type u</code>",
 "567": "<code>a</code>",
 "5669":
 "<code>LazyList.delayed.{u} {α : Type u} : Thunk (LazyList α) → LazyList α</code>",
 "5668":
 "<code>Thunk.pure.{u_1} {α : Type u_1} (a : α) : Thunk α</code><span class=\"sep\"></span><code class=\"docstring\">Stores an already-computed value in a thunk.\n\nBecause the value has already been computed, there is no laziness.\n</code>",
 "5667":
 "<code>Unit → α</code><span class=\"sep\"></span><code class=\"docstring\">Extract the getter function out of a thunk. Use `Thunk.get` instead. </code>",
 "5666":
 "<code>Thunk.bind.{u_1, u_2} {α : Type u_1} {β : Type u_2} (x : Thunk α) (f : α → Thunk β) : Thunk β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new thunk that applies `f` to the result of `x` when forced.\n</code>",
 "5665":
 "<code>Thunk.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (x : Thunk α) : Thunk β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new thunk that forces `x` and then applies `x` to the result. Upon forcing, the result\nof `f` is cached and the reference to the thunk `x` is dropped.\n</code>",
 "5664":
 "<code>Thunk.get.{u_1} {α : Type u_1} (x : Thunk α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Gets the thunk's value. If the value is cached, it is returned in constant time; if not, it is\ncomputed.\n\nComputed values are cached, so the value is not recomputed.\n</code>",
 "5663": "<code>DivBy3 : Type</code>",
 "5662": "<code>nine : DivBy3</code>",
 "5661": "<code>s1_eq_s2 : s1 = s2</code>",
 "5660":
 "<code>String.data_eq_of_eq {a b : String} (h : a = b) : a.data = b.data</code>",
 "566": "<code>(left : a) → (right : b) → motive ⋯</code>",
 "5659":
 "<code>List.cons_ne_nil.{u_1} {α : Type u_1} (a : α) (l : List α) : a :: l ≠ []</code>",
 "5658": "<code>\"equal\" = \"\"</code>",
 "5657":
 "<code>\"equal\" = \"\" → False</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "5656":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "5655":
 "<code>ne_of_beq_false.{u_1} {α : Type u_1} [BEq α] [ReflBEq α] {a b : α} (h : (a == b) = false) : a ≠ b</code>",
 "5654":
 "<code><span class=\"literal string\">\"equal\"</span> : String</code>",
 "5653": "<code>NonEmptyString : Type</code>",
 "5652": "<code>s2 : NonEmptyString</code>",
 "5651": "<code>s1 : NonEmptyString</code>",
 "5650": "<code>Subtype p</code>",
 "565": "<code>a ∧ b → Sort u</code>",
 "5649":
 "<code>p self.val</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "5648":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "5647":
 "<code>Std.TreeSet.Raw.inner.{u} {α : Type u} {cmp : autoParam (α → α → Ordering) _auto✝} (self : Std.TreeSet.Raw α cmp) :\n  Std.TreeMap.Raw α Unit cmp</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the tree set. </code>",
 "5646":
 "<code>Std.TreeSet.Raw.WF.mk.{u} {α : Type u} {cmp : α → α → Ordering} {t : Std.TreeSet.Raw α cmp} (out : t.inner.WF) : t.WF</code>",
 "5645": "<code>Std.TreeSet.Raw α cmp</code>",
 "5644":
 "<code>Std.TreeMap.Raw α Unit cmp</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the tree set. </code>",
 "5643":
 "<code>Std.TreeSet.Raw.mk.{u} {α : Type u} {cmp : autoParam (α → α → Ordering) _auto✝} (inner : Std.TreeMap.Raw α Unit cmp) :\n  Std.TreeSet.Raw α cmp</code>",
 "5642": "<code>α → δ → m (ForInStep δ)</code>",
 "5641": "<code>α → δ → m δ</code>",
 "5640": "<code>α → δ → δ</code>",
 "564":
 "<code>And.rec.{u} {a b : Prop} {motive : a ∧ b → Sort u} (intro : (left : a) → (right : b) → motive ⋯) (t : a ∧ b) : motive t</code>",
 "5639": "<code>δ → α → m δ</code>",
 "5638": "<code>δ → α → δ</code>",
 "5637":
 "<code>Std.TreeSet.isEmpty.{u} {α : Type u} {cmp : α → α → Ordering} (t : Std.TreeSet α cmp) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the tree set contains no mappings. </code>",
 "5636":
 "<code>Std.TreeSet.size.{u} {α : Type u} {cmp : α → α → Ordering} (t : Std.TreeSet α cmp) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the number of mappings present in the map. </code>",
 "5635": "<code>Std.TreeSet α cmp</code>",
 "5634":
 "<code>Std.TreeSet.Raw.WF.{u} {α : Type u} {cmp : α → α → Ordering} (t : Std.TreeSet.Raw α cmp) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for tree sets. Users of `TreeSet` will not need to interact with\nthis. Users of `TreeSet.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas\nlike `WF.empty` and `WF.insert` (which are always named exactly like the operations they are about)\nto show that set operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.\n</code>",
 "5633":
 "<code>Std.TreeSet.Raw.{u} (α : Type u) (cmp : α → α → Ordering := by exact compare) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Tree sets without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called `Raw.WF`. When in doubt, prefer `TreeSet`\nover `TreeSet.Raw`. Lemmas about the operations on `Std.TreeSet.Raw` are available in the\nmodule `Std.Data.TreeSet.Raw.Lemmas`.\n\nA tree set stores elements of a certain type in a certain order. It depends on a comparator function\nthat defines an ordering on the keys and provides efficient order-dependent queries, such as\nretrieval of the minimum or maximum.\n\nTo ensure that the operations behave as expected, the comparator function `cmp` should satisfy\ncertain laws that ensure a consistent ordering:\n\n* If `a` is less than (or equal) to `b`, then `b` is greater than (or equal) to `a`\nand vice versa (see the `OrientedCmp` typeclass).\n* If `a` is less than or equal to `b` and `b` is, in turn, less than or equal to `c`, then `a`\nis less than or equal to `c` (see the `TransCmp` typeclass).\n\nKeys for which `cmp a b = Ordering.eq` are considered the same, i.e only one of them\ncan be contained in a single tree set at the same time.\n\nTo avoid expensive copies, users should make sure that the tree set is used linearly.\n\nInternally, the tree sets are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.\n</code>",
 "5632":
 "<code>Std.DTreeMap.Internal.Impl.WF.{u, v} {α : Type u} [Ord α] {β : α → Type v} : Std.DTreeMap.Internal.Impl α β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness of tree maps. </code>",
 "5631":
 "<code>Std.DTreeMap.Raw.inner.{u, v} {α : Type u} {β : α → Type v} {_cmp : autoParam (α → α → Ordering) _auto✝}\n  (self : Std.DTreeMap.Raw α β _cmp) : Std.DTreeMap.Internal.Impl α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the tree map. </code>",
 "5630":
 "<code>Std.DTreeMap.Raw.WF.mk.{u, v} {α : Type u} {β : α → Type v} {cmp : α → α → Ordering} {t : Std.DTreeMap.Raw α β cmp}\n  (out : t.inner.WF) : t.WF</code>",
 "563": "<code>False</code>",
 "5629": "<code>Std.DTreeMap.Raw α β cmp</code>",
 "5628":
 "<code>Std.DTreeMap.Internal.Impl.{u, v} (α : Type u) (β : α → Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">(Implementation detail) The actual inductive type for the size-balanced tree data structure. </code>",
 "5627":
 "<code>Std.DTreeMap.Internal.Impl α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the tree map. </code>",
 "5626":
 "<code>Std.DTreeMap.Raw.mk.{u, v} {α : Type u} {β : α → Type v} {_cmp : autoParam (α → α → Ordering) _auto✝}\n  (inner : Std.DTreeMap.Internal.Impl α β) : Std.DTreeMap.Raw α β _cmp</code>",
 "5625": "<code>Std.DTreeMap α (fun x =&gt; β) cmp</code>",
 "5624":
 "<code>Std.LawfulEqCmp.{u} {α : Type u} (cmp : α → α → Ordering) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A typeclass for comparison functions satisfying `cmp a b = .eq` if and only if the logical equality\n`a = b` holds.\n\nThis typeclass distinguishes itself from `LawfulBEqCmp` by using logical equality (`=`) instead of\nboolean equality (`==`).\n</code>",
 "5623":
 "<code>Std.DTreeMap.contains.{u, v} {α : Type u} {β : α → Type v} {cmp : α → α → Ordering} (t : Std.DTreeMap α β cmp) (a : α) :\n  Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if there is a mapping for the given key `a` or a key that is equal to `a` according\nto the comparator `cmp`. There is also a `Prop`-valued version\nof this: `a ∈ t` is equivalent to `t.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` uses\n`==` for equality checks, while for tree maps, both use the given comparator `cmp`.\n</code>",
 "5622": "<code>Std.DTreeMap α β cmp</code>",
 "5621":
 "<code>Std.DTreeMap.Raw.WF.{u, v} {α : Type u} {β : α → Type v} {cmp : α → α → Ordering} (t : Std.DTreeMap.Raw α β cmp) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for tree maps. Users of `DTreeMap` will not need to interact with\nthis. Users of `DTreeMap.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas\nlike `WF.empty` and `WF.insert` (which are always named exactly like the operations they are about)\nto show that map operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.\n</code>",
 "5620":
 "<code>Std.TreeMap.Raw.inner.{u, v} {α : Type u} {β : Type v} {cmp : autoParam (α → α → Ordering) _auto✝}\n  (self : Std.TreeMap.Raw α β cmp) : Std.DTreeMap.Raw α (fun x =&gt; β) cmp</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the tree map. </code>",
 "562": "<code>False → Sort u</code>",
 "5619":
 "<code>t.inner.WF</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the tree map. </code>",
 "5618":
 "<code>Std.TreeMap.Raw.WF.mk.{u, v} {α : Type u} {β : Type v} {cmp : α → α → Ordering} {t : Std.TreeMap.Raw α β cmp}\n  (out : t.inner.WF) : t.WF</code>",
 "5617": "<code>Std.TreeMap.Raw α β cmp</code>",
 "5616":
 "<code>Std.DTreeMap.Raw.{u, v} (α : Type u) (β : α → Type v) (_cmp : α → α → Ordering := by exact compare) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Dependent tree maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called `Raw.WF`. When in doubt, prefer `DTreeMap`\nover `DTreeMap.Raw`. Lemmas about the operations on `Std.DTreeMap.Raw` are available in the\nmodule `Std.Data.DTreeMap.Raw.Lemmas`.\n\nA tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.\n\nTo ensure that the operations behave as expected, the comparator function `cmp` should satisfy\ncertain laws that ensure a consistent ordering:\n\n* If `a` is less than (or equal) to `b`, then `b` is greater than (or equal) to `a`\nand vice versa (see the `OrientedCmp` typeclass).\n* If `a` is less than or equal to `b` and `b` is, in turn, less than or equal to `c`, then `a`\nis less than or equal to `c` (see the `TransCmp` typeclass).\n\nKeys for which `cmp a b = Ordering.eq` are considered the same, i.e., there can be only one entry\nwith key either `a` or `b` in a tree map. Looking up either `a` or `b` always yields the same entry,\nif any is present. The `get` operations of the _dependent_ tree map additionally require a\n`LawfulEqCmp` instance to ensure that `cmp a b = .eq` always implies `a = b`, so that their\nrespective value types are equal.\n\nTo avoid expensive copies, users should make sure that the tree map is used linearly.\n\nInternally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.\n</code>",
 "5615":
 "<code>Std.DTreeMap.Raw α (fun x =&gt; β) cmp</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the tree map. </code>",
 "5614":
 "<code>Std.TreeMap.Raw.mk.{u, v} {α : Type u} {β : Type v} {cmp : autoParam (α → α → Ordering) _auto✝}\n  (inner : Std.DTreeMap.Raw α (fun x =&gt; β) cmp) : Std.TreeMap.Raw α β cmp</code>",
 "5613": "<code>α → β → δ → m (ForInStep δ)</code>",
 "5612": "<code>α → β → δ → m δ</code>",
 "5611": "<code>α → β → δ → δ</code>",
 "5610": "<code>δ → α → β → m δ</code>",
 "561":
 "<code>False.rec.{u} (motive : False → Sort u) (t : False) : motive t</code>",
 "5609": "<code>Type w → Type w₂</code>",
 "5608": "<code>δ → α → β → δ</code>",
 "5607": "<code>α → β → β → β</code>",
 "5606": "<code>Std.TreeMap α Unit cmp</code>",
 "5605":
 "<code>Std.TreeMap.isEmpty.{u, v} {α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Std.TreeMap α β cmp) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the tree map contains no mappings. </code>",
 "5604": "<code>t.isEmpty = false</code>",
 "5603": "<code>∃ a, a ∈ t ∧ cmp a k = Ordering.lt</code>",
 "5602": "<code>∃ a, a ∈ t ∧ (cmp a k).isLE = true</code>",
 "5601": "<code>∃ a, a ∈ t ∧ cmp a k = Ordering.gt</code>",
 "5600":
 "<code>Ordering.isGE : Ordering → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the ordering is `gt` or `eq`.\n</code>",
 "560": "<code>True</code>",
 "56":
 "<code>thirdOfFive.eq_def.{u_1} {α : Type u_1} (x✝ : List α) :\n  thirdOfFive x✝ =\n    match x✝ with\n    | [head, head_1, x, head_2, head_3] =&gt; some x\n    | x =&gt; none</code>",
 "5599": "<code>∃ a, a ∈ t ∧ (cmp a k).isGE = true</code>",
 "5598":
 "<code>Std.TransCmp.{u} {α : Type u} (cmp : α → α → Ordering) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A typeclass for functions `α → α → Ordering` which are transitive. </code>",
 "5597":
 "<code>Std.TreeMap.size.{u, v} {α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Std.TreeMap α β cmp) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the number of mappings present in the map. </code>",
 "5596": "<code>n &lt; t.size</code>",
 "5595": "<code>a ∈ t</code>",
 "5594": "<code>Std.TreeMap α β cmp</code>",
 "5593": "<code>α → α → Ordering</code>",
 "5592":
 "<code>Std.TreeMap.Raw.WF.{u, v} {α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Std.TreeMap.Raw α β cmp) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for tree maps. Users of `TreeMap` will not need to interact with\nthis. Users of `TreeMap.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas\nlike `WF.empty` and `WF.insert` (which are always named exactly like the operations they are about)\nto show that map operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.\n</code>",
 "5591":
 "<code>Std.TreeMap.Raw.{u, v} (α : Type u) (β : Type v) (cmp : α → α → Ordering := by exact compare) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Tree maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called `Raw.WF`. When in doubt, prefer `TreeMap`\nover `TreeMap.Raw`. Lemmas about the operations on `Std.TreeMap.Raw` are available in the\nmodule `Std.Data.TreeMap.Raw.Lemmas`.\n\nA tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.\n\nTo ensure that the operations behave as expected, the comparator function `cmp` should satisfy\ncertain laws that ensure a consistent ordering:\n\n* If `a` is less than (or equal) to `b`, then `b` is greater than (or equal) to `a`\nand vice versa (see the `OrientedCmp` typeclass).\n* If `a` is less than or equal to `b` and `b` is, in turn, less than or equal to `c`, then `a`\nis less than or equal to `c` (see the `TransCmp` typeclass).\n\nKeys for which `cmp a b = Ordering.eq` are considered the same, i.e., there can be only one entry\nwith key either `a` or `b` in a tree map. Looking up either `a` or `b` always yields the same entry,\nif any is present.\n\nTo avoid expensive copies, users should make sure that the tree map is used linearly.\n\nInternally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.\n</code>",
 "5590": "<code>autoParam (α → α → Ordering) _auto✝</code>",
 "559":
 "<code>True.intro : True</code><span class=\"sep\"></span><code class=\"docstring\">`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. </code>",
 "5589":
 "<code>Std.ExtHashSet.contains.{u} {α : Type u} {x✝ : BEq α} {x✝¹ : Hashable α} [EquivBEq α] [LawfulHashable α]\n  (m : Std.ExtHashSet α) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the given key is present in the set. There is also a `Prop`-valued version of\nthis: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` use\n`==` for comparisons, while for hash sets, both use `==`.\n</code>",
 "5588": "<code>Std.ExtHashSet α</code>",
 "5587":
 "<code>Std.ExtHashMap α Unit</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash set. </code>",
 "5586":
 "<code>Std.ExtHashSet.mk.{u} {α : Type u} [BEq α] [Hashable α] (inner : Std.ExtHashMap α Unit) : Std.ExtHashSet α</code>",
 "5585":
 "<code>Std.HashSet.Raw.WF.{u} {α : Type u} [BEq α] [Hashable α] (m : Std.HashSet.Raw α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for hash sets. Users of `HashSet` will not need to interact with this.\nUsers of `HashSet.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas like\n`WF.empty` and `WF.insert` (which are always named exactly like the operations they are about) to\nshow that set operations preserve well-formedness.\n</code>",
 "5584":
 "<code>Std.HashSet.Raw.inner.{u} {α : Type u} (self : Std.HashSet.Raw α) : Std.HashMap.Raw α Unit</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash set. </code>",
 "5583":
 "<code>m.inner.WF</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash set </code>",
 "5582":
 "<code>Std.HashSet.Raw.WF.mk.{u} {α : Type u} [BEq α] [Hashable α] {m : Std.HashSet.Raw α} (out : m.inner.WF) : m.WF</code>",
 "5581":
 "<code>Std.HashSet.Raw.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Hash sets without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called `Raw.WF`. When in doubt, prefer `HashSet`\nover `HashSet.Raw`. Lemmas about the operations on `Std.Data.HashSet.Raw` are available in the\nmodule `Std.Data.HashSet.RawLemmas`.\n\nThis is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash set is used linearly to\navoid expensive copies.\n\nThe hash set uses `==` (provided by the `BEq` typeclass) to compare elements and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n</code>",
 "5580": "<code>Std.HashSet.Raw α</code>",
 "558": "<code>motive True.intro</code>",
 "5579":
 "<code>Std.HashMap.Raw α Unit</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash set. </code>",
 "5578":
 "<code>Std.HashSet.Raw.mk.{u} {α : Type u} (inner : Std.HashMap.Raw α Unit) : Std.HashSet.Raw α</code>",
 "5577":
 "<code>Std.HashSet.Equiv.{u} {α : Type u} {x✝ : BEq α} {x✝¹ : Hashable α} (m₁ m₂ : Std.HashSet α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two hash sets are equivalent in the sense of `Equiv` iff all their values are equal.\n</code>",
 "5576":
 "<code>Std.HashSet.inner.{u} {α : Type u} [BEq α] [Hashable α] (self : Std.HashSet α) : Std.HashMap α Unit</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash set. </code>",
 "5575":
 "<code>Std.HashSet.Equiv.mk.{u} {α : Type u} {x✝ : BEq α} {x✝¹ : Hashable α} {m₁ m₂ : Std.HashSet α}\n  (inner : m₁.inner.Equiv m₂.inner) : m₁.Equiv m₂</code>",
 "5574":
 "<code>Std.HashSet.contains.{u} {α : Type u} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashSet α) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the given key is present in the set. There is also a `Prop`-valued version of\nthis: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` use\n`==` for comparisons, while for hash sets, both use `==`.\n</code>",
 "5573": "<code>Std.HashSet α</code>",
 "5572":
 "<code>Std.HashMap α Unit</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash set. </code>",
 "5571":
 "<code>Std.HashSet.mk.{u} {α : Type u} [BEq α] [Hashable α] (inner : Std.HashMap α Unit) : Std.HashSet α</code>",
 "5570": "<code>(a : α) → β a → γ a</code>",
 "557": "<code>True → Sort u</code>",
 "5569": "<code>(a : α) → β a → Option (γ a)</code>",
 "5568":
 "<code>Std.ExtDHashMap.contains.{u, v} {α : Type u} {β : α → Type v} {x✝ : BEq α} {x✝¹ : Hashable α} [EquivBEq α]\n  [LawfulHashable α] (m : Std.ExtDHashMap α β) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if there is a mapping for the given key. There is also a `Prop`-valued version\nof this: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` uses\n`==` for comparisons, while for hash maps, both use `==`.\n</code>",
 "5567": "<code>Std.ExtDHashMap α β</code>",
 "5566": "<code>Std.ExtHashMap α Unit</code>",
 "5565":
 "<code>Std.ExtHashMap.contains.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} [EquivBEq α] [LawfulHashable α]\n  (m : Std.ExtHashMap α β) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if there is a mapping for the given key. There is also a `Prop`-valued version\nof this: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` uses\n`==` for comparisons, while for hash maps, both use `==`.\n</code>",
 "5564": "<code>Std.ExtHashMap α β</code>",
 "5563":
 "<code>Std.DHashMap.Internal.Raw₀.Const.alter.{u, v} {α : Type u} [BEq α] [Hashable α] {β : Type v}\n  (m : Std.DHashMap.Internal.Raw₀ α fun x =&gt; β) (a : α) (f : Option β → Option β) :\n  Std.DHashMap.Internal.Raw₀ α fun x =&gt; β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5562":
 "<code>Std.DHashMap.Internal.Raw₀.alter.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α] [LawfulBEq α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) (f : Option (β a) → Option (β a)) : Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5561":
 "<code>Std.DHashMap.Internal.Raw₀.Const.modify.{u, v} {α : Type u} [BEq α] {β : Type v} [Hashable α]\n  (m : Std.DHashMap.Internal.Raw₀ α fun x =&gt; β) (a : α) (f : β → β) : Std.DHashMap.Internal.Raw₀ α fun x =&gt; β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5560":
 "<code>Std.DHashMap.Internal.Raw₀.modify.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α] [LawfulBEq α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) (f : β a → β a) : Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "556":
 "<code>True.rec.{u} {motive : True → Sort u} (intro : motive True.intro) (t : True) : motive t</code>",
 "5559":
 "<code>Std.DHashMap.Internal.Raw₀.Const.getThenInsertIfNew?.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α]\n  (m : Std.DHashMap.Internal.Raw₀ α fun x =&gt; β) (a : α) (b : β) : Option β × Std.DHashMap.Internal.Raw₀ α fun x =&gt; β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5558": "<code>Std.DHashMap.Raw α fun x =&gt; β</code>",
 "5557":
 "<code>Std.DHashMap.Internal.Raw₀.filter.{u, v} {α : Type u} {β : α → Type v} (f : (a : α) → β a → Bool)\n  (m : Std.DHashMap.Internal.Raw₀ α β) : Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5556":
 "<code>Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α] [LawfulBEq α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) (b : β a) : Option (β a) × Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5555":
 "<code>Std.DHashMap.Internal.Raw₀.insertIfNew.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) (b : β a) : Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5554":
 "<code>Std.DHashMap.Internal.Raw₀.erase.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) : Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5553":
 "<code>Std.DHashMap.Internal.Raw₀.containsThenInsertIfNew.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) (b : β a) : Bool × Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5552":
 "<code>Std.DHashMap.Internal.Raw₀.containsThenInsert.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) (b : β a) : Bool × Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5551":
 "<code>Std.DHashMap.Internal.Raw₀.insert.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α]\n  (m : Std.DHashMap.Internal.Raw₀ α β) (a : α) (b : β a) : Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5550": "<code>0 &lt; m.buckets.size</code>",
 "555": "<code>EvenOddList α isEven</code>",
 "5549":
 "<code>Std.DHashMap.Internal.Raw₀.emptyWithCapacity.{u, v} {α : Type u} {β : α → Type v} (capacity : Nat := 8) :\n  Std.DHashMap.Internal.Raw₀ α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5548":
 "<code>Std.DHashMap.Internal.Raw.WFImp.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α] (m : Std.DHashMap.Raw α β) :\n  Prop</code><span class=\"sep\"></span><code class=\"docstring\">This is the actual well-formedness predicate for hash maps. Users should never need to interact\nwith this and should use `WF` instead. </code>",
 "5547":
 "<code>Std.DHashMap.Raw.buckets.{u, v} {α : Type u} {β : α → Type v} (self : Std.DHashMap.Raw α β) :\n  Array (Std.DHashMap.Internal.AssocList α β)</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5546": "<code>Std.DHashMap.Raw α β</code>",
 "5545":
 "<code>Std.DHashMap.Internal.AssocList.{v, u} (α : Type u) (β : α → Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">`AssocList α β` is \"the same as\" `List (α × β)`, but flattening the structure\nleads to one fewer pointer indirection (in the current code generator).\n</code>",
 "5544":
 "<code>Array (Std.DHashMap.Internal.AssocList α β)</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5543":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of mappings present in the hash map </code>",
 "5542":
 "<code>Std.DHashMap.Raw.mk.{u, v} {α : Type u} {β : α → Type v} (size : Nat)\n  (buckets : Array (Std.DHashMap.Internal.AssocList α β)) : Std.DHashMap.Raw α β</code>",
 "5541": "<code>List ((a : α) × β a)</code>",
 "5540": "<code>(a : α) → β a → m PUnit</code>",
 "554":
 "<code>{isEven : Bool} →\n  (head : α) → (tail : EvenOddList α isEven) → motive isEven tail → motive (!isEven) (EvenOddList.cons head tail)</code>",
 "5539": "<code>(a : α) → β a → δ → m (ForInStep δ)</code>",
 "5538": "<code>δ → (a : α) → β a → m δ</code>",
 "5537": "<code>δ</code>",
 "5536": "<code>δ → (a : α) → β a → δ</code>",
 "5535": "<code>(a : α) → β a → δ a</code>",
 "5534": "<code>(a : α) → β a → Option (δ a)</code>",
 "5533": "<code>α → Type w</code>",
 "5532": "<code>(a : α) → β a → Bool</code>",
 "5531": "<code>β a → β a</code>",
 "5530": "<code>Option (β a) → Option (β a)</code>",
 "553": "<code>motive true EvenOddList.nil</code>",
 "5529": "<code>Std.DHashMap α fun x =&gt; β</code>",
 "5528": "<code>β a</code>",
 "5527":
 "<code>Std.DHashMap.contains.{u, v} {α : Type u} {β : α → Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.DHashMap α β)\n  (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if there is a mapping for the given key. There is also a `Prop`-valued version\nof this: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` uses\n`==` for comparisons, while for hash maps, both use `==`.\n</code>",
 "5526":
 "<code>Std.DHashMap.Raw.Equiv.{u, v} {α : Type u} {β : α → Type v} (m₁ m₂ : Std.DHashMap.Raw α β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two hash maps are equivalent in the sense of `Equiv` iff\nall the keys and values are equal.\n</code>",
 "5525":
 "<code>Std.DHashMap.inner.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α] (self : Std.DHashMap α β) :\n  Std.DHashMap.Raw α β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map. </code>",
 "5524":
 "<code>Std.DHashMap.Equiv.mk.{u, v} {α : Type u} {β : α → Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m₁ m₂ : Std.DHashMap α β}\n  (inner : m₁.inner.Equiv m₂.inner) : m₁.Equiv m₂</code>",
 "5523": "<code>Std.DHashMap α β</code>",
 "5522":
 "<code>Std.DHashMap.Raw.WF.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α] : Std.DHashMap.Raw α β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for hash maps. Users of `DHashMap` will not need to interact with\nthis. Users of `DHashMap.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas\nlike `WF.empty` and `WF.insert` (which are always named exactly like the operations they are about)\nto show that map operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.\n</code>",
 "5521":
 "<code>Std.HashMap.Raw.inner.{u, v} {α : Type u} {β : Type v} (self : Std.HashMap.Raw α β) : Std.DHashMap.Raw α fun x =&gt; β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5520":
 "<code>m.inner.WF</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "552": "<code>(isEven : Bool) → EvenOddList α isEven → Sort u</code>",
 "5519":
 "<code>Std.HashMap.Raw.WF.mk.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {m : Std.HashMap.Raw α β}\n  (out : m.inner.WF) : m.WF</code>",
 "5518": "<code>Std.HashMap.Raw α β</code>",
 "5517":
 "<code>Std.DHashMap.Raw.{u, v} (α : Type u) (β : α → Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Dependent hash maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called `Raw.WF`. When in doubt, prefer `DHashMap`\nover `DHashMap.Raw`. Lemmas about the operations on `Std.Data.DHashMap.Raw` are available in the\nmodule `Std.Data.DHashMap.RawLemmas`.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash map is used linearly to\navoid expensive copies.\n\nThis is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash map uses `==` (provided by the `BEq` typeclass) to compare keys and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n</code>",
 "5516":
 "<code>Std.DHashMap.Raw α fun x =&gt; β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5515":
 "<code>Std.HashMap.Raw.mk.{u, v} {α : Type u} {β : Type v} (inner : Std.DHashMap.Raw α fun x =&gt; β) : Std.HashMap.Raw α β</code>",
 "5514": "<code>α → β → m PUnit</code>",
 "5513": "<code>α → β → γ → m (ForInStep γ)</code>",
 "5512": "<code>γ → α → β → m γ</code>",
 "5511": "<code>Type w → Type w'</code>",
 "5510": "<code>γ → α → β → γ</code>",
 "551":
 "<code>EvenOddList.rec.{u_1, u} {α : Type u} {motive : (a : Bool) → EvenOddList α a → Sort u_1}\n  (nil : motive true EvenOddList.nil)\n  (cons :\n    {isEven : Bool} →\n      (a : α) → (a_1 : EvenOddList α isEven) → motive isEven a_1 → motive (!isEven) (EvenOddList.cons a a_1))\n  {a✝ : Bool} (t : EvenOddList α a✝) : motive a✝ t</code>",
 "5509": "<code>Std.HashMap α Unit</code>",
 "5508": "<code>α → β → Option γ</code>",
 "5507": "<code>α → β → Bool</code>",
 "5506":
 "<code>Insert.insert.{u, v} {α : outParam (Type u)} {γ : Type v} [self : Insert α γ] : α → γ → γ</code><span class=\"sep\"></span><code class=\"docstring\">`insert x xs` inserts the element `x` into the collection `xs`. </code>",
 "5505": "<code>Option β → Option β</code>",
 "5504":
 "<code>Std.HashMap.Equiv.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m₁ m₂ : Std.HashMap α β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two hash maps are equivalent in the sense of `Equiv` iff\nall the keys and values are equal.\n</code>",
 "5503":
 "<code>Std.DHashMap.Equiv.{u, v} {α : Type u} {β : α → Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m₁ m₂ : Std.DHashMap α β) :\n  Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two hash maps are equivalent in the sense of `Equiv` iff\nall the keys and values are equal.\n</code>",
 "5502":
 "<code>Std.HashMap.inner.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (self : Std.HashMap α β) :\n  Std.DHashMap α fun x =&gt; β</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5501":
 "<code>m₁.inner.Equiv m₂.inner</code><span class=\"sep\"></span><code class=\"docstring\">Internal implementation detail of the hash map </code>",
 "5500":
 "<code>Std.HashMap.Equiv.mk.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m₁ m₂ : Std.HashMap α β}\n  (inner : m₁.inner.Equiv m₂.inner) : m₁.Equiv m₂</code>",
 "550":
 "<code>(head : α) → (tail : List α) → motive tail → motive (head :: tail)</code>",
 "55":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "5499": "<code>Std.HashMap α β</code>",
 "5498": "<code>Option (Array String)</code>",
 "5497":
 "<code>Std.HashMap.alter.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : HashMap α β) (a : α)\n  (f : Option β → Option β) : HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an `Option` valued replacement function.\n\nThis function ensures that the value is used linearly.\n</code>",
 "5496":
 "<code>addAlias'' (aliases : HashMap String (Array String)) (key value : String) : HashMap String (Array String)</code>",
 "5495":
 "<code>addAlias' (aliases : HashMap String (Array String)) (key value : String) : HashMap String (Array String)</code>",
 "5494":
 "<code>Std.HashMap.getD.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : HashMap α β) (a : α)\n  (fallback : β) : β</code><span class=\"sep\"></span><code class=\"docstring\">Tries to retrieve the mapping for the given key, returning `fallback` if no such mapping is present.\n</code>",
 "5493": "<code>HashMap String (Array String)</code>",
 "5492":
 "<code>addAlias (aliases : HashMap String (Array String)) (key value : String) : HashMap String (Array String)</code>",
 "5491":
 "<code>addAlias (aliases : Std.HashMap String (Array String)) (key value : String) : Std.HashMap String (Array String)</code>",
 "5490":
 "<code>Std.HashMap.modify.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α)\n  (f : β → β) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Modifies in place the value associated with a given key.\n\nThis function ensures that the value is used linearly.\n</code>",
 "549": "<code>motive []</code>",
 "5489":
 "<code>{ description := description✝, passages := passages✝ }.WF</code>",
 "5488":
 "<code>{ raw := { description := description✝, passages := passages✝ }, wf := ⋯ }.raw.passages[dir]? = some m'</code>",
 "5487": "<code>passages✝.WF</code>",
 "5486":
 "<code>∀ (dir : String) (v : RawMaze), passages✝[dir]? = some v → v.WF</code>",
 "5485": "<code>r.WF</code>",
 "5484": "<code>{ raw := r, wf := wf }.raw.passages[dir]? = some m'</code>",
 "5483": "<code>r.WF</code>",
 "5482": "<code>maze.raw.passages[dir]? = some m'</code>",
 "5481": "<code>Maze.mk (raw : RawMaze) (wf : raw.WF) : Maze</code>",
 "5480": "<code>maze.raw.passages[dir]? = none</code>",
 "548": "<code>List α → Sort u</code>",
 "5479": "<code>Maze.go? (maze : Maze) (dir : String) : Option Maze</code>",
 "5478": "<code>Maze.description (maze : Maze) : String</code>",
 "5477": "<code>(maze.raw.insert dir next.raw).WF</code>",
 "5476": "<code>Maze</code>",
 "5475":
 "<code>RawMaze.base_wf (description : String) : (RawMaze.base description).WF</code>",
 "5474": "<code>(RawMaze.base description).WF</code>",
 "5473": "<code>RawMaze</code>",
 "5472":
 "<code>Maze.insert (maze : Maze) (dir : String) (next : Maze) : Maze</code>",
 "5471": "<code>Maze.base (description : String) : Maze</code>",
 "5470": "<code>Maze.wf (self : Maze) : self.raw.WF</code>",
 "547":
 "<code>List.nil.{u} {α : Type u} : List α</code><span class=\"sep\"></span><code class=\"docstring\">The empty list, usually written `[]`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.</code>",
 "5469": "<code>Maze.raw (self : Maze) : RawMaze</code>",
 "5468": "<code>Maze : Type</code>",
 "5467":
 "<code>Std.HashMap.Raw.WF.insert.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {m : HashMap.Raw α β} {a : α} {b : β}\n  (h : m.WF) : (m.insert a b).WF</code>",
 "5466": "<code>some next = some v</code>",
 "5465": "<code>passages[dir']? = some v</code>",
 "5464": "<code>¬(dir == dir') = true</code>",
 "5463": "<code>(dir == dir') = true</code>",
 "5462":
 "<code>Std.HashMap.Raw.getElem?_insert.{u, v} {α : Type u} {β : Type v} {m : HashMap.Raw α β} [BEq α] [Hashable α] [EquivBEq α]\n  [LawfulHashable α] (h : m.WF) {k a : α} {v : β} : (m.insert k v)[a]? = if (k == a) = true then some v else m[a]?</code>",
 "5461": "<code>next.WF</code>",
 "5460": "<code>passages.WF</code>",
 "546":
 "<code>List.rec.{u_1, u} {α : Type u} {motive : List α → Sort u_1} (nil : motive [])\n  (cons : (head : α) → (tail : List α) → motive tail → motive (head :: tail)) (t : List α) : motive t</code>",
 "5459":
 "<code>∀ (dir : String) (v : RawMaze), passages[dir]? = some v → v.WF</code>",
 "5458":
 "<code>RawMaze.mk (description : String) (passages : HashMap.Raw String RawMaze) : RawMaze</code>",
 "5457":
 "<code>RawMaze.insert_wf {next : RawMaze} {dir : String} (maze : RawMaze) : maze.WF → next.WF → (maze.insert dir next).WF</code>",
 "5456":
 "<code>Std.HashMap.Raw.WF.empty.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] : ∅.WF</code>",
 "5455":
 "<code>Std.HashMap.Raw.getElem?_empty.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {a : α} : ∅[a]? = none</code>",
 "5454": "<code>∅[v]? = some h</code>",
 "5453":
 "<code>EmptyCollection.emptyCollection.{u} {α : Type u} [self : EmptyCollection α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{}` in identifiers is `empty`.\n\n * The recommended spelling of `∅` in identifiers is `empty`.</code>",
 "5452":
 "<code>RawMaze.base_wf (description : String) : (base description).WF</code>",
 "5451":
 "<code>Std.HashMap.Raw.WF.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : HashMap.Raw α β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for hash maps. Users of `HashMap` will not need to interact with this.\nUsers of `HashMap.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas\n`WF.empty` and `WF.insert` (which are always named exactly like the operations they are about) to\nshow that map operations preserve well-formedness.\n</code>",
 "5450": "<code>HashMap.Raw String RawMaze</code>",
 "545": "<code>motive Bool.true</code>",
 "5449":
 "<code>RawMaze.WF.mk {description : String} {passages : HashMap.Raw String RawMaze} :\n  (∀ (dir : String) (v : RawMaze), passages[dir]? = some v → v.WF) →\n    passages.WF → { description := description, passages := passages }.WF</code>",
 "5448": "<code>RawMaze.WF : RawMaze → Prop</code>",
 "5447":
 "<code>RawMaze.passages (self : RawMaze) : Std.HashMap.Raw String RawMaze</code>",
 "5446":
 "<code>Std.HashMap.Raw.insert.{u, v} {α : Type u} {β : Type v} [beq : BEq α] [Hashable α] (m : HashMap.Raw α β) (a : α)\n  (b : β) : HashMap.Raw α β</code><span class=\"sep\"></span><code class=\"docstring\">Inserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nNote: this replacement behavior is true for `HashMap`, `DHashMap`, `HashMap.Raw` and `DHashMap.Raw`.\nThe `insert` function on `HashSet` and `HashSet.Raw` behaves differently: it will return the set\nunchanged if a matching key is already present.\n</code>",
 "5445": "<code>RawMaze</code>",
 "5444":
 "<code>RawMaze.insert (maze : RawMaze) (direction : String) (next : RawMaze) : RawMaze</code>",
 "5443": "<code>HashMap.Raw String RawMaze</code>",
 "5442": "<code>RawMaze.base (description : String) : RawMaze</code>",
 "5441":
 "<code>RawMaze.passages (self : RawMaze) : HashMap.Raw String RawMaze</code>",
 "5440": "<code>RawMaze.description (self : RawMaze) : String</code>",
 "544": "<code>motive Bool.false</code>",
 "5439": "<code>RawMaze : Type</code>",
 "5438": "<code>_nested.Std.DHashMap.Raw_3</code>",
 "5437":
 "<code>Std.DHashMap.Raw.WF.{u, v} {α : Type u} {β : α → Type v} [BEq α] [Hashable α] : DHashMap.Raw α β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for hash maps. Users of `DHashMap` will not need to interact with\nthis. Users of `DHashMap.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas\nlike `WF.empty` and `WF.insert` (which are always named exactly like the operations they are about)\nto show that map operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.\n</code>",
 "5436":
 "<code>Std.HashMap.Raw.WF.insert.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {m : Std.HashMap.Raw α β} {a : α}\n  {b : β} (h : m.WF) : (m.insert a b).WF</code>",
 "5435":
 "<code>Std.HashMap.Raw.insert.{u, v} {α : Type u} {β : Type v} [beq : BEq α] [Hashable α] (m : Std.HashMap.Raw α β) (a : α)\n  (b : β) : Std.HashMap.Raw α β</code><span class=\"sep\"></span><code class=\"docstring\">Inserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nNote: this replacement behavior is true for `HashMap`, `DHashMap`, `HashMap.Raw` and `DHashMap.Raw`.\nThe `insert` function on `HashSet` and `HashSet.Raw` behaves differently: it will return the set\nunchanged if a matching key is already present.\n</code>",
 "5434":
 "<code>Std.HashMap.Raw.WF.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : Std.HashMap.Raw α β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Well-formedness predicate for hash maps. Users of `HashMap` will not need to interact with this.\nUsers of `HashMap.Raw` will need to provide proofs of `WF` to lemmas and should use lemmas\n`WF.empty` and `WF.insert` (which are always named exactly like the operations they are about) to\nshow that map operations preserve well-formedness.\n</code>",
 "5433":
 "<code>Std.HashMap.Raw.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Hash maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called `Raw.WF`. When in doubt, prefer `HashMap`\nover `HashMap.Raw`. Lemmas about the operations on `Std.Data.HashMap.Raw` are available in the\nmodule `Std.Data.HashMap.RawLemmas`.\n\nThis is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash map is used linearly to\navoid expensive copies.\n\nThe hash map uses `==` (provided by the `BEq` typeclass) to compare keys and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nDependent hash maps, in which keys may occur in their values' types, are available as\n`Std.Data.Raw.DHashMap`.\n</code>",
 "5432":
 "<code>Std.HashMap.alter.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α)\n  (f : Option β → Option β) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an `Option` valued replacement function.\n\nThis function ensures that the value is used linearly.\n</code>",
 "5431":
 "<code>Std.HashMap.containsThenInsertIfNew.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α}\n  (m : Std.HashMap α β) (a : α) (b : β) : Bool × Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a key is present in a map and inserts a value for the key if it was not found.\n\nIf the returned `Bool` is `true`, then the returned map is unaltered. If the `Bool` is `false`, then\nthe returned map has a new value inserted.\n\nEquivalent to (but potentially faster than) calling `contains` followed by `insertIfNew`.\n</code>",
 "5430":
 "<code>Std.HashMap.containsThenInsert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β)\n  (a : α) (b : β) : Bool × Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a key is present in a map, and unconditionally inserts a value for the key.\n\nEquivalent to (but potentially faster than) calling `contains` followed by `insert`.\n</code>",
 "543": "<code>Bool → Sort u</code>",
 "5429":
 "<code>Std.TreeMap.filterMap.{u, v, w} {α : Type u} {β : Type v} {γ : Type w} {cmp : α → α → Ordering} (f : α → β → Option γ)\n  (m : Std.TreeMap α β cmp) : Std.TreeMap α γ cmp</code><span class=\"sep\"></span><code class=\"docstring\">Updates the values of the map by applying the given function to all mappings, keeping\nonly those mappings where the function returns `some` value.\n</code>",
 "5428":
 "<code>Std.HashMap.partition.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (f : α → β → Bool)\n  (m : Std.HashMap α β) : Std.HashMap α β × Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Partition a hash map into two hash map based on a predicate. </code>",
 "5427":
 "<code>Std.ExtHashSet.{u} (α : Type u) [BEq α] [Hashable α] : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Hash sets.\n\nThis is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash set is used linearly to\navoid expensive copies.\n\nThe hash set uses `==` (provided by the `BEq` typeclass) to compare elements and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nIn contrast to regular hash sets, `Std.ExtHashSet` offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over hash sets.\n\nThese hash sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.HashSet.Raw` and\n`Std.HashSet.Raw.WF` unbundle the invariant from the hash set. When in doubt, prefer\n`HashSet` or `ExtHashSet` over `HashSet.Raw`.\n</code>",
 "5426":
 "<code>Std.TreeSet.{u} (α : Type u) (cmp : α → α → Ordering := by exact compare) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Tree sets.\n\nA tree set stores elements of a certain type in a certain order. It depends on a comparator function\nthat defines an ordering on the keys and provides efficient order-dependent queries, such as\nretrieval of the minimum or maximum.\n\nTo ensure that the operations behave as expected, the comparator function `cmp` should satisfy\ncertain laws that ensure a consistent ordering:\n\n* If `a` is less than (or equal) to `b`, then `b` is greater than (or equal) to `a`\nand vice versa (see the `OrientedCmp` typeclass).\n* If `a` is less than or equal to `b` and `b` is, in turn, less than or equal to `c`, then `a`\nis less than or equal to `c` (see the `TransCmp` typeclass).\n\nKeys for which `cmp a b = Ordering.eq` are considered the same, i.e., there can be only one of them\nbe contained in a single tree set at the same time.\n\nTo avoid expensive copies, users should make sure that the tree set is used linearly.\n\nInternally, the tree sets are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.\n\nFor use in proofs, the type `Std.ExtTreeSet` of extensional tree sets should be preferred. This\ntype comes with several extensionality lemmas and provides the same functions but requires a\n`TransCmp` instance to work with.\n\nThese tree sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.TreeSet.Raw` and\n`Std.TreeSet.Raw.WF` unbundle the invariant from the tree set. When in doubt, prefer\n`TreeSet` over `TreeSet.Raw`.\n</code>",
 "5425":
 "<code>Std.HashSet.{u} (α : Type u) [BEq α] [Hashable α] : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Hash sets.\n\nThis is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash set is used linearly to\navoid expensive copies.\n\nThe hash set uses `==` (provided by the `BEq` typeclass) to compare elements and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nThese hash sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.Data.HashSet.Raw` and\n`Std.Data.HashSet.Raw.WF` unbundle the invariant from the hash set. When in doubt, prefer\n`HashSet` over `HashSet.Raw`.\n</code>",
 "5424":
 "<code>Std.ExtDHashMap.{u, v} (α : Type u) (β : α → Type v) [BEq α] [Hashable α] : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Extensional dependent hash maps.\n\nThis is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash map is used linearly to\navoid expensive copies.\n\nThe hash map uses `==` (provided by the `BEq` typeclass) to compare keys and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nmust be an equivalence relation and `a == b` must imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nIn contrast to regular dependent hash maps, `Std.ExtDHashMap` offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over the hash map.\n\nThese hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.DHashMap.Raw` and\n`Std.DHashMap.Raw.WF` unbundle the invariant from the hash map. When in doubt, prefer\n`DHashMap` over `DHashMap.Raw`.\n</code>",
 "5423":
 "<code>Std.ExtHashMap.{u, v} (α : Type u) (β : Type v) [BEq α] [Hashable α] : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Hash maps.\n\nThis is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash map is used linearly to\navoid expensive copies.\n\nThe hash map uses `==` (provided by the `BEq` typeclass) to compare keys and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nIn contrast to regular hash maps, `Std.ExtHashMap` offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over hash maps.\n\nThese hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.HashMap.Raw` and\n`Std.HashMap.Raw.WF` unbundle the invariant from the hash map. When in doubt, prefer\n`HashMap` or `ExtHashMap` over `HashMap.Raw`.\n\nDependent hash maps, in which keys may occur in their values' types, are available as\n`Std.ExtDHashMap` in the module `Std.Data.ExtDHashMap`.\n</code>",
 "5422":
 "<code>Std.DTreeMap.{u, v} (α : Type u) (β : α → Type v) (cmp : α → α → Ordering := by exact compare) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Dependent tree maps.\n\nA tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.\n\nTo ensure that the operations behave as expected, the comparator function `cmp` should satisfy\ncertain laws that ensure a consistent ordering:\n\n* If `a` is less than (or equal) to `b`, then `b` is greater than (or equal) to `a`\nand vice versa (see the `OrientedCmp` typeclass).\n* If `a` is less than or equal to `b` and `b` is, in turn, less than or equal to `c`, then `a`\nis less than or equal to `c` (see the `TransCmp` typeclass).\n\nKeys for which `cmp a b = Ordering.eq` are considered the same, i.e., there can be only one entry\nwith key either `a` or `b` in a tree map. Looking up either `a` or `b` always yields the same entry,\nif any is present. The `get` operations of the _dependent_ tree map additionally require a\n`LawfulEqCmp` instance to ensure that `cmp a b = .eq` always implies `a = b`, so that their\nrespective value types are equal.\n\nTo avoid expensive copies, users should make sure that the tree map is used linearly.\n\nInternally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.\n\nFor use in proofs, the type `Std.ExtDTreeMap` of extensional dependent tree maps should be\npreferred. This type comes with several extensionality lemmas and provides the same functions but\nrequires a `TransCmp` instance to work with.\n\nThese tree maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.DTreeMap.Raw` and\n`Std.DTreeMap.Raw.WF` unbundle the invariant from the tree map. When in doubt, prefer\n`DTreeMap` over `DTreeMap.Raw`.\n</code>",
 "5421":
 "<code>Std.DHashMap.{u, v} (α : Type u) (β : α → Type v) [BEq α] [Hashable α] : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Dependent hash maps.\n\nThis is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash map is used linearly to\navoid expensive copies.\n\nThe hash map uses `==` (provided by the `BEq` typeclass) to compare keys and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nThese hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.DHashMap.Raw` and\n`Std.DHashMap.Raw.WF` unbundle the invariant from the hash map. When in doubt, prefer\n`DHashMap` over `DHashMap.Raw`.\n\nFor a variant that is more convenient for use in proofs because of extensionalities, see\n`Std.ExtDHashMap` which is defined in the module `Std.Data.ExtDHashMap`.\n</code>",
 "5420": "<code>UInt8 → Bool</code>",
 "542":
 "<code>Bool.rec.{u} {motive : Bool → Sort u} (false : motive false) (true : motive true) (t : Bool) : motive t</code>",
 "5419": "<code>optParam Nat s.size</code>",
 "5418":
 "<code>ByteSlice.size (s : ByteSlice) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the size of the byte slice.\n</code>",
 "5417": "<code>UInt8 → m PUnit</code>",
 "5416": "<code>UInt8 → β → m β</code>",
 "5415":
 "<code>UInt8.toNat (n : UInt8) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 8-bit unsigned integer to an arbitrary-precision natural number.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "5414":
 "<code>ByteSlice.foldr.{v} {β : Type v} (f : UInt8 → β → β) (init : β) (as : ByteSlice) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds an operation from right to left over the bytes in a byte slice.\n\nAn accumulator of type `β` is constructed by starting with `init` and combining each byte of the\nbyte slice with the current accumulator value in turn, moving from the end to the start.\n\nExamples:\n * `(ByteArray.mk #[1, 2, 3]).toByteSlice.foldr (·.toNat + ·) 0 = 6`\n * `(ByteArray.mk #[1, 2, 3]).toByteSlice.popFront.foldr (·.toNat + ·) 0 = 5`\n</code>",
 "5413":
 "<code>ByteArray.toByteSlice (as : ByteArray) (start : Nat := 0) (stop : Nat := as.size) : ByteSlice</code><span class=\"sep\"></span><code class=\"docstring\">Returns a byte slice of a byte array, with the given bounds.\n\nIf `start` or `stop` are not valid bounds for a byte slice, then they are clamped to byte array's size.\nAdditionally, the starting index is clamped to the ending index.\n</code>",
 "5412": "<code>UInt8 → β → β</code>",
 "5411": "<code>ByteSlice</code>",
 "5410":
 "<code>ByteSlice : Type</code><span class=\"sep\"></span><code class=\"docstring\">A region of some underlying byte array.\n\nA byte slice contains a byte array together with the start and end indices of a region of interest.\nByte slices can be used to avoid copying or allocating space, while being more convenient than\ntracking the bounds by hand. The region of interest consists of every index that is both greater\nthan or equal to `start` and strictly less than `stop`.\n</code>",
 "541": "<code>FamilyBike</code>",
 "5409":
 "<code>ByteArray.Iterator.atEnd : ByteArray.Iterator → Bool</code><span class=\"sep\"></span><code class=\"docstring\">True if the iterator is past the array's last byte\\. </code>",
 "5408":
 "<code>ByteArray.Iterator.toEnd : ByteArray.Iterator → ByteArray.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Moves the iterator's position to the end of the array\\.\n\nGiven `i : ByteArray.Iterator`, note that `i.toEnd.atEnd` is always `true`\\.\n</code>",
 "5407":
 "<code>ByteArray.Iterator.hasNext : ByteArray.Iterator → Bool</code><span class=\"sep\"></span><code class=\"docstring\">True if the iterator is valid; that is, it is not past the array's last byte\\.\n</code>",
 "5406": "<code>ByteArray.Iterator</code>",
 "5405":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The current position.\n\nThis position is not necessarily valid for the array, for instance if one keeps calling\n`Iterator.next` when `Iterator.atEnd` is true. If the position is not valid, then the\ncurrent byte is `(default : UInt8)`. </code>",
 "5404":
 "<code>ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">The array the iterator is for. </code>",
 "5403":
 "<code>ByteArray.Iterator.mk (array : ByteArray) (idx : Nat) : ByteArray.Iterator</code>",
 "5402":
 "<code>ByteArray.Iterator : Type</code><span class=\"sep\"></span><code class=\"docstring\">Iterator over the bytes (`UInt8`) of a `ByteArray`.\n\nTypically created by `arr.iter`, where `arr` is a `ByteArray`.\n\nAn iterator is *valid* if the position `i` is *valid* for the array `arr`, meaning `0 ≤ i ≤ arr.size`\n\nMost operations on iterators return arbitrary values if the iterator is not valid. The functions in\nthe `ByteArray.Iterator` API should rule out the creation of invalid iterators, with two exceptions:\n\n- `Iterator.next iter` is invalid if `iter` is already at the end of the array (`iter.atEnd` is\n  `true`)\n- `Iterator.forward iter n`/`Iterator.nextn iter n` is invalid if `n` is strictly greater than the\n  number of remaining bytes.\n</code>",
 "5401":
 "<code>ByteArray.forInUnsafe.{v, w} {β : Type v} {m : Type v → Type w} [Monad m] (as : ByteArray) (b : β)\n  (f : UInt8 → β → m (ForInStep β)) : m β</code><span class=\"sep\"></span><code class=\"docstring\">An efficient implementation of `ForIn.forIn` for `ByteArray` that uses `USize`\nrather than `Nat` for indices\\.\n\nWe claim this unsafe implementation is correct because an array cannot have more than\n`USize.size` elements in our runtime\\. This is similar to the `Array` version\\.\n</code>",
 "5400": "<code>UInt8 → β → m (ForInStep β)</code>",
 "540":
 "<code>ElectricFamilyBike.mk (toFamilyBike : FamilyBike) (batteries : Nat) : ElectricFamilyBike</code>",
 "54": "<code>List α</code>",
 "5399": "<code>β → UInt8 → m β</code>",
 "5398":
 "<code>ByteArray.foldlM.{v, w} {β : Type v} {m : Type v → Type w} [Monad m] (f : β → UInt8 → m β) (init : β) (as : ByteArray)\n  (start : Nat := 0) (stop : Nat := as.size) : m β</code><span class=\"sep\"></span><code class=\"docstring\">A monadic left fold on `ByteArray` that iterates over an array from low to high indices,\ncomputing a running value\\.\n\nEach element of the array is combined with the value from the prior elements using a monadic\nfunction `f`\\. The initial value `init` is the starting value before any elements have\nbeen processed\\.\n</code>",
 "5397": "<code>β → UInt8 → β</code>",
 "5396":
 "<code>ByteArray.utf8DecodeChar? (bytes : ByteArray) (i : Nat) : Option Char</code><span class=\"sep\"></span><code class=\"docstring\">Decodes and returns the `Char` whose UTF-8 encoding begins at `i` in `bytes`.\n\nReturns `none` if `i` is not the start of a valid UTF-8 encoding of a character.\n</code>",
 "5395": "<code>(bytes.utf8DecodeChar? i).isSome = true</code>",
 "5394": "<code>autoParam (i.toNat &lt; a.size) _auto✝</code>",
 "5393": "<code>autoParam (i &lt; a.size) _auto✝</code>",
 "5392": "<code>ByteArray.fastAppend (a b : ByteArray) : ByteArray</code>",
 "5391":
 "<code>ByteArray.append (a b : ByteArray) : ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Appends two byte arrays\\.\n\nIn compiled code, calls to `ByteArray.append` are replaced with the much more efficient\n`ByteArray.fastAppend`\\.\n</code>",
 "5390":
 "<code>ByteArray.emptyWithCapacity (c : Nat) : ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new empty byte array with initial capacity `c`.\n</code>",
 "539":
 "<code>ElectricFamilyBike.toElectricBike (self : ElectricFamilyBike) : ElectricBike</code>",
 "5389":
 "<code>Array UInt8</code><span class=\"sep\"></span><code class=\"docstring\">The data contained in the byte array.\n\nConverting between `Array` and `ByteArray` takes linear time.\n</code>",
 "5388":
 "<code>ByteArray.mk (data : Array UInt8) : ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Packs an array of bytes into a `ByteArray`.\n\nConverting between `Array` and `ByteArray` takes linear time.\n</code>",
 "5387":
 "<code>List.toByteArray (bs : List UInt8) : ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Converts a list of bytes into a `ByteArray`.\n</code>",
 "5386":
 "<code>Subarray.anyM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Subarray α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether any of the elements in a subarray satisfy a monadic Boolean predicate.\n\nThe elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that satisfies the predicate is found.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\", \"orange\"].toSubarray.popFront.anyM fun x =&gt; do\n  IO.println x\n  pure (x == \"blue\")\n```\n```output\ngreen\nblue\n```\n```output\ntrue\n```\n</code>",
 "5385":
 "<code>Subarray.allM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Subarray α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether all of the elements in a subarray satisfy a monadic Boolean predicate.\n\nThe elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that does not satisfy the predicate is found.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\", \"orange\"].toSubarray.popFront.allM fun x =&gt; do\n  IO.println x\n  pure (x.length == 5)\n```\n```output\ngreen\nblue\n```\n```output\nfalse\n```\n</code>",
 "5384":
 "<code>Subarray.findSomeRevM?.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : Subarray α)\n  (f : α → m (Option β)) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function to each element in a subarray in reverse order, stopping at the first\nelement for which the function succeeds by returning a value other than `none`. The succeeding value\nis returned, or `none` if there is no success.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.findSomeRevM? fun x =&gt; do\n  IO.println x\n  return Option.guard (· = 5) x.length\n```\n```output\nblue\ngreen\n```\n```output\nsome 5\n```\n</code>",
 "5383":
 "<code>Subarray.findRevM?.{w} {α : Type} {m : Type → Type w} [Monad m] (as : Subarray α) (p : α → m Bool) : m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic Boolean predicate to each element in a subarray in reverse order, stopping at the\nfirst element that satisfies the predicate. The element that satisfies the predicate is returned, or\n`none` if no element satisfies it.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.findRevM? fun x =&gt; do\n  IO.println x\n  return (x.length = 5)\n```\n```output\nblue\ngreen\n```\n```output\nsome 5\n```\n</code>",
 "5382":
 "<code>Subarray.findRev? {α : Type} (as : Subarray α) (p : α → Bool) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Tests each element in a subarray with a Boolean predicate in reverse order, stopping at the first\nelement that satisfies the predicate. The element that satisfies the predicate is returned, or\n`none` if no element satisfies the predicate.\n\nExamples:\n * `#[\"red\", \"green\", \"blue\"].toSubarray.findRev? (·.length ≠ 4) = some \"green\"`\n * `#[\"red\", \"green\", \"blue\"].toSubarray.findRev? (fun _ =&gt; true) = some \"blue\"`\n * `#[\"red\", \"green\", \"blue\"].toSubarray 0 0 |&gt;.findRev? (fun _ =&gt; true) = none`\n</code>",
 "5381":
 "<code>Subarray.foldrM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → β → m β) (init : β)\n  (as : Subarray α) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic operation from right to left over the elements in a subarray.\n\nAn accumulator of type `β` is constructed by starting with `init` and monadically combining each\nelement of the subarray with the current accumulator value in turn, moving from the end to the\nstart. The monad in question may permit early termination or repetition.\n\nExamples:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldrM (init := \"\") fun x acc =&gt; do\n  let l ← Option.guard (· ≠ 0) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nsome \"(4)blue (5)green (3)red \"\n```\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldrM (init := 0) fun x acc =&gt; do\n  let l ← Option.guard (· ≠ 5) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nnone\n```\n</code>",
 "5380":
 "<code><span class=\"literal string\">\"(4)blue (5)green (3)red \"</span> : String</code>",
 "538":
 "<code>ElectricFamilyBike.toFamilyBike (self : ElectricFamilyBike) : FamilyBike</code>",
 "5379":
 "<code>Subarray.foldr.{u, v} {α : Type u} {β : Type v} (f : α → β → β) (init : β) (as : Subarray α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds an operation from right to left over the elements in a subarray.\n\nAn accumulator of type `β` is constructed by starting with `init` and combining each element of the\nsubarray with the current accumulator value in turn, moving from the end to the start.\n\nExamples:\n * `#[\"red\", \"green\", \"blue\"].toSubarray.foldr (·.length + ·) 0 = 12`\n * `#[\"red\", \"green\", \"blue\"].toSubarray.popFront.foldr (·.length + ·) 0 = 9`\n</code>",
 "5378":
 "<code>Subarray.foldlM.{v, w, u} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : β → α → m β) (init : β)\n  (as : Subarray α) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic operation from left to right over the elements in a subarray.\nAn accumulator of type `β` is constructed by starting with `init` and monadically combining each\nelement of the subarray with the current accumulator value in turn. The monad in question may permit\nearly termination or repetition.\nExamples:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldlM (init := \"\") fun acc x =&gt; do\n  let l ← Option.guard (· ≠ 0) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nsome \"(3)red (5)green (4)blue \"\n```\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldlM (init := 0) fun acc x =&gt; do\n  let l ← Option.guard (· ≠ 5) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nnone\n```\n</code>",
 "5377":
 "<code><span class=\"literal string\">\"(3)red (5)green (4)blue \"</span> : String</code>",
 "5376":
 "<code>Subarray.foldl.{v, u} {α : Type u} {β : Type v} (f : β → α → β) (init : β) (as : Subarray α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds an operation from left to right over the elements in a subarray.\nAn accumulator of type `β` is constructed by starting with `init` and combining each\nelement of the subarray with the current accumulator value in turn.\nExamples:\n * `#[\"red\", \"green\", \"blue\"].toSubarray.foldl (· + ·.length) 0 = 12`\n * `#[\"red\", \"green\", \"blue\"].toSubarray.popFront.foldl (· + ·.length) 0 = 9`\n</code>",
 "5375": "<code>Fin s.size</code>",
 "5374":
 "<code>Subarray.size.{u_1} {α : Type u_1} (s : Subarray α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the size of the subarray.\n</code>",
 "5373": "<code>Fin s.size.succ</code>",
 "5372":
 "<code>Subarray.toArray.{u} {α : Type u} (s : Subarray α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Allocates a new array that contains the contents of the subarray.\n</code>",
 "5371":
 "<code>Subarray.popFront.{u_1} {α : Type u_1} (s : Subarray α) : Subarray α</code><span class=\"sep\"></span><code class=\"docstring\">Shrinks the subarray by incrementing its starting index if possible, returning it unchanged if not.\n\nExamples:\n* `#[1,2,3].toSubarray.popFront.toArray = #[2, 3]`\n* `#[1,2,3].toSubarray.popFront.popFront.toArray = #[3]`\n* `#[1,2,3].toSubarray.popFront.popFront.popFront.toArray = #[]`\n* `#[1,2,3].toSubarray.popFront.popFront.popFront.popFront.toArray = #[]`\n</code>",
 "5370":
 "<code>Array.toSubarray.{u} {α : Type u} (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : Subarray α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a subarray of an array, with the given bounds.\n\nIf `start` or `stop` are not valid bounds for a subarray, then they are clamped to array's size.\nAdditionally, the starting index is clamped to the ending index.\n</code>",
 "537": "<code>Bicycle</code>",
 "5369":
 "<code>Subarray.stop.{u_1} {α : Type u_1} (xs : Subarray α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The ending index of the region of interest (exclusive). </code>",
 "5368":
 "<code>Subarray.start.{u_1} {α : Type u_1} (xs : Subarray α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The starting index of the region of interest (inclusive). </code>",
 "5367":
 "<code>Array.pmap.{u_1, u_2} {α : Type u_1} {β : Type u_2} {P : α → Prop} (f : (a : α) → P a → β) (xs : Array α)\n  (H : ∀ (a : α), a ∈ xs → P a) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Maps a partially defined function (defined on those terms of `α` that satisfy a predicate `P`) over\nan array `xs : Array α`, given a proof that every element of `xs` in fact satisfies `P`.\n\n`Array.pmap`, named for “partial map,” is the equivalent of `Array.map` for such partial functions.\n</code>",
 "5366": "<code>∀ (a : α), a ∈ xs → P a</code>",
 "5365":
 "<code>Array.attachWith.{u_1} {α : Type u_1} (xs : Array α) (P : α → Prop) (H : ∀ (x : α), x ∈ xs → P x) : Array { x // P x }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” individual proofs to an array of values that satisfy a predicate `P`, returning an array\nof elements in the corresponding subtype `{ x // P x }`.\n\n`O(1)`.\n</code>",
 "5364": "<code>Array { x // p x }</code>",
 "5363": "<code>∀ (x : α), x ∈ xs → P x</code>",
 "5362":
 "<code>Array.lex.{u_1} {α : Type u_1} [BEq α] (as bs : Array α) (lt : α → α → Bool := by exact (· &lt; ·)) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Compares arrays lexicographically with respect to a comparison `lt` on their elements.\n\nSpecifically, `Array.lex as bs lt` is true if\n* `bs` is larger than `as` and `as` is pairwise equivalent via `==` to the initial segment of `bs`,\n  or\n* there is an index `i` such that `lt as[i] bs[i]`, and for all `j &lt; i`, `as[j] == bs[j]`.\n</code>",
 "5361":
 "<code>Array.isPrefixOf.{u} {α : Type u} [BEq α] (as bs : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Return `true` if `as` is a prefix of `bs`, or `false` otherwise.\n\nExamples:\n* `#[0, 1, 2].isPrefixOf #[0, 1, 2, 3] = true`\n* `#[0, 1, 2].isPrefixOf #[0, 1, 2] = true`\n* `#[0, 1, 2].isPrefixOf #[0, 1] = false`\n* `#[].isPrefixOf #[0, 1] = true`\n</code>",
 "5360":
 "<code>Array.isEqv.{u} {α : Type u} (xs ys : Array α) (p : α → α → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `as` and `bs` have the same length and they are pairwise related by `eqv`.\n\nShort-circuits at the first non-related pair of elements.\n\nExamples:\n* `#[1, 2, 3].isEqv #[2, 3, 4] (· &lt; ·) = true`\n* `#[1, 2, 3].isEqv #[2, 2, 4] (· &lt; ·) = false`\n* `#[1, 2, 3].isEqv #[2, 3] (· &lt; ·) = false`\n</code>",
 "536":
 "<code>ElectricBike.mk (toBicycle : Bicycle) (batteries : Nat) : ElectricBike</code>",
 "5359":
 "<code>Array.allDiff.{u} {α : Type u} [BEq α] (as : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if no two elements of `as` are equal according to the `==` operator.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\"].allDiff = true`\n* `#[\"red\", \"green\", \"red\"].allDiff = false`\n* `(#[] : Array Nat).allDiff = true`\n</code>",
 "5358":
 "<code>Array.any.{u} {α : Type u} (as : Array α) (p : α → Bool) (start : Nat := 0) (stop : Nat := as.size) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for any element of `as`.\n\nShort-circuits upon encountering the first `true`.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n\nExamples:\n* `#[2, 4, 6].any (· % 2 = 0) = true`\n* `#[2, 4, 6].any (· % 2 = 1) = false`\n* `#[2, 4, 5, 6].any (· % 2 = 0) = true`\n* `#[2, 4, 5, 6].any (· % 2 = 1) = true`\n</code>",
 "5357":
 "<code>Array.all.{u} {α : Type u} (as : Array α) (p : α → Bool) (start : Nat := 0) (stop : Nat := as.size) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for every element of `as`.\n\nShort-circuits upon encountering the first `false`.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n\nExamples:\n* `#[a, b, c].all p = (p a && (p b && p c))`\n* `#[2, 4, 6].all (· % 2 = 0) = true`\n* `#[2, 4, 5, 6].all (· % 2 = 0) = false`\n</code>",
 "5356":
 "<code><span class=\"literal string\">\"Zero!\"</span> : String</code>",
 "5355":
 "<code>Array.findSome?.{u, v} {α : Type u} {β : Type v} (f : α → Option β) (as : Array α) : Option β</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the function `f` to each element of the\narray, in order. Returns `none` if `f` returns `none` for all elements.\n\nExample:\n```lean example\n#eval #[7, 6, 5, 8, 1, 2, 6].findSome? fun i =&gt;\n  if i &lt; 5 then\n    some (i * 10)\n  else\n    none\n```\n```output\nsome 10\n```\n</code>",
 "5354": "<code>Type → Type w</code>",
 "5353":
 "<code>Array.findFinIdx?.{u} {α : Type u} (p : α → Bool) (as : Array α) : Option (Fin as.size)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or `none` if there is no such\nelement. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 5) = some (4 : Fin 7)`\n* `#[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 1) = none`\n</code>",
 "5352":
 "<code>Array.findIdx.{u} {α : Type u} (p : α → Bool) (as : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or the size of the array if\nthere is no such element.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 5) = 4`\n* `#[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 1) = 7`\n</code>",
 "5351":
 "<code>Array.findRev? {α : Type} (p : α → Bool) (as : Array α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of the array for which the predicate `p` returns `true`, or `none` if no\nsuch element is found.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].findRev? (· &lt; 5) = some 2`\n* `#[7, 6, 5, 8, 1, 2, 6].findRev? (· &lt; 1) = none`\n</code>",
 "5350":
 "<code>Array.find?.{u} {α : Type u} (p : α → Bool) (as : Array α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the array for which the predicate `p` returns `true`, or `none` if no\nsuch element is found.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 5) = some 1`\n* `#[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 1) = none`\n</code>",
 "535":
 "<code>ElectricBike.toElectricVehicle (self : ElectricBike) : ElectricVehicle</code>",
 "5349":
 "<code>Array.contains.{u} {α : Type u} [BEq α] (as : Array α) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `as`, using `==` to compare elements.\n\n`Array.elem` is a synonym that takes the element before the array.\n\nExamples:\n* `#[1, 4, 2, 3, 3, 7].contains 3 = true`\n* `Array.contains #[1, 4, 2, 3, 3, 7] 5 = false`\n</code>",
 "5348":
 "<code>Array.elem.{u} {α : Type u} [BEq α] (a : α) (as : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `as`, using `==` to compare elements.\n\n`Array.contains` is a synonym that takes the array before the element.\n\nFor verification purposes, `Array.elem` is simplified to `Array.contains`.\n\nExample:\n* `Array.elem 3 #[1, 4, 2, 3, 3, 7] = true`\n* `Array.elem 5 #[1, 4, 2, 3, 3, 7] = false`\n</code>",
 "5347":
 "<code>Array.groupByKey.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (key : β → α) (xs : Array β) :\n  Std.HashMap α (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Groups the elements of an array `xs` according to the function `key`, returning a hash map in which\neach group is associated with its key. Groups preserve the relative order of elements in `xs`.\n\nExample:\n```lean example\n#eval #[0, 1, 2, 3, 4, 5, 6].groupByKey (· % 2)\n```\n```output\nStd.HashMap.ofList [(0, #[0, 2, 4, 6]), (1, #[1, 3, 5])]\n```\n</code>",
 "5346":
 "<code>Array.partition.{u} {α : Type u} (p : α → Bool) (as : Array α) : Array α × Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a pair of arrays that together contain all the elements of `as`. The first array contains\nthose elements for which `p` returns `true`, and the second contains those for which `p` returns\n`false`.\n\n`as.partition p` is equivalent to `(as.filter p, as.filter (not ∘ p))`, but it is\nmore efficient since it only has to do one pass over the array.\n\nExamples:\n * `#[1, 2, 5, 2, 7, 7].partition (· &gt; 2) = (#[5, 7, 7], #[1, 2, 2])`\n * `#[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; false) = (#[], #[1, 2, 5, 2, 7, 7])`\n * `#[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; true) = (#[1, 2, 5, 2, 7, 7], #[])`\n</code>",
 "5345": "<code>Lean.Syntax → m Bool</code>",
 "5344": "<code>Lean.Syntax → Bool</code>",
 "5343": "<code>Array Lean.Syntax</code>",
 "5342":
 "<code>Array.filterMap.{u, u_1} {α : Type u} {β : Type u_1} (f : α → Option β) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an `Option` to each element of an array, collecting the non-`none`\nvalues.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterMap fun x =&gt;\n  if x &gt; 2 then some (2 * x) else none\n```\n```output\n#[10, 14, 14]\n```\n</code>",
 "5341":
 "<code>Array.filterRevM.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → m Bool) (as : Array α)\n  (start : Nat := as.size) (stop : Nat := 0) : m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` on every element in the array in reverse order, from right to\nleft, and returns those elements for which `p` returns `true`. The elements of the returned list are\nin the same order as in the input list.\n\nOnly elements from `start` (exclusive) to `stop` (inclusive) are considered. Elements outside that\nrange are discarded. Because the array is examined in reverse order, elements are only examined when\n`start &gt; stop`. By default, the entire array is considered.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterRevM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 7\nChecking 7\nChecking 2\nChecking 5\nChecking 2\nChecking 1\n```\n```output\n#[1, 2, 2]\n```\n</code>",
 "5340": "<code>?m.77</code>",
 "534": "<code>ElectricBike.toBicycle (self : ElectricBike) : Bicycle</code>",
 "5339": "<code>?m.69</code>",
 "5338":
 "<code>Array.unzip.{u, u_1} {α : Type u} {β : Type u_1} (as : Array (α × β)) : Array α × Array β</code><span class=\"sep\"></span><code class=\"docstring\">Separates an array of pairs into two arrays that contain the respective first and second components.\n\nExamples:\n* `#[(\"Monday\", 1), (\"Tuesday\", 2)].unzip = (#[\"Monday\", \"Tuesday\"], #[1, 2])`\n* `#[(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzip = (#[x₁, x₂, x₃], #[y₁, y₂, y₃])`\n* `(#[] : Array (Nat × String)).unzip = ((#[], #[]) : List Nat × List String)`\n</code>",
 "5337": "<code>Array (α × β)</code>",
 "5336": "<code>?m.63</code>",
 "5335":
 "<code>Array.zipIdx.{u} {α : Type u} (xs : Array α) (start : Nat := 0) : Array (α × Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Pairs each element of an array with its index, optionally starting from an index other than `0`.\n\nExamples:\n* `#[a, b, c].zipIdx = #[(a, 0), (b, 1), (c, 2)]`\n* `#[a, b, c].zipIdx 5 = #[(a, 5), (b, 6), (c, 7)]`\n</code>",
 "5334": "<code>?m.31</code>",
 "5333":
 "<code>Array.zipWithAll.{u, u_1, u_2} {α : Type u} {β : Type u_1} {γ : Type u_2} (f : Option α → Option β → γ) (as : Array α)\n  (bs : Array β) : Array γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of both arrays, stopping when there are no more\nelements in either array. If one array is shorter than the other, the function is passed `none` for\nthe missing elements.\n\nExamples:\n* `#[1, 6].zipWithAll min #[5, 2] = #[some 1, some 2]`\n* `#[1, 2, 3].zipWithAll Prod.mk #[5, 6] = #[(some 1, some 5), (some 2, some 6), (some 3, none)]`\n* `#[x₁, x₂].zipWithAll f #[y] = #[f (some x₁) (some y), f (some x₂) none]`\n</code>",
 "5332":
 "<code>Array.zipWith.{u, u_1, u_2} {α : Type u} {β : Type u_1} {γ : Type u_2} (f : α → β → γ) (as : Array α) (bs : Array β) :\n  Array γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of two arrays, stopping at the end of the shorter\narray.\n\nExamples:\n* `#[1, 2].zipWith (· + ·) #[5, 6] = #[6, 8]`\n* `#[1, 2, 3].zipWith (· + ·) #[5, 6, 10] = #[6, 8, 13]`\n* `#[].zipWith (· + ·) #[5, 6] = #[]`\n* `#[x₁, x₂, x₃].zipWith f #[y₁, y₂, y₃, y₄] = #[f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n</code>",
 "5331": "<code>?m.113</code>",
 "5330": "<code>?m.112</code>",
 "533": "<code>ElectricBike.batteries (self : ElectricBike) : Nat</code>",
 "5329":
 "<code>Array.zip.{u, u_1} {α : Type u} {β : Type u_1} (as : Array α) (bs : Array β) : Array (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">Combines two arrays into an array of pairs in which the first and second components are the\ncorresponding elements of each input array. The resulting array is the length of the shorter of the\ninput arrays.\n\nExamples:\n* `#[\"Mon\", \"Tue\", \"Wed\"].zip #[1, 2, 3] = #[(\"Mon\", 1), (\"Tue\", 2), (\"Wed\", 3)]`\n* `#[\"Mon\", \"Tue\", \"Wed\"].zip #[1, 2] = #[(\"Mon\", 1), (\"Tue\", 2)]`\n* `#[x₁, x₂, x₃].zip #[y₁, y₂, y₃, y₄] = #[(x₁, y₁), (x₂, y₂), (x₃, y₃)]`\n</code>",
 "5328": "<code>α → m (Array β)</code>",
 "5327":
 "<code>Array.flatMap.{u, u_1} {α : Type u} {β : Type u_1} (f : α → Array β) (as : Array α) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an array to each element of an array. The resulting arrays are\nappended.\n\nExamples:\n* `#[2, 3, 2].flatMap Array.range = #[0, 1, 0, 1, 2, 0, 1]`\n* `#[['a', 'b'], ['c', 'd', 'e']].flatMap List.toArray = #['a', 'b', 'c', 'd', 'e']`\n</code>",
 "5326": "<code>α → Array β</code>",
 "5325": "<code>(i : Nat) → α → i &lt; as.size → m β</code>",
 "5324":
 "<code>Array.mapIdx.{u, v} {α : Type u} {β : Type v} (f : Nat → α → β) (as : Array α) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the array along with the index at which that element is found,\nreturning the array of results.\n\n`Array.mapFinIdx` is a variant that additionally provides the function with a proof that the index\nis valid.\n</code>",
 "5323": "<code>(i : Nat) → α → i &lt; as.size → β</code>",
 "5322":
 "<code>Array.mapFinIdx.{u, v} {α : Type u} {β : Type v} (as : Array α) (f : (i : Nat) → α → i &lt; as.size → β) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the array along with the index at which that element is found,\nreturning the array of results. In addition to the index, the function is also provided with a proof\nthat the index is valid.\n\n`Array.mapIdx` is a variant that does not provide the function with evidence that the index is\nvalid.\n</code>",
 "5321":
 "<code>Array.map.{u, v} {α : Type u} {β : Type v} (f : α → β) (as : Array α) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the array, returning the resulting array of values.\n\nExamples:\n* `#[a, b, c].map f = #[f a, f b, f c]`\n* `#[].map Nat.succ = #[]`\n* `#[\"one\", \"two\", \"three\"].map (·.length) = #[3, 3, 5]`\n* `#[\"one\", \"two\", \"three\"].map (·.reverse) = #[\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "5320":
 "<code>Array.firstM.{u, v, w} {β : Type v} {α : Type u} {m : Type v → Type w} [Alternative m] (f : α → m β) (as : Array α) :\n  m β</code><span class=\"sep\"></span><code class=\"docstring\">Maps `f` over the array and collects the results with `&lt;|&gt;`. The result for the end of the array is\n`failure`.\n\nExamples:\n * `#[[], [1, 2], [], [2]].firstM List.head? = some 1`\n * `#[[], [], []].firstM List.head? = none`\n * `#[].firstM List.head? = none`\n</code>",
 "532": "<code>ElectricVehicle.batteries (self : ElectricVehicle) : Nat</code>",
 "5319": "<code>β → α → m β</code>",
 "5318":
 "<code>Array.foldr.{u, v} {α : Type u} {β : Type v} (f : α → β → β) (init : β) (as : Array α) (start : Nat := as.size)\n  (stop : Nat := 0) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over an array from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the array in reverse order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (exclusive) to `stop` (inclusive), so no folding occurs unless `start &gt; stop`.\nBy default, the entire array is used.\n\nExamples:\n * `#[a, b, c].foldr f init  = f a (f b (f c init))`\n * `#[1, 2, 3].foldr (toString · ++ ·) \"\" = \"123\"`\n * `#[1, 2, 3].foldr (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"`\n</code>",
 "5317":
 "<code>Array.binInsert.{u} {α : Type u} (lt : α → α → Bool) (as : Array α) (k : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a sorted array such that the resulting array is sorted. If the element is\nalready present in the array, it is not inserted.\n\nThe ordering predicate `lt` should be a total order on elements, and the array `as` should be sorted\nwith respect to `lt`.\n\n`Array.binInsertM` is a more general operator that provides greater control over the handling of\nduplicate elements in addition to running in a monad.\n\nExamples:\n* `#[0, 1, 3, 5].binInsert (· &lt; ·) 2 = #[0, 1, 2, 3, 5]`\n* `#[0, 1, 3, 5].binInsert (· &lt; ·) 1 = #[0, 1, 3, 5]`\n* `#[].binInsert (· &lt; ·) 1 = #[1]`\n</code>",
 "5316":
 "<code>Array.binInsertM.{u, v} {α : Type u} {m : Type u → Type v} [Monad m] (lt : α → α → Bool) (merge : α → m α)\n  (add : Unit → m α) (as : Array α) (k : α) : m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element `k` into a sorted array `as` such that the resulting array is sorted.\n\nThe ordering predicate `lt` should be a total order on elements, and the array `as` should be sorted\nwith respect to `lt`.\n\nIf an element that `lt` equates to `k` is already present in `as`, then `merge` is applied to the\nexisting element to determine the value of that position in the resulting array. If no element equal\nto `k` is present, then `add` is used to determine the value to be inserted.\n</code>",
 "5315": "<code>optParam Nat (as.size - 1)</code>",
 "5314":
 "<code>Array.getEvenElems.{u} {α : Type u} (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new array that contains the elements at even indices in `as`, starting with the element at\nindex `0`.\n\nExamples:\n* `#[0, 1, 2, 3, 4].getEvenElems = #[0, 2, 4]`\n* `#[1, 2, 3, 4].getEvenElems = #[1, 3]`\n* `#[\"red\", \"green\", \"blue\"].getEvenElems = #[\"red\", \"blue\"]`\n* `(#[] : Array String).getEvenElems = #[]`\n</code>",
 "5313":
 "<code>Array.flatten.{u} {α : Type u} (xss : Array (Array α)) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Appends the contents of array of arrays into a single array. The resulting array contains the same\nelements as the nested arrays in the same order.\n\nExamples:\n * `#[#[5], #[4], #[3, 2]].flatten = #[5, 4, 3, 2]`\n * `#[#[0, 1], #[], #[2], #[1, 0, 1]].flatten = #[0, 1, 2, 1, 0, 1]`\n * `(#[] : Array Nat).flatten = #[]`\n</code>",
 "5312": "<code>Array (Array α)</code>",
 "5311":
 "<code>Array.shrink.{u} {α : Type u} (xs : Array α) (n : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first `n` elements of an array. The resulting array is produced by repeatedly calling\n`Array.pop`. If `n` is greater than the size of the array, it is returned unmodified.\n\nIf the reference to the array is unique, then this function uses in-place modification.\n\nExamples:\n* `#[0, 1, 2, 3, 4].shrink 2 = #[0, 1]`\n* `#[0, 1, 2, 3, 4].shrink 0 = #[]`\n* `#[0, 1, 2, 3, 4].shrink 10 = #[0, 1, 2, 3, 4]`\n</code>",
 "5310":
 "<code>Array.drop.{u} {α : Type u} (xs : Array α) (i : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first `i` elements of `xs`. If `xs` has fewer than `i` elements, the new array is empty.\n\nThe returned array is always a new array, even if it contains the same elements as the input array.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\"].drop 1 = #[\"green\", \"blue\"]`\n* `#[\"red\", \"green\", \"blue\"].drop 2 = #[\"blue\"]`\n* `#[\"red\", \"green\", \"blue\"].drop 5 = #[]`\n</code>",
 "531": "<code>ElectricVehicle : Type</code>",
 "5309":
 "<code>Array.takeWhile.{u} {α : Type u} (p : α → Bool) (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new array that contains the longest prefix of elements that satisfy the predicate `p` from\nan array.\n\nExamples:\n * `#[0, 1, 2, 3, 2, 1].takeWhile (· &lt; 2) = #[0, 1]`\n * `#[0, 1, 2, 3, 2, 1].takeWhile (· &lt; 20) = #[0, 1, 2, 3, 2, 1]`\n * `#[0, 1, 2, 3, 2, 1].takeWhile (· &lt; 0) = #[]`\n</code>",
 "5308":
 "<code>Array.insertIdx!.{u} {α : Type u} (as : Array α) (i : Nat) (a : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into an array at the specified index. Panics if the index is greater than the\nsize of the array.\n\nIn other words, the new element is inserted into the array `as` after the first `i` elements of\n`as`.\n\nThis function takes worst case `O(n)` time because it has to swap the inserted element into place.\n`Array.insertIdx` and `Array.insertIdxIfInBounds` are safer alternatives.\n\nExamples:\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx! 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx! 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx! 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]`\n</code>",
 "5307":
 "<code>Array.insertIdxIfInBounds.{u} {α : Type u} (as : Array α) (i : Nat) (a : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into an array at the specified index. The array is returned unmodified if the\nindex is greater than the size of the array.\n\nIn other words, the new element is inserted into the array `as` after the first `i` elements of\n`as`.\n\nThis function takes worst case `O(n)` time because it has to swap the inserted element into place.\n\nExamples:\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 4 \"wed\" = #[\"tues\", \"thur\", \"sat\"]`\n</code>",
 "5306":
 "<code>Array.insertIdx.{u} {α : Type u} (as : Array α) (i : Nat) (a : α) : autoParam (i ≤ as.size) _auto✝ → Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into an array at the specified index. If the index is greater than the size of\nthe array, then the array is returned unmodified.\n\nIn other words, the new element is inserted into the array `as` after the first `i` elements of\n`as`.\n\nThis function takes worst case `O(n)` time because it has to swap the inserted element into place.\n\nExamples:\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]`\n</code>",
 "5305": "<code>_auto✝ : Lean.Syntax</code>",
 "5304":
 "<code>Array.modifyOp.{u} {α : Type u} (xs : Array α) (idx : Nat) (f : α → α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it. If the\nindex is invalid, the array is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].modifyOp 0 (· * 10) = #[10, 2, 3]`\n * `#[1, 2, 3].modifyOp 2 (· * 10) = #[1, 2, 30]`\n * `#[1, 2, 3].modifyOp 3 (· * 10) = #[1, 2, 3]`\n</code>",
 "5303":
 "<code>Array.modify.{u} {α : Type u} (xs : Array α) (i : Nat) (f : α → α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it. If the\nindex is invalid, the array is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].modify 0 (· * 10) = #[10, 2, 3]`\n * `#[1, 2, 3].modify 2 (· * 10) = #[1, 2, 30]`\n * `#[1, 2, 3].modify 3 (· * 10) = #[1, 2, 3]`\n</code>",
 "5302":
 "<code>Array.setIfInBounds.{u_1} {α : Type u_1} (xs : Array α) (i : Nat) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the provided index in an array. The array is returned unmodified if the\nindex is out of bounds.\n\nThe array is modified in-place if there are no other references to it.\n\nExamples:\n* `#[0, 1, 2].setIfInBounds 1 5 = #[0, 5, 2]`\n* `#[\"orange\", \"apple\"].setIfInBounds 1 \"grape\" = #[\"orange\", \"grape\"]`\n* `#[\"orange\", \"apple\"].setIfInBounds 5 \"grape\" = #[\"orange\", \"apple\"]`\n</code>",
 "5301":
 "<code>Array.replace.{u} {α : Type u} [BEq α] (xs : Array α) (a b : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first occurrence of `a` with `b` in an array. The modification is performed in-place\nwhen the reference to the array is unique. Returns the array unmodified when `a` is not present.\n\nExamples:\n* `#[1, 2, 3, 2, 1].replace 2 5 = #[1, 5, 3, 2, 1]`\n* `#[1, 2, 3, 2, 1].replace 0 5 = #[1, 2, 3, 2, 1]`\n* `#[].replace 2 5 = #[]`\n</code>",
 "5300":
 "<code>Array.swapAt!.{u} {α : Type u} (xs : Array α) (i : Nat) (v : α) : α × Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps a new element with the element at the given index. Panics if the index is out of bounds.\n\nReturns the value formerly found at `i`, paired with an array in which the value at `i` has been\nreplaced with `v`.\n\nExamples:\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt! 1 \"pepper\" = (#[\"spinach\", \"pepper\", \"carrot\"], \"broccoli\")`\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt! 2 \"pepper\" = (#[\"spinach\", \"broccoli\", \"pepper\"], \"carrot\")`\n</code>",
 "530": "<code>Vehicle.wheels (self : Vehicle) : Nat</code>",
 "53": "<code class=\"docstring\">The universe parameter u_1</code>",
 "5299":
 "<code><span class=\"literal string\">\"pepper\"</span> : String</code>",
 "5298":
 "<code>Array.swapAt.{u} {α : Type u} (xs : Array α) (i : Nat) (v : α) (hi : i &lt; xs.size := by get_elem_tactic) : α × Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps a new element with the element at the given index.\n\nReturns the value formerly found at `i`, paired with an array in which the value at `i` has been\nreplaced with `v`.\n\nExamples:\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt 1 \"pepper\" = (\"broccoli\", #[\"spinach\", \"pepper\", \"carrot\"])`\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt 2 \"pepper\" = (\"carrot\", #[\"spinach\", \"broccoli\", \"pepper\"])`\n</code>",
 "5297":
 "<code><span class=\"literal string\">\"spinach\"</span> : String</code>",
 "5296":
 "<code>Array.swapIfInBounds.{u} {α : Type u} (xs : Array α) (i j : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps two elements of an array, returning the array unchanged if either index is out of bounds. The\nmodification is performed in-place when the reference to the array is unique.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 3 = #[\"brown\", \"green\", \"blue\", \"red\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 2 = #[\"blue\", \"green\", \"red\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 1 2 = #[\"red\", \"blue\", \"green\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 4 = #[\"red\", \"green\", \"blue\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 9 2 = #[\"red\", \"green\", \"blue\", \"brown\"]`\n</code>",
 "5295": "<code>autoParam (j &lt; xs.size) _auto✝</code>",
 "5294":
 "<code>Array.eraseReps.{u_1} {α : Type u_1} [BEq α] (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Erases repeated elements, keeping the first element of each run.\n\n`O(|as|)`.\n\nExample:\n* `#[1, 3, 2, 2, 2, 3, 3, 5].eraseReps = #[1, 3, 2, 3, 5]`\n</code>",
 "5293":
 "<code>Array.eraseIdxIfInBounds.{u} {α : Type u} (xs : Array α) (i : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at a given index from an array. Does nothing if the index is out of bounds.\n\nThis function takes worst-case `O(n)` time because it back-shifts all elements at positions greater\nthan `i`.\n\nExamples:\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 0 = #[\"pear\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 1 = #[\"apple\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 2 = #[\"apple\", \"pear\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 3 = #[\"apple\", \"pear\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 5 = #[\"apple\", \"pear\", \"orange\"]`\n</code>",
 "5292":
 "<code>Array.eraseIdx.{u} {α : Type u} (xs : Array α) (i : Nat) (h : i &lt; xs.size := by get_elem_tactic) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at a given index from an array without a run-time bounds check.\n\nThis function takes worst-case `O(n)` time because it back-shifts all elements at positions\ngreater than `i`.\n\nExamples:\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdx 0 = #[\"pear\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdx 1 = #[\"apple\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdx 2 = #[\"apple\", \"pear\"]`\n</code>",
 "5291": "<code>autoParam (i &lt; xs.size) _auto✝</code>",
 "5290":
 "<code>Array.eraseP.{u} {α : Type u} (as : Array α) (p : α → Bool) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first element that satisfies the predicate `p`. If no element satisfies `p`, the array\nis returned unmodified.\n\nThis function takes worst-case `O(n)` time because it back-shifts all later elements.\n\nExamples:\n* `#[\"red\", \"green\", \"\", \"blue\"].eraseP (·.isEmpty) = #[\"red\", \"green\", \"blue\"]`\n* `#[\"red\", \"green\", \"\", \"blue\", \"\"].eraseP (·.isEmpty) = #[\"red\", \"green\", \"blue\", \"\"]`\n* `#[\"red\", \"green\", \"blue\"].eraseP (·.length % 2 == 0) = #[\"red\", \"green\"]`\n* `#[\"red\", \"green\", \"blue\"].eraseP (fun _ =&gt; true) = #[\"green\", \"blue\"]`\n* `(#[] : Array String).eraseP (fun _ =&gt; true) = #[]`\n</code>",
 "529": "<code>Vehicle : Type</code>",
 "5289":
 "<code>Array.erase.{u} {α : Type u} [BEq α] (as : Array α) (a : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first occurrence of a specified element from an array, or does nothing if it is not\npresent.\n\nThis function takes worst-case `O(n)` time because it back-shifts all later elements.\n\nExamples:\n* `#[1, 2, 3].erase 2 = #[1, 3]`\n* `#[1, 2, 3].erase 5 = #[1, 2, 3]`\n* `#[1, 2, 3, 2, 1].erase 2 = #[1, 3, 2, 1]`\n* `(#[] : List Nat).erase 2 = #[]`\n</code>",
 "5288":
 "<code>Array.popWhile.{u} {α : Type u} (p : α → Bool) (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes all the elements that satisfy a predicate from the end of an array.\n\nThe longest contiguous sequence of elements that all satisfy the predicate is removed.\n\nExamples:\n* `#[0, 1, 2, 3, 4].popWhile (· &gt; 2) = #[0, 1, 2]`\n* `#[3, 2, 3, 4].popWhile (· &gt; 2) = #[3, 2]`\n* `(#[] : Array Nat).popWhile (· &gt; 2) = #[]`\n</code>",
 "5287": "<code>Subarray α</code>",
 "5286":
 "<code>Subarray.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A region of some underlying array.\n\nA subarray contains an array together with the start and end indices of a region of interest.\nSubarrays can be used to avoid copying or allocating space, while being more convenient than\ntracking the bounds by hand. The region of interest consists of every index that is both greater\nthan or equal to `start` and strictly less than `stop`.\n</code>",
 "5285":
 "<code>Array.toListAppend.{u} {α : Type u} (as : Array α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Prepends an array to a list. The elements of the array are at the beginning of the resulting list.\n\nEquivalent to `as.toList ++ l`.\n\nExamples:\n* `#[1, 2].toListAppend [3, 4] = [1, 2, 3, 4]`\n* `#[1, 2].toListAppend [] = [1, 2]`\n* `#[].toListAppend [3, 4, 5] = [3, 4, 5]`\n</code>",
 "5284":
 "<code>Array.toListRev.{u_1} {α : Type u_1} (xs : Array α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an array to a list that contains the same elements in the opposite order.\n\nThis is equivalent to, but more efficient than, `Array.toList ∘ List.reverse`.\n\nExamples:\n* `#[1, 2, 3].toListRev = [3, 2, 1]`\n* `#[\"blue\", \"yellow\"].toListRev = [\"yellow\", \"blue\"]`\n</code>",
 "5283": "<code>Fin #[\"carrot\", \"potato\", \"broccoli\"].size</code>",
 "5282":
 "<code>Array.finIdxOf?.{u} {α : Type u} [BEq α] (xs : Array α) (v : α) : Option (Fin xs.size)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the size of the array if no element is equal\nto `a`. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"carrot\" = some 0`\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"broccoli\" = some 2`\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"tomato\" = none`\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"anything else\" = none`\n</code>",
 "5281":
 "<code>Array.idxOf?.{u} {α : Type u} [BEq α] (xs : Array α) (v : α) : Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or `none` if no element is equal to `a`.\n\nExamples:\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"carrot\" = some 0`\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"broccoli\" = some 2`\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"tomato\" = none`\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"anything else\" = none`\n</code>",
 "5280":
 "<code>Array.idxOf.{u} {α : Type u} [BEq α] (a : α) : Array α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the size of the array if no element is equal\nto `a`.\n\nExamples:\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"carrot\" = 0`\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"broccoli\" = 2`\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"tomato\" = 3`\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"anything else\" = 3`\n</code>",
 "528": "<code>Bicycle : Type</code>",
 "5279":
 "<code>Array.countP.{u} {α : Type u} (p : α → Bool) (as : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of elements in the array `as` that satisfy the Boolean predicate `p`.\n\nExamples:\n* `#[1, 2, 3, 4, 5].countP (· % 2 == 0) = 2`\n* `#[1, 2, 3, 4, 5].countP (· &lt; 5) = 4`\n* `#[1, 2, 3, 4, 5].countP (· &gt; 5) = 0`\n</code>",
 "5278":
 "<code>Array.count.{u} {α : Type u} [BEq α] (a : α) (as : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of times an element occurs in an array.\n\nExamples:\n* `#[1, 1, 2, 3, 5].count 1 = 2`\n* `#[1, 1, 2, 3, 5].count 5 = 1`\n* `#[1, 1, 2, 3, 5].count 4 = 0`\n</code>",
 "5277":
 "<code>Array.getMax?.{u} {α : Type u} (as : Array α) (lt : α → α → Bool) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the largest element of the array, as determined by the comparison `lt`, or `none` if\nthe array is empty.\n\nExamples:\n* `(#[] : Array Nat).getMax? (· &lt; ·) = none`\n* `#[\"red\", \"green\", \"blue\"].getMax? (·.length &lt; ·.length) = some \"green\"`\n* `#[\"red\", \"green\", \"blue\"].getMax? (· &lt; ·) = some \"red\"`\n</code>",
 "5276":
 "<code>Array.back?.{u} {α : Type u} (xs : Array α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of an array, or `none` if the array is empty.\n\nSee `Array.back!` for the version that panics if the array is empty, or `Array.back` for the version\nthat requires a proof the array is non-empty.\n</code>",
 "5275":
 "<code>Array.back!.{u} {α : Type u} [Inhabited α] (xs : Array α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of an array, or panics if the array is empty.\n\nSafer alternatives include `Array.back`, which requires a proof the array is non-empty, and\n`Array.back?`, which returns an `Option`.\n</code>",
 "5274": "<code>autoParam (0 &lt; xs.size) _auto✝</code>",
 "5273":
 "<code>USize.toNat (n : USize) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Converts a word-sized unsigned integer to an arbitrary-precision natural number.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "5272": "<code>i.toNat &lt; xs.size</code>",
 "5271":
 "<code>Array.getD.{u_1} {α : Type u_1} (a : Array α) (i : Nat) (v₀ : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the element at the provided index, counting from `0`. Returns the fallback value `v₀` if the\nindex is out of bounds.\n\nTo return an `Option` depending on whether the index is in bounds, use `a[i]?`. To panic if the\nindex is out of bounds, use `a[i]!`.\n\nExamples:\n * `#[\"spring\", \"summer\", \"fall\", \"winter\"].getD 2 \"never\" = \"fall\"`\n * `#[\"spring\", \"summer\", \"fall\", \"winter\"].getD 0 \"never\" = \"spring\"`\n * `#[\"spring\", \"summer\", \"fall\", \"winter\"].getD 4 \"never\" = \"never\"`\n</code>",
 "5270":
 "<code>Array.extract.{u_1} {α : Type u_1} (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the slice of `as` from indices `start` to `stop` (exclusive). The resulting array has size\n`(min stop as.size) - start`.\n\nIf `start` is greater or equal to `stop`, the result is empty. If `stop` is greater than the size of\n`as`, the size is used instead.\n\nExamples:\n * `#[0, 1, 2, 3, 4].extract 1 3 = #[1, 2]`\n * `#[0, 1, 2, 3, 4].extract 1 30 = #[1, 2, 3, 4]`\n * `#[0, 1, 2, 3, 4].extract 0 0 = #[]`\n * `#[0, 1, 2, 3, 4].extract 2 1 = #[]`\n * `#[0, 1, 2, 3, 4].extract 2 2 = #[]`\n * `#[0, 1, 2, 3, 4].extract 2 3 = #[2]`\n * `#[0, 1, 2, 3, 4].extract 2 4 = #[2, 3]`\n</code>",
 "527": "<code>ElectricBike : Type</code>",
 "5269": "<code>optParam Nat as.size</code>",
 "5268":
 "<code>Array.isEmpty.{u} {α : Type u} (xs : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether an array is empty.\n\nAn array is empty if its size is `0`.\n\nExamples:\n* `(#[] : Array String).isEmpty = true`\n* `#[1, 2].isEmpty = false`\n* `#[()].isEmpty = false`\n</code>",
 "5267":
 "<code>Array.usize.{u} {α : Type u} (xs : Array α) : USize</code><span class=\"sep\"></span><code class=\"docstring\">Returns the size of the array as a platform-native unsigned integer.\n\nThis is a low-level version of `Array.size` that directly queries the runtime system's\nrepresentation of arrays. While this is not provable, `Array.usize` always returns the exact size of\nthe array since the implementation only supports arrays of size less than `USize.size`.\n</code>",
 "5266":
 "<code>Array.rightpad.{u} {α : Type u} (n : Nat) (a : α) (xs : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `xs : Array α` on the right with repeated occurrences of `a : α` until it is of length `n`. If\n`l` already has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].rightpad 5 0 = #[1, 2, 3, 0, 0]`\n * `#[\"red\", \"green\", \"blue\"].rightpad 4 \"blank\" = #[\"red\", \"green\", \"blue\", \"blank\"]`\n * `#[\"red\", \"green\", \"blue\"].rightpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n * `#[\"red\", \"green\", \"blue\"].rightpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "5265":
 "<code>Array.leftpad.{u} {α : Type u} (n : Nat) (a : α) (xs : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `xs : Array α` on the left with repeated occurrences of `a : α` until it is of size `n`. If `xs`\nalready has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].leftpad 5 0 = #[0, 0, 1, 2, 3]`\n * `#[\"red\", \"green\", \"blue\"].leftpad 4 \"blank\" = #[\"blank\", \"red\", \"green\", \"blue\"]`\n * `#[\"red\", \"green\", \"blue\"].leftpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n * `#[\"red\", \"green\", \"blue\"].leftpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "5264":
 "<code>Array.appendList.{u} {α : Type u} (as : Array α) (bs : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Appends an array and a list.\n\nTakes time proportional to the length of the list..\n\nExamples:\n* `#[1, 2, 3].appendList [4, 5] = #[1, 2, 3, 4, 5]`.\n* `#[].appendList [4, 5] = #[4, 5]`.\n* `#[1, 2, 3].appendList [] = #[1, 2, 3]`.\n</code>",
 "5263":
 "<code><span class=\"literal string\">\"anything\"</span> : String</code>",
 "5262":
 "<code>Array.replicate.{u} {α : Type u} (n : Nat) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Creates an array that contains `n` repetitions of `v`.\n\nThe corresponding `List` function is `List.replicate`.\n\nExamples:\n* `Array.replicate 2 true = #[true, true]`\n* `Array.replicate 3 () = #[(), (), ()]`\n* `Array.replicate 0 \"anything\" = #[]`\n</code>",
 "5261": "<code>Fin ?m.41</code>",
 "5260":
 "<code>Array.ofFn.{u} {α : Type u} {n : Nat} (f : Fin n → α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Creates an array by applying `f` to each potential index in order, starting at `0`.\n\nExamples:\n* `Array.ofFn (n := 3) toString = #[\"0\", \"1\", \"2\"]`\n* `Array.ofFn (fun i =&gt; #[\"red\", \"green\", \"blue\"].get i.val i.isLt) = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "526": "<code>FamilyBike : Type</code>",
 "5259":
 "<code>Array.finRange (n : Nat) : Array (Fin n)</code><span class=\"sep\"></span><code class=\"docstring\">Returns an array of all elements of `Fin n` in order, starting at `0`.\n\nExamples:\n* `Array.finRange 0 = (#[] : Array (Fin 0))`\n* `Array.finRange 2 = (#[0, 1] : Array (Fin 2))`\n</code>",
 "5258":
 "<code>Array.range' (start size : Nat) (step : Nat := 1) : Array Nat</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an array of numbers of size `size`, starting at `start` and increasing by\n`step` at each element.\n\nIn other words, `Array.range' start size step` is `#[start, start+step, ..., start+(len-1)*step]`.\n\nExamples:\n * `Array.range' 0 3 (step := 1) = #[0, 1, 2]`\n * `Array.range' 0 3 (step := 2) = #[0, 2, 4]`\n * `Array.range' 0 4 (step := 2) = #[0, 2, 4, 6]`\n * `Array.range' 3 4 (step := 2) = #[3, 5, 7, 9]`\n</code>",
 "5257":
 "<code>Array.singleton.{u} {α : Type u} (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a single-element array that contains `v`.\n\nExamples:\n* `Array.singleton 5 = #[5]`\n* `Array.singleton \"one\" = #[\"one\"]`\n</code>",
 "5256":
 "<code>Subarray.array.{u_1} {α : Type u_1} (xs : Subarray α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">The underlying array. </code>",
 "5255":
 "<code>Array.range (n : Nat) : Array Nat</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an array that contains all the numbers from `0` to `n`, exclusive.\n\nExamples:\n* `Array.range 5 := #[0, 1, 2, 3, 4]`\n* `Array.range 0 := #[]`\n* `Array.range 1 := #[0]`\n</code>",
 "5254": "<code>ten : Array Nat</code>",
 "5253": "<code>oneTwoThree : Array Nat</code>",
 "5252":
 "<code>Array.toList.{u} {α : Type u} (self : Array α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an `Array α` into a `List α` that contains the same elements in the same order.\n\nAt runtime, this is implemented by `Array.toListImpl` and is `O(n)` in the length of the\narray.\n</code>",
 "5251":
 "<code>Array.toListImpl.{u} {α : Type u} (as : Array α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Convert a `Array α` into an `List α`. This is O(n) in the size of the array.  </code>",
 "5250":
 "<code>List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an `Array α` into a `List α` that contains the same elements in the same order.\n\nAt runtime, this is implemented by `Array.toListImpl` and is `O(n)` in the length of the\narray.\n</code>",
 "525": "<code>ElectricFamilyBike : Type</code>",
 "5249":
 "<code>List.pmap.{u_1, u_2} {α : Type u_1} {β : Type u_2} {P : α → Prop} (f : (a : α) → P a → β) (l : List α)\n  (H : ∀ (a : α), a ∈ l → P a) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Maps a partially defined function (defined on those terms of `α` that satisfy a predicate `P`) over\na list `l : List α`, given a proof that every element of `l` in fact satisfies `P`.\n\n`O(|l|)`. `List.pmap`, named for “partial map,” is the equivalent of `List.map` for such partial\nfunctions.\n</code>",
 "5248": "<code>∀ (a : α), a ∈ l → P a</code>",
 "5247": "<code>(a : α) → P a → β</code>",
 "5246":
 "<code>List.attachWith.{u_1} {α : Type u_1} (l : List α) (P : α → Prop) (H : ∀ (x : α), x ∈ l → P x) : List { x // P x }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” individual proofs to a list of values that satisfy a predicate `P`, returning a list of\nelements in the corresponding subtype `{ x // P x }`.\n\n`O(1)`.\n</code>",
 "5245": "<code>List { x // p x }</code>",
 "5244": "<code>∀ (x : α), x ∈ l → P x</code>",
 "5243": "<code>List ?m.90</code>",
 "5242": "<code>?m.90</code>",
 "5241": "<code>List ?m.39</code>",
 "5240":
 "<code>List.lex.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) (lt : α → α → Bool := by exact (· &lt; ·)) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Compares lists lexicographically with respect to a comparison on their elements.\n\nThe lexicographic order with respect to `lt` is:\n* `[].lex (b :: bs)` is `true`\n* `as.lex [] = false` is `false`\n* `(a :: as).lex (b :: bs)` is true if `lt a b` or `a == b` and `lex lt as bs` is true.\n</code>",
 "524": "<code>EvenNumber</code>",
 "5239":
 "<code>List.cons_le_cons_iff.{u_1} {α : Type u_1} [LT α] [i₁ : Std.Asymm fun x1 x2 =&gt; x1 &lt; x2]\n  [i₂ : Std.Antisymm fun x1 x2 =&gt; ¬x1 &lt; x2] {a b : α} {l₁ l₂ : List α} : a :: l₁ ≤ b :: l₂ ↔ a &lt; b ∨ a = b ∧ l₁ ≤ l₂</code>",
 "5238":
 "<code>List.isSuffixOf?.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) : Option (List α)</code><span class=\"sep\"></span><code class=\"docstring\">If the first list is a suffix of the second, returns the result of dropping the suffix from the\nsecond.\n\nIn other words, `isSuffixOf? l₁ l₂` returns `some t` when `l₂ == t ++ l₁`.\n\nExamples:\n * `[2, 3].isSuffixOf? [1, 2, 3] = some [1]`\n * `[2, 3].isSuffixOf? [1, 2, 3, 4] = none`\n * `[2, 3].isSuffixOf? [1, 2] = none`\n * `[2, 3].isSuffixOf? [1, 1, 2, 3] = some [1, 1]`\n</code>",
 "5237":
 "<code>List.isSublist.{u} {α : Type u} [BEq α] : List α → List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">True if the first list is a potentially non-contiguous sub-sequence of the second list, comparing\nelements with the `==` operator.\n\nThe relation `List.Sublist` is a logical characterization of this property.\n\nExamples:\n* `[1, 3].isSublist [0, 1, 2, 3, 4] = true`\n* `[1, 3].isSublist [0, 1, 2, 4] = false`\n</code>",
 "5236":
 "<code>List.isPrefixOf?.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) : Option (List α)</code><span class=\"sep\"></span><code class=\"docstring\">If the first list is a prefix of the second, returns the result of dropping the prefix.\n\nIn other words, `isPrefixOf? l₁ l₂` returns `some t` when `l₂ == l₁ ++ t`.\n\nExamples:\n* `[1, 2].isPrefixOf? [1, 2, 3] = some [3]`\n* `[1, 2].isPrefixOf? [1, 2] = some []`\n* `[1, 2].isPrefixOf? [1] = none`\n* `[1, 2].isPrefixOf? [1, 1, 2, 3] = none`\n</code>",
 "5235":
 "<code>List.isEqv.{u} {α : Type u} (as bs : List α) (eqv : α → α → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `as` and `bs` have the same length and they are pairwise related by `eqv`.\n\n`O(min |as| |bs|)`. Short-circuits at the first non-related pair of elements.\n\nExamples:\n* `[1, 2, 3].isEqv [2, 3, 4] (· &lt; ·) = true`\n* `[1, 2, 3].isEqv [2, 2, 4] (· &lt; ·) = false`\n* `[1, 2, 3].isEqv [2, 3] (· &lt; ·) = false`\n</code>",
 "5234":
 "<code>List.or (bs : List Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `true` is an element of the list `bs`.\n\n`O(|bs|)`. Short-circuits at the first `true` value.\n\n* `[true, true, true].or = true`\n* `[true, false, true].or = true`\n* `[false, false, false].or = false`\n* `[false, false, true].or = true`\n* `[].or = false`\n</code>",
 "5233":
 "<code>List.and (bs : List Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if every element of `bs` is the value `true`.\n\n`O(|bs|)`. Short-circuits at the first `false` value.\n\n* `[true, true, true].and = true`\n* `[true, false, true].and = false`\n* `[true, false, false].and = false`\n* `[].and = true`\n</code>",
 "5232":
 "<code>List.any.{u} {α : Type u} (l : List α) (p : α → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for any element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `true`.\n\nExamples:\n* `[2, 4, 6].any (· % 2 = 0) = true`\n* `[2, 4, 6].any (· % 2 = 1) = false`\n* `[2, 4, 5, 6].any (· % 2 = 0) = true`\n* `[2, 4, 5, 6].any (· % 2 = 1) = true`\n</code>",
 "5231": "<code>?m.15 → Bool</code>",
 "5230":
 "<code>List.all.{u} {α : Type u} : List α → (α → Bool) → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for every element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `false`.\n\nExamples:\n* `[a, b, c].all p = (p a && (p b && p c))`\n* `[2, 4, 6].all (· % 2 = 0) = true`\n* `[2, 4, 5, 6].all (· % 2 = 0) = false`\n</code>",
 "523": "<code>printEven (num : EvenNumber) : IO Unit</code>",
 "5229":
 "<code>List.contains.{u} {α : Type u} [BEq α] (as : List α) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `as`, using `==` to compare elements.\n\n`O(|as|)`. `List.elem` is a synonym that takes the element before the list.\n\nThe preferred simp normal form is `l.contains a`, and when `LawfulBEq α` is available,\n`l.contains a = true ↔ a ∈ l` and `l.contains a = false ↔ a ∉ l`.\n\nExamples:\n* `[1, 4, 2, 3, 3, 7].contains 3 = true`\n* `List.contains [1, 4, 2, 3, 3, 7] 5 = false`\n</code>",
 "5228":
 "<code>Std.HashMap.ofList.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (l : List (α × β)) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence. </code>",
 "5227":
 "<code>List.groupByKey.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (key : β → α) (xs : List β) :\n  Std.HashMap α (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Groups the elements of a list `xs` according to the function `key`, returning a hash map in which\neach group is associated with its key. Groups preserve the relative order of elements in `xs`.\n\nExample:\n```lean example\n#eval [0, 1, 2, 3, 4, 5, 6].groupByKey (· % 2)\n```\n```output\nStd.HashMap.ofList [(0, [0, 2, 4, 6]), (1, [1, 3, 5])]\n```\n</code>",
 "5226":
 "<code>List.partitionMap.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β ⊕ γ) (l : List α) :\n  List β × List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns a disjoint union to each element of a list, collecting the `Sum.inl`\nand `Sum.inr` results into separate lists.\n\nExamples:\n * `[0, 1, 2, 3].partitionMap (fun x =&gt; if x % 2 = 0 then .inl x else .inr x) = ([0, 2], [1, 3])`\n * `[0, 1, 2, 3].partitionMap (fun x =&gt; if x = 0 then .inl x else .inr x) = ([0], [1, 2, 3])`\n</code>",
 "5225": "<code>α → β ⊕ γ</code>",
 "5224":
 "<code><span class=\"literal string\">\"Zero is not positive or negative\"</span> : String</code>",
 "5223": "<code>posOrNeg (x : Int) : Except String Bool</code>",
 "5222":
 "<code>List.partition.{u} {α : Type u} (p : α → Bool) (as : List α) : List α × List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a pair of lists that together contain all the elements of `as`. The first list contains\nthose elements for which `p` returns `true`, and the second contains those for which `p` returns\n`false`.\n\n`O(|l|)`. `as.partition p` is equivalent to `(as.filter p, as.filter (not ∘ p))`, but it is slightly\nmore efficient since it only has to do one pass over the list.\n\nExamples:\n * `[1, 2, 5, 2, 7, 7].partition (· &gt; 2) = ([5, 7, 7], [1, 2, 2])`\n * `[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; false) = ([], [1, 2, 5, 2, 7, 7])`\n * `[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; true) = ([1, 2, 5, 2, 7, 7], [])`\n</code>",
 "5221":
 "<code>List.splitBy.{u} {α : Type u} (R : α → α → Bool) : List α → List (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Splits a list into the longest segments in which each pair of adjacent elements are related by `R`.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 1, 2, 2, 2, 3, 2].splitBy (· == ·) = [[1, 1], [2, 2, 2], [3], [2]]`\n* `[1, 2, 5, 4, 5, 1, 4].splitBy (· &lt; ·) = [[1, 2, 5], [4, 5], [1, 4]]`\n* `[1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ =&gt; true) = [[1, 2, 5, 4, 5, 1, 4]]`\n* `[1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ =&gt; false) = [[1], [2], [5], [4], [5], [1], [4]]`\n</code>",
 "5220":
 "<code>List.span.{u} {α : Type u} (p : α → Bool) (as : List α) : List α × List α</code><span class=\"sep\"></span><code class=\"docstring\">Splits a list into the the longest initial segment for which `p` returns `true`, paired with the\nremainder of the list.\n\n`O(|l|)`.\n\nExamples:\n* `[6, 8, 9, 5, 2, 9].span (· &gt; 5) = ([6, 8, 9], [5, 2, 9])`\n* `[6, 8, 9, 5, 2, 9].span (· &gt; 10) = ([], [6, 8, 9, 5, 2, 9])`\n* `[6, 8, 9, 5, 2, 9].span (· &gt; 0) = ([6, 8, 9, 5, 2, 9], [])`\n</code>",
 "522":
 "<code class=\"docstring\">The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n</code>",
 "5219":
 "<code>List.splitAt.{u} {α : Type u} (n : Nat) (l : List α) : List α × List α</code><span class=\"sep\"></span><code class=\"docstring\">Splits a list at an index, resulting in the first `n` elements of `l` paired with the remaining\nelements.\n\nIf `n` is greater than the length of `l`, then the resulting pair consists of `l` and the empty\nlist. `List.splitAt` is equivalent to a combination of `List.take` and `List.drop`, but it is more\nefficient.\n\nExamples:\n* `[\"red\", \"green\", \"blue\"].splitAt 2 = ([\"red\", \"green\"], [\"blue\"])`\n* `[\"red\", \"green\", \"blue\"].splitAt 3 = ([\"red\", \"green\", \"blue], [])`\n* `[\"red\", \"green\", \"blue\"].splitAt 4 = ([\"red\", \"green\", \"blue], [])`\n</code>",
 "5218":
 "<code>List.dropLastTR.{u_1} {α : Type u_1} (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the last element of the list, if one exists.\n\nThis is a tail-recursive version of `List.dropLast`, used at runtime.\n\nExamples:\n* `[].dropLastTR = []`\n* `[\"tea\"].dropLastTR = []`\n* `[\"tea\", \"coffee\", \"juice\"].dropLastTR = [\"tea\", \"coffee\"]`\n</code>",
 "5217":
 "<code>List.dropLast.{u_1} {α : Type u_1} : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the last element of the list, if one exists.\n\nExamples:\n* `[].dropLast = []`\n* `[\"tea\"].dropLast = []`\n* `[\"tea\", \"coffee\", \"juice\"].dropLast = [\"tea\", \"coffee\"]`\n</code>",
 "5216":
 "<code>List.dropWhile.{u} {α : Type u} (p : α → Bool) : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the longest prefix of a list for which `p` returns `true`.\n\nElements are removed from the list until one is encountered for which `p` returns `false`. This\nelement and the remainder of the list are returned.\n\n`O(|l|)`.\n\nExamples:\n * `[1, 3, 2, 4, 2, 7, 4].dropWhile (· &lt; 4) = [4, 2, 7, 4]`\n * `[8, 3, 2, 4, 2, 7, 4].dropWhile (· &lt; 4) = [8, 3, 2, 4, 2, 7, 4]`\n * `[8, 3, 2, 4, 2, 7, 4].dropWhile (· &lt; 100) = []`\n</code>",
 "5215":
 "<code>List.takeWhileTR.{u_1} {α : Type u_1} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the longest initial segment of `xs` for which `p` returns true.\n\n`O(|xs|)`. This is a tail-recursive version of `List.take`, used at runtime.\n\nExamples:\n* `[7, 6, 4, 8].takeWhileTR (· &gt; 5) = [7, 6]`\n* `[7, 6, 6, 5].takeWhileTR (· &gt; 5) = [7, 6, 6]`\n* `[7, 6, 6, 8].takeWhileTR (· &gt; 5) = [7, 6, 6, 8]`\n</code>",
 "5214":
 "<code>List.takeWhile.{u} {α : Type u} (p : α → Bool) (xs : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the longest initial segment of `xs` for which `p` returns true.\n\n`O(|xs|)`.\n\nExamples:\n* `[7, 6, 4, 8].takeWhile (· &gt; 5) = [7, 6]`\n* `[7, 6, 6, 5].takeWhile (· &gt; 5) = [7, 6, 6]`\n* `[7, 6, 6, 8].takeWhile (· &gt; 5) = [7, 6, 6, 8]`\n</code>",
 "5213":
 "<code>List.takeTR.{u_1} {α : Type u_1} (n : Nat) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the first `n` elements of `xs`, or the whole list if `n` is greater than `xs.length`.\n\n`O(min n |xs|)`. This is a tail-recursive version of `List.take`, used at runtime.\n\nExamples:\n* `[a, b, c, d, e].takeTR 0 = []`\n* `[a, b, c, d, e].takeTR 3 = [a, b, c]`\n* `[a, b, c, d, e].takeTR 6 = [a, b, c, d, e]`\n</code>",
 "5212": "<code>?m.75</code>",
 "5211":
 "<code>List.filterMapM.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} {β : Type u} (f : α → m (Option β))\n  (as : List α) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function that returns an `Option` to each element of a list, collecting the\nnon-`none` values.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterMapM fun x =&gt; do\n  IO.println s!\"Examining {x}\"\n  if x &gt; 2 then return some (2 * x)\n  else return none\n```\n```output\nExamining 1\nExamining 2\nExamining 5\nExamining 2\nExamining 7\nExamining 7\n```\n```output\n[10, 14, 14]\n```\n</code>",
 "5210":
 "<code>List.filterMapTR.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → Option β) (l : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an `Option` to each element of a list, collecting the non-`none`\nvalues.\n\n`O(|l|)`. This is a tail-recursive version of `List.filterMap`, used at runtime.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterMapTR fun x =&gt;\n  if x &gt; 2 then some (2 * x) else none\n```\n```output\n[10, 14, 14]\n```\n</code>",
 "521":
 "<code class=\"docstring\">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.\nIf the tactic fails on any goal, the entire `all_goals` tactic fails.\n\nSee also `any_goals tac`.\n</code>",
 "5209":
 "<code>List.filterMap.{u, v} {α : Type u} {β : Type v} (f : α → Option β) : List α → List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an `Option` to each element of a list, collecting the non-`none`\nvalues.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterMap fun x =&gt;\n  if x &gt; 2 then some (2 * x) else none\n```\n```output\n[10, 14, 14]\n```\n</code>",
 "5208":
 "<code>List.filterTR.{u} {α : Type u} (p : α → Bool) (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the list of elements in `l` for which `p` returns `true`.\n\n`O(|l|)`. This is a tail-recursive version of `List.filter`, used at runtime.\n\nExamples:\n* `[1, 2, 5, 2, 7, 7].filterTR (· &gt; 2)  = [5, 7, 7]`\n* `[1, 2, 5, 2, 7, 7].filterTR (fun _ =&gt; false) = []`\n* `[1, 2, 5, 2, 7, 7].filterTR (fun _ =&gt; true) = * [1, 2, 5, 2, 7, 7]`\n</code>",
 "5207":
 "<code>List.unzipTR.{u, v} {α : Type u} {β : Type v} (l : List (α × β)) : List α × List β</code><span class=\"sep\"></span><code class=\"docstring\">Separates a list of pairs into two lists that contain the respective first and second components.\n\n`O(|l|)`. This is a tail-recursive version of `List.unzip` that's used at runtime.\n\nExamples:\n* `[(\"Monday\", 1), (\"Tuesday\", 2)].unzipTR = ([\"Monday\", \"Tuesday\"], [1, 2])`\n* `[(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzipTR = ([x₁, x₂, x₃], [y₁, y₂, y₃])`\n* `([] : List (Nat × String)).unzipTR = (([], []) : List Nat × List String)`\n</code>",
 "5206": "<code>?m.71</code>",
 "5205": "<code>?m.64</code>",
 "5204":
 "<code>List.unzip.{u, v} {α : Type u} {β : Type v} (l : List (α × β)) : List α × List β</code><span class=\"sep\"></span><code class=\"docstring\">Separates a list of pairs into two lists that contain the respective first and second components.\n\n`O(|l|)`.\n\nExamples:\n* `[(\"Monday\", 1), (\"Tuesday\", 2)].unzip = ([\"Monday\", \"Tuesday\"], [1, 2])`\n* `[(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzip = ([x₁, x₂, x₃], [y₁, y₂, y₃])`\n* `([] : List (Nat × String)).unzip = (([], []) : List Nat × List String)`\n</code>",
 "5203":
 "<code><span class=\"literal string\">\"Tuesday\"</span> : String</code>",
 "5202":
 "<code><span class=\"literal string\">\"Monday\"</span> : String</code>",
 "5201": "<code>List (α × β)</code>",
 "5200":
 "<code>List.zipWithAll.{u, v, w} {α : Type u} {β : Type v} {γ : Type w} (f : Option α → Option β → γ) :\n  List α → List β → List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of both lists, stopping when there are no more\nelements in either list. If one list is shorter than the other, the function is passed `none` for\nthe missing elements.\n\nExamples:\n* `[1, 6].zipWithAll min [5, 2] = [some 1, some 2]`\n* `[1, 2, 3].zipWithAll Prod.mk [5, 6] = [(some 1, some 5), (some 2, some 6), (some 3, none)]`\n* `[x₁, x₂].zipWithAll f [y] = [f (some x₁) (some y), f (some x₂) none]`\n</code>",
 "520": "<code>0 ∣ 2</code>",
 "52":
 "<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>",
 "5199": "<code>Option α → Option β → γ</code>",
 "5198":
 "<code>List.zipWithTR.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (as : List α)\n  (bs : List β) : List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.\n\n`O(min |xs| |ys|)`. This is a tail-recursive version of `List.zipWith` that's used at runtime.\n\nExamples:\n* `[1, 2].zipWithTR (· + ·) [5, 6] = [6, 8]`\n* `[1, 2, 3].zipWithTR (· + ·) [5, 6, 10] = [6, 8, 13]`\n* `[].zipWithTR (· + ·) [5, 6] = []`\n* `[x₁, x₂, x₃].zipWithTR f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n</code>",
 "5197":
 "<code>List.zipIdxTR.{u_1} {α : Type u_1} (l : List α) (n : Nat := 0) : List (α × Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Pairs each element of a list with its index, optionally starting from an index other than `0`.\n\n`O(|l|)`. This is a tail-recursive version of `List.zipIdx` that's used at runtime.\n\nExamples:\n* `[a, b, c].zipIdxTR = [(a, 0), (b, 1), (c, 2)]`\n* `[a, b, c].zipIdxTR 5 = [(a, 5), (b, 6), (c, 7)]`\n</code>",
 "5196": "<code>?m.59</code>",
 "5195":
 "<code>List.zipIdx.{u} {α : Type u} (l : List α) (n : Nat := 0) : List (α × Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Pairs each element of a list with its index, optionally starting from an index other than `0`.\n\n`O(|l|)`.\n\nExamples:\n* `[a, b, c].zipIdx = [(a, 0), (b, 1), (c, 2)]`\n* `[a, b, c].zipIdx 5 = [(a, 5), (b, 6), (c, 7)]`\n</code>",
 "5194": "<code>?m.104</code>",
 "5193": "<code>?m.103</code>",
 "5192":
 "<code>List.zip.{u, v} {α : Type u} {β : Type v} : List α → List β → List (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">Combines two lists into a list of pairs in which the first and second components are the\ncorresponding elements of each list. The resulting list is the length of the shorter of the input\nlists.\n\n`O(min |xs| |ys|)`.\n\nExamples:\n* `[\"Mon\", \"Tue\", \"Wed\"].zip [1, 2, 3] = [(\"Mon\", 1), (\"Tue\", 2), (\"Wed\", 3)]`\n* `[\"Mon\", \"Tue\", \"Wed\"].zip [1, 2] = [(\"Mon\", 1), (\"Tue\", 2)]`\n* `[x₁, x₂, x₃].zip [y₁, y₂, y₃, y₄] = [(x₁, y₁), (x₂, y₂), (x₃, y₃)]`\n</code>",
 "5191": "<code><span class=\"literal string\">\"Wed\"</span> : String</code>",
 "5190": "<code><span class=\"literal string\">\"Tue\"</span> : String</code>",
 "519":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n</code>",
 "5189": "<code><span class=\"literal string\">\"Mon\"</span> : String</code>",
 "5188": "<code>α → m (List β)</code>",
 "5187":
 "<code>List.flatMapTR.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → List β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns a list to each element of a list, and concatenates the resulting\nlists.\n\nThis is the tail-recursive version of `List.flatMap` that's used at runtime.\n\nExamples:\n* `[2, 3, 2].flatMapTR List.range = [0, 1, 0, 1, 2, 0, 1]`\n* `[\"red\", \"blue\"].flatMapTR String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']`\n</code>",
 "5186":
 "<code>List.flatMap.{u, v} {α : Type u} {β : Type v} (b : α → List β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns a list to each element of a list, and concatenates the resulting\nlists.\n\nExamples:\n* `[2, 3, 2].flatMap List.range = [0, 1, 0, 1, 2, 0, 1]`\n* `[\"red\", \"blue\"].flatMap String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']`\n</code>",
 "5185": "<code>α → List β</code>",
 "5184": "<code>α → m α</code>",
 "5183":
 "<code>List.mapMono.{u_1} {α : Type u_1} (as : List α) (f : α → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of a list, returning the list of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new list if the result of each function call is\npointer-equal to its argument.\n\nFor verification purposes, `List.mapMono = List.map`.\n</code>",
 "5182":
 "<code>List.mapFinIdxM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (as : List α)\n  (f : (i : Nat) → α → i &lt; as.length → m β) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results. In addition to the index, the function is also provided with a\nproof that the index is valid.\n\n`List.mapIdxM` is a variant that does not provide the function with evidence that the index is\nvalid.\n</code>",
 "5181": "<code>Nat → α → m β</code>",
 "5180":
 "<code>List.mapFinIdx.{u_1, u_2} {α : Type u_1} {β : Type u_2} (as : List α) (f : (i : Nat) → α → i &lt; as.length → β) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list along with the index at which that element is found,\nreturning the list of results. In addition to the index, the function is also provided with a proof\nthat the index is valid.\n\n`List.mapIdx` is a variant that does not provide the function with evidence that the index is valid.\n</code>",
 "518":
 "<code class=\"docstring\">`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n</code>",
 "5179": "<code>Nat → α → β</code>",
 "5178":
 "<code>List.mapIdxM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (f : Nat → α → m β)\n  (as : List α) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results.\n\n`List.mapFinIdxM` is a variant that additionally provides the function with a proof that the index\nis valid.\n</code>",
 "5177": "<code>(i : Nat) → α → i &lt; as.length → m β</code>",
 "5176":
 "<code>List.mapIdx.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : Nat → α → β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list along with the index at which that element is found,\nreturning the list of results.\n\n`List.mapFinIdx` is a variant that additionally provides the function with a proof that the index\nis valid.\n</code>",
 "5175": "<code>(i : Nat) → α → i &lt; as.length → β</code>",
 "5174":
 "<code>List.mapM'.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (f : α → m β) :\n  List α → m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` on every element in the list, left-to-right, and returns the list of\nresults.\n\nThis is a non-tail-recursive variant of `List.mapM` that's easier to reason about. It cannot be used\nas the main definition and replaced by the tail-recursive version because they can only be proved\nequal when `m` is a `LawfulMonad`.\n</code>",
 "5173":
 "<code>List.mapTR.{u, v} {α : Type u} {β : Type v} (f : α → β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list, returning the resulting list of values.\n\n`O(|l|)`. This is the tail-recursive variant of `List.map`, used in runtime code.\n\nExamples:\n* `[a, b, c].mapTR f = [f a, f b, f c]`\n* `[].mapTR Nat.succ = []`\n* `[\"one\", \"two\", \"three\"].mapTR (·.length) = [3, 3, 5]`\n* `[\"one\", \"two\", \"three\"].mapTR (·.reverse) = [\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "5172":
 "<code><span class=\"literal string\">\"eerht\"</span> : String</code>",
 "5171": "<code><span class=\"literal string\">\"owt\"</span> : String</code>",
 "5170": "<code><span class=\"literal string\">\"eno\"</span> : String</code>",
 "517": "<code>n✝ ∣ 2</code>",
 "5169":
 "<code>List.foldrRecOn.{u_1, u_2, u_3} {β : Type u_1} {α : Type u_2} {motive : β → Sort u_3} (l : List α) (op : α → β → β)\n  {b : β} : motive b → ((b : β) → motive b → (a : α) → a ∈ l → motive (op a b)) → motive (List.foldr op b l)</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for proving propositions about the result of `List.foldr` by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.\n\nBecause the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.\n\nExample:\n```lean example\nexample {xs : List Nat} : xs.foldr (· + ·) 1 &gt; 0 := by\n  apply List.foldrRecOn\n  . show 0 &lt; 1; trivial\n  . show ∀ (b : Nat), 0 &lt; b → ∀ (a : Nat), a ∈ xs → 0 &lt; a + b\n    intros; omega\n```\n</code>",
 "5168": "<code>α → s → m s</code>",
 "5167":
 "<code><span class=\"literal string\">\"(1 (2 (3 !)))\"</span> : String</code>",
 "5166":
 "<code>List.foldrTR.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β → β) (init : β) (l : List α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a list from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in reverse order, using `f`.\n\n`O(|l|)`. This is the tail-recursive replacement for `List.foldr` in runtime code.\n\nExamples:\n * `[a, b, c].foldrTR f init  = f a (f b (f c init))`\n * `[1, 2, 3].foldrTR (toString · ++ ·) \"\" = \"123\"`\n * `[1, 2, 3].foldrTR (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"`\n</code>",
 "5165": "<code>α → β → β</code>",
 "5164": "<code>a✝¹ ∈ xs</code>",
 "5163": "<code>0 &lt; b✝</code>",
 "5162":
 "<code>List.foldlRecOn.{u_1, u_2, u_3} {β : Type u_1} {α : Type u_2} {motive : β → Sort u_3} (l : List α) (op : β → α → β)\n  {b : β} : motive b → ((b : β) → motive b → (a : α) → a ∈ l → motive (op b a)) → motive (List.foldl op b l)</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for proving propositions about the result of `List.foldl` by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.\n\nBecause the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.\n\nExample:\n```lean example\nexample {xs : List Nat} : xs.foldl (· + ·) 1 &gt; 0 := by\n  apply List.foldlRecOn\n  . show 0 &lt; 1; trivial\n  . show ∀ (b : Nat), 0 &lt; b → ∀ (a : Nat), a ∈ xs → 0 &lt; b + a\n    intros; omega\n```\n</code>",
 "5161": "<code>β → α → β</code>",
 "5160": "<code>β → Sort u_3</code>",
 "516": "<code>n✝ ≤ 2</code>",
 "5159": "<code>Monad m</code>",
 "5158": "<code>α → β → m α</code>",
 "5157": "<code>s</code>",
 "5156": "<code>s → α → m s</code>",
 "5155":
 "<code><span class=\"literal string\">\"((( 1) 2) 3)\"</span> : String</code>",
 "5154": "<code><span class=\"literal string\">\"123\"</span> : String</code>",
 "5153": "<code>α → β → α</code>",
 "5152":
 "<code>List.firstM.{u, v, w} {m : Type u → Type v} [Alternative m] {α : Type w} {β : Type u} (f : α → m β) : List α → m β</code><span class=\"sep\"></span><code class=\"docstring\">Maps `f` over the list and collects the results with `&lt;|&gt;`. The result for the end of the list is\n`failure`.\n\nExamples:\n * `[[], [1, 2], [], [2]].firstM List.head? = some 1`\n * `[[], [], []].firstM List.head? = none`\n * `[].firstM List.head? = none`\n</code>",
 "5151":
 "<code>List.forA.{u, v, w} {m : Type u → Type v} [Applicative m] {α : Type w} (as : List α) (f : α → m PUnit) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the applicative action `f` to every element in the list, in order.\n\nIf `m` is also a `Monad`, then using `List.forM` can be more efficient.\n\n`List.mapA` is a variant that collects results.\n</code>",
 "5150":
 "<code>List.mapA.{u, v, w} {m : Type u → Type v} [Applicative m] {α : Type w} {β : Type u} (f : α → m β) : List α → m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the applicative action `f` on every element in the list, left-to-right, and returns the list\nof results.\n\nIf `m` is also a `Monad`, then using `mapM` can be more efficient.\n\nSee `List.forA` for the variant that discards the results. See `List.mapM` for the variant that\nworks with `Monad`.\n\nThis function is not tail-recursive, so it may fail with a stack overflow on long lists.\n</code>",
 "515":
 "<code class=\"docstring\">`intros` repeatedly applies `intro` to introduce zero or more hypotheses\nuntil the goal is no longer a *binding expression*\n(i.e., a universal quantifier, function type, implication, or `have`/`let`),\nwithout performing any definitional reductions (no unfolding, beta, eta, etc.).\nThe introduced hypotheses receive inaccessible (hygienic) names.\n\n`intros x y z` is equivalent to `intro x y z` and exists only for historical reasons.\nThe `intro` tactic should be preferred in this case.\n\n## Properties and relations\n\n- `intros` succeeds even when it introduces no hypotheses.\n\n- `repeat intro` is like `intros`, but it performs definitional reductions\n  to expose binders, and as such it may introduce more hypotheses than `intros`.\n\n- `intros` is equivalent to `intro _ _ … _`,\n  with the fewest trailing `_` placeholders needed so that the goal is no longer a binding expression.\n  The trailing introductions do not perform any definitional reductions.\n\n## Examples\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet-bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n\nDoes not unfold definitions:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/\n  sorry\n```\n</code>",
 "5149": "<code>α → m PUnit</code>",
 "5148":
 "<code>List.merge.{u_1} {α : Type u_1} (xs ys : List α) (le : α → α → Bool := by exact fun a b =&gt; a ≤ b) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Merges two lists, using `le` to select the first element of the resulting list if both are\nnon-empty.\n\nIf both input lists are sorted according to `le`, then the resulting list is also sorted according\nto `le`. `O(|xs| + |ys|)`.\n\nThis implementation is not tail-recursive, but it is replaced at runtime by a proven-equivalent\ntail-recursive merge.\n</code>",
 "5147": "<code>autoParam (α → α → Bool) _auto✝</code>",
 "5146":
 "<code>List.intercalateTR.{u_1} {α : Type u_1} (sep : List α) (xs : List (List α)) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the lists in `xs` with the separator `sep`.\n\nThis is a tail-recursive version of `List.intercalate` used at runtime.\n\nExamples:\n* `List.intercalateTR sep [] = []`\n* `List.intercalateTR sep [a] = a`\n* `List.intercalateTR sep [a, b] = a ++ sep ++ b`\n* `List.intercalateTR sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`\n</code>",
 "5145":
 "<code>List.intersperseTR.{u} {α : Type u} (sep : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the elements of `l` with `sep`.\n\n`O(|l|)`.\n\nThis is a tail-recursive version of `List.intersperse`, used at runtime.\n\nExamples:\n* `List.intersperseTR \"then\" [] = []`\n* `List.intersperseTR \"then\" [\"walk\"] = [\"walk\"]`\n* `List.intersperseTR \"then\" [\"walk\", \"run\"] = [\"walk\", \"then\", \"run\"]`\n* `List.intersperseTR \"then\" [\"walk\", \"run\", \"rest\"] = [\"walk\", \"then\", \"run\", \"then\", \"rest\"]`\n</code>",
 "5144": "<code><span class=\"literal string\">\"rest\"</span> : String</code>",
 "5143": "<code><span class=\"literal string\">\"run\"</span> : String</code>",
 "5142": "<code><span class=\"literal string\">\"walk\"</span> : String</code>",
 "5141": "<code><span class=\"literal string\">\"then\"</span> : String</code>",
 "5140":
 "<code>List.intersperse.{u} {α : Type u} (sep : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the elements of `l` with `sep`.\n\n`O(|l|)`.\n\n`List.intercalate` is a similar function that alternates a separator list with elements of a list of\nlists.\n\nExamples:\n* `List.intersperse \"then\" [] = []`\n* `List.intersperse \"then\" [\"walk\"] = [\"walk\"]`\n* `List.intersperse \"then\" [\"walk\", \"run\"] = [\"walk\", \"then\", \"run\"]`\n* `List.intersperse \"then\" [\"walk\", \"run\", \"rest\"] = [\"walk\", \"then\", \"run\", \"then\", \"rest\"]`\n</code>",
 "514":
 "<code>Or (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.\n\n * The recommended spelling of `\\/` in identifiers is `or` (prefer `∨` over `\\/`).</code>",
 "5139":
 "<code>List.intercalate.{u} {α : Type u} (sep : List α) (xs : List (List α)) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the lists in `xs` with the separator `sep`, appending them. The resulting list is\nflattened.\n\n`O(|xs|)`.\n\n`List.intersperse` is a similar function that alternates a separator element with the elements of a\nlist.\n\nExamples:\n* `List.intercalate sep [] = []`\n* `List.intercalate sep [a] = a`\n* `List.intercalate sep [a, b] = a ++ sep ++ b`\n* `List.intercalate sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`\n</code>",
 "5138":
 "<code>List.insertIdxTR.{u_1} {α : Type u_1} (l : List α) (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a list at the specified index. If the index is greater than the length of\nthe list, then the list is returned unmodified.\n\nIn other words, the new element is inserted into the list `l` after the first `i` elements of `l`.\n\nThis is a tail-recursive version of `List.insertIdx`, used at runtime.\n\nExamples:\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 1 \"wed\" = [\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 2 \"wed\" = [\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 3 \"wed\" = [\"tues\", \"thur\", \"sat\", \"wed\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 4 \"wed\" = [\"tues\", \"thur\", \"sat\"]`\n\n</code>",
 "5137": "<code><span class=\"literal string\">\"wed\"</span> : String</code>",
 "5136":
 "<code>List.insertIdx.{u} {α : Type u} (xs : List α) (i : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a list at the specified index. If the index is greater than the length of\nthe list, then the list is returned unmodified.\n\nIn other words, the new element is inserted into the list `l` after the first `i` elements of `l`.\n\nExamples:\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 1 \"wed\" = [\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 2 \"wed\" = [\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 3 \"wed\" = [\"tues\", \"thur\", \"sat\", \"wed\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 4 \"wed\" = [\"tues\", \"thur\", \"sat\"]`\n</code>",
 "5135": "<code><span class=\"literal string\">\"sat\"</span> : String</code>",
 "5134": "<code><span class=\"literal string\">\"thur\"</span> : String</code>",
 "5133": "<code><span class=\"literal string\">\"tues\"</span> : String</code>",
 "5132":
 "<code>List.insert.{u} {α : Type u} [BEq α] (a : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a list without duplication.\n\nIf the element is present in the list, the list is returned unmodified. Otherwise, the new element\nis inserted at the head of the list.\n\nExamples:\n * `[1, 2, 3].insert 0 = [0, 1, 2, 3]`\n * `[1, 2, 3].insert 4 = [4, 1, 2, 3]`\n * `[1, 2, 3].insert 2 = [1, 2, 3]`\n</code>",
 "5131":
 "<code>List.rightpad.{u} {α : Type u} (n : Nat) (a : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `l : List α` on the right with repeated occurrences of `a : α` until it is of length `n`. If\n`l` already has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `[1, 2, 3].rightpad 5 0 = [1, 2, 3, 0, 0]`\n * `[\"red\", \"green\", \"blue\"].rightpad 4 \"blank\" = [\"red\", \"green\", \"blue\", \"blank\"]`\n * `[\"red\", \"green\", \"blue\"].rightpad 3 \"blank\" = [\"red\", \"green\", \"blue\"]`\n * `[\"red\", \"green\", \"blue\"].rightpad 1 \"blank\" = [\"red\", \"green\", \"blue\"]`\n</code>",
 "5130":
 "<code><span class=\"literal string\">\"blank\"</span> : String</code>",
 "513":
 "<code>Dvd.dvd.{u_1} {α : Type u_1} [self : Dvd α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.</code>",
 "5129":
 "<code>List.leftpad.{u} {α : Type u} (n : Nat) (a : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `l : List α` on the left with repeated occurrences of `a : α` until it is of length `n`. If `l`\nalready has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `[1, 2, 3].leftpad 5 0 = [0, 0, 1, 2, 3]`\n * `[\"red\", \"green\", \"blue\"].leftpad 4 \"blank\" = [\"blank\", \"red\", \"green\", \"blue\"]`\n * `[\"red\", \"green\", \"blue\"].leftpad 3 \"blank\" = [\"red\", \"green\", \"blue\"]`\n * `[\"red\", \"green\", \"blue\"].leftpad 1 \"blank\" = [\"red\", \"green\", \"blue\"]`\n</code>",
 "5128":
 "<code>List.rotateRight.{u} {α : Type u} (xs : List α) (i : Nat := 1) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Rotates the elements of `xs` to the right, moving `i % xs.length` elements from the end of the list\nto the start.\n\nAfter rotation, the element at `xs[n]` is at index `(i + n) % l.length`. `O(|xs|)`.\n\nExamples:\n* `[1, 2, 3, 4, 5].rotateRight 3 = [3, 4, 5, 1, 2]`\n* `[1, 2, 3, 4, 5].rotateRight 5 = [1, 2, 3, 4, 5]`\n* `[1, 2, 3, 4, 5].rotateRight 1 = [5, 1, 2, 3, 4]`\n</code>",
 "5127":
 "<code>List.rotateLeft.{u} {α : Type u} (xs : List α) (i : Nat := 1) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Rotates the elements of `xs` to the left, moving `i % xs.length` elements from the start of the list\nto the end.\n\n`O(|xs|)`.\n\nExamples:\n* `[1, 2, 3, 4, 5].rotateLeft 3 = [4, 5, 1, 2, 3]`\n* `[1, 2, 3, 4, 5].rotateLeft 5 = [1, 2, 3, 4, 5]`\n* `[1, 2, 3, 4, 5].rotateLeft 1 = [2, 3, 4, 5, 1]`\n</code>",
 "5126":
 "<code>List.flattenTR.{u_1} {α : Type u_1} (l : List (List α)) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Concatenates a list of lists into a single list, preserving the order of the elements.\n\n`O(|flatten L|)`. This is a tail-recursive version of `List.flatten`, used in runtime code.\n\nExamples:\n* `[[\"a\"], [\"b\", \"c\"]].flattenTR = [\"a\", \"b\", \"c\"]`\n* `[[\"a\"], [], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]].flattenTR = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]`\n</code>",
 "5125": "<code>List (List α)</code>",
 "5124": "<code><span class=\"literal string\">\"f\"</span> : String</code>",
 "5123": "<code><span class=\"literal string\">\"d\"</span> : String</code>",
 "5122":
 "<code>List.replaceTR.{u_1} {α : Type u_1} [BEq α] (l : List α) (b c : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first element of the list `l` that is equal to `a` with `b`. If no element is equal to\n`a`, then the list is returned unchanged.\n\n`O(|l|)`. This is a tail-recursive version of `List.replace` that's used in runtime code.\n\nExamples:\n* `[1, 4, 2, 3, 3, 7].replaceTR 3 6 = [1, 4, 2, 6, 3, 7]`\n* `[1, 4, 2, 3, 3, 7].replaceTR 5 6 = [1, 4, 2, 3, 3, 7]`\n</code>",
 "5121":
 "<code>List.replace.{u} {α : Type u} [BEq α] (l : List α) (a b : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first element of the list `l` that is equal to `a` with `b`. If no element is equal to\n`a`, then the list is returned unchanged.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 4, 2, 3, 3, 7].replace 3 6 = [1, 4, 2, 6, 3, 7]`\n* `[1, 4, 2, 3, 3, 7].replace 5 6 = [1, 4, 2, 3, 3, 7]`\n</code>",
 "5120":
 "<code>List.removeAll.{u} {α : Type u} [BEq α] (xs ys : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes all elements of `xs` that are present in `ys`.\n\n`O(|xs| * |ys|)`.\n\nExamples:\n* `[1, 1, 5, 1, 2, 4, 5].removeAll [1, 2, 2] = [5, 4, 5]`\n* `[1, 2, 3, 2].removeAll [] = [1, 2, 3, 2]`\n* `[1, 2, 3, 2].removeAll [3] = [1, 2, 2]`\n</code>",
 "512":
 "<code>LE.le.{u} {α : Type u} [self : LE α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "5119": "<code>optParam Nat l.length</code>",
 "5118":
 "<code>List.eraseReps.{u_1} {α : Type u_1} [BEq α] (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Erases repeated elements, keeping the first element of each run.\n\n`O(|l|)`.\n\nExample:\n* `[1, 3, 2, 2, 2, 3, 3, 5].eraseReps = [1, 3, 2, 3, 5]`\n</code>",
 "5117":
 "<code>List.erasePTR.{u_1} {α : Type u_1} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first element of a list for which `p` returns `true`. If no element satisfies `p`, then\nthe list is returned unchanged.\n\nThis is a tail-recursive version of `eraseP`, used at runtime.\n\nExamples:\n  * `[2, 1, 2, 1, 3, 4].erasePTR (· &lt; 2) = [2, 2, 1, 3, 4]`\n  * `[2, 1, 2, 1, 3, 4].erasePTR (· &gt; 2) = [2, 1, 2, 1, 4]`\n  * `[2, 1, 2, 1, 3, 4].erasePTR (· &gt; 8) = [2, 1, 2, 1, 3, 4]`\n</code>",
 "5116":
 "<code>List.eraseP.{u} {α : Type u} (p : α → Bool) : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first element of a list for which `p` returns `true`. If no element satisfies `p`, then\nthe list is returned unchanged.\n\nExamples:\n  * `[2, 1, 2, 1, 3, 4].eraseP (· &lt; 2) = [2, 2, 1, 3, 4]`\n  * `[2, 1, 2, 1, 3, 4].eraseP (· &gt; 2) = [2, 1, 2, 1, 4]`\n  * `[2, 1, 2, 1, 3, 4].eraseP (· &gt; 8) = [2, 1, 2, 1, 3, 4]`\n</code>",
 "5115":
 "<code>List.eraseIdxTR.{u_1} {α : Type u_1} (l : List α) (n : Nat) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at the specified index. If the index is out of bounds, the list is returned\nunmodified.\n\n`O(i)`.\n\nThis is a tail-recursive version of `List.eraseIdx`, used at runtime.\n\nExamples:\n* `[0, 1, 2, 3, 4].eraseIdxTR 0 = [1, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdxTR 1 = [0, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdxTR 5 = [0, 1, 2, 3, 4]`\n</code>",
 "5114":
 "<code>List.eraseIdx.{u} {α : Type u} (l : List α) (i : Nat) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at the specified index. If the index is out of bounds, the list is returned\nunmodified.\n\n`O(i)`.\n\nExamples:\n* `[0, 1, 2, 3, 4].eraseIdx 0 = [1, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdx 1 = [0, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdx 5 = [0, 1, 2, 3, 4]`\n</code>",
 "5113":
 "<code>List.eraseDups.{u_1} {α : Type u_1} [BEq α] (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Erases duplicated elements in the list, keeping the first occurrence of duplicated elements.\n\n`O(|l|^2)`.\n\nExamples:\n* `[1, 3, 2, 2, 3, 5].eraseDups = [1, 3, 2, 5]`\n* `[\"red\", \"green\", \"green\", \"blue\"].eraseDups = [\"red\", \"green\", \"blue\"]`\n</code>",
 "5112":
 "<code>List.eraseTR.{u_1} {α : Type u_1} [BEq α] (l : List α) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first occurrence of `a` from `l`. If `a` does not occur in `l`, the list is returned\nunmodified.\n\n`O(|l|)`.\n\nThis is a tail-recursive version of `List.erase`, used in runtime code.\n\nExamples:\n* `[1, 5, 3, 2, 5].eraseTR 5 = [1, 3, 2, 5]`\n* `[1, 5, 3, 2, 5].eraseTR 6 = [1, 5, 3, 2, 5]`\n</code>",
 "5111":
 "<code>List.erase.{u_1} {α : Type u_1} [BEq α] : List α → α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first occurrence of `a` from `l`. If `a` does not occur in `l`, the list is returned\nunmodified.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 5, 3, 2, 5].erase 5 = [1, 3, 2, 5]`\n* `[1, 5, 3, 2, 5].erase 6 = [1, 5, 3, 2, 5]`\n</code>",
 "5110":
 "<code>List.modifyTailIdx.{u} {α : Type u} (l : List α) (i : Nat) (f : List α → List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the `n`th tail of `l` with the result of applying `f` to it. Returns the input without\nusing `f` if the index is larger than the length of the List.\n\nExamples:\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 1 List.reverse\n```\n```output\n[\"circle\", \"triangle\", \"square\"]\n```\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 1 (fun xs =&gt; xs ++ xs)\n```\n```output\n[\"circle\", \"square\", \"triangle\", \"square\", \"triangle\"]\n```\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 2 (fun xs =&gt; xs ++ xs)\n```\n```output\n[\"circle\", \"square\", \"triangle\", \"triangle\"]\n```\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 5 (fun xs =&gt; xs ++ xs)\n```\n```output\n[\"circle\", \"square\", \"triangle\"]\n```\n</code>",
 "511": "<code>∀ (n : Nat), n ≤ 2 → n ∣ 2 → n = 1 ∨ n = 2</code>",
 "5109":
 "<code><span class=\"literal string\">\"triangle\"</span> : String</code>",
 "5108":
 "<code><span class=\"literal string\">\"square\"</span> : String</code>",
 "5107": "<code>List α → List α</code>",
 "5106":
 "<code>List.modifyHead.{u} {α : Type u} (f : α → α) : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Replace the head of the list with the result of applying `f` to it. Returns the empty list if the\nlist is empty.\n\nExamples:\n * `[1, 2, 3].modifyHead (· * 10) = [10, 2, 3]`\n * `[].modifyHead (· * 10) = []`\n</code>",
 "5105":
 "<code>List.modifyTR.{u_1} {α : Type u_1} (l : List α) (i : Nat) (f : α → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it.\n\nThis is a tail-recursive version of `List.modify`.\n\nExamples:\n* `[1, 2, 3].modifyTR 0 (· * 10) = [10, 2, 3]`\n* `[1, 2, 3].modifyTR 2 (· * 10) = [1, 2, 30]`\n* `[1, 2, 3].modifyTR 3 (· * 10) = [1, 2, 3]`\n</code>",
 "5104":
 "<code>List.modify.{u} {α : Type u} (l : List α) (i : Nat) (f : α → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it. If the\nindex is invalid, the list is returned unmodified.\n\nExamples:\n * `[1, 2, 3].modify 0 (· * 10) = [10, 2, 3]`\n * `[1, 2, 3].modify 2 (· * 10) = [1, 2, 30]`\n * `[1, 2, 3].modify 3 (· * 10) = [1, 2, 3]`\n</code>",
 "5103":
 "<code>List.set.{u_1} {α : Type u_1} (l : List α) (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the value at (zero-based) index `n` in `l` with `a`. If the index is out of bounds, then\nthe list is returned unmodified.\n\nExamples:\n* `[\"water\", \"coffee\", \"soda\", \"juice\"].set 1 \"tea\" = [\"water\", \"tea\", \"soda\", \"juice\"]`\n* `[\"water\", \"coffee\", \"soda\", \"juice\"].set 4 \"tea\" = [\"water\", \"coffee\", \"soda\", \"juice\"]`\n</code>",
 "5102": "<code><span class=\"literal string\">\"soda\"</span> : String</code>",
 "5101":
 "<code><span class=\"literal string\">\"[cat, dog, ]\"</span> : String</code>",
 "5100":
 "<code><span class=\"literal string\">\"[cat, dog]\"</span> : String</code>",
 "510": "<code>two : EvenPrime</code>",
 "51":
 "<code>thirdOfFive.eq_unfold.{u_1} :\n  @thirdOfFive = fun {α} x =&gt;\n    match x with\n    | [head, head_1, x, head_2, head_3] =&gt; some x\n    | x =&gt; none</code>",
 "5099": "<code><span class=\"literal string\">\"dog\"</span> : String</code>",
 "5098":
 "<code><span class=\"literal string\">\"[1, 2, 3]\"</span> : String</code>",
 "5097":
 "<code>List.toString.{u_1} {α : Type u_1} [ToString α] : List α → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a list into a string, using `ToString.toString` to convert its elements.\n\nThe resulting string resembles list literal syntax, with the elements separated by `\", \"` and\nenclosed in square brackets.\n\nThe resulting string may not be valid Lean syntax, because there's no such expectation for\n`ToString` instances.\n\nExamples:\n* `[1, 2, 3].toString = \"[1, 2, 3]\"`\n* `[\"cat\", \"dog\"].toString = \"[cat, dog]\"`\n* `[\"cat\", \"dog\", \"\"].toString = \"[cat, dog, ]\"`\n</code>",
 "5096": "<code>FloatArray : Type</code>",
 "5095": "<code>List Float</code>",
 "5094": "<code>List UInt8</code>",
 "5093":
 "<code><span class=\"literal string\">\", friday\"</span> : String</code>",
 "5092":
 "<code><span class=\"literal string\">\"].toArray = #[\"</span> : String</code>",
 "5091":
 "<code><span class=\"literal string\">\"wednesday\"</span> : String</code>",
 "5090":
 "<code><span class=\"literal string\">\"monday\"</span> : String</code>",
 "509":
 "<code>EvenPrime.isPrime (self : EvenPrime) (n : Nat) : n ≤ self.val → n ∣ self.val → n = 1 ∨ n = self.val</code>",
 "5089":
 "<code>Array.mk.{u} {α : Type u} (toList : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `List α` into an `Array α`.\n\nThe function `List.toArray` is preferred.\n\nAt runtime, this constructor is overridden by `List.toArrayImpl` and is `O(n)` in the length of\nthe list.\n</code>",
 "5088":
 "<code>List.toArrayImpl.{u_1} {α : Type u_1} (xs : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `List α` into an `Array α` by repeatedly pushing elements from the list onto an empty\narray. `O(|xs|)`.\n\nUse `List.toArray` instead of calling this function directly. At runtime, this operation implements\nboth `List.toArray` and `Array.mk`.\n</code>",
 "5087":
 "<code>List.findSome?.{u, v} {α : Type u} {β : Type v} (f : α → Option β) : List α → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying `f` to each element of the list in order. Returns\n`none` if `f` returns `none` for all elements of the list.\n\n`O(|l|)`.\n\nExamples:\n * `[7, 6, 5, 8, 1, 2, 6].findSome? (fun x =&gt; if x &lt; 5 then some (10 * x) else none) = some 10`\n * `[7, 6, 5, 8, 1, 2, 6].findSome? (fun x =&gt; if x &lt; 1 then some (10 * x) else none) = none`\n</code>",
 "5086":
 "<code>List.findIdx.{u} {α : Type u} (p : α → Bool) (l : List α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or the length of the list if\nthere is no such element.\n\nExamples:\n* `[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 5) = 4`\n* `[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 1) = 7`\n</code>",
 "5085":
 "<code>List.findFinIdx?.{u} {α : Type u} (p : α → Bool) (l : List α) : Option (Fin l.length)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or `none` if there is no such\nelement. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n* `[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 5) = some (4 : Fin 7)`\n* `[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 1) = none`\n</code>",
 "5084":
 "<code>List.find?.{u} {α : Type u} (p : α → Bool) : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the list for which the predicate `p` returns `true`, or `none` if no\nsuch element is found.\n\n`O(|l|)`.\n\nExamples:\n* `[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 5) = some 1`\n* `[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 1) = none`\n</code>",
 "5083": "<code>Fin [\"carrot\", \"potato\", \"broccoli\"].length</code>",
 "5082":
 "<code>List.finIdxOf?.{u} {α : Type u} [BEq α] (a : α) (l : List α) : Option (Fin l.length)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the length of the list if no element is\nequal to `a`. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"carrot\" = some 0`\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"broccoli\" = some 2`\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"tomato\" = none`\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"anything else\" = none`\n</code>",
 "5081":
 "<code>List.idxOf?.{u} {α : Type u} [BEq α] (a : α) : List α → Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or `none` if no element is equal to `a`.\n\nExamples:\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"carrot\" = some 0`\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"broccoli\" = some 2`\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"tomato\" = none`\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"anything else\" = none`\n</code>",
 "5080":
 "<code><span class=\"literal string\">\"anything else\"</span> : String</code>",
 "508": "<code>EvenPrime.notOne (self : EvenPrime) : self.val ≠ 1</code>",
 "5079":
 "<code><span class=\"literal string\">\"tomato\"</span> : String</code>",
 "5078":
 "<code>List.idxOf.{u} {α : Type u} [BEq α] (a : α) : List α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the length of the list if no element is\nequal to `a`.\n\nExamples:\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"carrot\" = 0`\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"broccoli\" = 2`\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"tomato\" = 3`\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"anything else\" = 3`\n</code>",
 "5077":
 "<code><span class=\"literal string\">\"broccoli\"</span> : String</code>",
 "5076":
 "<code><span class=\"literal string\">\"potato\"</span> : String</code>",
 "5075":
 "<code><span class=\"literal string\">\"carrot\"</span> : String</code>",
 "5074":
 "<code>List.countP.{u} {α : Type u} (p : α → Bool) (l : List α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of elements in the list `l` that satisfy the Boolean predicate `p`.\n\nExamples:\n* `[1, 2, 3, 4, 5].countP (· % 2 == 0) = 2`\n* `[1, 2, 3, 4, 5].countP (· &lt; 5) = 4`\n* `[1, 2, 3, 4, 5].countP (· &gt; 5) = 0`\n</code>",
 "5073":
 "<code>List.count.{u} {α : Type u} [BEq α] (a : α) : List α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of times an element occurs in a list.\n\nExamples:\n* `[1, 1, 2, 3, 5].count 1 = 2`\n* `[1, 1, 2, 3, 5].count 5 = 1`\n* `[1, 1, 2, 3, 5].count 4 = 0`\n</code>",
 "5072":
 "<code>List.min?.{u} {α : Type u} [Min α] : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the smallest element of the list if it is not empty, or `none` if it is empty.\n\nExamples:\n* `[].min? = none`\n* `[4].min? = some 4`\n* `[1, 4, 2, 10, 6].min? = some 1`\n</code>",
 "5071":
 "<code>List.max?.{u} {α : Type u} [Max α] : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the largest element of the list if it is not empty, or `none` if it is empty.\n\nExamples:\n* `[].max? = none`\n* `[4].max? = some 4`\n* `[1, 4, 2, 10, 6].max? = some 10`\n</code>",
 "5070":
 "<code>List.lookup.{u, v} {α : Type u} {β : Type v} [BEq α] : α → List (α × β) → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Treats the list as an association list that maps keys to values, returning the first value whose key\nis equal to the specified key.\n\n`O(|l|)`.\n\nExamples:\n* `[(1, \"one\"), (3, \"three\"), (3, \"other\")].lookup 3 = some \"three\"`\n* `[(1, \"one\"), (3, \"three\"), (3, \"other\")].lookup 2 = none`\n</code>",
 "507": "<code>EvenPrime : Type</code>",
 "5069":
 "<code><span class=\"literal string\">\"other\"</span> : String</code>",
 "5068": "<code><span class=\"literal string\">\"oval\"</span> : String</code>",
 "5067":
 "<code>List.getLast?.{u} {α : Type u} : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element in the list, or `none` if the list is empty.\n\nAlternatives include `List.getLastD`, which takes a fallback value for empty lists, and\n`List.getLast!`, which panics on empty lists.\n\nExamples:\n * `[\"circle\", \"rectangle\"].getLast? = some \"rectangle\"`\n * `[\"circle\"].getLast? = some \"circle\"`\n * `([] : List String).getLast? = none`\n</code>",
 "5066":
 "<code>List.getLast!.{u_1} {α : Type u_1} [Inhabited α] : List α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element in the list. Panics and returns `default` if the list is empty.\n\nSafer alternatives include:\n* `getLast?`, which returns an `Option`,\n* `getLastD`, which takes a fallback value for empty lists, and\n* `getLast`, which requires a proof that the list is non-empty.\n\nExamples:\n* `[\"circle\", \"rectangle\"].getLast! = \"rectangle\"`\n* `[\"circle\"].getLast! = \"circle\"`\n</code>",
 "5065":
 "<code><span class=\"literal string\">\"rectangle\"</span> : String</code>",
 "5064":
 "<code><span class=\"literal string\">\"circle\"</span> : String</code>",
 "5063":
 "<code><span class=\"literal string\">\"never\"</span> : String</code>",
 "5062":
 "<code>List.getD.{u_1} {α : Type u_1} (as : List α) (i : Nat) (fallback : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the element at the provided index, counting from `0`. Returns `fallback` if the index is out\nof bounds.\n\nTo return an `Option` depending on whether the index is in bounds, use `as[i]?`. To panic if the\nindex is out of bounds, use `as[i]!`.\n\nExamples:\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].getD 2 \"never\" = \"fall\"`\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].getD 0 \"never\" = \"spring\"`\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].getD 4 \"never\" = \"never\"`\n</code>",
 "5061":
 "<code><span class=\"literal string\">\"winter\"</span> : String</code>",
 "5060": "<code><span class=\"literal string\">\"fall\"</span> : String</code>",
 "506": "<code>EvenNumber.isEven (self : EvenNumber) : 2 ∣ self.val</code>",
 "5059":
 "<code><span class=\"literal string\">\"summer\"</span> : String</code>",
 "5058":
 "<code><span class=\"literal string\">\"spring\"</span> : String</code>",
 "5057":
 "<code>List.get.{u} {α : Type u} (as : List α) : Fin as.length → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the element at the provided index, counting from `0`.\n\nIn other words, for `i : Fin as.length`, `as.get i` returns the `i`'th element of the list `as`.\nBecause the index is a `Fin` bounded by the list's length, the index will never be out of bounds.\n\nExamples:\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].get (2 : Fin 4) = \"fall\"`\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].get (0 : Fin 4) = \"spring\"`\n</code>",
 "5056": "<code>Fin as.length</code>",
 "5055":
 "<code>List.tail?.{u} {α : Type u} : List α → Option (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. Returns `none` when the argument is\nempty.\n\nAlternatives include `List.tail`, which returns the empty list on failure, `List.tailD`, which\nreturns an explicit fallback value, and `List.tail!`, which panics on the empty list.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tail? = some [\"banana\", \"grape\"]`\n * `[\"apple\"].tail? = some []`\n * `([] : List String).tail = none`\n</code>",
 "5054":
 "<code>List.tailD.{u} {α : Type u} (l fallback : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. Returns `none` when the argument is\nempty.\n\nAlternatives include `List.tail`, which returns the empty list on failure, `List.tail?`, which\nreturns an `Option`, and `List.tail!`, which panics on the empty list.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tailD [\"orange\"] = [\"banana\", \"grape\"]`\n * `[\"apple\"].tailD [\"orange\"] = []`\n * `[].tailD [\"orange\"] = [\"orange\"]`\n</code>",
 "5053":
 "<code>List.tail!.{u_1} {α : Type u_1} : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. If the list is empty, this function\npanics when executed and returns the empty list.\n\nSafer alternatives include\n * `tail`, which returns the empty list without panicking,\n * `tail?`, which returns an `Option`, and\n * `tailD`, which returns a fallback value when passed the empty list.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tail! = [\"banana\", \"grape\"]`\n * `[\"banana\", \"grape\"].tail! = [\"grape\"]`\n</code>",
 "5052": "<code><span class=\"literal string\">\"toes\"</span> : String</code>",
 "5051":
 "<code><span class=\"literal string\">\"knees\"</span> : String</code>",
 "5050":
 "<code><span class=\"literal string\">\"shoulders\"</span> : String</code>",
 "505": "<code>EvenNumber.val (self : EvenNumber) : Nat</code>",
 "5049": "<code><span class=\"literal string\">\"head\"</span> : String</code>",
 "5048":
 "<code>List.head?.{u} {α : Type u} : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element in the list, if there is one. Returns `none` if the list is empty.\n\nUse `List.headD` to provide a fallback value for empty lists, or `List.head!` to panic on empty\nlists.\n\nExamples:\n * `([] : List Nat).head? = none`\n * `[3, 2, 1].head? = some 3`\n</code>",
 "5047":
 "<code>List.headD.{u} {α : Type u} (as : List α) (fallback : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element in the list if there is one, or `fallback` if the list is empty.\n\nUse `List.head?` to return an `Option`, and `List.head!` to panic on empty lists.\n\nExamples:\n* `[].headD \"empty\" = \"empty\"`\n* `[].headD 2 = 2`\n* `[\"head\", \"shoulders\", \"knees\"].headD \"toes\" = \"head\"`\n</code>",
 "5046":
 "<code><span class=\"literal string\">\"grape\"</span> : String</code>",
 "5045":
 "<code>List.isEmpty.{u} {α : Type u} : List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a list is empty.\n\n`O(1)`.\n\nExamples:\n* `[].isEmpty = true`\n* `[\"grape\"].isEmpty = false`\n* `[\"apple\", \"banana\"].isEmpty = false`\n</code>",
 "5044":
 "<code>List.lengthTR.{u_1} {α : Type u_1} (as : List α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The length of a list.\n\nThis is a tail-recursive version of `List.length`, used to implement `List.length` without running\nout of stack space.\n\nExamples:\n * `([] : List String).lengthTR = 0`\n * `[\"green\", \"brown\"].lengthTR = 2`\n</code>",
 "5043":
 "<code>List.finRange (n : Nat) : List (Fin n)</code><span class=\"sep\"></span><code class=\"docstring\">Lists all elements of `Fin n` in order, starting at `0`.\n\nExamples:\n* `List.finRange 0 = ([] : List (Fin 0))`\n* `List.finRange 2 = ([0, 1] : List (Fin 2))`\n</code>",
 "5042":
 "<code>List.range'TR (s n : Nat) (step : Nat := 1) : List Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a list of the numbers with the given length `len`, starting at `start` and increasing by\n`step` at each element.\n\nIn other words, `List.range'TR start len step` is `[start, start+step, ..., start+(len-1)*step]`.\n\nThis is a tail-recursive version of `List.range'`.\n\nExamples:\n * `List.range'TR 0 3 (step := 1) = [0, 1, 2]`\n * `List.range'TR 0 3 (step := 2) = [0, 2, 4]`\n * `List.range'TR 0 4 (step := 2) = [0, 2, 4, 6]`\n * `List.range'TR 3 4 (step := 2) = [3, 5, 7, 9]`\n</code>",
 "5041":
 "<code>List.range' (start len : Nat) (step : Nat := 1) : List Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a list of the numbers with the given length `len`, starting at `start` and increasing by\n`step` at each element.\n\nIn other words, `List.range' start len step` is `[start, start+step, ..., start+(len-1)*step]`.\n\nExamples:\n * `List.range' 0 3 (step := 1) = [0, 1, 2]`\n * `List.range' 0 3 (step := 2) = [0, 2, 4]`\n * `List.range' 0 4 (step := 2) = [0, 2, 4, 6]`\n * `List.range' 3 4 (step := 2) = [3, 5, 7, 9]`\n</code>",
 "5040": "<code>optParam Nat 1</code>",
 "504": "<code>EvenNumber : Type</code>",
 "5039":
 "<code>List.append.{u_1} {α : Type u_1} (xs ys : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Appends two lists. Normally used via the `++` operator.\n\nAppending lists takes time proportional to the length of the first list: `O(|xs|)`.\n\nExamples:\n* `[1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5]`.\n* `[] ++ [4, 5] = [4, 5]`.\n* `[1, 2, 3] ++ [] = [1, 2, 3]`.\n</code>",
 "5038": "<code>Fin ?m.38</code>",
 "5037": "<code><span class=\"literal string\">\"2\"</span> : String</code>",
 "5036":
 "<code>List.ofFn.{u_1} {α : Type u_1} {n : Nat} (f : Fin n → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a list by applying `f` to each potential index in order, starting at `0`.\n\nExamples:\n* `List.ofFn (n := 3) toString = [\"0\", \"1\", \"2\"]`\n* `List.ofFn (fun i =&gt; #[\"red\", \"green\", \"blue\"].get i.val i.isLt) = [\"red\", \"green\", \"blue\"]`\n</code>",
 "5035": "<code>Fin n → α</code>",
 "5034":
 "<code>List.replicateTR.{u} {α : Type u} (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a list that contains `n` copies of `a`.\n\nThis is a tail-recursive version of `List.replicate`.\n\n* `List.replicateTR 5 \"five\" = [\"five\", \"five\", \"five\", \"five\", \"five\"]`\n* `List.replicateTR 0 \"zero\" = []`\n* `List.replicateTR 2 ' ' = [' ', ' ']`\n</code>",
 "5033": "<code><span class=\"literal string\">\"zero\"</span> : String</code>",
 "5032":
 "<code>List.concat.{u} {α : Type u} : List α → α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Adds an element to the *end* of a list.\n\nThe added element is the last element of the resulting list.\n\nExamples:\n* `List.concat [\"red\", \"yellow\"] \"green\" = [\"red\", \"yellow\", \"green\"]`\n* `List.concat [1, 2, 3] 4 = [1, 2, 3, 4]`\n* `List.concat [] () = [()]`\n</code>",
 "5031":
 "<code>List.Mem.{u} {α : Type u} (a : α) : List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">List membership, typically accessed via the `∈` operator.\n\n`a ∈ l` means that `a` is an element of the list `l`. Elements are compared according to Lean's\nlogical equality.\n\nThe related function `List.elem` is a Boolean membership test that uses a `BEq α` instance.\n\nExamples:\n* `a ∈ [x, y, z] ↔ a = x ∨ a = y ∨ a = z`\n</code>",
 "5030":
 "<code>List.elem.{u} {α : Type u} [BEq α] (a : α) (l : List α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `l`, using `==` to compare elements.\n\n`O(|l|)`. `List.contains` is a synonym that takes the list before the element.\n\nThe preferred simp normal form is `l.contains a`. When `LawfulBEq α` is available,\n`l.contains a = true ↔ a ∈ l` and `l.contains a = false ↔ a ∉ l`.\n\nExample:\n* `List.elem 3 [1, 4, 2, 3, 3, 7] = true`\n* `List.elem 5 [1, 4, 2, 3, 3, 7] = false`\n</code>",
 "503":
 "<code>Triple.toPair.{u} {α : Type u} (self : Triple α) : Pair α</code>",
 "5029": "<code>List.Lex r l₁ l₂</code>",
 "5028": "<code>r a₁ a₂</code>",
 "5027":
 "<code>List.Lex.{u} {α : Type u} (r : α → α → Prop) (as bs : List α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lexicographic ordering for lists with respect to an ordering of elements.\n\n`as` is lexicographically smaller than `bs` if\n* `as` is empty and `bs` is non-empty, or\n* both `as` and `bs` are non-empty, and the head of `as` is less than the head of `bs` according to\n  `r`, or\n* both `as` and `bs` are non-empty, their heads are equal, and the tail of `as` is less than the\n  tail of `bs`.\n</code>",
 "5026":
 "<code>List.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Each element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and `Pairwise (· &lt; ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· &lt; ·) [1, 2, 3] ↔ (1 &lt; 2 ∧ 1 &lt; 3) ∧ 2 &lt; 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n</code>",
 "5025":
 "<code>List.Perm.{u} {α : Type u} : List α → List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two lists are permutations of each other if they contain the same elements, each occurring the same\nnumber of times but not necessarily in the same order.\n\nOne list can be proven to be a permutation of another by showing how to transform one into the other\nby repeatedly swapping adjacent elements.\n\n`List.isPerm` is a Boolean equivalent of this relation.\n</code>",
 "5024":
 "<code>List.isPerm.{u} {α : Type u} [BEq α] : List α → List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `l₁` and `l₂` are permutations of each other. `O(|l₁| * |l₂|)`.\n\nThe relation `List.Perm` is a logical characterization of permutations. When the `BEq α` instance\ncorresponds to `DecidableEq α`, `isPerm l₁ l₂ ↔ l₁ ~ l₂` (use the theorem `isPerm_iff`).\n</code>",
 "5023":
 "<code>List.Sublist.{u_1} {α : Type u_1} : List α → List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The first list is a non-contiguous sub-list of the second list. Typically written with the `&lt;+`\noperator.\n\nIn other words, `l₁ &lt;+ l₂` means that `l₁` can be transformed into `l₂` by repeatedly inserting new\nelements.\n</code>",
 "5022": "<code>Type ?u.3612</code>",
 "5021": "<code>List ?m.7</code>",
 "5020": "<code>Type ?u.2421</code>",
 "502": "<code>Nat</code>",
 "5019":
 "<code>List.isSuffixOf.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first list is a suffix of the second.\n\nThe relation `List.IsSuffixOf` expresses this property with respect to logical equality.\n\nExamples:\n* `[2, 3].isSuffixOf [1, 2, 3] = true`\n* `[2, 3].isSuffixOf [1, 2, 3, 4] = false`\n* `[2, 3].isSuffixOf [1, 2] = false`\n* `[2, 3].isSuffixOf [1, 1, 2, 3] = true`\n</code>",
 "5018": "<code>Type ?u.839</code>",
 "5017":
 "<code>List.isPrefixOf.{u} {α : Type u} [BEq α] : List α → List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first list is a prefix of the second.\n\nThe relation `List.IsPrefixOf` expresses this property with respect to logical equality.\n\nExamples:\n* `[1, 2].isPrefixOf [1, 2, 3] = true`\n* `[1, 2].isPrefixOf [1, 2] = true`\n* `[1, 2].isPrefixOf [1] = false`\n* `[1, 2].isPrefixOf [1, 1, 2, 3] = false`\n</code>",
 "5016": "<code>split''.{u_1} {α : Type u_1} : List α → List α × List α</code>",
 "5015":
 "<code>List.singleton.{u} {α : Type u} (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a single-element list.\n\nExamples:\n* `List.singleton 5 = [5]`.\n* `List.singleton \"green\" = [\"green\"]`.\n* `List.singleton [1, 2, 3] = [[1, 2, 3]]`\n</code>",
 "5014": "<code>split'.{u_1} {α : Type u_1} : List α → List α × List α</code>",
 "5013": "<code>split.{u_1} {α : Type u_1} : List α → List α × List α</code>",
 "5012": "<code>List ?m.1</code>",
 "5011": "<code>List ?m.16</code>",
 "5010": "<code>?m.12</code>",
 "501": "<code>coords : Triple Nat</code>",
 "5009":
 "<code>Singleton.singleton.{u, v} {α : outParam (Type u)} {β : Type v} [self : Singleton α β] : α → β</code><span class=\"sep\"></span><code class=\"docstring\">`singleton x` is a collection with the single element `x` (notation: `{x}`). \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.</code>",
 "5008":
 "<code class=\"docstring\">simplification theorem for the compiler</code>",
 "5007":
 "<code>Sum.inhabitedLeft.{u, v} {α : Type u} {β : Type v} [Inhabited α] : Inhabited (α ⊕ β)</code><span class=\"sep\"></span><code class=\"docstring\">If the left type in a sum is inhabited then the sum is inhabited.\n\nThis is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n</code>",
 "5006":
 "<code><span class=\"literal string\">\"Cant' find it\"</span> : String</code>",
 "5005":
 "<code class=\"docstring\">`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n</code>",
 "5004": "<code>β → β'</code>",
 "5003": "<code>α → α'</code>",
 "5002":
 "<code>Sum.isRight.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α ⊕ β → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a sum is the right injection `inr`. </code>",
 "5001":
 "<code>Sum.isLeft.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α ⊕ β → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a sum is the left injection `inl`. </code>",
 "5000": "<code>α ⊕ β</code>",
 "500": "<code>Triple.thd.{u} {α : Type u} (self : Triple α) : α</code>",
 "50":
 "<code>Option.none.{u} {α : Type u} : Option α</code><span class=\"sep\"></span><code class=\"docstring\">No value. </code>",
 "5":
 "<code>IO.println.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it with a trailing newline to\nthe current standard output (as determined by `IO.getStdout`).\n</code>",
 "4999": "<code>α → γ</code>",
 "4998":
 "<code>PSigma.fst.{u, v} {α : Sort u} {β : α → Sort v} (self : PSigma β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>",
 "4997": "<code>PSigma β</code>",
 "4996": "<code>Sum'.swap {α β : Type} : Sum' α β → Sum' β α</code>",
 "4995": "<code>Sum'.inr {α β : Type} (x : β) : Sum' α β</code>",
 "4994": "<code>Sum'.inl {α β : Type} (x : α) : Sum' α β</code>",
 "4993": "<code>Sum' (α β : Type) : Type</code>",
 "4992":
 "<code>Sigma.snd.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : β self.fst</code><span class=\"sep\"></span><code class=\"docstring\">The second component of a dependent pair. Its type depends on the first component.\n</code>",
 "4991": "<code>(n : Nat) × Vector String n</code>",
 "4990":
 "<code><span class=\"literal string\">\"Please enter a number.\"</span> : String</code>",
 "499": "<code>Triple.{u} (α : Type u) : Type u</code>",
 "4989":
 "<code><span class=\"literal string\">\"How many lines to read?\"</span> : String</code>",
 "4988": "<code>getValues : IO ((n : Nat) × Vector String n)</code>",
 "4987":
 "<code>Vector.reverse.{u_1} {α : Type u_1} {n : Nat} (xs : Vector α n) : Vector α n</code><span class=\"sep\"></span><code class=\"docstring\">Reverse the elements of a vector. </code>",
 "4986": "<code>getNLines (n : Nat) : IO (Vector String n)</code>",
 "4985":
 "<code>Vector.push.{u_1} {α : Type u_1} {n : Nat} (xs : Vector α n) (x : α) : Vector α (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">Push an element `x` to the end of a vector. </code>",
 "4984": "<code>Vector String n</code>",
 "4983":
 "<code class=\"docstring\">Syntax for `Vector α n` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `#v[]` in identifiers is `empty`.\n\n * The recommended spelling of `#v[x]` in identifiers is `singleton`.</code>",
 "4982": "<code>getNLinesRev (n : Nat) : IO (Vector String n)</code>",
 "4981":
 "<code>Sigma.fst.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>",
 "4980": "<code>Sigma β</code>",
 "498": "<code>Pair.snd.{u} {α : Type u} (self : Pair α) : α</code>",
 "4979":
 "<code>β self.fst</code><span class=\"sep\"></span><code class=\"docstring\">The second component of a dependent pair. Its type depends on the first component.\n</code>",
 "4978":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>",
 "4977": "<code>α → Type v</code>",
 "4976":
 "<code>Sigma.mk.{u, v} {α : Type u} {β : α → Type v} (fst : α) (snd : β fst) : Sigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a dependent pair.\n\nUsing this constructor in a context in which the type is not known usually requires a type\nascription to determine `β`. This is because the desired relationship between the two values can't\ngenerally be determined automatically.\n</code>",
 "4975": "<code>Fin (n * k)</code>",
 "4974": "<code>α × β</code>",
 "4973": "<code><span class=\"literal string\">\"6\"</span> : String</code>",
 "4972": "<code><span class=\"literal string\">\"7\"</span> : String</code>",
 "4971":
 "<code>Prod.foldI.{u} {α : Type u} (i : Nat × Nat) (f : (j : Nat) → i.fst ≤ j → j &lt; i.snd → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Combines an initial value with each natural number from a range, in increasing order.\n\nIn particular, `(start, stop).foldI f init` applies `f`on all the numbers\nfrom `start` (inclusive) to `stop` (exclusive) in increasing order:\n\nExamples:\n* `(5, 8).foldI (fun j _ _ xs =&gt; xs.push j) #[] = (#[] |&gt;.push 5 |&gt;.push 6 |&gt;.push 7)`\n* `(5, 8).foldI (fun j _ _ xs =&gt; xs.push j) #[] = #[5, 6, 7]`\n* `(5, 8).foldI (fun j _ _ xs =&gt; toString j :: xs) [] = [\"7\", \"6\", \"5\"]`\n</code>",
 "4970": "<code>(j : Nat) → i.fst ≤ j → j &lt; i.snd → α → α</code>",
 "497": "<code>Pair.fst.{u} {α : Type u} (self : Pair α) : α</code>",
 "4969":
 "<code>Prod.anyI (i : Nat × Nat) (f : (j : Nat) → i.fst ≤ j → j &lt; i.snd → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a predicate holds for any natural number in a range.\n\nIn particular, `(start, stop).allI f` returns true if `f` is true for any natural number from\n`start` (inclusive) to `stop` (exclusive).\n\nExamples:\n * `(5, 8).anyI (fun j _ _ =&gt; j == 6) = (5 == 6) || (6 == 6) || (7 == 6)`\n * `(5, 8).anyI (fun j _ _ =&gt; j % 2 = 0) = true`\n * `(6, 6).anyI (fun j _ _ =&gt; j % 2 = 0) = false`\n</code>",
 "4968":
 "<code>Prod.allI (i : Nat × Nat) (f : (j : Nat) → i.fst ≤ j → j &lt; i.snd → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a predicate holds for all natural numbers in a range.\n\nIn particular, `(start, stop).allI f` returns true if `f` is true for all natural numbers from\n`start` (inclusive) to `stop` (exclusive).\n\nExamples:\n * `(5, 8).allI (fun j _ _ =&gt; j &lt; 10) = (5 &lt; 10) && (6 &lt; 10) && (7 &lt; 10)`\n * `(5, 8).allI (fun j _ _ =&gt; j % 2 = 0) = false`\n * `(6, 7).allI (fun j _ _ =&gt; j % 2 = 0) = true`\n</code>",
 "4967": "<code>(j : Nat) → i.fst ≤ j → j &lt; i.snd → Bool</code>",
 "4966":
 "<code>Prod.map.{u₁, u₂, v₁, v₂} {α₁ : Type u₁} {α₂ : Type u₂} {β₁ : Type v₁} {β₂ : Type v₂} (f : α₁ → α₂) (g : β₁ → β₂) :\n  α₁ × β₁ → α₂ × β₂</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a pair by applying functions to both elements.\n\nExamples:\n* `(1, 2).map (· + 1) (· * 3) = (2, 6)`\n* `(1, 2).map toString (· * 3) = (\"1\", 6)`\n</code>",
 "4965": "<code>β₁ → β₂</code>",
 "4964": "<code>α₁ → α₂</code>",
 "4963": "<code>Type v₂</code>",
 "4962": "<code>Type v₁</code>",
 "4961": "<code>Type u₂</code>",
 "4960":
 "<code>MProd.mk.{u} {α β : Type u} (fst : α) (snd : β) : MProd α β</code>",
 "496": "<code>Pair.{u} (α : Type u) : Type u</code>",
 "4959":
 "<code>β</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "4958":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "4957": "<code>Type w</code>",
 "4956":
 "<code>MProd.{u} (α β : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A product type in which both `α` and `β` are in the same universe.\n\nIt is called `MProd` is because it is the *universe-monomorphic* product type.\n</code>",
 "4955": "<code>v = some x✝</code>",
 "4954": "<code>a ∈ v</code>",
 "4953":
 "<code>Option.pmap.{u_1, u_2} {α : Type u_1} {β : Type u_2} {p : α → Prop} (f : (a : α) → p a → β) (o : Option α) :\n  (∀ (a : α), o = some a → p a) → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Given a function from the elements of `α` that satisfy `p` to `β` and a proof that an optional value\nsatisfies `p` if it's present, applies the function to the value.\n\nExamples:\n```lean example\ndef attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pmap (fun a (h : a ∈ v) =&gt; ⟨_, h⟩) (fun _ h =&gt; h)\n```\n```lean example\n#reduce attach (some 3)\n```\n```output\nsome ⟨3, ⋯⟩\n```\n```lean example\n#reduce attach none\n```\n```output\nnone\n```\n</code>",
 "4952": "<code>(a : α) → p a → β</code>",
 "4951":
 "<code>Option.pelim.{u_1, u_2} {α : Type u_1} {β : Sort u_2} (o : Option α) (b : β) (f : (a : α) → o = some a → β) : β</code><span class=\"sep\"></span><code class=\"docstring\">Given an optional value and a function that can be applied when the value is `some`, returns the\nresult of applying the function if this is possible, or a fallback value otherwise.\n\nThe function `f` is _partial_ because it is only defined for the values `a : α` such that\n`o = some a`. This restriction allows the function to use the fact that it can only be called when\n`o` is not `none`: it can relate its argument to the optional value `o`. Its runtime behavior is\nequivalent to that of `Option.elim`.\n\nExamples:\n```lean example\ndef attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pelim none fun x h =&gt; some ⟨x, h⟩\n```\n```lean example\n#reduce attach (some 3)\n```\n```output\nsome ⟨3, ⋯⟩\n```\n```lean example\n#reduce attach none\n```\n```output\nnone\n```\n</code>",
 "4950": "<code>(a : α) → o = some a → β</code>",
 "495":
 "<code>AcademicWork.mk (author discipline : String) : AcademicWork</code>",
 "4949": "<code>v = some x</code>",
 "4948":
 "<code>Option.pbind.{u_1, u_2} {α : Type u_1} {β : Type u_2} (o : Option α) (f : (a : α) → o = some a → Option β) : Option β</code><span class=\"sep\"></span><code class=\"docstring\">Given an optional value and a function that can be applied when the value is `some`, returns the\nresult of applying the function if this is possible.\n\nThe function `f` is _partial_ because it is only defined for the values `a : α` such that\n`o = some a`. This restriction allows the function to use the fact that it can only be called when\n`o` is not `none`: it can relate its argument to the optional value `o`. Its runtime behavior is\nequivalent to that of `Option.bind`.\n\nExamples:\n```lean example\ndef attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pbind fun x h =&gt; some ⟨x, h⟩\n```\n```lean example\n#reduce attach (some 3)\n```\n```output\nsome ⟨3, ⋯⟩\n```\n```lean example\n#reduce attach none\n```\n```output\nnone\n```\n</code>",
 "4947":
 "<code>attach.{u_1} {α : Type u_1} (v : Option α) : Option { y // v = some y }</code>",
 "4946": "<code>(a : α) → o = some a → Option β</code>",
 "4945": "<code>Option { x // p x }</code>",
 "4944":
 "<code>Option.attach.{u_1} {α : Type u_1} (xs : Option α) : Option { x // xs = some x }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” a proof that an optional value, if present, is indeed this value, returning a subtype\nthat expresses this fact.\n\nThis function is primarily used to allow definitions by well-founded recursion that use iteration\noperators (such as `Option.map`) to prove that an optional value drawn from a parameter is smaller\nthan the parameter. This allows the well-founded recursion mechanism to prove that the function\nterminates.\n</code>",
 "4943": "<code>∀ (x : α), xs = some x → P x</code>",
 "4942":
 "<code>Option.mapA.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Applicative m] (f : α → m β) :\n  Option α → m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function in some applicative functor to an optional value, returning `none` with no\neffects if the value is missing.\n\nThis is an alias for `Option.mapM`, which already works for applicative functors.\n</code>",
 "4941":
 "<code>Option.forM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} [Pure m] : Option α → (α → m PUnit) → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Executes a monadic action on an optional value if it is present, or does nothing if there is no\nvalue.\n\nExamples:\n```lean example\n#eval ((some 5).forM set : StateM Nat Unit).run 0\n```\n```output\n((), 5)\n```\n```lean example\n#eval (none.forM (fun x : Nat =&gt; set x) : StateM Nat Unit).run 0\n```\n```output\n((), 0)\n```\n</code>",
 "4940":
 "<code>Option.filterM.{u_1} {m : Type → Type u_1} {α : Type} [Applicative m] (p : α → m Bool) : Option α → m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Keeps an optional value only if it satisfies a monadic Boolean predicate.\n\nIf `Option` is thought of as a collection that contains at most one element, then `Option.filterM`\nis analogous to `List.filterM`.\n</code>",
 "494": "<code>Book.mk (title author : String) : Book</code>",
 "4939": "<code>α → m Bool</code>",
 "4938":
 "<code>Array.filter.{u} {α : Type u} (p : α → Bool) (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the array of elements in `as` for which `p` returns `true`.\n\nOnly elements from `start` (inclusive) to `stop` (exclusive) are considered. Elements outside that\nrange are discarded. By default, the entire array is considered.\n\nExamples:\n* `#[1, 2, 5, 2, 7, 7].filter (· &gt; 2) = #[5, 7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; false) = #[]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) = #[1, 2, 5, 2, 7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (· &gt; 2) (start := 3) = #[7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) (start := 3) = #[2, 7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) (stop := 3) = #[1, 2, 5]`\n</code>",
 "4937":
 "<code>List.filter.{u} {α : Type u} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the list of elements in `l` for which `p` returns `true`.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 2, 5, 2, 7, 7].filter (· &gt; 2) = [5, 7, 7]`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; false) = []`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) = [1, 2, 5, 2, 7, 7]`\n</code>",
 "4936":
 "<code>Option.filter.{u_1} {α : Type u_1} (p : α → Bool) : Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Keeps an optional value only if it satisfies a Boolean predicate.\n\nIf `Option` is thought of as a collection that contains at most one element, then `Option.filter` is\nanalogous to `List.filter` or `Array.filter`.\n\nExamples:\n * `(some 5).filter (· % 2 == 0) = none`\n * `(some 4).filter (· % 2 == 0) = some 4`\n * `none.filter (fun x : Nat =&gt; x % 2 == 0) = none`\n * `none.filter (fun x : Nat =&gt; true) = none`\n</code>",
 "4935":
 "<code>OrElse.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HOrElse`: `a &lt;|&gt; b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n</code>",
 "4934":
 "<code><span class=\"literal string\">\"succeeded\"</span> : String</code>",
 "4933":
 "<code><span class=\"literal string\">\"handled\"</span> : String</code>",
 "4932":
 "<code>Option.tryCatch.{u_1} {α : Type u_1} (x : Option α) (handle : Unit → Option α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Recover from failing `Option` computations with a handler function.\n\nThis function is usually accessed through the `MonadExceptOf Unit Option` instance.\n\nExamples:\n* `Option.tryCatch none (fun () =&gt; some \"handled\") = some \"handled\"`\n* `Option.tryCatch (some \"succeeded\") (fun () =&gt; some \"handled\") = some \"succeeded\"`\n</code>",
 "4931": "<code>Unit → Option α</code>",
 "4930":
 "<code>Option.sequence.{u, u_1} {m : Type u → Type u_1} [Applicative m] {α : Type u} : Option (m α) → m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Converts an optional monadic computation into a monadic computation of an optional value.\n\nThis function only requires `m` to be an applicative functor.\n\nExample:\n```lean example\n#eval show IO (Option String) from\n  Option.sequence &lt;| some do\n    IO.println \"hello\"\n    return \"world\"\n```\n```output\nhello\n```\n```output\nsome \"world\"\n```\n</code>",
 "493": "<code>toAcademicWork (self : Textbook) : AcademicWork</code>",
 "4929":
 "<code>Option.join.{u_1} {α : Type u_1} (x : Option (Option α)) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Flattens nested optional values, preserving any value found.\n\nThis is analogous to `List.flatten`.\n\nExamples:\n* `none.join = none`\n* `(some none).join = none`\n* `(some (some v)).join = some v`\n</code>",
 "4928":
 "<code>List.flatten.{u_1} {α : Type u_1} : List (List α) → List α</code><span class=\"sep\"></span><code class=\"docstring\">Concatenates a list of lists into a single list, preserving the order of the elements.\n\n`O(|flatten L|)`.\n\nExamples:\n* `[[\"a\"], [\"b\", \"c\"]].flatten = [\"a\", \"b\", \"c\"]`\n* `[[\"a\"], [], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]].flatten = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]`\n</code>",
 "4927": "<code>Option (Option α)</code>",
 "4926": "<code>α → m (Option β)</code>",
 "4925":
 "<code>Option.guard.{u_1} {α : Type u_1} (p : α → Bool) (a : α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns `none` if a value doesn't satisfy a Boolean predicate, or the value itself otherwise.\n\nFrom the perspective of `Option` as computations that might fail, this function is a run-time\nassertion operator in the `Option` monad.\n\nExamples:\n * `Option.guard (· &gt; 2) 1 = none`\n * `Option.guard (· &gt; 2) 5 = some 5`\n</code>",
 "4924":
 "<code>Option.toList.{u_1} {α : Type u_1} : Option α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an optional value to a list with zero or one element.\n\nExamples:\n* `(some \"value\").toList = [\"value\"]`\n* `none.toList = []`\n</code>",
 "4923":
 "<code>Option.toArray.{u_1} {α : Type u_1} : Option α → Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an optional value to an array with zero or one element.\n\nExamples:\n* `(some \"value\").toArray = #[\"value\"]`\n* `none.toArray = #[]`\n</code>",
 "4922":
 "<code><span class=\"literal string\">\"value\"</span> : String</code>",
 "4921":
 "<code>Option.lt.{u_1, u_2} {α : Type u_1} {β : Type u_2} (r : α → β → Prop) : Option α → Option β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an ordering relation to `Option`, such that `none` is the least element.\n\nIt can be understood as adding a distinguished least element, represented by `none`, to both `α` and\n`β`.\n\nThis definition is part of the implementation of the `LT (Option α)` instance. However, because it\ncan be used with heterogeneous relations, it is sometimes useful on its own.\n\nExamples:\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) none none = False`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) none (some 3) = True`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) (some 3) none = False`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) (some 4) (some 5) = True`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) (some 4) (some 4) = False`\n</code>",
 "4920":
 "<code>Option.max.{u_1} {α : Type u_1} [Max α] : Option α → Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">The maximum of two optional values.\n\nThis function is usually accessed through the `Max (Option α)` instance, rather than directly.\n\nExamples:\n* `Option.max (some 2) (some 5) = some 5`\n* `Option.max (some 5) (some 2) = some 5`\n* `Option.max (some 2) none = some 2`\n* `Option.max none (some 5) = some 5`\n* `Option.max none none = none`\n</code>",
 "492": "<code>Textbook.toAcademicWork (self : Textbook) : AcademicWork</code>",
 "4919":
 "<code>Option.min.{u_1} {α : Type u_1} [Min α] : Option α → Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">The minimum of two optional values, with `none` treated as the least element. This function is\nusually accessed through the `Min (Option α)` instance, rather than directly.\n\nPrior to `nightly-2025-02-27`, `none` was treated as the greatest element, so\n`min none (some x) = min (some x) none = some x`.\n\nExamples:\n * `Option.min (some 2) (some 5) = some 2`\n * `Option.min (some 5) (some 2) = some 2`\n * `Option.min (some 2) none = none`\n * `Option.min none (some 5) = none`\n * `Option.min none none = none`\n</code>",
 "4918":
 "<code>Option.isEqSome.{u_1} {α : Type u_1} [BEq α] : Option α → α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether an optional value is both present and equal to some other value.\n\nGiven `x? : Option α` and `y : α`, `x?.isEqSome y` is equivalent to `x? == some y`. It is more\nefficient because it avoids an allocation.\n</code>",
 "4917":
 "<code>Option.isNone.{u_1} {α : Type u_1} : Option α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` on `none` and `false` on `some x`.\n\nThis function is more flexible than `(· == none)` because it does not require a `BEq α` instance.\n\nExamples:\n* `(none : Option Nat).isNone = true`\n* `(some Nat.add).isNone = false`\n</code>",
 "4916":
 "<code>Option.merge.{u_1} {α : Type u_1} (fn : α → α → α) : Option α → Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to a two optional values if both are present. Otherwise, if one value is present,\nit is returned and the function is not used.\n\nThe value is `some (fn a b)` if the inputs are `some a` and `some b`. Otherwise, the behavior is\nequivalent to `Option.orElse`: if only one input is `some x`, then the value is `some x`, and if\nboth are `none`, then the value is `none`.\n\nExamples:\n * `Option.merge (· + ·) none (some 3) = some 3`\n * `Option.merge (· + ·) (some 2) (some 3) = some 5`\n * `Option.merge (· + ·) (some 2) none = some 2`\n * `Option.merge (· + ·) none none = none`\n</code>",
 "4915":
 "<code>Option.orElse.{u_1} {α : Type u_1} : Option α → (Unit → Option α) → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Implementation of `OrElse`'s `&lt;|&gt;` syntax for `Option`. If the first argument is `some a`, returns\n`some a`, otherwise evaluates and returns the second argument.\n\nSee also `or` for a version that is strict in the second argument.\n</code>",
 "4914":
 "<code>Option.recOn.{u_1, u} {α : Type u} {motive : Option α → Sort u_1} (t : Option α) (none : motive none)\n  (some : (val : α) → motive (some val)) : motive t</code>",
 "4913":
 "<code>Option.elim.{u_1, u_2} {α : Type u_1} {β : Sort u_2} : Option α → β → (α → β) → β</code><span class=\"sep\"></span><code class=\"docstring\">A case analysis function for `Option`.\n\nGiven a value for `none` and a function to apply to the contents of `some`, `Option.elim` checks\nwhich constructor a given `Option` consists of, and uses the appropriate argument.\n\n`Option.elim` is an elimination principle for `Option`. In particular, it is a non-dependent version\nof `Option.recOn`. It can also be seen as a combination of `Option.map` and `Option.getD`.\n\nExamples:\n * `(some \"hello\").elim 0 String.length = 5`\n * `none.elim 0 String.length = 0`\n</code>",
 "4912":
 "<code><span class=\"literal string\">\"goodbye\"</span> : String</code>",
 "4911":
 "<code>Option.isSome.{u_1} {α : Type u_1} : Option α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` on `some x` and `false` on `none`. </code>",
 "4910": "<code>getAlpha : IO (Option String)</code>",
 "491": "<code>Book</code>",
 "4909":
 "<code class=\"docstring\">`if let pat := d then t else e` is a shorthand syntax for:\n```\nmatch d with\n| pat =&gt; t\n| _ =&gt; e\n```\nIt matches `d` against the pattern `pat` and the bindings are available in `t`.\nIf the pattern does not match, it returns `e` instead.\n</code>",
 "4908":
 "<code><span class=\"literal string\">\"not found\"</span> : String</code>",
 "4907":
 "<code><span class=\"literal string\">\"Schenectady\"</span> : String</code>",
 "4906":
 "<code>Std.HashMap.emptyWithCapacity.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (capacity : Nat := 8) :\n  Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new empty hash map. The optional parameter `capacity` can be supplied to presize the\nmap so that it can hold the given number of mappings without reallocating. It is also possible to\nuse the empty collection notations `∅` and `{}` to create an empty hash map with the default\ncapacity.\n</code>",
 "4905":
 "<code>Std.HashMap.empty.{u_1, u_2} {α : Type u_1} {β : Type u_2} [BEq α] [Hashable α] (capacity : Nat := 8) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new empty hash map. The optional parameter `capacity` can be supplied to presize the\nmap so that it can hold the given number of mappings without reallocating. It is also possible to\nuse the empty collection notations `∅` and `{}` to create an empty hash map with the default\ncapacity.\n</code>",
 "4904": "<code>postalCodes : Std.HashMap Nat String</code>",
 "4903":
 "<code>Std.HashMap.get?.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : HashMap α β) (a : α) : Option β</code><span class=\"sep\"></span><code class=\"docstring\">The notation `m[a]?` is preferred over calling this function directly.\n\nTries to retrieve the mapping for the given key, returning `none` if no such mapping is present.\n</code>",
 "4902": "<code>HashMap α β</code>",
 "4901":
 "<code>Std.HashMap.get?.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α) :\n  Option β</code><span class=\"sep\"></span><code class=\"docstring\">The notation `m[a]?` is preferred over calling this function directly.\n\nTries to retrieve the mapping for the given key, returning `none` if no such mapping is present.\n</code>",
 "4900": "<code>c = false → α</code>",
 "490":
 "<code>Textbook.mk (toBook : Book) (discipline : String) : Textbook</code>",
 "49":
 "<code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Some value of type `α`. </code>",
 "4899": "<code>c = true → α</code>",
 "4898":
 "<code class=\"docstring\">mark definition to always be inlined before ANF conversion</code>",
 "4897": "<code>BIG_EXPENSIVE_COMPUTATION : Bool</code>",
 "4896":
 "<code>cond.{u} {α : Sort u} (c : Bool) (x y : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The conditional function.\n\n`cond c x y` is the same as `if c then x else y`, but optimized for a Boolean condition rather than\na decidable proposition. It can also be written using the notation `bif c then x else y`.\n\nJust like `ite`, `cond` is declared `@[macro_inline]`, which causes applications of `cond` to be\nunfolded. As a result, `x` and `y` are not evaluated at runtime until one of them is selected, and\nonly the selected branch is evaluated.\n</code>",
 "4895": "<code>Empty</code>",
 "4894": "<code>f.{u_1} {ε : Type u_1} (n : Nat) : Except ε Nat</code>",
 "4893": "<code>ProofUnitLike</code>",
 "4892": "<code>ProofUnitLike.mk : 2 = 2 → ProofUnitLike</code>",
 "4891": "<code>ProofUnitLike : Prop</code>",
 "4890": "<code>NotUnitLike</code>",
 "489": "<code>Textbook</code>",
 "4889": "<code>NotUnitLike.mk (u : Unit) : NotUnitLike</code>",
 "4888": "<code>NotUnitLike : Type</code>",
 "4887": "<code>WithParam 3</code>",
 "4886": "<code>WithParam.mk {n : Nat} : WithParam n</code>",
 "4885": "<code>WithParam (n : Nat) : Type</code>",
 "4884": "<code>AlsoUnit</code>",
 "4883": "<code>CustomUnit</code>",
 "4882": "<code>CustomUnit.customUnit : CustomUnit</code>",
 "4881": "<code>AlsoUnit : Type</code>",
 "4880": "<code>CustomUnit : Type</code>",
 "488": "<code>Textbook.toBook (self : Textbook) : Book</code>",
 "4879":
 "<code><span class=\"literal string\">\"\\x0d\\n\"</span> : String</code>",
 "4878": "<code>a.IsValidUTF8</code>",
 "4877": "<code>p &lt; s.endPos</code>",
 "4876":
 "<code><span class=\"literal string\">\"\\\"\\\\\\\"\\\"\"</span> : String</code>",
 "4875":
 "<code><span class=\"literal string\">\"\\\"abc\\\"\"</span> : String</code>",
 "4874":
 "<code>String.quote (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to its corresponding Lean string literal syntax. Double quotes are added to each\nend, and internal characters are escaped as needed.\n\nExamples:\n* `\"abc\".quote = \"\\\"abc\\\"\"`\n* `\"\\\"\".quote = \"\\\"\\\\\\\"\\\"\"`\n</code>",
 "4873":
 "<code>String.toName (s : String) : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to the Lean compiler's representation of names. The resulting name is\nhierarchical, and the string is split at the dots (`'.'`).\n\n`\"a.b\".toName` is the name `a.b`, not `«a.b»`. For the latter, use `Name.mkSimple`.\n</code>",
 "4872": "<code>p₀ ≤ pos</code>",
 "4871":
 "<code>String.Slice.replaceStart (s : String.Slice) (pos : s.Pos) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Given a slice and a valid position within the slice, obtain a new slice on the same underlying\nstring by replacing the start of the slice with the given position. </code>",
 "4870": "<code>(s.replaceStart p₀).Pos</code>",
 "487": "<code>AcademicWork.discipline (self : AcademicWork) : String</code>",
 "4869": "<code>s.toSlice.Pos</code>",
 "4868":
 "<code>String.Slice.Pos.prev {s : String.Slice} (pos : s.Pos) (h : pos ≠ s.startPos) : s.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the previous valid position before the given position, given a proof that the position\nis not the start position, which guarantees that such a position exists. </code>",
 "4867":
 "<code>String.Slice.startPos (s : String.Slice) : s.Pos</code><span class=\"sep\"></span><code class=\"docstring\">The start position of `s`, as an `s.Pos`. </code>",
 "4866": "<code>pos ≠ s.startPos</code>",
 "4865": "<code>pos ≠ s.endPos</code>",
 "4864":
 "<code>(s : String.Slice) → ρ → Option s.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the slice ends with the pattern\\. If it does, the slice is returned with the\n  suffix removed; otherwise the result is `none`\\.\n  </code>",
 "4863":
 "<code>String.Slice → ρ → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the slice ends with the pattern\\.\n  </code>",
 "4862":
 "<code>String.Slice.Pattern.BackwardPattern.mk {ρ : Type} (endsWith : String.Slice → ρ → Bool)\n  (dropSuffix? : (s : String.Slice) → ρ → Option s.Pos) : String.Slice.Pattern.BackwardPattern ρ</code>",
 "4861":
 "<code>(s : String.Slice) → ρ → Std.Iter (String.Slice.Pattern.SearchStep s)</code><span class=\"sep\"></span><code class=\"docstring\">Build an iterator of `SearchStep` corresponding to matches of `pat` along the slice\n  `s`\\. The `SearchStep`s returned by this iterator must contain ranges that are\n  adjacent, non\\-overlapping and cover all of `s`\\.\n  </code>",
 "4860":
 "<code>String.Slice.Pattern.ToBackwardSearcher.mk {ρ : Type} {σ : outParam (String.Slice → Type)}\n  (toSearcher : (s : String.Slice) → ρ → Std.Iter (String.Slice.Pattern.SearchStep s)) :\n  String.Slice.Pattern.ToBackwardSearcher ρ σ</code>",
 "486": "<code>AcademicWork.author (self : AcademicWork) : String</code>",
 "4859":
 "<code>(s : String.Slice) → ρ → Option s.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the slice starts with the pattern\\. If it does, the slice is returned with the\n  prefix removed; otherwise the result is `none`\\.\n  </code>",
 "4858":
 "<code>String.Slice → ρ → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the slice starts with the pattern\\.\n  </code>",
 "4857":
 "<code>String.Slice.Pattern.ForwardPattern.mk {ρ : Type} (startsWith : String.Slice → ρ → Bool)\n  (dropPrefix? : (s : String.Slice) → ρ → Option s.Pos) : String.Slice.Pattern.ForwardPattern ρ</code>",
 "4856":
 "<code>(s : String.Slice) → ρ → Std.Iter (String.Slice.Pattern.SearchStep s)</code><span class=\"sep\"></span><code class=\"docstring\">Builds an iterator of `SearchStep` corresponding to matches of `pat` along the slice\n  `s`\\. The `SearchStep`s returned by this iterator must contain ranges that are\n  adjacent, non\\-overlapping and cover all of `s`\\.\n  </code>",
 "4855":
 "<code>String.Slice.Pattern.ToForwardSearcher.mk {ρ : Type} {σ : outParam (String.Slice → Type)}\n  (toSearcher : (s : String.Slice) → ρ → Std.Iter (String.Slice.Pattern.SearchStep s)) :\n  String.Slice.Pattern.ToForwardSearcher ρ σ</code>",
 "4854": "<code>outParam (String.Slice → Type)</code>",
 "4853":
 "<code>String.Slice.toNat? (s : String.Slice) : Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a slice as the decimal representation of a natural number, returning it\\. Returns\n`none` if the slice does not contain a decimal natural number\\.\n\nA slice can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits\\.\n\nUse `isNat` to check whether `toNat?` would return `some`\\.\n`toNat!` is an alternative that panics instead of\nreturning `none` when the slice is not a natural number\\.\n\nExamples:\n\n* `\"\".toSlice.toNat? = none`\n\n* `\"0\".toSlice.toNat? = some 0`\n\n* `\"5\".toSlice.toNat? = some 5`\n\n* `\"587\".toSlice.toNat? = some 587`\n\n* `\"-587\".toSlice.toNat? = none`\n\n* `\" 5\".toSlice.toNat? = none`\n\n* `\"2+3\".toSlice.toNat? = none`\n\n* `\"0xff\".toSlice.toNat? = none`\n  </code>",
 "4852":
 "<code>String.Slice.toNat! (s : String.Slice) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a slice as the decimal representation of a natural number, returning it\\. Panics if the\nslice does not contain a decimal natural number\\.\n\nA slice can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits\\.\n\nUse `isNat` to check whether `toNat!` would return a value\\. `toNat?` is a safer\nalternative that returns `none` instead of panicking when the string is not a natural number\\.\n\nExamples:\n\n* `\"0\".toSlice.toNat! = 0`\n\n* `\"5\".toSlice.toNat! = 5`\n\n* `\"587\".toSlice.toNat! = 587`\n  </code>",
 "4851":
 "<code>String.Slice.isNat (s : String.Slice) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the slice can be interpreted as the decimal representation of a natural number\\.\n\nA slice can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits\\.\n\nUse `toNat?` or\n`toNat!` to convert such a slice to a natural number\\.\n\nExamples:\n\n* `\"\".toSlice.isNat = false`\n\n* `\"0\".toSlice.isNat = true`\n\n* `\"5\".toSlice.isNat = true`\n\n* `\"05\".toSlice.isNat = true`\n\n* `\"587\".toSlice.isNat = true`\n\n* `\"-587\".toSlice.isNat = false`\n\n* `\" 5\".toSlice.isNat = false`\n\n* `\"2+3\".toSlice.isNat = false`\n\n* `\"0xff\".toSlice.isNat = false`\n  </code>",
 "4850":
 "<code><span class=\"literal string\">\"retaw aet eeffoc\"</span> : String</code>",
 "485": "<code>Book.author (self : Book) : String</code>",
 "4849":
 "<code>String.Slice.foldr.{u} {α : Type u} (f : Char → α → α) (init : α) (s : String.Slice) : α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a slice from the end, accumulating a value starting with `init`\\. The\naccumulated value is combined with each character in reverse order, using `f`\\.\n\nExamples:\n\n* `\"coffee tea water\".toSlice.foldr (fun c n =&gt; if c.isWhitespace then n + 1 else n) 0 = 2`\n\n* `\"coffee tea and water\".toSlice.foldr (fun c n =&gt; if c.isWhitespace then n + 1 else n) 0 = 3`\n\n* `\"coffee tea water\".toSlice.foldr (fun c s =&gt; s.push c) \"\" = \"retaw aet eeffoc\"`\n  </code>",
 "4848":
 "<code>String.Slice.foldl.{u} {α : Type u} (f : α → Char → α) (init : α) (s : String.Slice) : α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a slice from the start, accumulating a value starting with `init`\\. The\naccumulated value is combined with each character in order, using `f`\\.\n\nExamples:\n\n* `\"coffee tea water\".toSlice.foldl (fun n c =&gt; if c.isWhitespace then n + 1 else n) 0 = 2`\n\n* `\"coffee tea and water\".toSlice.foldl (fun n c =&gt; if c.isWhitespace then n + 1 else n) 0 = 3`\n\n* `\"coffee tea water\".toSlice.foldl (·.push ·) \"\" = \"coffee tea water\"`\n  </code>",
 "4847":
 "<code>String.Slice.revSplit {σ : String.Slice → Type} {ρ : Type} [String.Slice.Pattern.ToBackwardSearcher ρ σ]\n  (s : String.Slice) (pat : ρ) : Std.Iter String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Splits a slice at each subslice that matches the pattern `pat`, starting from the end of the\nslice and traversing towards the start\\.\n\nThe subslices that matched the pattern are not included in any of the resulting subslices\\. If\nmultiple subslices in a row match the pattern, the resulting list will contain empty slices\\.\n\nThis function is generic over all currently supported patterns except\n`String`/`String.Slice`\\.\n\nExamples:\n\n* `(\"coffee tea water\".toSlice.revSplit Char.isWhitespace).allowNontermination.toList == [\"water\".toSlice, \"tea\".toSlice, \"coffee\".toSlice]`\n\n* `(\"coffee tea water\".toSlice.revSplit ' ').allowNontermination.toList == [\"water\".toSlice, \"tea\".toSlice, \"coffee\".toSlice]`\n  </code>",
 "4846":
 "<code>String.Slice.revBytes (s : String.Slice) : Std.Iter UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator over all bytes in {name}`s`, starting from the last one and iterating towards\nthe first one.\n\nExamples:\n * {lean}`\"abc\".toSlice.revBytes.toList = [99, 98, 97]`\n * {lean}`\"ab∀c\".toSlice.revBytes.toList = [99, 128, 136, 226, 98, 97]`\n</code>",
 "4845":
 "<code>String.Slice.bytes (s : String.Slice) : Std.Iter UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator over all bytes in {name}`s`.\n\nExamples:\n* {lean}`\"abc\".toSlice.bytes.toList = [97, 98, 99]`\n* {lean}`\"ab∀c\".toSlice.bytes.toList = [97, 98, 226, 136, 128, 99]`\n</code>",
 "4844":
 "<code>String.Slice.revPositions (s : String.Slice) : Std.Iter { p // p ≠ s.endPos }</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator over all valid positions within {name}`s`, starting from the last valid\nposition and iterating towards the first one.\n\nExamples\n * {lean}`(\"abc\".toSlice.revPositions.map (fun ⟨p, h⟩ =&gt; p.get h) |&gt;.toList) = ['c', 'b', 'a']`\n * {lean}`(\"abc\".toSlice.revPositions.map (·.val.offset.byteIdx) |&gt;.toList) = [2, 1, 0]`\n * {lean}`(\"ab∀c\".toSlice.revPositions.map (fun ⟨p, h⟩ =&gt; p.get h) |&gt;.toList) = ['c', '∀', 'b', 'a']`\n * {lean}`(\"ab∀c\".toSlice.revPositions.map (·.val.offset.byteIdx) |&gt;.toList) = [5, 2, 1, 0]`\n</code>",
 "4843": "<code>p ≠ \"ab∀c\".toSlice.endPos</code>",
 "4842": "<code>\"ab∀c\".toSlice.Pos</code>",
 "4841":
 "<code>String.Pos.Raw.byteIdx (self : String.Pos.Raw) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Get the underlying byte index of a `String.Pos.Raw` </code>",
 "4840":
 "<code>String.Slice.Pos.get {s : String.Slice} (pos : s.Pos) (h : pos ≠ s.endPos) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Obtains the character at the given position in the string. </code>",
 "484": "<code>Book.title (self : Book) : String</code>",
 "4839": "<code>p ≠ \"abc\".toSlice.endPos</code>",
 "4838": "<code>\"abc\".toSlice.Pos</code>",
 "4837":
 "<code>Std.Iterators.Iter.map.{w} {α β γ : Type w} [Std.Iterators.Iterator α Id β] (f : β → γ) (it : Std.Iter β) : Std.Iter γ</code><span class=\"sep\"></span><code class=\"docstring\">If `it` is an iterator, then `it.map f` is another iterator that applies a\nfunction `f` to all values emitted by `it` and emits the result.\n\nIn situations where `f` is monadic, use `mapM` instead.\n\n**Marble diagram:**\n\n```text\nit         ---a --b --c --d -e ----⊥\nit.map     ---a'--b'--c'--d'-e'----⊥\n```\n\n(given that `f a = a'`, `f b = b'` etc.)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is productive\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f`.\n</code>",
 "4836":
 "<code>String.Slice.positions (s : String.Slice) : Std.Iter { p // p ≠ s.endPos }</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator over all valid positions within {name}`s`.\n\nExamples\n* {lean}`(\"abc\".toSlice.positions.map (fun ⟨p, h⟩ =&gt; p.get h) |&gt;.toList) = ['a', 'b', 'c']`\n* {lean}`(\"abc\".toSlice.positions.map (·.val.offset.byteIdx) |&gt;.toList) = [0, 1, 2]`\n* {lean}`(\"ab∀c\".toSlice.positions.map (fun ⟨p, h⟩ =&gt; p.get h) |&gt;.toList) = ['a', 'b', '∀', 'c']`\n* {lean}`(\"ab∀c\".toSlice.positions.map (·.val.offset.byteIdx) |&gt;.toList) = [0, 1, 2, 5]`\n</code>",
 "4835":
 "<code>String.Slice.endPos (s : String.Slice) : s.Pos</code><span class=\"sep\"></span><code class=\"docstring\">The past-the-end position of `s`, as an `s.Pos`. </code>",
 "4834":
 "<code>String.Slice.revChars (s : String.Slice) : Std.Iter Char</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator over all characters \\(Unicode code points\\) in `s`, starting from the end\nof the slice and iterating towards the start\\.\n\nExample:\n\n* `\"abc\".toSlice.revChars.toList = ['c', 'b', 'a']`\n\n* `\"ab∀c\".toSlice.revChars.toList = ['c', '∀', 'b', 'a']`\n  </code>",
 "4833": "<code><span class=\"literal string\">\"ab∀c\"</span> : String</code>",
 "4832":
 "<code>Std.Iterators.Iter.toList.{w} {α β : Type w} [Std.Iterators.Iterator α Id β] [Std.Iterators.Finite α Id]\n  [Std.Iterators.IteratorCollect α Id Id] (it : Std.Iter β) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Traverses the given iterator and stores the emitted values in a list. Because\nlists are prepend-only, `toListRev` is usually more efficient that `toList`.\n\nThis function requires a `Finite` instance proving that the iterator will finish after a finite\nnumber of steps. If the iterator is not finite or such an instance is not available, consider using\n`it.allowNontermination.toList` instead of `it.toList`. However, it is not possible to\nformally verify the behavior of the partial variant.\n</code>",
 "4831":
 "<code>String.Slice.chars (s : String.Slice) : Std.Iter Char</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator over all characters \\(Unicode code points\\) in `s`\\.\n\nExamples:\n\n* `\"abc\".toSlice.chars.toList = ['a', 'b', 'c']`\n\n* `\"ab∀c\".toSlice.chars.toList = ['a', 'b', '∀', 'c']`\n  </code>",
 "4830":
 "<code>String.Slice.trimAsciiStart (s : String.Slice) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Removes leading whitespace from a slice by moving its start position to the first non\\-whitespace\ncharacter, or to its end position if there is no non\\-whitespace character\\.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`\\.\n\nExamples:\n\n* `\"abc\".toSlice.trimAsciiStart == \"abc\".toSlice`\n\n* `\"   abc\".toSlice.trimAsciiStart == \"abc\".toSlice`\n\n* `\"abc \\t  \".toSlice.trimAsciiStart == \"abc \\t  \".toSlice`\n\n* `\"  abc   \".toSlice.trimAsciiStart == \"abc   \".toSlice`\n\n* `\"abc\\ndef\\n\".toSlice.trimAsciiStart == \"abc\\ndef\\n\".toSlice`\n  </code>",
 "483": "<code>AcademicWork : Type</code>",
 "4829":
 "<code>String.Slice.trimAsciiEnd (s : String.Slice) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Removes trailing whitespace from a slice by moving its start position to the first non\\-whitespace\ncharacter, or to its end position if there is no non\\-whitespace character\\.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`\\.\n\nExamples:\n\n* `\"abc\".toSlice.trimAsciiEnd == \"abc\".toSlice`\n\n* `\"   abc\".toSlice.trimAsciiEnd == \"   abc\".toSlice`\n\n* `\"abc \\t  \".toSlice.trimAsciiEnd == \"abc\".toSlice`\n\n* `\"  abc   \".toSlice.trimAsciiEnd == \"  abc\".toSlice`\n\n* `\"abc\\ndef\\n\".toSlice.trimAsciiEnd == \"abc\\ndef\".toSlice`\n  </code>",
 "4828":
 "<code>String.Slice.trimAscii (s : String.Slice) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Removes leading and trailing whitespace from a slice\\.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`\\.\n\nExamples:\n\n* `\"abc\".toSlice.trimAscii == \"abc\".toSlice`\n\n* `\"   abc\".toSlice.trimAscii == \"abc\".toSlice`\n\n* `\"abc \\t  \".toSlice.trimAscii == \"abc\".toSlice`\n\n* `\"  abc   \".toSlice.trimAscii == \"abc\".toSlice`\n\n* `\"abc\\ndef\\n\".toSlice.trimAscii == \"abc\\ndef\".toSlice`\n  </code>",
 "4827":
 "<code><span class=\"literal string\">\"baz\\x0d\"</span> : String</code>",
 "4826":
 "<code><span class=\"literal string\">\"foo\\x0d\\nbar\\n\\nbaz\\x0d\"</span> : String</code>",
 "4825":
 "<code><span class=\"literal string\">\"foo\\x0d\\nbar\\n\\nbaz\"</span> : String</code>",
 "4824": "<code><span class=\"literal string\">\"baz\"</span> : String</code>",
 "4823": "<code><span class=\"literal string\">\"bar\"</span> : String</code>",
 "4822":
 "<code>String.Slice.lines (s : String.Slice) : Std.Iter String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator over all lines in `s` with the line ending characters `\\r\\n` or `\\n` being\nstripped\\.\n\nExamples:\n\n* `\"foo\\r\\nbar\\n\\nbaz\\n\".toSlice.lines.allowNontermination.toList  == [\"foo\".toSlice, \"bar\".toSlice, \"\".toSlice, \"baz\".toSlice]`\n\n* `\"foo\\r\\nbar\\n\\nbaz\".toSlice.lines.allowNontermination.toList  == [\"foo\".toSlice, \"bar\".toSlice, \"\".toSlice, \"baz\".toSlice]`\n\n* `\"foo\\r\\nbar\\n\\nbaz\\r\".toSlice.lines.allowNontermination.toList  == [\"foo\".toSlice, \"bar\".toSlice, \"\".toSlice, \"baz\\r\".toSlice]`\n  </code>",
 "4821":
 "<code><span class=\"literal string\">\"foo\\x0d\\nbar\\n\\nbaz\\n\"</span> : String</code>",
 "4820": "<code><span class=\"literal string\">\"baa\"</span> : String</code>",
 "482": "<code>Book : Type</code>",
 "4819":
 "<code><span class=\"literal string\">\"coffee tea \"</span> : String</code>",
 "4818": "<code><span class=\"literal string\">\"tea \"</span> : String</code>",
 "4817":
 "<code><span class=\"literal string\">\"coffee \"</span> : String</code>",
 "4816":
 "<code>String.Slice.splitInclusive {ρ : Type} {σ : String.Slice → Type} [String.Slice.Pattern.ToForwardSearcher ρ σ]\n  (s : String.Slice) (pat : ρ) : Std.Iter String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Splits a slice at each subslice that matches the pattern `pat`\\. Unlike `split` the\nmatched subslices are included at the end of each subslice\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `(\"coffee tea water\".toSlice.splitInclusive Char.isWhitespace).allowNontermination.toList == [\"coffee \".toSlice, \"tea \".toSlice, \"water\".toSlice]`\n\n* `(\"coffee tea water\".toSlice.splitInclusive ' ').allowNontermination.toList == [\"coffee \".toSlice, \"tea \".toSlice, \"water\".toSlice]`\n\n* `(\"coffee tea water\".toSlice.splitInclusive \" tea \").allowNontermination.toList == [\"coffee tea \".toSlice, \"water\".toSlice]`\n\n* `(\"baaab\".toSlice.splitInclusive \"aa\").allowNontermination.toList == [\"baa\".toSlice, \"ab\".toSlice]`\n  </code>",
 "4815": "<code><span class=\"literal string\">\"ab\"</span> : String</code>",
 "4814":
 "<code><span class=\"literal string\">\"baaab\"</span> : String</code>",
 "4813":
 "<code><span class=\"literal string\">\"ababababa\"</span> : String</code>",
 "4812":
 "<code><span class=\"literal string\">\" tea \"</span> : String</code>",
 "4811":
 "<code>Std.Iterators.Iter.Partial.toList.{w} {α β : Type w} [Std.Iterators.Iterator α Id β]\n  [Std.Iterators.IteratorCollectPartial α Id Id] (it : Std.Iterators.Iter.Partial β) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Traverses the given iterator and stores the emitted values in a list. Because\nlists are prepend-only, `toListRev` is usually more efficient that `toList`.\n\nThis is a partial, potentially nonterminating, function. It is not possible to formally verify\nits behavior. If the iterator has a `Finite` instance, consider using `IterM.toList` instead.\n</code>",
 "4810":
 "<code>Std.Iterators.Iter.allowNontermination.{w} {α β : Type w} (it : Std.Iter β) : Std.Iterators.Iter.Partial β</code><span class=\"sep\"></span><code class=\"docstring\">For an iterator `it`, `it.allowNontermination` provides potentially nonterminating variants of\nconsumers such as `toList`. They can be used without any proof of termination such as `Finite`\nor `Productive`, but as they are implemented with the `partial` declaration modifier, they are\nopaque for the kernel and it is impossible to prove anything about them.\n</code>",
 "481": "<code>Textbook : Type</code>",
 "4809":
 "<code>String.Slice.split {ρ : Type} {σ : String.Slice → Type} [String.Slice.Pattern.ToForwardSearcher ρ σ] (s : String.Slice)\n  (pat : ρ) : Std.Iter String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Splits a slice at each subslice that matches the pattern `pat`\\.\n\nThe subslices that matched the pattern are not included in any of the resulting subslices\\. If\nmultiple subslices in a row match the pattern, the resulting list will contain empty strings\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `(\"coffee tea water\".toSlice.split Char.isWhitespace).allowNontermination.toList == [\"coffee\".toSlice, \"tea\".toSlice, \"water\".toSlice]`\n\n* `(\"coffee tea water\".toSlice.split ' ').allowNontermination.toList == [\"coffee\".toSlice, \"tea\".toSlice, \"water\".toSlice]`\n\n* `(\"coffee tea water\".toSlice.split \" tea \").allowNontermination.toList == [\"coffee\".toSlice, \"water\".toSlice]`\n\n* `(\"ababababa\".toSlice.split \"aba\").allowNontermination.toList == [\"coffee\".toSlice, \"water\".toSlice]`\n\n* `(\"baaab\".toSlice.split \"aa\").allowNontermination.toList == [\"b\".toSlice, \"ab\".toSlice]`\n  </code>",
 "4808":
 "<code>Std.Iterators.Iter.{w} {α : Type w} (β : Type w) : Type w</code><span class=\"sep\"></span><code class=\"docstring\">An iterator that sequentially emits values of type `β`. It may be finite\nor infinite.\n\nSee the root module `Std.Data.Iterators` for a more comprehensive overview over the iterator\nframework.\n\nSee `Std.Data.Iterators.Producers` for ways to iterate over common data structures.\nBy convention, the monadic iterator associated with an object can be obtained via dot notation.\nFor example, `List.iterM IO` creates an iterator over a list in the monad `IO`.\n\nSee `Init.Data.Iterators.Consumers` for ways to use an iterator. For example, `it.toList` will\nconvert a provably finite iterator `it` into a list and `it.allowNontermination.toList` will\ndo so even if finiteness cannot be proved. It is also always possible to manually iterate using\n`it.step`, relying on the termination measures `it.finitelyManySteps` and `it.finitelyManySkips`.\n\nSee `IterM` for iterators that operate in a monad.\n\nInternally, `Iter β` wraps an element of type `α` containing state information.\nThe type `α` determines the implementation of the iterator using a typeclass mechanism.\nThe concrete typeclass implementing the iterator is `Iterator α m β`.\n\nWhen using combinators, `α` can become very complicated. It is an implicit parameter\nof `α` so that the pretty printer will not print this large type by default. If a declaration\nreturns an iterator, the following will not work:\n\n```lean\ndef x : Iter Nat := [1, 2, 3].iter\n```\n\nInstead the declaration type needs to be completely omitted:\n\n```lean\ndef x := [1, 2, 3].iter\n\n-- if you want to ensure that `x` is an iterator emitting `Nat`\ndef x := ([1, 2, 3].iter : Iter Nat)\n```\n</code>",
 "4807":
 "<code>String.Slice.Pattern.ToBackwardSearcher (ρ : Type) (σ : outParam (String.Slice → Type)) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Provides a conversion from a pattern to an iterator of `SearchStep` searching for matches of\nthe pattern from the end towards the start of a `Slice`\\.\n</code>",
 "4806":
 "<code>String.Slice.Pos.get! {s : String.Slice} (pos : s.Pos) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the byte at the given position in the string, or panicks if the position is the end\nposition. </code>",
 "4805":
 "<code>Option.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) : Option α → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Apply a function to an optional value, if present.\n\nFrom the perspective of `Option` as a container with at most one value, this is analogous to\n`List.map`. It can also be accessed via the `Functor Option` instance.\n\nExamples:\n * `(none : Option Nat).map (· + 1) = none`\n * `(some 3).map (· + 1) = some 4`\n</code>",
 "4804":
 "<code>String.Slice.find? {ρ : Type} {σ : String.Slice → Type}\n  [(s : String.Slice) → Std.Iterators.Iterator (σ s) Id (String.Slice.Pattern.SearchStep s)]\n  [∀ (s : String.Slice), Std.Iterators.Finite (σ s) Id] [String.Slice.Pattern.ToForwardSearcher ρ σ] (s : String.Slice)\n  (pat : ρ) : Option s.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Finds the position of the first match of the pattern `pat` in a slice `true`\\. If there\nis no match `none` is returned\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `(\"coffee tea water\".toSlice.find? Char.isWhitespace).map (·.get!) == some ' '`\n\n* `\"tea\".toSlice.find? (fun (c : Char) =&gt; c == 'X') == none`\n\n* `(\"coffee tea water\".toSlice.find? \"tea\").map (·.get!) == some 't'`\n  </code>",
 "4803": "<code><span class=\"literal string\">\"aa\"</span> : String</code>",
 "4802":
 "<code><span class=\"literal string\">\"aaaaaa\"</span> : String</code>",
 "4801":
 "<code>String.Slice.all {ρ : Type} [String.Slice.Pattern.ForwardPattern ρ] (s : String.Slice) (pat : ρ) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a slice only consists of matches of the pattern `pat` anywhere\\.\n\nShort\\-circuits at the first pattern mis\\-match\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"brown\".toSlice.all Char.isLower = true`\n\n* `\"brown and orange\".toSlice.all Char.isLower = false`\n\n* `\"aaaaaa\".toSlice.all 'a' = true`\n\n* `\"aaaaaa\".toSlice.all \"aa\" = true`\n  </code>",
 "4800":
 "<code>String.Slice.endsWith {ρ : Type} [String.Slice.Pattern.BackwardPattern ρ] (s : String.Slice) (pat : ρ) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the slice \\(`s`\\) ends with the pattern \\(`pat`\\)\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.endsWith \"blue\" = true`\n\n* `\"red green blue\".toSlice.endsWith \"green\" = false`\n\n* `\"red green blue\".toSlice.endsWith \"\" = true`\n\n* `\"red green blue\".toSlice.endsWith 'e' = true`\n\n* `\"red green blue\".toSlice.endsWith Char.isLower = true`\n  </code>",
 "480":
 "<code>Float</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "48": "<code>α</code>",
 "4799":
 "<code>String.Slice.startsWith {ρ : Type} [String.Slice.Pattern.ForwardPattern ρ] (s : String.Slice) (pat : ρ) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the slice \\(`s`\\) begins with the pattern \\(`pat`\\)\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.startsWith \"red\" = true`\n\n* `\"red green blue\".toSlice.startsWith \"green\" = false`\n\n* `\"red green blue\".toSlice.startsWith \"\" = true`\n\n* `\"red green blue\".toSlice.startsWith 'r' = true`\n\n* `\"red green blue\".toSlice.startsWith Char.isLower = true`\n  </code>",
 "4798":
 "<code>String.Slice.contains {ρ : Type} {σ : String.Slice → Type}\n  [(s : String.Slice) → Std.Iterators.Iterator (σ s) Id (String.Slice.Pattern.SearchStep s)]\n  [∀ (s : String.Slice), Std.Iterators.Finite (σ s) Id] [String.Slice.Pattern.ToForwardSearcher ρ σ] (s : String.Slice)\n  (pat : ρ) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a slice has a match of the pattern `pat` anywhere\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"coffee tea water\".toSlice.contains Char.isWhitespace = true`\n\n* `\"tea\".toSlice.contains (fun (c : Char) =&gt; c == 'X') = false`\n\n* `\"coffee tea water\".toSlice.contains \"tea\" = true`\n  </code>",
 "4797":
 "<code>String.Slice.Pattern.ToForwardSearcher (ρ : Type) (σ : outParam (String.Slice → Type)) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Provides a conversion from a pattern to an iterator of `SearchStep` that searches for matches\nof the pattern from the start towards the end of a `Slice`\\.\n</code>",
 "4796":
 "<code>Std.Iterators.Finite.{w, w'} (α : Type w) (m : Type w → Type w') {β : Type w} [Std.Iterators.Iterator α m β] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Finite α m` asserts that `IterM (α := α) m` terminates after finitely many steps. Technically,\nthis means that the relation of plausible successors is well-founded.\nGiven this typeclass, termination proofs for well-founded recursion over an iterator `it` can use\n`it.finitelyManySteps` as a termination measure.\n</code>",
 "4795":
 "<code>String.Slice.Pattern.SearchStep (s : String.Slice) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A step taken during the traversal of a `Slice` by a forward or backward searcher\\.\n</code>",
 "4794":
 "<code>Std.Iterators.Iterator.{w, w'} (α : Type w) (m : Type w → Type w') (β : outParam (Type w)) : Type (max w w')</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass providing the step function of an iterator in `Iter (α := α) β` or\n`IterM (α := α) m β`.\n\nIn order to allow intrinsic termination proofs when iterating with the `step` function, the\nstep object is bundled with a proof that it is a \"plausible\" step for the given current iterator.\n</code>",
 "4793": "<code>String.Slice → Type</code>",
 "4792": "<code>offset &lt; s.rawEndPos</code>",
 "4791":
 "<code>String.Slice.rawEndPos (s : String.Slice) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The end position of a slice, as a `Pos.Raw`. </code>",
 "4790": "<code>p &lt; s.rawEndPos</code>",
 "479":
 "<code>Float</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "4789":
 "<code>String.Slice.back? (s : String.Slice) : Option Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last character in `s`\\. If `s` is empty, returns `none`\\.\n\nExamples:\n\n* `\"abc\".toSlice.back? = some 'c'`\n\n* `\"\".toSlice.back? = none`\n  </code>",
 "4788":
 "<code>String.Slice.back (s : String.Slice) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last character in `s`\\. If `s` is empty, returns `(default : Char)`\\.\n\nExamples:\n\n* `\"abc\".toSlice.back = 'c'`\n\n* `\"\".toSlice.back = (default : Char)`\n  </code>",
 "4787":
 "<code>String.Slice.front? (s : String.Slice) : Option Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first character in `s`\\. If `s` is empty, `none`\\.\n\nExamples:\n\n* `\"abc\".toSlice.front? = some 'a'`\n\n* `\"\".toSlice.front? = none`\n  </code>",
 "4786":
 "<code>String.Slice.front (s : String.Slice) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first character in `s`\\. If `s` is empty, returns `(default : Char)`\\.\n\nExamples:\n\n* `\"abc\".toSlice.front = 'a'`\n\n* `\"\".toSlice.front = (default : Char)`\n  </code>",
 "4785":
 "<code><span class=\"literal string\">\"red red \"</span> : String</code>",
 "4784":
 "<code>String.Slice.takeWhile {ρ : Type} [String.Slice.Pattern.ForwardPattern ρ] (s : String.Slice) (pat : ρ) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new slice that contains the longest prefix of `s` for which `pat` matched\n\\(potentially repeatedly\\)\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.takeWhile Char.isLower == \"red\".toSlice`\n\n* `\"red green blue\".toSlice.takeWhile 'r' == \"r\".toSlice`\n\n* `\"red red green blue\".toSlice.takeWhile \"red \" == \"red red \".toSlice`\n\n* `\"red green blue\".toSlice.takeWhile (fun (_ : Char) =&gt; true) == \"red green blue\".toSlice`\n  </code>",
 "4783":
 "<code>String.Slice.takeEndWhile {ρ : Type} [String.Slice.Pattern.BackwardPattern ρ] (s : String.Slice) (pat : ρ) :\n  String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new slice that contains the suffix prefix of `s` for which `pat` matched\n\\(potentially repeatedly\\)\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.takeEndWhile Char.isLower == \"blue\".toSlice`\n\n* `\"red green blue\".toSlice.takeEndWhile 'e' == \"e\".toSlice`\n\n* `\"red green blue\".toSlice.takeEndWhile (fun (_ : Char) =&gt; true) == \"red green blue\".toSlice`\n  </code>",
 "4782":
 "<code>String.Slice.takeEnd (s : String.Slice) (n : Nat) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new slice that contains the last `n` characters \\(Unicode code points\\) of `s`\\.\n\nIf `n` is greater than the amount of characters in `s`, returns `s`\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.takeEnd 4 == \"blue\".toSlice`\n\n* `\"red green blue\".toSlice.takeEnd 1 == \"e\".toSlice`\n\n* `\"red green blue\".toSlice.takeEnd 0 == \"\".toSlice`\n\n* `\"red green blue\".toSlice.takeEnd 100 == \"red green blue\".toSlice`\n  </code>",
 "4781":
 "<code>String.Slice.take (s : String.Slice) (n : Nat) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new slice that contains the first `n` characters \\(Unicode code points\\) of `s`\\.\n\nIf `n` is greater than the amount of characters in `s`, returns `s`\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.take 3 == \"red\".toSlice`\n\n* `\"red green blue\".toSlice.take 1 == \"r\".toSlice`\n\n* `\"red green blue\".toSlice.take 0 == \"\".toSlice`\n\n* `\"red green blue\".toSlice.take 100 == \"red green blue\".toSlice`\n  </code>",
 "4780":
 "<code><span class=\"literal string\">\"red red green blue\"</span> : String</code>",
 "478":
 "<code>Float : Type</code><span class=\"sep\"></span><code class=\"docstring\">64-bit floating-point numbers.\n\n`Float` corresponds to the IEEE 754 *binary64* format (`double` in C or `f64` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of “not a number” values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n</code>",
 "4779":
 "<code>String.Slice.dropWhile {ρ : Type} [String.Slice.Pattern.ForwardPattern ρ] (s : String.Slice) (pat : ρ) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new slice that contains the longest prefix of `s` for which `pat` matched\n\\(potentially repeatedly\\)\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.dropWhile Char.isLower == \" green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropWhile 'r' == \"ed green blue\".toSlice`\n\n* `\"red red green blue\".toSlice.dropWhile \"red \" == \"green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropWhile (fun (_ : Char) =&gt; true) == \"\".toSlice`\n  </code>",
 "4778":
 "<code><span class=\"literal string\">\"bluu \"</span> : String</code>",
 "4777":
 "<code>String.Slice.dropSuffix {ρ : Type} [String.Slice.Pattern.BackwardPattern ρ] (s : String.Slice) (pat : ρ) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">If `pat` matches a suffix of `s`, returns the remainder\\. Returns `s` unmodified\notherwise\\.\n\nUse `String.Slice.dropSuffix?` to return `none` when `pat` does not match a\nprefix\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.dropSuffix \" blue\" == \"red green\".toSlice`\n\n* `\"red green blue\".toSlice.dropSuffix \"bluu \" == \"red green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropSuffix 'e' == \"red green blu\".toSlice`\n\n* `\"red green blue\".toSlice.dropSuffix Char.isLower == \"red green blu\".toSlice`\n  </code>",
 "4776":
 "<code>String.Slice.dropSuffix? {ρ : Type} [String.Slice.Pattern.BackwardPattern ρ] (s : String.Slice) (pat : ρ) :\n  Option String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">If `pat` matches a suffix of `s`, returns the remainder\\. Returns `none` otherwise\\.\n\nUse `String.Slice.dropSuffix` to return the slice\nunchanged when `pat` does not match a prefix\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.dropSuffix? \" blue\" == some \"red green\".toSlice`\n\n* `\"red green blue\".toSlice.dropSuffix? \"bluu \" == none`\n\n* `\"red green blue\".toSlice.dropSuffix? 'e' == some \"red green blu\".toSlice`\n\n* `\"red green blue\".toSlice.dropSuffix? Char.isLower == some \"red green blu\".toSlice`\n  </code>",
 "4775":
 "<code>String.Slice.dropPrefix {ρ : Type} [String.Slice.Pattern.ForwardPattern ρ] (s : String.Slice) (pat : ρ) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">If `pat` matches a prefix of `s`, returns the remainder\\. Returns `s` unmodified\notherwise\\.\n\nUse `String.Slice.dropPrefix?` to return `none` when `pat` does not match a prefix\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.dropPrefix \"red \" == \"green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropPrefix \"reed \" == \"red green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropPrefix 'r' == \"ed green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropPrefix Char.isLower == \"ed green blue\".toSlice`\n  </code>",
 "4774":
 "<code>String.Slice.dropPrefix? {ρ : Type} [String.Slice.Pattern.ForwardPattern ρ] (s : String.Slice) (pat : ρ) :\n  Option String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">If `pat` matches a prefix of `s`, returns the remainder\\. Returns `none` otherwise\\.\n\nUse `String.Slice.dropPrefix` to return the slice\nunchanged when `pat` does not match a prefix\\.\n\nThis function is generic over all currently supported patterns\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.dropPrefix? \"red \" == some \"green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropPrefix? \"reed \" == none`\n\n* `\"red green blue\".toSlice.dropPrefix? 'r' == some \"ed green blue\".toSlice`\n\n* `\"red green blue\".toSlice.dropPrefix? Char.isLower == some \"ed green blue\".toSlice`\n  </code>",
 "4773":
 "<code>String.Slice.Pattern.ForwardPattern (ρ : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Provides simple pattern matching capabilities from the start of a `Slice`\\.\n\nWhile these operations can be implemented on top of `ToForwardSearcher` some patterns allow\nfor more efficient implementations\\. This class can be used to specialize for them\\. If there is no\nneed to specialize in this fashion, then\n`ForwardPattern.defaultImplementation` can be used\nto automatically derive an instance\\.\n</code>",
 "4772":
 "<code>Char.isLower (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is a lowercase ASCII letter.\n\nThe lowercase ASCII letters are the following: `abcdefghijklmnopqrstuvwxyz`.\n</code>",
 "4771":
 "<code>String.Slice.dropEndWhile {ρ : Type} [String.Slice.Pattern.BackwardPattern ρ] (s : String.Slice) (pat : ρ) :\n  String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new slice that contains the longest suffix of `s` for which `pat` matched\n\\(potentially repeatedly\\)\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.dropEndWhile Char.isLower == \"red green \".toSlice`\n\n* `\"red green blue\".toSlice.dropEndWhile 'e' == \"red green blu\".toSlice`\n\n* `\"red green blue\".toSlice.dropEndWhile (fun (_ : Char) =&gt; true) == \"\".toSlice`\n  </code>",
 "4770":
 "<code>String.Slice.Pattern.BackwardPattern (ρ : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Provides simple pattern matching capabilities from the end of a `Slice`\\.\n\nWhile these operations can be implemented on top of `ToBackwardSearcher`, some patterns allow\nfor more efficient implementations\\. This class can be used to specialize for them\\. If there is no\nneed to specialize in this fashion, then\n`BackwardPattern.defaultImplementation` can be\nused to automatically derive an instance\\.\n</code>",
 "477": "<code>location : Float × Float</code>",
 "4769":
 "<code>String.Slice.dropEnd (s : String.Slice) (n : Nat) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Removes the specified number of characters \\(Unicode code points\\) from the end of the slice\\.\n\nIf `n` is greater than the amount of characters in `s`, returns an empty slice\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.dropEnd 5 == \"red green\".toSlice`\n\n* `\"red green blue\".toSlice.dropEnd 11 == \"red\".toSlice`\n\n* `\"red green blue\".toSlice.dropEnd 50 == \"\".toSlice`\n  </code>",
 "4768":
 "<code>String.Slice.drop (s : String.Slice) (n : Nat) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Removes the specified number of characters \\(Unicode code points\\) from the start of the slice\\.\n\nIf `n` is greater than the amount of characters in `s`, returns an empty slice\\.\n\nExamples:\n\n* `\"red green blue\".toSlice.drop 4 == \"green blue\".toSlice`\n\n* `\"red green blue\".toSlice.drop 10 == \"blue\".toSlice`\n\n* `\"red green blue\".toSlice.drop 50 == \"\".toSlice`\n  </code>",
 "4767": "<code>newStart.offset ≤ newEnd.offset</code>",
 "4766": "<code>String.Pos.Raw.IsValidForSlice s off</code>",
 "4765":
 "<code>String.Slice.isEmpty (s : String.Slice) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a slice is empty\\.\n\nEmpty slices have `utf8ByteSize` `0`\\.\n\nExamples:\n\n* `\"\".toSlice.isEmpty = true`\n\n* `\" \".toSlice.isEmpty = false`\n  </code>",
 "4764":
 "<code>String.Slice.Pos.offset {s : String.Slice} (self : s.Pos) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The underlying byte offset of the `Slice.Pos`. </code>",
 "4763": "<code>s.Pos</code>",
 "4762":
 "<code>String.Pos.Raw.IsValidForSlice (s : String.Slice) (p : String.Pos.Raw) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Criterion for validity of positions in string slices. </code>",
 "4761":
 "<code>String.Pos.Raw.IsValidForSlice s self.offset</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `offset` is valid for the string slice `s`. </code>",
 "4760":
 "<code>String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The underlying byte offset of the `Slice.Pos`. </code>",
 "476": "<code>two'' : AugmentedIntArray</code>",
 "4759":
 "<code>String.Slice.Pos.mk {s : String.Slice} (offset : String.Pos.Raw)\n  (isValidForSlice : String.Pos.Raw.IsValidForSlice s offset) : s.Pos</code>",
 "4758":
 "<code>String.Slice.endExclusive (self : String.Slice) : self.str.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the end of the string slice. </code>",
 "4757":
 "<code>String.Slice.startInclusive (self : String.Slice) : self.str.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the start of the string slice. </code>",
 "4756":
 "<code>self.startInclusive ≤ self.endExclusive</code><span class=\"sep\"></span><code class=\"docstring\">The slice is not degenerate (but it may be empty). </code>",
 "4755":
 "<code>self.str.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the end of the string slice. </code>",
 "4754":
 "<code>String.Slice.str (self : String.Slice) : String</code><span class=\"sep\"></span><code class=\"docstring\">The underlying strings. </code>",
 "4753":
 "<code>self.str.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the start of the string slice. </code>",
 "4752":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The underlying strings. </code>",
 "4751":
 "<code>String.Slice.mk (str : String) (startInclusive endExclusive : str.ValidPos)\n  (startInclusive_le_endExclusive : startInclusive ≤ endExclusive) : String.Slice</code>",
 "4750":
 "<code>Substring.toName (s : Substring) : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">Converts a substring to the Lean compiler's representation of names. The resulting name is\nhierarchical, and the string is split at the dots (`'.'`).\n\n`\"a.b\".toSubstring.toName` is the name `a.b`, not `«a.b»`. For the latter, use\n`Name.mkSimple ∘ Substring.toString`.\n</code>",
 "475": "<code>two' : AugmentedIntArray</code>",
 "4749": "<code><span class=\"literal string\">\"a.b\"</span> : String</code>",
 "4748":
 "<code>Substring.isNat (s : Substring) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the substring can be interpreted as the decimal representation of a natural number.\n\nA substring can be interpreted as a decimal natural number if it is not empty and all the characters\nin it are digits.\n\nUse `Substring.toNat?` to convert such a substring to a natural number.\n</code>",
 "4747":
 "<code>Substring.toNat? (s : Substring) : Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the substring can be interpreted as the decimal representation of a natural number,\nreturning the number if it can.\n\nA substring can be interpreted as a decimal natural number if it is not empty and all the characters\nin it are digits.\n\nUse `Substring.isNat` to check whether the substring is such a substring.\n</code>",
 "4746":
 "<code><span class=\"literal string\">\"     \"</span> : String</code>",
 "4745":
 "<code>Substring.stopPos (self : Substring) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the end of the string slice. </code>",
 "4744":
 "<code>Substring.startPos (self : Substring) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the start of the string slice. </code>",
 "4743":
 "<code>Substring.trim : Substring → Substring</code><span class=\"sep\"></span><code class=\"docstring\">Removes leading and trailing whitespace from a substring by first moving its start position to the\nfirst non-whitespace character, and then moving its end position to the last non-whitespace\ncharacter.\n\nIf the substring consists only of whitespace, then the resulting substring's start position is moved\nto its end position.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`.\n\nExamples:\n * `\" red green blue \".toSubstring.trim.toString = \"red green blue\"`\n * `\" red green blue \".toSubstring.trim.startPos = ⟨1⟩`\n * `\" red green blue \".toSubstring.trim.stopPos = ⟨15⟩`\n * `\"     \".toSubstring.trim.startPos = ⟨5⟩`\n</code>",
 "4742":
 "<code><span class=\"literal string\">\" red green blue \"</span> : String</code>",
 "4741":
 "<code>Substring.toString : Substring → String</code><span class=\"sep\"></span><code class=\"docstring\">Copies the region of the underlying string pointed to by a substring into a fresh string.\n</code>",
 "4740":
 "<code>Substring.bsize : Substring → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of bytes used by the string's UTF-8 encoding.\n</code>",
 "474": "<code>two : AugmentedIntArray</code>",
 "4739": "<code>Substring</code>",
 "4738":
 "<code>String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the end of the string slice. </code>",
 "4737":
 "<code>String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The byte position of the start of the string slice. </code>",
 "4736":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The underlying string. </code>",
 "4735":
 "<code>Substring.mk (str : String) (startPos stopPos : String.Pos.Raw) : Substring</code>",
 "4734":
 "<code>String.toSubstring (s : String) : Substring</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `String` into a `Substring` that denotes the entire string.\n</code>",
 "4733": "<code>α → Char → Option α</code>",
 "4732": "<code>it.hasNext = true</code>",
 "4731": "<code>String.Iterator</code>",
 "4730":
 "<code>String.Iterator.curr' (it : String.Iterator) (h : it.hasNext = true) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Gets the character at the iterator's current position.\n\nThe proof of `it.hasNext` ensures that there is, in fact, a character at the current position. This\nfunction is faster that `String.Iterator.curr` due to avoiding a run-time bounds check.\n</code>",
 "473": "<code>Array Int</code>",
 "4729":
 "<code>String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The current UTF-8 byte position in the string `s`.\n\nThis position is not guaranteed to be valid for the string. If the position is not valid, then the\ncurrent character is `(default : Char)`, similar to `String.get` on an invalid position.\n</code>",
 "4728":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The string being iterated over. </code>",
 "4727":
 "<code>String.Iterator.mk (s : String) (i : String.Pos.Raw) : String.Iterator</code>",
 "4726":
 "<code>String.iter (s : String) : String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator at the beginning of the string. </code>",
 "4725":
 "<code>String.Iterator.next : String.Iterator → String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Moves the iterator's position forward by one character, unconditionally.\n\nIt is only valid to call this function if the iterator is not at the end of the string (i.e.\nif `Iterator.atEnd` is `false`); otherwise, the resulting iterator will be invalid.\n</code>",
 "4724":
 "<code>String.Iterator.prev : String.Iterator → String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Moves the iterator's position backward by one character, unconditionally.\n\nThe position is not changed if the iterator is at the beginning of the string.\n</code>",
 "4723":
 "<code>String.Iterator.hasNext : String.Iterator → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the iterator is at or before the string's last character.\n</code>",
 "4722":
 "<code>String.Iterator.hasPrev : String.Iterator → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the iterator is after the beginning of the string.\n</code>",
 "4721":
 "<code>String.Iterator.setCurr : String.Iterator → Char → String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current character in the string.\n\nDoes nothing if the iterator is at the end of the string. If both the replacement character and the\nreplaced character are 7-bit ASCII characters and the string is not shared, then it is updated\nin-place and not copied.\n</code>",
 "4720":
 "<code>String.Iterator.curr : String.Iterator → Char</code><span class=\"sep\"></span><code class=\"docstring\">Gets the character at the iterator's current position.\n\nA run-time bounds check is performed. Use `String.Iterator.curr'` to avoid redundant bounds checks.\n\nIf the position is invalid, returns `(default : Char)`.\n</code>",
 "472": "<code>one : AugmentedIntArray</code>",
 "4719":
 "<code>String.Iterator : Type</code><span class=\"sep\"></span><code class=\"docstring\">An iterator over the characters (Unicode code points) in a `String`. Typically created by\n`String.iter`.\n\nString iterators pair a string with a valid byte index. This allows efficient character-by-character\nprocessing of strings while avoiding the need to manually ensure that byte indices are used with the\ncorrect strings.\n\nAn iterator is *valid* if the position `i` is *valid* for the string `s`, meaning `0 ≤ i ≤ s.endPos`\nand `i` lies on a UTF8 byte boundary. If `i = s.endPos`, the iterator is at the end of the string.\n\nMost operations on iterators return unspecified values if the iterator is not valid. The functions\nin the `String.Iterator` API rule out the creation of invalid iterators, with two exceptions:\n- `Iterator.next iter` is invalid if `iter` is already at the end of the string (`iter.atEnd` is\n  `true`), and\n- `Iterator.forward iter n`/`Iterator.nextn iter n` is invalid if `n` is strictly greater than the\n  number of remaining characters.\n</code>",
 "4718":
 "<code><span class=\"literal string\">\"ABc123\"</span> : String</code>",
 "4717":
 "<code>String.toLower (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces each character in `s` with the result of applying `Char.toLower` to it.\n\n`Char.toLower` has no effect on characters outside of the range `'A'`–`'Z'`.\n\nExamples:\n* `\"ORANGE\".toLower = \"orange\"`\n* `\"Orange\".toLower = \"orange\"`\n* `\"ABc123\".toLower = \"abc123\"`\n</code>",
 "4716":
 "<code>String.toUpper (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces each character in `s` with the result of applying `Char.toUpper` to it.\n\n`Char.toUpper` has no effect on characters outside of the range `'a'`–`'z'`.\n\nExamples:\n* `\"orange\".toUpper = \"ORANGE\"`\n* `\"abc123\".toUpper = \"ABC123\"`\n</code>",
 "4715":
 "<code><span class=\"literal string\">\"oRANGE\"</span> : String</code>",
 "4714":
 "<code>String.decapitalize (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first character in `s` with the result of applying `Char.toLower` to it. Returns the\nempty string if the string is empty.\n\n`Char.toLower` has no effect on characters outside of the range `'A'`–`'Z'`.\n\nExamples:\n* `\"Orange\".decapitalize = \"orange\"`\n* `\"ORANGE\".decapitalize = \"oRANGE\"`\n* `\"\".decapitalize = \"\"`\n</code>",
 "4713":
 "<code>Char.toLower (c : Char) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts an uppercase ASCII letter to the corresponding lowercase letter. Letters outside the ASCII\nalphabet are returned unchanged.\n\nThe uppercase ASCII letters are the following: `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n</code>",
 "4712":
 "<code><span class=\"literal string\">\"ORANGE\"</span> : String</code>",
 "4711":
 "<code><span class=\"literal string\">\"Orange\"</span> : String</code>",
 "4710":
 "<code>String.capitalize (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first character in `s` with the result of applying `Char.toUpper` to it. Returns the\nempty string if the string is empty.\n\n`Char.toUpper` has no effect on characters outside of the range `'a'`–`'z'`.\n\nExamples:\n* `\"orange\".capitalize = \"Orange\"`\n* `\"ORANGE\".capitalize = \"ORANGE\"`\n* `\"\".capitalize = \"\"`\n</code>",
 "471":
 "<code>AugmentedIntArray.augmentation (self : AugmentedIntArray) : String</code>",
 "4709": "<code><span class=\"literal string\">\"    \"</span> : String</code>",
 "4708":
 "<code><span class=\"literal string\">\"indeed!!\"</span> : String</code>",
 "4707":
 "<code>String.pushn (s : String) (c : Char) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Adds multiple repetitions of a character to the end of a string.\n\nReturns `s`, with `n` repetitions of `c` at the end. Internally, the implementation repeatedly calls\n`String.push`, so the string is modified in-place if there is a unique reference to it.\n\nExamples:\n * `\"indeed\".pushn '!' 2 = \"indeed!!\"`\n * `\"indeed\".pushn '!' 0 = \"indeed\"`\n * `\"\".pushn ' ' 4 = \"    \"`\n</code>",
 "4706":
 "<code><span class=\"literal string\">\"indeed\"</span> : String</code>",
 "4705": "<code><span class=\"literal string\">\"abcd\"</span> : String</code>",
 "4704": "<code><span class=\"literal string\">\"bac\"</span> : String</code>",
 "4703": "<code><span class=\"literal string\">\"aba\"</span> : String</code>",
 "4702":
 "<code><span class=\"literal string\">\"ababacabac\"</span> : String</code>",
 "4701":
 "<code><span class=\"literal string\">\" text \"</span> : String</code>",
 "4700":
 "<code><span class=\"literal string\">\"here is \"</span> : String</code>",
 "470":
 "<code>AugmentedIntArray.array (self : AugmentedIntArray) : Array Int</code>",
 "47":
 "<code>Option.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Optional values, which are either `some` around a value from the underlying type or `none`.\n\n`Option` can represent nullable types or computations that might fail. In the codomain of a function\ntype, it can also represent partiality.\n</code>",
 "4699": "<code><span class=\"literal string\">\"text\"</span> : String</code>",
 "4698": "<code><span class=\"literal string\">\"some\"</span> : String</code>",
 "4697": "<code><span class=\"literal string\">\"here\"</span> : String</code>",
 "4696":
 "<code><span class=\"literal string\">\"here is some text \"</span> : String</code>",
 "4695": "<code>optParam String \" \"</code>",
 "4694":
 "<code><span class=\"literal string\">\"  x + 1\"</span> : String</code>",
 "4693":
 "<code><span class=\"literal string\">\"fun x =&gt;\"</span> : String</code>",
 "4692":
 "<code><span class=\"literal string\">\"fun x =&gt;\\n  x + 1\\n\"</span> : String</code>",
 "4691":
 "<code><span class=\"literal string\">\"coffee  tea  water\"</span> : String</code>",
 "4690":
 "<code>String.split (s : String) (p : Char → Bool) : List String</code>",
 "469": "<code>AugmentedIntArray : Type</code>",
 "4689":
 "<code>String.endsWith (s post : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first string (`s`) ends with the second (`post`).\n\nExamples:\n* `\"red green blue\".endsWith \"blue\" = true`\n* `\"red green blue\".endsWith \"green\" = false`\n* `\"red green blue\".endsWith \"\" = true`\n* `\"red\".endsWith \"red\" = true`\n</code>",
 "4688": "<code>Manual.post : Verso.Doc.Elab.CodeBlockExpander</code>",
 "4687":
 "<code>String.startsWith (s pre : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first string (`s`) begins with the second (`pre`).\n\n`String.isPrefix` is a version that takes the potential prefix before the string.\n\nExamples:\n* `\"red green blue\".startsWith \"red\" = true`\n* `\"red green blue\".startsWith \"green\" = false`\n* `\"red green blue\".startsWith \"\" = true`\n* `\"red\".startsWith \"red\" = true`\n</code>",
 "4686": "<code><span class=\"literal string\">\"teas\"</span> : String</code>",
 "4685": "<code><span class=\"literal string\">\"ten\"</span> : String</code>",
 "4684":
 "<code>String.firstDiffPos (a b : String) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first position where the two strings differ.\n\nIf one string is a prefix of the other, then the returned position is the end position of the\nshorter string. If the strings are identical, then their end position is returned.\n\nExamples:\n* `\"tea\".firstDiffPos \"ten\" = ⟨2⟩`\n* `\"tea\".firstDiffPos \"tea\" = ⟨3⟩`\n* `\"tea\".firstDiffPos \"teas\" = ⟨3⟩`\n* `\"teas\".firstDiffPos \"tea\" = ⟨3⟩`\n</code>",
 "4683":
 "<code><span class=\"literal string\">\"brown and orange\"</span> : String</code>",
 "4682":
 "<code>String.all (s : String) (p : Char → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the Boolean predicate `p` returns `true` for every character in a string.\n\nShort-circuits at the first character for which `p` returns `false`.\n\nExamples:\n* `\"brown\".all (·.isLetter) = true`\n* `\"brown and orange\".all (·.isLetter) = false`\n* `\"\".all (fun _ =&gt; false) = true`\n</code>",
 "4681":
 "<code><span class=\"literal string\">\"brown\"</span> : String</code>",
 "4680":
 "<code><span class=\"literal string\">\"retaw dna aet eeffoc\"</span> : String</code>",
 "468": "<code><span class=\"literal string\">\"extra\"</span> : String</code>",
 "4679":
 "<code>String.foldr.{u} {α : Type u} (f : Char → α → α) (init : α) (s : String) : α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a string from the right, accumulating a value starting with `init`. The\naccumulated value is combined with each character in reverse order, using `f`.\n\nExamples:\n * `\"coffee tea water\".foldr (fun c n =&gt; if c.isWhitespace then n + 1 else n) 0 = 2`\n * `\"coffee tea and water\".foldr (fun c n =&gt; if c.isWhitespace then n + 1 else n) 0 = 3`\n * `\"coffee tea water\".foldr (fun c s =&gt; c.push s) \"\" = \"retaw dna aet eeffoc\"`\n</code>",
 "4678": "<code>Char → α → α</code>",
 "4677":
 "<code>String.push : String → Char → String</code><span class=\"sep\"></span><code class=\"docstring\">Adds a character to the end of a string.\n\nThe internal implementation uses dynamic arrays and will perform destructive updates\nif the string is not shared.\n\nExamples:\n* `\"abc\".push 'd' = \"abcd\"`\n* `\"\".push 'a' = \"a\"`\n</code>",
 "4676":
 "<code><span class=\"literal string\">\"coffee tea and water\"</span> : String</code>",
 "4675":
 "<code>String.foldl.{u} {α : Type u} (f : α → Char → α) (init : α) (s : String) : α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a string from the left, accumulating a value starting with `init`. The\naccumulated value is combined with each character in order, using `f`.\n\nExamples:\n * `\"coffee tea water\".foldl (fun n c =&gt; if c.isWhitespace then n + 1 else n) 0 = 2`\n * `\"coffee tea and water\".foldl (fun n c =&gt; if c.isWhitespace then n + 1 else n) 0 = 3`\n * `\"coffee tea water\".foldl (·.push ·) \"\" = \"coffee tea water\"`\n</code>",
 "4674": "<code>α → Char → α</code>",
 "4673":
 "<code><span class=\"literal string\">\"ABC123\"</span> : String</code>",
 "4672":
 "<code>String.map (f : Char → Char) (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Applies the function `f` to every character in a string, returning a string that contains the\nresulting characters.\n\nExamples:\n * `\"abc123\".map Char.toUpper = \"ABC123\"`\n * `\"\".map Char.toUpper = \"\"`\n</code>",
 "4671":
 "<code><span class=\"literal string\">\"abc123\"</span> : String</code>",
 "4670":
 "<code>String.revFind (s : String) (p : Char → Bool) : Option String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">Finds the position of the last character in a string for which the Boolean predicate `p` returns\n`true`. If there is no such character in the string, then `none` is returned.\n\nExamples:\n * `\"coffee tea water\".revFind (·.isWhitespace) = some ⟨10⟩`\n * `\"tea\".revFind (· == 'X') = none`\n * `\"\".revFind (· == 'X') = none`\n</code>",
 "467": "<code>String</code>",
 "4669":
 "<code>String.find (s : String) (p : Char → Bool) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">Finds the position of the first character in a string for which the Boolean predicate `p` returns\n`true`. If there is no such character in the string, then the end position of the string is\nreturned.\n\nExamples:\n * `\"coffee tea water\".find (·.isWhitespace) = ⟨6⟩`\n * `\"tea\".find (· == 'X') = ⟨3⟩`\n * `\"\".find (· == 'X') = ⟨0⟩`\n</code>",
 "4668":
 "<code><span class=\"literal string\">\"coffee tea water\"</span> : String</code>",
 "4667":
 "<code><span class=\"literal string\">\"rEd grEEn bluE\"</span> : String</code>",
 "4666":
 "<code><span class=\"literal string\">\"red grEn blue\"</span> : String</code>",
 "4665": "<code><span class=\"literal string\">\"E\"</span> : String</code>",
 "4664":
 "<code><span class=\"literal string\">\"rd grn blu\"</span> : String</code>",
 "4663":
 "<code>String.replace (s pattern replacement : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">In the string `s`, replaces all occurrences of `pattern` with `replacement`.\n\nExamples:\n* `\"red green blue\".replace \"e\" \"\" = \"rd grn blu\"`\n* `\"red green blue\".replace \"ee\" \"E\" = \"red grEn blue\"`\n* `\"red green blue\".replace \"e\" \"E\" = \"rEd grEEn bluE\"`\n</code>",
 "4662":
 "<code>String.offsetOfPos (s : String) (pos : String.Pos.Raw) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character index that corresponds to the provided position (i.e. UTF-8 byte index) in a\nstring.\n\nIf the position is at the end of the string, then the string's length in characters is returned. If\nthe position is invalid due to pointing at the middle of a UTF-8 byte sequence, then the character\nindex of the next character after the position is returned.\n\nExamples:\n* `\"L∃∀N\".offsetOfPos ⟨0⟩ = 0`\n* `\"L∃∀N\".offsetOfPos ⟨1⟩ = 1`\n* `\"L∃∀N\".offsetOfPos ⟨2⟩ = 2`\n* `\"L∃∀N\".offsetOfPos ⟨4⟩ = 2`\n* `\"L∃∀N\".offsetOfPos ⟨5⟩ = 3`\n* `\"L∃∀N\".offsetOfPos ⟨50⟩ = 4`\n</code>",
 "4661":
 "<code>String.contains (s : String) (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a string contains the specified character.\n\nExamples:\n* `\"green\".contains 'e' = true`\n* `\"green\".contains 'x' = false`\n* `\"\".contains 'x' = false`\n</code>",
 "4660":
 "<code>String.revPosOf (s : String) (c : Char) : Option String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">Returns the position of the last occurrence of a character, `c`, in a string `s`. If `s` does not\ncontain `c`, returns `none`.\n\nExamples:\n* `\"abcabc\".revPosOf 'a' = some ⟨3⟩`\n* `\"abcabc\".revPosOf 'z' = none`\n* `\"L∃∀N\".revPosOf '∀' = some ⟨4⟩`\n</code>",
 "466": "<code>List Int</code>",
 "4659":
 "<code><span class=\"literal string\">\"abcabc\"</span> : String</code>",
 "4658":
 "<code>String.posOf (s : String) (c : Char) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">Returns the position of the first occurrence of a character, `c`, in a string `s`. If `s` does not\ncontain `c`, returns `s.endPos`.\n\nExamples:\n* `\"abcba\".posOf 'a' = ⟨0⟩`\n* `\"abcba\".posOf 'z' = ⟨5⟩`\n* `\"L∃∀N\".posOf '∀' = ⟨4⟩`\n</code>",
 "4657":
 "<code><span class=\"literal string\">\"abcba\"</span> : String</code>",
 "4656":
 "<code>String.back (s : String) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last character in `s`. If `s = \"\"`, returns `(default : Char)`.\n\nExamples:\n* `\"abc\".back = 'c'`\n* `\"\".back = (default : Char)`\n</code>",
 "4655":
 "<code>String.front (s : String) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first character in `s`. If `s = \"\"`, returns `(default : Char)`.\n\nExamples:\n* `\"abc\".front = 'a'`\n* `\"\".front = (default : Char)`\n</code>",
 "4654":
 "<code><span class=\"literal string\">\"Here:\\nfun x =&gt;\\n\\n \\tx + 1\"</span> : String</code>",
 "4653":
 "<code><span class=\"literal string\">\"Here:\\n\\t\\tfun x =&gt;\\n \\n\\t  \\tx + 1\"</span> : String</code>",
 "4652":
 "<code><span class=\"literal string\">\"Here:\\nfun x =&gt;\\n \\tx + 1\"</span> : String</code>",
 "4651":
 "<code><span class=\"literal string\">\"Here:\\n\\t\\tfun x =&gt;\\n\\t  \\tx + 1\"</span> : String</code>",
 "4650":
 "<code><span class=\"literal string\">\"Here:\\nfun x =&gt;\\n  x + 1\"</span> : String</code>",
 "465": "<code>AugmentedIntList.isEmpty : AugmentedIntList → Bool</code>",
 "4649":
 "<code>String.removeLeadingSpaces (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Consistently de-indents the lines in a string, removing the same amount of leading whitespace from\neach line such that the least-indented line has no leading whitespace.\n\nThe number of leading whitespace characters to remove from each line is determined by counting the\nnumber of leading space (`' '`) and tab (`'\\t'`) characters on lines after the first line that also\ncontain non-whitespace characters. No distinction is made between tab and space characters; both\ncount equally.\n\nThe least number of leading whitespace characters found is then removed from the beginning of each\nline. The first line's leading whitespace is not counted when determining how far to de-indent the\nstring, but leading whitespace is removed from it.\n\nExamples:\n* `\"Here:\\n  fun x =&gt;\\n    x + 1\".removeLeadingSpaces = \"Here:\\nfun x =&gt;\\n  x + 1\"`\n* `\"Here:\\n\\t\\tfun x =&gt;\\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =&gt;\\n \\tx + 1\"`\n* `\"Here:\\n\\t\\tfun x =&gt;\\n \\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =&gt;\\n\\n \\tx + 1\"`\n</code>",
 "4648":
 "<code><span class=\"literal string\">\"Here:\\n  fun x =&gt;\\n    x + 1\"</span> : String</code>",
 "4647":
 "<code><span class=\"literal string\">\"  abc\"</span> : String</code>",
 "4646":
 "<code><span class=\"literal string\">\"abc   \"</span> : String</code>",
 "4645":
 "<code>String.trimLeft (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes leading whitespace from a string.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`.\n\nExamples:\n* `\"abc\".trimLeft = \"abc\"`\n* `\"   abc\".trimLeft = \"   abc\"`\n* `\"abc \\t  \".trimLeft = \"abc \\t  \"`\n* `\"  abc   \".trimLeft = \"abc   \"`\n* `\"abc\\ndef\\n\".trimLeft = \"abc\\ndef\\n\"`\n</code>",
 "4644":
 "<code><span class=\"literal string\">\"abc\\ndef\"</span> : String</code>",
 "4643":
 "<code><span class=\"literal string\">\"abc\\ndef\\n\"</span> : String</code>",
 "4642":
 "<code><span class=\"literal string\">\"  abc   \"</span> : String</code>",
 "4641":
 "<code><span class=\"literal string\">\"abc \\t  \"</span> : String</code>",
 "4640":
 "<code><span class=\"literal string\">\"   abc\"</span> : String</code>",
 "464":
 "<code>AugmentedIntList.augmentation (self : AugmentedIntList) : String</code>",
 "4639":
 "<code><span class=\"literal string\">\" blu \"</span> : String</code>",
 "4638":
 "<code>String.dropSuffix? (s suff : String) : Option Substring</code><span class=\"sep\"></span><code class=\"docstring\">If `suff` is a suffix of `s`, returns the remainder. Returns `none` otherwise.\n\nThe string `suff` is a suffix of `s` if there exists a `t : String` such that `s = t ++ suff`. If so,\nthe result is `some t`.\n\nUse `String.stripSuffix` to return the string unchanged when `suff` is not a suffix.\n\nExamples:\n * `\"red green blue\".dropSuffix? \" blue\" = some \"red green\"`\n * `\"red green blue\".dropSuffix? \" blu \" = none`\n * `\"red green blue\".dropSuffix? \"\" = some \"red green blue\"`\n</code>",
 "4637":
 "<code>String.stripSuffix (s suff : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">If `suff` is a suffix of `s`, returns the remainder. Returns `s` unmodified otherwise.\n\nThe string `suff` is a suffix of `s` if there exists a `t : String` such that `s = t ++ suff`. If so,\nthe result is `t`. Otherwise, it is `s`.\n\nUse `String.dropSuffix?` to return `none` when `suff` is not a suffix.\n\nExamples:\n * `\"red green blue\".stripSuffix \" blue\" = \"red green\"`\n * `\"red green blue\".stripSuffix \" blu \" = \"red green blue\"`\n * `\"red green blue\".stripSuffix \"\" = \"red green blue\"`\n</code>",
 "4636":
 "<code><span class=\"literal string\">\"reed \"</span> : String</code>",
 "4635": "<code><span class=\"literal string\">\"red \"</span> : String</code>",
 "4634":
 "<code>String.dropPrefix? (s pre : String) : Option Substring</code><span class=\"sep\"></span><code class=\"docstring\">If `pre` is a prefix of `s`, returns the remainder. Returns `none` otherwise.\n\nThe string `pre` is a prefix of `s` if there exists a `t : String` such that `s = pre ++ t`. If so,\nthe result is `some t`.\n\nUse `String.stripPrefix` to return the string unchanged when `pre` is not a prefix.\n\nExamples:\n * `\"red green blue\".dropPrefix? \"red \" = some \"green blue\"`\n * `\"red green blue\".dropPrefix? \"reed \" = none`\n * `\"red green blue\".dropPrefix? \"\" = some \"red green blue\"`\n</code>",
 "4633":
 "<code>String.stripPrefix (s pre : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">If `pre` is a prefix of `s`, returns the remainder. Returns `s` unmodified otherwise.\n\nThe string `pre` is a prefix of `s` if there exists a `t : String` such that `s = pre ++ t`. If so,\nthe result is `t`. Otherwise, it is `s`.\n\nUse `String.dropPrefix?` to return `none` when `pre` is not a prefix.\n\nExamples:\n * `\"red green blue\".stripPrefix \"red \" = \"green blue\"`\n * `\"red green blue\".stripPrefix \"reed \" = \"red green blue\"`\n * `\"red green blue\".stripPrefix \"\" = \"red green blue\"`\n</code>",
 "4632":
 "<code>Substring : Type</code><span class=\"sep\"></span><code class=\"docstring\">A region or slice of some underlying string.\n\nA substring contains an string together with the start and end byte positions of a region of\ninterest. Actually extracting a substring requires copying and memory allocation, while many\nsubstrings of the same underlying string may exist with very little overhead, and they are more\nconvenient than tracking the bounds by hand.\n\nUsing its constructor explicitly, it is possible to construct a `Substring` in which one or both of\nthe positions is invalid for the string. Many operations will return unexpected or confusing results\nif the start and stop positions are not valid. For this reason, `Substring` will be deprecated in\nfavor of `String.Slice`, which always represents a valid substring.\n</code>",
 "4631":
 "<code><span class=\"literal string\">\"red green blu\"</span> : String</code>",
 "4630":
 "<code><span class=\"literal string\">\"red green \"</span> : String</code>",
 "463":
 "<code>AugmentedIntList.list (self : AugmentedIntList) : List Int</code>",
 "4629":
 "<code>String.dropRightWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string by removing the longest suffix from `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".dropRightWhile (·.isLetter) = \"red green \"`\n* `\"red green blue\".dropRightWhile (· == 'e') = \"red green blu\"`\n* `\"red green blue\".dropRightWhile (· != 'n') = \"red green\"`\n* `\"red green blue\".dropRightWhile (fun _ =&gt; true) = \"\"`\n</code>",
 "4628":
 "<code><span class=\"literal string\">\"red green\"</span> : String</code>",
 "4627":
 "<code>String.dropRight (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes the specified number of characters (Unicode code points) from the end of the string.\n\nIf `n` is greater than `s.length`, returns `\"\"`.\n\nExamples:\n* `\"red green blue\".dropRight 5 = \"red green\"`\n* `\"red green blue\".dropRight 11 = \"red\"`\n* `\"red green blue\".dropRight 50 = \"\"`\n</code>",
 "4626":
 "<code><span class=\"literal string\">\"n blue\"</span> : String</code>",
 "4625":
 "<code><span class=\"literal string\">\"ed green blue\"</span> : String</code>",
 "4624":
 "<code><span class=\"literal string\">\" green blue\"</span> : String</code>",
 "4623":
 "<code>String.dropWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string by removing the longest prefix from `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".dropWhile (·.isLetter) = \" green blue\"`\n* `\"red green blue\".dropWhile (· == 'r') = \"ed green blue\"`\n* `\"red green blue\".dropWhile (· != 'n') = \"n blue\"`\n* `\"red green blue\".dropWhile (fun _ =&gt; true) = \"\"`\n</code>",
 "4622":
 "<code>String.drop (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes the specified number of characters (Unicode code points) from the start of the string.\n\nIf `n` is greater than `s.length`, returns `\"\"`.\n\nExamples:\n* `\"red green blue\".drop 4 = \"green blue\"`\n* `\"red green blue\".drop 10 = \"blue\"`\n* `\"red green blue\".drop 50 = \"\"`\n</code>",
 "4621":
 "<code><span class=\"literal string\">\" blue\"</span> : String</code>",
 "4620":
 "<code>String.takeRightWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the longest suffix of `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".takeRightWhile (·.isLetter) = \"blue\"`\n* `\"red green blue\".takeRightWhile (· == 'e') = \"e\"`\n* `\"red green blue\".takeRightWhile (· != 'n') = \" blue\"`\n* `\"red green blue\".takeRightWhile (fun _ =&gt; true) = \"red green blue\"`\n</code>",
 "462": "<code>AugmentedIntList : Type</code>",
 "4619":
 "<code>String.takeRight (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the last `n` characters (Unicode code points) of `s`.\n\nIf `n` is greater than `s.length`, returns `s`.\n\nExamples:\n* `\"red green blue\".takeRight 4 = \"blue\"`\n* `\"red green blue\".takeRight 1 = \"e\"`\n* `\"red green blue\".takeRight 0 = \"\"`\n* `\"red green blue\".takeRight 100 = \"red green blue\"`\n</code>",
 "4618":
 "<code><span class=\"literal string\">\"red gree\"</span> : String</code>",
 "4617":
 "<code>String.takeWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the longest prefix of `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".takeWhile (·.isLetter) = \"red\"`\n* `\"red green blue\".takeWhile (· == 'r') = \"r\"`\n* `\"red green blue\".takeWhile (· != 'n') = \"red gree\"`\n* `\"red green blue\".takeWhile (fun _ =&gt; true) = \"red green blue\"`\n</code>",
 "4616": "<code><span class=\"literal string\">\"r\"</span> : String</code>",
 "4615":
 "<code>String.modify (s : String) (i : String.Pos.Raw) (f : Char → Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the character at position `p` in the string `s` with the result of applying `f` to that\ncharacter. If `p` is an invalid position, the string is returned unchanged.\n\nIf both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.\n\nThis is a legacy function. The recommended alternative is `String.ValidPos.set`, combined with\n`String.pos` or another means of obtaining a `String.ValidPos`.\n\nExamples:\n* `\"abc\".modify ⟨1⟩ Char.toUpper = \"aBc\"`\n* `\"abc\".modify ⟨3⟩ Char.toUpper = \"abc\"`\n</code>",
 "4614": "<code>String.set : String → String.Pos.Raw → Char → String</code>",
 "4613": "<code>String.get? : String → String.Pos.Raw → Option Char</code>",
 "4612":
 "<code>String.utf8GetAux? : List Char → String.Pos.Raw → String.Pos.Raw → Option Char</code>",
 "4611":
 "<code>String.Pos.Raw.get' (s : String) (p : String.Pos.Raw) (h : ¬String.Pos.Raw.atEnd s p = true) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character at position `p` of a string. Returns `(default : Char)`, which is `'A'`, if\n`p` is not a valid position.\n\nRequires evidence, `h`, that `p` is within bounds instead of performing a run-time bounds check as\nin `String.get`.\n\nA typical pattern combines `get'` with a dependent `if`-expression to avoid the overhead of an\nadditional bounds check. For example:\n```\ndef getInBounds? (s : String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else some (s.get' p h)\n```\nEven with evidence of `¬ s.atEnd p`, `p` may be invalid if a byte index points into the middle of a\nmulti-byte UTF-8 character. For example, `\"L∃∀N\".get' ⟨2⟩ (by decide) = (default : Char)`.\n\nThis is a legacy function. The recommended alternative is `String.ValidPos.get`, combined with\n`String.pos` or another means of obtaining a `String.ValidPos`.\n\nExamples:\n* `\"abc\".get' 0 (by decide) = 'a'`\n* `let lean := \"L∃∀N\"; lean.get' (0 |&gt; lean.next |&gt; lean.next) (by decide) = '∀'`\n</code>",
 "4610":
 "<code>String.get' (s : String) (p : String.Pos.Raw) (h : ¬String.Pos.Raw.atEnd s p = true) : Char</code>",
 "461":
 "<code>Std.HashMap.insert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α)\n  (b : β) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Inserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nNote: this replacement behavior is true for `HashMap`, `DHashMap`, `HashMap.Raw` and `DHashMap.Raw`.\nThe `insert` function on `HashSet` and `HashSet.Raw` behaves differently: it will return the set\nunchanged if a matching key is already present.\n</code>",
 "4609":
 "<code>getInBounds? (s : String) (p : String.Pos) : Option Char</code>",
 "4608": "<code>String.get! (s : String) (p : String.Pos.Raw) : Char</code>",
 "4607":
 "<code>String.pos! (s : String) (off : String.Pos.Raw) : s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a valid position `s` from a position, panicking if the position is not valid. </code>",
 "4606":
 "<code>String.utf8GetAux : List Char → String.Pos.Raw → String.Pos.Raw → Char</code>",
 "4605":
 "<code>String.pos? (s : String) (off : String.Pos.Raw) : Option s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a valid position on `s` from a position, returning `none` if the position is not valid. </code>",
 "4604":
 "<code>String.Pos.Raw.utf8GetAux : List Char → String.Pos.Raw → String.Pos.Raw → Char</code>",
 "4603": "<code><span class=\"literal string\">\"∃∀N\"</span> : String</code>",
 "4602":
 "<code><span class=\"literal string\">\"green blue\"</span> : String</code>",
 "4601":
 "<code>String.extract : String → String.Pos.Raw → String.Pos.Raw → String</code>",
 "4600":
 "<code><span class=\"literal string\">\"red green blue\"</span> : String</code>",
 "460":
 "<code>Std.HashMap.contains.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α) :\n  Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if there is a mapping for the given key. There is also a `Prop`-valued version\nof this: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` uses\n`==` for comparisons, while for hash maps, both use `==`.\n</code>",
 "46": "<code>Type u_1</code>",
 "4599":
 "<code>String.ValidPos.extract {s : String} (b e : s.ValidPos) : String</code>",
 "4598": "<code><span class=\"literal string\">\"ba  \"</span> : String</code>",
 "4597":
 "<code>String.nextWhile (s : String) (p : Char → Bool) (i : String.Pos.Raw) : String.Pos.Raw</code>",
 "4596": "<code><span class=\"literal string\">\"a  \"</span> : String</code>",
 "4595":
 "<code>Char.isWhitespace (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is a space `(' ', U+0020)`, a tab `('\\t', U+0009)`, a carriage\nreturn `('\\r', U+000D)`, or a newline `('\\n', U+000A)`.\n</code>",
 "4594":
 "<code>String.nextUntil (s : String) (p : Char → Bool) (i : String.Pos.Raw) : String.Pos.Raw</code>",
 "4593":
 "<code><span class=\"literal string\">\"   a  \"</span> : String</code>",
 "4592": "<code>Char → Bool</code>",
 "4591": "<code>¬s.atEnd p = true</code>",
 "4590":
 "<code>String.Pos.Raw.next' (s : String) (p : String.Pos.Raw) (h : ¬String.Pos.Raw.atEnd s p = true) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">Returns the next position in a string after position `p`. The result is unspecified if `p` is not a\nvalid position.\n\nRequires evidence, `h`, that `p` is within bounds. No run-time bounds check is performed, as in\n`String.next`.\n\nA typical pattern combines `String.next'` with a dependent `if`-expression to avoid the overhead of\nan additional bounds check. For example:\n```\ndef next? (s : String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else s.get (s.next' p h)\n```\n\nThis is a legacy function. The recommended alternative is `String.ValidPos.next`, combined with\n`String.pos` or another means of obtaining a `String.ValidPos`.\n\nExample:\n* `let abc := \"abc\"; abc.get (abc.next' 0 (by decide)) = 'b'`\n</code>",
 "459": "<code>NatStringBimap</code>",
 "4589":
 "<code>String.Pos.Raw.get (s : String) (p : String.Pos.Raw) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character at position `p` of a string. If `p` is not a valid position, returns the\nfallback value `(default : Char)`, which is `'A'`, but does not panic.\n\nThis function is overridden with an efficient implementation in runtime code. See\n`String.Pos.Raw.utf8GetAux` for the reference implementation.\n\nThis is a legacy function. The recommended alternative is `String.ValidPos.get`, combined with\n`String.pos` or another means of obtaining a `String.ValidPos`.\n\nExamples:\n* `\"abc\".get ⟨1⟩ = 'b'`\n* `\"abc\".get ⟨3⟩ = (default : Char)` because byte `3` is at the end of the string.\n* `\"L∃∀N\".get ⟨2⟩ = (default : Char)` because byte `2` is in the middle of `'∃'`.\n</code>",
 "4588": "<code>s.atEnd p = true</code>",
 "4587": "<code>String.Pos</code>",
 "4586": "<code>next? (s : String) (p : String.Pos) : Option Char</code>",
 "4585":
 "<code>String.Pos.Raw.atEnd : String → String.Pos.Raw → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if a specified byte position is greater than or equal to the position which points to\nthe end of a string. Otherwise, returns `false`.\n\nExamples:\n* `(0 |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".atEnd) = false`\n* `(0 |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".atEnd) = true`\n* `(0 |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".atEnd) = false`\n* `(0 |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".atEnd) = true`\n* `\"abc\".atEnd ⟨4⟩ = true`\n* `\"L∃∀N\".atEnd ⟨7⟩ = false`\n* `\"L∃∀N\".atEnd ⟨8⟩ = true`\n</code>",
 "4584": "<code>¬String.Pos.Raw.atEnd s p = true</code>",
 "4583":
 "<code>String.ValidPos.next? {s : String} (pos : s.ValidPos) : Option s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">Advances a valid position on a string to the next valid position, or returns `none` if the\ngiven position is the past-the-end position. </code>",
 "4582":
 "<code>String.ValidPos.next {s : String} (pos : s.ValidPos) (h : pos ≠ s.endValidPos) : s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">Advances a valid position on a string to the next valid position, given a proof that the\nposition is not the past-the-end position, which guarantees that such a position exists. </code>",
 "4581":
 "<code>String.next' (s : String) (p : String.Pos.Raw) (h : ¬String.Pos.Raw.atEnd s p = true) : String.Pos.Raw</code>",
 "4580": "<code>String.get (s : String) (p : String.Pos.Raw) : Char</code>",
 "458":
 "<code>NatStringBimap.insert (nat : Nat) (string : String) (map : NatStringBimap) : Option NatStringBimap</code>",
 "4579":
 "<code>String.ValidPos.prev? {s : String} (pos : s.ValidPos) : Option s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the previous valid position before the given position, or `none` if the position is\nthe start position. </code>",
 "4578":
 "<code>String.ValidPos.prev {s : String} (pos : s.ValidPos) (h : pos ≠ s.startValidPos) : s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the previous valid position before the given position, given a proof that the position\nis not the start position, which guarantees that such a position exists. </code>",
 "4577": "<code>String.atEnd : String → String.Pos.Raw → Bool</code>",
 "4576": "<code><span class=\"literal string\">\"𝒫(A)\"</span> : String</code>",
 "4575":
 "<code>String.endPos (s : String) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">A UTF-8 byte position that points at the end of a string, just after the last character.\n\n* `\"abc\".endPos = ⟨3⟩`\n* `\"L∃∀N\".endPos = ⟨8⟩`\n</code>",
 "4574":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">Get the underlying byte index of a `String.Pos.Raw` </code>",
 "4573": "<code>String.Pos : Type</code>",
 "4572":
 "<code>String.toSlice (s : String) : String.Slice</code><span class=\"sep\"></span><code class=\"docstring\">Returns a slice that contains the entire string.\n</code>",
 "4571": "<code>q ≤ p</code>",
 "4570":
 "<code>String.Slice.Pos (s : String.Slice) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A `Slice.Pos s` is a byte offset in `s` together with a proof that this position is at a UTF-8\ncharacter boundary.\n</code>",
 "457": "<code>NatStringBimap.empty : NatStringBimap</code>",
 "4569":
 "<code>String.Slice.copy (s : String.Slice) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `String` from a `String.Slice` by copying the bytes. </code>",
 "4568": "<code>s.copy.ValidPos</code>",
 "4567":
 "<code>String.Slice : Type</code><span class=\"sep\"></span><code class=\"docstring\">A region or slice of some underlying string.\n\nA slice consists of a string together with the start and end byte positions of a region of\ninterest. Actually extracting a substring requires copying and memory allocation, while many\nslices of the same underlying string may exist with very little overhead. While this could be achieved by tracking the bounds by hand, the slice API is much more convenient.\n\n`String.Slice` bundles proofs to ensure that the start and end positions always delineate a valid\nstring. For this reason, it should be preferred over `Substring`.\n</code>",
 "4566": "<code>String.Slice</code>",
 "4565": "<code>s = t</code>",
 "4564":
 "<code>String.startValidPos (s : String) : s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">The start position of `s`, as an `s.ValidPos`. </code>",
 "4563": "<code>pos ≠ s.startValidPos</code>",
 "4562":
 "<code>Char.toUpper (c : Char) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a lowercase ASCII letter to the corresponding uppercase letter. Letters outside the ASCII\nalphabet are returned unchanged.\n\nThe lowercase ASCII letters are the following: `abcdefghijklmnopqrstuvwxyz`.\n</code>",
 "4561":
 "<code>String.ValidPos.modify {s : String} (p : s.ValidPos) (f : Char → Char) (hp : p ≠ s.endValidPos) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the character at position `p` in the string `s` with the result of applying `f` to that\ncharacter.\n\nIf both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.\n\nExamples:\n* `(\"abc\".pos ⟨1⟩ (by decide)).modify Char.toUpper (by decide) = \"aBc\"`\n</code>",
 "4560": "<code>Char → Char</code>",
 "456":
 "<code>NatStringBimap.stringToNat (self : NatStringBimap) : Std.HashMap String Nat</code>",
 "4559": "<code><span class=\"literal string\">\"L∃XN\"</span> : String</code>",
 "4558": "<code><span class=\"literal string\">\"aBc\"</span> : String</code>",
 "4557":
 "<code>String.ValidPos.set {s : String} (p : s.ValidPos) (c : Char) (hp : p ≠ s.endValidPos) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the character at a specified position in a string with a new character.\n\nIf both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.\n\nExamples:\n* `(\"abc\".pos ⟨1⟩ (by decide)).set 'B' (by decide) = \"aBc\"`\n* `(\"L∃∀N\".pos ⟨4⟩ (by decide)).set 'X' (by decide) = \"L∃XN\"`\n</code>",
 "4556": "<code>p ≠ s.endValidPos</code>",
 "4555":
 "<code>String.ValidPos.get {s : String} (pos : s.ValidPos) (h : pos ≠ s.endValidPos) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character at the position `pos` of a string, taking a proof that `p` is not the\npast-the-end position.\n\nThis function is overridden with an efficient implementation in runtime code.\n\nExamples:\n* `(\"abc\".pos ⟨1⟩ (by decide)).get (by decide) = 'b'`\n* `(\"L∃∀N\".pos ⟨1⟩ (by decide)).get (by decide) = '∃'`\n</code>",
 "4554": "<code>String.Pos.Raw.mk (byteIdx : Nat) : String.Pos.Raw</code>",
 "4553":
 "<code>String.pos (s : String) (off : String.Pos.Raw) (h : String.Pos.Raw.IsValid s off) : s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a valid position on `s` from a position and a proof that it is valid. </code>",
 "4552":
 "<code>String.endValidPos (s : String) : s.ValidPos</code><span class=\"sep\"></span><code class=\"docstring\">The past-the-end position of `s`, as an `s.ValidPos`. </code>",
 "4551": "<code>pos ≠ s.endValidPos</code>",
 "4550": "<code>String.Pos.Raw.IsValid s off</code>",
 "455":
 "<code>Std.HashMap.{u, v} (α : Type u) (β : Type v) [BEq α] [Hashable α] : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Hash maps.\n\nThis is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash map is used linearly to\navoid expensive copies.\n\nThe hash map uses `==` (provided by the `BEq` typeclass) to compare keys and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nThese hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.Data.HashMap.Raw` and\n`Std.Data.HashMap.Raw.WF` unbundle the invariant from the hash map. When in doubt, prefer\n`HashMap` over `HashMap.Raw`.\n\nDependent hash maps, in which keys may occur in their values' types, are available as\n`Std.Data.DHashMap`.\n</code>",
 "4549": "<code>String.Pos.Raw</code>",
 "4548":
 "<code>String.ValidPos.offset {s : String} (self : s.ValidPos) : String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The underlying byte offset of the `ValidPos`. </code>",
 "4547": "<code>s.ValidPos</code>",
 "4546":
 "<code>String.Pos.Raw.IsValid (s : String) (off : String.Pos.Raw) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Predicate for validity of positions inside a `String`.\n\nThere are multiple equivalent definitions for validity.\n\nWe say that a position is valid if the string obtained by taking all of the bytes up to, but\nexcluding, the given position, is valid UTF-8; see `Pos.isValid_iff_isValidUTF8_extract_zero`.\n\nSimilarly, a position is valid if the string obtained by taking all of the bytes starting at the\ngiven position is valid UTF-8; see `Pos.isValid_iff_isValidUTF8_extract_utf8ByteSize`.\n\nAn equivalent condition is that the position is the length of the UTF-8 encoding of\nsome prefix of the characters of the string; see `Pos.isValid_iff_exists_append` and\n`Pos.isValid_iff_exists_take_data`.\n\nAnother equivalent condition that can be checked efficiently is that the position is either the\nend position or strictly smaller than the end position and the byte at the position satisfies\n`UInt8.IsUTF8FirstByte`; see `Pos.isValid_iff_isUTF8FirstByte`.\n\nExamples:\n * `String.Pos.IsValid \"abc\" ⟨0⟩`\n * `String.Pos.IsValid \"abc\" ⟨1⟩`\n * `String.Pos.IsValid \"abc\" ⟨3⟩`\n * `¬ String.Pos.IsValid \"abc\" ⟨4⟩`\n * `String.Pos.IsValid \"𝒫(A)\" ⟨0⟩`\n * `¬ String.Pos.IsValid \"𝒫(A)\" ⟨1⟩`\n * `¬ String.Pos.IsValid \"𝒫(A)\" ⟨2⟩`\n * `¬ String.Pos.IsValid \"𝒫(A)\" ⟨3⟩`\n * `String.Pos.IsValid \"𝒫(A)\" ⟨4⟩`\n</code>",
 "4545":
 "<code>String.Pos.Raw.IsValid s self.offset</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `offset` is valid for the string `s`. </code>",
 "4544":
 "<code>String.Pos.Raw : Type</code><span class=\"sep\"></span><code class=\"docstring\">A byte position in a `String`, according to its UTF-8 encoding.\n\nCharacter positions (counting the Unicode code points rather than bytes) are represented by plain\n`Nat`s. Indexing a `String` by a `String.Pos.Raw` takes constant time, while character positions need to\nbe translated internally to byte positions, which takes linear time.\n\nA byte position `p` is *valid* for a string `s` if `0 ≤ p ≤ s.endPos` and `p` lies on a UTF-8\ncharacter boundary, see `String.Pos.IsValid`.\n\nThere is another type, `String.ValidPos`, which bundles the validity predicate. Using `String.ValidPos`\ninstead of `String.Pos.Raw` is recommended because it will lead to less error handling and fewer edge cases.\n</code>",
 "4543":
 "<code>String.Pos.Raw</code><span class=\"sep\"></span><code class=\"docstring\">The underlying byte offset of the `ValidPos`. </code>",
 "4542":
 "<code>String.ValidPos.mk {s : String} (offset : String.Pos.Raw) (isValid : String.Pos.Raw.IsValid s offset) : s.ValidPos</code>",
 "4541":
 "<code><span class=\"literal string\">\"empty\"</span> : String</code>",
 "4540":
 "<code>String.isEmpty (s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a string is empty.\n\nEmpty strings are equal to `\"\"` and have length and end position `0`.\n\nExamples:\n* `\"\".isEmpty = true`\n* `\"empty\".isEmpty = false`\n* `\" \".isEmpty = false`\n</code>",
 "454":
 "<code>NatStringBimap.natToString (self : NatStringBimap) : Std.HashMap Nat String</code>",
 "4539": "<code><span class=\"literal string\">\"-5\"</span> : String</code>",
 "4538": "<code><span class=\"literal string\">\"2-3\"</span> : String</code>",
 "4537": "<code><span class=\"literal string\">\"+587\"</span> : String</code>",
 "4536": "<code><span class=\"literal string\">\"-0\"</span> : String</code>",
 "4535": "<code><span class=\"literal string\">\"-\"</span> : String</code>",
 "4534":
 "<code>String.isInt (s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the string can be interpreted as the decimal representation of an integer.\n\nA string can be interpreted as a decimal integer if it only consists of at least one decimal digit\nand optionally `-` in front. Leading `+` characters are not allowed.\n\nUse `String.toInt?` or `String.toInt!` to convert such a string to an integer.\n\nExamples:\n * `\"\".isInt = false`\n * `\"-\".isInt = false`\n * `\"0\".isInt = true`\n * `\"-0\".isInt = true`\n * `\"5\".isInt = true`\n * `\"587\".isInt = true`\n * `\"-587\".isInt = true`\n * `\"+587\".isInt = false`\n * `\" 5\".isInt = false`\n * `\"2-3\".isInt = false`\n * `\"0xff\".isInt = false`\n</code>",
 "4533":
 "<code>String.toInt! (s : String) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of an integer, returning it. Panics if the string\ndoes not contain a decimal integer.\n\nA string can be interpreted as a decimal integer if it only consists of at least one decimal digit\nand optionally `-` in front. Leading `+` characters are not allowed.\n\nUse `String.isInt` to check whether `String.toInt!` would return a value. `String.toInt?` is a safer\nalternative that returns `none` instead of panicking when the string is not an integer.\n\nExamples:\n * `\"0\".toInt! = 0`\n * `\"5\".toInt! = 5`\n * `\"587\".toInt! = 587`\n * `\"-587\".toInt! = -587`\n</code>",
 "4532":
 "<code>String.toInt? (s : String) : Option Int</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of an integer, returning it. Returns `none` if\nthe string does not contain a decimal integer.\n\nA string can be interpreted as a decimal integer if it only consists of at least one decimal digit\nand optionally `-` in front. Leading `+` characters are not allowed.\n\nUse `String.isInt` to check whether `String.toInt?` would return `some`. `String.toInt!` is an\nalternative that panics instead of returning `none` when the string is not an integer.\n\nExamples:\n * `\"\".toInt? = none`\n * `\"-\".toInt? = none`\n * `\"0\".toInt? = some 0`\n * `\"5\".toInt? = some 5`\n * `\"-5\".toInt? = some (-5)`\n * `\"587\".toInt? = some 587`\n * `\"-587\".toInt? = some (-587)`\n * `\" 5\".toInt? = none`\n * `\"2-3\".toInt? = none`\n * `\"0xff\".toInt? = none`\n</code>",
 "4531": "<code><span class=\"literal string\">\"0xff\"</span> : String</code>",
 "4530": "<code><span class=\"literal string\">\"2+3\"</span> : String</code>",
 "453":
 "<code>NatStringBimap.mk (natToString : Std.HashMap Nat String) (stringToNat : Std.HashMap String Nat) : NatStringBimap</code><span class=\"sep\"></span><code class=\"docstring\">Build a finite bijection between some\nnatural numbers and strings\n</code>",
 "4529": "<code><span class=\"literal string\">\" 5\"</span> : String</code>",
 "4528": "<code><span class=\"literal string\">\"-587\"</span> : String</code>",
 "4527": "<code><span class=\"literal string\">\"587\"</span> : String</code>",
 "4526": "<code><span class=\"literal string\">\"05\"</span> : String</code>",
 "4525": "<code><span class=\"literal string\">\"5\"</span> : String</code>",
 "4524":
 "<code>String.isNat (s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the string can be interpreted as the decimal representation of a natural number.\n\nA string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.\n\nUse `String.toNat?` or `String.toNat!` to convert such a string to a natural number.\n\nExamples:\n * `\"\".isNat = false`\n * `\"0\".isNat = true`\n * `\"5\".isNat = true`\n * `\"05\".isNat = true`\n * `\"587\".isNat = true`\n * `\"-587\".isNat = false`\n * `\" 5\".isNat = false`\n * `\"2+3\".isNat = false`\n * `\"0xff\".isNat = false`\n</code>",
 "4523":
 "<code>String.toNat! (s : String) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of a natural number, returning it. Panics if the\nstring does not contain a decimal natural number.\n\nA string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.\n\nUse `String.isNat` to check whether `String.toNat!` would return a value. `String.toNat?` is a safer\nalternative that returns `none` instead of panicking when the string is not a natural number.\n\nExamples:\n * `\"0\".toNat! = 0`\n * `\"5\".toNat! = 5`\n * `\"587\".toNat! = 587`\n</code>",
 "4522":
 "<code><span class=\"literal string\">\"M |  | N\"</span> : String</code>",
 "4521": "<code><span class=\"literal string\">\"N\"</span> : String</code>",
 "4520": "<code><span class=\"literal string\">\"M\"</span> : String</code>",
 "452": "<code>NatStringBimap : Type</code>",
 "4519": "<code><span class=\"literal string\">\" | \"</span> : String</code>",
 "4518":
 "<code><span class=\"literal string\">\"tea and coffee\"</span> : String</code>",
 "4517":
 "<code><span class=\"literal string\">\" and \"</span> : String</code>",
 "4516":
 "<code><span class=\"literal string\">\"red, green, blue\"</span> : String</code>",
 "4515": "<code><span class=\"literal string\">\"red\"</span> : String</code>",
 "4514": "<code><span class=\"literal string\">\"blue\"</span> : String</code>",
 "4513": "<code><span class=\"literal string\">\"ue\"</span> : String</code>",
 "4512": "<code><span class=\"literal string\">\"l\"</span> : String</code>",
 "4511": "<code><span class=\"literal string\">\"ee\"</span> : String</code>",
 "4510": "<code><span class=\"literal string\">\"gr\"</span> : String</code>",
 "451": "<code>String.data (b : String) : List Char</code>",
 "4509":
 "<code>String.join (l : List String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Appends all the strings in a list of strings, in order.\n\nUse `String.intercalate` to place a separator string between the strings in a list.\n\nExamples:\n* `String.join [\"gr\", \"ee\", \"n\"] = \"green\"`\n* `String.join [\"b\", \"\", \"l\", \"\", \"ue\"] = \"blue\"`\n* `String.join [] = \"\"`\n</code>",
 "4508":
 "<code><span class=\"literal string\">\"abcdef\"</span> : String</code>",
 "4507": "<code><span class=\"literal string\">\"def\"</span> : String</code>",
 "4506":
 "<code>String.append (s : String) (t : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Appends two strings. Usually accessed via the `++` operator.\n\nThe internal implementation will perform destructive updates if the string is not shared.\n\nExamples:\n* `\"abc\".append \"def\" = \"abcdef\"`\n* `\"abc\" ++ \"def\" = \"abcdef\"`\n* `\"\" ++ \"\" = \"\"`\n</code>",
 "4505": "<code><span class=\"literal string\">\"𝒫\"</span> : String</code>",
 "4504":
 "<code>String.singleton (c : Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new string that contains only the character `c`.\n\nBecause strings are encoded in UTF-8, the resulting string may take multiple bytes.\n\nExamples:\n* `String.singleton 'L' = \"L\"`\n* `String.singleton ' ' = \" \"`\n* `String.singleton '\"' = \"\\\"\"`\n* `String.singleton '𝒫' = \"𝒫\"`\n</code>",
 "4503":
 "<code><span class=\"literal string\">\"This is r#\\\"literally\\\"# quoted\"</span> : String</code>",
 "4502":
 "<code><span class=\"literal string\">\"This is \\\"literally\\\" quoted\"</span> : String</code>",
 "4501":
 "<code><span class=\"literal string\">\"Write backslash in a string using '\\\\\\\\\\\\\\\\'\"</span> : String</code>",
 "4500":
 "<code><span class=\"literal string\">\"\\\\t\"</span> : String</code>",
 "450":
 "<code>Palindrome.is_palindrome (self : Palindrome) : self.text.data.reverse = self.text.data</code>",
 "45":
 "<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>",
 "4499":
 "<code>Lean.MessageData : Type</code><span class=\"sep\"></span><code class=\"docstring\">Structured message data. We use it for reporting errors, trace messages, etc. </code>",
 "4498":
 "<code><span class=\"literal string\">\"1 + 1 = \"</span> : String</code>",
 "4497": "<code>str2 : String</code>",
 "4496":
 "<code><span class=\"literal string\">\"String with a gap\"</span> : String</code>",
 "4495": "<code>str1 : String</code>",
 "4494": "<code><span class=\"literal string\">\"aaa\"</span> : String</code>",
 "4493": "<code><span class=\"literal string\">\"L∃∀N\"</span> : String</code>",
 "4492":
 "<code>List.asString (s : List Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a string that contains the characters in a list, in order.\n\nExamples:\n* `['L', '∃', '∀', 'N'].asString = \"L∃∀N\"`\n* `[].asString = \"\"`\n* `['a', 'a', 'a'].asString = \"aaa\"`\n</code>",
 "4491": "<code>List Char</code>",
 "4490":
 "<code>String.mk (data : List Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a string that contains the characters in a list, in order.\n\nExamples:\n* `['L', '∃', '∀', 'N'].asString = \"L∃∀N\"`\n* `[].asString = \"\"`\n* `['a', 'a', 'a'].asString = \"aaa\"`\n</code>",
 "449": "<code>Palindrome.text (self : Palindrome) : String</code>",
 "4489":
 "<code>String.isValidUTF8 (self : String) : self.bytes.IsValidUTF8</code><span class=\"sep\"></span><code class=\"docstring\">The bytes of the string form valid UTF-8. </code>",
 "4488":
 "<code>ByteArray.IsValidUTF8 (b : ByteArray) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A byte array is valid UTF-8 if it is of the form `List.Internal.utf8Encode m` for some `m`.\n\nNote that in order for this definition to be well-behaved it is necessary to know that this `m`\nis unique. To show this, one defines UTF-8 decoding and shows that encoding and decoding are\nmutually inverse. </code>",
 "4487":
 "<code>String.bytes (self : String) : ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">The bytes of the UTF-8 encoding of the string. Since strings have a special representation in\nthe runtime, this function actually takes linear time and space at runtime. For efficient access\nto the string's bytes, use `String.utf8ByteSize` and `String.getUTF8Byte`. </code>",
 "4486":
 "<code>self.bytes.IsValidUTF8</code><span class=\"sep\"></span><code class=\"docstring\">The bytes of the string form valid UTF-8. </code>",
 "4485":
 "<code>String.getUTF8Byte (s : String) (p : String.Pos.Raw) (h : p &lt; s.endPos) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Accesses the indicated byte in the UTF-8 encoding of a string.\n\nAt runtime, this function is implemented by efficient, constant-time code.\n</code>",
 "4484":
 "<code>ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">The bytes of the UTF-8 encoding of the string. Since strings have a special representation in\nthe runtime, this function actually takes linear time and space at runtime. For efficient access\nto the string's bytes, use `String.utf8ByteSize` and `String.getUTF8Byte`. </code>",
 "4483":
 "<code>String.ofByteArray (bytes : ByteArray) (isValidUTF8 : bytes.IsValidUTF8) : String</code>",
 "4482":
 "<code>String.utf8ByteSize (s : String) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of bytes used by the string's UTF-8 encoding.\n\nAt runtime, this function takes constant time because the byte length of strings is cached.\n</code>",
 "4481": "<code>String.prev : String → String.Pos.Raw → String.Pos.Raw</code>",
 "4480":
 "<code>String.next (s : String) (p : String.Pos.Raw) : String.Pos.Raw</code>",
 "448":
 "<code>Palindrome.ofString (text : String) (is_palindrome : text.data.reverse = text.data) : Palindrome</code>",
 "4479":
 "<code>String.ValidPos (s : String) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A `ValidPos s` is a byte offset in `s` together with a proof that this position is at a UTF-8\ncharacter boundary.\n</code>",
 "4478": "<code><span class=\"literal string\">\"'e'\"</span> : String</code>",
 "4477": "<code><span class=\"literal string\">\"e\"</span> : String</code>",
 "4476":
 "<code><span class=\"literal string\">\"'\\\\\\\"'\"</span> : String</code>",
 "4475": "<code><span class=\"literal string\">\"'L'\"</span> : String</code>",
 "4474": "<code><span class=\"literal string\">\"\\\"\"</span> : String</code>",
 "4473": "<code><span class=\"literal string\">\"L\"</span> : String</code>",
 "4472":
 "<code>Char.quote (c : Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Quotes the character to its representation as a character literal, surrounded by single quotes and\nescaped as necessary.\n\nExamples:\n * `'L'.quote = \"'L'\"`\n * `'\"'.quote = \"'\\\\\\\"'\"`\n</code>",
 "4471":
 "<code>Char.toString (c : Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a singleton string that contains only the provided character.\n\nExamples:\n* `'L'.toString = \"L\"`\n* `'\"'.toString = \"\\\"\"`\n</code>",
 "4470":
 "<code>self.val.isValidChar</code><span class=\"sep\"></span><code class=\"docstring\">The value must be a legal scalar value. </code>",
 "447": "<code>Palindrome : Type</code>",
 "4469":
 "<code>UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The underlying Unicode scalar value as a `UInt32`. </code>",
 "4468":
 "<code>Float32.ceil : Float32 → Float32</code><span class=\"sep\"></span><code class=\"docstring\">Computes the ceiling of a floating-point number, which is the smallest integer that's no smaller\nthan the given number.\n\nThis function does not reduce in the kernel. It is implemented in compiled code by the C function\n`ceilf`.\n\nExamples:\n * `Float32.ceil 1.5 = 2`\n * `Float32.ceil (-1.5) = (-1)`\n</code>",
 "4467":
 "<code>Float.ceil : Float → Float</code><span class=\"sep\"></span><code class=\"docstring\">Computes the ceiling of a floating-point number, which is the smallest integer that's no smaller\nthan the given number.\n\nThis function does not reduce in the kernel. It is implemented in compiled code by the C function\n`ceil`.\n\nExamples:\n * `Float.ceil 1.5 = 2`\n * `Float.ceil (-1.5) = (-1)`\n</code>",
 "4466":
 "<code>Float32.floor : Float32 → Float32</code><span class=\"sep\"></span><code class=\"docstring\">Computes the floor of a floating-point number, which is the largest integer that's no larger\nthan the given number.\n\nThis function does not reduce in the kernel. It is implemented in compiled code by the C function\n`floorf`.\n\nExamples:\n * `Float32.floor 1.5 = 1`\n * `Float32.floor (-1.5) = (-2)`\n</code>",
 "4465":
 "<code>Float.floor : Float → Float</code><span class=\"sep\"></span><code class=\"docstring\">Computes the floor of a floating-point number, which is the largest integer that's no larger\nthan the given number.\n\nThis function does not reduce in the kernel. It is implemented in compiled code by the C function\n`floor`.\n\nExamples:\n * `Float.floor 1.5 = 1`\n * `Float.floor (-1.5) = (-2)`\n</code>",
 "4464": "<code>Float32</code>",
 "4463": "<code>Float</code>",
 "4462":
 "<code>Float.toUInt32 : Float → UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a floating-point number to a 32-bit unsigned integer.\n\nIf the given `Float` is non-negative, truncates the value to a positive integer, rounding down and\nclamping to the range of `UInt32`. Returns `0` if the `Float` is negative or `NaN`, and returns the\nlargest `UInt32` value (i.e. `UInt32.size - 1`) if the float is larger than it.\n\nThis function does not reduce in the kernel.\n</code>",
 "4461":
 "<code>Float.toUInt64 : Float → UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a floating-point number to a 64-bit unsigned integer.\n\nIf the given `Float` is non-negative, truncates the value to a positive integer, rounding down and\nclamping to the range of `UInt64`. Returns `0` if the `Float` is negative or `NaN`, and returns the\nlargest `UInt64` value (i.e. `UInt64.size - 1`) if the float is larger than it.\n\nThis function does not reduce in the kernel.\n</code>",
 "4460": "<code>pos0 : Float</code>",
 "446": "<code>Graph : Type</code>",
 "4459": "<code>neg0 : Float</code>",
 "4458":
 "<code>Float.zero_eq_zero_plus_zero : (0.0 == 0.0 + 0.0) = true</code>",
 "4457":
 "<code>BitVec.ushiftRight {n : Nat} (x : BitVec n) (s : Nat) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">Shifts a bitvector to the right. This is a logical right shift - the high bits are filled with\nzeros.\n\nAs a numeric operation, this is equivalent to `x / 2^s`, rounding down.\n\nSMT-LIB name: `bvlshr` except this operator uses a `Nat` shift value.\n</code>",
 "4456":
 "<code>BitVec.ushiftRightRec_succ {w₁ w₂ n : Nat} (x : BitVec w₁) (y : BitVec w₂) :\n  x.ushiftRightRec y (n + 1) = x.ushiftRightRec y n &gt;&gt;&gt; (y &&& BitVec.twoPow w₂ (n + 1))</code>",
 "4455":
 "<code>BitVec.ushiftRightRec_zero {w₁ w₂ : Nat} (x : BitVec w₁) (y : BitVec w₂) :\n  x.ushiftRightRec y 0 = x &gt;&gt;&gt; (y &&& BitVec.twoPow w₂ 0)</code>",
 "4454":
 "<code>BitVec.ushiftRightRec {w₁ w₂ : Nat} (x : BitVec w₁) (y : BitVec w₂) (n : Nat) : BitVec w₁</code><span class=\"sep\"></span><code class=\"docstring\">Shifts `x` logically to the right by the first `n` bits of `y`.\n\nThe theorem `BitVec.shiftRight_eq_ushiftRightRec` proves the equivalence\nof `(x &gt;&gt;&gt; y)` and `BitVec.ushiftRightRec`.\n\nTogether with equations `BitVec.ushiftRightRec_zero` and `BitVec.ushiftRightRec_succ`,\nthis allows `BitVec.ushiftRight` to be unfolded into a circuit for bit blasting.\n</code>",
 "4453":
 "<code>BitVec.shiftRight_eq_ushiftRightRec {w₁ w₂ : Nat} (x : BitVec w₁) (y : BitVec w₂) :\n  x &gt;&gt;&gt; y = x.ushiftRightRec y (w₂ - 1)</code><span class=\"sep\"></span><code class=\"docstring\">Show that `x &gt;&gt;&gt; y` can be written in terms of `ushiftRightRec`.\nThis can be unfolded in terms of `ushiftRightRec_zero`, `ushiftRightRec_succ` for bit blasting.\n</code>",
 "4452":
 "<code>BitVec.sshiftRightRec {w₁ w₂ : Nat} (x : BitVec w₁) (y : BitVec w₂) (n : Nat) : BitVec w₁</code><span class=\"sep\"></span><code class=\"docstring\">Shifts `x` arithmetically (signed) to the right by the first `n` bits of `y`.\n\nThe theorem `BitVec.sshiftRight_eq_sshiftRightRec` proves the equivalence of `(x.sshiftRight y)` and\n`BitVec.sshiftRightRec x y`. Together with equations `BitVec.sshiftRightRec_zero`, and\n`BitVec.sshiftRightRec_succ`, this allows `BitVec.sshiftRight` to be unfolded into a circuit for\nbit blasting.\n</code>",
 "4451":
 "<code>BitVec.sshiftRight {n : Nat} (x : BitVec n) (s : Nat) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">Shifts a bitvector to the right. This is an arithmetic right shift - the high bits are filled with\nmost significant bit's value.\n\nAs a numeric operation, this is equivalent to `x.toInt &gt;&gt;&gt; s`.\n\nSMT-LIB name: `bvashr` except this operator uses a `Nat` shift value.\n</code>",
 "4450":
 "<code>BitVec.sshiftRight_eq_sshiftRightRec {w₁ w₂ i : Nat} (x : BitVec w₁) (y : BitVec w₂) :\n  (x.sshiftRight' y).getLsbD i = (x.sshiftRightRec y (w₂ - 1)).getLsbD i</code><span class=\"sep\"></span><code class=\"docstring\">Show that `x.sshiftRight y` can be written in terms of `sshiftRightRec`.\nThis can be unfolded in terms of `sshiftRightRec_zero_eq`, `sshiftRightRec_succ_eq` for bit blasting.\n</code>",
 "445": "<code>Graph.empty : Graph</code>",
 "4449":
 "<code>BitVec.shiftLeft {n : Nat} (x : BitVec n) (s : Nat) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">Shifts a bitvector to the left. The low bits are filled with zeros. As a numeric operation, this is\nequivalent to `x * 2^s`, modulo `2^n`.\n\nSMT-LIB name: `bvshl` except this operator uses a `Nat` shift value.\n</code>",
 "4448":
 "<code>BitVec.shiftLeftRec_succ {w₁ w₂ n : Nat} {x : BitVec w₁} {y : BitVec w₂} :\n  x.shiftLeftRec y (n + 1) = x.shiftLeftRec y n &lt;&lt;&lt; (y &&& BitVec.twoPow w₂ (n + 1))</code>",
 "4447":
 "<code>BitVec.shiftLeftRec_zero {w₁ w₂ : Nat} {x : BitVec w₁} {y : BitVec w₂} :\n  x.shiftLeftRec y 0 = x &lt;&lt;&lt; (y &&& BitVec.twoPow w₂ 0)</code>",
 "4446":
 "<code>BitVec.shiftLeftRec {w₁ w₂ : Nat} (x : BitVec w₁) (y : BitVec w₂) (n : Nat) : BitVec w₁</code><span class=\"sep\"></span><code class=\"docstring\">Shifts `x` to the left by the first `n` bits of `y`.\n\nThe theorem `BitVec.shiftLeft_eq_shiftLeftRec` proves the equivalence of `(x &lt;&lt;&lt; y)` and\n`BitVec.shiftLeftRec x y`.\n\nTogether with equations `BitVec.shiftLeftRec_zero` and `BitVec.shiftLeftRec_succ`, this allows\n`BitVec.shiftLeft` to be unfolded into a circuit for bit blasting.\n </code>",
 "4445":
 "<code>BitVec.shiftLeft_eq_shiftLeftRec {w₁ w₂ : Nat} (x : BitVec w₁) (y : BitVec w₂) : x &lt;&lt;&lt; y = x.shiftLeftRec y (w₂ - 1)</code><span class=\"sep\"></span><code class=\"docstring\">Show that `x &lt;&lt;&lt; y` can be written in terms of `shiftLeftRec`.\nThis can be unfolded in terms of `shiftLeftRec_zero`, `shiftLeftRec_succ` for bit blasting.\n</code>",
 "4444": "<code>BitVec w₂</code>",
 "4443": "<code>BitVec w₁</code>",
 "4442":
 "<code>BitVec.DivModState (w : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">`DivModState` is a structure that maintains the state of recursive `divrem` calls. </code>",
 "4441": "<code>BitVec.DivModState w</code>",
 "4440":
 "<code>BitVec.DivModArgs (w : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">`DivModArgs` contains the arguments to a `divrem` call which remain constant throughout\nexecution. </code>",
 "444": "<code>Graph.adjacency (self : Graph) : Array (List Nat)</code>",
 "4439": "<code>BitVec.DivModArgs w</code>",
 "4438":
 "<code>∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value[↑i])</code>",
 "4437": "<code>state 0 = a</code>",
 "4436": "<code>Nat → α</code>",
 "4435":
 "<code>BitVec.iunfoldr.{u_1} {w : Nat} {α : Type u_1} (f : Fin w → α → α × Bool) (s : α) : α × BitVec w</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a bitvector by iteratively computing a state for each bit using the function `f`,\nstarting with the initial state `s`. At each step, the prior state and the current bit index are\npassed to `f`, and it produces a bit along with the next state value. These bits are assembled into\nthe final bitvector.\n\nIt produces a sequence of state values `[s_0, s_1 .. s_w]` and a bitvector `v` where `f i s_i =\n(s_{i+1}, b_i)` and `b_i` is bit `i`th least-significant bit in `v` (e.g., `getLsb v i = b_i`).\n\nThe theorem `iunfoldr_replace` allows uses of `BitVec.iunfoldr` to be replaced with declarative\nspecifications that are easier to reason about.\n</code>",
 "4434": "<code>Fin w → α → α × Bool</code>",
 "4433":
 "<code>BitVec.smtSDiv {n : Nat} (x y : BitVec n) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">Signed division for bitvectors using the SMT-LIB using the\n[SMT-LIB convention](http://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml),\nwhere division by zero returns `BitVector.allOnes n`.\n\nSpecifically, `x.smtSDiv 0 = if x &gt;= 0 then -1 else 1`\n\nSMT-LIB name: `bvsdiv`.\n</code>",
 "4432":
 "<code>BitVec.sdiv {n : Nat} (x y : BitVec n) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">Signed T-division (using the truncating rounding convention) for bitvectors. This function obeys the\nLean convention that division by zero returns zero.\n\nExamples:\n* `(7#4).sdiv 2 = 3#4`\n* `(-9#4).sdiv 2 = -4#4`\n* `(5#4).sdiv -2 = -2#4`\n* `(-7#4).sdiv (-2) = 3#4`\n</code>",
 "4431":
 "<code>BitVec.toNat {w : Nat} (x : BitVec w) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Return the underlying `Nat` that represents a bitvector.\n\nThis is O(1) because `BitVec` is a (zero-cost) wrapper around a `Nat`.\n</code>",
 "4430": "<code>Fin w</code>",
 "443": "<code>ArraySized α length</code>",
 "4429":
 "<code>BitVec.rotateLeft {w : Nat} (x : BitVec w) (n : Nat) : BitVec w</code><span class=\"sep\"></span><code class=\"docstring\">Rotates the bits in a bitvector to the left.\n\nAll the bits of `x` are shifted to higher positions, with the top `n` bits wrapping around to fill\nthe vacated low bits.\n\nSMT-LIB name: `rotate_left`, except this operator uses a `Nat` shift amount.\n\nExample:\n * `(0b0011#4).rotateLeft 3 = 0b1001`\n</code>",
 "4428": "<code>BitVec m</code>",
 "4427": "<code>n ≤ w</code>",
 "4426":
 "<code>BitVec.truncate {w : Nat} (v : Nat) (x : BitVec w) : BitVec v</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a bitvector of length `w` into a bitvector of length `v`, padding with `0` as needed.\n\nThe specific behavior depends on the relationship between the starting width `w` and the final width\n`v`:\n * If `v &gt; w`, it is zero-extended; the high bits are padded with zeroes until the bitvector has `v`\n   bits.\n * If `v = w`, the bitvector is returned unchanged.\n * If `v &lt; w`, the high bits are truncated.\n\n`BitVec.setWidth`, `BitVec.zeroExtend`, and `BitVec.truncate` are aliases for this operation.\n\nSMT-LIB name: `zero_extend`.\n</code>",
 "4425":
 "<code>BitVec.zeroExtend {w : Nat} (v : Nat) (x : BitVec w) : BitVec v</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a bitvector of length `w` into a bitvector of length `v`, padding with `0` as needed.\n\nThe specific behavior depends on the relationship between the starting width `w` and the final width\n`v`:\n * If `v &gt; w`, it is zero-extended; the high bits are padded with zeroes until the bitvector has `v`\n   bits.\n * If `v = w`, the bitvector is returned unchanged.\n * If `v &lt; w`, the high bits are truncated.\n\n`BitVec.setWidth`, `BitVec.zeroExtend`, and `BitVec.truncate` are aliases for this operation.\n\nSMT-LIB name: `zero_extend`.\n</code>",
 "4424":
 "<code>BitVec.concat {n : Nat} (msbs : BitVec n) (lsb : Bool) : BitVec (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">Append a single bit to the end of a bitvector, using big endian order (see `append`).\nThat is, the new bit is the least significant bit. </code>",
 "4423":
 "<code>mixHash (u₁ u₂ : UInt64) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">An opaque hash mixing operation, used to implement hashing for products. </code>",
 "4422": "<code>BitVec 4</code>",
 "4421":
 "<code>BitVec.slt {n : Nat} (x y : BitVec n) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Signed less-than for bitvectors.\n\nSMT-LIB name: `bvslt`.\n\nExamples:\n* `BitVec.slt 6#4 7 = true`\n* `BitVec.slt 7#4 8 = false`\n</code>",
 "4420":
 "<code>BitVec.cast {n m : Nat} (eq : n = m) (x : BitVec n) : BitVec m</code><span class=\"sep\"></span><code class=\"docstring\">If two natural numbers `n` and `m` are equal, then a bitvector of width `n` is also a bitvector of\nwidth `m`.\n\nUsing `x.cast eq` should be preferred over `eq ▸ x` because there are special-purpose `simp` lemmas\nthat can more consistently simplify `BitVec.cast` away.\n</code>",
 "442": "<code>Array α</code>",
 "4419": "<code>i &lt; 2 ^ w</code>",
 "4418":
 "<code>BitVec.toInt {n : Nat} (x : BitVec n) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Interprets the bitvector as an integer stored in two's complement form.\n</code>",
 "4417": "<code>List Bool</code>",
 "4416": "<code>BitVec w</code>",
 "4415": "<code>BitVec n</code>",
 "4414":
 "<code>HShiftRight.hShiftRight.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HShiftRight α β γ] :\n  α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &gt;&gt;&gt; b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;&gt;` in identifiers is `shiftRight`.</code>",
 "4413": "<code>popcount_correct : popcount = popcount_spec</code>",
 "4412": "<code>popcount_spec (x : BitVec 32) : BitVec 32</code>",
 "4411": "<code>popcount (x : BitVec 32) : BitVec 32</code>",
 "4410":
 "<code>Fin (2 ^ w)</code><span class=\"sep\"></span><code class=\"docstring\">Interpret a bitvector as a number less than `2^w`.\nO(1), because we use `Fin` as the internal representation of a bitvector. </code>",
 "441":
 "<code>ArraySized.size_eq_length.{u} {α : Type u} {length : Nat} (self : ArraySized α length) : self.array.size = length</code>",
 "4409":
 "<code>BitVec.ofFin {w : Nat} (toFin : Fin (2 ^ w)) : BitVec w</code><span class=\"sep\"></span><code class=\"docstring\">Construct a `BitVec w` from a number less than `2^w`.\nO(1), because we use `Fin` as the internal representation of a bitvector. </code>",
 "4408":
 "<code>Int64.complement (a : Int64) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Bitwise complement, also known as bitwise negation, for 64-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int64.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4407":
 "<code>Int32.complement (a : Int32) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Bitwise complement, also known as bitwise negation, for 32-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int32.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4406":
 "<code>Int16.complement (a : Int16) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Bitwise complement, also known as bitwise negation, for 16-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int16.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4405":
 "<code>Int8.complement (a : Int8) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Bitwise complement, also known as bitwise negation, for 8-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int8.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4404":
 "<code>ISize.complement (a : ISize) : ISize</code><span class=\"sep\"></span><code class=\"docstring\">Bitwise complement, also known as bitwise negation, for word-sized signed integers. Usually accessed\nvia the `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `ISize.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4403":
 "<code>XorOp.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HXor`: `a ^^^ b : α` where `a b : α`. </code>",
 "4402":
 "<code>ShiftRight.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HShiftRight`: `a &gt;&gt;&gt; b : α` where `a b : α`. </code>",
 "4401":
 "<code>ShiftLeft.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HShiftLeft`: `a &lt;&lt;&lt; b : α` where `a b : α`. </code>",
 "4400":
 "<code>UInt64.log2 (a : UInt64) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Base-two logarithm of 64-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `UInt64.log2 0 = 0`\n * `UInt64.log2 1 = 0`\n * `UInt64.log2 2 = 1`\n * `UInt64.log2 4 = 2`\n * `UInt64.log2 7 = 2`\n * `UInt64.log2 8 = 3`\n</code>",
 "440":
 "<code>ArraySized.array.{u} {α : Type u} {length : Nat} (self : ArraySized α length) : Array α</code>",
 "44": "<code>thirdOfFive.{u_1} {α : Type u_1} : List α → Option α</code>",
 "4399":
 "<code>UInt32.log2 (a : UInt32) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Base-two logarithm of 32-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `UInt32.log2 0 = 0`\n * `UInt32.log2 1 = 0`\n * `UInt32.log2 2 = 1`\n * `UInt32.log2 4 = 2`\n * `UInt32.log2 7 = 2`\n * `UInt32.log2 8 = 3`\n</code>",
 "4398":
 "<code>UInt16.log2 (a : UInt16) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Base-two logarithm of 16-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `UInt16.log2 0 = 0`\n * `UInt16.log2 1 = 0`\n * `UInt16.log2 2 = 1`\n * `UInt16.log2 4 = 2`\n * `UInt16.log2 7 = 2`\n * `UInt16.log2 8 = 3`\n</code>",
 "4397":
 "<code>UInt8.log2 (a : UInt8) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Base-two logarithm of 8-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `UInt8.log2 0 = 0`\n * `UInt8.log2 1 = 0`\n * `UInt8.log2 2 = 1`\n * `UInt8.log2 4 = 2`\n * `UInt8.log2 7 = 2`\n * `UInt8.log2 8 = 3`\n</code>",
 "4396":
 "<code>USize.log2 (a : USize) : USize</code><span class=\"sep\"></span><code class=\"docstring\">Base-two logarithm of word-sized unsigned integers. Returns `⌊max 0 (log₂ a)⌋`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `USize.log2 0 = 0`\n * `USize.log2 1 = 0`\n * `USize.log2 2 = 1`\n * `USize.log2 4 = 2`\n * `USize.log2 7 = 2`\n * `USize.log2 8 = 3`\n</code>",
 "4395":
 "<code>Int64.mod (a b : Int64) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 64-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int64.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int64.mod 5 2 = 1`\n* `Int64.mod 5 (-2) = 1`\n* `Int64.mod (-5) 2 = (-1)`\n* `Int64.mod (-5) (-2) = (-1)`\n* `Int64.mod 4 2 = 0`\n* `Int64.mod 4 (-2) = 0`\n* `Int64.mod 4 0 = 4`\n* `Int64.mod (-4) 0 = (-4)`\n</code>",
 "4394":
 "<code>UInt64.mod (a b : UInt64) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 64-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the `%` operator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt64.mod 5 2 = 1`\n* `UInt64.mod 4 2 = 0`\n* `UInt64.mod 4 0 = 4`\n</code>",
 "4393":
 "<code>Int32.mod (a b : Int32) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 32-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int32.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.mod 5 2 = 1`\n* `Int32.mod 5 (-2) = 1`\n* `Int32.mod (-5) 2 = (-1)`\n* `Int32.mod (-5) (-2) = (-1)`\n* `Int32.mod 4 2 = 0`\n* `Int32.mod 4 (-2) = 0`\n* `Int32.mod 4 0 = 4`\n* `Int32.mod (-4) 0 = (-4)`\n</code>",
 "4392":
 "<code>UInt32.mod (a b : UInt32) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 32-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the `%` operator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt32.mod 5 2 = 1`\n* `UInt32.mod 4 2 = 0`\n* `UInt32.mod 4 0 = 4`\n</code>",
 "4391":
 "<code>Int16.mod (a b : Int16) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 16-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int16.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.mod 5 2 = 1`\n* `Int16.mod 5 (-2) = 1`\n* `Int16.mod (-5) 2 = (-1)`\n* `Int16.mod (-5) (-2) = (-1)`\n* `Int16.mod 4 2 = 0`\n* `Int16.mod 4 (-2) = 0`\n* `Int16.mod 4 0 = 4`\n* `Int16.mod (-4) 0 = (-4)`\n</code>",
 "4390":
 "<code>UInt16.mod (a b : UInt16) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 16-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the `%` operator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt16.mod 5 2 = 1`\n* `UInt16.mod 4 2 = 0`\n* `UInt16.mod 4 0 = 4`\n</code>",
 "439": "<code>ArraySized.{u} (α : Type u) (length : Nat) : Type u</code>",
 "4389":
 "<code>Int8.mod (a b : Int8) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 8-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int8.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.mod 5 2 = 1`\n* `Int8.mod 5 (-2) = 1`\n* `Int8.mod (-5) 2 = (-1)`\n* `Int8.mod (-5) (-2) = (-1)`\n* `Int8.mod 4 2 = 0`\n* `Int8.mod 4 (-2) = 0`\n* `Int8.mod 4 0 = 4`\n* `Int8.mod (-4) 0 = (-4)`\n</code>",
 "4388":
 "<code>UInt8.mod (a b : UInt8) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for 8-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the `%` operator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt8.mod 5 2 = 1`\n* `UInt8.mod 4 2 = 0`\n* `UInt8.mod 4 0 = 4`\n</code>",
 "4387":
 "<code>ISize.mod (a b : ISize) : ISize</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for word-sized signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `ISize.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `ISize.mod 5 2 = 1`\n* `ISize.mod 5 (-2) = 1`\n* `ISize.mod (-5) 2 = (-1)`\n* `ISize.mod (-5) (-2) = (-1)`\n* `ISize.mod 4 2 = 0`\n* `ISize.mod 4 (-2) = 0`\n* `ISize.mod 4 0 = 4`\n* `ISize.mod (-4) 0 = (-4)`\n</code>",
 "4386":
 "<code>USize.mod (a b : USize) : USize</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator for word-sized unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the `%` operator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `USize.mod 5 2 = 1`\n* `USize.mod 4 2 = 0`\n* `USize.mod 4 0 = 4`\n</code>",
 "4385":
 "<code>Int64.div (a b : Int64) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Truncating division for 64-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int64.div 10 3 = 3`\n* `Int64.div 10 (-3) = (-3)`\n* `Int64.div (-10) (-3) = 3`\n* `Int64.div (-10) 3 = (-3)`\n* `Int64.div 10 0 = 0`\n</code>",
 "4384":
 "<code>Int32.div (a b : Int32) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Truncating division for 32-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.div 10 3 = 3`\n* `Int32.div 10 (-3) = (-3)`\n* `Int32.div (-10) (-3) = 3`\n* `Int32.div (-10) 3 = (-3)`\n* `Int32.div 10 0 = 0`\n</code>",
 "4383":
 "<code>Int16.div (a b : Int16) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Truncating division for 16-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.div 10 3 = 3`\n* `Int16.div 10 (-3) = (-3)`\n* `Int16.div (-10) (-3) = 3`\n* `Int16.div (-10) 3 = (-3)`\n* `Int16.div 10 0 = 0`\n</code>",
 "4382":
 "<code>Int8.div (a b : Int8) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Truncating division for 8-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.div 10 3 = 3`\n* `Int8.div 10 (-3) = (-3)`\n* `Int8.div (-10) (-3) = 3`\n* `Int8.div (-10) 3 = (-3)`\n* `Int8.div 10 0 = 0`\n</code>",
 "4381":
 "<code>ISize.div (a b : ISize) : ISize</code><span class=\"sep\"></span><code class=\"docstring\">Truncating division for word-sized signed integers, rounding towards zero. Usually accessed via the\n`/` operator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `ISize.div 10 3 = 3`\n* `ISize.div 10 (-3) = (-3)`\n* `ISize.div (-10) (-3) = 3`\n* `ISize.div (-10) 3 = (-3)`\n* `ISize.div 10 0 = 0`\n</code>",
 "4380":
 "<code>UInt64.neg (a : UInt64) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Negation of 64-bit unsigned integers, computed modulo `UInt64.size`.\n\n`UInt64.neg a` is equivalent to `18_446_744_073_709_551_615 - a + 1`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "438": "<code>{α : Sort v} → α</code>",
 "4379":
 "<code>UInt32.neg (a : UInt32) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Negation of 32-bit unsigned integers, computed modulo `UInt32.size`.\n\n`UInt32.neg a` is equivalent to `429_4967_295 - a + 1`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4378":
 "<code>UInt16.neg (a : UInt16) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Negation of 16-bit unsigned integers, computed modulo `UInt16.size`.\n\n`UInt16.neg a` is equivalent to `65_535 - a + 1`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4377":
 "<code>UInt8.neg (a : UInt8) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Negation of 8-bit unsigned integers, computed modulo `UInt8.size`.\n\n`UInt8.neg a` is equivalent to `255 - a + 1`.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4376":
 "<code>Int64.decEq (a b : Int64) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 64-bit signed integers are equal. Usually accessed via the `DecidableEq Int64`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int64.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int64) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int64) = 7 by decide`\n</code>",
 "4375":
 "<code>UInt64.decEq (a b : UInt64) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 64-bit unsigned integers are equal. Usually accessed via the\n`DecidableEq UInt64` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `UInt64.decEq 123 123 = .isTrue rfl`\n * `(if (6 : UInt64) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : UInt64) = 7 by decide`\n</code>",
 "4374":
 "<code>Int32.decEq (a b : Int32) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 32-bit signed integers are equal. Usually accessed via the `DecidableEq Int32`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int32.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int32) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int32) = 7 by decide`\n</code>",
 "4373":
 "<code>UInt32.decEq (a b : UInt32) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 32-bit unsigned integers are equal. Usually accessed via the\n`DecidableEq UInt32` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `UInt32.decEq 123 123 = .isTrue rfl`\n * `(if (6 : UInt32) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : UInt32) = 7 by decide`\n</code>",
 "4372":
 "<code>Int16.decEq (a b : Int16) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 16-bit signed integers are equal. Usually accessed via the `DecidableEq Int16`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int16.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int16) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int16) = 7 by decide`\n</code>",
 "4371":
 "<code>UInt16.decEq (a b : UInt16) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 16-bit unsigned integers are equal. Usually accessed via the\n`DecidableEq UInt16` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `UInt16.decEq 123 123 = .isTrue rfl`\n * `(if (6 : UInt16) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : UInt16) = 7 by decide`\n</code>",
 "4370":
 "<code>Int8.decEq (a b : Int8) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 8-bit signed integers are equal. Usually accessed via the `DecidableEq Int8`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int8.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int8) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int8) = 7 by decide`\n</code>",
 "437": "<code>{α : Sort u} → α</code>",
 "4369":
 "<code>UInt8.decEq (a b : UInt8) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two 8-bit unsigned integers are equal. Usually accessed via the `DecidableEq UInt8`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `UInt8.decEq 123 123 = .isTrue rfl`\n * `(if (6 : UInt8) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : UInt8) = 7 by decide`\n</code>",
 "4368":
 "<code>ISize.decEq (a b : ISize) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two word-sized signed integers are equal. Usually accessed via the\n`DecidableEq ISize` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `ISize.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : ISize) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : ISize) = 7 by decide`\n</code>",
 "4367":
 "<code>USize.decEq (a b : USize) : Decidable (a = b)</code><span class=\"sep\"></span><code class=\"docstring\">Decides whether two word-sized unsigned integers are equal. Usually accessed via the\n`DecidableEq USize` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `USize.decEq 123 123 = .isTrue rfl`\n * `(if (6 : USize) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : USize) = 7 by decide`\n</code>",
 "4366": "<code><span class=\"literal string\">\"307\"</span> : String</code>",
 "4365": "<code><span class=\"literal string\">\"28\"</span> : String</code>",
 "4364":
 "<code>USize.repr (n : USize) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a word-sized unsigned integer into a decimal string.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `USize.repr 0 = \"0\"`\n* `USize.repr 28 = \"28\"`\n* `USize.repr 307 = \"307\"`\n</code>",
 "4363": "<code>Fin UInt64.size</code>",
 "4362": "<code>Fin UInt32.size</code>",
 "4361": "<code>Fin UInt16.size</code>",
 "4360": "<code>Fin UInt8.size</code>",
 "436":
 "<code>MyStructure.mk.{u_1, u_2} (field1 : {α : Sort u_1} → α) (field2 : {α : Sort u_2} → α) : MyStructure</code>",
 "4359": "<code>Fin USize.size</code>",
 "4358": "<code>BitVec 16</code>",
 "4357": "<code>BitVec 8</code>",
 "4356": "<code>BitVec System.Platform.numBits</code>",
 "4355":
 "<code>Int64.toBitVec (x : Int64) : BitVec 64</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `BitVec` that contains the 2's complement representation of the `Int64`.\n</code>",
 "4354":
 "<code>Int32.toBitVec (x : Int32) : BitVec 32</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `BitVec` that contains the 2's complement representation of the `Int32`.\n</code>",
 "4353":
 "<code>Int16.toBitVec (x : Int16) : BitVec 16</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `BitVec` that contains the 2's complement representation of the `Int16`.\n</code>",
 "4352":
 "<code>Int8.toBitVec (x : Int8) : BitVec 8</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `BitVec` that contains the 2's complement representation of the `Int8`.\n</code>",
 "4351":
 "<code>ISize.toBitVec (x : ISize) : BitVec System.Platform.numBits</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `BitVec` that contains the 2's complement representation of the `ISize`.\n</code>",
 "4350":
 "<code>UInt64.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of distinct values representable by `UInt64`, that is, `2^64 = 18446744073709551616`. </code>",
 "435":
 "<code>MyStructure.field2.{u_1, u_2} (self : MyStructure) {α : Sort u_2} : α</code>",
 "4349": "<code>n &lt; UInt64.size</code>",
 "4348":
 "<code>UInt32.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of distinct values representable by `UInt32`, that is, `2^32 = 4294967296`. </code>",
 "4347": "<code>n &lt; UInt32.size</code>",
 "4346":
 "<code>UInt16.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of distinct values representable by `UInt16`, that is, `2^16 = 65536`. </code>",
 "4345": "<code>n &lt; UInt16.size</code>",
 "4344":
 "<code>UInt8.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of distinct values representable by `UInt8`, that is, `2^8 = 256`. </code>",
 "4343": "<code>n &lt; UInt8.size</code>",
 "4342": "<code>n &lt; USize.size</code>",
 "4341":
 "<code>USize.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of distinct values representable by `USize`, that is, `2^System.Platform.numBits`. </code>",
 "4340": "<code>n &lt; 4294967296</code>",
 "434":
 "<code>MyStructure.field1.{u_1, u_2} (self : MyStructure) {α : Sort u_1} : α</code>",
 "4339":
 "<code>Int64.ofNat (n : Nat) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int64.ofNat 127 = 127`\n * `Int64.ofNat 2_147_483_648 = 2_147_483_648`\n * `Int64.ofNat 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807`\n * `Int64.ofNat 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n * `Int64.ofNat 18_446_744_073_709_551_618 = 0`\n</code>",
 "4338":
 "<code>UInt64.ofNat (n : Nat) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt64.ofNat 5 = 5`\n* `UInt64.ofNat 65539 = 65539`\n* `UInt64.ofNat 4_294_967_299 = 4_294_967_299`\n* `UInt64.ofNat 18_446_744_073_709_551_620 = 4`\n</code>",
 "4337":
 "<code>Int32.ofNat (n : Nat) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit signed integer, wrapping around on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.ofNat 127 = 127`\n* `Int32.ofNat 32770 = 32770`\n* `Int32.ofNat 2_147_483_647 = 2_147_483_647`\n* `Int32.ofNat 2_147_483_648 = -2_147_483_648`\n</code>",
 "4336":
 "<code>UInt32.ofNat (n : Nat) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt32.ofNat 5 = 5`\n* `UInt32.ofNat 65539 = 65539`\n* `UInt32.ofNat 4_294_967_299 = 3`\n</code>",
 "4335":
 "<code>Int16.ofNat (n : Nat) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit signed integer, wrapping around on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.ofNat 127 = 127`\n* `Int16.ofNat 32767 = 32767`\n* `Int16.ofNat 32768 = -32768`\n* `Int16.ofNat 32770 = -32766`\n</code>",
 "4334":
 "<code>UInt16.ofNat (n : Nat) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt16.ofNat 5 = 5`\n* `UInt16.ofNat 255 = 255`\n* `UInt16.ofNat 32770 = 32770`\n* `UInt16.ofNat 65537 = 1`\n</code>",
 "4333":
 "<code>Int8.ofNat (n : Nat) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit signed integer, wrapping around on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.ofNat 53 = 53`\n* `Int8.ofNat 127 = 127`\n* `Int8.ofNat 128 = -128`\n* `Int8.ofNat 255 = -1`\n</code>",
 "4332":
 "<code>UInt8.ofNat (n : Nat) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `UInt8.ofNat 5 = 5`\n* `UInt8.ofNat 255 = 255`\n* `UInt8.ofNat 256 = 0`\n* `UInt8.ofNat 259 = 3`\n* `UInt8.ofNat 32770 = 2`\n</code>",
 "4331":
 "<code>Int64.maxValue : Int64</code><span class=\"sep\"></span><code class=\"docstring\">The largest number that `Int64` can represent: `2^63 - 1 = 9223372036854775807`. </code>",
 "4330": "<code>i ≤ Int64.maxValue.toInt</code>",
 "433": "<code>MyStructure.{u_1, u_2} : Type (max u_1 u_2)</code>",
 "4329":
 "<code>Int64.toInt (i : Int64) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Converts a 64-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4328":
 "<code>Int64.minValue : Int64</code><span class=\"sep\"></span><code class=\"docstring\">The smallest number that `Int64` can represent: `-2^63 = -9223372036854775808`. </code>",
 "4327": "<code>Int64.minValue.toInt ≤ i</code>",
 "4326":
 "<code>Int32.maxValue : Int32</code><span class=\"sep\"></span><code class=\"docstring\">The largest number that `Int32` can represent: `2^31 - 1 = 2147483647`. </code>",
 "4325": "<code>i ≤ Int32.maxValue.toInt</code>",
 "4324":
 "<code>Int32.toInt (i : Int32) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Converts a 32-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4323":
 "<code>Int32.minValue : Int32</code><span class=\"sep\"></span><code class=\"docstring\">The smallest number that `Int32` can represent: `-2^31 = -2147483648`. </code>",
 "4322": "<code>Int32.minValue.toInt ≤ i</code>",
 "4321":
 "<code>Int16.maxValue : Int16</code><span class=\"sep\"></span><code class=\"docstring\">The largest number that `Int16` can represent: `2^15 - 1 = 32767`. </code>",
 "4320": "<code>i ≤ Int16.maxValue.toInt</code>",
 "432": "<code>AtLeastOne.head'.{u_1} {α : Type u_1} : AtLeastOne α → α</code>",
 "4319":
 "<code>Int16.toInt (i : Int16) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Converts a 16-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4318":
 "<code>Int16.minValue : Int16</code><span class=\"sep\"></span><code class=\"docstring\">The smallest number that `Int16` can represent: `-2^15 = -32768`. </code>",
 "4317": "<code>Int16.minValue.toInt ≤ i</code>",
 "4316":
 "<code>Int8.maxValue : Int8</code><span class=\"sep\"></span><code class=\"docstring\">The largest number that `Int8` can represent: `2^7 - 1 = 127`. </code>",
 "4315": "<code>i ≤ Int8.maxValue.toInt</code>",
 "4314":
 "<code>Int8.toInt (i : Int8) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 8-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4313":
 "<code>Int8.minValue : Int8</code><span class=\"sep\"></span><code class=\"docstring\">The smallest number that `Int8` can represent: `-2^7 = -128`. </code>",
 "4312": "<code>Int8.minValue.toInt ≤ i</code>",
 "4311":
 "<code>ISize.maxValue : ISize</code><span class=\"sep\"></span><code class=\"docstring\">The largest number that `ISize` can represent: `2^(System.Platform.numBits - 1) - 1`. </code>",
 "4310": "<code>i ≤ ISize.maxValue.toInt</code>",
 "431": "<code>oneTwoThree' : AtLeastOne Nat</code>",
 "4309":
 "<code>ISize.toInt (i : ISize) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Converts a word-sized signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n</code>",
 "4308":
 "<code>ISize.minValue : ISize</code><span class=\"sep\"></span><code class=\"docstring\">The smallest number that `ISize` can represent: `-2^(System.Platform.numBits - 1)`. </code>",
 "4307": "<code>ISize.minValue.toInt ≤ i</code>",
 "4306":
 "<code>Int64.ofInt (i : Int) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int64.ofInt 48 = 48`\n* `Int64.ofInt (-40_000) = -40_000`\n* `Int64.ofInt 2_147_483_648 = 2_147_483_648`\n* `Int64.ofInt (-2_147_483_649) = -2_147_483_649`\n* `Int64.ofInt 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n* `Int64.ofInt (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807`\n</code>",
 "4305":
 "<code>Int32.ofInt (i : Int) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.ofInt 48 = 48`\n* `Int32.ofInt (-129) = -129`\n* `Int32.ofInt 70000 = 70000`\n* `Int32.ofInt (-40000) = -40000`\n* `Int32.ofInt 2147483648 = -2147483648`\n* `Int32.ofInt (-2147483649) = 2147483647`\n</code>",
 "4304":
 "<code>Int16.ofInt (i : Int) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 16-bit signed integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.ofInt 48 = 48`\n* `Int16.ofInt (-129) = -129`\n* `Int16.ofInt (128) = 128`\n* `Int16.ofInt 70000 = 4464`\n* `Int16.ofInt (-40000) = 25536`\n</code>",
 "4303":
 "<code>Int8.ofInt (i : Int) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.ofInt 48 = 48`\n* `Int8.ofInt (-115) = -115`\n* `Int8.ofInt (-129) = 127`\n* `Int8.ofInt (128) = -128`\n</code>",
 "4302": "<code>ISize</code>",
 "4301":
 "<code>Permissions.mk (readable writable executable : Bool) : Permissions</code>",
 "4300": "<code>Permissions.decode (i : UInt8) : Permissions</code>",
 "430": "<code>AtLeastOne.head.{u_1} {α : Type u_1} : AtLeastOne α → α</code>",
 "43":
 "<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>",
 "4299": "<code>Permissions</code>",
 "4298": "<code>Permissions.encode (p : Permissions) : UInt8</code>",
 "4297": "<code>Permissions.executable (self : Permissions) : Bool</code>",
 "4296": "<code>Permissions.writable (self : Permissions) : Bool</code>",
 "4295": "<code>Permissions.readable (self : Permissions) : Bool</code>",
 "4294": "<code>Permissions : Type</code>",
 "4293":
 "<code>UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 64-bit signed integer into the 64-bit unsigned integer that is its two's complement\nencoding.\n</code>",
 "4292": "<code>Int64.ofUInt64 (toUInt64 : UInt64) : Int64</code>",
 "4291":
 "<code>UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 32-bit signed integer into the 32-bit unsigned integer that is its two's complement\nencoding.\n</code>",
 "4290": "<code>Int32.ofUInt32 (toUInt32 : UInt32) : Int32</code>",
 "429": "<code>oneTwoThree : AtLeastOne Nat</code>",
 "4289":
 "<code>UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 16-bit signed integer into the 16-bit unsigned integer that is its two's complement\nencoding.\n</code>",
 "4288": "<code>Int16.ofUInt16 (toUInt16 : UInt16) : Int16</code>",
 "4287":
 "<code>UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 8-bit signed integer into the 8-bit unsigned integer that is its two's complement\nencoding.\n</code>",
 "4286": "<code>Int8.ofUInt8 (toUInt8 : UInt8) : Int8</code>",
 "4285":
 "<code>USize</code><span class=\"sep\"></span><code class=\"docstring\">Converts a word-sized signed integer into the word-sized unsigned integer that is its two's\ncomplement encoding.\n</code>",
 "4284": "<code>ISize.ofUSize (toUSize : USize) : ISize</code>",
 "4283":
 "<code>BitVec 64</code><span class=\"sep\"></span><code class=\"docstring\">Unpacks a `UInt64` into a `BitVec 64`. This function is overridden with a native implementation.\n</code>",
 "4282":
 "<code>UInt64.ofBitVec (toBitVec : BitVec 64) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `UInt64` from a `BitVec 64`. This function is overridden with a native implementation.\n</code>",
 "4281":
 "<code>BitVec 32</code><span class=\"sep\"></span><code class=\"docstring\">Unpacks a `UInt32` into a `BitVec 32`. This function is overridden with a native implementation.\n</code>",
 "4280":
 "<code>UInt32.ofBitVec (toBitVec : BitVec 32) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `UInt32` from a `BitVec 32`. This function is overridden with a native implementation.\n</code>",
 "428":
 "<code>AtLeastOne.mk.{u} {α : Type u} : α → Option (AtLeastOne α) → AtLeastOne α</code>",
 "4279":
 "<code>BitVec 16</code><span class=\"sep\"></span><code class=\"docstring\">Unpacks a `UInt16` into a `BitVec 16`. This function is overridden with a native implementation.\n</code>",
 "4278":
 "<code>UInt16.ofBitVec (toBitVec : BitVec 16) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `UInt16` from a `BitVec 16`. This function is overridden with a native implementation.\n</code>",
 "4277":
 "<code>BitVec 8</code><span class=\"sep\"></span><code class=\"docstring\">Unpacks a `UInt8` into a `BitVec 8`. This function is overridden with a native implementation.\n</code>",
 "4276":
 "<code>UInt8.ofBitVec (toBitVec : BitVec 8) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `UInt8` from a `BitVec 8`. This function is overridden with a native implementation.\n</code>",
 "4275":
 "<code>BitVec System.Platform.numBits</code><span class=\"sep\"></span><code class=\"docstring\">Unpacks a `USize` into a `BitVec System.Platform.numBits`. This function is overridden with a native\nimplementation.\n</code>",
 "4274":
 "<code>System.Platform.numBits : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The word size of the current platform, which may be 64 or 32 bits.\n</code>",
 "4273":
 "<code>USize.ofBitVec (toBitVec : BitVec System.Platform.numBits) : USize</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `USize` from a `BitVec System.Platform.numBits`. This function is overridden with a\nnative implementation.\n</code>",
 "4272":
 "<code>Fin.succRec.{u_1} {motive : (n : Nat) → Fin n → Sort u_1} (zero : (n : Nat) → motive n.succ 0)\n  (succ : (n : Nat) → (i : Fin n) → motive n i → motive n.succ i.succ) {n : Nat} (i : Fin n) : motive n i</code><span class=\"sep\"></span><code class=\"docstring\">An induction principle for `Fin` that considers a given `i : Fin n` as given by a sequence of `i`\napplications of `Fin.succ`.\n\nThe cases in the induction are:\n * `zero` demonstrates the motive for `(0 : Fin (n + 1))` for all bounds `n`\n * `succ` demonstrates the motive for `Fin.succ` applied to an arbitrary `Fin` for an arbitrary\n   bound `n`\n\nUnlike `Fin.induction`, the motive quantifies over the bound, and the bound varies at each inductive\nstep. `Fin.succRecOn` is a version of this induction principle that takes the `Fin` argument first.\n</code>",
 "4271": "<code>(n : Nat) → motive (n + 1) 0</code>",
 "4270":
 "<code>Fin.succRecOn.{u_1} {n : Nat} (i : Fin n) {motive : (n : Nat) → Fin n → Sort u_1} (zero : (n : Nat) → motive (n + 1) 0)\n  (succ : (n : Nat) → (i : Fin n) → motive n i → motive n.succ i.succ) : motive n i</code><span class=\"sep\"></span><code class=\"docstring\">An induction principle for `Fin` that considers a given `i : Fin n` as given by a sequence of `i`\napplications of `Fin.succ`.\n\nThe cases in the induction are:\n * `zero` demonstrates the motive for `(0 : Fin (n + 1))` for all bounds `n`\n * `succ` demonstrates the motive for `Fin.succ` applied to an arbitrary `Fin` for an arbitrary\n   bound `n`\n\nUnlike `Fin.induction`, the motive quantifies over the bound, and the bound varies at each inductive\nstep. `Fin.succRec` is a version of this induction principle that takes the `Fin` argument last.\n</code>",
 "427": "<code>AtLeastOne.{u} (α : Type u) : Type u</code>",
 "4269":
 "<code>(n : Nat) → (i : Fin n) → motive n i → motive n.succ i.succ</code>",
 "4268": "<code>(n : Nat) → motive n.succ 0</code>",
 "4267": "<code>(n : Nat) → Fin n → Sort u_1</code>",
 "4266": "<code>Fin (m + n)</code>",
 "4265": "<code>(i : Fin n) → motive (Fin.natAdd m i)</code>",
 "4264": "<code>(i : Fin m) → motive (Fin.castAdd n i)</code>",
 "4263": "<code>Fin (m + n) → Sort u</code>",
 "4262": "<code>(i : Fin n) → motive i.castSucc</code>",
 "4261": "<code>(i : Fin n) → motive i.succ</code>",
 "4260":
 "<code>_root_.cast.{u} {α β : Sort u} (h : α = β) (a : α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Cast across a type equality. If `h : α = β` is an equality of types, and\n`a : α`, then `a : β` will usually not typecheck directly, but this function\nwill allow you to work around this and embed `a` in type `β` as `cast h a : β`.\n\nIt is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "426":
 "<code>Either''.right.{u, v} {β : Type v} {α : Type u} : β → Either'' α β</code>",
 "4259": "<code>(i : Fin n) → motive i.succ → motive i.castSucc</code>",
 "4258": "<code>motive (Fin.last n)</code>",
 "4257":
 "<code>Fin.reverseInduction.{u_1} {n : Nat} {motive : Fin (n + 1) → Sort u_1} (last : motive (Fin.last n))\n  (cast : (i : Fin n) → motive i.succ → motive i.castSucc) (i : Fin (n + 1)) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by reverse induction on the underlying `Nat` value in a `Fin (n + 1)`.\n\nFor the induction:\n* `last` is the base case, demonstrating `motive (Fin.last n)`.\n* `cast` is the inductive step, assuming the motive for `(j : Fin n).succ` and demonstrating it for\n   the predecessor `j.castSucc`.\n\n`Fin.induction` is the non-reverse induction principle.\n</code>",
 "4256":
 "<code>Fin.cases.{u_1} {n : Nat} {motive : Fin (n + 1) → Sort u_1} (zero : motive 0) (succ : (i : Fin n) → motive i.succ)\n  (i : Fin (n + 1)) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by cases on the underlying `Nat` value in a `Fin (n + 1)`.\n\nThe two cases are:\n* `zero`, used when the value is of the form `(0 : Fin (n + 1))`\n* `succ`, used when the value is of the form `(j : Fin n).succ`\n\nThe corresponding induction principle is `Fin.induction`.\n</code>",
 "4255":
 "<code>Fin.inductionOn.{u_1} {n : Nat} (i : Fin (n + 1)) {motive : Fin (n + 1) → Sort u_1} (zero : motive 0)\n  (succ : (i : Fin n) → motive i.castSucc → motive i.succ) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by induction on the underlying `Nat` value in a `Fin (n + 1)`.\n\nFor the induction:\n * `zero` is the base case, demonstrating `motive 0`.\n * `succ` is the inductive step, assuming the motive for `i : Fin n` (lifted to `Fin (n + 1)` with\n   `Fin.castSucc`) and demonstrating it for `i.succ`.\n\n`Fin.induction` is a version of this induction principle that takes the `Fin` as its last\nparameter.\n</code>",
 "4254": "<code>Fin (n + 1) → Sort u_1</code>",
 "4253": "<code>P i</code>",
 "4252": "<code>i ≤ n</code>",
 "4251":
 "<code>Fin.hIterateFrom.{u_1} (P : Nat → Sort u_1) {n : Nat} (f : (i : Fin n) → P ↑i → P (↑i + 1)) (i : Nat) (ubnd : i ≤ n)\n  (a : P i) : P n</code><span class=\"sep\"></span><code class=\"docstring\">Applies an index-dependent function `f` to all of the values in `[i:n]`, starting at `i` with an\ninitial accumulator `a`.\n\nConcretely, `Fin.hIterateFrom P f i a` is equal to\n```lean\n  a |&gt; f i |&gt; f (i + 1) |&gt; ... |&gt; f (n - 1)\n```\n\nTheorems about `Fin.hIterateFrom` can be proven using the general theorem `Fin.hIterateFrom_elim` or\nother more specialized theorems.\n\n`Fin.hIterate` is a variant that always starts at `0`.\n</code>",
 "4250":
 "<code>Fin.hIterate_elim.{u_1} {P : Nat → Sort u_1} (Q : (i : Nat) → P i → Prop) {n : Nat}\n  (f : (i : Fin n) → P ↑i → P (↑i + 1)) (s : P 0) (init : Q 0 s)\n  (step : ∀ (k : Fin n) (s : P ↑k), Q (↑k) s → Q (↑k + 1) (f k s)) : Q n (Fin.hIterate P s f)</code>",
 "425":
 "<code>Either''.left.{u, v} {α : Type u} {β : Type v} : α → Either'' α β</code>",
 "4249":
 "<code>Fin.hIterate.{u_1} (P : Nat → Sort u_1) {n : Nat} (init : P 0) (f : (i : Fin n) → P ↑i → P (↑i + 1)) : P n</code><span class=\"sep\"></span><code class=\"docstring\">Applies an index-dependent function to all the values less than the given bound `n`, starting at\n`0` with an accumulator.\n\nConcretely, `Fin.hIterate P init f` is equal to\n```lean\n  init |&gt; f 0 |&gt; f 1 |&gt; ... |&gt; f (n-1)\n```\n\nTheorems about `Fin.hIterate` can be proven using the general theorem `Fin.hIterate_elim` or other more\nspecialized theorems.\n\n`Fin.hIterateFrom` is a variant that takes a custom starting value instead of `0`.\n </code>",
 "4248": "<code>(i : Fin n) → P ↑i → P (↑i + 1)</code>",
 "4247": "<code>P 0</code>",
 "4246": "<code>α → Fin n → m α</code>",
 "4245":
 "<code>Fin.foldl.{u_1} {α : Sort u_1} (n : Nat) (f : α → Fin n → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Combine all the values that can be represented by `Fin n` with an initial value, starting at `0` and\nnesting to the left.\n\nExample:\n * `Fin.foldl 3 (· + ·.val) (0 : Nat) = ((0 + (0 : Fin 3).val) + (1 : Fin 3).val) + (2 : Fin 3).val`\n</code>",
 "4244": "<code>α → Fin n → α</code>",
 "4243": "<code>Fin n → α → m α</code>",
 "4242":
 "<code>Fin.foldr.{u_1} {α : Sort u_1} (n : Nat) (f : Fin n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Combine all the values that can be represented by `Fin n` with an initial value, starting at `n - 1`\nand nesting to the right.\n\nExample:\n * `Fin.foldr 3 (·.val + ·) (0 : Nat) = (0 : Fin 3).val + ((1 : Fin 3).val + ((2 : Fin 3).val + 0))`\n</code>",
 "4241": "<code>Fin n → α → α</code>",
 "4240":
 "<code>Fin.rev {n : Nat} (i : Fin n) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Replaces a value with its difference from the largest value in the type.\n\nConsidering the values of `Fin n` as a sequence `0`, `1`, …, `n-2`, `n-1`, `Fin.rev` finds the\ncorresponding element of the reversed sequence. In other words, it maps `0` to `n-1`, `1` to `n-2`,\n..., and `n-1` to `0`.\n\nExamples:\n * `(5 : Fin 6).rev = (0 : Fin 6)`\n * `(0 : Fin 6).rev = (5 : Fin 6)`\n * `(2 : Fin 5).rev = (2 : Fin 5)`\n</code>",
 "424": "<code>Either''.{u, v} : Type u → Type v → Type ((max u v) + 1)</code>",
 "4239":
 "<code>Fin.castLE {n m : Nat} (h : n ≤ m) (i : Fin n) : Fin m</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound to one at least as large.\n\nSee also `Fin.castAdd` for a version that represents the larger bound with addition rather than an\nexplicit inequality proof.\n</code>",
 "4238":
 "<code>Fin.castAdd {n : Nat} (m : Nat) : Fin n → Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound to one at least as large.\n\nSee also `Fin.natAdd` and `Fin.addNat` for addition functions that increase the bound, and\n`Fin.castLE` for a version that uses an explicit inequality proof.\n</code>",
 "4237": "<code>n ≤ m</code>",
 "4236": "<code>val✝ &lt; 10</code>",
 "4235":
 "<code>Fin.castLT {n m : Nat} (i : Fin m) (h : ↑i &lt; n) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the bound with another that is suitable for the value.\n\nThe proof embedded in `i` can be used to cast to a larger bound even if the concrete value is not\nknown.\n\nExamples:\n```lean example\nexample : Fin 12 := (7 : Fin 10).castLT (by decide : 7 &lt; 12)\n```\n```lean example\nexample (i : Fin 10) : Fin 12 :=\n  i.castLT &lt;| by\n    cases i; simp; omega\n```\n</code>",
 "4234": "<code>↑i &lt; n</code>",
 "4233":
 "<code>Fin.cast {n m : Nat} (eq : n = m) (i : Fin n) : Fin m</code><span class=\"sep\"></span><code class=\"docstring\">Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other.\n\nIn other words, when `eq : n = m`, `Fin.cast eq i` converts `i : Fin n` into a `Fin m`.\n</code>",
 "4232": "<code>n = m</code>",
 "4231": "<code>Fin 17</code>",
 "4230": "<code>Fin 16</code>",
 "423": "<code>Type u → Type v → Type (max u v)</code>",
 "4229":
 "<code>Fin.log2 {m : Nat} (n : Fin m) : Fin m</code><span class=\"sep\"></span><code class=\"docstring\">Logarithm base 2 for bounded numbers.\n\nThe resulting value is the same as that computed by `Nat.log2`. In particular, the result for `0` is\n`0`.\n\nExamples:\n * `(8 : Fin 10).log2 = (3 : Fin 10)`\n * `(7 : Fin 10).log2 = (2 : Fin 10)`\n * `(4 : Fin 10).log2 = (2 : Fin 10)`\n * `(3 : Fin 10).log2 = (1 : Fin 10)`\n * `(1 : Fin 10).log2 = (0 : Fin 10)`\n * `(0 : Fin 10).log2 = (0 : Fin 10)`\n</code>",
 "4228": "<code>Fin 6</code>",
 "4227":
 "<code>Fin.subNat {n : Nat} (m : Nat) (i : Fin (n + m)) (h : m ≤ ↑i) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Subtraction of a natural number from a `Fin`, with the bound narrowed.\n\nThis is a generalization of `Fin.pred`. It is guaranteed to not underflow or wrap around.\n\nExamples:\n* `(5 : Fin 9).subNat 2 (by decide) = (3 : Fin 7)`\n* `(5 : Fin 9).subNat 0 (by decide) = (5 : Fin 9)`\n* `(3 : Fin 9).subNat 3 (by decide) = (0 : Fin 6)`\n</code>",
 "4226": "<code>m ≤ ↑i</code>",
 "4225": "<code>Fin (n + m)</code>",
 "4224": "<code>Fin 9</code>",
 "4223":
 "<code>Fin.addNat {n : Nat} (i : Fin n) (m : Nat) : Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a natural number to a `Fin`, increasing the bound.\n\nThis is a generalization of `Fin.succ`.\n\n`Fin.natAdd` is a version of this function that takes its `Nat` parameter first.\n\nExamples:\n* `Fin.addNat (5 : Fin 8) 3 = (8 : Fin 11)`\n* `Fin.addNat (0 : Fin 8) 1 = (1 : Fin 9)`\n* `Fin.addNat (1 : Fin 8) 2 = (3 : Fin 10)`\n\n</code>",
 "4222": "<code>Fin m</code>",
 "4221":
 "<code>Fin.natAdd {m : Nat} (n : Nat) (i : Fin m) : Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a natural number to a `Fin`, increasing the bound.\n\nThis is a generalization of `Fin.succ`.\n\n`Fin.addNat` is a version of this function that takes its `Nat` parameter second.\n\nExamples:\n* `Fin.natAdd 3 (5 : Fin 8) = (8 : Fin 11)`\n* `Fin.natAdd 1 (0 : Fin 8) = (1 : Fin 9)`\n* `Fin.natAdd 1 (2 : Fin 8) = (3 : Fin 9)`\n</code>",
 "4220": "<code>Fin 1</code>",
 "422": "<code>Type u → Type v → Type (max u v)</code>",
 "4219":
 "<code>Fin.pred {n : Nat} (i : Fin (n + 1)) (h : i ≠ 0) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">The predecessor of a non-zero element of `Fin (n+1)`, with the bound decreased.\n\nExamples:\n* `(4 : Fin 8).pred (by decide) = (3 : Fin 7)`\n* `(1 : Fin 2).pred (by decide) = (0 : Fin 1)`\n</code>",
 "4218": "<code>Fin 8</code>",
 "4217": "<code>i ≠ 0</code>",
 "4216": "<code>Fin 4</code>",
 "4215":
 "<code>Fin.last (n : Nat) : Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">The greatest value of `Fin (n+1)`, namely `n`.\n\nExamples:\n* `Fin.last 4 = (4 : Fin 5)`\n* `(Fin.last 0).val = (0 : Nat)`\n</code>",
 "4214": "<code>Fin 0</code>",
 "4213":
 "<code>NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A type-class version of `n ≠ 0`.  </code>",
 "4212": "<code>Fin 20</code>",
 "4211": "<code>Fin 3</code>",
 "4210":
 "<code>↑self &lt; n</code><span class=\"sep\"></span><code class=\"docstring\">The number `val` is strictly less than the bound `n`.\n</code>",
 "421":
 "<code>Either.right.{u, v} {α : Type u} {β : Type v} : β → Either α β</code>",
 "4209":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number that is strictly less than `n`.\n\n`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.\n</code>",
 "4208":
 "<code>Int.NonNeg : Int → Prop</code><span class=\"sep\"></span><code class=\"docstring\">An integer is non-negative if it is equal to a natural number.\n</code>",
 "4207":
 "<code>Int.fmod : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer modulus using the F-rounding convention.\n\nIn the F-rounding convention (flooring division), `Int.fdiv x y` satisfies `Int.fdiv x y = ⌊x / y⌋`\nand `Int.fmod` is the unique function satisfying `Int.fmod x y + (Int.fdiv x y) * y = x`.\n\nExamples:\n\n* `(7 : Int).fmod (0 : Int) = 7`\n* `(0 : Int).fmod (7 : Int) = 0`\n\n* `(12 : Int).fmod (6 : Int) = 0`\n* `(12 : Int).fmod (-6 : Int) = 0`\n* `(-12 : Int).fmod (6 : Int) = 0`\n* `(-12 : Int).fmod (-6 : Int) = 0`\n\n* `(12 : Int).fmod (7 : Int) = 5`\n* `(12 : Int).fmod (-7 : Int) = -2`\n* `(-12 : Int).fmod (7 : Int) = 2`\n* `(-12 : Int).fmod (-7 : Int) = -5`\n\n</code>",
 "4206":
 "<code>Int.bmod (x : Int) (m : Nat) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Balanced modulus.\n\nThis version of integer modulus uses the balanced rounding convention, which guarantees that\n`-m / 2 ≤ Int.bmod x m &lt; m/2` for `m ≠ 0` and `Int.bmod x m` is congruent to `x` modulo `m`.\n\nIf `m = 0`, then `Int.bmod x m = x`.\n\nExamples:\n* `(7 : Int).bmod 0 = 7`\n* `(0 : Int).bmod 7 = 0`\n* `(12 : Int).bmod 6 = 0`\n* `(12 : Int).bmod 7 = -2`\n* `(12 : Int).bmod 8 = -4`\n* `(12 : Int).bmod 9 = 3`\n* `(-12 : Int).bmod 6 = 0`\n* `(-12 : Int).bmod 7 = 2`\n* `(-12 : Int).bmod 8 = -4`\n* `(-12 : Int).bmod 9 = -3`\n</code>",
 "4205":
 "<code>Int.tmod : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer modulo using the T-rounding convention.\n\nIn [the T-rounding convention][t-rounding] (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0 and `Int.tmod a 0 = a`.\n\nIn this convention, `Int.tmod a b + b * (Int.tdiv a b) = a`. Additionally,\n`Int.natAbs (Int.tmod a b) = Int.natAbs a % Int.natAbs b`, and when `b` does not divide `a`,\n`Int.tmod a b` has the same sign as `a`.\n\n[t-rounding]: https://dl.acm.org/doi/pdf/10.1145/128861.128862\n\nThis function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.\n\nExamples:\n* `(7 : Int).tmod (0 : Int) = 7`\n* `(0 : Int).tmod (7 : Int) = 0`\n* `(12 : Int).tmod (6 : Int) = 0`\n* `(12 : Int).tmod (-6 : Int) = 0`\n* `(-12 : Int).tmod (6 : Int) = 0`\n* `(-12 : Int).tmod (-6 : Int) = 0`\n* `(12 : Int).tmod (7 : Int) = 5`\n* `(12 : Int).tmod (-7 : Int) = 5`\n* `(-12 : Int).tmod (7 : Int) = -5`\n* `(-12 : Int).tmod (-7 : Int) = -5`\n</code>",
 "4204":
 "<code>Int.emod : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer modulus that uses the E-rounding convention. Usually accessed via the `%` operator.\n\nIn the E-rounding convention (Euclidean division), `Int.emod x y` satisfies `0 ≤ Int.emod x y &lt; Int.natAbs y`\nfor `y ≠ 0` and `Int.ediv` is the unique function satisfying `Int.emod x y + (Int.ediv x y) * y = x`\nfor `y ≠ 0`.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n* `(7 : Int) % (0 : Int) = 7`\n* `(0 : Int) % (7 : Int) = 0`\n* `(12 : Int) % (6 : Int) = 0`\n* `(12 : Int) % (-6 : Int) = 0`\n* `(-12 : Int) % (6 : Int) = 0`\n* `(-12 : Int) % (-6 : Int) = 0`\n* `(12 : Int) % (7 : Int) = 5`\n* `(12 : Int) % (-7 : Int) = 5`\n* `(-12 : Int) % (7 : Int) = 2`\n* `(-12 : Int) % (-7 : Int) = 2`\n</code>",
 "4203":
 "<code>Mod.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HMod`: `a % b : α` where `a b : α`. </code>",
 "4202":
 "<code>Int.lcm (m n : Int) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the least common multiple of two integers as a natural number. The LCM of two integers is\nthe smallest natural number that's evenly divisible by the absolute values of both.\n\nExamples:\n * `Int.lcm 9 6 = 18`\n * `Int.lcm 9 (-6) = 18`\n * `Int.lcm 9 3 = 9`\n * `Int.lcm 9 (-3) = 9`\n * `Int.lcm 0 3 = 0`\n * `Int.lcm (-3) 0 = 0`\n</code>",
 "4201":
 "<code>Int.gcd (m n : Int) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the greatest common divisor of two integers as a natural number. The GCD of two integers is\nthe largest natural number that evenly divides both. However, the GCD of a number and `0` is the\nnumber's absolute value.\n\nThis implementation uses `Nat.gcd`, which is overridden in both the kernel and the compiler to\nefficiently evaluate using arbitrary-precision arithmetic.\n\nExamples:\n* `Int.gcd 10 15 = 5`\n* `Int.gcd 10 (-15) = 5`\n* `Int.gcd (-6) (-9) = 3`\n* `Int.gcd 0 5 = 5`\n* `Int.gcd (-7) 0 = 7`\n</code>",
 "4200":
 "<code>Int.negOfNat : Nat → Int</code><span class=\"sep\"></span><code class=\"docstring\">Negation of natural numbers.\n\nExamples:\n* `Int.negOfNat 6 = -6`\n* `Int.negOfNat 0 = 0`\n</code>",
 "420":
 "<code>Either.left.{u, v} {α : Type u} {β : Type v} : α → Either α β</code>",
 "42":
 "<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>",
 "4199":
 "<code>Int.neg (n : Int) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Negation of integers, usually accessed via the `-` prefix operator.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `-(6 : Int) = -6`\n * `-(-6 : Int) = 6`\n * `(12 : Int).neg = -12`\n</code>",
 "4198":
 "<code>Int.toInt64 (i : Int) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int.toInt64 48 = 48`\n* `Int.toInt64 (-40_000) = -40_000`\n* `Int.toInt64 2_147_483_648 = 2_147_483_648`\n* `Int.toInt64 (-2_147_483_649) = -2_147_483_649`\n* `Int.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n* `Int.toInt64 (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807`\n</code>",
 "4197":
 "<code>Int.toInt32 (i : Int) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt32 48 = 48`\n* `Int.toInt32 (-129) = -129`\n* `Int.toInt32 70000 = 70000`\n* `Int.toInt32 (-40000) = -40000`\n* `Int.toInt32 2147483648 = -2147483648`\n* `Int.toInt32 (-2147483649) = 2147483647`\n</code>",
 "4196":
 "<code>Int.toInt16 (i : Int) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 16-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt16 48 = 48`\n* `Int.toInt16 (-129) = -129`\n* `Int.toInt16 (128) = 128`\n* `Int.toInt16 70000 = 4464`\n* `Int.toInt16 (-40000) = 25536`\n</code>",
 "4195":
 "<code>Int.toInt8 (i : Int) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt8 48 = 48`\n* `Int.toInt8 (-115) = -115`\n* `Int.toInt8 (-129) = 127`\n* `Int.toInt8 (128) = -128`\n</code>",
 "4194":
 "<code>Int.toNat? : Int → Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Converts an integer into a natural number. Returns `none` for negative numbers.\n\nExamples:\n* `(7 : Int).toNat? = some 7`\n* `(0 : Int).toNat? = some 0`\n* `(-7 : Int).toNat? = none`\n</code>",
 "4193":
 "<code>Int.toNat : Int → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Converts an integer into a natural number. Negative numbers are converted to `0`.\n\nExamples:\n* `(7 : Int).toNat = 7`\n* `(0 : Int).toNat = 0`\n* `(-7 : Int).toNat = 0`\n</code>",
 "4192":
 "<code>Int.sign : Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Returns the “sign” of the integer as another integer:\n* `1` for positive numbers,\n* `-1` for negative numbers, and\n* `0` for `0`.\n\nExamples:\n* `Int.sign 34 = 1`\n* `Int.sign 2 = 1`\n* `Int.sign 0 = 0`\n* `Int.sign -1 = -1`\n* `Int.sign -362 = -1`\n</code>",
 "4191":
 "<code>Int.negSucc : Nat → Int</code><span class=\"sep\"></span><code class=\"docstring\">The negation of the successor of a natural number is an integer.\n\nThis constructor covers the negative integers (from `-1` to `-∞`).\n</code>",
 "4190": "<code>(n : Nat) → (n &gt; 0 → motive (n / 2)) → motive n</code>",
 "419": "<code class=\"docstring\">The maximum of two universes.</code>",
 "4189": "<code>(x y : Nat) → ¬(0 &lt; y ∧ y ≤ x) → motive x y</code>",
 "4188":
 "<code>(x y : Nat) → 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y</code>",
 "4187": "<code>Nat → Nat → Sort u</code>",
 "4186":
 "<code>(n : Nat) → ((m : Nat) → m ≤ n → motive m) → motive n.succ</code>",
 "4185":
 "<code>(n : Nat) → ((m : Nat) → m &lt; n → motive m) → motive n</code>",
 "4184": "<code>(n : Nat) → motive (n + 1)</code>",
 "4183": "<code>(n : Nat) → motive n → motive (n + 1)</code>",
 "4182":
 "<code>Nat.superDigitChar (n : Nat) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number less than `10` to the corresponding Unicode superscript digit character.\nReturns `'*'` for other numbers.\n\nExamples:\n* `Nat.superDigitChar 3 = '³'`\n* `Nat.superDigitChar 7 = '⁷'`\n* `Nat.superDigitChar 10 = '*'`\n</code>",
 "4181":
 "<code>Nat.subDigitChar (n : Nat) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number less than `10` to the corresponding Unicode subscript digit character.\nReturns `'*'` for other numbers.\n\nExamples:\n* `Nat.subDigitChar 3 = '₃'`\n* `Nat.subDigitChar 7 = '₇'`\n* `Nat.subDigitChar 10 = '*'`\n</code>",
 "4180":
 "<code>Nat.toSubDigits (n : Nat) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to the list of Unicode subscript digit characters that corresponds to\nits decimal representation.\n\nExamples:\n * `Nat.toSubDigits 0 = ['₀']`\n * `Nat.toSubDigits 35 = ['₃', '₅']`\n</code>",
 "418": "<code>Either.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code>",
 "4179":
 "<code>Nat.toSuperDigits (n : Nat) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to the list of Unicode superscript digit characters that corresponds to\nits decimal representation.\n\nExamples:\n * `Nat.toSuperDigits 0 = ['⁰']`\n * `Nat.toSuperDigits 35 = ['³', '⁵']`\n</code>",
 "4178": "<code><span class=\"literal string\">\"³⁵\"</span> : String</code>",
 "4177": "<code><span class=\"literal string\">\"⁰\"</span> : String</code>",
 "4176":
 "<code>Nat.toSuperscriptString (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a string that contains the its decimal representation as Unicode\nsuperscript digit characters.\n\nExamples:\n * `Nat.toSuperscriptString 0 = \"⁰\"`\n * `Nat.toSuperscriptString 35 = \"³⁵\"`\n</code>",
 "4175": "<code><span class=\"literal string\">\"₃₅\"</span> : String</code>",
 "4174": "<code><span class=\"literal string\">\"₀\"</span> : String</code>",
 "4173":
 "<code>Nat.toSubscriptString (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a string that contains the its decimal representation as Unicode\nsubscript digit characters.\n\nExamples:\n * `Nat.toSubscriptString 0 = \"₀\"`\n * `Nat.toSubscriptString 35 = \"₃₅\"`\n</code>",
 "4172":
 "<code>Nat.digitChar (n : Nat) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns a single digit representation of `n`, which is assumed to be in a base less than or equal to\n`16`. Returns `'*'` if `n &gt; 15`.\n\nExamples:\n * `Nat.digitChar 5 = '5'`\n * `Nat.digitChar 12 = 'c'`\n * `Nat.digitChar 15 = 'f'`\n * `Nat.digitChar 16 = '*'`\n * `Nat.digitChar 85 = '*'`\n</code>",
 "4171":
 "<code>Nat.toDigits (base n : Nat) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the decimal representation of a natural number as a list of digit characters in the given\nbase. If the base is greater than `16` then `'*'` is returned for digits greater than `0xf`.\n\nExamples:\n* `Nat.toDigits 10 0xff = ['2', '5', '5']`\n* `Nat.toDigits 8 0xc = ['1', '4']`\n* `Nat.toDigits 16 0xcafe = ['c', 'a', 'f', 'e']`\n* `Nat.toDigits 80 200 = ['2', '*']`\n</code>",
 "4170": "<code>Int64</code>",
 "417":
 "<code>Bool.not : Bool → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean negation, also known as Boolean complement. `not x` can be written `!x`.\n\nThis is a function that maps the value `true` to `false` and the value `false` to `true`. The\npropositional connective is `Not : Prop → Prop`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `!` in identifiers is `not`.</code>",
 "4169":
 "<code>Nat.toInt64 (n : Nat) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt64 127 = 127`\n * `Nat.toInt64 2_147_483_648 = 2_147_483_648`\n * `Nat.toInt64 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807`\n * `Nat.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n * `Nat.toInt64 18_446_744_073_709_551_618 = 0`\n</code>",
 "4168": "<code>Int32</code>",
 "4167":
 "<code>Nat.toInt32 (n : Nat) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt32 127 = 127`\n * `Nat.toInt32 32770 = 32770`\n * `Nat.toInt32 2_147_483_647 = 2_147_483_647`\n * `Nat.toInt32 2_147_483_648 = -2_147_483_648`\n</code>",
 "4166":
 "<code>Int32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Signed 32-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 32-bit value.\n</code>",
 "4165": "<code>Int16</code>",
 "4164":
 "<code>Nat.toInt16 (n : Nat) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt16 127 = 127`\n * `Nat.toInt16 32767 = 32767`\n * `Nat.toInt16 32768 = -32768`\n * `Nat.toInt16 32770 = -32766`\n</code>",
 "4163":
 "<code>Int16 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Signed 16-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 16-bit value.\n</code>",
 "4162": "<code>Int8</code>",
 "4161":
 "<code>Nat.toInt8 (n : Nat) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt8 53 = 53`\n * `Nat.toInt8 127 = 127`\n * `Nat.toInt8 128 = -128`\n * `Nat.toInt8 255 = -1`\n</code>",
 "4160":
 "<code>Nat.toUInt64 (n : Nat) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Nat.toUInt64 5 = 5`\n* `Nat.toUInt64 65539 = 65539`\n* `Nat.toUInt64 4_294_967_299 = 4_294_967_299`\n* `Nat.toUInt64 18_446_744_073_709_551_620 = 4`\n</code>",
 "416":
 "<code>EvenOddList.cons.{u} {α : Type u} {isEven : Bool} : α → EvenOddList α isEven → EvenOddList α !isEven</code>",
 "4159": "<code>UInt16</code>",
 "4158":
 "<code>Nat.toUInt16 (n : Nat) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Nat.toUInt16 5 = 5`\n* `Nat.toUInt16 255 = 255`\n* `Nat.toUInt16 32770 = 32770`\n* `Nat.toUInt16 65537 = 1`\n</code>",
 "4157": "<code>(i : Nat) → i &lt; n → m Bool</code>",
 "4156":
 "<code>Nat.anyTR (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether there is some number less that the given bound for which `f` returns `true`.\n\nThis is a tail-recursive equivalent of `Nat.any` that's used at runtime.\n\nExamples:\n* `Nat.anyTR 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.anyTR 7 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.anyTR 7 (fun i _ =&gt; i % 2 = 0) = true`\n* `Nat.anyTR 1 (fun i _ =&gt; i % 2 = 1) = false`\n</code>",
 "4155":
 "<code>Nat.any (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether there is some number less that the given bound for which `f` returns `true`.\n\nExamples:\n* `Nat.any 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.any 7 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.any 7 (fun i _ =&gt; i % 2 = 0) = true`\n* `Nat.any 1 (fun i _ =&gt; i % 2 = 1) = false`\n</code>",
 "4154":
 "<code>Nat.allTR (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `f` returns `true` for every number strictly less than a bound.\n\nThis is a tail-recursive equivalent of `Nat.all` that's used at runtime.\n\nExamples:\n* `Nat.allTR 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.allTR 7 (fun i _ =&gt; i &lt; 5) = false`\n* `Nat.allTR 7 (fun i _ =&gt; i % 2 = 0) = false`\n* `Nat.allTR 1 (fun i _ =&gt; i % 2 = 0) = true`\n</code>",
 "4153":
 "<code>Nat.all (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `f` returns `true` for every number strictly less than a bound.\n\nExamples:\n* `Nat.all 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.all 7 (fun i _ =&gt; i &lt; 5) = false`\n* `Nat.all 7 (fun i _ =&gt; i % 2 = 0) = false`\n* `Nat.all 1 (fun i _ =&gt; i % 2 = 0) = true`\n</code>",
 "4152": "<code>(i : Nat) → i &lt; n → Bool</code>",
 "4151":
 "<code>Nat.forRevM.{u_1} {m : Type → Type u_1} [Monad m] (n : Nat) (f : (i : Nat) → i &lt; n → m Unit) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Executes a monadic action on all the numbers less than some bound, in decreasing order.\n\nExample:\n````lean example\n#eval Nat.forRevM 5 fun i _ =&gt; IO.println i\n````\n````output\n4\n3\n2\n1\n0\n````\n</code>",
 "4150":
 "<code>Nat.forM.{u_1} {m : Type → Type u_1} [Monad m] (n : Nat) (f : (i : Nat) → i &lt; n → m Unit) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Executes a monadic action on all the numbers less than some bound, in increasing order.\n\nExample:\n````lean example\n#eval Nat.forM 5 fun i _ =&gt; IO.println i\n````\n````output\n0\n1\n2\n3\n4\n````\n</code>",
 "415": "<code>EvenOddList.nil.{u} {α : Type u} : EvenOddList α true</code>",
 "4149": "<code>(i : Nat) → i &lt; n → m Unit</code>",
 "4148":
 "<code>Nat.foldRev.{u} {α : Type u} (n : Nat) (f : (i : Nat) → i &lt; n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Iterates the application of a function `f` to a starting value `init`, `n` times. At each step, `f`\nis applied to the current value and to the next natural number less than `n`, in decreasing order.\n\nExamples:\n* `Nat.foldRev 3 f init = (f 0 (by simp) &lt;| f 1 (by simp) &lt;| f 2 (by simp) init)`\n* `Nat.foldRev 4 (fun i _ xs =&gt; xs.push i) #[] = #[3, 2, 1, 0]`\n* `Nat.foldRev 0 (fun i _ xs =&gt; xs.push i) #[] = #[]`\n</code>",
 "4147": "<code>(i : Nat) → i &lt; n → α → m α</code>",
 "4146":
 "<code>Nat.foldTR.{u} {α : Type u} (n : Nat) (f : (i : Nat) → i &lt; n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Iterates the application of a function `f` to a starting value `init`, `n` times. At each step, `f`\nis applied to the current value and to the next natural number less than `n`, in increasing order.\n\nThis is a tail-recursive version of `Nat.fold` that's used at runtime.\n\nExamples:\n* `Nat.foldTR 3 f init = (init |&gt; f 0 (by simp) |&gt; f 1 (by simp) |&gt; f 2 (by simp))`\n* `Nat.foldTR 4 (fun i _ xs =&gt; xs.push i) #[] = #[0, 1, 2, 3]`\n* `Nat.foldTR 0 (fun i _ xs =&gt; xs.push i) #[] = #[]`\n</code>",
 "4145": "<code>(i : Nat) → i &lt; n → α → α</code>",
 "4144":
 "<code>Nat.repeatTR.{u} {α : Type u} (f : α → α) (n : Nat) (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to a starting value the specified number of times.\n\nIn other words, `f` is iterated `n` times on `a`.\n\nThis is a tail-recursive version of `Nat.repeat` that's used at runtime.\n\nExamples:\n* `Nat.repeatTR f 3 a = f &lt;| f &lt;| f &lt;| a`\n* `Nat.repeatTR (· ++ \"!\") 4 \"Hello\" = \"Hello!!!!\"`\n</code>",
 "4143":
 "<code><span class=\"literal string\">\"Hello!!!!\"</span> : String</code>",
 "4142": "<code><span class=\"literal string\">\"!\"</span> : String</code>",
 "4141":
 "<code>Nat.repeat.{u} {α : Type u} (f : α → α) (n : Nat) (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to a starting value the specified number of times.\n\nIn other words, `f` is iterated `n` times on `a`.\n\nExamples:\n* `Nat.repeat f 3 a = f &lt;| f &lt;| f &lt;| a`\n* `Nat.repeat (· ++ \"!\") 4 \"Hello\" = \"Hello!!!!\"`\n</code>",
 "4140":
 "<code>DecidableLT.{u} (α : Type u) [LT α] : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Abbreviation for `DecidableRel (· &lt; · : α → α → Prop)`. </code>",
 "414": "<code>b : Bool</code>",
 "4139":
 "<code>DecidableLE.{u} (α : Type u) [LE α] : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Abbreviation for `DecidableRel (· ≤ · : α → α → Prop)`. </code>",
 "4138": "<code><span class=\"literal string\">\"no\"</span> : String</code>",
 "4137": "<code><span class=\"literal string\">\"yes\"</span> : String</code>",
 "4136":
 "<code>Nat.decEq (n m : Nat) : Decidable (n = m)</code><span class=\"sep\"></span><code class=\"docstring\">A decision procedure for equality of natural numbers, usually accessed via the `DecidableEq Nat`\ninstance.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nExamples:\n * `Nat.decEq 5 5 = isTrue rfl`\n * `(if 3 = 4 then \"yes\" else \"no\") = \"no\"`\n * `show 12 = 12 by decide`\n</code>",
 "4135":
 "<code>Nat.blt (a b : Nat) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean less-than comparison on natural numbers.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nExamples:\n * `Nat.blt 2 5 = true`\n * `Nat.blt 5 2 = false`\n * `Nat.blt 5 5 = false`\n</code>",
 "4134":
 "<code>Nat.ble : Nat → Nat → Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean less-than-or-equal-to comparison on natural numbers.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nExamples:\n * `Nat.ble 2 5 = true`\n * `Nat.ble 5 2 = false`\n * `Nat.ble 5 5 = true`\n</code>",
 "4133":
 "<code>Nat.nextPowerOfTwo (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the least power of two that's greater than or equal to `n`.\n\nExamples:\n* `Nat.nextPowerOfTwo 0 = 1`\n* `Nat.nextPowerOfTwo 1 = 1`\n* `Nat.nextPowerOfTwo 2 = 2`\n* `Nat.nextPowerOfTwo 3 = 4`\n* `Nat.nextPowerOfTwo 5 = 8`\n</code>",
 "4132":
 "<code>Nat.lcm (m n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The least common multiple of `m` and `n` is the smallest natural number that's evenly divisible by\nboth `m` and `n`. Returns `0` if either `m` or `n` is `0`.\n\nExamples:\n * `Nat.lcm 9 6 = 18`\n * `Nat.lcm 9 3 = 9`\n * `Nat.lcm 0 3 = 0`\n * `Nat.lcm 3 0 = 0`\n</code>",
 "4131":
 "<code>Nat.gcd (m n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the greatest common divisor of two natural numbers. The GCD of two natural numbers is the\nlargest natural number that evenly divides both.\n\nIn particular, the GCD of a number and `0` is the number itself.\n\nThis reference implementation via the Euclidean algorithm is overridden in both the kernel and the\ncompiler to efficiently evaluate using arbitrary-precision arithmetic. The definition provided here\nis the logical model.\n\nExamples:\n* `Nat.gcd 10 15 = 5`\n* `Nat.gcd 0 5 = 5`\n* `Nat.gcd 7 0 = 7`\n</code>",
 "4130": "<code>Bool → Bool → Bool</code>",
 "413": "<code>α.{u} : Type u</code>",
 "4129":
 "<code>Nat.log2 (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Base-two logarithm of natural numbers. Returns `⌊max 0 (log₂ n)⌋`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `Nat.log2 0 = 0`\n * `Nat.log2 1 = 0`\n * `Nat.log2 2 = 1`\n * `Nat.log2 4 = 2`\n * `Nat.log2 7 = 2`\n * `Nat.log2 8 = 3`\n</code>",
 "4128":
 "<code>Nat.modCore (x y : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator, which computes the remainder when dividing one natural number by another.\nUsually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather\nthan an error.\n\nThis is the core implementation of `Nat.mod`. It computes the correct result for any two closed\nnatural numbers, but it does not have some convenient [definitional\nreductions](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=type-system) when the `Nat`s contain free variables. The wrapper\n`Nat.mod` handles those cases specially and then calls `Nat.modCore`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is the\nlogical model.\n</code>",
 "4127":
 "<code>Nat.mod : Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator, which computes the remainder when dividing one natural number by another.\nUsually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather\nthan an error.\n\n`Nat.mod` is a wrapper around `Nat.modCore` that special-cases two situations, giving better\ndefinitional reductions:\n * `Nat.mod 0 m` should reduce to `m`, for all terms `m : Nat`.\n * `Nat.mod n (m + n + 1)` should reduce to `n` for concrete `Nat` literals `n`.\n\nThese reductions help `Fin n` literals work well, because the `OfNat` instance for `Fin` uses\n`Nat.mod`. In particular, `(0 : Fin (n + 1)).val` should reduce definitionally to `0`. `Nat.modCore`\ncan handle all numbers, but its definitional reductions are not as convenient.\n\nThis function is overridden at runtime with an efficient implementation. This definition is the\nlogical model.\n\nExamples:\n * `7 % 2 = 1`\n * `9 % 3 = 0`\n * `5 % 7 = 5`\n * `5 % 0 = 5`\n * `show ∀ (n : Nat), 0 % n = 0 from fun _ =&gt; rfl`\n * `show ∀ (m : Nat), 5 % (m + 6) = 5 from fun _ =&gt; rfl`\n</code>",
 "4126": "<code>succ_not_zero {n : Nat} : ¬n + 1 = 0</code>",
 "4125": "<code>succ_injective {n k : Nat} : n + 1 = k + 1 → n = k</code>",
 "4124":
 "<code>_root_.noConfusion (n k : Nat) (eq : n = k) : NoConfusion n k</code>",
 "4123": "<code>noConfusionDiagonal (n : Nat) : NoConfusion n n</code>",
 "4122": "<code>NoConfusion : Nat → Nat → Prop</code>",
 "4121": "<code>(n : Nat) → motive n → motive n.succ</code>",
 "4120": "<code>motive Nat.zero</code>",
 "412": "<code>EvenOddList.{u} (α : Type u) : Bool → Type u</code>",
 "4119":
 "<code>Nat.succ_lt_succ {n m : Nat} : n &lt; m → n.succ &lt; m.succ</code>",
 "4118": "<code>i &lt; i + 1</code>",
 "4117": "<code>b = b'</code>",
 "4116":
 "<code>Eq.recOn.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} {a✝¹ : α} (t : a✝ = a✝¹)\n  (refl : motive a✝ ⋯) : motive a✝¹ t</code>",
 "4115": "<code>φ a</code>",
 "4114": "<code>h₁ ▸ a = b</code>",
 "4113": "<code>a = a'</code>",
 "4112": "<code>a ≍ a'</code>",
 "4111": "<code>p α a</code>",
 "4110": "<code>(T : Sort u) → T → Prop</code>",
 "411":
 "<code>One.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type with a \"one\" element. </code>",
 "4109":
 "<code>HEq.{u} {α : Sort u} : α → {β✝ : Sort u} → β✝ → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Heterogeneous equality. `a ≍ b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\n\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `Eq`, because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\npublic important non-theorem is the analogue of `congr`: If `f ≍ g` and `x ≍ y`\nand `f x` and `g y` are well typed it does not follow that `f x ≍ g y`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `a ≍ b` are equivalent.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≍` in identifiers is `heq`.</code>",
 "4108": "<code>{β : Sort u2} → β → Sort u1</code>",
 "4107": "<code>Sort u2</code>",
 "4106":
 "<code>HEq.ndrec.{u1, u2} {α : Sort u2} {a : α} {motive : {β : Sort u2} → β → Sort u1} (m : motive a) {β : Sort u2} {b : β}\n  (h : a ≍ b) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">Non-dependent recursor for `HEq` </code>",
 "4105": "<code>a ≍ b</code>",
 "4104":
 "<code>(toArray✝² ++ (toArray✝¹ ++ toArray✝)).size = l₁ + l₂ + l₃</code>",
 "4103":
 "<code>(toArray✝² ++ (toArray✝¹ ++ toArray✝)).size = l₁ + (l₂ + l₃)</code>",
 "4102":
 "<code>heq_of_eqRec_eq.{u} {α β : Sort u} {a : α} {b : β} (h₁ : α = β) (h₂ : h₁ ▸ a = b) : a ≍ b</code><span class=\"sep\"></span><code class=\"docstring\">If casting a term with `Eq.rec` to another type makes it equal to some other term, then the two\nterms are heterogeneously equal.\n</code>",
 "4101": "<code>toArray✝.size = l₃</code>",
 "4100": "<code>toArray✝¹.size = l₂</code>",
 "410": "<code>Yes.intro : Yes</code>",
 "41":
 "<code>pp.match</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) disable/enable 'match' notation</code>",
 "4099": "<code>toArray✝².size = l₁</code>",
 "4098": "<code>toArray✝.size = l₂</code>",
 "4097": "<code>toArray✝¹.size = l₁</code>",
 "4096":
 "<code>Vector.mk.{u} {α : Type u} {n : Nat} (toArray : Array α) (size_toArray : toArray.size = n) : Vector α n</code>",
 "4095": "<code>toArray✝.size = l₁</code>",
 "4094":
 "<code>Vector.append_associative.{u} {α : Type u} {l₁ l₂ l₃ : Nat} {xs : Vector α l₁} {ys : Vector α l₂} {zs : Vector α l₃} :\n  xs ++ (ys ++ zs) ≍ xs ++ ys ++ zs</code>",
 "4093":
 "<code>Vector.append_associative'.{u} {α : Type u} {l₁ l₂ l₃ : Nat} {xs : Vector α l₁} {ys : Vector α l₂} {zs : Vector α l₃} :\n  xs ++ (ys ++ zs) = ⋯ ▸ (xs ++ ys ++ zs)</code>",
 "4092":
 "<code>linter.unusedVariables</code><span class=\"sep\"></span><code class=\"docstring\">enable the 'unused variables' linter</code>",
 "4091": "<code>Vector α l₃</code>",
 "4090": "<code>Vector α l₂</code>",
 "409": "<code>Yes : Prop</code>",
 "4089": "<code>Vector α l₁</code>",
 "4088":
 "<code>Vector.{u} (α : Type u) (n : Nat) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Vector α n` is an `Array α` with size `n`. </code>",
 "4087":
 "<code>HEq.refl.{u} {α : Sort u} (a : α) : a ≍ a</code><span class=\"sep\"></span><code class=\"docstring\">Reflexivity of heterogeneous equality. </code>",
 "4086": "<code>?m.48</code>",
 "4085": "<code>motive ⋯</code>",
 "4084": "<code>{x : α} → x = x → Sort u</code>",
 "4083": "<code>x = x</code>",
 "4082": "<code>{x : α} → motive ⋯</code>",
 "4081": "<code>{x : α} → x = x → Sort v</code>",
 "4080":
 "<code>K.{u, v} {α : Sort u} {motive : {x : α} → x = x → Sort v} (d : {x : α} → motive ⋯) (x : α) (z : x = x) : motive z</code>",
 "408": "<code>Solo.solo : Solo</code>",
 "4079":
 "<code>Eq.unique.{u} {α : Sort u} (x y : α) (p1 p2 : x = y) : p1 = p2</code>",
 "4078":
 "<code>Eq.mpr.{u} {α β : Sort u} (h : α = β) (b : β) : α</code><span class=\"sep\"></span><code class=\"docstring\">If `h : α = β` is a proof of type equality, then `h.mpr : β → α` is the induced\n\"cast\" operation in the reverse direction, mapping elements of `β` to elements of `α`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mpr` is definitionally the identity function.\n</code>",
 "4077":
 "<code>Eq.mp.{u} {α β : Sort u} (h : α = β) (a : α) : β</code><span class=\"sep\"></span><code class=\"docstring\">If `h : α = β` is a proof of type equality, then `h.mp : α → β` is the induced\n\"cast\" operation, mapping elements of `α` to elements of `β`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mp` is definitionally the identity function.\n</code>",
 "4076": "<code>f = g</code>",
 "4075": "<code>a₁ = a₂</code>",
 "4074": "<code>f₁ = f₂</code>",
 "4073": "<code>motive a</code>",
 "4072": "<code>p a</code>",
 "4071":
 "<code>Eq.subst.{u} {α : Sort u} {motive : α → Prop} {a b : α} (h₁ : a = b) (h₂ : motive a) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x =&gt; x &lt; 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "4070":
 "<code>Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a</code><span class=\"sep\"></span><code class=\"docstring\">Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "407": "<code>Solo : Type</code>",
 "4069":
 "<code>Eq.trans.{u} {α : Sort u} {a b c : α} (h₁ : a = b) (h₂ : b = c) : a = c</code><span class=\"sep\"></span><code class=\"docstring\">Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you have variables or expressions\n`h₁ : a = b` and `h₂ : b = c`, you can use `h₁.trans h₂ : a = c` as shorthand\nfor `Eq.trans h₁ h₂`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "4068": "<code>c = d</code>",
 "4067": "<code>c = b</code>",
 "4066":
 "<code>Classical.choose.{u} {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : α</code><span class=\"sep\"></span><code class=\"docstring\">Given that there exists an element satisfying `p`, returns one such element.\n\nThis is a straightforward consequence of, and equivalent to, `Classical.choice`.\n\nSee also `choose_spec`, which asserts that the returned value has property `p`.\n</code>",
 "4065": "<code>∃ a, p a</code>",
 "4064": "<code>p w</code>",
 "4063": "<code>∃ x, x = x</code>",
 "4062": "<code>ex_four_plus_five' : ∃ n, 4 + 5 = n</code>",
 "4061": "<code>ex_four_plus_five : ∃ n, 4 + 5 = n</code>",
 "4060":
 "<code>Sigma.{u, v} {α : Type u} (β : α → Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Dependent pairs, in which the second element's type depends on the value of the first element. The\ntype `Sigma β` is typically written `Σ a : α, β a` or `(a : α) × β a`.\n\nAlthough its values are pairs, `Sigma` is sometimes known as the *dependent sum type*, since it is\nthe type level version of an indexed summation.\n</code>",
 "406": "<code>No : Prop</code>",
 "4059": "<code>a ↔ b</code>",
 "4058": "<code>(a → b) → (b → a) → α</code>",
 "4057":
 "<code>b → a</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. </code>",
 "4056":
 "<code>a → b</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. </code>",
 "4055":
 "<code>Iff.intro {a b : Prop} (mp : a → b) (mpr : b → a) : a ↔ b</code><span class=\"sep\"></span><code class=\"docstring\">If `a → b` and `b → a` then `a` and `b` are equivalent. </code>",
 "4054": "<code>A → B</code>",
 "4053": "<code>A</code>",
 "4052": "<code>B</code>",
 "4051": "<code>¬A</code>",
 "4050": "<code>truth_functional_imp {A B : Prop} : (¬A ∨ B) = (A → B)</code>",
 "405": "<code>Vacant : Type</code>",
 "4049":
 "<code>absurd.{v} {a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a) : b</code><span class=\"sep\"></span><code class=\"docstring\">Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : ¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "4048": "<code>¬a</code>",
 "4047": "<code>q → α</code>",
 "4046": "<code>p → α</code>",
 "4045": "<code>p ∨ q</code>",
 "4044": "<code>a → b → α</code>",
 "4043":
 "<code>b</code><span class=\"sep\"></span><code class=\"docstring\">Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. </code>",
 "4042":
 "<code>a</code><span class=\"sep\"></span><code class=\"docstring\">Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. </code>",
 "4041":
 "<code>And.right {a b : Prop} (self : a ∧ b) : b</code><span class=\"sep\"></span><code class=\"docstring\">Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. </code>",
 "4040":
 "<code>And.left {a b : Prop} (self : a ∧ b) : a</code><span class=\"sep\"></span><code class=\"docstring\">Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. </code>",
 "404":
 "<code>inductive.autoPromoteIndices</code><span class=\"sep\"></span><code class=\"docstring\">Promote indices to parameters in inductive types whenever possible.</code>",
 "4039":
 "<code>PProd.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">A product type in which the types may be propositions, usually written `α ×' β`.\n\nThis type is primarily used internally and as an implementation detail of proof automation. It is\nrarely useful in hand-written code.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×'` in identifiers is `PProd`.</code>",
 "4038":
 "<code>And.elim.{u_1} {a b : Prop} {α : Sort u_1} (f : a → b → α) (h : a ∧ b) : α</code><span class=\"sep\"></span><code class=\"docstring\">Non-dependent eliminator for `And`. </code>",
 "4037": "<code>g (n : Nat) : String</code>",
 "4036":
 "<code><span class=\"literal string\">\"Twelve\"</span> : String</code>",
 "4035": "<code>¬n % 2 = 1</code>",
 "4034": "<code>¬n &gt; 13</code>",
 "4033": "<code>¬n &lt; 11</code>",
 "4032": "<code>n ≠ 12</code>",
 "4031": "<code><span class=\"literal string\">\"Odd\"</span> : String</code>",
 "4030": "<code>n % 2 = 1</code>",
 "403":
 "<code>Empty : Type</code><span class=\"sep\"></span><code class=\"docstring\">The empty type. It has no constructors.\n\nUse `Empty.elim` in contexts where a value of type `Empty` is in scope.\n</code>",
 "4029":
 "<code><span class=\"literal string\">\"Large\"</span> : String</code>",
 "4028": "<code>n &gt; 13</code>",
 "4027":
 "<code><span class=\"literal string\">\"Small\"</span> : String</code>",
 "4026": "<code>n &lt; 11</code>",
 "4025": "<code>f (n : Nat) : String</code>",
 "4024": "<code>autoParam (a ∈ m) _auto✝</code>",
 "4023":
 "<code>IndexMap.findIdx_insert_self.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  (m : IndexMap α β) (a : α) (b : β) : (m.insert a b).findIdx a ⋯ = if h : a ∈ m then m.findIdx a h else m.size</code>",
 "4022":
 "<code>IndexMap.getElem_insert.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  (m : IndexMap α β) (a a' : α) (b : β) (h : a' ∈ m.insert a b) :\n  (m.insert a b)[a'] = if h' : (a' == a) = true then b else m[a']</code>",
 "4021":
 "<code>IndexMap.mem_insert.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  (m : IndexMap α β) (a a' : α) (b : β) : a' ∈ m.insert a b ↔ a' = a ∨ a' ∈ m</code>",
 "4020":
 "<code>IndexMap.getIdx_findIdx.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  (m : IndexMap α β) (a : α) (h : a ∈ m) : m.getIdx (m.findIdx a h) ⋯ = m[a]</code>",
 "402":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts a wrapped value from a universe-lifted type. </code>",
 "4019":
 "<code>IndexMap.findIdx.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (a : α)\n  (h : a ∈ m := by get_elem_tactic) : Nat</code>",
 "4018": "<code>m.keys[i]? = some a ↔ m.indices[a]? = some i</code>",
 "4017": "<code>i &lt; m.keys.size</code>",
 "4016":
 "<code>IndexMap.WF'.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {m : IndexMap α β} [LawfulBEq α] [LawfulHashable α]\n  (i : Nat) (a : α) (h₁ : i &lt; m.keys.size) (h₂ : a ∈ m) : m.keys[i] = a ↔ m.indices[a] = i</code>",
 "4015":
 "<code>Std.HashMap.contains_insert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β}\n  [EquivBEq α] [LawfulHashable α] {k a : α} {v : β} : (m.insert k v).contains a = (k == a || m.contains a)</code>",
 "4014":
 "<code>Std.HashMap.contains_erase.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β}\n  [EquivBEq α] [LawfulHashable α] {k a : α} : (m.erase k).contains a = (!k == a && m.contains a)</code>",
 "4013":
 "<code>Option.none_beq_none.{u_1} {α : Type u_1} [BEq α] : (none == none) = true</code>",
 "4012":
 "<code>Option.none_beq_some.{u_1} {α : Type u_1} [BEq α] (a : α) : (none == some a) = false</code>",
 "4011":
 "<code>Option.some_beq_none.{u_1} {α : Type u_1} [BEq α] (a : α) : (some a == none) = false</code>",
 "4010":
 "<code>Option.some_beq_some.{u_1} {α : Type u_1} [BEq α] {a b : α} : (some a == some b) = (a == b)</code>",
 "401":
 "<code>ULift.up.{r, s} {α : Type s} (down : α) : ULift α</code><span class=\"sep\"></span><code class=\"docstring\">Wraps a value to increase its type's universe level. </code>",
 "4009":
 "<code>Array.getElem_pop.{u_1} {α : Type u_1} {xs : Array α} {i : Nat} (h : i &lt; xs.pop.size) : xs.pop[i] = xs[i]</code>",
 "4008":
 "<code>Array.getElem_set.{u_1} {α : Type u_1} {xs : Array α} {i : Nat} (h' : i &lt; xs.size) {v : α} {j : Nat}\n  (h : j &lt; (xs.set i v h').size) : (xs.set i v h')[j] = if i = j then v else xs[j]</code>",
 "4007":
 "<code>Std.HashMap.getElem_insert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β}\n  [EquivBEq α] [LawfulHashable α] {k a : α} {v : β} {h₁ : a ∈ m.insert k v} :\n  (m.insert k v)[a] = if h₂ : (k == a) = true then v else m[a]</code>",
 "4006":
 "<code>Std.HashMap.getElem_erase.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β}\n  [EquivBEq α] [LawfulHashable α] {k a : α} {h' : a ∈ m.erase k} : (m.erase k)[a] = m[a]</code>",
 "4005":
 "<code>Array.getElem_mem.{u} {α : Type u} {xs : Array α} {i : Nat} (h : i &lt; xs.size) : xs[i] ∈ xs</code>",
 "4004":
 "<code>Option.none_le.{u_1} {α : Type u_1} [LE α] {a : Option α} : none ≤ a</code>",
 "4003":
 "<code>Option.not_some_le_none.{u_1} {α : Type u_1} [LE α] {a : α} : ¬some a ≤ none</code>",
 "4002":
 "<code>Option.not_mem_none.{u_1} {α : Type u_1} (a : α) : ¬a ∈ none</code>",
 "4001":
 "<code>Option.none_lt_some.{u_1} {α : Type u_1} [LT α] {a : α} : none &lt; some a</code>",
 "4000":
 "<code>Option.not_lt_none.{u_1} {α : Type u_1} [LT α] {a : Option α} : ¬a &lt; none</code>",
 "400": "<code class=\"docstring\">The universe level 7</code>",
 "40":
 "<code>Dynamic : Type</code><span class=\"sep\"></span><code class=\"docstring\">A type-tagged union that can store any type with a `TypeName` instance.\n\nThis is roughly equivalent to `(α : Type) × TypeName α × α`, but without the universe bump. Use\n`Dynamic.mk` to inject a value into `Dynamic` from another type, and `Dynamic.get?` to extract a\nvalue from `Dynamic` if it has some expected type.\n</code>",
 "4":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "3999":
 "<code>Std.HashMap.getElem?_erase.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β}\n  [EquivBEq α] [LawfulHashable α] {k a : α} : (m.erase k)[a]? = if (k == a) = true then none else m[a]?</code>",
 "3998":
 "<code>Std.HashMap.mem_insert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β} [EquivBEq α]\n  [LawfulHashable α] {k a : α} {v : β} : a ∈ m.insert k v ↔ (k == a) = true ∨ a ∈ m</code>",
 "3997":
 "<code>Array.size_set.{u} {α : Type u} {xs : Array α} {i : Nat} {v : α} (h : i &lt; xs.size) : (xs.set i v h).size = xs.size</code>",
 "3996":
 "<code>Array.size_pop.{u} {α : Type u} {xs : Array α} : xs.pop.size = xs.size - 1</code>",
 "3995":
 "<code>Array.getElem?_eq_none.{u_1} {α : Type u_1} {i : Nat} {xs : Array α} (h : xs.size ≤ i) : xs[i]? = none</code>",
 "3994":
 "<code>Array.size_pos_of_mem.{u_1} {α : Type u_1} {a : α} {xs : Array α} (h : a ∈ xs) : 0 &lt; xs.size</code>",
 "3993":
 "<code>Option.some_lt_some.{u_1} {α : Type u_1} [LT α] {a b : α} : some a &lt; some b ↔ a &lt; b</code>",
 "3992":
 "<code>Array.back_eq_getElem.{u_1} {α : Type u_1} {xs : Array α} (h : 0 &lt; xs.size) : xs.back h = xs[xs.size - 1]</code>",
 "3991":
 "<code>Array.set_pop.{u_1} {α : Type u_1} {xs : Array α} {x : α} {i : Nat} (h : i &lt; xs.pop.size) :\n  xs.pop.set i x h = (xs.set i x ⋯).pop</code>",
 "3990":
 "<code>Array.mem_or_eq_of_mem_set.{u_1} {α : Type u_1} {xs : Array α} {i : Nat} {a b : α} {w : i &lt; xs.size}\n  (h : a ∈ xs.set i b w) : a ∈ xs ∨ a = b</code>",
 "399": "<code>Type s</code>",
 "3989":
 "<code>Option.mem_some.{u_1} {α : Type u_1} {a b : α} : a ∈ some b ↔ b = a</code>",
 "3988":
 "<code>Option.some_le_some.{u_1} {α : Type u_1} [LE α] {a b : α} : some a ≤ some b ↔ a ≤ b</code>",
 "3987":
 "<code>IndexMap.size.eq_1.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) : m.size = m.values.size</code>",
 "3986":
 "<code>getElem?_pos.{u_1, u_2, u_3} {cont : Type u_1} {idx : Type u_2} {elem : Type u_3} {dom : cont → idx → Prop}\n  [GetElem? cont idx elem dom] [LawfulGetElem cont idx elem dom] (c : cont) (i : idx) (h : dom c i) : c[i]? = some c[i]</code>",
 "3985":
 "<code>getElem?_neg.{u_1, u_2, u_3} {cont : Type u_1} {idx : Type u_2} {elem : Type u_3} {dom : cont → idx → Prop}\n  [GetElem? cont idx elem dom] [LawfulGetElem cont idx elem dom] (c : cont) (i : idx) (h : ¬dom c i) : c[i]? = none</code>",
 "3984":
 "<code>Std.HashMap.mem_erase.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β} [EquivBEq α]\n  [LawfulHashable α] {k a : α} : a ∈ m.erase k ↔ (k == a) = false ∧ a ∈ m</code>",
 "3983":
 "<code>Std.HashMap.getElem?_insert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β}\n  [EquivBEq α] [LawfulHashable α] {k a : α} {v : β} : (m.insert k v)[a]? = if (k == a) = true then some v else m[a]?</code>",
 "3982":
 "<code>Array.getElem?_set.{u_1} {α : Type u_1} {xs : Array α} {i : Nat} (h : i &lt; xs.size) {v : α} {j : Nat} :\n  (xs.set i v h)[j]? = if i = j then some v else xs[j]?</code>",
 "3981":
 "<code>Array.getElem?_pop.{u_1} {α : Type u_1} {xs : Array α} {i : Nat} : xs.pop[i]? = if i &lt; xs.size - 1 then xs[i]? else none</code>",
 "3980": "<code>i_2 + 1 ≤ m_1.keys.pop.size</code>",
 "398":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts a wrapped proof or value from a universe-lifted proposition or type. </code>",
 "3979": "<code>m_1.keys[i_2] ∈ m_1</code>",
 "3978": "<code>m_1.keys[i_2] ∈ m_1.indices</code>",
 "3977": "<code>i_2 + 1 ≤ (m_1.keys.set i_1 (m_1.keys.back ⋯) ⋯).size</code>",
 "3976": "<code>a_1 ∈ m_1</code>",
 "3975": "<code>i_1 + 1 ≤ m_1.keys.pop.size</code>",
 "3974": "<code>i_1 + 1 ≤ m_1.keys.size</code>",
 "3973": "<code>i_2 + 1 ≤ m_1.keys.size</code>",
 "3972": "<code>a_1 ∈ m_1.indices</code>",
 "3971":
 "<code>i_2 + 1 ≤ (m_1.keys.pop.set i_1 (m_1.keys.back ⋯) ⋯).size</code>",
 "3970":
 "<code>a_2 ∈ (m_1.indices.erase a_1).insert (m_1.keys.back ⋯) i_1</code>",
 "397":
 "<code>True : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "3969": "<code>a_2 ∈ m_1.indices</code>",
 "3968": "<code>(a_1 == a_2) = false</code>",
 "3967": "<code>a_2 ∈ m_1.indices.erase a_1</code>",
 "3966": "<code>(m_1.keys.back ⋯ == a_2) = true</code>",
 "3965": "<code>¬m_1.indices[a_1]? = some i_2</code>",
 "3964": "<code>¬m_1.keys[i_2]? = some a_1</code>",
 "3963": "<code>¬i_1 = i_2</code>",
 "3962":
 "<code>¬((m_1.indices.erase a_1).insert (m_1.keys.back ⋯) i_1)[a_2]? = some i_2</code>",
 "3961":
 "<code>(m_1.keys.pop.set i_1 (m_1.keys.back ⋯) ⋯)[i_2]? = some a_2</code>",
 "3960":
 "<code>-1 * ↑(m_1.keys.set i_1 (m_1.keys.back ⋯) ⋯).size + 1 ≤ 0</code>",
 "396":
 "<code class=\"docstring\">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nThe target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,\nor you can use the `+revert` option, described below.\n\nOptions:\n- `decide +revert` begins by reverting local variables that the target depends on,\n  after cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,\n  or if it is a proposition that refers to a relevant variable.\n- `decide +kernel` uses kernel for reduction instead of the elaborator.\n  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\n  and (2) it reduces the `Decidable` instance only once instead of twice.\n- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,\n  admitting the result via the `Lean.ofReduceBool` axiom.\n  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size\n  of the trusted code base.\n  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.\n  Like with `+kernel`, the `Decidable` instance is evaluated only once.\n\nLimitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,\n`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on `Decidable` instances with `Eq.rec` terms.\nThese can appear in instances defined using tactics (such as `rw` and `simp`).\nTo avoid this, create such instances using definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n</code>",
 "3959":
 "<code>((m_1.keys.pop.set i_1 (m_1.keys.back ⋯) ⋯)[i_2]? = some a_2) =\n  ¬((m_1.indices.erase a_1).insert (m_1.keys.back ⋯) i_1)[a_2]? = some i_2</code>",
 "3958": "<code>¬i_1 = m_1.size - 1</code>",
 "3957": "<code>m_1.indices[a_1]? = some i_1</code>",
 "3956": "<code>Inhabited β</code>",
 "3955": "<code>Decidable (i ∈ c)</code>",
 "3954":
 "<code>IndexMap.getElem!_def.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  [Inhabited β] (m : IndexMap α β) (a : α) : m[a]! = (m.indices[a]?.bind fun x =&gt; m.values[x]?).getD default</code>",
 "3953":
 "<code>IndexMap.getElem?_def.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  (m : IndexMap α β) (a : α) : m[a]? = m.indices[a]?.bind fun i =&gt; m.values[i]?</code>",
 "3952":
 "<code>IndexMap.getElem_def.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  (m : IndexMap α β) (a : α) (h : a ∈ m) : m[a] = m.values[m.indices[a]]</code>",
 "3951":
 "<code>IndexMap.getElem_indices_lt.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {m : IndexMap α β} {a : α}\n  [LawfulBEq α] [LawfulHashable α] {h : a ∈ m} : m.indices[a] &lt; m.size</code>",
 "3950": "<code>Iff.rfl {a : Prop} : a ↔ a</code>",
 "395":
 "<code class=\"docstring\">`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) =&gt; `(tactic| simp)\n```\n</code>",
 "3949":
 "<code>IndexMap.mem_indices_of_mem.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {m : IndexMap α β} {a : α} :\n  a ∈ m ↔ a ∈ m.indices</code>",
 "3948":
 "<code>Std.HashMap.contains_iff_mem.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} {m : HashMap α β}\n  {a : α} : m.contains a = true ↔ a ∈ m</code>",
 "3947": "<code>m.size ≤ m.indices[a]</code>",
 "3946":
 "<code>IndexMap.getElem_indices_lt.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (a : α)\n  (h : a ∈ m) : m.indices[a] &lt; m.size</code>",
 "3945":
 "<code>IndexMap.size_keys.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] {m : IndexMap α β} : m.keys.size = m.size</code>",
 "3944":
 "<code>IndexMap.size_keys'.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (self : IndexMap α β) :\n  self.keys.size = self.values.size</code>",
 "3943":
 "<code>IndexMap.findIdx_insert_self.{u, v} {α : Type u} {β : Type v} [BEq α] [LawfulBEq α] [Hashable α] [LawfulHashable α]\n  (m : IndexMap α β) (a : α) (b : β) : (m.insert a b).findIdx a ⋯ = if h : a ∈ m then m.findIdx a h else m.size</code>",
 "3942": "<code>(a' == a) = true</code>",
 "3941": "<code>a' ∈ m.insert a b</code>",
 "3940":
 "<code>IndexMap.getElem_insert.{u, v} {α : Type u} {β : Type v} [BEq α] [LawfulBEq α] [Hashable α] [LawfulHashable α]\n  (m : IndexMap α β) (a a' : α) (b : β) (h : a' ∈ m.insert a b) :\n  (m.insert a b)[a'] = if h' : (a' == a) = true then b else m[a']</code>",
 "394":
 "<code>PLift.up.{u} {α : Sort u} (down : α) : PLift α</code><span class=\"sep\"></span><code class=\"docstring\">Wraps a proof or value to increase its type's universe level by 1. </code>",
 "3939":
 "<code>IndexMap.mem_insert.{u, v} {α : Type u} {β : Type v} [BEq α] [LawfulBEq α] [Hashable α] [LawfulHashable α]\n  (m : IndexMap α β) (a a' : α) (b : β) : a' ∈ m.insert a b ↔ a' = a ∨ a' ∈ m</code>",
 "3938":
 "<code>IndexMap.getIdx_findIdx.{u, v} {α : Type u} {β : Type v} [BEq α] [LawfulBEq α] [Hashable α] [LawfulHashable α]\n  (m : IndexMap α β) (a : α) (h : a ∈ m) : m.getIdx (m.findIdx a h) ⋯ = m[a]</code>",
 "3937":
 "<code>∀ (i_1 : Nat) (a_1 : α),\n  (m.keys.pop.set i lastKey ⋯)[i_1]? = some a_1 ↔ ((m.indices.erase a).insert lastKey i)[a_1]? = some i_1</code>",
 "3936":
 "<code>(m.keys.pop.set i lastKey ⋯).size = (m.values.pop.set i lastValue ⋯).size</code>",
 "3935":
 "<code>Array.back.{u} {α : Type u} (xs : Array α) (h : 0 &lt; xs.size := by get_elem_tactic) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of an array, given a proof that the array is not empty.\n\nSee `Array.back!` for the version that panics if the array is empty, or `Array.back?` for the\nversion that returns an option.\n</code>",
 "3934":
 "<code>∀ (i : Nat) (a_1 : α), m.keys.pop[i]? = some a_1 ↔ (m.indices.erase a)[a_1]? = some i</code>",
 "3933": "<code>m.keys.pop.size = m.values.pop.size</code>",
 "3932":
 "<code>Array.pop.{u} {α : Type u} (xs : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the last element of an array. If the array is empty, then it is returned unmodified. The\nmodification is performed in-place when the reference to the array is unique.\n\nExamples:\n* `#[1, 2, 3].pop = #[1, 2]`\n* `#[\"orange\", \"yellow\"].pop = #[\"orange\"]`\n* `(#[] : Array String).pop = #[]`\n</code>",
 "3931":
 "<code>Std.HashMap.erase.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : HashMap α β) (a : α) :\n  HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Removes the mapping for the given key if it exists. </code>",
 "3930": "<code>i = m.size - 1</code>",
 "393":
 "<code>ULift.{r, s} (α : Type s) : Type (max s r)</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a type to a higher universe level.\n\n`ULift α` wraps a value of type `α`. Instead of occupying the same universe as `α`, which would be\nthe minimal level, it takes a further level parameter and occupies their maximum. The resulting type\nmay occupy any universe that's at least as large as that of `α`.\n\nThe resulting universe of the lifting operator is the first parameter, and may be written explicitly\nwhile allowing `α`'s level to be inferred.\n\nThe related type `PLift` can be used to lift a proposition or type by one level.\n\nExamples:\n * `(Nat : Type 0)`\n * `(ULift Nat : Type 0)`\n * `(ULift Nat : Type 1)`\n * `(ULift Nat : Type 5)`\n * `(ULift.{7} (PUnit : Type 3) : Type 7)`\n</code>",
 "3929":
 "<code>IndexMap.eraseSwap.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (a : α) : IndexMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Erase the key-value pair with the given key,\nmoving the last pair into its place in the order.\nIf the key is not present, the map is unchanged.\n</code>",
 "3928":
 "<code>LawfulSingleton.mk.{u, v} {α : Type u} {β : Type v} [EmptyCollection β] [Insert α β] [Singleton α β]\n  (insert_empty_eq : ∀ (x : α), Insert.insert x ∅ = {x}) : LawfulSingleton α β</code>",
 "3927":
 "<code>LawfulSingleton.{u, v} (α : Type u) (β : Type v) [EmptyCollection β] [Insert α β] [Singleton α β] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`insert x ∅ = {x}` </code>",
 "3926":
 "<code>Insert.mk.{u, v} {α : outParam (Type u)} {γ : Type v} (insert : α → γ → γ) : Insert α γ</code>",
 "3925":
 "<code>Insert.{u, v} (α : outParam (Type u)) (γ : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Type class for the `insert` operation.\nUsed to implement the `{ a, b, c }` syntax.\n</code>",
 "3924":
 "<code>Singleton.mk.{u, v} {α : outParam (Type u)} {β : Type v} (singleton : α → β) : Singleton α β</code>",
 "3923":
 "<code>Singleton.{u, v} (α : outParam (Type u)) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Type class for the `singleton` operation.\nUsed to implement the `{ a, b, c }` syntax.\n</code>",
 "3922":
 "<code>∀ (i : Nat) (a_1 : α), (m.keys.push a)[i]? = some a_1 ↔ (m.indices.insert a m.size)[a_1]? = some i</code>",
 "3921": "<code>(m.keys.push a).size = (m.values.push b).size</code>",
 "3920":
 "<code>∀ (i_1 : Nat) (a_1 : α), (m.keys.set i a ⋯)[i_1]? = some a_1 ↔ m.indices[a_1]? = some i_1</code>",
 "392":
 "<code>PLift.{u} (α : Sort u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a proposition or type to a higher universe level.\n\n`PLift α` wraps a proof or value of type `α`. The resulting type is in the next largest universe\nafter that of `α`. In particular, propositions become data.\n\nThe related type `ULift` can be used to lift a non-proposition type by any number of levels.\n\nExamples:\n * `(False : Prop)`\n * `(PLift False : Type)`\n * `([.up (by trivial), .up (by simp), .up (by decide)] : List (PLift True))`\n * `(Nat : Type 0)`\n * `(PLift Nat : Type 1)`\n</code>",
 "3919": "<code>(m.keys.set i a ⋯).size = (m.values.set i b ⋯).size</code>",
 "3918":
 "<code>Array.set.{u_1} {α : Type u_1} (xs : Array α) (i : Nat) (v : α) (h : i &lt; xs.size := by get_elem_tactic) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at a given index in an array.\n\nNo bounds check is performed, but the function requires a proof that the index is in bounds. This\nproof can usually be omitted, and will be synthesized automatically.\n\nThe array is modified in-place if there are no other references to it.\n\nExamples:\n* `#[0, 1, 2].set 1 5 = #[0, 5, 2]`\n* `#[\"orange\", \"apple\"].set 1 \"grape\" = #[\"orange\", \"grape\"]`\n</code>",
 "3917": "<code>m.indices[a]? = some i</code>",
 "3916":
 "<code>IndexMap.insert.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (a : α) (b : β) : IndexMap α β</code>",
 "3915":
 "<code>∀ [inst : Inhabited β] (c : IndexMap α β) (i : α),\n  c[i]! =\n    match c[i]? with\n    | some e =&gt; e\n    | none =&gt; default</code><span class=\"sep\"></span><code class=\"docstring\">`GetElem?.getElem!` succeeds and fails when `GetElem.getElem?` succeeds and fails. </code>",
 "3914":
 "<code>∀ (c : IndexMap α β) (i : α) [inst : Decidable (i ∈ c)], c[i]? = if h : i ∈ c then some c[i] else none</code><span class=\"sep\"></span><code class=\"docstring\">`GetElem?.getElem?` succeeds when the validity predicate is satisfied and fails otherwise. </code>",
 "3913":
 "<code>LawfulGetElem.{u, v, w} (cont : Type u) (idx : Type v) (elem : outParam (Type w)) (dom : outParam (cont → idx → Prop))\n  [ge : GetElem? cont idx elem dom] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lawful `GetElem?` instances (which extend `GetElem`) are those for which the potentially-failing\n`GetElem?.getElem?` and `GetElem?.getElem!` operators succeed when the validity predicate is\nsatisfied, and fail when it is not.\n</code>",
 "3912":
 "<code>[Inhabited β] → IndexMap α β → α → β</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]!` gets the `i`'th element of the collection `arr`,\nif it is present, and otherwise panics at runtime and returns the `default` term\nfrom `Inhabited elem`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]!` in identifiers is `getElem!`.</code>",
 "3911":
 "<code>Option.bind.{u_1, u_2} {α : Type u_1} {β : Type u_2} : Option α → (α → Option β) → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Sequencing of `Option` computations.\n\nFrom the perspective of `Option` as computations that might fail, this function sequences\npotentially-failing computations, failing if either fails. From the perspective of `Option` as a\ncollection with at most one element, the function is applied to the element if present, and the\nfinal result is empty if either the initial or the resulting collections are empty.\n\nThis function is often accessed via the `&gt;&gt;=` operator from the `Bind (Option α)` instance, or\nimplicitly via `do`-notation, but it is also idiomatic to call it using [generalized field\nnotation](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=generalized-field-notation).\n\nExamples:\n * `none.bind (fun x =&gt; some x) = none`\n * `(some 4).bind (fun x =&gt; some x) = some 4`\n * `none.bind (Option.guard (· &gt; 2)) = none`\n * `(some 2).bind (Option.guard (· &gt; 2)) = none`\n * `(some 4).bind (Option.guard (· &gt; 2)) = some 4`\n</code>",
 "3910":
 "<code>IndexMap α β → α → Option β</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]?` gets the `i`'th element of the collection `arr`,\nif it is present (and wraps it in `some`), and otherwise returns `none`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]?` in identifiers is `getElem?`.</code>",
 "391": "<code>L : Type 1</code>",
 "3909": "<code>LawfulHashable α</code>",
 "3908": "<code>Hashable α</code>",
 "3907": "<code>LawfulBEq α</code>",
 "3906": "<code>BEq α</code>",
 "3905":
 "<code>(m : IndexMap α β) → (a : α) → a ∈ m → β</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.\n\n * The recommended spelling of `xs[i]'h` in identifiers is `getElem`.</code>",
 "3904": "<code>autoParam (i &lt; m.size) _auto✝</code>",
 "3903":
 "<code>IndexMap.getIdx.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (i : Nat)\n  (h : i &lt; m.size := by get_elem_tactic) : β</code>",
 "3902":
 "<code>IndexMap.getIdx?.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (i : Nat) : Option β</code>",
 "3901": "<code>a ∈ m</code>",
 "3900":
 "<code>IndexMap.findIdx.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (a : α) (h : a ∈ m) : Nat</code>",
 "390": "<code>L.{u_1} : Type u_1</code>",
 "39":
 "<code>Lean.Elab.Info.ofCustomInfo (i : Lean.Elab.CustomInfo) : Info</code>",
 "3899":
 "<code>IndexMap.findIdx?.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (a : α) : Option Nat</code>",
 "3898":
 "<code>IndexMap α β → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>",
 "3897":
 "<code>IndexMap.contains.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) (a : α) : Bool</code>",
 "3896":
 "<code>IndexMap α β</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "3895":
 "<code>IndexMap α β</code><span class=\"sep\"></span><code class=\"docstring\">`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{}` in identifiers is `empty`.\n\n * The recommended spelling of `∅` in identifiers is `empty`.</code>",
 "3894":
 "<code>EmptyCollection.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`EmptyCollection α` is the typeclass which supports the notation `∅`, also written as `{}`. </code>",
 "3893":
 "<code>∀ (i : Nat) (a : α), (Array.emptyWithCapacity capacity)[i]? = some a ↔ (HashMap.emptyWithCapacity capacity)[a]? = some i</code>",
 "3892":
 "<code>(Array.emptyWithCapacity capacity).size = (Array.emptyWithCapacity capacity).size</code>",
 "3891": "<code>Array β</code>",
 "3890":
 "<code>Array.emptyWithCapacity.{u} {α : Type u} (c : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new empty array with initial capacity `c`.\n</code>",
 "389": "<code>L.{u} : Type (u + 1)</code>",
 "3889":
 "<code>Std.HashMap.emptyWithCapacity.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (capacity : Nat := 8) : HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new empty hash map. The optional parameter `capacity` can be supplied to presize the\nmap so that it can hold the given number of mappings without reallocating. It is also possible to\nuse the empty collection notations `∅` and `{}` to create an empty hash map with the default\ncapacity.\n</code>",
 "3888": "<code>HashMap α Nat</code>",
 "3887": "<code>optParam Nat 8</code>",
 "3886":
 "<code>IndexMap.emptyWithCapacity.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (capacity : Nat := 8) : IndexMap α β</code>",
 "3885":
 "<code>IndexMap.size.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (m : IndexMap α β) : Nat</code>",
 "3884": "<code>IndexMap α β</code>",
 "3883": "<code>HashMap α Nat</code>",
 "3882":
 "<code>IndexMap.WF.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (self : IndexMap α β) (i : Nat) (a : α) :\n  self.keys[i]? = some a ↔ self.indices[a]? = some i</code>",
 "3881": "<code>Array β</code>",
 "3880":
 "<code>IndexMap.size_keys.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (self : IndexMap α β) :\n  self.keys.size = self.values.size</code>",
 "388": "<code>id₃.{u} (α : Type u) (a : α) : α</code>",
 "3879":
 "<code>IndexMap.values.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (self : IndexMap α β) : Array β</code>",
 "3878":
 "<code>IndexMap.keys.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (self : IndexMap α β) : Array α</code>",
 "3877":
 "<code>IndexMap.indices.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (self : IndexMap α β) : HashMap α Nat</code>",
 "3876":
 "<code>IndexMap.eraseSwap.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulBEq α] [LawfulHashable α]\n  (m : IndexMap α β) (a : α) : IndexMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Erase the key-value pair with the given key,\nmoving the last pair into its place in the order.\nIf the key is not present, the map is unchanged.\n</code>",
 "3875":
 "<code>IndexMap.insert.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] [LawfulHashable α] [LawfulBEq α]\n  (m : IndexMap α β) (a : α) (b : β) : IndexMap α β</code>",
 "3874":
 "<code>IndexMap.{u, v} (α : Type u) (β : Type v) [BEq α] [Hashable α] : Type (max u v)</code>",
 "3873":
 "<code>IfExpr.normalize_spec (assign : TreeMap Nat Bool compare) (e : IfExpr) :\n  (normalize assign e).normalized = true ∧\n    (∀ (f : Nat → Bool), eval f (normalize assign e) = eval (fun w =&gt; assign[w]?.getD (f w)) e) ∧\n      ∀ (v : Nat), v ∈ (normalize assign e).vars → ¬v ∈ assign</code>",
 "3872":
 "<code>Std.TreeMap.insert.{u, v} {α : Type u} {β : Type v} {cmp : α → α → Ordering} (l : TreeMap α β cmp) (a : α) (b : β) :\n  TreeMap α β cmp</code><span class=\"sep\"></span><code class=\"docstring\">Inserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n</code>",
 "3871": "<code>TreeMap Nat Bool compare</code>",
 "3870":
 "<code>IfExpr.normalize (assign : TreeMap Nat Bool compare) : IfExpr → IfExpr</code>",
 "387":
 "<code class=\"docstring\">Declares one or more universe variables.\n\n`universe u v`\n\n`Prop`, `Type`, `Type u` and `Sort u` are types that classify other types, also known as\n*universes*. In `Type u` and `Sort u`, the variable `u` stands for the universe's *level*, and a\nuniverse at level `u` can only classify universes that are at levels lower than `u`. For more\ndetails on type universes, please refer to [the relevant chapter of Theorem Proving in Lean][tpil\nuniverses].\n\nJust as type arguments allow polymorphic definitions to be used at many different types, universe\nparameters, represented by universe variables, allow a definition to be used at any required level.\nWhile Lean mostly handles universe levels automatically, declaring them explicitly can provide more\ncontrol when writing signatures. The `universe` keyword allows the declared universe variables to be\nused in a collection of definitions, and Lean will ensure that these definitions use them\nconsistently.\n\n[tpil universes]: https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects\n(Type universes on Theorem Proving in Lean)\n\n```lean\n/- Explicit type-universe parameter. -/\ndef id₁.{u} (α : Type u) (a : α) := a\n\n/- Implicit type-universe parameter, equivalent to `id₁`.\n  Requires option `autoImplicit true`, which is the default. -/\ndef id₂ (α : Type u) (a : α) := a\n\n/- Explicit standalone universe variable declaration, equivalent to `id₁` and `id₂`. -/\nuniverse u\ndef id₃ (α : Type u) (a : α) := a\n```\n\nOn a more technical note, using a universe variable only in the right-hand side of a definition\ncauses an error if the universe has not been declared previously.\n\n```lean\ndef L₁.{u} := List (Type u)\n\n-- def L₂ := List (Type u) -- error: `unknown universe level 'u'`\n\nuniverse u\ndef L₃ := List (Type u)\n```\n\n## Examples\n\n```lean\nuniverse u v w\n\nstructure Pair (α : Type u) (β : Type v) : Type (max u v) where\n  a : α\n  b : β\n\n#check Pair.{v, w}\n-- Pair : Type v → Type w → Type (max v w)\n```\n</code>",
 "3869":
 "<code>Std.HashMap.contains.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : HashMap α β) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if there is a mapping for the given key. There is also a `Prop`-valued version\nof this: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` uses\n`==` for comparisons, while for hash maps, both use `==`.\n</code>",
 "3868":
 "<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>",
 "3867":
 "<code>Option.getD.{u_1} {α : Type u_1} (opt : Option α) (dflt : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Gets an optional value, returning a given default on `none`.\n\nThis function is `@[macro_inline]`, so `dflt` will not be evaluated unless `opt` turns out to be\n`none`.\n\nExamples:\n * `(some \"hello\").getD \"goodbye\" = \"hello\"`\n * `none.getD \"goodbye\" = \"goodbye\"`\n</code>",
 "3866":
 "<code>IfExpr.normalize_spec (assign : HashMap Nat Bool) (e : IfExpr) :\n  (normalize assign e).normalized = true ∧\n    (∀ (f : Nat → Bool), eval f (normalize assign e) = eval (fun w =&gt; assign[w]?.getD (f w)) e) ∧\n      ∀ (v : Nat), v ∈ (normalize assign e).vars → ¬v ∈ assign</code>",
 "3865": "<code>IfExpr.normSize : IfExpr → Nat</code>",
 "3864":
 "<code>Std.HashMap.insert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : HashMap α β) (a : α) (b : β) :\n  HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Inserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nNote: this replacement behavior is true for `HashMap`, `DHashMap`, `HashMap.Raw` and `DHashMap.Raw`.\nThe `insert` function on `HashSet` and `HashSet.Raw` behaves differently: it will return the set\nunchanged if a matching key is already present.\n</code>",
 "3863":
 "<code>IfExpr.normalize (assign : HashMap Nat Bool) : IfExpr → IfExpr</code>",
 "3862": "<code>HashMap Nat Bool</code>",
 "3861": "<code>IfExpr → IfExpr</code>",
 "3860": "<code>IfNormalization : Type</code>",
 "386": "<code>List sorry</code>",
 "3859":
 "<code class=\"docstring\">The conditional function.\n\n`cond c x y` is the same as `if c then x else y`, but optimized for a Boolean condition rather than\na decidable proposition. It can also be written using the notation `bif c then x else y`.\n\nJust like `ite`, `cond` is declared `@[macro_inline]`, which causes applications of `cond` to be\nunfolded. As a result, `x` and `y` are not evaluated at runtime until one of them is selected, and\nonly the selected branch is evaluated.\n</code>",
 "3858":
 "<code>IfExpr.eval (f : Nat → Bool) : IfExpr → Bool</code><span class=\"sep\"></span><code class=\"docstring\">The evaluation of an if expression\nat some assignment of variables.\n</code>",
 "3857":
 "<code>IfExpr.normalized (e : IfExpr) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">An if expression is \"normalized\" if it has\nno nested, constant, or redundant ifs,\nand it evaluates each variable at most once.\n</code>",
 "3856":
 "<code>IfExpr.disjoint : IfExpr → Bool</code><span class=\"sep\"></span><code class=\"docstring\">An if expression evaluates each variable at most once if\nfor each if-then-else the variables in the \"if\" clause\nare disjoint from the variables in the \"then\" clause\nand the variables in the \"if\" clause\nare disjoint from the variables in the \"else\" clause.\n</code>",
 "3855":
 "<code>List.disjoint.{u_1} {α : Type u_1} [DecidableEq α] : List α → List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">A helper function to specify that two lists are disjoint.\n</code>",
 "3854":
 "<code>IfExpr.vars : IfExpr → List Nat</code><span class=\"sep\"></span><code class=\"docstring\">All the variables appearing in an if-expressions,\nread left to right, without removing duplicates.\n</code>",
 "3853":
 "<code>IfExpr.hasRedundantIf : IfExpr → Bool</code><span class=\"sep\"></span><code class=\"docstring\">An if-expression has a \"redundant if\" if\nit contains an if-then-else where\nthe \"then\" and \"else\" clauses are identical.\n</code>",
 "3852":
 "<code>IfExpr.hasConstantIf : IfExpr → Bool</code><span class=\"sep\"></span><code class=\"docstring\">An if-expression has a \"constant if\" if it contains\nan if-then-else where the \"if\" is itself a literal.\n</code>",
 "3851": "<code>IfExpr</code>",
 "3850":
 "<code>IfExpr.hasNestedIf : IfExpr → Bool</code><span class=\"sep\"></span><code class=\"docstring\">An if-expression has a \"nested if\" if it contains\nan if-then-else where the \"if\" is itself an if-then-else.\n</code>",
 "385": "<code>sorry</code>",
 "3849": "<code>IfExpr.ite : IfExpr → IfExpr → IfExpr → IfExpr</code>",
 "3848": "<code>IfExpr.var : Nat → IfExpr</code>",
 "3847": "<code>IfExpr.lit : Bool → IfExpr</code>",
 "3846":
 "<code>IfExpr : Type</code><span class=\"sep\"></span><code class=\"docstring\">An if-expression is either boolean literal, a\nnumbered variable, or an if-then-else expression\nwhere each subexpression is an if-expression.\n</code>",
 "3845":
 "<code>Std.TreeMap.{u, v} (α : Type u) (β : Type v) (cmp : α → α → Ordering := by exact compare) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Tree maps.\n\nA tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.\n\nTo ensure that the operations behave as expected, the comparator function `cmp` should satisfy\ncertain laws that ensure a consistent ordering:\n\n* If `a` is less than (or equal) to `b`, then `b` is greater than (or equal) to `a`\nand vice versa (see the `OrientedCmp` typeclass).\n* If `a` is less than or equal to `b` and `b` is, in turn, less than or equal to `c`, then `a`\nis less than or equal to `c` (see the `TransCmp` typeclass).\n\nKeys for which `cmp a b = Ordering.eq` are considered the same, i.e., there can be only one entry\nwith key either `a` or `b` in a tree map. Looking up either `a` or `b` always yields the same entry,\nif any is present.\n\nTo avoid expensive copies, users should make sure that the tree map is used linearly.\n\nInternally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.\n\nFor use in proofs, the type `Std.ExtTreeMap` of extensional tree maps should be preferred. This\ntype comes with several extensionality lemmas and provides the same functions but requires a\n`TransCmp` instance to work with.\n\nThese tree maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.TreeMap.Raw` and\n`Std.TreeMap.Raw.WF` unbundle the invariant from the tree map. When in doubt, prefer\n`TreeMap` over `TreeMap.Raw`.\n</code>",
 "3844":
 "<code>Nat.max_def {n m : Nat} : max n m = if n ≤ m then m else n</code>",
 "3843": "<code>R → Nat</code>",
 "3842": "<code>trig_identity (x : R) : cos x ^ 2 + sin x ^ 2 = 1</code>",
 "3841": "<code>cos : R → R</code>",
 "3840": "<code>sin : R → R</code>",
 "384":
 "<code>map.{u_1, u_2, u_3, u_4, u_5} {α : sorry} {β : sorry} (f : sorry) : List sorry → List sorry</code>",
 "3839": "<code>instCommRingR : CommRing R</code>",
 "3838": "<code>R : Type</code>",
 "3837":
 "<code>∀ {a b c : R}, a &lt; b → 0 &lt; c → a * c &lt; b * c</code><span class=\"sep\"></span><code class=\"docstring\">In a strict ordered semiring, we can multiply an inequality `a &lt; b` on the right\nby a positive element `0 &lt; c` to obtain `a * c &lt; b * c`. </code>",
 "3836":
 "<code>∀ {a b c : R}, a &lt; b → 0 &lt; c → c * a &lt; c * b</code><span class=\"sep\"></span><code class=\"docstring\">In a strict ordered semiring, we can multiply an inequality `a &lt; b` on the left\nby a positive element `0 &lt; c` to obtain `c * a &lt; c * b`. </code>",
 "3835":
 "<code>0 &lt; 1</code><span class=\"sep\"></span><code class=\"docstring\">In a strict ordered semiring, we have `0 &lt; 1`. </code>",
 "3834":
 "<code>Lean.Grind.OrderedRing.mk.{u} {R : Type u} [Semiring R] [LE R] [LT R] [Std.IsPreorder R] [toOrderedAdd : OrderedAdd R]\n  (zero_lt_one : 0 &lt; 1) (mul_lt_mul_of_pos_left : ∀ {a b c : R}, a &lt; b → 0 &lt; c → c * a &lt; c * b)\n  (mul_lt_mul_of_pos_right : ∀ {a b c : R}, a &lt; b → 0 &lt; c → a * c &lt; b * c) : OrderedRing R</code>",
 "3833":
 "<code>∀ {a b : M} (c : M), a ≤ b ↔ a + c ≤ b + c</code><span class=\"sep\"></span><code class=\"docstring\">`a + c ≤ b + c` iff `a ≤ b`. </code>",
 "3832":
 "<code>Lean.Grind.OrderedAdd.mk.{u} {M : Type u} [HAdd M M M] [LE M] [Std.IsPreorder M]\n  (add_le_left_iff : ∀ {a b : M} (c : M), a ≤ b ↔ a + c ≤ b + c) : OrderedAdd M</code>",
 "3831":
 "<code>∀ (n : Nat) (a : M), ↑n • a = n • a</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by natural numbers is consistent with scalar multiplication by integers. </code>",
 "3830":
 "<code>∀ (n m : Int) (a : M), (n + m) • a = n • a + m • a</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication is distributive over addition in the integers. </code>",
 "383":
 "<code>autoImplicit</code><span class=\"sep\"></span><code class=\"docstring\">Unbound local variables in declaration headers become implicit arguments. In \"relaxed\" mode (default), any atomic identifier is eligible, otherwise only single character followed by numeric digits are eligible. For example, `def f (x : Vector α n) : Vector α n :=` automatically introduces the implicit variables {α n}.</code>",
 "3829":
 "<code>∀ (a : M), 1 • a = a</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by one is the identity. </code>",
 "3828":
 "<code>SMul Int M</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by integers. </code>",
 "3827":
 "<code>Lean.Grind.AddCommGroup.{u} (M : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type with zero, addition, negation, and subtraction,\nwhere addition is commutative and associative,\nand negation is the left inverse of addition. </code>",
 "3826":
 "<code>Lean.Grind.IntModule.mk.{u} {M : Type u} [toAddCommGroup : AddCommGroup M] [nsmul : SMul Nat M] [zsmul : SMul Int M]\n  (zero_zsmul : ∀ (a : M), 0 • a = 0) (one_zsmul : ∀ (a : M), 1 • a = a)\n  (add_zsmul : ∀ (n m : Int) (a : M), (n + m) • a = n • a + m • a)\n  (zsmul_natCast_eq_nsmul : ∀ (n : Nat) (a : M), ↑n • a = n • a) : IntModule M</code>",
 "3825":
 "<code>∀ (n : Nat) (a : M), (n + 1) • a = n • a + a</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by a successor. </code>",
 "3824":
 "<code>∀ (a : M), 0 • a = 0</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by zero is zero. </code>",
 "3823":
 "<code>SMul Nat M</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by natural numbers. </code>",
 "3822":
 "<code>Lean.Grind.AddCommMonoid.{u} (M : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type with zero and addition,\nwhere addition is commutative and associative,\nand the zero is the right identity for addition. </code>",
 "3821":
 "<code>Lean.Grind.NatModule.mk.{u} {M : Type u} [toAddCommMonoid : AddCommMonoid M] [nsmul : SMul Nat M]\n  (zero_nsmul : ∀ (a : M), 0 • a = 0) (add_one_nsmul : ∀ (n : Nat) (a : M), (n + 1) • a = n • a + a) : NatModule M</code>",
 "3820":
 "<code>Std.IsPartialOrder.{u} (α : Type u) [LE α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">This typeclass states that the order structure on `α`, represented by an `LE α` instance,\nis a partial order.\nIn other words, the less-or-equal relation is reflexive, transitive and antisymmetric.\n</code>",
 "382": "<code>{α : Type u} → {β : Type v} → (α → β) → List α → List β</code>",
 "3819":
 "<code>Std.IsPreorder.{u} (α : Type u) [LE α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">This typeclass states that the order structure on `α`, represented by an `LE α` instance,\nis a preorder. In other words, the less-or-equal relation is reflexive and transitive.\n</code>",
 "3818": "<code>OrderedRing R</code>",
 "3817": "<code>CommRing R</code>",
 "3816": "<code>Std.LawfulOrderLT R</code>",
 "3815": "<code>Std.IsLinearOrder R</code>",
 "3814": "<code>LT R</code>",
 "3813": "<code>LE R</code>",
 "3812": "<code>a * b ≤ 1</code>",
 "3811":
 "<code>Lean.Grind.OrderedRing.{u} (R : Type u) [Semiring R] [LE R] [LT R] [Std.IsPreorder R] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A ring which is also equipped with a preorder is considered a strict ordered ring if addition, negation,\nand multiplication are compatible with the preorder, and `0 &lt; 1`.\n</code>",
 "3810": "<code>a ≤ b</code>",
 "381": "<code class=\"docstring\">The universe parameter v</code>",
 "3809": "<code>OrderedAdd α</code>",
 "3808": "<code>IntModule α</code>",
 "3807": "<code>Std.IsLinearOrder α</code>",
 "3806": "<code>Std.LawfulOrderLT α</code>",
 "3805": "<code>LT α</code>",
 "3804": "<code>LE α</code>",
 "3803":
 "<code>Lean.Grind.OrderedAdd.{u} (M : Type u) [HAdd M M M] [LE M] [Std.IsPreorder M] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Addition is compatible with a preorder if `a ≤ b ↔ a + c ≤ b + c`.\n</code>",
 "3802": "<code>Type ?u.38</code>",
 "3801":
 "<code>Std.IsLinearOrder.{u} (α : Type u) [LE α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">This typeclass states that the order structure on `α`, represented by an `LE α` instance,\nis a linear order.\nIn other words, the less-or-equal relation is reflexive, transitive, antisymmetric and total.\n</code>",
 "3800":
 "<code>Std.LawfulOrderLT.{u} (α : Type u) [LT α] [LE α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">This typeclass states that the synthesized `LT α` instance is compatible with the `LE α`\ninstance. This means that `LT.lt a b` holds if and only if `a` is less or equal to `b` according\nto the `LE α` instance, but `b` is not less or equal to `a`.\n\n`LawfulOrderLT α` automatically entails that `LT α` is asymmetric: `a &lt; b` and `b &lt; a` can never\nbe true simultaneously.\n\n`LT α` does not uniquely determine the `LE α`: There can be only one compatible order data\ninstance that is total, but there can be others that are not total.\n</code>",
 "380": "<code>Type v</code>",
 "38":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "3799":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">Maximum number of steps performed by the `ring` solver.\nA step is counted whenever one polynomial is used to simplify another.\nFor example, given `x^2 + 1` and `x^2 * y^3 + x * y`, the first can be\nused to simplify the second to `-1 * y^3 + x * y`.\n</code>",
 "3798": "<code>¬t ^ 2 = t + 1</code>",
 "3797": "<code>(d + t - d * t - 2) * PSO3_inv = 1</code>",
 "3796": "<code>d * d_inv = 1</code>",
 "3795":
 "<code>-d ^ 4 * (d + t - d * t - 2) *\n    (2 * d + 2 * d * t - 4 * d * t ^ 2 + 2 * d * t ^ 4 + 2 * d ^ 2 * t ^ 4 - c * (d + t + d * t)) =\n  0</code>",
 "3794": "<code>d ^ 2 * (d + t - d * t - 2) * (d + t + d * t) = 0</code>",
 "3793": "<code>M</code>",
 "3792":
 "<code>∀ (a b c : M), a + c = b + c → a = b</code><span class=\"sep\"></span><code class=\"docstring\">Addition is right-cancellative. </code>",
 "3791":
 "<code>Lean.Grind.AddRightCancel.mk.{u} {M : Type u} [Add M] (add_right_cancel : ∀ (a b c : M), a + c = b + c → a = b) :\n  Lean.Grind.AddRightCancel M</code>",
 "3790":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), uses procedure for handling equalities over commutative rings.\nThis solver also support commutative semirings, fields, and normalizer non-commutative rings and\nsemirings.\n</code>",
 "379":
 "<code>map.{u, v} {α : Type u} {β : Type v} (f : α → β) : List α → List β</code>",
 "3789": "<code>¬y * x = 1</code>",
 "3788": "<code>x * y ^ 2 = y</code>",
 "3787": "<code>x ^ 2 * y = 1</code>",
 "3786": "<code>∀ (k : Nat) (a : α), k ≠ 0 → k • a = 0 → a = 0</code>",
 "3785":
 "<code>Lean.Grind.IntModule.{u} (M : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A module over the integers, i.e. a type with zero, addition, negation, subtraction, and scalar multiplication by integers,\nsatisfying appropriate compatibilities.\n\nEquivalently, an additive commutative group.\n</code>",
 "3784": "<code>?m.49</code>",
 "3783":
 "<code>∀ (k : Nat) (a b : α), k ≠ 0 → k • a = k • b → a = b</code><span class=\"sep\"></span><code class=\"docstring\">If `k * a ≠ k * b` then `k ≠ 0` or `a ≠ b`.</code>",
 "3782":
 "<code>Lean.Grind.NoNatZeroDivisors.mk.{u} {α : Type u} [Lean.Grind.NatModule α]\n  (no_nat_zero_divisors : ∀ (k : Nat) (a b : α), k ≠ 0 → k • a = k • b → a = b) : Lean.Grind.NoNatZeroDivisors α</code>",
 "3781":
 "<code>Lean.Grind.NatModule.{u} (M : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A module over the natural numbers, i.e. a type with zero, addition, and scalar multiplication by natural numbers,\nsatisfying appropriate compatibilities.\n\nEquivalently, an additive commutative monoid.\n\nUse `IntModule` if the type has negation.\n</code>",
 "3780": "<code>¬b = -a</code>",
 "378": "<code>m α</code>",
 "3779": "<code>2 * a + 2 * b = 0</code>",
 "3778":
 "<code>∀ {x y : Nat}, OfNat.ofNat x = OfNat.ofNat y ↔ x % p = y % p</code><span class=\"sep\"></span><code class=\"docstring\">Two numerals in a semiring are equal iff they are congruent module `p` in the natural numbers. </code>",
 "3777":
 "<code>Lean.Grind.IsCharP.mk.{u} {α : Type u} [Lean.Grind.Semiring α] {p : outParam Nat}\n  (ofNat_ext_iff : ∀ {x y : Nat}, OfNat.ofNat x = OfNat.ofNat y ↔ x % p = y % p) : Lean.Grind.IsCharP α p</code>",
 "3776": "<code>outParam Nat</code>",
 "3775":
 "<code>∀ (a : α) (n : Int), a ^ (-n) = (a ^ n)⁻¹</code><span class=\"sep\"></span><code class=\"docstring\">Raising to a negative power is the inverse of raising to the positive power. </code>",
 "3774":
 "<code>∀ (a : α) (n : Nat), a ^ (↑n + 1) = a ^ ↑n * a</code><span class=\"sep\"></span><code class=\"docstring\">The (n+1)-st power of any element is the element multiplied by the n-th power. </code>",
 "3773":
 "<code>∀ {a : α}, a ≠ 0 → a * a⁻¹ = 1</code><span class=\"sep\"></span><code class=\"docstring\">The inverse of a non-zero element is a right inverse. </code>",
 "3772":
 "<code>0⁻¹ = 0</code><span class=\"sep\"></span><code class=\"docstring\">The inverse of zero is zero. This is a \"junk value\" convention. </code>",
 "3771":
 "<code>0 ≠ 1</code><span class=\"sep\"></span><code class=\"docstring\">Zero is not equal to one: fields are non trivial.</code>",
 "3770":
 "<code>Inv.inv.{u} {α : Type u} [self : Inv α] : α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a⁻¹` computes the inverse of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `⁻¹` in identifiers is `inv`.</code>",
 "377": "<code>α → Bool</code>",
 "3769":
 "<code>∀ (a b : α), a / b = a * b⁻¹</code><span class=\"sep\"></span><code class=\"docstring\">Division is multiplication by the inverse. </code>",
 "3768": "<code>HPow α Int α</code>",
 "3767":
 "<code>Lean.Grind.Field.mk.{u} {α : Type u} [toCommRing : Lean.Grind.CommRing α] [toInv : Inv α] [toDiv : Div α]\n  [zpow : HPow α Int α] (div_eq_mul_inv : ∀ (a b : α), a / b = a * b⁻¹) (zero_ne_one : 0 ≠ 1) (inv_zero : 0⁻¹ = 0)\n  (mul_inv_cancel : ∀ {a : α}, a ≠ 0 → a * a⁻¹ = 1) (zpow_zero : ∀ (a : α), a ^ 0 = 1)\n  (zpow_succ : ∀ (a : α) (n : Nat), a ^ (↑n + 1) = a ^ ↑n * a) (zpow_neg : ∀ (a : α) (n : Int), a ^ (-n) = (a ^ n)⁻¹) :\n  Lean.Grind.Field α</code>",
 "3766":
 "<code>Lean.Grind.CommRing.mk.{u} {α : Type u} [toRing : Lean.Grind.Ring α] (mul_comm : ∀ (a b : α), a * b = b * a) :\n  Lean.Grind.CommRing α</code>",
 "3765":
 "<code>∀ (i : Int), ↑(-i) = -↑i</code><span class=\"sep\"></span><code class=\"docstring\">The canonical map from the integers is consistent with negation. </code>",
 "3764":
 "<code>∀ (n : Nat), ↑(OfNat.ofNat n) = OfNat.ofNat n</code><span class=\"sep\"></span><code class=\"docstring\">The canonical map from the integers is consistent with the canonical map from the natural numbers. </code>",
 "3763":
 "<code>∀ (n : Nat) (a : α), ↑n • a = n • a</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by natural numbers is consistent with scalar multiplication by integers. </code>",
 "3762":
 "<code>∀ (i : Int) (a : α), -i • a = -(i • a)</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by the negation of an integer is the negation of scalar multiplication by that integer. </code>",
 "3761":
 "<code>∀ (a b : α), a - b = a + -b</code><span class=\"sep\"></span><code class=\"docstring\">Subtraction is addition of the negative. </code>",
 "3760":
 "<code>∀ (a : α), -a + a = 0</code><span class=\"sep\"></span><code class=\"docstring\">Negation is the left inverse of addition. </code>",
 "376": "<code>Type → Type u_1</code>",
 "3759":
 "<code>SMul Int α</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by integers. </code>",
 "3758":
 "<code>IntCast α</code><span class=\"sep\"></span><code class=\"docstring\">In every ring there is a canonical map from the integers to the ring. </code>",
 "3757":
 "<code>Lean.Grind.Ring.mk.{u} {α : Type u} [toSemiring : Lean.Grind.Semiring α] [toNeg : Neg α] [toSub : Sub α]\n  [intCast : IntCast α] [zsmul : SMul Int α] (neg_add_cancel : ∀ (a : α), -a + a = 0)\n  (sub_eq_add_neg : ∀ (a b : α), a - b = a + -b) (neg_zsmul : ∀ (i : Int) (a : α), -i • a = -(i • a))\n  (zsmul_natCast_eq_nsmul : ∀ (n : Nat) (a : α), ↑n • a = n • a := by intros; rfl)\n  (intCast_ofNat : ∀ (n : Nat), ↑(OfNat.ofNat n) = OfNat.ofNat n := by intros; rfl)\n  (intCast_neg : ∀ (i : Int), ↑(-i) = -↑i := by intros; rfl) : Lean.Grind.Ring α</code>",
 "3756":
 "<code>∀ (a b : α), a * b = b * a</code><span class=\"sep\"></span><code class=\"docstring\">Multiplication is commutative. </code>",
 "3755":
 "<code>Lean.Grind.CommSemiring.mk.{u} {α : Type u} [toSemiring : Lean.Grind.Semiring α]\n  (mul_comm : ∀ (a b : α), a * b = b * a) : Lean.Grind.CommSemiring α</code>",
 "3754":
 "<code>HSMul.hSMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HSMul α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a • b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent, but it is intended to be used for left actions. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `•` in identifiers is `smul`.</code>",
 "3753": "<code>∀ (n : Nat) (a : α), n • a = ↑n * a</code>",
 "3752":
 "<code>∀ (n : Nat), OfNat.ofNat n = ↑n</code><span class=\"sep\"></span><code class=\"docstring\">Numerals are consistently defined with respect to the canonical map from natural numbers. </code>",
 "3751":
 "<code>∀ (a : Nat), OfNat.ofNat (a + 1) = OfNat.ofNat a + 1</code><span class=\"sep\"></span><code class=\"docstring\">Numerals are consistently defined with respect to addition. </code>",
 "3750":
 "<code>∀ (a : α) (n : Nat), a ^ (n + 1) = a ^ n * a</code><span class=\"sep\"></span><code class=\"docstring\">The successor power law for exponentiation. </code>",
 "375":
 "<code>count.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → Bool) (act : m α) : m Nat</code>",
 "3749":
 "<code>∀ (a : α), a ^ 0 = 1</code><span class=\"sep\"></span><code class=\"docstring\">The zeroth power of any element is one. </code>",
 "3748":
 "<code>∀ (a : α), a * 0 = 0</code><span class=\"sep\"></span><code class=\"docstring\">Zero is left absorbing for multiplication. </code>",
 "3747":
 "<code>∀ (a : α), 0 * a = 0</code><span class=\"sep\"></span><code class=\"docstring\">Zero is right absorbing for multiplication. </code>",
 "3746":
 "<code>∀ (a b c : α), (a + b) * c = a * c + b * c</code><span class=\"sep\"></span><code class=\"docstring\">Right distributivity of multiplication over addition. </code>",
 "3745":
 "<code>∀ (a b c : α), a * (b + c) = a * b + a * c</code><span class=\"sep\"></span><code class=\"docstring\">Left distributivity of multiplication over addition. </code>",
 "3744":
 "<code>∀ (a : α), 1 * a = a</code><span class=\"sep\"></span><code class=\"docstring\">One is the left identity for multiplication. </code>",
 "3743":
 "<code>∀ (a : α), a * 1 = a</code><span class=\"sep\"></span><code class=\"docstring\">One is the right identity for multiplication. </code>",
 "3742":
 "<code>∀ (a b c : α), a * b * c = a * (b * c)</code><span class=\"sep\"></span><code class=\"docstring\">Multiplication is associative. </code>",
 "3741":
 "<code>∀ (a b c : α), a + b + c = a + (b + c)</code><span class=\"sep\"></span><code class=\"docstring\">Addition is associative. </code>",
 "3740":
 "<code>∀ (a b : α), a + b = b + a</code><span class=\"sep\"></span><code class=\"docstring\">Addition is commutative. </code>",
 "374": "<code>id'.{u_1} {α : Sort u_1} (x : α) : α</code>",
 "3739":
 "<code>∀ (a : α), a + 0 = a</code><span class=\"sep\"></span><code class=\"docstring\">Zero is the right identity for addition. </code>",
 "3738":
 "<code>HPow α Nat α</code><span class=\"sep\"></span><code class=\"docstring\">Exponentiation by a natural number. </code>",
 "3737":
 "<code>SMul.{u, v} (M : Type u) (α : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`) </code>",
 "3736":
 "<code>SMul Nat α</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication by natural numbers. </code>",
 "3735": "<code>NatCast α</code>",
 "3734":
 "<code>autoParam (∀ (n : Nat), OfNat.ofNat n = ↑n) Lean.Grind.Semiring.ofNat_eq_natCast._autoParam</code>",
 "3733":
 "<code>(n : Nat) → OfNat α n</code><span class=\"sep\"></span><code class=\"docstring\">Natural number numerals in the semiring.\nThe field `ofNat_eq_natCast` ensures that these are (propositionally) equal to the values of `natCast`.\n</code>",
 "3732":
 "<code>NatCast α</code><span class=\"sep\"></span><code class=\"docstring\">In every semiring there is a canonical map from the natural numbers to the semiring,\nproviding the values of `0` and `1`. Note that this function need not be injective.\n</code>",
 "3731":
 "<code>Lean.Grind.Semiring.mk.{u} {α : Type u} [toAdd : Add α] [toMul : Mul α] [natCast : NatCast α]\n  [ofNat : (n : Nat) → OfNat α n] [nsmul : SMul Nat α] [npow : HPow α Nat α] (add_zero : ∀ (a : α), a + 0 = a)\n  (add_comm : ∀ (a b : α), a + b = b + a) (add_assoc : ∀ (a b c : α), a + b + c = a + (b + c))\n  (mul_assoc : ∀ (a b c : α), a * b * c = a * (b * c)) (mul_one : ∀ (a : α), a * 1 = a) (one_mul : ∀ (a : α), 1 * a = a)\n  (left_distrib : ∀ (a b c : α), a * (b + c) = a * b + a * c)\n  (right_distrib : ∀ (a b c : α), (a + b) * c = a * c + b * c) (zero_mul : ∀ (a : α), 0 * a = 0)\n  (mul_zero : ∀ (a : α), a * 0 = 0) (pow_zero : ∀ (a : α), a ^ 0 = 1)\n  (pow_succ : ∀ (a : α) (n : Nat), a ^ (n + 1) = a ^ n * a)\n  (ofNat_succ : ∀ (a : Nat), OfNat.ofNat (a + 1) = OfNat.ofNat a + 1 := by intros; rfl)\n  (ofNat_eq_natCast : ∀ (n : Nat), OfNat.ofNat n = ↑n := by intros; rfl)\n  (nsmul_eq_natCast_mul : ∀ (n : Nat) (a : α), n • a = ↑n * a := by intros; rfl) : Lean.Grind.Semiring α</code>",
 "3730":
 "<code>Lean.Grind.NoNatZeroDivisors.{u} (α : Type u) [Lean.Grind.NatModule α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">We say a module has no natural number zero divisors if\n`k ≠ 0` and `k * a = k * b` implies `a = b` (here `k` is a natural number and `a` and `b` are element of the module).\n\nFor a module over the integers this is equivalent to\n`k ≠ 0` and `k * a = 0` implies `a = 0`.\n(See the alternative constructor `NoNatZeroDivisors.mk'`,\nand the theorem `eq_zero_of_mul_eq_zero`.)\n</code>",
 "373":
 "<code>rfl.{u} {α : Sort u} {a : α} : Eq.{u} a a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>",
 "3729":
 "<code>Lean.Grind.AddRightCancel.{u} (M : Type u) [Add M] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A type where addition is right-cancellative, i.e. `a + c = b + c` implies `a = b`.\n</code>",
 "3728":
 "<code>Lean.Grind.CommSemiring.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A commutative semiring, i.e. a semiring with commutative multiplication.\n\nUse `CommRing` if the type has negation.\n</code>",
 "3727":
 "<code>Lean.Grind.Ring.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A ring, i.e. a type equipped with addition, negation, multiplication, and a map from the integers,\nsatisfying appropriate compatibilities.\n\nUse `CommRing` if the multiplication is commutative.\n</code>",
 "3726":
 "<code>Lean.Grind.Semiring.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A semiring, i.e. a type equipped with addition, multiplication, and a map from the natural numbers,\nsatisfying appropriate compatibilities.\n\nUse `Ring` instead if the type also has negation,\n`CommSemiring` if the multiplication is commutative,\nor `CommRing` if the type has negation and multiplication is commutative.\n</code>",
 "3725": "<code>b + 3 * c = 0</code>",
 "3724": "<code>c = c + 9</code>",
 "3723": "<code>a + 6 = a</code>",
 "3722": "<code>IsCharP α 0</code>",
 "3721":
 "<code>Lean.Grind.IsCharP.{u} (α : Type u) [Lean.Grind.Semiring α] (p : outParam Nat) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A ring `α` has characteristic `p` if `OfNat.ofNat x = 0` iff `x % p = 0`.\n\nNote that for `p = 0`, we have `x % p = x`, so this says that `OfNat.ofNat` is injective from `Nat` to `α`.\n\nIn the case of a semiring, we take the stronger condition that\n`OfNat.ofNat x = OfNat.ofNat y` iff `x % p = y % p`.\n</code>",
 "3720":
 "<code>∀ (x : α), ↑x ∈ range</code><span class=\"sep\"></span><code class=\"docstring\">The embedding function lands in the interval. </code>",
 "372": "<code>test.{u, v} : Eq.{1} (T.{u} 0) (T.{v} 0)</code>",
 "3719":
 "<code>Lean.Grind.ToInt.toInt.{u} {α : Type u} {range : outParam Lean.Grind.IntInterval} [self : Lean.Grind.ToInt α range] :\n  α → Int</code><span class=\"sep\"></span><code class=\"docstring\">The embedding function. </code>",
 "3718":
 "<code>∀ (x y : α), ↑x = ↑y → x = y</code><span class=\"sep\"></span><code class=\"docstring\">The embedding function is injective. </code>",
 "3717":
 "<code>α → Int</code><span class=\"sep\"></span><code class=\"docstring\">The embedding function. </code>",
 "3716":
 "<code>Lean.Grind.ToInt.mk.{u} {α : Type u} {range : outParam Lean.Grind.IntInterval} (toInt : α → Int)\n  (toInt_inj : ∀ (x y : α), toInt x = toInt y → x = y) (toInt_mem : ∀ (x : α), toInt x ∈ range) :\n  Lean.Grind.ToInt α range</code>",
 "3715":
 "<code>Lean.Grind.IntInterval : Type</code><span class=\"sep\"></span><code class=\"docstring\">An interval in the integers (either finite, half-infinite, or infinite). </code>",
 "3714": "<code>outParam Lean.Grind.IntInterval</code>",
 "3713":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `mbtc` is `true`, `grind` will use model-based theory combination for creating new case splits.\nSee paper \"Model-based Theory Combination\" for details.\n</code>",
 "3712": "<code>¬f (x + y) = 0</code>",
 "3711": "<code>¬y = 1</code>",
 "3710": "<code>y + -1 ≤ 0</code>",
 "371":
 "<code>pp.universes</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display universe</code>",
 "3709": "<code>-1 * y ≤ 0</code>",
 "3708": "<code>f x = 0</code>",
 "3707": "<code>Int → Int</code>",
 "3706": "<code>a * a * b ≤ a + 1</code>",
 "3705": "<code>a + 1 ≠ a * b * a</code>",
 "3704":
 "<code>trace.grind.cutsat.assert</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "3703": "<code>y + 1 ≤ 0</code>",
 "3702": "<code>x * x + 1 ≤ 0</code>",
 "3701":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `qlia` is `true`, `grind` may generate counterexamples for integer constraints\nusing rational numbers, and ignoring divisibility constraints.\nThis approach is cheaper but incomplete. </code>",
 "3700": "<code>9 * x + -7 * y + -4 ≤ 0</code>",
 "370": "<code>T.{u} : Nat → Bool</code>",
 "37":
 "<code>Lean.SourceInfo.none : SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">A synthesized token without position information. </code>",
 "3699": "<code>-9 * x + 7 * y + -10 ≤ 0</code>",
 "3698": "<code>13 * x + 11 * y + -30 ≤ 0</code>",
 "3697": "<code>-13 * x + -11 * y + 27 ≤ 0</code>",
 "3696":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), uses procedure for handling linear integer arithmetic for `Int` and `Nat`.\n</code>",
 "3695": "<code>2 ∣ 2 * a + b</code>",
 "3694": "<code>2 ∣ a + b</code>",
 "3693": "<code>2 ∣ a + 1</code>",
 "3692":
 "<code>Lean.Grind.ToInt.{u} (α : Type u) (range : outParam Lean.Grind.IntInterval) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`ToInt α I` asserts that `α` can be embedded faithfully into an interval `I` in the integers.\n</code>",
 "3691":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `matchEqs` is `true`, `grind` uses `match`-equations as E-matching theorems. </code>",
 "3690": "<code>x = n + 1</code>",
 "369":
 "<code>Alternative.failure.{u, v} {f : Type u → Type v} [self : Alternative f] {α : Type u} : f α</code><span class=\"sep\"></span><code class=\"docstring\">Produces an empty collection or recoverable failure.  The `&lt;|&gt;` operator collects values or recovers\nfrom failures. See `Alternative` for more details.\n</code>",
 "3689":
 "<code>(match x with\n  | 0 =&gt; 0\n  | n.succ =&gt; 1) =\n  0</code>",
 "3688": "<code>x = y + 1</code>",
 "3687": "<code>x✝ = n✝.succ</code>",
 "3686": "<code>(n : Nat) → motive n.succ</code>",
 "3685": "<code>Unit → motive 0</code>",
 "3684":
 "<code>gt1.match_1.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive 0) (h_2 : (n : Nat) → motive n.succ) :\n  motive x✝</code>",
 "3683":
 "<code>gt1.match_1.congr_eq_2.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive 0)\n  (h_2 : (n : Nat) → motive n.succ) (n✝ : Nat) (heq_1 : x✝ = n✝.succ) :\n  (match x✝ with\n    | 0 =&gt; h_1 ()\n    | n.succ =&gt; h_2 n) ≍\n    h_2 n✝</code>",
 "3682":
 "<code>gt1 (x y : Nat) :\n  x = y + 1 →\n    0 &lt;\n      match x with\n      | 0 =&gt; 0\n      | n.succ =&gt; 1</code>",
 "3681":
 "<code>Lean.Grind.CommSemiring.toSemiring.{u} {α : Type u} [self : Lean.Grind.CommSemiring α] : Lean.Grind.Semiring α</code>",
 "3680": "<code>instHAdd.{u_1} {α : Type u_1} [Add α] : HAdd α α α</code>",
 "368":
 "<code class=\"docstring\">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,\nskipping any further statements.\nNote that uses of the `do` keyword in other syntax like in `for _ in _ do`\ndo not constitute a surrounding block in this sense;\nin supported editors, the corresponding `do` keyword of the surrounding block\nis highlighted when hovering over `return`.\n\n`return` not followed by a term starting on the same line is equivalent to `return ()`.\n</code>",
 "3679": "<code>instOfNatNat (n : Nat) : OfNat Nat n</code>",
 "3678":
 "<code>Nat.Linear.Expr.rec.{u} {motive : Nat.Linear.Expr → Sort u} (num : (v : Nat) → motive (Nat.Linear.Expr.num v))\n  (var : (i : Nat.Linear.Var) → motive (Nat.Linear.Expr.var i))\n  (add : (a b : Nat.Linear.Expr) → motive a → motive b → motive (a.add b))\n  (mulL : (k : Nat) → (a : Nat.Linear.Expr) → motive a → motive (Nat.Linear.Expr.mulL k a))\n  (mulR : (a : Nat.Linear.Expr) → (k : Nat) → motive a → motive (a.mulR k)) (t : Nat.Linear.Expr) : motive t</code>",
 "3677":
 "<code>Bool.casesOn.{u} {motive : Bool → Sort u} (t : Bool) (false : motive false) (true : motive true) : motive t</code>",
 "3676":
 "<code>List.casesOn.{u_1, u} {α : Type u} {motive : List α → Sort u_1} (t : List α) (nil : motive [])\n  (cons : (head : α) → (tail : List α) → motive (head :: tail)) : motive t</code>",
 "3675":
 "<code>Lean.Grind.Ring.toSemiring.{u} {α : Type u} [self : Lean.Grind.Ring α] : Lean.Grind.Semiring α</code>",
 "3674":
 "<code>Std.LinearPreorderPackage.toPreorderPackage.{u} {α : Type u} [self : Std.LinearPreorderPackage α] :\n  Std.PreorderPackage α</code>",
 "3673":
 "<code>diagnostics</code><span class=\"sep\"></span><code class=\"docstring\">collect diagnostic information</code>",
 "3672":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">Maximum term generation.\nThe input goal terms have generation 0. When we instantiate a theorem using a term from generation `n`,\nthe new terms have generation `n+1`. Thus, this parameter limits the length of an instantiation chain. </code>",
 "3671":
 "<code>Lean.Grind.Ring.OfSemiring.toQ.{u} {α : Type u} [Lean.Grind.Semiring α] (a : α) : Lean.Grind.Ring.OfSemiring.Q α</code>",
 "3670":
 "<code>Lean.Grind.Ring.OfSemiring.Q.{u} (α : Type u) [Lean.Grind.Semiring α] : Type u</code>",
 "367": "<code>Char.mk (val : UInt32) (valid : val.isValidChar) : Char</code>",
 "3669": "<code>(iota 20).length ≤ 10</code>",
 "3668": "<code>iota_succ {n : Nat} : iota (n + 1) = n :: iota n</code>",
 "3667": "<code>iota : Nat → List Nat</code>",
 "3666":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">Maximum number of E-matching (aka heuristic theorem instantiation) rounds before each case split. </code>",
 "3665": "<code>s 0 = 0</code>",
 "3664": "<code>s (x : Nat) : Nat</code>",
 "3663": "<code>s_eq (x : Nat) : s x = s (x + 1)</code>",
 "3662":
 "<code>h₆ {y x : Nat} : q (y + 2) = q y → q (y + 1) = q y → p (x + 2) = 7</code>",
 "3661": "<code>h₅ {x y : Nat} (w : p x = q y) : p (x + 2) = 7</code>",
 "3660": "<code>p x = q y</code>",
 "366":
 "<code>UInt32.isValidChar (n : UInt32) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A `UInt32` denotes a valid Unicode code point if it is less than `0x110000` and it is also not a\nsurrogate code point (the range `0xd800` to `0xdfff` inclusive).\n</code>",
 "3659": "<code>h₄ {x y : Nat} (w : p x = q y) : p (x + 2) = 7</code>",
 "3658": "<code>h₃ {x : Nat} (w : 7 = p (q x)) : p (x + 1) = q x</code>",
 "3657": "<code>h₂ {x : Nat} (w : 7 = p (q x)) : p (x + 1) = q x</code>",
 "3656":
 "<code>Lean.Grind.offset (a b : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for representing offsets `t+k` in patterns. </code>",
 "3655":
 "<code>trace.grind.debug.ematch.pattern</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "3654": "<code>7 = p (q x)</code>",
 "3653":
 "<code class=\"docstring\">Like `@[grind!]`, but also prints the pattern(s) selected by `grind`\nas info messages. Combines minimal subexpression selection with debugging output.\n</code>",
 "3652": "<code>h₁ {x : Nat} (w : 7 = p (q x)) : p (x + 1) = q x</code>",
 "3651": "<code>q : Nat → Nat</code>",
 "3650": "<code>p : Nat → Nat</code>",
 "365": "<code>v.isValidChar</code>",
 "3649":
 "<code class=\"docstring\">Like `@[grind]`, but also prints the pattern(s) selected by `grind`\nas info messages. Useful for debugging annotations and modifiers.\n</code>",
 "3648":
 "<code>Nat.instDvd : Dvd Nat</code><span class=\"sep\"></span><code class=\"docstring\">Divisibility of natural numbers. `a ∣ b` (typed as `\\|`) says that\nthere is some `c` such that `b = a * c`.\n</code>",
 "3647": "<code>Nat.mul_assoc (n m k : Nat) : n * m * k = n * (m * k)</code>",
 "3646":
 "<code>Exists.intro.{u} {α : Sort u} {p : α → Prop} (w : α) (h : p w) : Exists p</code><span class=\"sep\"></span><code class=\"docstring\">Existential introduction. If `a : α` and `h : p a`,\nthen `⟨a, h⟩` is a proof that `∃ x : α, p x`. </code>",
 "3645": "<code>j = k * d₂</code>",
 "3644": "<code>k = n * d₁</code>",
 "3643": "<code>div_trans {n k j : Nat} : n ∣ k → k ∣ j → n ∣ j</code>",
 "3642":
 "<code>decreasingCorrect'' {xs : List Int} : (decreasing xs = true) = Decreasing xs</code>",
 "3641": "<code>Decreasing (y :: x :: xs)</code>",
 "3640": "<code>y &gt; x</code>",
 "364": "<code>UInt32</code>",
 "3639": "<code>Decreasing (x :: xs)</code>",
 "3638":
 "<code>decreasingCorrect' {xs : List Int} : (decreasing xs = true) = Decreasing xs</code>",
 "3637": "<code>(true = true) = ¬Decreasing [head]</code>",
 "3636": "<code>(true = true) = ¬Decreasing []</code>",
 "3635": "<code>¬Decreasing (y :: x :: xs)</code>",
 "3634": "<code>decreasing (x :: xs) = true</code>",
 "3633": "<code>-1 * y + x + 1 ≤ 0</code>",
 "3632":
 "<code>(-1 * y + x + 1 ≤ 0 ∧ decreasing (x :: xs) = true) = ¬Decreasing (y :: x :: xs)</code>",
 "3631": "<code>(decreasing (x :: xs) = true) = Decreasing (x :: xs)</code>",
 "3630":
 "<code>(decreasing (x✝ :: xs✝) = true) = Decreasing (x✝ :: xs✝)</code>",
 "363": "<code>Array UInt32 → Nat → Option (Char × Nat)</code>",
 "3629":
 "<code>decreasingCorrect {xs : List Int} : (decreasing xs = true) = Decreasing xs</code>",
 "3628": "<code>List Int</code>",
 "3627":
 "<code>Decreasing.cons {x : Int} {xs : List Int} {y : Int} : Decreasing (x :: xs) → y &gt; x → Decreasing (y :: x :: xs)</code>",
 "3626": "<code>Decreasing.singleton {x : Int} : Decreasing [x]</code>",
 "3625": "<code>Decreasing.nil : Decreasing []</code>",
 "3624": "<code>decreasing : List Int → Bool</code>",
 "3623": "<code>Decreasing : List Int → Prop</code>",
 "3622": "<code>Even x</code>",
 "3621":
 "<code class=\"docstring\">The `intro` modifier instructs `grind` to use the constructors (introduction rules)\nof an inductive predicate as E-matching theorems.Example:\n```\ninductive Even : Nat → Prop where\n| zero : Even 0\n| add2 : Even x → Even (x + 2)\n\nattribute [grind intro] Even\nexample (h : Even x) : Even (x + 6) := by grind\nexample : Even 0 := by grind\n```\nHere `attribute [grind intro] Even` acts like a macro that expands to\n`attribute [grind] Even.zero` and `attribute [grind] Even.add2`.\nThis is especially convenient for inductive predicates with many constructors.\n</code>",
 "3620": "<code>Even.add2 {x : Nat} : Even x → Even (x + 2)</code>",
 "362":
 "<code>Char.val (self : Char) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The underlying Unicode scalar value as a `UInt32`. </code>",
 "3619":
 "<code>B {n k : Nat} : double (n + 5) = double (k - 3) → n + 8 = k</code>",
 "3618": "<code>double_inj : Function.Injective double</code>",
 "3617":
 "<code class=\"docstring\">The `inj` modifier marks injectivity theorems for use by `grind`.\nThe conclusion of the theorem must be of the form `Function.Injective f`\nwhere the term `f` contains at least one constant symbol.\n</code>",
 "3616":
 "<code>NatCast.natCast.{u} {R : Type u} [self : NatCast R] : Nat → R</code><span class=\"sep\"></span><code class=\"docstring\">The canonical map `Nat → R`. </code>",
 "3615": "<code>-1 * ↑k + 3 ≤ 0</code>",
 "3614": "<code>¬n + 8 = k</code>",
 "3613": "<code>double (n + 5) = double (k - 3)</code>",
 "3612":
 "<code>A {n k : Nat} : double (n + 5) = double (k - 3) → n + 8 = k</code>",
 "3611": "<code>double (x : Nat) : Nat</code>",
 "3610": "<code>?m.8 → ?m.9</code>",
 "361":
 "<code>Array.push.{u} {α : Type u} (a : Array α) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Adds an element to the end of an array. The resulting array's size is one greater than the input\narray. If there are no other references to the array, then it is modified in-place.\n\nThis takes amortized `O(1)` time because `Array α` is represented by a dynamic array.\n\nExamples:\n* `#[].push \"apple\" = #[\"apple\"]`\n* `#[\"apple\"].push \"orange\" = #[\"apple\", \"orange\"]`\n</code>",
 "3609":
 "<code>Function.Injective.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} (f : α → β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f : α → β` is called injective if `f x = f y` implies `x = y`. </code>",
 "3608": "<code>swap_swap_eq_id' : Point.swap ∘ Point.swap = id</code>",
 "3607":
 "<code class=\"docstring\">The `ext` modifier marks extensionality theorems for use by `grind`.\nFor example, the standard library marks `funext` with this attribute.\n\nWhenever `grind` encounters a disequality `a ≠ b`, it attempts to apply any\navailable extensionality theorems whose matches the type of `a` and `b`.\n</code>",
 "3606": "<code>id.eq_1.{u} {α : Sort u} (a : α) : id a = a</code>",
 "3605": "<code>¬{ x := w.x, y := w.y } = id w</code>",
 "3604":
 "<code>¬((fun p =&gt; { x := p.y, y := p.x }) ∘ fun p =&gt; { x := p.y, y := p.x }) = id</code>",
 "3603": "<code>swap_swap_eq_id : Point.swap ∘ Point.swap = id</code>",
 "3602": "<code>Point.swap (p : Point) : Point</code>",
 "3601": "<code>¬p = { x := p.x, y := p.y }</code>",
 "3600": "<code>Int</code>",
 "360": "<code>Char</code>",
 "36":
 "<code>Lean.SourceInfo.synthetic (pos endPos : String.Pos.Raw) (canonical : Bool := false) : SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">Synthetic syntax is syntax that was produced by a metaprogram or by Lean itself (e.g. by a\nquotation). Synthetic syntax is annotated with a source span from the original syntax, which\nrelates it to the source file.\n\nThe delaborator uses this constructor to store an encoded indicator of which core language\nexpression gave rise to the syntax.\n\nThe `canonical` flag on synthetic syntax is enabled for syntax that is not literally part of the\noriginal input syntax but should be treated “as if” the user really wrote it for the purpose of\nhovers and error messages. This is usually used on identifiers in order to connect the binding\nsite to the user's original syntax even if the name of the identifier changes during expansion, as\nwell as on tokens that should receive targeted messages.\n\nGenerally speaking, a macro expansion should only use a given piece of input syntax in a single\ncanonical token. An exception to this rule is when the same identifier is used to declare two\nbinders, as in the macro expansion for dependent if:\n```\n`(if $h : $cond then $t else $e) ~&gt;\n`(dite $cond (fun $h =&gt; $t) (fun $h =&gt; $t))\n```\nIn these cases, if the user hovers over `h` they will see information about both binding sites.\n</code>",
 "3599": "<code>Point.mk (x y : Int) : Point</code>",
 "3598": "<code>Point</code>",
 "3597": "<code>Point.y (self : Point) : Int</code>",
 "3596": "<code>Point.x (self : Point) : Int</code>",
 "3595": "<code>Point : Type</code>",
 "3594": "<code>a * b = 1</code>",
 "3593":
 "<code>Inv.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for inverses.\nThis enables the notation `a⁻¹ : α` where `a : α`.\n</code>",
 "3592":
 "<code>inv_eq.{u_1} {α : Type u_1} [Inv α] [One α] [Mul α] [Inv α] {a b : α} (w : a * b = 1) : a⁻¹ = b</code>",
 "3591":
 "<code class=\"docstring\">Like `@[grind]`, but enforces the **minimal indexable subexpression condition**:\nwhen several subterms cover the same free variables, `grind!` chooses the smallest one.\n\nThis influences E-matching pattern selection.\n\n### Example\n```lean\ntheorem fg_eq (h : x &gt; 0) : f (g x) = x\n\n@[grind &lt;-] theorem fg_eq (h : x &gt; 0) : f (g x) = x\n-- Pattern selected: `f (g x)`\n\n-- With minimal subexpression:\n@[grind! &lt;-] theorem fg_eq (h : x &gt; 0) : f (g x) = x\n-- Pattern selected: `g x`\n</code>",
 "3590":
 "<code class=\"docstring\">The `[grind!?]` attribute is identical to the `[grind!]` attribute, but displays inferred pattern information.When applied to an equational theorem, `[grind =]`, `[grind =_]`, or `[grind _=_]`will mark the theorem for use in heuristic instantiations by the `grind` tactic,\n      using respectively the left-hand side, the right-hand side, or both sides of the theorem.When applied to a function, `[grind =]` automatically annotates the equational theorems associated with that function.When applied to a theorem `[grind ←]` will instantiate the theorem whenever it encounters the conclusion of the theorem\n      (that is, it will use the theorem for backwards reasoning).When applied to a theorem `[grind →]` will instantiate the theorem whenever it encounters sufficiently many of the propositional hypotheses\n      (that is, it will use the theorem for forwards reasoning).The attribute `[grind]` by itself will effectively try `[grind ←]` (if the conclusion is sufficient for instantiation) and then `[grind →]`.The `grind` tactic utilizes annotated theorems to add instances of matching patterns into the local context during proof search.For example, if a theorem `@[grind =] theorem foo_idempotent : foo (foo x) = foo x` is annotated,`grind` will add an instance of this theorem to the local context whenever it encounters the pattern `foo (foo x)`.</code>",
 "359": "<code>Array UInt32</code>",
 "3589":
 "<code class=\"docstring\">The `[grind!]` attribute is used to annotate declarations, but selecting minimal indexable subterms.When applied to an equational theorem, `[grind =]`, `[grind =_]`, or `[grind _=_]`will mark the theorem for use in heuristic instantiations by the `grind` tactic,\n      using respectively the left-hand side, the right-hand side, or both sides of the theorem.When applied to a function, `[grind =]` automatically annotates the equational theorems associated with that function.When applied to a theorem `[grind ←]` will instantiate the theorem whenever it encounters the conclusion of the theorem\n      (that is, it will use the theorem for backwards reasoning).When applied to a theorem `[grind →]` will instantiate the theorem whenever it encounters sufficiently many of the propositional hypotheses\n      (that is, it will use the theorem for forwards reasoning).The attribute `[grind]` by itself will effectively try `[grind ←]` (if the conclusion is sufficient for instantiation) and then `[grind →]`.The `grind` tactic utilizes annotated theorems to add instances of matching patterns into the local context during proof search.For example, if a theorem `@[grind =] theorem foo_idempotent : foo (foo x) = foo x` is annotated,`grind` will add an instance of this theorem to the local context whenever it encounters the pattern `foo (foo x)`.</code>",
 "3588":
 "<code class=\"docstring\">The `[grind?]` attribute is identical to the `[grind]` attribute, but displays inferred pattern information.When applied to an equational theorem, `[grind =]`, `[grind =_]`, or `[grind _=_]`will mark the theorem for use in heuristic instantiations by the `grind` tactic,\n      using respectively the left-hand side, the right-hand side, or both sides of the theorem.When applied to a function, `[grind =]` automatically annotates the equational theorems associated with that function.When applied to a theorem `[grind ←]` will instantiate the theorem whenever it encounters the conclusion of the theorem\n      (that is, it will use the theorem for backwards reasoning).When applied to a theorem `[grind →]` will instantiate the theorem whenever it encounters sufficiently many of the propositional hypotheses\n      (that is, it will use the theorem for forwards reasoning).The attribute `[grind]` by itself will effectively try `[grind ←]` (if the conclusion is sufficient for instantiation) and then `[grind →]`.The `grind` tactic utilizes annotated theorems to add instances of matching patterns into the local context during proof search.For example, if a theorem `@[grind =] theorem foo_idempotent : foo (foo x) = foo x` is annotated,`grind` will add an instance of this theorem to the local context whenever it encounters the pattern `foo (foo x)`.</code>",
 "3587": "<code>¬b = c</code>",
 "3586": "<code>f c = a</code>",
 "3585": "<code>f b = a</code>",
 "3584": "<code>Even (n + 2)</code>",
 "3583":
 "<code>trace.grind.split</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "3582": "<code>Even 5</code>",
 "3581": "<code>Even.step {n : Nat} : Even n → Even (n + 2)</code>",
 "3580":
 "<code class=\"docstring\">The `cases` modifier marks inductively-defined predicates as suitable for case splitting.\n</code>",
 "358": "<code>Array UInt32 → Char → Array UInt32</code>",
 "3579": "<code>n = 30</code>",
 "3578": "<code>Not30 n</code>",
 "3577": "<code>Not30.lt {x : Nat} : x &lt; 30 → Not30 x</code>",
 "3576": "<code>Not30.gt {x : Nat} : x &gt; 30 → Not30 x</code>",
 "3575": "<code>Not30 : Nat → Prop</code>",
 "3574":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `splitMatch` is `true`, `grind` performs case-splitting on `match`-expressions during the search. </code>",
 "3573":
 "<code>_example.match_1.congr_eq_2.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive 0)\n  (h_2 : (x : Nat) → motive x) (x✝¹ : Nat) (heq_1 : x✝ = x✝¹) :\n  (x✝¹ = 0 → False) →\n    (match x✝ with\n      | 0 =&gt; h_1 ()\n      | x =&gt; h_2 x) ≍\n      h_2 x✝¹</code>",
 "3572":
 "<code>Lean.Grind.genPattern.{u} {α : Sort u} (_h : Prop) (x _val : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for representing generalization steps `h : x = val` in patterns\nThis gadget is used to represent patterns in theorems that have been generalized to reduce the\nnumber of casts introduced during E-matching based instantiation.\n\nFor example, consider the theorem\n```\nOption.pbind_some {α1 : Type u_1} {a : α1} {α2 : Type u_2}\n    {f : (a_1 : α1) → some a = some a_1 → Option α2}\n    : (some a).pbind f = f a rfl\n```\nNow, suppose we have a goal containing the term `c.pbind g` and the equivalence class\n`{c, some b}`. The E-matching module generates the instance\n```\n(some b).pbind (cast ⋯ g)\n```\nThe `cast` is necessary because `g`'s type contains `c` instead of `some b.\nThis `cast` problematic because we don't have a systematic way of pushing casts over functions\nto its arguments. Moreover, heterogeneous equality is not effective because the following theorem\nis not provable in DTT:\n```\ntheorem hcongr (h₁ : f ≍ g) (h₂ : a ≍ b)  : f a ≍ g b := ...\n```\nThe standard solution is to generalize the theorem above and write it as\n```\ntheorem Option.pbind_some'\n        {α1 : Type u_1} {a : α1} {α2 : Type u_2}\n        {x : Option α1}\n        {f : (a_1 : α1) → x = some a_1 → Option α2}\n        (h : x = some a)\n        : x.pbind f = f a h := by\n  subst h\n  apply Option.pbind_some\n```\nInternally, we use this gadget to mark the E-matching pattern as\n```\n(genPattern h x (some a)).pbind f\n```\nThis pattern is matched in the same way we match `(some a).pbind f`, but it saves the proof\nfor the actual term to the `some`-application in `f`, and the actual term in `x`.\n\nIn the example above, `c.pbind g` also matches the pattern `(genPattern h x (some a)).pbind f`,\nand stores `c` in `x`, `b` in `a`, and the proof that `c = some b` in `h`.\n</code>",
 "3571":
 "<code>_example.match_1.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive 0) (h_2 : (x : Nat) → motive x) :\n  motive x✝</code>",
 "3570":
 "<code>_example.match_1.congr_eq_1.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive 0)\n  (h_2 : (x : Nat) → motive x) (heq_1 : x✝ = 0) :\n  (match x✝ with\n    | 0 =&gt; h_1 ()\n    | x =&gt; h_2 x) ≍\n    h_1 ()</code>",
 "357": "<code>Type</code>",
 "3569": "<code>y = 0</code>",
 "3568": "<code>y =\n  match x with\n  | 0 =&gt; 1\n  | x =&gt; 2</code>",
 "3567":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">Maximum number of case-splits in a proof search branch. It does not include splits performed during normalization. </code>",
 "3566":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `splitIte` is `true`, `grind` performs case-splitting on `if-then-else` expressions during the search. </code>",
 "3565": "<code>¬y = 0</code>",
 "3564": "<code>¬x = 0</code>",
 "3563": "<code>(if c = true then x else y) = 0</code>",
 "3562":
 "<code>Dvd.{u_1} (α : Type u_1) : Type u_1</code><span class=\"sep\"></span><code class=\"docstring\">Notation typeclass for the `∣` operation (typed as `\\|`), which represents divisibility. </code>",
 "3561": "<code>¬w = z</code>",
 "3560": "<code>w = x ∨ w = v</code>",
 "356": "<code>Codec.char : Codec</code>",
 "3559": "<code>y = z</code>",
 "3558": "<code>?m.16</code>",
 "3557":
 "<code>trace.grind.eqc</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "3556":
 "<code>Lean.Meta.Grind.propagateBoolNotDown : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">`Bool` version of `propagateNotDown` </code>",
 "3555": "<code>(!a) = true</code>",
 "3554": "<code>c = true</code>",
 "3553":
 "<code>Lean.Meta.Grind.propagateBoolAndUp : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">`Bool` version of `propagateAndUp` </code>",
 "3552":
 "<code>Lean.Meta.Grind.propagateDIte : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates `dite` upwards </code>",
 "3551":
 "<code>Lean.Meta.Grind.propagateIte : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates `ite` upwards </code>",
 "3550":
 "<code>Lean.Meta.Grind.propagateEqDown : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates `Eq` downwards </code>",
 "355":
 "<code>Codec.decode.{u} (self : Codec) : Array UInt32 → Nat → Option (self.type × Nat)</code>",
 "3549":
 "<code>Lean.Meta.Grind.propagateEqUp : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates `Eq` upwards </code>",
 "3548":
 "<code>Lean.Meta.Grind.propagateNotDown : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates truth values downwards for a negation expression `Not a` based on the truth value of `Not a`.\nThis function performs the following:\n\n- If `(Not a) = False`, propagates `a = True`.\n- If `(Not a) = True`, propagates `a = False`.\n</code>",
 "3547":
 "<code>Lean.Meta.Grind.propagateNotUp : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates equalities for a negation `Not a` based on the truth value of `a`.\nThis function checks the truth value of `a` and propagates the following equalities:\n\n- If `a = False`, propagates `(Not a) = True`.\n- If `a = True`, propagates `(Not a) = False`.\n</code>",
 "3546":
 "<code>Lean.Meta.Grind.propagateOrDown : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates truth values downwards for a disjunction `a ∨ b` when the\nexpression itself is known to be `False`.\n</code>",
 "3545":
 "<code>Lean.Meta.Grind.propagateOrUp : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagates equalities for a disjunction `a ∨ b` based on the truth values\nof its components `a` and `b`. This function checks the truth value of `a` and `b`,\nand propagates the following equalities:\n\n- If `a = False`, propagates `(a ∨ b) = b`.\n- If `b = False`, propagates `(a ∨ b) = a`.\n- If `a = True`, propagates `(a ∨ b) = True`.\n- If `b = True`, propagates `(a ∨ b) = True`.\n</code>",
 "3544":
 "<code>Lean.Grind.eq_true_of_and_eq_true_right {a b : Prop} (h : (a ∧ b) = True) : b = True</code>",
 "3543":
 "<code>Lean.Grind.eq_true_of_and_eq_true_left {a b : Prop} (h : (a ∧ b) = True) : a = True</code>",
 "3542":
 "<code>ExamplePropagators.propagateAndDown : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Truth flows *down* when the whole `And` is proven `True`.\n</code>",
 "3541":
 "<code>Lean.Grind.and_eq_of_eq_false_right {a b : Prop} (h : b = False) : (a ∧ b) = False</code>",
 "3540":
 "<code>Lean.Meta.Grind.mkEqFalseProof (a : Expr) : GoalM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns a proof that `a = False`.\nIt assumes `a` and `False` are in the same equivalence class.\n</code>",
 "354":
 "<code>UInt32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Unsigned 32-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 32-bit value\nrather than wrapping a `BitVec 32`.\n</code>",
 "3539":
 "<code>Lean.Grind.and_eq_of_eq_false_left {a b : Prop} (h : a = False) : (a ∧ b) = False</code>",
 "3538":
 "<code>Lean.Meta.Grind.isEqFalse (e : Expr) : GoalM Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `e` is in the equivalence class of `False`. </code>",
 "3537":
 "<code>Lean.Grind.and_eq_of_eq_true_right {a b : Prop} (h : b = True) : (a ∧ b) = a</code>",
 "3536":
 "<code>Lean.Meta.Grind.mkEqTrueProof (a : Expr) : GoalM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns a proof that `a = True`.\nIt assumes `a` and `True` are in the same equivalence class.\n</code>",
 "3535":
 "<code>Lean.mkConst (declName : Name) (us : List Level := []) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">`mkConst declName us` return `.const declName us`. </code>",
 "3534": "<code>Lean.mkApp3 (f a b c : Expr) : Expr</code>",
 "3533":
 "<code>Lean.Meta.Grind.isEqTrue (e : Expr) : GoalM Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `e` is in the equivalence class of `True`. </code>",
 "3532": "<code>Expr</code>",
 "3531":
 "<code>ExamplePropagators.propagateAndUp : Propagator</code><span class=\"sep\"></span><code class=\"docstring\">Propagate equalities *upwards* for conjunctions. </code>",
 "3530":
 "<code class=\"docstring\">A builtin propagator for the `grind` tactic. </code>",
 "353":
 "<code>Codec.encode.{u} (self : Codec) : Array UInt32 → self.type → Array UInt32</code>",
 "3529":
 "<code>Lean.Meta.Grind.closeGoal (falseProof : Expr) : GoalM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Closes the current goal using the given proof of `False` and\nmarks it as inconsistent if it is not already marked so.\n</code>",
 "3528":
 "<code>Lean.Grind.and_eq_of_eq_true_left {a b : Prop} (h : a = True) : (a ∧ b) = b</code>",
 "3527":
 "<code>Lean.Meta.Grind.pushEqFalse (a proof : Expr) : GoalM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Pushes `a = False` with `proof` to `newEqs`. </code>",
 "3526":
 "<code>Lean.Meta.Grind.pushEqTrue (a proof : Expr) : GoalM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Pushes `a = True` with `proof` to `newEqs`. </code>",
 "3525":
 "<code>Lean.Meta.Grind.pushEq (lhs rhs proof : Expr) : GoalM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Pushes `lhs = rhs` with `proof` to `newEqs`. </code>",
 "3524":
 "<code class=\"docstring\">The `[grind]` attribute is used to annotate declarations.When applied to an equational theorem, `[grind =]`, `[grind =_]`, or `[grind _=_]`will mark the theorem for use in heuristic instantiations by the `grind` tactic,\n      using respectively the left-hand side, the right-hand side, or both sides of the theorem.When applied to a function, `[grind =]` automatically annotates the equational theorems associated with that function.When applied to a theorem `[grind ←]` will instantiate the theorem whenever it encounters the conclusion of the theorem\n      (that is, it will use the theorem for backwards reasoning).When applied to a theorem `[grind →]` will instantiate the theorem whenever it encounters sufficiently many of the propositional hypotheses\n      (that is, it will use the theorem for forwards reasoning).The attribute `[grind]` by itself will effectively try `[grind ←]` (if the conclusion is sufficient for instantiation) and then `[grind →]`.The `grind` tactic utilizes annotated theorems to add instances of matching patterns into the local context during proof search.For example, if a theorem `@[grind =] theorem foo_idempotent : foo (foo x) = foo x` is annotated,`grind` will add an instance of this theorem to the local context whenever it encounters the pattern `foo (foo x)`.</code>",
 "3523":
 "<code>S.mk.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} (x : α) (y : β) : S α β</code>",
 "3522":
 "<code>S.{u_1, u_2} (α : Sort u_1) (β : Sort u_2) : Sort (max (max 1 u_1) u_2)</code>",
 "3521": "<code>S α β</code>",
 "3520": "<code>Sort ?u.596</code>",
 "352": "<code>Codec.type.{u} (self : Codec) : Type u</code>",
 "3519":
 "<code>cast.{u} {α β : Sort u} (h : α = β) (a : α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Cast across a type equality. If `h : α = β` is an equality of types, and\n`a : α`, then `a : β` will usually not typecheck directly, but this function\nwill allow you to work around this and embed `a` in type `β` as `cast h a : β`.\n\nIt is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "3518": "<code>(x, y) = (x', y')</code>",
 "3517": "<code>f y = g y</code>",
 "3516": "<code>β → β</code>",
 "3515": "<code>t₁ = t₂</code>",
 "3514":
 "<code class=\"docstring\">`grind?` takes the same arguments as `grind`, but reports an equivalent call to `grind only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the `grind`\ntheorems in a local invocation.\n</code>",
 "3513": "<code>Fin 11</code>",
 "3512": "<code>b = c</code>",
 "3511":
 "<code>Lean.Meta.Rewrite.Config.occs (self : Lean.Meta.Rewrite.Config) : Lean.Meta.Occurrences</code><span class=\"sep\"></span><code class=\"docstring\">Which occurrences to rewrite</code>",
 "3510":
 "<code class=\"docstring\">Auxiliary attribute for simplification procedures.\n</code>",
 "351": "<code>Codec.{u} : Type (u + 1)</code>",
 "3509":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default : `true`), then `simp` will remove unused `let` and `have` expressions:\n`let x := v; e` simplifies to `e` when `x` does not occur in `e`.\n</code>",
 "3508":
 "<code>Lean.Meta.DSimp.Config.mk (zeta beta eta : Bool) (etaStruct : Lean.Meta.EtaStructMode)\n  (iota proj decide autoUnfold failIfUnchanged unfoldPartialApp zetaDelta index zetaUnused zetaHave : Bool) :\n  Lean.Meta.DSimp.Config</code>",
 "3507":
 "<code>Lean.Elab.Tactic.elabSimpConfig (optConfig : Lean.Syntax) (kind : Lean.Elab.Tactic.SimpKind) :\n  Lean.Elab.Tactic.TacticM Lean.Meta.Simp.Config</code>",
 "3506":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), the `^` simprocs generate an warning it the exponents are too big.\n</code>",
 "3505":
 "<code>BitVec.ofNat (n i : Nat) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">The bitvector with value `i mod 2^n`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `0#n` in identifiers is `zero` (not `ofNat_zero`).\n\n * The recommended spelling of `1#n` in identifiers is `one` (not `ofNat_one`).</code>",
 "3504":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), the bitvector simprocs use `BitVec.ofNat` for representing\nbitvector literals.\n</code>",
 "3503":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), `simp` tries to realize constant `f.congr_simp`\nwhen constructing an auxiliary congruence proof for `f`.\nThis option exists because the termination prover uses `simp` and `withoutModifyingEnv`\nwhile constructing the termination proof. Thus, any constant realized by `simp`\nis deleted.\n</code>",
 "3502":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default : `true`), then `simp` will attempt to transform `let`s into `have`s\nif they are non-dependent. This only applies when `zeta := false`.\n</code>",
 "3501":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `false` (default: `true`), then disables zeta reduction of `have` expressions.\nIf `zeta` is `false`, then this option has no effect.\nUnused `have`s are still removed if `zeta` or `zetaUnused` are true.\n</code>",
 "3500":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default : `true`), then `simp` catches runtime exceptions and\nconverts them into `simp` exceptions.\n</code>",
 "350": "<code>Type 2</code>",
 "35":
 "<code>Lean.SourceInfo.original (leading : Substring) (pos : String.Pos.Raw) (trailing : Substring) (endPos : String.Pos.Raw) :\n  SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">A token produced by the parser from original input that includes both leading and trailing\nwhitespace as well as position information.\n\nThe `leading` whitespace is inferred after parsing by `Syntax.updateLeading`. This is because the\n“preceding token” is not well-defined during parsing, especially in the presence of backtracking.\n</code>",
 "3499":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default : `true`), then `simp` removes unused `let` and `have` expressions:\n`let x := v; e` simplifies to `e` when `x` does not occur in `e`.\nThis option takes precedence over `zeta` and `zetaHave`.\n</code>",
 "3498":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `implicitDefEqProofs := true`, `simp` does not create proof terms when the\ninput and output terms are definitionally equal.\n</code>",
 "3497":
 "<code>Verso.Genre.Manual.index (args : Array (Verso.Doc.Inline Manual)) (subterm index : Option String := none) :\n  Verso.Doc.Inline Manual</code>",
 "3496":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `index` (default : `true`) is `false`, `simp` will only use the root symbol\nto find candidate `simp` theorems. It approximates Lean 3 `simp` behavior.\n</code>",
 "3495":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), local definitions are unfolded.\nThat is, given a local context containing `x : t := e`, then the free variable `x` reduces to `e`.\nOtherwise, `x` must be provided as a `simp` argument.\n</code>",
 "3494":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `unfoldPartialApp` is `true` (default: `false`), then calls to `simp`, `dsimp`, or `simp_all`\nwill unfold even partial applications of `f` when we request `f` to be unfolded.\n</code>",
 "3493":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `ground` is `true` (default: `false`), then ground terms are reduced.\nA term is ground when it does not contain free or meta variables.\nReduction is interrupted at a function application `f ...` if `f` is marked to not be unfolded.\nGround term reduction applies `@[seval]` lemmas.\n</code>",
 "3492":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `failIfUnchanged` is `true` (default: `true`), then calls to `simp`, `dsimp`, or `simp_all`\nwill fail if they do not make progress.\n</code>",
 "3491":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`) then switches to `dsimp` on dependent arguments\nif there is no congruence theorem that would allow `simp` to visit them.\nWhen `dsimp` is `false`, then the argument is not visited.\n</code>",
 "3490":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), unfolds applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be enabled using the `simp!` syntax.\n</code>",
 "349": "<code>Type 1</code>",
 "3489":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), rewrites a proposition `p` to `True` or `False` by inferring\na `Decidable p` instance and reducing it.\n</code>",
 "3488":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), reduces projections of structure constructors.\n</code>",
 "3487":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), reduces `match` expressions applied to constructors.\n</code>",
 "3486":
 "<code>Lean.Meta.EtaStructMode : Type</code><span class=\"sep\"></span><code class=\"docstring\">Which structure types should eta be used with? </code>",
 "3485":
 "<code>Lean.Meta.EtaStructMode</code><span class=\"sep\"></span><code class=\"docstring\">Configures how to determine definitional equality between two structure instances.\nSee documentation for `Lean.Meta.EtaStructMode`.\n</code>",
 "3484": "<code>?m.14</code>",
 "3483":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">TODO (currently unimplemented). When `true` (default: `true`), performs eta reduction for `fun` expressions.\nThat is, `(fun x =&gt; f x)` reduces to `f`.\n</code>",
 "3482":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), performs beta reduction of applications of `fun` expressions.\nThat is, `(fun x =&gt; e[x]) v` reduces to `e[v]`.\n</code>",
 "3481":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), performs zeta reduction of `let` and `have` expressions.\nThat is, `let x := v; e[x]` reduces to `e[v]`.\nIf `zetaHave` is `false` then `have` expressions are not zeta reduced.\nSee also `zetaDelta`.\n</code>",
 "3480":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `singlePass` is `true` (default: `false`), the simplifier runs through a single round of simplification,\nwhich consists of running pre-methods, recursing using congruence lemmas, and then running post-methods.\nOtherwise, when it is `false`, it iteratively applies this simplification procedure.\n</code>",
 "348": "<code>Type 5</code>",
 "3479":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When true (default: `true`) then the simplifier caches the result of simplifying each sub-expression, if possible.\n</code>",
 "3478": "<code>Sort ?u.13872</code>",
 "3477": "<code>Sort ?u.13871</code>",
 "3476":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `contextual` is true (default: `false`) and simplification encounters an implication `p → q`\nit includes `p` as an additional simp lemma when simplifying `q`.\n</code>",
 "3475":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">When simp discharges side conditions for conditional lemmas, it can recursively apply simplification.\nThe `maxDischargeDepth` (default: 2) is the maximum recursion depth when recursively applying simplification to side conditions.\n</code>",
 "3474":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The maximum number of subexpressions to visit when performing simplification.\nThe default is 100000.\n</code>",
 "3473":
 "<code>Lean.Meta.Simp.Config.mk (maxSteps maxDischargeDepth : Nat) (contextual memoize singlePass zeta beta eta : Bool)\n  (etaStruct : Lean.Meta.EtaStructMode)\n  (iota proj decide arith autoUnfold dsimp failIfUnchanged ground unfoldPartialApp zetaDelta index implicitDefEqProofs\n    zetaUnused catchRuntime zetaHave letToHave congrConsts bitVecOfNat warnExponents : Bool) :\n  Lean.Meta.Simp.Config</code>",
 "3472":
 "<code>Lean.Meta.Simp.neutralConfig : Lean.Meta.Simp.Config</code><span class=\"sep\"></span><code class=\"docstring\">A neutral configuration for `simp`, turning off all reductions and other built-in simplifications.\n</code>",
 "3471": "<code>Nat.reduceAdd : Lean.Meta.Simp.DSimproc</code>",
 "3470": "<code>Nat.zero_add (n : Nat) : 0 + n = n</code>",
 "347": "<code>P</code>",
 "3469": "<code>List.length_nil.{u} {α : Type u} : [].length = 0</code>",
 "3468":
 "<code>List.length_cons.{u} {α : Type u} {a : α} {as : List α} : (a :: as).length = as.length + 1</code>",
 "3467":
 "<code>List.size_toArray.{u} {α : Type u} {as : List α} : as.toArray.size = as.length</code>",
 "3466": "<code>xs.size = 2</code>",
 "3465": "<code>Array Unit</code>",
 "3464":
 "<code>Lean.Meta.SimpExtension.getTheorems (ext : Lean.Meta.SimpExtension) : Lean.CoreM Lean.Meta.SimpTheorems</code>",
 "3463":
 "<code>Lean.Meta.addSimpTheorem (ext : Lean.Meta.SimpExtension) (declName : Lean.Name) (post inv : Bool)\n  (attrKind : Lean.AttributeKind) (prio : Nat) : Lean.MetaM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Adds a simp theorem to a simp extension\n</code>",
 "3462": "<code>autoParam Lean.Name _auto✝</code>",
 "3461": "<code>Lean.Name</code>",
 "3460":
 "<code>Lean.Meta.SimpExtension : Type</code><span class=\"sep\"></span><code class=\"docstring\">The environment extension that contains a simp set, returned by `Lean.Meta.registerSimpAttr`.\n\nUse the simp set's attribute or `Lean.Meta.addSimpTheorem` to add theorems to the simp set. Use\n`Lean.Meta.SimpExtension.getTheorems` to get the contents.\n</code>",
 "346": "<code class=\"docstring\">The universe level 3</code>",
 "3459":
 "<code>Lean.Meta.registerSimpAttr (attrName : Lean.Name) (attrDescr : String) (ref : Lean.Name := by exact decl_name%) :\n  IO Lean.Meta.SimpExtension</code><span class=\"sep\"></span><code class=\"docstring\">Registers the given name as a custom simp set. Applying the name as an attribute to a name adds it\nto the simp set, and using the name as a parameter to the `simp` tactic causes `simp` to use the\nincluded lemmas.\n\nCustom simp sets must be registered during [initialization](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=initialization).\n\nThe description should be a short, singular noun phrase that describes the contents of the custom\nsimp set.\n</code>",
 "3458": "<code>p (x + 12)</code>",
 "3457": "<code>p (x + 7)</code>",
 "3456": "<code>p (3 + x + 9)</code>",
 "3455": "<code>p (x + 5 + 2)</code>",
 "3454": "<code>iff_self (p : Prop) : (p ↔ p) = True</code>",
 "3453": "<code>eq_self.{u_1} {α : Sort u_1} (a : α) : (a = a) = True</code>",
 "3452":
 "<code>Lean.Meta.DSimp.Config : Type</code><span class=\"sep\"></span><code class=\"docstring\">The configuration for `dsimp`.\nPassed to `dsimp` using, for example, the `dsimp (config := {zeta := false})` syntax.\n\nImplementation note: this structure is only used for processing the `(config := ...)` syntax, and it is not used internally.\nIt is immediately converted to `Lean.Meta.Simp.Config` by `Lean.Elab.Tactic.elabSimpConfig`.\n</code>",
 "3451":
 "<code>Lean.Meta.Simp.Config : Type</code><span class=\"sep\"></span><code class=\"docstring\">The configuration for `simp`.\nPassed to `simp` using, for example, the `simp +contextual` or `simp (maxSteps := 100000)` syntax.\n\nSee also `Lean.Meta.Simp.neutralConfig` and `Lean.Meta.DSimp.Config`.\n</code>",
 "3450":
 "<code>Lean.Meta.Simp.Config.autoUnfold (self : Lean.Meta.Simp.Config) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), unfolds applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be enabled using the `simp!` syntax.\n</code>",
 "345": "<code class=\"docstring\">The universe level 1</code>",
 "3449":
 "<code>Std.BaseMutex : Type</code><span class=\"sep\"></span><code class=\"docstring\">Mutual exclusion primitive (a lock).\n\nIf you want to guard shared state, use `Mutex α` instead.\n</code>",
 "3448": "<code>Std.BaseMutex</code>",
 "3447":
 "<code>Std.Mutex.atomicallyOnce {m : Type → Type} {α β : Type} [Monad m] [MonadLiftT BaseIO m] [MonadFinally m]\n  (mutex : Std.Mutex α) (condvar : Std.Condvar) (pred : Std.AtomicT α m Bool) (k : Std.AtomicT α m β) : m β</code><span class=\"sep\"></span><code class=\"docstring\">`mutex.atomicallyOnce condvar pred k` runs `k`, waiting on `condvar` until `pred` returns true.\nBoth `k` and `pred` have access to the mutex's state.\n\nCalling `mutex.atomicallyOnce` while already holding the underlying `BaseMutex` in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using `RecursiveMutex`.\n</code>",
 "3446": "<code>Std.AtomicT α m Bool</code>",
 "3445":
 "<code>Std.Condvar : Type</code><span class=\"sep\"></span><code class=\"docstring\">Condition variable, a synchronization primitive to be used with a `BaseMutex` or `Mutex`.\n\nThe thread that wants to modify the shared variable must:\n1. Lock the `BaseMutex` or `Mutex`\n2. Work on the shared variable\n3. Call `Condvar.notifyOne` or `Condvar.notifyAll` after it is done. Note that this may be done\n   before or after the mutex is unlocked.\n\nIf working with a `Mutex` the thread that waits on the `Condvar` can use `Mutex.atomicallyOnce`\nto wait until a condition is true. If working with a `BaseMutex` it must:\n1. Lock the `BaseMutex`.\n2. Do one of the following:\n  - Use `Condvar.waitUntil` to (potentially repeatedly wait) on the condition variable until\n     the condition is true.\n  - Implement the waiting manually by:\n    1. Checking the condition\n    2. Calling `Condvar.wait` which releases the `BaseMutex` and suspends execution until the\n       condition variable is notified.\n    3. Check the condition and resume waiting if not satisfied.\n</code>",
 "3444": "<code>Std.Condvar</code>",
 "3443":
 "<code>Std.Mutex.atomically {m : Type → Type} {α β : Type} [Monad m] [MonadLiftT BaseIO m] [MonadFinally m]\n  (mutex : Std.Mutex α) (k : Std.AtomicT α m β) : m β</code><span class=\"sep\"></span><code class=\"docstring\">`mutex.atomically k` runs `k` with access to the mutex's state while locking the mutex.\n\nCalling `mutex.atomically` while already holding the underlying `BaseMutex` in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using `RecursiveMutex`.\n</code>",
 "3442":
 "<code>Std.AtomicT (σ : Type) (m : Type → Type) (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">`AtomicT α m` is the monad that can be atomically executed inside mutual exclusion primitives like\n`Mutex α` with outside monad `m`.\nThe action has access to the state `α` of the mutex (via `get` and `set`).\n</code>",
 "3441": "<code>Std.AtomicT α m β</code>",
 "3440": "<code>Std.Mutex α</code>",
 "344": "<code class=\"docstring\">The universe level 2</code>",
 "3439":
 "<code>Std.Mutex (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `Mutex α` is similar to `IO.Ref α`, except that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n</code>",
 "3438":
 "<code>Std.CloseableChannel.Sync (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A multi-producer multi-consumer FIFO channel that offers both bounded and unbounded buffering\nand a synchronous API. This type acts as a convenient layer to use a channel in a blocking fashion\nand is not actually different from the original channel.\n\nAdditionally `Std.CloseableChannel.Sync` can be closed if necessary, unlike `Std.Channel.Sync`.\nThis introduces the need to handle errors in some cases, thus it is usually easier to use\n`Std.Channel` if applicable.\n</code>",
 "3437":
 "<code>Std.Channel.Sync (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A multi-producer multi-consumer FIFO channel that offers both bounded and unbounded buffering\nand a synchronous API. This type acts as a convenient layer to use a channel in a blocking fashion\nand is not actually different from the original channel.\n\nIf a channel needs to be closed to indicate some sort of completion event use\n`Std.CloseableChannel.Sync` instead. Note that `Std.CloseableChannel.Sync` introduces a need for error\nhandling in some cases, thus `Std.Channel.Sync` is usually easier to use if applicable.\n</code>",
 "3436":
 "<code>Std.Channel.forAsync {α : Type} [Inhabited α] (f : α → BaseIO Unit) (ch : Std.Channel α)\n  (prio : Task.Priority := Task.Priority.default) : BaseIO (Task Unit)</code><span class=\"sep\"></span><code class=\"docstring\">`ch.forAsync f` calls `f` for every message received on `ch`.\n\nNote that if this function is called twice, each message will only arrive at exactly one invocation.\n</code>",
 "3435": "<code>Std.Channel α</code>",
 "3434": "<code>?m.21</code>",
 "3433": "<code>optParam (Option Nat) none</code>",
 "3432":
 "<code>Std.Channel (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A multi-producer multi-consumer FIFO channel that offers both bounded and unbounded buffering\nand an asynchronous API. To switch into synchronous mode use `Channel.sync`.\n\nIf a channel needs to be closed to indicate some sort of completion event use `Std.CloseableChannel`\ninstead. Note that `Std.CloseableChannel` introduces a need for error handling in some cases, thus\n`Std.Channel` is usually easier to use if applicable.\n</code>",
 "3431":
 "<code>Std.CloseableChannel (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A multi-producer multi-consumer FIFO channel that offers both bounded and unbounded buffering\nand an asynchronous API, to switch into synchronous mode use `CloseableChannel.sync`.\n\nAdditionally `Std.CloseableChannel` can be closed if necessary, unlike `Std.Channel`.\nThis introduces a need for error handling in some cases, thus it is usually easier to use\n`Std.Channel` if applicable.\n</code>",
 "3430": "<code>IO.Promise α</code>",
 "343": "<code class=\"docstring\">The universe level 4</code>",
 "3429":
 "<code>IO.wait {α : Type} (t : Task α) : BaseIO α</code><span class=\"sep\"></span><code class=\"docstring\">Waits for the task to finish, then returns its result.\n</code>",
 "3428":
 "<code>IO.Promise.resolve {α : Type} (value : α) (promise : Promise α) : BaseIO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Resolves a `Promise`.\n\nOnly the first call to this function has an effect.\n</code>",
 "3427":
 "<code>IO.Promise (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">`Promise α` allows you to create a `Task α` whose value is provided later by calling `resolve`.\n\nTypical usage is as follows:\n1. `let promise ← Promise.new` creates a promise\n2. `promise.result? : Task (Option α)` can now be passed around\n3. `promise.result?.get` blocks until the promise is resolved\n4. `promise.resolve a` resolves the promise\n5. `promise.result?.get` now returns `some a`\n\nIf the promise is dropped without ever being resolved, `promise.result?.get` will return `none`.\nSee `Promise.result!/resultD` for other ways to handle this case.\n</code>",
 "3426":
 "<code>IO.TaskState : Type</code><span class=\"sep\"></span><code class=\"docstring\">The current state of a `Task` in the Lean runtime's task manager. </code>",
 "3425":
 "<code>IO.mapTask.{u_1} {α : Type u_1} {β : Type} (f : α → IO β) (t : Task α) (prio : Task.Priority := Task.Priority.default)\n  (sync : Bool := false) : BaseIO (Task (Except IO.Error β))</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new task that waits for `t` to complete and then runs the `IO` action `f` on its result.\nThis new task has priority `prio`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Unlike pure tasks\ncreated by `Task.spawn`, tasks created by this function will run even if the last reference to the\ntask is dropped. The `act` should explicitly check for cancellation via `IO.checkCanceled` if it\nshould be terminated or otherwise react to the last reference being dropped. Because `IO` actions\nmay throw an exception of type `IO.Error`, the result of the task is an `Except IO.Error α`.\n</code>",
 "3424": "<code>α → IO Unit</code>",
 "3423":
 "<code>EIO.mapTask.{u_1} {α : Type u_1} {ε β : Type} (f : α → EIO ε β) (t : Task α)\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : BaseIO (Task (Except ε β))</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new task that waits for `t` to complete and then runs the `IO` action `f` on its result.\nThis new task has priority `prio`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Unlike pure tasks\ncreated by `Task.spawn`, tasks created by this function will run even if the last reference to the\ntask is dropped. The `act` should explicitly check for cancellation via `IO.checkCanceled` if it\nshould be terminated or otherwise react to the last reference being dropped. Because `EIO ε` actions\nmay throw an exception of type `ε`, the result of the task is an `Except ε α`.\n</code>",
 "3422": "<code>α → EIO ε Unit</code>",
 "3421":
 "<code>BaseIO.mapTask.{u_1} {α : Type u_1} {β : Type} (f : α → BaseIO β) (t : Task α)\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : BaseIO (Task β)</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new task that waits for `t` to complete and then runs the `BaseIO` action `f` on its\nresult. This new task has priority `prio`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Unlike pure tasks\ncreated by `Task.spawn`, tasks created by this function will run even if the last reference to the\ntask is dropped. The `act` should explicitly check for cancellation via `IO.checkCanceled` if it\nshould be terminated or otherwise react to the last reference being dropped.\n</code>",
 "3420": "<code>α → BaseIO Unit</code>",
 "342": "<code class=\"docstring\">The universe level 5</code>",
 "3419": "<code>α → IO (Task (Except IO.Error β))</code>",
 "3418": "<code>α → EIO ε (Task (Except ε β))</code>",
 "3417": "<code>α → BaseIO (Task β)</code>",
 "3416":
 "<code>EIO.mapTasks.{u_1} {α : Type u_1} {ε β : Type} (f : List α → EIO ε β) (tasks : List (Task α))\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : BaseIO (Task (Except ε β))</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new task that waits for all the tasks in the list `tasks` to complete, and then runs the\n`EIO ε` action `f` on their results. This new task has priority `prio`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Unlike pure tasks\ncreated by `Task.spawn`, tasks created by this function will run even if the last reference to the\ntask is dropped. The `act` should explicitly check for cancellation via `IO.checkCanceled` if it\nshould be terminated or otherwise react to the last reference being dropped.\n</code>",
 "3415": "<code>List α → IO β</code>",
 "3414": "<code>List α → EIO ε β</code>",
 "3413": "<code>List α → BaseIO β</code>",
 "3412": "<code>α → IO β</code>",
 "3411": "<code>α → EIO ε β</code>",
 "3410": "<code>α → BaseIO β</code>",
 "341": "<code class=\"docstring\">The universe level 0</code>",
 "3409": "<code>List α → β</code>",
 "3408": "<code>α → Task β</code>",
 "3407": "<code>optParam Bool false</code>",
 "3406": "<code>autoParam (tasks.length &gt; 0) _auto✝</code>",
 "3405": "<code>List (Task α)</code>",
 "3404":
 "<code>Task.bind.{u_1, u_2} {α : Type u_1} {β : Type u_2} (x : Task α) (f : α → Task β)\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : Task β</code><span class=\"sep\"></span><code class=\"docstring\">`bind x f` does a monad \"bind\" operation on the task `x` with function `f`:\nthat is, it constructs (and immediately launches) a new task which will wait\nfor the value of `x` to be available and then calls `f` on the result,\nresulting in a new task which is then run for a result.\n\n`prio`, if provided, is the priority of the task.\nIf `sync` is set to true, `f` is executed on the current thread if `x` has already finished and\notherwise on the thread that `x` finished on. `prio` is ignored in this case. This should only be\ndone when executing `f` is cheap and non-blocking.\n</code>",
 "3403":
 "<code>Task.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (x : Task α)\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : Task β</code><span class=\"sep\"></span><code class=\"docstring\">`map f x` maps function `f` over the task `x`: that is, it constructs\n(and immediately launches) a new task which will wait for the value of `x` to\nbe available and then calls `f` on the result.\n\n`prio`, if provided, is the priority of the task.\nIf `sync` is set to true, `f` is executed on the current thread if `x` has already finished and\notherwise on the thread that `x` finished on. `prio` is ignored in this case. This should only be\ndone when executing `f` is cheap and non-blocking.\n</code>",
 "3402": "<code>Task α</code>",
 "3401":
 "<code>Task.Priority.max : Task.Priority</code><span class=\"sep\"></span><code class=\"docstring\">The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but will spawn a\ndedicated worker for the task. This is indicated using `Task.Priority.dedicated`. Regular priority\ntasks are placed in a thread pool and worked on according to their priority order.\n</code>",
 "3400":
 "<code>Task.Priority.default : Task.Priority</code><span class=\"sep\"></span><code class=\"docstring\">The default priority for spawned tasks, also the lowest priority: `0`. </code>",
 "340": "<code>Prop → Prop</code>",
 "34":
 "<code>Lean.SourceInfo : Type</code><span class=\"sep\"></span><code class=\"docstring\">Source information that relates syntax to the context that it came from.\n\nThe primary purpose of `SourceInfo` is to relate the output of the parser and the macro expander to\nthe original source file. When produced by the parser, `Syntax.node` does not carry source info; the\nparser associates it only with atoms and identifiers. If a `Syntax.node` is introduced by a\nquotation, then it has synthetic source info that both associates it with an original reference\nposition and indicates that the original atoms in it may not originate from the Lean file under\nelaboration.\n\nSource info is also used to relate Lean's output to the internal data that it represents; this is\nthe basis for many interactive features. When used this way, it can occur on `Syntax.node` as well.\n</code>",
 "3399": "<code>optParam Task.Priority Task.Priority.default</code>",
 "3398":
 "<code>Task.pure.{u} {α : Type u} (get : α) : Task α</code><span class=\"sep\"></span><code class=\"docstring\">`Task.pure (a : α)` constructs a task that is already resolved with value `a`. </code>",
 "3397":
 "<code>Task.Priority : Type</code><span class=\"sep\"></span><code class=\"docstring\">Task priority.\n\nTasks with higher priority will always be scheduled before tasks with lower priority. Tasks with a\npriority greater than `Task.Priority.max` are scheduled on dedicated threads.\n</code>",
 "3396":
 "<code>IO.cancel.{u_1} {α : Type u_1} : Task α → BaseIO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Requests cooperative cancellation of the task. The task must explicitly call `IO.checkCanceled` to\nreact to the cancellation.\n</code>",
 "3395":
 "<code>IO.checkCanceled : BaseIO Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the current task's cancellation flag has been set by calling `IO.cancel` or by\ndropping the last reference to the task.\n</code>",
 "3394":
 "<code>EIO.asTask {ε α : Type} (act : EIO ε α) (prio : Task.Priority := Task.Priority.default) : BaseIO (Task (Except ε α))</code><span class=\"sep\"></span><code class=\"docstring\">Runs `act` in a separate `Task`, with priority `prio`. Because `EIO ε` actions may throw an exception\nof type `ε`, the result of the task is an `Except ε α`.\n\nRunning the resulting `IO` action causes the task to be started eagerly. Pure accesses to the `Task`\ndo not influence the impure `act`.\n\nUnlike pure tasks created by `Task.spawn`, tasks created by this function will run even if the last\nreference to the task is dropped. The `act` should explicitly check for cancellation via\n`IO.checkCanceled` if it should be terminated or otherwise react to the last reference being\ndropped.\n</code>",
 "3393":
 "<code>BaseIO.asTask {α : Type} (act : BaseIO α) (prio : Task.Priority := Task.Priority.default) : BaseIO (Task α)</code><span class=\"sep\"></span><code class=\"docstring\">Runs `act` in a separate `Task`, with priority `prio`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Pure accesses to the\n`Task` do not influence the impure `act`.\n\nUnlike pure tasks created by `Task.spawn`, tasks created by this function will run even if the last\nreference to the task is dropped. The `act` should explicitly check for cancellation via\n`IO.checkCanceled` if it should be terminated or otherwise react to the last reference being\ndropped.\n</code>",
 "3392":
 "<code>Task.spawn.{u} {α : Type u} (fn : Unit → α) (prio : Task.Priority := Task.Priority.default) : Task α</code><span class=\"sep\"></span><code class=\"docstring\">`spawn fn : Task α` constructs and immediately launches a new task for\nevaluating the function `fn () : α` asynchronously.\n\n`prio`, if provided, is the priority of the task.\n</code>",
 "3391":
 "<code>Task.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Task α` is a primitive for asynchronous computation.\nIt represents a computation that will resolve to a value of type `α`,\npossibly being computed on another thread. This is similar to `Future` in Scala,\n`Promise` in Javascript, and `JoinHandle` in Rust.\n\nThe tasks have an overridden representation in the runtime.\n</code>",
 "3390":
 "<code>StdGen : Type</code><span class=\"sep\"></span><code class=\"docstring\">\"Standard\" random number generator. </code>",
 "339":
 "<code>Iff (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.\n\n * The recommended spelling of `&lt;-&gt;` in identifiers is `iff` (prefer `↔` over `&lt;-&gt;`).</code>",
 "3389":
 "<code>g → g × g</code><span class=\"sep\"></span><code class=\"docstring\">The 'split' operation allows one to obtain two distinct random number\ngenerators. This is very useful in functional programs (for example, when\npassing a random number generator down to recursive calls). </code>",
 "3388": "<code>g → Nat × g</code>",
 "3387":
 "<code>g → Nat × g</code><span class=\"sep\"></span><code class=\"docstring\">`next` operation returns a natural number that is uniformly distributed\n the range returned by `range` (including both end points),\nand a new generator. </code>",
 "3386": "<code>g → Nat × Nat</code>",
 "3385":
 "<code>g → Nat × Nat</code><span class=\"sep\"></span><code class=\"docstring\">`range` returns the range of values returned by\nthe generator. </code>",
 "3384":
 "<code>RandomGen.mk.{u} {g : Type u} (range : g → Nat × Nat) (next : g → Nat × g) (split : g → g × g) : RandomGen g</code>",
 "3383": "<code>gen</code>",
 "3382":
 "<code>RandomGen.{u} (g : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Interface for random number generators. </code>",
 "3381":
 "<code>IO.setRandSeed (n : Nat) : BaseIO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Seeds the random number generator state used by `IO.rand`.\n</code>",
 "3380":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">Everything that was written to the process's standard error. </code>",
 "338": "<code>Prop</code>",
 "3379":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">Everything that was written to the process's standard output. </code>",
 "3378":
 "<code>UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The process's exit code. </code>",
 "3377":
 "<code>IO.Process.Output.mk (exitCode : UInt32) (stdout stderr : String) : IO.Process.Output</code>",
 "3376":
 "<code>IO.Process.Child.wait {cfg : IO.Process.StdioConfig} : IO.Process.Child cfg → IO UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Blocks until the child process has exited and return its exit code.\n</code>",
 "3375":
 "<code>{ stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null, cmd := \"grep\",\n      args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.stdin.toHandleType</code>",
 "3374":
 "<code>IO.Process.Child\n  { stdin := IO.Process.Stdio.null,\n    stdout :=\n      { stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null,\n          cmd := \"grep\", args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.stdout,\n    stderr :=\n      { stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null,\n          cmd := \"grep\", args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.stderr }</code>",
 "3373":
 "<code>IO.Process.StdioConfig.stderr (self : IO.Process.StdioConfig) : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stderr handle. </code>",
 "3372":
 "<code>cfg.stderr.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard error handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "3371":
 "<code>IO.Process.StdioConfig.stdout (self : IO.Process.StdioConfig) : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdout handle. </code>",
 "3370":
 "<code>cfg.stdout.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard output handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "337":
 "<code>propext {a b : Prop} : (a ↔ b) → a = b</code><span class=\"sep\"></span><code class=\"docstring\">The [axiom](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=axioms) of **propositional extensionality**. It asserts that if\npropositions `a` and `b` are logically equivalent (that is, if `a` can be proved from `b` and vice\nversa), then `a` and `b` are *equal*, meaning `a` can be replaced with `b` in all contexts.\n\nThe standard logical connectives provably respect propositional extensionality. However, an axiom is\nneeded for higher order expressions like `P a` where `P : Prop → Prop` is unknown, as well as for\nequality. Propositional extensionality is intuitionistically valid.\n</code>",
 "3369":
 "<code>IO.Process.Stdio.toHandleType : IO.Process.Stdio → Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of handles that can be used to communicate with a child process on its standard input,\noutput, or error streams.\n\nFor `IO.Process.Stdio.piped`, this type is `IO.FS.Handle`. Otherwise, it is `Unit`, because no\ncommunication is possible.\n</code>",
 "3368":
 "<code>IO.Process.StdioConfig.stdin (self : IO.Process.StdioConfig) : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdin handle. </code>",
 "3367":
 "<code>cfg.stdin.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard input handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "3366": "<code>IO.Process.StdioConfig</code>",
 "3365":
 "<code>IO.Process.StdioConfig.mk (stdin stdout stderr : IO.Process.Stdio) : IO.Process.StdioConfig</code>",
 "3364":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Starts the child process in a new session and process group using `setsid`. Currently a no-op on\nnon-POSIX platforms.\n</code>",
 "3363":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Inherit environment variables from the spawning process. </code>",
 "3362": "<code>Array (String × Option String)</code>",
 "3361":
 "<code>Array (String × Option String)</code><span class=\"sep\"></span><code class=\"docstring\">Add or remove environment variables for the child process.\n\nThe child process inherits the parent's environment, as modified by `env`. Keys in the array are\nthe names of environment variables. A `none`, causes the entry to be removed from the environment,\nand `some` sets the variable to the new value, adding it if necessary. Variables are processed from left to right.\n</code>",
 "3360":
 "<code>Option System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The child process's working directory. Inherited from the parent current process if `none`. </code>",
 "336":
 "<code>id.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>",
 "3359":
 "<code>IO.Process.Stdio : Type</code><span class=\"sep\"></span><code class=\"docstring\">Whether the standard input, output, and error handles of a child process should be attached to\npipes, inherited from the parent, or null.\n\nIf the stream is a pipe, then the parent process can use it to communicate with the child.\n</code>",
 "3358":
 "<code>IO.Process.StdioConfig : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the standard input, output, and error handles of a child process.\n</code>",
 "3357":
 "<code>IO.Process.SpawnArgs.mk (toStdioConfig : IO.Process.StdioConfig) (cmd : String) (args : Array String)\n  (cwd : Option System.FilePath) (env : Array (String × Option String)) (inheritEnv setsid : Bool) :\n  IO.Process.SpawnArgs</code>",
 "3356":
 "<code>IO.FS.Handle.readToEnd (h : IO.FS.Handle) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads the entire remaining contents of the file handle as a UTF-8-encoded string. An exception is\nthrown if the contents are not valid UTF-8.\n\nThe underlying file is not automatically closed, and subsequent reads from the handle may block\nand/or return data.\n</code>",
 "3355":
 "<code>IO.Process.Child.stdout {cfg : IO.Process.StdioConfig} (self : IO.Process.Child cfg) : cfg.stdout.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard output handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "3354":
 "<code>IO.Process.Child.stdin {cfg : IO.Process.StdioConfig} (self : IO.Process.Child cfg) : cfg.stdin.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard input handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "3353":
 "<code>IO.Process.Stdio.null : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">The stream should be empty. </code>",
 "3352":
 "<code>IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stderr handle. </code>",
 "3351":
 "<code>IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdout handle. </code>",
 "3350":
 "<code>IO.Process.Stdio.piped : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">The stream should be attached to a pipe. </code>",
 "335": "<code>β → α</code>",
 "3349":
 "<code>IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdin handle. </code>",
 "3348":
 "<code>IO.Process.Child\n  { stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null, cmd := \"grep\",\n      args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.toStdioConfig</code>",
 "3347":
 "<code>IO.Process.Child.takeStdin {cfg : IO.Process.StdioConfig} :\n  IO.Process.Child cfg →\n    IO\n      (cfg.stdin.toHandleType ×\n        IO.Process.Child { stdin := IO.Process.Stdio.null, stdout := cfg.stdout, stderr := cfg.stderr })</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the `stdin` field from a `Child` object, allowing the handle to be closed while maintaining\na reference to the child process.\n\nFile handles are closed when the last reference to them is dropped. Closing the child's standard\ninput causes an end-of-file marker. Because the `Child` object has a reference to the standard\ninput, this operation is necessary in order to close the stream while the process is running (e.g.\nto extract its exit code after calling `Child.wait`). Many processes do not terminate until their\nstandard input is exhausted.\n</code>",
 "3346":
 "<code>IO.Process.SpawnArgs.toStdioConfig (self : IO.Process.SpawnArgs) : IO.Process.StdioConfig</code>",
 "3345":
 "<code>IO.Process.Child (cfg : IO.Process.StdioConfig) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A child process that was spawned with configuration `cfg`.\n\nThe configuration determines whether the child process's standard input, standard output, and\nstandard error are `IO.FS.Handle`s or `Unit`.\n</code>",
 "3344":
 "<code><span class=\"literal string\">\"Concatenation failed\"</span> : String</code>",
 "3343":
 "<code>IO.Process.Output.stdout (self : IO.Process.Output) : String</code><span class=\"sep\"></span><code class=\"docstring\">Everything that was written to the process's standard output. </code>",
 "3342":
 "<code>IO.Process.Output.exitCode (self : IO.Process.Output) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The process's exit code. </code>",
 "3341":
 "<code><span class=\"literal string\">\"Nonexistent.lean\"</span> : String</code>",
 "3340": "<code>IO.Process.Output</code>",
 "334": "<code>Sort u_2</code>",
 "3339": "<code>main : IO UInt32</code>",
 "3338":
 "<code>IO.Process.Output : Type</code><span class=\"sep\"></span><code class=\"docstring\">The result of running a process to completion.\n</code>",
 "3337":
 "<code>String.splitOn (s : String) (sep : String := \" \") : List String</code><span class=\"sep\"></span><code class=\"docstring\">Splits a string `s` on occurrences of the separator string `sep`. The default separator is `\" \"`.\n\nWhen `sep` is empty, the result is `[s]`. When `sep` occurs in overlapping patterns, the first match\nis taken. There will always be exactly `n+1` elements in the returned list if there were `n`\nnon-overlapping matches of `sep` in the string. The separators are not included in the returned\nsubstrings.\n\nExamples:\n* `\"here is some text \".splitOn = [\"here\", \"is\", \"some\", \"text\", \"\"]`\n* `\"here is some text \".splitOn \"some\" = [\"here is \", \" text \"]`\n* `\"here is some text \".splitOn \"\" = [\"here is some text \"]`\n* `\"ababacabac\".splitOn \"aba\" = [\"\", \"bac\", \"c\"]`\n</code>",
 "3336":
 "<code><span class=\"literal string\">\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"</span> : String</code>",
 "3335": "<code><span class=\"literal string\">\"grep\"</span> : String</code>",
 "3334":
 "<code>IO.FS.Handle.putStrLn (h : IO.FS.Handle) (s : String) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the contents of the string to the handle, followed by a newline. Uses UTF-8.\n</code>",
 "3333":
 "<code><span class=\"literal string\">\"numbers.txt\"</span> : String</code>",
 "3332":
 "<code><span class=\"literal string\">\"Main.lean\"</span> : String</code>",
 "3331":
 "<code>Array String</code><span class=\"sep\"></span><code class=\"docstring\">Arguments for the command. </code>",
 "3330": "<code><span class=\"literal string\">\"cat\"</span> : String</code>",
 "333": "<code><span class=\"literal string\">\"and\"</span> : String</code>",
 "3329":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">Command name. </code>",
 "3328": "<code>optParam (Option String) none</code>",
 "3327":
 "<code>IO.Process.SpawnArgs : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for a child process to be spawned.\n\nUse `IO.Process.spawn` to start the child process. `IO.Process.output` and `IO.Process.run` can be\nused when the child process should be run to completion, with its output and/or error code captured.\n</code>",
 "3326": "<code>IO.Process.SpawnArgs</code>",
 "3325":
 "<code>IO.Process.spawn (args : IO.Process.SpawnArgs) : IO (IO.Process.Child args.toStdioConfig)</code><span class=\"sep\"></span><code class=\"docstring\">Starts a child process with the provided configuration. The child process is spawned using operating\nsystem primitives, and it can be written in any language.\n\nThe child process runs in parallel with the parent.\n\nIf the child process's standard input is a pipe, use `IO.Process.Child.takeStdin` to make it\npossible to close the child's standard input before the process terminates, which provides the child with an end-of-file marker.\n</code>",
 "3324":
 "<code>IO.Process.output (args : IO.Process.SpawnArgs) (input? : Option String := none) : IO IO.Process.Output</code><span class=\"sep\"></span><code class=\"docstring\">Runs a process to completion and captures its output and exit code.\nThe child process is run with a null standard input or the specified input if provided,\nand the current process blocks until it has run to completion.\n\nThe specifications of standard input, output, and error handles in `args` are ignored.\n</code>",
 "3323":
 "<code>IO.Process.run (args : IO.Process.SpawnArgs) (input? : Option String := none) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Runs a process to completion, blocking until it terminates.\nThe child process is run with a null standard input or the specified input if provided,\nIf the child process terminates successfully with exit code 0, its standard output is returned.\nAn exception is thrown if it terminates with any other exit code.\n\nThe specifications of standard input, output, and error handles in `args` are ignored.\n</code>",
 "3322":
 "<code><span class=\"literal string\">\"10\\n9\\n8\\n7\\n6\\n5\\n4\\n3\\n2\\n1\\nBlastoff!\\n\"</span> : String</code>",
 "3321":
 "<code>IO.FS.withIsolatedStreams.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] [MonadFinally m] [MonadLiftT BaseIO m]\n  (x : m α) (isolateStderr : Bool := true) : m (String × α)</code><span class=\"sep\"></span><code class=\"docstring\">Runs an action with `stdin` emptied and `stdout` and `stderr` captured into a `String`. If\n`isolateStderr` is `false`, only `stdout` is captured.\n</code>",
 "3320": "<code>runCountdown : IO String</code>",
 "332": "<code><span class=\"literal string\">\"or\"</span> : String</code>",
 "3319":
 "<code><span class=\"literal string\">\"Blastoff!\"</span> : String</code>",
 "3318": "<code>countdown : Nat → IO Unit</code>",
 "3317":
 "<code>Verso.Genre.Manual.InlineLean.stderr : Verso.Doc.Elab.CodeBlockExpanderOf IOExample.Config</code>",
 "3316":
 "<code>Verso.Genre.Manual.InlineLean.stdout : Verso.Doc.Elab.CodeBlockExpanderOf IOExample.Config</code>",
 "3315":
 "<code>Verso.Genre.Manual.InlineLean.stdin : Verso.Doc.Elab.CodeBlockExpanderOf IOExample.Config</code>",
 "3314":
 "<code>IO.setStderr : IO.FS.Stream → BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the standard error stream of the current thread and returns its previous value.\n\nUse `IO.getStderr` to get the current standard error stream.\n</code>",
 "3313":
 "<code>IO.setStdout : IO.FS.Stream → BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the standard output stream of the current thread and returns its previous value.\n\nUse `IO.getStdout` to get the current standard output stream.\n</code>",
 "3312":
 "<code><span class=\"literal string\">\"Hello, \"</span> : String</code>",
 "3311":
 "<code>IO.FS.Stream.putStr (self : IO.FS.Stream) : String → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided string to the stream.\n</code>",
 "3310":
 "<code><span class=\"literal string\">\"Who is it?\"</span> : String</code>",
 "331":
 "<code>String.take (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the first `n` characters (Unicode code points) of `s`.\n\nIf `n` is greater than `s.length`, returns `s`.\n\nExamples:\n* `\"red green blue\".take 3 = \"red\"`\n* `\"red green blue\".take 1 = \"r\"`\n* `\"red green blue\".take 0 = \"\"`\n* `\"red green blue\".take 100 = \"red green blue\"`\n</code>",
 "3309":
 "<code>IO.FS.Stream.putStrLn (strm : IO.FS.Stream) (s : String) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the contents of the string to the stream, followed by a newline.\n</code>",
 "3308":
 "<code>IO.FS.withFile {α : Type} (fn : System.FilePath) (mode : IO.FS.Mode) (f : IO.FS.Handle → IO α) : IO α</code><span class=\"sep\"></span><code class=\"docstring\">Opens the file `fn` with the specified `mode` and passes the resulting file handle to `f`.\n\nThe file handle is closed when the last reference to it is dropped. If references escape `f`, then\nthe file remains open even after `IO.FS.withFile` has finished.\n</code>",
 "3307": "<code>IO.FS.Handle → IO α</code>",
 "3306":
 "<code>IO.FS.createTempDir : IO System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">Creates a temporary directory in the most secure manner possible, returning the new directory's\npath. There are no race conditions in the directory’s creation. The directory is readable and\nwritable only by the creating user ID.\n\nIt is the caller's job to remove the directory after use. Use `withTempDir` to ensure that the\ntemporary directory is removed.\n</code>",
 "3305": "<code>System.FilePath → m α</code>",
 "3304":
 "<code>IO.FS.createTempFile : IO (IO.FS.Handle × System.FilePath)</code><span class=\"sep\"></span><code class=\"docstring\">Creates a temporary file in the most secure manner possible, returning both a `Handle` to the\nalready-opened file and its path.\n\nThere are no race conditions in the file’s creation. The file is readable and writable only by the\ncreating user ID. Additionally on UNIX style platforms the file is executable by nobody.\n\nIt is the caller's job to remove the file after use. Use `withTempFile` to ensure that the temporary\nfile is removed.\n</code>",
 "3303": "<code>IO.FS.Handle → System.FilePath → m α</code>",
 "3302":
 "<code>IO.FS.removeDirAll (p : System.FilePath) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Fully remove given directory by deleting all contained files and directories in an unspecified order.\nSymlinks are deleted but not followed. Fails if any contained entry cannot be deleted or was newly\ncreated during execution.\n</code>",
 "3301":
 "<code>IO.FS.removeDir : System.FilePath → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Removes (deletes) a directory.\n\nRemoving a directory fails if the directory is not empty. Use `IO.FS.removeDirAll` to remove\ndirectories along with their contents.\n</code>",
 "3300":
 "<code>IO.FileRight : Type</code><span class=\"sep\"></span><code class=\"docstring\">POSIX-style file permissions that describe access rights for a file's owner, members of its\nassigned group, and all others.\n</code>",
 "330":
 "<code><span class=\"literal string\">\"android\"</span> : String</code>",
 "33":
 "<code>Lean.Syntax.missing : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A portion of the syntax tree that is missing because of a parse error.\n\nThe indexing operator on `Syntax` also returns `Syntax.missing` when the index is out of bounds.\n</code>",
 "3299": "<code>IO.FileRight</code>",
 "3298":
 "<code>IO.AccessRight</code><span class=\"sep\"></span><code class=\"docstring\">The permissions that all others have to access the file. </code>",
 "3297":
 "<code>IO.AccessRight</code><span class=\"sep\"></span><code class=\"docstring\">The assigned group's permissions to access the file. </code>",
 "3296":
 "<code>IO.AccessRight</code><span class=\"sep\"></span><code class=\"docstring\">The owner's permissions to access the file. </code>",
 "3295":
 "<code>IO.FileRight.mk (user group other : IO.AccessRight) : IO.FileRight</code>",
 "3294": "<code>Sort ?u.10452</code>",
 "3293":
 "<code>IO.AccessRight : Type</code><span class=\"sep\"></span><code class=\"docstring\">POSIX-style file permissions.\n\nThe `FileRight` structure describes these permissions for a file's owner, members of it's designated\ngroup, and all others.\n</code>",
 "3292": "<code>IO.AccessRight</code>",
 "3291":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">The file can be executed. </code>",
 "3290":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">The file can be written to. </code>",
 "329":
 "<code><span class=\"literal string\">\"orange\"</span> : String</code>",
 "3289":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">The file can be read. </code>",
 "3288":
 "<code>IO.AccessRight.mk (read write execution : Bool) : IO.AccessRight</code>",
 "3287":
 "<code>optParam (System.FilePath → IO Bool) fun x =&gt; pure true</code>",
 "3286":
 "<code>IO.FS.DirEntry : Type</code><span class=\"sep\"></span><code class=\"docstring\">An entry in a directory on a filesystem. </code>",
 "3285": "<code>IO.FS.DirEntry</code>",
 "3284":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The name of the entry. </code>",
 "3283":
 "<code>System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The directory in which the entry is found. </code>",
 "3282":
 "<code>IO.FS.DirEntry.mk (root : System.FilePath) (fileName : String) : IO.FS.DirEntry</code>",
 "3281":
 "<code>IO.FS.Metadata : Type</code><span class=\"sep\"></span><code class=\"docstring\">File metadata.\n\nThe metadata for a file can be accessed with `System.FilePath.metadata`/\n`System.FilePath.symlinkMetadata`.\n</code>",
 "3280":
 "<code>IO.FS.FileType : Type</code><span class=\"sep\"></span><code class=\"docstring\">Types of files that may be found on a filesystem. </code>",
 "328": "<code><span class=\"literal string\">\"c\"</span> : String</code>",
 "3279":
 "<code>IO.FS.FileType</code><span class=\"sep\"></span><code class=\"docstring\">Whether the file is an ordinary file, a directory, a symbolic link, or some other kind of file.\n</code>",
 "3278":
 "<code>UInt64</code><span class=\"sep\"></span><code class=\"docstring\">The size of the file in bytes. </code>",
 "3277":
 "<code>IO.FS.SystemTime</code><span class=\"sep\"></span><code class=\"docstring\">File modification time. </code>",
 "3276":
 "<code>IO.FS.SystemTime : Type</code><span class=\"sep\"></span><code class=\"docstring\">Low-level system time, tracked in whole seconds and additional nanoseconds.\n</code>",
 "3275":
 "<code>IO.FS.SystemTime</code><span class=\"sep\"></span><code class=\"docstring\">File access time. </code>",
 "3274":
 "<code>IO.FS.Metadata.mk (accessed modified : IO.FS.SystemTime) (byteSize : UInt64) (type : IO.FS.FileType) : IO.FS.Metadata</code>",
 "3273":
 "<code>System.FilePath.symlinkMetadata : System.FilePath → IO IO.FS.Metadata</code><span class=\"sep\"></span><code class=\"docstring\">Returns metadata for the indicated file without following symlinks. Throws an exception if the file\ndoes not exist or the metadata cannot be accessed.\n</code>",
 "3272":
 "<code>System.FilePath.metadata : System.FilePath → IO IO.FS.Metadata</code><span class=\"sep\"></span><code class=\"docstring\">Returns metadata for the indicated file, following symlinks. Throws an exception if the file does\nnot exist or the metadata cannot be accessed.\n</code>",
 "3271":
 "<code><span class=\"literal string\">\"files.tar.xz\"</span> : String</code>",
 "3270": "<code><span class=\"literal string\">\"xz\"</span> : String</code>",
 "327": "<code><span class=\"literal string\">\"b\"</span> : String</code>",
 "3269":
 "<code><span class=\"literal string\">\"files/archive.tar.gz\"</span> : String</code>",
 "3268":
 "<code><span class=\"literal string\">\"files.zip\"</span> : String</code>",
 "3267":
 "<code><span class=\"literal string\">\"files\"</span> : String</code>",
 "3266": "<code><span class=\"literal string\">\"zip\"</span> : String</code>",
 "3265":
 "<code><span class=\"literal string\">\"files/picture.jpeg\"</span> : String</code>",
 "3264":
 "<code>System.FilePath.withExtension (p : System.FilePath) (ext : String) : System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current extension in a path `p` with `ext`, adding it if there is no extension. If the\npath has multiple file extensions, only the last one is replaced. If the path has no filename, or if\n`ext` is the empty string, then the filename is returned unmodified.\n\n`ext` should not have a leading `.`, as this function adds one.\n\nExamples:\n* `(\"files/picture.jpeg\" : System.FilePath).withExtension \"jpg\" = ⟨\"files/picture.jpg\"⟩`\n* `(\"files/\" : System.FilePath).withExtension \"zip\" = ⟨\"files/\"⟩`\n* `(\"files\" : System.FilePath).withExtension \"zip\" = ⟨\"files.zip\"⟩`\n* `(\"files/archive.tar.gz\" : System.FilePath).withExtension \"xz\" = ⟨\"files.tar.xz\"⟩`\n</code>",
 "3263": "<code><span class=\"literal string\">\"jpg\"</span> : String</code>",
 "3262": "<code><span class=\"literal string\">\"gz\"</span> : String</code>",
 "3261": "<code><span class=\"literal string\">\"exe\"</span> : String</code>",
 "3260":
 "<code>System.FilePath.extension (p : System.FilePath) : Option String</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the extension part of `p.fileName`.\n\nIf the filename contains multiple extensions, then only the last one is extracted. Returns `none` if\nthere is no file name at the end of the path.\n\nExamples:\n * `(\"app.exe\" : System.FilePath).extension = some \"exe\"`\n * `(\"file.tar.gz\" : System.FilePath).extension = some \"gz\"`\n * `(\"files/\" : System.FilePath).extension = none`\n * `(\"files/picture.jpg\" : System.FilePath).extension = some \"jpg\"`\n</code>",
 "326": "<code><span class=\"literal string\">\"a\"</span> : String</code>",
 "3259":
 "<code><span class=\"literal string\">\"picture\"</span> : String</code>",
 "3258":
 "<code><span class=\"literal string\">\"files/picture.jpg\"</span> : String</code>",
 "3257":
 "<code><span class=\"literal string\">\"files/\"</span> : String</code>",
 "3256":
 "<code><span class=\"literal string\">\"file.tar\"</span> : String</code>",
 "3255":
 "<code><span class=\"literal string\">\"file.tar.gz\"</span> : String</code>",
 "3254": "<code><span class=\"literal string\">\"app\"</span> : String</code>",
 "3253":
 "<code>System.FilePath.fileStem (p : System.FilePath) : Option String</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the stem (non-extension) part of `p.fileName`.\n\nIf the filename contains multiple extensions, then only the last one is removed. Returns `none` if\nthere is no file name at the end of the path.\n\nExamples:\n * `(\"app.exe\" : System.FilePath).fileStem = some \"app\"`\n * `(\"file.tar.gz\" : System.FilePath).fileStem = some \"file.tar\"`\n * `(\"files/\" : System.FilePath).fileStem = none`\n * `(\"files/picture.jpg\" : System.FilePath).fileStem = some \"picture\"`\n</code>",
 "3252":
 "<code><span class=\"literal string\">\"app.exe\"</span> : String</code>",
 "3251":
 "<code>System.FilePath.fileName (p : System.FilePath) : Option String</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the last element of a path if it is a file or directory name.\n\nReturns `none ` if the last entry is a special name (such as `.` or `..`) or if the path is the root\ndirectory.\n</code>",
 "3250": "<code>List String</code>",
 "325":
 "<code>Function.uncurry.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {φ : Sort u_3} : (α → β → φ) → α × β → φ</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a two-parameter function into an equivalent function from pairs.\n\nExamples:\n* `Function.uncurry List.drop (1, [\"a\", \"b\", \"c\"]) = [\"b\", \"c\"]`\n* `[(\"orange\", 2), (\"android\", 3) ].map (Function.uncurry String.take) = [\"or\", \"and\"]`\n</code>",
 "3249":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The string representation of the path. </code>",
 "3248":
 "<code>System.FilePath.mk (toString : String) : System.FilePath</code>",
 "3247":
 "<code>Div.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HDiv`: `a / b : α` where `a b : α`. </code>",
 "3246":
 "<code>System.FilePath.pathSeparator : Char</code><span class=\"sep\"></span><code class=\"docstring\">The character that separates directories.\n\nOn platforms that support multiple separators, `System.FilePath.pathSeparator` is the “ideal” one expected by users\non the platform. `System.FilePath.pathSeparators` lists all supported separators.\n</code>",
 "3245":
 "<code>System.FilePath.join (p sub : System.FilePath) : System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">Appends two paths, taking absolute paths into account. This operation is also accessible via the `/`\noperator.\n\nIf `sub` is an absolute path, then `p` is discarded and `sub` is returned. If `sub` is a relative\npath, then it is attached to `p` with the platform-specific path separator.\n</code>",
 "3244":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The read/write cursor's position in the buffer. </code>",
 "3243":
 "<code>ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">The contents of the buffer. </code>",
 "3242":
 "<code>IO.FS.Stream.Buffer.mk (data : ByteArray) (pos : Nat) : IO.FS.Stream.Buffer</code>",
 "3241":
 "<code>IO.FS.Stream.ofBuffer (r : IO.Ref IO.FS.Stream.Buffer) : IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Creates a stream from a mutable reference to a buffer.\n\nThe resulting stream simulates a file, mutating the contents of the reference in response to writes\nand reading from it in response to reads. These streams can be used with `IO.withStdin`,\n`IO.setStdin`, and the corresponding operators for standard output and standard error to redirect\ninput and output.\n</code>",
 "3240": "<code>IO.FS.Stream</code>",
 "324": "<code><span class=\"literal string\">\"five\"</span> : String</code>",
 "3239":
 "<code>IO.setStdin : IO.FS.Stream → BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the standard input stream of the current thread and returns its previous value.\n\nUse `IO.getStdin` to get the current standard input stream.\n</code>",
 "3238":
 "<code>IO.FS.Stream.Buffer : Type</code><span class=\"sep\"></span><code class=\"docstring\">A byte buffer that can simulate a file in memory.\n\nUse `IO.FS.Stream.ofBuffer` to create a stream from a buffer.\n</code>",
 "3237": "<code>IO.Ref IO.FS.Stream.Buffer</code>",
 "3236":
 "<code>BaseIO Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if a stream refers to a Windows console or Unix terminal. </code>",
 "3235":
 "<code>String → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided string to the stream.\n</code>",
 "3234":
 "<code>IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads text up to and including the next newline from the stream.\n\nIf the returned string is empty, an end-of-file marker (EOF) has been reached.\nAn EOF does not actually close a stream, so further reads may block and return more data.\n</code>",
 "3233":
 "<code>ByteArray → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided bytes to the stream.\n\nIf the stream represents a physical output device such as a file on disk, then the results may be\nbuffered. Call `FS.Stream.flush` to synchronize their contents.\n</code>",
 "3232":
 "<code>USize → IO ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Reads up to the given number of bytes from the stream.\n\nIf the returned array is empty, an end-of-file marker (EOF) has been reached. An EOF does not\nactually close a stream, so further reads may block and return more data.\n</code>",
 "3231":
 "<code>IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Flushes the stream's output buffers.\n</code>",
 "3230":
 "<code>IO.FS.Stream.mk (flush : IO Unit) (read : USize → IO ByteArray) (write : ByteArray → IO Unit) (getLine : IO String)\n  (putStr : String → IO Unit) (isTty : BaseIO Bool) : IO.FS.Stream</code>",
 "323":
 "<code>Prod.swap.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α × β → β × α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps the elements in a pair.\n\nExamples:\n* `(1, 2).swap = (2, 1)`\n* `(\"orange\", -87).swap = (-87, \"orange\")`\n</code>",
 "3229":
 "<code>IO.FS.Handle.flush (h : Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Flushes the output buffer associated with the handle, writing any unwritten data to the associated\noutput device.\n</code>",
 "3228":
 "<code>Char.toUInt8 (c : Char) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a character into a `UInt8` that contains its code point.\n\nIf the code point is larger than 255, it is truncated (reduced modulo 256).\n</code>",
 "3227":
 "<code>ByteArray.push : ByteArray → UInt8 → ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Adds an element to the end of an array. The resulting array's size is one greater than the input\narray. If there are no other references to the array, then it is modified in-place.\n\nThis takes amortized `O(1)` time because `ByteArray` is represented by a dynamic array.\n</code>",
 "3226":
 "<code>ByteArray.empty : ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new empty byte array with initial capacity `0`.\n\nUse `ByteArray.emptyWithCapacity` to create an array with a greater initial capacity.\n</code>",
 "3225":
 "<code>IO.FS.Handle.write (h : Handle) (buffer : ByteArray) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided bytes to the the handle.\n\nWriting to a handle is typically buffered, and may not immediately modify the file on disk. Use\n`IO.FS.Handle.flush` to write changes to buffers to the associated device.\n</code>",
 "3224":
 "<code>Char.ofUInt8 (n : UInt8) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 8-bit unsigned integer into a character.\n\nThe integer's value is interpreted as a Unicode code point.\n</code>",
 "3223":
 "<code>ByteArray.size : ByteArray → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the number of bytes in the byte array.\n\nThis is the number of bytes actually in the array, as distinct from its capacity, which is the\namount of memory presently allocated for the array.\n</code>",
 "3222": "<code>buf.size = 1</code>",
 "3221":
 "<code>IO.FS.Handle.read (h : Handle) (bytes : USize) : IO ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Reads up to the given number of bytes from the handle. If the returned array is empty, an\nend-of-file marker (EOF) has been reached.\n\nEncountering an EOF does not close a handle. Subsequent reads may block and return more data.\n</code>",
 "3220":
 "<code>IO.FS.Handle.rewind (h : Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Rewinds the read/write cursor to the beginning of the handle's file.\n</code>",
 "322":
 "<code>Function.curry.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {φ : Sort u_3} : (α × β → φ) → α → β → φ</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a function from pairs into an equivalent two-parameter function.\n\nExamples:\n* `Function.curry (fun (x, y) =&gt; x + y) 3 5 = 8`\n* `Function.curry Prod.swap 3 \"five\" = (\"five\", 3)`\n</code>",
 "3219":
 "<code>IO.FS.Mode.read : IO.FS.Mode</code><span class=\"sep\"></span><code class=\"docstring\">The file should be opened for reading.\n\nThe read/write cursor is positioned at the beginning of the file. It is an error if the file does\nnot exist.\n\n* `open` flags: `O_RDONLY`\n* `fdopen` mode: `r`\n</code>",
 "3218":
 "<code>IO.FS.Handle.mk (fn : System.FilePath) (mode : IO.FS.Mode) : IO Handle</code><span class=\"sep\"></span><code class=\"docstring\">Opens the file at `fn` with the given `mode`.\n\nAn exception is thrown if the file cannot be opened.\n</code>",
 "3217": "<code>Handle</code>",
 "3216": "<code><span class=\"literal string\">\"data\"</span> : String</code>",
 "3215":
 "<code>IO.FS.readFile (fname : System.FilePath) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads the entire contents of the UTF-8-encoded file at the given path as a `String`.\n\nAn exception is thrown if the contents of the file are not valid UTF-8. This is in addition to\nexceptions that may always be thrown as a result of failing to read files.\n</code>",
 "3214":
 "<code>IO.FS.Mode.write : IO.FS.Mode</code><span class=\"sep\"></span><code class=\"docstring\">The file should be opened for writing.\n\nIf the file already exists, it is truncated to zero length. Otherwise, a new file is created. The\nread/write cursor is positioned at the beginning of the file.\n\n* `open` flags: `O_WRONLY | O_CREAT | O_TRUNC`\n* `fdopen` mode: `w`\n</code>",
 "3213":
 "<code>IO.FS.Mode.readWrite : IO.FS.Mode</code><span class=\"sep\"></span><code class=\"docstring\">The file should be opened for both reading and writing.\n\nIt is an error if the file does not already exist. The read/write cursor is positioned at the\nstart of the file.\n\n* `open` flags: `O_RDWR`\n* `fdopen` mode: `r+`\n</code>",
 "3212":
 "<code>IO.FS.Handle.truncate (h : IO.FS.Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Truncates the handle to its read/write cursor.\n\nThis operation does not automatically flush output buffers, so the contents of the output device may\nnot reflect the change immediately. This does not usually lead to problems because the read/write\ncursor includes buffered writes. However, buffered writes followed by `IO.FS.Handle.rewind`, then\n`IO.FS.Handle.truncate`, and then closing the file may lead to a non-empty file. If unsure, call\n`IO.FS.Handle.flush` before truncating.\n</code>",
 "3211":
 "<code>IO.FS.Handle.rewind (h : IO.FS.Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Rewinds the read/write cursor to the beginning of the handle's file.\n</code>",
 "3210":
 "<code>IO.FS.Handle.flush (h : IO.FS.Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Flushes the output buffer associated with the handle, writing any unwritten data to the associated\noutput device.\n</code>",
 "321":
 "<code>Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.</code>",
 "3209": "<code>ByteArray</code>",
 "3208":
 "<code>ByteArray : Type</code><span class=\"sep\"></span><code class=\"docstring\">`ByteArray` is like `Array UInt8`, but with an efficient run-time representation as a packed\nbyte buffer.\n</code>",
 "3207": "<code>USize</code>",
 "3206": "<code>IO.FS.Handle</code>",
 "3205":
 "<code>IO.FS.Mode : Type</code><span class=\"sep\"></span><code class=\"docstring\">Whether a file should be opened for reading, writing, creation and writing, or appending.\n\nAt the operating system level, this translates to the mode of a file handle (i.e., a set of `open`\nflags and an `fdopen` mode).\n\nNone of the modes represented by this datatype translate line endings (i.e. `O_BINARY` on Windows).\nFurthermore, they are not inherited across process creation (i.e. `O_NOINHERIT` on Windows and\n`O_CLOEXEC` elsewhere).\n\n**Operating System Specifics:**\n* Windows:\n  [`_open`](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/open-wopen?view=msvc-170),\n  [`_fdopen`](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/fdopen-wfdopen?view=msvc-170)\n* Linux: [`open`](https://linux.die.net/man/2/open), [`fdopen`](https://linux.die.net/man/3/fdopen)\n</code>",
 "3204": "<code>IO.FS.Mode</code>",
 "3203": "<code>System.FilePath</code>",
 "3202":
 "<code>IO.FS.Handle.mk (fn : System.FilePath) (mode : IO.FS.Mode) : IO IO.FS.Handle</code><span class=\"sep\"></span><code class=\"docstring\">Opens the file at `fn` with the given `mode`.\n\nAn exception is thrown if the file cannot be opened.\n</code>",
 "3201":
 "<code>System.FilePath.exeExtension : String</code><span class=\"sep\"></span><code class=\"docstring\">The file extension expected for executable binaries on the current platform, or `\"\"` if there is no\nsuch extension.\n</code>",
 "3200":
 "<code>System.FilePath.extSeparator : Char</code><span class=\"sep\"></span><code class=\"docstring\">The character that separates file extensions from file names.\n</code>",
 "320": "<code>Sort u_3</code>",
 "32":
 "<code>Lean.Syntax : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lean syntax trees.\n\nSyntax trees are used pervasively throughout Lean: they are produced by the parser, transformed by\nthe macro expander, and elaborated. They are also produced by the delaborator and presented to\nusers.\n</code>",
 "3199":
 "<code>System.FilePath.pathSeparators : List Char</code><span class=\"sep\"></span><code class=\"docstring\">The list of all path separator characters supported on the current platform.\n\nOn platforms that support multiple separators, `System.FilePath.pathSeparator` is the “ideal” one\nexpected by users on the platform.\n</code>",
 "3198":
 "<code>System.FilePath : Type</code><span class=\"sep\"></span><code class=\"docstring\">A path on the file system.\n\nPaths consist of a sequence of directories followed by the name of a file or directory. They are\ndelimited by a platform-dependent separator character (see `System.FilePath.pathSeparator`).\n</code>",
 "3197":
 "<code>IO.FS.Handle : Type</code><span class=\"sep\"></span><code class=\"docstring\">A reference to an opened file.\n\nFile handles wrap the underlying operating system's file descriptors. There is no explicit operation\nto close a file: when the last reference to a file handle is dropped, the file is closed\nautomatically.\n\nHandles have an associated read/write cursor that determines the where reads and writes occur in the\nfile.\n</code>",
 "3196":
 "<code><span class=\"literal string\">\"Validation prevented a negative balance.\"</span> : String</code>",
 "3195": "<code>IO.Ref Bool</code>",
 "3194":
 "<code>ST.Ref.take {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Reads the value of a mutable reference cell, removing it.\n\nThis causes subsequent attempts to read from or take the reference cell to block until a new value\nis written using `ST.Ref.set`.\n</code>",
 "3193":
 "<code>ST.mkRef {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (a : α) : m (ST.Ref σ α)</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new mutable reference that contains the provided value `a`.\n</code>",
 "3192": "<code>α → β × α</code>",
 "3191":
 "<code><span class=\"literal string\">\"Final balance negative!\"</span> : String</code>",
 "3190":
 "<code>ST.Ref.modify {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) (f : α → α) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Atomically modifies a mutable reference cell by replacing its contents with the result of a function\ncall.\n</code>",
 "319": "<code>Type u_2</code>",
 "3189":
 "<code><span class=\"literal string\">\"Final balance is zero or positive.\"</span> : String</code>",
 "3188":
 "<code><span class=\"literal string\">\"Final balance is negative!\"</span> : String</code>",
 "3187":
 "<code>Task.get.{u} {α : Type u} (self : Task α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Blocks the current thread until the given task has finished execution, and then returns the result\nof the task. If the current thread is itself executing a (non-dedicated) task, the maximum\nthreadpool size is temporarily increased by one while waiting so as to ensure the process cannot\nbe deadlocked by threadpool starvation. Note that when the current thread is unblocked, more tasks\nthan the configured threadpool size may temporarily be running at the same time until sufficiently\nmany tasks have finished.\n\n`Task.map` and `Task.bind` should be preferred over `Task.get` for setting up task dependencies\nwhere possible as they do not require temporarily growing the threadpool in this way. In\nparticular, calling `Task.get` in a task continuation with `(sync := true)` will panic as the\ncontinuation is decidedly not \"cheap\" in this case and deadlocks may otherwise occur. The\nwaited-upon task should instead be returned and unwrapped using `Task.bind/IO.bindTask`.\n</code>",
 "3186":
 "<code>Nat.toUInt32 (n : Nat) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Nat.toUInt32 5 = 5`\n* `Nat.toUInt32 65_539 = 65_539`\n* `Nat.toUInt32 4_294_967_299 = 3`\n</code>",
 "3185":
 "<code>IO.sleep (ms : UInt32) : BaseIO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Pauses execution for the specified number of milliseconds.\n</code>",
 "3184":
 "<code>IO.rand (lo hi : Nat) : BaseIO Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a pseudorandom number between `lo` and `hi`, using and updating a saved random generator\nstate.\n\nThis state can be seeded using `IO.setRandSeed`.\n</code>",
 "3183":
 "<code>Task.Priority.dedicated : Task.Priority</code><span class=\"sep\"></span><code class=\"docstring\">Indicates that a task should be scheduled on a dedicated thread.\n\nAny priority higher than `Task.Priority.max` will result in the task being scheduled\nimmediately on a dedicated thread. This is particularly useful for long-running and/or\nI/O-bound tasks since Lean will, by default, allocate no more non-dedicated workers\nthan the number of cores to reduce context switches.\n</code>",
 "3182":
 "<code>IO.asTask {α : Type} (act : IO α) (prio : Task.Priority := Task.Priority.default) : BaseIO (Task (Except IO.Error α))</code><span class=\"sep\"></span><code class=\"docstring\">Runs `act` in a separate `Task`, with priority `prio`. Because `IO` actions may throw an exception\nof type `IO.Error`, the result of the task is an `Except IO.Error α`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Pure accesses to the\n`Task` do not influence the impure `act`. Because `IO` actions may throw an exception of type\n`IO.Error`, the result of the task is an `Except IO.Error α`.\n\nUnlike pure tasks created by `Task.spawn`, tasks created by this function will run even if the last\nreference to the task is dropped. The `act` should explicitly check for cancellation via\n`IO.checkCanceled` if it should be terminated or otherwise react to the last reference being\ndropped.\n</code>",
 "3181": "<code>Task (Except IO.Error Unit)</code>",
 "3180":
 "<code><span class=\"literal string\">\"Sending out orders...\"</span> : String</code>",
 "318":
 "<code><span class=\"literal string\">\"any string\"</span> : String</code>",
 "3179": "<code>Array (Task (Except IO.Error Unit))</code>",
 "3178":
 "<code>IO.mkRef {α : Type} (a : α) : BaseIO (IO.Ref α)</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new mutable reference cell that contains `a`.\n</code>",
 "3177": "<code>IO.Ref Int</code>",
 "3176":
 "<code>ST.Ref.set {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) (a : α) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the value of a mutable reference.\n</code>",
 "3175":
 "<code>ST.Ref.get {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Reads the value of a mutable reference.\n</code>",
 "3174": "<code>ST.Ref σ α</code>",
 "3173":
 "<code>ST.Ref.mk {σ α : Type} (ref : ST.RefPointed.type) (h : Nonempty α) : ST.Ref σ α</code>",
 "3172": "<code>(σ : Type) → EST ε σ α</code>",
 "3171":
 "<code>runEST {ε α : Type} (x : (σ : Type) → EST ε σ α) : Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">Runs an `EST` computation, in which mutable state and exceptions are the only side effects.\n</code>",
 "3170": "<code>(σ : Type) → ST σ α</code>",
 "317": "<code>β</code>",
 "3169":
 "<code>IO.Ref (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Mutable reference cells that contain values of type `α`. These cells can read from and mutated in\nthe `IO` monad.\n</code>",
 "3168":
 "<code><span class=\"literal string\">\" so they can be corrected.\"</span> : String</code>",
 "3167":
 "<code>IO.eprintln.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it with a trailing newline to\nthe current standard error (as determined by `IO.getStderr`).\n</code>",
 "3166":
 "<code><span class=\"literal string\">\"errors\"</span> : String</code>",
 "3165":
 "<code><span class=\"literal string\">\"Please report any \"</span> : String</code>",
 "3164":
 "<code>IO.eprint.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it to the current standard\nerror (as determined by `IO.getStderr`).\n</code>",
 "3163":
 "<code><span class=\"literal string\">\"Thank you for reading it!\"</span> : String</code>",
 "3162":
 "<code><span class=\"literal string\">\" language reference.\"</span> : String</code>",
 "3161": "<code><span class=\"literal string\">\"Lean\"</span> : String</code>",
 "3160":
 "<code><span class=\"literal string\">\"This is the \"</span> : String</code>",
 "316":
 "<code>Function.const.{u, v} {α : Sort u} (β : Sort v) (a : α) : β → α</code><span class=\"sep\"></span><code class=\"docstring\">The constant function that ignores its argument.\n\nIf `a : α`, then `Function.const β a : β → α` is the “constant function with value `a`”. For all\narguments `b : β`, `Function.const β a b = a`.\n\nExamples:\n * `Function.const Bool 10 true = 10`\n * `Function.const Bool 10 false = 10`\n * `Function.const String 10 \"any string\" = 10`\n</code>",
 "3159":
 "<code>IO.getStderr : BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Returns the current thread's standard error stream.\n\nUse `IO.setStderr` to replace the current thread's standard error stream.\n</code>",
 "3158":
 "<code>IO.getStdout : BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Returns the current thread's standard output stream.\n\nUse `IO.setStdout` to replace the current thread's standard output stream.\n</code>",
 "3157":
 "<code>Sum.inr.{u, v} {α : Type u} {β : Type v} (val : β) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Right injection into the sum type `α ⊕ β`. </code>",
 "3156": "<code>α → IO (α ⊕ β)</code>",
 "3155":
 "<code><span class=\"literal string\">\"Access granted!\"</span> : String</code>",
 "3154": "<code>IO.Error</code>",
 "3153":
 "<code class=\"docstring\">`continue` skips to the next iteration of the surrounding `for` loop. </code>",
 "3152": "<code>repeatAccessControl : IO Unit</code>",
 "3151":
 "<code><span class=\"literal string\">\"Incorrect password\"</span> : String</code>",
 "3150":
 "<code><span class=\"literal string\">\"secret\"</span> : String</code>",
 "315":
 "<code>List.drop.{u} {α : Type u} (n : Nat) (xs : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first `n` elements of the list `xs`. Returns the empty list if `n` is greater than the\nlength of the list.\n\n`O(min n |xs|)`.\n\nExamples:\n* `[0, 1, 2, 3, 4].drop 0 = [0, 1, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].drop 3 = [3, 4]`\n* `[0, 1, 2, 3, 4].drop 6 = []`\n</code>",
 "3149":
 "<code><span class=\"literal string\">\"What is the password?\"</span> : String</code>",
 "3148": "<code>accessControl : IO Unit</code>",
 "3147": "<code>ε → BaseIO α</code>",
 "3146": "<code>Option String</code>",
 "3145":
 "<code>IO.Error.userError (msg : String) : IO.Error</code><span class=\"sep\"></span><code class=\"docstring\">Some other error occurred. </code>",
 "3144": "<code>IO.Error → ε</code>",
 "3143": "<code>ε → IO.Error</code>",
 "3142": "<code>Unit → α</code>",
 "3141":
 "<code>α : Type</code><span class=\"sep\"></span><code class=\"docstring\">A type </code>",
 "3140": "<code>ε → EStateM ε σ α</code>",
 "314":
 "<code>List.reverse.{u} {α : Type u} (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Reverses a list.\n\n`O(|as|)`.\n\nBecause of the “functional but in place” optimization implemented by Lean's compiler, this function\ndoes not allocate a new list when its reference to the input list is unshared: it simply walks the\nlinked list and reverses all the node pointers.\n\nExamples:\n* `[1, 2, 3, 4].reverse = [4, 3, 2, 1]`\n* `[].reverse = []`\n</code>",
 "3139": "<code>Unit → EStateM ε σ β</code>",
 "3138": "<code>Unit → EStateM ε σ α</code>",
 "3137": "<code>α → EStateM ε σ β</code>",
 "3136":
 "<code>σ → δ → σ</code><span class=\"sep\"></span><code class=\"docstring\">Updates the current state with the saved information that should be rolled back. This updated\nstate becomes the current state when an exception is handled.\n</code>",
 "3135":
 "<code>σ → δ</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the information in the state that should be rolled back if an exception is handled.\n</code>",
 "3134":
 "<code>EStateM.Backtrackable.mk.{u} {δ : outParam (Type u)} {σ : Type u} (save : σ → δ) (restore : σ → δ → σ) :\n  EStateM.Backtrackable δ σ</code>",
 "3133": "<code>StateM σ α</code>",
 "3132": "<code>EStateM ε σ α</code>",
 "3131":
 "<code>EStateM.Backtrackable.{u} (δ : outParam (Type u)) (σ : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Exception handlers in `EStateM` save some part of the state, determined by `δ`, and restore it if an\nexception is caught. By default, `δ` is `Unit`, and no information is saved.\n</code>",
 "3130":
 "<code>EStateM.Result.{u} (ε σ α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The value returned from a combined state and exception monad in which exceptions do not\nautomatically roll back the state.\n\n`Result ε σ α` is equivalent to `Except ε α × σ`, but using a single combined inductive type yields\na more efficient data representation.\n</code>",
 "313":
 "<code>Function.comp.{u, v, w} {α : Sort u} {β : Sort v} {δ : Sort w} (f : β → δ) (g : α → β) : α → δ</code><span class=\"sep\"></span><code class=\"docstring\">Function composition, usually written with the infix operator `∘`. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.\n\nExamples:\n * `Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]`\n * `(List.reverse ∘ List.drop 2) [3, 2, 4, 1] = [1, 4]`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∘` in identifiers is `comp`.</code>",
 "3129": "<code>ε → m β</code>",
 "3128": "<code>ExceptCpsT ε m α</code>",
 "3127": "<code>ExceptCpsT α m α</code>",
 "3126": "<code>m (Except ε α)</code>",
 "3125": "<code>ε → ExceptT ε m α</code>",
 "3124": "<code>α → ExceptT ε m β</code>",
 "3123":
 "<code>ExceptT.mk.{u, v} {ε : Type u} {m : Type u → Type v} {α : Type u} (x : m (Except ε α)) : ExceptT ε m α</code><span class=\"sep\"></span><code class=\"docstring\">Use a monadic action that may return an exception's value as an action in the transformed monad that\nmay throw the corresponding exception.\n\nThis is the inverse of `ExceptT.run`.\n</code>",
 "3122": "<code>ExceptT ε m α</code>",
 "3121": "<code>Option ?m.19 → m ?m.8</code>",
 "3120": "<code>m ?m.16</code>",
 "312": "<code>α → β</code>",
 "3119": "<code>Sort ?u.6231</code>",
 "3118": "<code>Option ?m.7 → m ?m.8</code>",
 "3117": "<code>m ?m.7</code>",
 "3116": "<code>{α β : Type u} → m α → (Option α → m β) → m (α × β)</code>",
 "3115":
 "<code>{α β : Type u} → m α → (Option α → m β) → m (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">Runs an action, ensuring that some other action always happens afterward.\n\nMore specifically, `tryFinally' x f` runs `x` and then the “finally” computation `f`. If `x`\nsucceeds with some value `a : α`, `f (some a)` is returned. If `x` fails for `m`'s definition of\nfailure, `f none` is returned.\n\n`tryFinally'` can be thought of as performing the same role as a `finally` block in an imperative\nprogramming language.\n</code>",
 "3114":
 "<code>MonadFinally.mk.{u, v} {m : Type u → Type v} (tryFinally' : {α β : Type u} → m α → (Option α → m β) → m (α × β)) :\n  MonadFinally m</code>",
 "3113":
 "<code>MonadFinally.tryFinally'.{u, v} {m : Type u → Type v} [self : MonadFinally m] {α β : Type u} (x : m α)\n  (f : Option α → m β) : m (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">Runs an action, ensuring that some other action always happens afterward.\n\nMore specifically, `tryFinally' x f` runs `x` and then the “finally” computation `f`. If `x`\nsucceeds with some value `a : α`, `f (some a)` is returned. If `x` fails for `m`'s definition of\nfailure, `f none` is returned.\n\n`tryFinally'` can be thought of as performing the same role as a `finally` block in an imperative\nprogramming language.\n</code>",
 "3112": "<code>ε → m α</code>",
 "3111": "<code>ε</code>",
 "3110":
 "<code>{α : Type v} → ε → m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception of type `ε` to the nearest enclosing `catch`.\n</code>",
 "311": "<code>β → δ</code>",
 "3109":
 "<code>MonadExceptOf.mk.{u, v, w} {ε : semiOutParam (Type u)} {m : Type v → Type w} (throw : {α : Type v} → ε → m α)\n  (tryCatch : {α : Type v} → m α → (ε → m α) → m α) : MonadExceptOf ε m</code>",
 "3108": "<code>Unit → m α</code>",
 "3107":
 "<code>{α : Type v} → m α → (ε → m α) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Catches errors thrown in `body`, passing them to `handler`. Errors in `handler` are not caught.\n</code>",
 "3106":
 "<code>{α : Type v} → ε → m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception of type `ε` to the nearest enclosing handler.\n</code>",
 "3105":
 "<code>MonadExcept.mk.{u, v, w} {ε : outParam (Type u)} {m : Type v → Type w} (throw : {α : Type v} → ε → m α)\n  (tryCatch : {α : Type v} → m α → (ε → m α) → m α) : MonadExcept ε m</code>",
 "3104": "<code>Type v → Type w</code>",
 "3103":
 "<code><span class=\"literal string\">\"Failure\"</span> : String</code>",
 "3102":
 "<code>Except.toOption.{u, u_1} {ε : Type u} {α : Type u_1} : Except ε α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns `none` if an exception was thrown, or `some` around the value on success.\n\nExamples:\n* `(pure 10 : Except String Nat).toOption = some 10`\n* `(throw \"Failure\" : Except String Nat).toOption = none`\n</code>",
 "3101": "<code>Unit → Except ε α</code>",
 "3100":
 "<code><span class=\"literal string\">\"E: Error\"</span> : String</code>",
 "310": "<code>Sort w</code>",
 "31":
 "<code>Even.plusTwo {n : Nat} : Even n → Even (n + 2)</code><span class=\"sep\"></span><code class=\"docstring\">If `n` is even, then so is `n + 2`. </code>",
 "3099": "<code><span class=\"literal string\">\"E: \"</span> : String</code>",
 "3098":
 "<code>Except.mapError.{u, u_1, u_2} {ε : Type u} {ε' : Type u_1} {α : Type u_2} (f : ε → ε') : Except ε α → Except ε' α</code><span class=\"sep\"></span><code class=\"docstring\">Transforms exceptions with a function, doing nothing on successful results.\n\nExamples:\n* `(pure 2 : Except String Nat).mapError (·.length) = pure 2`\n* `(throw \"Error\" : Except String Nat).mapError (·.length) = throw 5`\n</code>",
 "3097": "<code>ε → ε'</code>",
 "3096":
 "<code><span class=\"literal string\">\"Error\"</span> : String</code>",
 "3095": "<code>α → Except ε β</code>",
 "3094": "<code>Unit → OptionT m α</code>",
 "3093": "<code>α → OptionT m β</code>",
 "3092": "<code>m (Option α)</code>",
 "3091": "<code>OptionT m α</code>",
 "3090": "<code>Unit → ReaderT ρ m α</code>",
 "309": "<code>Sort v</code>",
 "3089": "<code>α → ReaderT ρ m β</code>",
 "3088": "<code>ρ' → ρ</code>",
 "3087": "<code>ReaderT ρ m α</code>",
 "3086": "<code>ρ → ρ</code>",
 "3085":
 "<code>MonadWithReaderOf.mk.{u, v} {ρ : semiOutParam (Type u)} {m : Type u → Type v}\n  (withReader : {α : Type u} → (ρ → ρ) → m α → m α) : MonadWithReaderOf ρ m</code>",
 "3084":
 "<code>{α : Type u} → (ρ → ρ) → m α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Locally modifies the reader monad's value while running an action.\n\nDuring the inner action `x`, reading the value returns `f` applied to the original value. After\ncontrol returns from `x`, the reader monad's value is restored.\n</code>",
 "3083":
 "<code>MonadWithReader.mk.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v}\n  (withReader : {α : Type u} → (ρ → ρ) → m α → m α) : MonadWithReader ρ m</code>",
 "3082":
 "<code>m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value. </code>",
 "3081":
 "<code>MonadReaderOf.mk.{u, v} {ρ : semiOutParam (Type u)} {m : Type u → Type v} (read : m ρ) : MonadReaderOf ρ m</code>",
 "3080":
 "<code>m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value.\n\nUse `readThe` to explicitly specify a type when more than one value is available.\n</code>",
 "308": "<code>Array Char</code>",
 "3079":
 "<code>MonadReader.mk.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v} (read : m ρ) : MonadReader ρ m</code>",
 "3078": "<code>StateRefT' ω σ m α</code>",
 "3077":
 "<code>STWorld.mk {σ : outParam Type} {m : Type → Type} : STWorld σ m</code>",
 "3076":
 "<code>STWorld (σ : outParam Type) (m : Type → Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">An auxiliary class used to infer the “state” of `EST` and `ST` monads.\n</code>",
 "3075":
 "<code>runST {α : Type} (x : (σ : Type) → ST σ α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Runs an `ST` computation, in which mutable state via `ST.Ref` is the only side effect.\n</code>",
 "3074":
 "<code>EST (ε σ : Type) : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A restricted version of `IO` in which mutable state and exceptions are the only side effects.\n\nIt is possible to run `EST` computations in a non-monadic context using `runEST`.\n</code>",
 "3073":
 "<code>ST (σ : Type) : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A restricted version of `IO` in which mutable state is the only side effect.\n\nIt is possible to run `ST` computations in a non-monadic context using `runST`.\n</code>",
 "3072":
 "<code class=\"docstring\">A state monad that uses an actual mutable reference cell (i.e. an `ST.Ref`).\n\nThis is syntax, rather than a function, to make it easier to use. Its elaborator synthesizes an\nappropriate parameter for the underlying monad's `ST` effects, then passes it to `StateRefT'`.\n</code>",
 "3071": "<code>α → σ → m β</code>",
 "3070": "<code>StateCpsT σ m α</code>",
 "307": "<code>thirdChar (xs : Array Char) : Char</code>",
 "3069":
 "<code>StateT.modifyGet.{u, v} {σ : Type u} {m : Type u → Type v} [Monad m] {α : Type u} (f : σ → α × σ) : StateT σ m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.\n\nIt is equivalent to `do let (a, s) := f (← StateT.get); StateT.set s; pure a`. However, using\n`StateT.modifyGet` may lead to better performance because it doesn't add a new reference to the\nstate value, and additional references can inhibit in-place updates of data.\n</code>",
 "3068": "<code>α → StateT σ m β</code>",
 "3067": "<code>Unit → StateT σ m α</code>",
 "3066": "<code>StateT σ m α</code>",
 "3065":
 "<code>modifyGetThe.{u, v} {α : Type u} (σ : Type u) {m : Type u → Type v} [MonadStateOf σ m] (f : σ → α × σ) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that has the explicitly-provided type `σ`. The function both\ncomputes a new state and a value. The new state replaces the current state, and the value is\nreturned.\n\nIt is equivalent to `do let (a, s) := f (← getThe σ); set s; pure a`. However, using `modifyGetThe`\nmay lead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n</code>",
 "3064": "<code>σ → α × σ</code>",
 "3063":
 "<code>MonadStateOf.mk.{u, v} {σ : semiOutParam (Type u)} {m : Type u → Type v} (get : m σ) (set : σ → m PUnit)\n  (modifyGet : {α : Type u} → (σ → α × σ) → m α) : MonadStateOf σ m</code>",
 "3062": "<code>semiOutParam (Type u)</code>",
 "3061": "<code>σ → σ</code>",
 "3060": "<code>MonadState σ m</code>",
 "306":
 "<code>Inhabited.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">`Inhabited α` is a typeclass that says that `α` has a designated element,\ncalled `(default : α)`. This is sometimes referred to as a \"pointed type\".\n\nThis class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, `Array.get! arr i : α` returns\na value of type `α` when `arr : Array α`, but if `i` is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type `α` (and in fact this is required\nfor logical consistency), so in this case it returns `default`.\n</code>",
 "3059":
 "<code>{α : Type u} → (σ → α × σ) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.\n\nIt is equivalent to `do let (a, s) := f (← get); set s; pure a`. However, using `modifyGet` may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n</code>",
 "3058":
 "<code>σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "3057":
 "<code>m σ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the current value of the monad's mutable state.\n</code>",
 "3056":
 "<code>MonadState.mk.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} (get : m σ) (set : σ → m PUnit)\n  (modifyGet : {α : Type u} → (σ → α × σ) → m α) : MonadState σ m</code>",
 "3055": "<code>outParam (Type u)</code>",
 "3054":
 "<code>ST.Ref (σ α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Mutable reference cells that contain values of type `α`. These cells can read from and mutated in\nthe `ST σ` monad.\n</code>",
 "3053": "<code>Id α</code>",
 "3052": "<code>containsFive (xs : List Nat) : Bool</code>",
 "3051":
 "<code>EStateM.{u} (ε σ α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A combined state and exception monad in which exceptions do not automatically roll back the state.\n\nInstances of `EStateM.Backtrackable` provide a way to roll back some part of the state if needed.\n\n`EStateM ε σ` is equivalent to `ExceptT ε (StateM σ)`, but it is more efficient.\n</code>",
 "3050":
 "<code>ExceptCpsT.{u, v} (ε : Type u) (m : Type u → Type v) (α : Type u) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds exceptions of type `ε` to a monad `m`.\n\nInstead of using `Except ε` to model exceptions, this implementation uses continuation passing\nstyle. This has different performance characteristics from `ExceptT ε`.\n</code>",
 "305": "<code>∀ (x : α), f x = g x</code>",
 "3049":
 "<code>StateRefT' (ω σ : Type) (m : Type → Type) (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A state monad that uses an actual mutable reference cell (i.e. an `ST.Ref ω σ`).\n\nThe macro `StateRefT σ m α` infers `ω` from `m`. It should normally be used instead.\n</code>",
 "3048":
 "<code>StateCpsT.{u, v} (σ : Type u) (m : Type u → Type v) (α : Type u) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An alternative implementation of a state monad transformer that internally uses continuation passing\nstyle instead of tuples.\n</code>",
 "3047":
 "<code>{α : Type u} → m α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to `liftWith`'s parameter.\n</code>",
 "3046": "<code>IdT m β✝</code>",
 "3045": "<code>({β : Type u} → IdT m β → m β) → m α✝</code>",
 "3044":
 "<code>{α : Type u} → (({β : Type u} → IdT m β → m β) → m α) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "3043": "<code>m α✝</code>",
 "3042":
 "<code>{α : Type u} → m α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "3041": "<code>α✝ → IdT m β✝</code>",
 "3040": "<code>IdT m α✝</code>",
 "304": "<code>(x : α) → β x</code>",
 "3039":
 "<code>{α β : Type u} → IdT m α → (α → IdT m β) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "3038":
 "<code>{α : Type u} → α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "3037": "<code>IdT m α</code>",
 "3036":
 "<code>IdT.run.{u, v} {m : Type u → Type v} {α : Type u} (act : IdT m α) : m α</code>",
 "3035": "<code>IdT.{u, v} (m : Type u → Type v) : Type u → Type v</code>",
 "3034": "<code>(Type u → Type v) → Type u → Type w</code>",
 "3033": "<code><span class=\"literal string\">\"Four\"</span> : String</code>",
 "3032": "<code>M (α : Type) : Type</code>",
 "3031":
 "<code>throwThe.{u, v, w} (ε : Type u) {m : Type v → Type w} [MonadExceptOf ε m] {α : Type v} (e : ε) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception, with the exception type specified explicitly. This is useful when a monad\nsupports throwing more than one type of exception.\n\nUse `throw` for a version that expects the exception type to be inferred from `m`.\n</code>",
 "3030":
 "<code>MonadWithReaderOf.{u, v} (ρ : semiOutParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A reader monad that additionally allows the value to be locally overridden.\n\nIn this class, `ρ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadWithReader ρ` provides the same operations, but requires that `ρ` be inferable from `m`.\n</code>",
 "303": "<code>α → Sort v</code>",
 "3029":
 "<code>withTheReader.{u, v} (ρ : Type u) {m : Type u → Type v} [MonadWithReaderOf ρ m] {α : Type u} (f : ρ → ρ) (x : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Locally modifies the reader monad's value while running an action, with the reader monad's local\nvalue type specified explicitly. This is useful when a monad supports reading more than one type of\nvalue.\n\nDuring the inner action `x`, reading the value returns `f` applied to the original value. After\ncontrol returns from `x`, the reader monad's value is restored.\n\nUse `withReader` for a version that expects the local value's type to be inferred from `m`.\n</code>",
 "3028":
 "<code>MonadWithReader.withReader.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v} [self : MonadWithReader ρ m]\n  {α : Type u} (f : ρ → ρ) (x : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Locally modifies the reader monad's value while running an action.\n\nDuring the inner action `x`, reading the value returns `f` applied to the original value. After\ncontrol returns from `x`, the reader monad's value is restored.\n</code>",
 "3027":
 "<code>MonadState.modifyGet.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] {α : Type u} :\n  (σ → α × σ) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.\n\nIt is equivalent to `do let (a, s) := f (← get); set s; pure a`. However, using `modifyGet` may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n</code>",
 "3026":
 "<code>tryCatchThe.{u, v, w} (ε : Type u) {m : Type v → Type w} [MonadExceptOf ε m] {α : Type v} (x : m α) (handle : ε → m α) :\n  m α</code><span class=\"sep\"></span><code class=\"docstring\">Catches errors, recovering using `handle`. The exception type is specified explicitly. This is useful when a monad\nsupports throwing or handling more than one type of exception.\n\nUse `tryCatch`, for a version that expects the exception type to be inferred from `m`.\n</code>",
 "3025":
 "<code>readThe.{u, v} (ρ : Type u) {m : Type u → Type v} [MonadReaderOf ρ m] : m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value whose type is `ρ`.  This is useful when a monad supports reading more than\none type of value.\n\nUse `read` for a version that expects the type `ρ` to be inferred from `m`.\n</code>",
 "3024":
 "<code>getThe.{u, v} (σ : Type u) {m : Type u → Type v} [MonadStateOf σ m] : m σ</code><span class=\"sep\"></span><code class=\"docstring\">Gets the current state that has the explicitly-provided type `σ`. When the current monad has\nmultiple state types available, this function selects one of them.\n</code>",
 "3023":
 "<code>MonadExceptOf.{u, v, w} (ε : semiOutParam (Type u)) (m : Type v → Type w) : Type (max (max u (v + 1)) w)</code><span class=\"sep\"></span><code class=\"docstring\">Exception monads provide the ability to throw errors and handle errors.\n\nIn this class, `ε` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadExcept ε` provides the same operations, but requires that `ε` be inferable from `m`.\n\n`tryCatchThe`, which takes an explicit exception type, is used to desugar `try ... catch ...` steps\ninside `do`-blocks when the handlers have type annotations.\n</code>",
 "3022":
 "<code>MonadReaderOf.{u, v} (ρ : semiOutParam (Type u)) (m : Type u → Type v) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Reader monads provide the ability to implicitly thread a value through a computation. The value can\nbe read, but not written. A `MonadWithReader ρ` instance additionally allows the value to be locally\noverridden for a sub-computation.\n\nIn this class, `ρ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadReader ρ` provides the same operations, but requires that `ρ` be inferable from `m`.\n</code>",
 "3021":
 "<code>StateT.run'.{u, v} {σ : Type u} {m : Type u → Type v} [Functor m] {α : Type u} (x : StateT σ m α) (s : σ) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value, discarding the final state.\n</code>",
 "3020":
 "<code>MonadState.set.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] : σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "302":
 "<code class=\"docstring\">A specific universe in Lean's infinite hierarchy of universes. </code>",
 "3019":
 "<code>sumUntilFive.{u_1} {m : Type → Type u_1} [Monad m] [MonadState Nat m] [MonadExcept String m] (xs : List Nat) : m Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the sum of the non-5 prefix of a list. </code>",
 "3018":
 "<code><span class=\"literal string\">\"Five was encountered\"</span> : String</code>",
 "3017":
 "<code>sumNonFives.{u_1} {m : Type → Type u_1} [Monad m] [MonadState Nat m] [MonadExcept String m] (xs : List Nat) : m Unit</code>",
 "3016":
 "<code>MonadExcept.{u, v, w} (ε : outParam (Type u)) (m : Type v → Type w) : Type (max (max u (v + 1)) w)</code><span class=\"sep\"></span><code class=\"docstring\">Exception monads provide the ability to throw errors and handle errors.\n\nIn this class, `ε` is an `outParam`, which means that it is inferred from `m`. `MonadExceptOf ε`\nprovides the same operations, but allows `ε` to influence instance synthesis.\n\n`MonadExcept.tryCatch` is used to desugar `try ... catch ...` steps inside `do`-blocks when the\nhandlers do not have exception type annotations.\n</code>",
 "3015":
 "<code>MonadWithReader.{u, v} (ρ : outParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A reader monad that additionally allows the value to be locally overridden.\n\nIn this class, `ρ` is an `outParam`, which means that it is inferred from `m`. `MonadWithReaderOf ρ`\nprovides the same operations, but allows `ρ` to influence instance synthesis.\n</code>",
 "3014":
 "<code>MonadReader.{u, v} (ρ : outParam (Type u)) (m : Type u → Type v) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Reader monads provide the ability to implicitly thread a value through a computation. The value can\nbe read, but not written. A `MonadWithReader ρ` instance additionally allows the value to be locally\noverridden for a sub-computation.\n\nIn this class, `ρ` is an `outParam`, which means that it is inferred from `m`. `MonadReaderOf ρ`\nprovides the same operations, but allows `ρ` to influence instance synthesis.\n</code>",
 "3013":
 "<code>MonadState.{u, v} (σ : outParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">State monads provide a value of a given type (the _state_) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. `ST.Ref σ`), or in other ways.\n\nIn this class, `σ` is an `outParam`, which means that it is inferred from `m`. `MonadStateOf σ`\nprovides the same operations, but allows `σ` to influence instance synthesis.\n\nThe mutable state of a state monad is visible between multiple `do`-blocks or functions, unlike\n[local mutable state](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation-let-mut) in `do`-notation.\n</code>",
 "3012": "<code>m Bool</code>",
 "3011":
 "<code>orM.{u, v} {m : Type u → Type v} {β : Type u} [Monad m] [ToBool β] (x y : m β) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Converts the result of the monadic action `x` to a `Bool`. If it is `true`, returns it and ignores\n`y`; otherwise, runs `y` and returns its result.\n\nThis a monadic counterpart to the short-circuiting `||` operator, usually accessed via the `&lt;||&gt;`\noperator.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;||&gt;` in identifiers is `orM`.</code>",
 "3010":
 "<code>andM.{u, v} {m : Type u → Type v} {β : Type u} [Monad m] [ToBool β] (x y : m β) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Converts the result of the monadic action `x` to a `Bool`. If it is `true`, returns `y`; otherwise,\nreturns the original result of `x`.\n\nThis a monadic counterpart to the short-circuiting `&&` operator, usually accessed via the `&lt;&&&gt;`\noperator.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;&&&gt;` in identifiers is `andM`.</code>",
 "301": "<code>Sort u</code>",
 "3009": "<code>ToBool.{u} (α : Type u) : Type u</code>",
 "3008": "<code>Type → Type v</code>",
 "3007":
 "<code>Functor.discard.{u, v} {f : Type u → Type v} {α : Type u} [Functor f] (x : f α) : f PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Discards the value in a functor, retaining the functor's structure.\n\nDiscarding values is especially useful when using `Applicative` functors or `Monad`s to implement\neffects, and some operation should be carried out only for its effects. In `do`-notation, statements\nwhose values are discarded must return `Unit`, and `discard` can be used to explicitly discard their\nvalues.\n</code>",
 "3006":
 "<code><span class=\"literal string\">\"These values were kept:\"</span> : String</code>",
 "3005": "<code><span class=\"literal string\">\"n\"</span> : String</code>",
 "3004": "<code>values : Array Nat</code>",
 "3003":
 "<code>Array.filterM.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → m Bool) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` to every element in the array, in order from left to right, and\nreturns the array of elements for which `p` returns `true`.\n\nOnly elements from `start` (inclusive) to `stop` (exclusive) are considered. Elements outside that\nrange are discarded. By default, the entire array is checked.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 1\nChecking 2\nChecking 5\nChecking 2\nChecking 7\nChecking 7\n```\n```output\n#[1, 2, 2]\n```\n</code>",
 "3002": "<code>α → β → m (ForInStep β)</code>",
 "3001": "<code>Type u_4</code>",
 "3000": "<code>Type u_3</code>",
 "300":
 "<code class=\"docstring\">Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n</code>",
 "30":
 "<code>Even.zero : Even 0</code><span class=\"sep\"></span><code class=\"docstring\">0 is considered even here </code>",
 "3": "<code>hello : IO Unit</code>",
 "2999": "<code>Type u_1 → Type u_2</code>",
 "2998":
 "<code>[Monad m] → γ → (α → m PUnit) → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Runs the monadic action `f` on each element of the collection `coll`.\n</code>",
 "2997":
 "<code>ForM.mk.{u, v, w₁, w₂} {m : Type u → Type v} {γ : Type w₁} {α : outParam (Type w₂)}\n  (forM : [Monad m] → γ → (α → m PUnit) → m PUnit) : ForM m γ α</code>",
 "2996":
 "<code>ForM.forIn.{u_1, u_2, u_3, u_4} {m : Type u_1 → Type u_2} {β : Type u_1} {ρ : Type u_3} {α : Type u_4} [Monad m]\n  [ForM (StateT β (ExceptT β m)) ρ α] (x : ρ) (b : β) (f : α → β → m (ForInStep β)) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Creates a suitable implementation of `ForIn.forIn` from a `ForM` instance.\n</code>",
 "2995":
 "<code>ForM.{u, v, w₁, w₂} (m : Type u → Type v) (γ : Type w₁) (α : outParam (Type w₂)) :\n  Type (max (max (max (u + 1) v) w₁) w₂)</code><span class=\"sep\"></span><code class=\"docstring\">Overloaded monadic iteration over some container type.\n\nAn instance of `ForM m γ α` describes how to iterate a monadic operator over a container of type `γ`\nwith elements of type `α` in the monad `m`. The element type should be uniquely determined by the\nmonad and the container.\n\nUse `ForM.forIn` to construct a `ForIn` instance from a `ForM` instance, thus enabling the use of\nthe `for` operator in `do`-notation.\n</code>",
 "2994": "<code>outParam (Type w₂)</code>",
 "2993": "<code>Type w₁</code>",
 "2992": "<code>ForInStep α</code>",
 "2991": "<code>ρ</code>",
 "2990":
 "<code>{β : Type u₁} → [Monad m] → (x : ρ) → β → ((a : α) → a ∈ x → β → m (ForInStep β)) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Monadically iterates over the contents of a collection `xs`, with a local state `b` and the\npossibility of early termination. At each iteration, the body of the loop is provided with a proof\nthat the current element is in the collection.\n\nBecause a `do` block supports local mutable bindings along with `return`, and `break`, the monadic\naction passed to `ForIn'.forIn'` takes a starting state in addition to the current element of the\ncollection with its membership proof. The action returns an updated state together with an\nindication of whether iteration should continue or terminate. If the action returns\n`ForInStep.done`, then `ForIn'.forIn'` should stop iteration and return the updated state. If the\naction returns `ForInStep.yield`, then `ForIn'.forIn'` should continue iterating if there are\nfurther elements, passing the updated state to the action.\n\nMore information about the translation of `for` loops into `ForIn'.forIn'` is available in [the\nLean reference manual](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=monad-iteration-syntax).\n</code>",
 "299":
 "<code>funext.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : ∀ (x : α), f x = g x) : f = g</code><span class=\"sep\"></span><code class=\"docstring\">**Function extensionality.** If two functions return equal results for all possible arguments, then\nthey are equal.\n\nIt is called “extensionality” because it provides a way to prove two objects equal based on the\nproperties of the underlying mathematical functions, rather than based on the syntax used to denote\nthem. Function extensionality is a theorem that can be [proved using quotient\ntypes](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=quotient-funext).\n</code>",
 "2989":
 "<code>ForIn'.mk.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)} {d : outParam (Membership α ρ)}\n  (forIn' : {β : Type u₁} → [Monad m] → (x : ρ) → β → ((a : α) → a ∈ x → β → m (ForInStep β)) → m β) : ForIn' m ρ α d</code>",
 "2988": "<code>outParam (Membership α ρ)</code>",
 "2987":
 "<code>ForInStep.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">An indication of whether a loop's body terminated early that's used to compile the `for x in xs`\nnotation.\n\nA collection's `ForIn` or `ForIn'` instance describe's how to iterate over its elements. The monadic\naction that represents the body of the loop returns a `ForInStep α`, where `α` is the local state\nused to implement features such as `let mut`.\n</code>",
 "2986": "<code>Type u₁</code>",
 "2985":
 "<code>{β : Type u₁} → [Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Monadically iterates over the contents of a collection `xs`, with a local state `b` and the\npossibility of early termination.\n\nBecause a `do` block supports local mutable bindings along with `return`, and `break`, the monadic\naction passed to `ForIn.forIn` takes a starting state in addition to the current element of the\ncollection and returns an updated state together with an indication of whether iteration should\ncontinue or terminate. If the action returns `ForInStep.done`, then `ForIn.forIn` should stop\niteration and return the updated state. If the action returns `ForInStep.yield`, then\n`ForIn.forIn` should continue iterating if there are further elements, passing the updated state\nto the action.\n\nMore information about the translation of `for` loops into `ForIn.forIn` is available in [the Lean\nreference manual](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=monad-iteration-syntax).\n</code>",
 "2984":
 "<code>ForIn.mk.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)}\n  (forIn : {β : Type u₁} → [Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β) : ForIn m ρ α</code>",
 "2983": "<code>outParam (Type v)</code>",
 "2982": "<code>Type u₁ → Type u₂</code>",
 "2981":
 "<code>ForIn'.{u, v, u₁, u₂} (m : Type u₁ → Type u₂) (ρ : Type u) (α : outParam (Type v)) (d : outParam (Membership α ρ)) :\n  Type (max (max (max u (u₁ + 1)) u₂) v)</code><span class=\"sep\"></span><code class=\"docstring\">Monadic iteration in `do`-blocks with a membership proof, using the `for h : x in xs` notation.\n\nThe parameter `m` is the monad of the `do`-block in which iteration is performed, `ρ` is the type of\nthe collection being iterated over, `α` is the type of elements, and `d` is the specific membership\npredicate to provide.\n</code>",
 "2980":
 "<code>MonadStateOf.set.{u, v} {σ : semiOutParam (Type u)} {m : Type u → Type v} [self : MonadStateOf σ m] : σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "298": "<code>β : α → Type</code>",
 "2979": "<code>test : StateM Nat Unit</code>",
 "2978": "<code>(x : α) → x ∈ xs → β → m β</code>",
 "2977":
 "<code class=\"docstring\">`break` exits the surrounding `for` loop. </code>",
 "2976": "<code>α → β → m β</code>",
 "2975": "<code>Coll</code>",
 "2974":
 "<code>ForInStep.done.{u} {α : Type u} : α → ForInStep α</code><span class=\"sep\"></span><code class=\"docstring\">The loop should terminate early.\n\n`ForInStep.done` is produced by uses of `break` or `return` in the loop body.\n</code>",
 "2973":
 "<code>ForInStep.yield.{u} {α : Type u} : α → ForInStep α</code><span class=\"sep\"></span><code class=\"docstring\">The loop should continue with the next iteration, using the returned state.\n\n`ForInStep.yield` is produced by `continue` and by reaching the bottom of the loop body.\n</code>",
 "2972":
 "<code>DecidablePred.{u} {α : Sort u} (r : α → Prop) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A decidable predicate.\n\nA predicate is decidable if the corresponding proposition is `Decidable` for each possible argument.\n</code>",
 "2971":
 "<code>satisfyingIndices {α : Type} (p : α → Prop) [DecidablePred p] (xs : Array α) : Array Nat</code>",
 "2970": "<code>Array (Nat × Char)</code>",
 "297": "<code>α : Type</code>",
 "2969": "<code>m (Option β)</code>",
 "2968": "<code>m Unit</code>",
 "2967":
 "<code>ForIn.{u, v, u₁, u₂} (m : Type u₁ → Type u₂) (ρ : Type u) (α : outParam (Type v)) :\n  Type (max (max (max u (u₁ + 1)) u₂) v)</code><span class=\"sep\"></span><code class=\"docstring\">Monadic iteration in `do`-blocks, using the `for x in xs` notation.\n\nThe parameter `m` is the monad of the `do`-block in which iteration is performed, `ρ` is the type of\nthe collection being iterated over, and `α` is the type of elements.\n</code>",
 "2966":
 "<code>Bind.kleisliLeft.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β γ : Type u_1} [Bind m] (f₂ : β → m γ)\n  (f₁ : α → m β) (a : α) : m γ</code><span class=\"sep\"></span><code class=\"docstring\">Right-to-left composition of Kleisli arrows. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;=&lt;` in identifiers is `kleisliLeft`.</code>",
 "2965":
 "<code>Bind.kleisliRight.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β γ : Type u_1} [Bind m] (f₁ : α → m β)\n  (f₂ : β → m γ) (a : α) : m γ</code><span class=\"sep\"></span><code class=\"docstring\">Left-to-right composition of Kleisli arrows. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;=&gt;` in identifiers is `kleisliRight`.</code>",
 "2964": "<code>User</code>",
 "2963":
 "<code><span class=\"literal string\">\"Let's try again.\"</span> : String</code>",
 "2962":
 "<code>String.toNat? (s : String) : Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of a natural number, returning it. Returns `none`\nif the string does not contain a decimal natural number.\n\nA string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.\n\nUse `String.isNat` to check whether `String.toNat?` would return `some`. `String.toNat!` is an\nalternative that panics instead of returning `none` when the string is not a natural number.\n\nExamples:\n * `\"\".toNat? = none`\n * `\"0\".toNat? = some 0`\n * `\"5\".toNat? = some 5`\n * `\"587\".toNat? = some 587`\n * `\"-587\".toNat? = none`\n * `\" 5\".toNat? = none`\n * `\"2+3\".toNat? = none`\n * `\"0xff\".toNat? = none`\n</code>",
 "2961":
 "<code>String.trim (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes leading and trailing whitespace from a string.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`.\n\nExamples:\n* `\"abc\".trim = \"abc\"`\n* `\"   abc\".trim = \"abc\"`\n* `\"abc \\t  \".trim = \"abc\"`\n* `\"  abc   \".trim = \"abc\"`\n* `\"abc\\ndef\\n\".trim = \"abc\\ndef\"`\n</code>",
 "2960":
 "<code><span class=\"literal string\">\"What is your favorite natural number?\"</span> : String</code>",
 "296": "<code>f (x : α) : β x</code>",
 "2959": "<code>getFavoriteNat : IO Nat</code>",
 "2958":
 "<code>String.trimRight (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes trailing whitespace from a string.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`.\n\nExamples:\n* `\"abc\".trimRight = \"abc\"`\n* `\"   abc\".trimRight = \"   abc\"`\n* `\"abc \\t  \".trimRight = \"abc\"`\n* `\"  abc   \".trimRight = \"  abc\"`\n* `\"abc\\ndef\\n\".trimRight = \"abc\\ndef\"`\n</code>",
 "2957":
 "<code>IO.FS.Stream.getLine (self : IO.FS.Stream) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads text up to and including the next newline from the stream.\n\nIf the returned string is empty, an end-of-file marker (EOF) has been reached.\nAn EOF does not actually close a stream, so further reads may block and return more data.\n</code>",
 "2956":
 "<code>IO.getStdin : BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Returns the current thread's standard input stream.\n\nUse `IO.setStdin` to replace the current thread's standard input stream.\n</code>",
 "2955":
 "<code><span class=\"literal string\">\"What is your name?\"</span> : String</code>",
 "2954": "<code>getName : IO String</code>",
 "2953": "<code>User.mk (name : String) (favoriteNat : Nat) : User</code>",
 "2952": "<code>main : IO Unit</code>",
 "2951": "<code>User.favoriteNat (self : User) : Nat</code>",
 "2950": "<code>User.name (self : User) : String</code>",
 "295": "<code>Type</code>",
 "2949": "<code>User : Type</code>",
 "2948":
 "<code>OrElse.orElse.{u} {α : Type u} [self : OrElse α] : α → (Unit → α) → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a &lt;|&gt; b : α`. See `HOrElse`. </code>",
 "2947": "<code>Array UInt8</code>",
 "2946": "<code>Array String</code>",
 "2945":
 "<code>{β : Type} →\n  StateT (Array String) (StateT (Array UInt8) (Except String)) β →\n    Except String (stM (Except String) (StateT (Array String) (StateT (Array UInt8) (Except String))) β)</code>",
 "2944":
 "<code>modifyThe.{u, v} (σ : Type u) {m : Type u → Type v} [MonadStateOf σ m] (f : σ → σ) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Mutates the current state that has the explicitly-provided type `σ`, replacing its value with the\nresult of applying `f` to it. When the current monad has multiple state types available, this\nfunction selects one of them.\n\nIt is equivalent to `do set (f (← get))`. However, using `modify` may lead to higher performance\nbecause it doesn't add a new reference to the state value. Additional references can inhibit\nin-place updates of data.\n</code>",
 "2943":
 "<code>MonadStateOf.{u, v} (σ : semiOutParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">State monads provide a value of a given type (the _state_) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. `ST.Ref σ`), or in other ways.\n\nIn this class, `σ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadState σ` provides the same operations, but requires that `σ` be inferable from `m`.\n\nThe mutable state of a state monad is visible between multiple `do`-blocks or functions, unlike\n[local mutable state](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation-let-mut) in `do`-notation.\n</code>",
 "2942":
 "<code>getBytes' (input : Array Nat) : StateT (Array String) (StateT (Array UInt8) (Except String)) Unit</code>",
 "2941":
 "<code>MonadExcept.tryCatch.{u, v, w} {ε : outParam (Type u)} {m : Type v → Type w} [self : MonadExcept ε m] {α : Type v}\n  (body : m α) (handler : ε → m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Catches errors thrown in `body`, passing them to `handler`. Errors in `handler` are not caught.\n</code>",
 "2940":
 "<code>Except.map.{u, u_1, u_2} {ε : Type u} {α : Type u_1} {β : Type u_2} (f : α → β) : Except ε α → Except ε β</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a successful result with a function, doing nothing when an exception is thrown.\n\nExamples:\n* `(pure 2 : Except String Nat).map toString = pure 2`\n* `(throw \"Error\" : Except String Nat).map toString = throw \"Error\"`\n</code>",
 "294":
 "<code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>",
 "2939":
 "<code>Nat.toUInt8 (n : Nat) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit unsigned integer, wrapping on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Nat.toUInt8 5 = 5`\n* `Nat.toUInt8 255 = 255`\n* `Nat.toUInt8 256 = 0`\n* `Nat.toUInt8 259 = 3`\n* `Nat.toUInt8 32770 = 2`\n</code>",
 "2938": "<code>getByte (n : Nat) : Except String UInt8</code>",
 "2937":
 "<code>getBytes (input : Array Nat) : StateT (Array UInt8) (Except String) Unit</code>",
 "2936": "<code>ε → Except ε α</code>",
 "2935": "<code>Except ε α</code>",
 "2934":
 "<code>Except.tryCatch.{u, u_1} {ε : Type u} {α : Type u_1} (ma : Except ε α) (handle : ε → Except ε α) : Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">Handles exceptions thrown in the `Except ε` monad.\n\nIf `ma` is successful, its result is returned. If it throws an exception, then `handle` is invoked\non the exception's value.\n\nExamples:\n * `(pure 2 : Except String Nat).tryCatch (pure ·.length) = pure 2`\n * `(throw \"Error\" : Except String Nat).tryCatch (pure ·.length) = pure 5`\n * `(throw \"Error\" : Except String Nat).tryCatch (fun x =&gt; throw (\"E: \" ++ x)) = throw \"E: Error\"`\n</code>",
 "2933": "<code>({β : Type u} → n β → m (stM m n β)) → m (stM m n α)</code>",
 "2932":
 "<code>{α : Type u} → stM m n α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to `liftWith`'s parameter.\n</code>",
 "2931":
 "<code>MonadControlT.stM.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) [self : MonadControlT m n] : Type u → Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.\n</code>",
 "2930":
 "<code>{α : Type u} → (({β : Type u} → n β → m (stM m n β)) → m α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "293":
 "<code>Array.size.{u} {α : Type u} (a : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Gets the number of elements stored in an array.\n\nThis is a cached value, so it is `O(1)` to access. The space allocated for an array, referred to as\nits _capacity_, is at least as large as its size, but may be larger. The capacity of an array is an\ninternal detail that's not observable by Lean code.\n</code>",
 "2929":
 "<code>MonadControlT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} (stM : Type u → Type u)\n  (liftWith : {α : Type u} → (({β : Type u} → n β → m (stM β)) → m α) → n α) (restoreM : {α : Type u} → stM α → n α) :\n  MonadControlT m n</code>",
 "2928":
 "<code>MonadControlT.liftWith.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [self : MonadControlT m n] {α : Type u} :\n  (({β : Type u} → n β → m (MonadControlT.stM m n β)) → m α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "2927":
 "<code>{α : Type u} → m (MonadControl.stM m n α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to `liftWith`'s parameter.\n</code>",
 "2926":
 "<code>MonadControl.stM.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) [self : MonadControl m n] :\n  Type u → Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.\n</code>",
 "2925":
 "<code>{α : Type u} → (({β : Type u} → n β → m (MonadControl.stM m n β)) → m α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "2924":
 "<code>Type u → Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.\n</code>",
 "2923":
 "<code>MonadControl.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w} (stM : Type u → Type u)\n  (liftWith : {α : Type u} → (({β : Type u} → n β → m (stM β)) → m α) → n α)\n  (restoreM : {α : Type u} → m (stM α) → n α) : MonadControl m n</code>",
 "2922":
 "<code>MonadControlT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to lift a computation from one monad to another while providing the lifted computation with a\nmeans of interpreting computations from the outer monad. This provides a means of lifting\nhigher-order operations automatically.\n\nClients should typically use `control` or `controlAt`, which request an instance of `MonadControlT`:\nthe reflexive, transitive closure of `MonadControl`. New instances should be defined for\n`MonadControl` itself.\n</code>",
 "2921":
 "<code>controlAt.{u, v, w} (m : Type u → Type v) {n : Type u → Type w} [MonadControlT m n] [Bind n] {α : Type u}\n  (f : ({β : Type u} → n β → m (stM m n β)) → m (stM m n α)) : n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an operation from an inner monad to an outer monad, providing it with a reverse lifting\noperator that allows outer monad computations to be run in the inner monad. The lifted operation is\nrequired to return extra information that is required in order to reconstruct the reverse lift's\neffects in the outer monad; this extra information is determined by `stM`.\n\nThis function takes the inner monad as an explicit parameter. Use `control` to infer the monad.\n</code>",
 "2920":
 "<code>control.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [MonadControlT m n] [Bind n] {α : Type u}\n  (f : ({β : Type u} → n β → m (stM m n β)) → m (stM m n α)) : n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an operation from an inner monad to an outer monad, providing it with a reverse lifting\noperator that allows outer monad computations to be run in the inner monad. The lifted operation is\nrequired to return extra information that is required in order to reconstruct the reverse lift's\neffects in the outer monad; this extra information is determined by `stM`.\n\nThis function takes the inner monad as an implicit parameter. Use `controlAt` to specify it\nexplicitly.\n</code>",
 "292": "<code>i &lt; xs.size</code>",
 "2919":
 "<code>MonadFunctorT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w}\n  (monadMap : {α : Type u} → ({β : Type u} → m β → m β) → n α → n α) : MonadFunctorT m n</code>",
 "2918":
 "<code>{α : Type u} → ({β : Type u} → m β → m β) → n α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a fully-polymorphic transformation of `m` into `n`.\n</code>",
 "2917":
 "<code>MonadFunctor.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w}\n  (monadMap : {α : Type u} → ({β : Type u} → m β → m β) → n α → n α) : MonadFunctor m n</code>",
 "2916":
 "<code>MonadFunctorT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to interpret a fully-polymorphic function in `m` into `n`. Such a function can be thought of\nas one that may change the effects in `m`, but can't do so based on specific values that are\nprovided.\n\nThis is the reflexive, transitive closure of `MonadFunctor`. It automatically chains together\n`MonadFunctor` instances as needed. Clients of `MonadFunctor` should typically use `MonadFunctorT`,\nbut new instances should be defined for `MonadFunctor`.\n</code>",
 "2915":
 "<code>MonadControl.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to lift a computation from one monad to another while providing the lifted computation with a\nmeans of interpreting computations from the outer monad. This provides a means of lifting\nhigher-order operations automatically.\n\nClients should typically use `control` or `controlAt`, which request an instance of `MonadControlT`:\nthe reflexive, transitive closure of `MonadControl`. New instances should be defined for\n`MonadControl` itself.\n</code>",
 "2914":
 "<code>MonadFunctor.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to interpret a fully-polymorphic function in `m` into `n`. Such a function can be thought of\nas one that may change the effects in `m`, but can't do so based on specific values that are\nprovided.\n\nClients of `MonadFunctor` should typically use `MonadFunctorT`, which is the reflexive, transitive\nclosure of `MonadFunctor`. New instances should be defined for `MonadFunctor.`\n</code>",
 "2913":
 "<code>autoLift</code><span class=\"sep\"></span><code class=\"docstring\">Insert monadic lifts (i.e., `liftM` and coercions) when needed.</code>",
 "2912":
 "<code><span class=\"literal string\">\"Too much!\"</span> : String</code>",
 "2911":
 "<code>MonadReader.read.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v} [self : MonadReader ρ m] : m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value.\n\nUse `readThe` to explicitly specify a type when more than one value is available.\n</code>",
 "2910":
 "<code>ExceptT.{u, v} (ε : Type u) (m : Type u → Type v) (α : Type u) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Adds exceptions of type `ε` to a monad `m`.\n</code>",
 "291":
 "<code>Array.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with elements\nfrom `α`. This type has special support in the runtime.\n\nArrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed _destructively_. This results in performance comparable to mutable\narrays in imperative programming languages.\n\nAn array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\n`Array.size`, but the capacity is not observable from Lean code. `Array.emptyWithCapacity n` creates\nan array which is equal to `#[]`, but internally allocates an array of capacity `n`. When the size\nexceeds the capacity, allocation is required to grow the array.\n\nFrom the point of view of proofs, `Array α` is just a wrapper around `List α`.\n</code>",
 "2909":
 "<code>ReaderT.{u, v} (ρ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds the ability to access a read-only value of type `ρ` to a monad. The value can be locally\noverridden by `withReader`, but it cannot be mutated.\n\nActions in the resulting monad are functions that take the local value as a parameter, returning\nordinary actions in `m`.\n</code>",
 "2908":
 "<code>incrOrFail : ReaderT Nat (ExceptT String (StateM Nat)) Unit</code>",
 "2907":
 "<code>modify.{u, v} {σ : Type u} {m : Type u → Type v} [MonadState σ m] (f : σ → σ) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Mutates the current state, replacing its value with the result of applying `f` to it.\n\nUse `modifyThe` to explicitly select a state type to modify.\n\nIt is equivalent to `do set (f (← get))`. However, using `modify` may lead to higher performance\nbecause it doesn't add a new reference to the state value. Additional references can inhibit\nin-place updates of data.\n</code>",
 "2906": "<code>incrBy (n : Nat) : StateM Nat Unit</code>",
 "2905": "<code>fromBaseIO {α : Type} (act : BaseIO α) : IO α</code>",
 "2904":
 "<code>Lean.Internal.liftCoeM.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} {α β : Type u} [MonadLiftT m n]\n  [(a : α) → CoeT α a β] [Monad n] (x : m α) : n β</code><span class=\"sep\"></span><code class=\"docstring\">Helper definition used by the elaborator. It is not meant to be used directly by users.\n\nThis is used for coercions between monads, in the case where we want to apply\na monad lift and a coercion on the result type at the same time.\n</code>",
 "2903": "<code>MonadLiftT m n</code>",
 "2902": "<code class=\"docstring\">The universe parameter w</code>",
 "2901":
 "<code>liftM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [self : MonadLiftT m n] {α : Type u_1} :\n  m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "2900":
 "<code>Lean.Internal.coeM.{u, v} {m : Type u → Type v} {α β : Type u} [(a : α) → CoeT α a β] [Monad m] (x : m α) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Helper definition used by the elaborator. It is not meant to be used directly by users.\n\nThis is used for coercing the result type under a monad.\n</code>",
 "290": "<code>Array Nat</code>",
 "29":
 "<code>Even : Nat → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Evenness: a number is even if it can be evenly divided by two.\n</code>",
 "2899":
 "<code>IO.FS.Stream : Type</code><span class=\"sep\"></span><code class=\"docstring\">A pure-Lean abstraction of POSIX streams. These streams may represent an underlying POSIX stream or\nbe implemented by Lean code.\n\nBecause standard input, standard output, and standard error are all `IO.FS.Stream`s that can be\noverridden, Lean code may capture and redirect input and output.\n</code>",
 "2898": "<code>FS.Stream</code>",
 "2897":
 "<code>MonadFinally.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">Monads that provide the ability to ensure an action happens, regardless of exceptions or other\nfailures.\n\n`MonadFinally.tryFinally'` is used to desugar `try ... finally ...` syntax.\n</code>",
 "2896": "<code>Type → Type u</code>",
 "2895":
 "<code>IO.withStdin.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] [MonadFinally m] [MonadLiftT BaseIO m] (h : IO.FS.Stream)\n  (x : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Runs an action with the specified stream `h` as standard input, restoring the original standard\ninput stream afterwards.\n</code>",
 "2894":
 "<code>MonadLiftT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} (monadLift : {α : Type u} → m α → n α) :\n  MonadLiftT m n</code>",
 "2893":
 "<code>{α : Type u} → m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "2892":
 "<code>MonadLift.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w}\n  (monadLift : {α : Type u} → m α → n α) : MonadLift m n</code>",
 "2891":
 "<code>autoParam\n  (∀ {α β : Type u} (f : m (α → β)) (x : m α),\n    (do\n        let x_1 ← f\n        x_1 &lt;$&gt; x) =\n      f &lt;*&gt; x)\n  _auto✝</code>",
 "2890":
 "<code>autoParam\n  (∀ {α β : Type u} (f : α → β) (x : m α),\n    (do\n        let y ← x\n        pure (f y)) =\n      f &lt;$&gt; x)\n  _auto✝</code>",
 "289": "<code>AllNonZero (xs : Array Nat) : Prop</code>",
 "2889":
 "<code>autoParam\n  (∀ {α β : Type u} (x : m α) (y : m β),\n    x *&gt; y = do\n      let _ ← x\n      y)\n  _auto✝</code>",
 "2888":
 "<code>autoParam\n  (∀ {α β : Type u} (x : m α) (y : m β),\n    x &lt;* y = do\n      let a ← x\n      let _ ← y\n      pure a)\n  _auto✝</code>",
 "2887":
 "<code>autoParam (∀ {α β : Type u} (x : α) (y : m β), Functor.mapConst x y = Function.const β x &lt;$&gt; y) _auto✝</code>",
 "2886":
 "<code>∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g</code>",
 "2885":
 "<code>∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x</code>",
 "2884": "<code>∀ {α : Type u} (x : m α), id &lt;$&gt; x = x</code>",
 "2883": "<code>β → m γ</code>",
 "2882":
 "<code>∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g</code><span class=\"sep\"></span><code class=\"docstring\">`bind` is associative.\n\nChanging the nesting of `bind` calls while maintaining the order of computations results in an\nequivalent computation. This means that `bind` is not doing more than data-dependent sequencing.\n</code>",
 "2881":
 "<code>∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x</code><span class=\"sep\"></span><code class=\"docstring\">`pure` followed by `bind` is equivalent to function application.\n\nThis means that `pure` really is pure before a `bind` and has no effects.\n</code>",
 "2880":
 "<code>∀ {α β : Type u} (f : m (α → β)) (x : m α),\n  (do\n      let x_1 ← f\n      x_1 &lt;$&gt; x) =\n    f &lt;*&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">A `bind` followed by a functorial map is equivalent to `Applicative` sequencing.\n\nThis means that the effect sequencing from `Monad` and `Applicative` are the same.\n</code>",
 "288":
 "<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>",
 "2879":
 "<code>∀ {α β : Type u} (f : α → β) (x : m α),\n  (do\n      let a ← x\n      pure (f a)) =\n    f &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">A `bind` followed by `pure` composed with a function is equivalent to a functorial map.\n\nThis means that `pure` really is pure after a `bind` and has no effects.\n</code>",
 "2878": "<code>m (β → γ)</code>",
 "2877": "<code>m (α → β)</code>",
 "2876": "<code>m β</code>",
 "2875":
 "<code>LawfulMonad.mk.{u, v} {m : Type u → Type v} [Monad m] [toLawfulApplicative : LawfulApplicative m]\n  (bind_pure_comp :\n    ∀ {α β : Type u} (f : α → β) (x : m α),\n      (do\n          let a ← x\n          pure (f a)) =\n        f &lt;$&gt; x)\n  (bind_map :\n    ∀ {α β : Type u} (f : m (α → β)) (x : m α),\n      (do\n          let x_1 ← f\n          x_1 &lt;$&gt; x) =\n        f &lt;*&gt; x)\n  (pure_bind : ∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x)\n  (bind_assoc : ∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g) :\n  LawfulMonad m</code>",
 "2874":
 "<code>LawfulMonad.mk'.{u, v} (m : Type u → Type v) [Monad m] (id_map : ∀ {α : Type u} (x : m α), id &lt;$&gt; x = x)\n  (pure_bind : ∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x)\n  (bind_assoc : ∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g)\n  (map_const : ∀ {α β : Type u} (x : α) (y : m β), Functor.mapConst x y = Function.const β x &lt;$&gt; y := by intros; rfl)\n  (seqLeft_eq :\n    ∀ {α β : Type u} (x : m α) (y : m β),\n      x &lt;* y = do\n        let a ← x\n        let _ ← y\n        pure a := by\n    intros; rfl)\n  (seqRight_eq :\n    ∀ {α β : Type u} (x : m α) (y : m β),\n      x *&gt; y = do\n        let _ ← x\n        y := by\n    intros; rfl)\n  (bind_pure_comp :\n    ∀ {α β : Type u} (f : α → β) (x : m α),\n      (do\n          let y ← x\n          pure (f y)) =\n        f &lt;$&gt; x := by\n    intros; rfl)\n  (bind_map :\n    ∀ {α β : Type u} (f : m (α → β)) (x : m α),\n      (do\n          let x_1 ← f\n          x_1 &lt;$&gt; x) =\n        f &lt;*&gt; x := by\n    intros; rfl) :\n  LawfulMonad m</code><span class=\"sep\"></span><code class=\"docstring\">An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n</code>",
 "2873": "<code>f (β → γ)</code>",
 "2872":
 "<code>∀ {α β γ : Type u} (x : f α) (g : f (α → β)) (h : f (β → γ)), h &lt;*&gt; (g &lt;*&gt; x) = Function.comp &lt;$&gt; h &lt;*&gt; g &lt;*&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">`seq` is associative.\n\nChanging the nesting of `seq` calls while maintaining the order of computations results in an\nequivalent computation. This means that `seq` is not doing any more than sequencing.\n</code>",
 "2871": "<code>f (α → β)</code>",
 "2870":
 "<code>∀ {α β : Type u} (g : f (α → β)) (x : α), g &lt;*&gt; pure x = (fun h =&gt; h x) &lt;$&gt; g</code><span class=\"sep\"></span><code class=\"docstring\">`pure` after `seq` is equivalent to `Functor.map`.\n\nThis means that `pure` really is pure when occurring just after `seq`.\n</code>",
 "287":
 "<code>two (b : Bool) : if b = true then Unit × Unit else String</code>",
 "2869":
 "<code>∀ {α β : Type u} (g : α → β) (x : α), g &lt;$&gt; pure x = pure (g x)</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a function over the result of `pure` is equivalent to applying the function under `pure`.\n\nThis means that `pure` really is pure with respect to `Functor.map`.\n</code>",
 "2868":
 "<code>∀ {α β : Type u} (g : α → β) (x : f α), pure g &lt;*&gt; x = g &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">`pure` before `seq` is equivalent to `Functor.map`.\n\nThis means that `pure` really is pure when occurring immediately prior to `seq`.\n</code>",
 "2867":
 "<code>∀ {α β : Type u} (x : f α) (y : f β), x *&gt; y = Function.const α id &lt;$&gt; x &lt;*&gt; y</code><span class=\"sep\"></span><code class=\"docstring\">`seqRight` is equivalent to the default implementation. </code>",
 "2866":
 "<code>∀ {α β : Type u} (x : f α) (y : f β), x &lt;* y = Function.const β &lt;$&gt; x &lt;*&gt; y</code><span class=\"sep\"></span><code class=\"docstring\">`seqLeft` is equivalent to the default implementation. </code>",
 "2865":
 "<code>LawfulApplicative.mk.{u, v} {f : Type u → Type v} [Applicative f] [toLawfulFunctor : LawfulFunctor f]\n  (seqLeft_eq : ∀ {α β : Type u} (x : f α) (y : f β), x &lt;* y = Function.const β &lt;$&gt; x &lt;*&gt; y)\n  (seqRight_eq : ∀ {α β : Type u} (x : f α) (y : f β), x *&gt; y = Function.const α id &lt;$&gt; x &lt;*&gt; y)\n  (pure_seq : ∀ {α β : Type u} (g : α → β) (x : f α), pure g &lt;*&gt; x = g &lt;$&gt; x)\n  (map_pure : ∀ {α β : Type u} (g : α → β) (x : α), g &lt;$&gt; pure x = pure (g x))\n  (seq_pure : ∀ {α β : Type u} (g : f (α → β)) (x : α), g &lt;*&gt; pure x = (fun h =&gt; h x) &lt;$&gt; g)\n  (seq_assoc :\n    ∀ {α β γ : Type u} (x : f α) (g : f (α → β)) (h : f (β → γ)), h &lt;*&gt; (g &lt;*&gt; x) = Function.comp &lt;$&gt; h &lt;*&gt; g &lt;*&gt; x) :\n  LawfulApplicative f</code>",
 "2864": "<code>f.{u, v} : Type u → Type v</code>",
 "2863":
 "<code>SeqRight.seqRight.{u, v} {f : Type u → Type v} [self : SeqRight f] {α β : Type u} : f α → (Unit → f β) → f β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the first. This function is usually\ninvoked via the `*&gt;` operator.\n\nGiven `x : f α` and `y : f β`, `x *&gt; y` runs `x`, then runs `y`, and finally returns the result of\n`y`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*&gt;` in identifiers is `seqRight`.</code>",
 "2862":
 "<code>SeqLeft.seqLeft.{u, v} {f : Type u → Type v} [self : SeqLeft f] {α β : Type u} : f α → (Unit → f β) → f α</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the second. This function is usually\ninvoked via the `&lt;*` operator.\n\nGiven `x : f α` and `y : f β`, `x &lt;* y` runs `x`, then runs `y`, and finally returns the result of\n`x`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*` in identifiers is `seqLeft`.</code>",
 "2861":
 "<code>∀ {α β γ : Type u} (g : α → β) (h : β → γ) (x : f α), (h ∘ g) &lt;$&gt; x = h &lt;$&gt; g &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">The `map` implementation preserves function composition.\n</code>",
 "2860":
 "<code>∀ {α : Type u} (x : f α), id &lt;$&gt; x = x</code><span class=\"sep\"></span><code class=\"docstring\">The `map` implementation preserves identity.\n</code>",
 "286":
 "<code>Quot.{u} {α : Sort u} (r : α → α → Prop) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Low-level quotient types. Quotient types coarsen the propositional equality for a type `α`, so that\nterms related by some relation `r` are considered equal in `Quot r`.\n\nSet-theoretically, `Quot r` can seen as the set of equivalence classes of `α` modulo `r`. Functions\nfrom `Quot r` must prove that they respect `r`: to define a function `f : Quot r → β`, it is\nnecessary to provide `f' : α → β` and prove that for all `x : α` and `y : α`, `r x y → f' x = f' y`.\n\n`Quot` is a built-in primitive:\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`.\n\nThe relation `r` is not required to be an equivalence relation; the resulting quotient type's\nequality extends `r` to an equivalence as a consequence of the rules for equality and quotients.\nWhen `r` is an equivalence relation, it can be more convenient to use the higher-level type\n`Quotient`.\n</code>",
 "2859":
 "<code>∀ {α β : Type u}, Functor.mapConst = Functor.map ∘ Function.const β</code><span class=\"sep\"></span><code class=\"docstring\">The `mapConst` implementation is equivalent to the default implementation.\n</code>",
 "2858":
 "<code>LawfulFunctor.mk.{u, v} {f : Type u → Type v} [Functor f]\n  (map_const : ∀ {α β : Type u}, Functor.mapConst = Functor.map ∘ Function.const β)\n  (id_map : ∀ {α : Type u} (x : f α), id &lt;$&gt; x = x)\n  (comp_map : ∀ {α β γ : Type u} (g : α → β) (h : β → γ) (x : f α), (h ∘ g) &lt;$&gt; x = h &lt;$&gt; g &lt;$&gt; x) : LawfulFunctor f</code>",
 "2857":
 "<code>Monad.mk.{u, v} {m : Type u → Type v} [toApplicative : Applicative m] [toBind : Bind m] : Monad m</code>",
 "2856": "<code>α → m β</code>",
 "2855":
 "<code>{α β : Type u} → m α → (α → m β) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "2854":
 "<code>Bind.mk.{u, v} {m : Type u → Type v} (bind : {α β : Type u} → m α → (α → m β) → m β) : Bind m</code>",
 "2853":
 "<code>{α : Type u} → f α → (Unit → f α) → f α</code><span class=\"sep\"></span><code class=\"docstring\">Depending on the `Alternative` instance, collects values or recovers from `failure`s by\nreturning the leftmost success. Can be written using the `&lt;|&gt;` operator syntax.\n</code>",
 "2852":
 "<code>{α : Type u} → f α</code><span class=\"sep\"></span><code class=\"docstring\">Produces an empty collection or recoverable failure.  The `&lt;|&gt;` operator collects values or recovers\nfrom failures. See `Alternative` for more details.\n</code>",
 "2851":
 "<code>Alternative.mk.{u, v} {f : Type u → Type v} [toApplicative : Applicative f] (failure : {α : Type u} → f α)\n  (orElse : {α : Type u} → f α → (Unit → f α) → f α) : Alternative f</code>",
 "2850":
 "<code>Id.{u} (type : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The identity function on types, used primarily for its `Monad` instance.\n\nThe identity monad is useful together with monad transformers to construct monads for particular\npurposes. Additionally, it can be used with `do`-notation in order to use control structures such as\nlocal mutability, `for`-loops, and early returns in code that does not otherwise use monads.\n\nExamples:\n```lean example\ndef containsFive (xs : List Nat) : Bool := Id.run do\n  for x in xs do\n    if x == 5 then return true\n  return false\n```\n\n```lean example\n#eval containsFive [1, 3, 5, 7]\n```\n```output\ntrue\n```\n</code>",
 "285":
 "<code>Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : α × β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.</code>",
 "2849":
 "<code>StateT.{u, v} (σ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a mutable state of type `σ` to a monad.\n\nActions in the resulting monad are functions that take an initial state and return, in `m`, a tuple\nof a value and a state.\n</code>",
 "2848":
 "<code>OptionT.{u, v} (m : Type u → Type v) (α : Type u) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Adds the ability to fail to a monad. Unlike ordinary exceptions, there is no way to signal why a\nfailure occurred.\n</code>",
 "2847": "<code>LenList (n' + 1) α</code>",
 "2846":
 "<code>(square.head.head :: (diagonal (map (fun x =&gt; x.tail) square.tail)).list).length = n' + 1</code>",
 "2845": "<code>LenList (n' + 1) (LenList (n' + 1) α)</code>",
 "2844": "<code>LenList n (LenList n α)</code>",
 "2843":
 "<code>LenList.diagonal.{u} {α : Type u} {n : Nat} (square : LenList n (LenList n α)) : LenList n α</code>",
 "2842":
 "<code>LenList.list_length_eq.{u} {α : Type u} {n : Nat} (xs : LenList n α) : xs.list.length = n</code>",
 "2841": "<code>Unit → LenList n α</code>",
 "2840": "<code>LenList n (α → β)</code>",
 "284":
 "<code>Unit.unit : Unit</code><span class=\"sep\"></span><code class=\"docstring\">The only element of the unit type.\n\nIt can be written as an empty tuple: `()`.\n</code>",
 "2839":
 "<code>{α β : Type u_1} → LenList n (α → β) → (Unit → LenList n α) → LenList n β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "2838":
 "<code>List.length_replicate.{u} {α : Type u} {n : Nat} {a : α} : (List.replicate n a).length = n</code>",
 "2837": "<code>(List.replicate n x).length = n</code>",
 "2836": "<code>List α✝</code>",
 "2835":
 "<code>{α : Type u_1} → α → LenList n α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "2834":
 "<code>{α β : Type u_1} → (α → β) → LenList n α → LenList n β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "2833":
 "<code>List.length_zipWith.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {l₁ : List α}\n  {l₂ : List β} : (List.zipWith f l₁ l₂).length = min l₁.length l₂.length</code>",
 "2832": "<code>list✝¹.length = n</code>",
 "2831": "<code>List β</code>",
 "2830": "<code>list✝¹.length = n</code>",
 "283":
 "<code><span class=\"literal string\">\"number\"</span> : String</code>",
 "2829": "<code>Type ?u.2815</code>",
 "2828": "<code>(List.zipWith f xs.list ys.list).length = n</code>",
 "2827":
 "<code>List.zipWith.{u, v, w} {α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (xs : List α) (ys : List β) : List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.\n\n`O(min |xs| |ys|)`.\n\nExamples:\n* `[1, 2].zipWith (· + ·) [5, 6] = [6, 8]`\n* `[1, 2, 3].zipWith (· + ·) [5, 6, 10] = [6, 8, 13]`\n* `[].zipWith (· + ·) [5, 6] = []`\n* `[x₁, x₂, x₃].zipWith f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n</code>",
 "2826": "<code>List γ</code>",
 "2825": "<code>LenList n β</code>",
 "2824": "<code>α → β → γ</code>",
 "2823":
 "<code>LenList.zipWith.{u, u_1} {α β : Type u} {γ : Type u_1} {n : Nat} (f : α → β → γ) (xs : LenList n α) (ys : LenList n β) :\n  LenList n γ</code>",
 "2822":
 "<code>List.length_map.{u_1, u_2} {α : Type u_1} {β : Type u_2} {as : List α} (f : α → β) : (List.map f as).length = as.length</code>",
 "2821": "<code>list✝.length = n</code>",
 "2820": "<code>list✝.length = n</code>",
 "282": "<code><span class=\"literal string\">\"Wrong\"</span> : String</code>",
 "2819": "<code>(List.map f xs.list).length = n</code>",
 "2818": "<code>List β</code>",
 "2817": "<code>LenList n α</code>",
 "2816":
 "<code>LenList.map.{u} {α β : Type u} {n : Nat} (f : α → β) (xs : LenList n α) : LenList n β</code>",
 "2815": "<code>(head✝ :: xs').length = n + 1</code>",
 "2814":
 "<code>LenList.tail.{u} {α : Type u} {n : Nat} (xs : LenList (n + 1) α) : LenList n α</code>",
 "2813": "<code>list✝ = []</code>",
 "2812": "<code>list✝.length = n + 1</code>",
 "2811": "<code>List α</code>",
 "2810":
 "<code>LenList.mk.{u} {length : Nat} {α : Type u} (list : List α) (lengthOk : list.length = length) : LenList length α</code>",
 "281": "<code><span class=\"literal string\">\"there\"</span> : String</code>",
 "2809": "<code>{ list := list✝, lengthOk := lengthOk✝ }.list = []</code>",
 "2808": "<code>list✝.length = n + 1</code>",
 "2807": "<code>xs.list = []</code>",
 "2806":
 "<code>List.head.{u} {α : Type u} (as : List α) : as ≠ [] → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of a non-empty list.\n</code>",
 "2805": "<code>LenList (n + 1) α</code>",
 "2804":
 "<code>LenList.head.{u} {α : Type u} {n : Nat} (xs : LenList (n + 1) α) : α</code>",
 "2803":
 "<code>LenList.lengthOk.{u} {length : Nat} {α : Type u} (self : LenList length α) : self.list.length = length</code>",
 "2802":
 "<code>LenList.list.{u} {length : Nat} {α : Type u} (self : LenList length α) : List α</code>",
 "2801": "<code>LenList.{u} (length : Nat) (α : Type u) : Type u</code>",
 "2800":
 "<code>Applicative.mk.{u, v} {f : Type u → Type v} [toFunctor : Functor f] [toPure : Pure f] [toSeq : Seq f]\n  [toSeqLeft : SeqLeft f] [toSeqRight : SeqRight f] : Applicative f</code>",
 "280": "<code><span class=\"literal string\">\"Hello\"</span> : String</code>",
 "28": "<code>Even.plusTwo {n : Nat} : Even n → Even (n + 2)</code>",
 "2799":
 "<code>LawfulApplicative.{u, v} (f : Type u → Type v) [Applicative f] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An applicative functor satisfies the laws of an applicative functor.\n\nThe `Applicative` class contains the operations of an applicative functor, but does not require that\ninstances prove they satisfy the laws of an applicative functor. A `LawfulApplicative` instance\nincludes proofs that the laws are satisfied.\n\nBecause `Applicative` instances may provide optimized implementations of `seqLeft` and `seqRight`,\n`LawfulApplicative` instances must also prove that the optimized implementation is equivalent to the\nstandard implementation.\n</code>",
 "2798": "<code>{α β : Type u} → f α → (Unit → f β) → f β</code>",
 "2797":
 "<code>{α β : Type u} → f α → (Unit → f β) → f β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the first. This function is usually\ninvoked via the `*&gt;` operator.\n\nGiven `x : f α` and `y : f β`, `x *&gt; y` runs `x`, then runs `y`, and finally returns the result of\n`y`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*&gt;` in identifiers is `seqRight`.</code>",
 "2796":
 "<code>SeqRight.mk.{u, v} {f : Type u → Type v} (seqRight : {α β : Type u} → f α → (Unit → f β) → f β) : SeqRight f</code>",
 "2795": "<code>{α β : Type u} → f α → (Unit → f β) → f α</code>",
 "2794": "<code>f β</code>",
 "2793":
 "<code>{α β : Type u} → f α → (Unit → f β) → f α</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the second. This function is usually\ninvoked via the `&lt;*` operator.\n\nGiven `x : f α` and `y : f β`, `x &lt;* y` runs `x`, then runs `y`, and finally returns the result of\n`x`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*` in identifiers is `seqLeft`.</code>",
 "2792":
 "<code>SeqLeft.mk.{u, v} {f : Type u → Type v} (seqLeft : {α β : Type u} → f α → (Unit → f β) → f α) : SeqLeft f</code>",
 "2791": "<code>{α β : Type u} → f (α → β) → (Unit → f α) → f β</code>",
 "2790":
 "<code>{α β : Type u} → f (α → β) → (Unit → f α) → f β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "279":
 "<code>PUnit.{u} : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">The canonical universe-polymorphic type with just one element.\n\nIt should be used in contexts that require a type to be universe polymorphic, thus disallowing\n`Unit`.\n</code>",
 "2789":
 "<code>Seq.mk.{u, v} {f : Type u → Type v} (seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β) : Seq f</code>",
 "2788":
 "<code>Seq.seq.{u, v} {f : Type u → Type v} [self : Seq f] {α β : Type u} : f (α → β) → (Unit → f α) → f β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "2787": "<code>{α : Type u} → α → f α</code>",
 "2786": "<code>Sort ?u.10046</code>",
 "2785":
 "<code>{α : Type u} → α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "2784":
 "<code>Pure.mk.{u, v} {f : Type u → Type v} (pure : {α : Type u} → α → f α) : Pure f</code>",
 "2783": "<code>{α β : Type u} → α → f β → f α</code>",
 "2782": "<code>Sort ?u.9005</code>",
 "2781":
 "<code>{α β : Type u} → α → f β → f α</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a constant function.\n\nGiven `a : α` and `v : f α`, `mapConst a v` is equivalent to `Function.const _ a &lt;$&gt; v`. For some\nfunctors, this can be implemented more efficiently; for all other functors, the default\nimplementation may be used.\n</code>",
 "2780": "<code>{α β : Type u} → (α → β) → f α → f β</code>",
 "278": "<code>LengthList.{u} (α : Type u) : Nat → Type u</code>",
 "2779":
 "<code>Functor.mapConst.{u, v} {f : Type u → Type v} [self : Functor f] {α β : Type u} : α → f β → f α</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a constant function.\n\nGiven `a : α` and `v : f α`, `mapConst a v` is equivalent to `Function.const _ a &lt;$&gt; v`. For some\nfunctors, this can be implemented more efficiently; for all other functors, the default\nimplementation may be used.\n</code>",
 "2778":
 "<code>{α β : Type u} → (α → β) → f α → f β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "2777":
 "<code>Functor.mk.{u, v} {f : Type u → Type v} (map : {α β : Type u} → (α → β) → f α → f β)\n  (mapConst : {α β : Type u} → α → f β → f α) : Functor f</code>",
 "2776":
 "<code>LawfulFunctor.{u, v} (f : Type u → Type v) [Functor f] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A functor satisfies the functor laws.\n\nThe `Functor` class contains the operations of a functor, but does not require that instances\nprove they satisfy the laws of a functor. A `LawfulFunctor` instance includes proofs that the laws\nare satisfied. Because `Functor` instances may provide optimized implementations of `mapConst`,\n`LawfulFunctor` instances must also prove that the optimized implementation is equivalent to the\nstandard implementation.\n</code>",
 "2775": "<code>Sort ?u.4968</code>",
 "2774": "<code>Sort ?u.4965</code>",
 "2773": "<code>Sort ?u.4964</code>",
 "2772": "<code>β → γ</code>",
 "2771": "<code>f α</code>",
 "2770":
 "<code>Alternative.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An `Alternative` functor is an `Applicative` functor that can \"fail\" or be \"empty\"\nand a binary operation `&lt;|&gt;` that “collects values” or finds the “left-most success”.\n\nImportant instances include\n* `Option`, where `failure := none` and `&lt;|&gt;` returns the left-most `some`.\n* Parser combinators typically provide an `Applicative` instance for error-handling and\n  backtracking.\n\nError recovery and state can interact subtly. For example, the implementation of `Alternative` for `OptionT (StateT σ Id)` keeps modifications made to the state while recovering from failure, while `StateT σ (OptionT Id)` discards them.\n</code>",
 "277": "<code>S : Type</code>",
 "2769":
 "<code>Seq.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `&lt;*&gt;` operator is overloaded using the function `Seq.seq`.\n\nWhile `&lt;$&gt;` from the class `Functor` allows an ordinary function to be mapped over its contents,\n`&lt;*&gt;` allows a function that's “inside” the functor to be applied. When thinking about `f` as\npossible side effects, this captures evaluation order: `seq` arranges for the effects that produce\nthe function to occur prior to those that produce the argument value.\n\nFor most applications, `Applicative` or `Monad` should be used rather than `Seq` itself.\n</code>",
 "2768":
 "<code>SeqRight.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `*&gt;` operator is overloaded using `seqRight`.\n\nWhen thinking about `f` as potential side effects, `*&gt;` evaluates first the left and then the right\nargument for their side effects, discarding the value of the left argument and returning the value\nof the right argument.\n\nFor most applications, `Applicative` or `Monad` should be used rather than `SeqLeft` itself.\n</code>",
 "2767":
 "<code>SeqLeft.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `&lt;*` operator is overloaded using `seqLeft`.\n\nWhen thinking about `f` as potential side effects, `&lt;*` evaluates first the left and then the right\nargument for their side effects, discarding the value of the right argument and returning the value\nof the left argument.\n\nFor most applications, `Applicative` or `Monad` should be used rather than `SeqLeft` itself.\n</code>",
 "2766":
 "<code>Bind.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `&gt;&gt;=` operator is overloaded via instances of `bind`.\n\n`Bind` is typically used via `Monad`, which extends it.\n</code>",
 "2765":
 "<code>Applicative.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An [applicative functor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=monads-and-do) is more powerful than a `Functor`, but\nless powerful than a `Monad`.\n\nApplicative functors capture sequencing of effects with the `&lt;*&gt;` operator, overloaded as `seq`, but\nnot data-dependent effects. The results of earlier computations cannot be used to control later\neffects.\n\nApplicative functors should satisfy four laws. Instances of `Applicative` are not required to prove\nthat they satisfy these laws, which are part of the `LawfulApplicative` class.\n</code>",
 "2764":
 "<code>Functor.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A functor in the sense used in functional programming, which means a function `f : Type u → Type v`\nhas a way of mapping a function over its contents. This `map` operator is written `&lt;$&gt;`, and\noverloaded via `Functor` instances.\n\nThis `map` function should respect identity and function composition. In other words, for all terms\n`v : f α`, it should be the case that:\n\n * `id &lt;$&gt; v = v`\n\n * For all functions `h : β → γ` and `g : α → β`, `(h ∘ g) &lt;$&gt; v = h &lt;$&gt; g &lt;$&gt; v`\n\nWhile all `Functor` instances should live up to these requirements, they are not required to _prove_\nthat they do. Proofs may be required or provided via the `LawfulFunctor` class.\n\nAssuming that instances are lawful, this definition corresponds to the category-theoretic notion of\n[functor](https://en.wikipedia.org/wiki/Functor) in the special case where the category is the\ncategory of types and functions between them.\n</code>",
 "2763":
 "<code><span class=\"literal string\">\"&lt;|||&gt;\"</span> : String</code>",
 "2762": "<code>emptyIsEmpty.{u_1} {α : Type u_1} : IsEmpty []</code>",
 "2761": "<code>IsEmpty.{u_1} {α : Type u_1} (xs : List α) : Prop</code>",
 "2760":
 "<code>Nat.le.refl {n : Nat} : n.le n</code><span class=\"sep\"></span><code class=\"docstring\">Non-strict inequality is reflexive: `n ≤ n` </code>",
 "276": "<code>S.f2 (self : S) : β</code>",
 "2759":
 "<code>Nat.le (n : Nat) : Nat → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Non-strict, or weak, inequality of natural numbers, usually accessed via the `≤` operator.\n</code>",
 "2758":
 "<code>Nat.le.step {n m : Nat} : n.le m → n.le m.succ</code><span class=\"sep\"></span><code class=\"docstring\">If `n ≤ m`, then `n ≤ m + 1`. </code>",
 "2757": "<code>TSyntax `tactic</code>",
 "2756":
 "<code>Lean.Parser.Category.tactic : Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n</code>",
 "2755": "<code><span class=\"literal string\">\"rep\"</span> : String</code>",
 "2754":
 "<code>Lean.Elab.Tactic.TacticM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The tactic monad, which extends the term elaboration monad `TermElabM` with state that contains the\ncurrent goals (`Lean.Elab.Tactic.State`, accessible via `MonadStateOf`) and local information about\nthe current tactic's name and whether error recovery is enabled (`Lean.Elab.Tactic.Context`,\naccessible via `MonadReaderOf`).\n</code>",
 "2753": "<code class=\"docstring\">`norm_cast` tactic in `conv` mode. </code>",
 "2752":
 "<code class=\"docstring\">`rfl` closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting). </code>",
 "2751":
 "<code class=\"docstring\">`trace_state` prints the current goal state. </code>",
 "2750":
 "<code class=\"docstring\">`conv =&gt; cs` runs `cs` in sequence on the target `t`,\nresulting in `t'`, which becomes the new target subgoal. </code>",
 "275": "<code>S.f1 (self : S) : α</code>",
 "2749":
 "<code class=\"docstring\">Executes the given tactic block without converting `conv` goal into a regular goal. </code>",
 "2748":
 "<code class=\"docstring\">Focuses, converts the `conv` goal `⊢ lhs` into a regular goal `⊢ lhs = rhs`, and then executes the given tactic block. </code>",
 "2747":
 "<code class=\"docstring\">Executes the given conv block without converting regular goal into a `conv` goal. </code>",
 "2746":
 "<code class=\"docstring\">The `apply thm` conv tactic is the same as `apply thm` the tactic.\nThere are no restrictions on `thm`, but strange results may occur if `thm`\ncannot be reasonably interpreted as proving one equality from a list of others. </code>",
 "2745":
 "<code class=\"docstring\">`rw [thm]` rewrites the target using `thm`. See the `rw` tactic for more information. </code>",
 "2744":
 "<code class=\"docstring\">`change t'` replaces the target `t` with `t'`,\nassuming `t` and `t'` are definitionally equal. </code>",
 "2743":
 "<code class=\"docstring\">`simp_match` simplifies match expressions. For example,\n```\nmatch [a, b] with\n| [] =&gt; 0\n| hd :: tl =&gt; hd\n```\nsimplifies to `a`. </code>",
 "2742": "<code>Nat.sub_self (n : Nat) : n - n = 0</code>",
 "2741":
 "<code class=\"docstring\">`dsimp` is the definitional simplifier in `conv`-mode. It differs from `simp` in that it only\napplies theorems that hold by reflexivity.\n\nExamples:\n\n```lean\nexample (a : Nat): (0 + 0) = a - a := by\n  conv =&gt;\n    lhs\n    dsimp\n    rw [← Nat.sub_self a]\n```\n</code>",
 "2740":
 "<code class=\"docstring\">`simp [thm]` performs simplification using `thm` and marked `@[simp]` lemmas.\nSee the `simp` tactic for more information. </code>",
 "274": "<code>x : S</code>",
 "2739":
 "<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n\nThis is the `conv` version of the `unfold` tactic.\n</code>",
 "2738":
 "<code class=\"docstring\">`delta id1 id2 ...` unfolds all occurrences of `id1`, `id2`, ... in the target.\nLike the `delta` tactic, this ignores any definitional equations and uses\nprimitive delta-reduction instead, which may result in leaking implementation details.\nUsers should prefer `unfold` for unfolding definitions. </code>",
 "2737":
 "<code class=\"docstring\">Expands let-declarations and let-variables. </code>",
 "2736":
 "<code class=\"docstring\">Puts term in normal form, this tactic is meant for debugging purposes only. </code>",
 "2735": "<code>?m.29</code>",
 "2734": "<code>?m.29 → ?m.23</code>",
 "2733": "<code>?m.19 → ?m.8</code>",
 "2732":
 "<code class=\"docstring\">Reduces the target to Weak Head Normal Form. This reduces definitions\nin \"head position\" until a constructor is exposed. For example, `List.map f [a, b, c]`\nweak head normalizes to `f a :: List.map f [b, c]`. </code>",
 "2731":
 "<code class=\"docstring\">`right` traverses into the right argument. Synonym for `rhs`. </code>",
 "2730":
 "<code class=\"docstring\">`left` traverses into the left argument. Synonym for `lhs`. </code>",
 "273": "<code>S.mk (f1 : α) (f2 : β) : S</code>",
 "2729":
 "<code class=\"docstring\">`args` traverses into all arguments. Synonym for `congr`. </code>",
 "2728": "<code>Sort ?u.9238</code>",
 "2727":
 "<code class=\"docstring\">`ext x` traverses into a binder (a `fun x =&gt; e` or `∀ x, e` expression)\nto target `e`, introducing name `x` in the process. </code>",
 "2726":
 "<code class=\"docstring\">* `pattern pat` traverses to the first subterm of the target that matches `pat`.\n* `pattern (occs := *) pat` traverses to every subterm of the target that matches `pat`\n  which is not contained in another match of `pat`. It generates one subgoal for each matching\n  subterm.\n* `pattern (occs := 1 2 4) pat` matches occurrences `1, 2, 4` of `pat` and produces three subgoals.\n  Occurrences are numbered left to right from the outside in.\n\nNote that skipping an occurrence of `pat` will traverse inside that subexpression, which means\nit may find more matches and this can affect the numbering of subsequent pattern matches.\nFor example, if we are searching for `f _` in `f (f a) = f b`:\n* `occs := 1 2` (and `occs := *`) returns `| f (f a)` and `| f b`\n* `occs := 2` returns `| f a`\n* `occs := 2 3` returns `| f a` and `| f b`\n* `occs := 1 3` is an error, because after skipping `f b` there is no third match.\n</code>",
 "2725":
 "<code class=\"docstring\">`enter [arg, ...]` is a compact way to describe a path to a subterm.\nIt is a shorthand for other conv tactics as follows:\n* `enter [i]` is equivalent to `arg i`.\n* `enter [@i]` is equivalent to `arg @i`.\n* `enter [x]` (where `x` is an identifier) is equivalent to `ext x`.\n* `enter [in e]` (where `e` is a term) is equivalent to `pattern e`.\n  Occurrences can be specified with `enter [in (occs := ...) e]`.\nFor example, given the target `f (g a (fun x =&gt; x b))`, `enter [1, 2, x, 1]`\nwill traverse to the subterm `b`. </code>",
 "2724":
 "<code class=\"docstring\">Performs one step of \"congruence\", which takes a term and produces\nsubgoals for all the function arguments. For example, if the target is `f x y` then\n`congr` produces two subgoals, one for `x` and one for `y`. </code>",
 "2723":
 "<code class=\"docstring\">Traverses into the function of a (unary) function application.\nFor example, `| f a b` turns into `| f a`. (Use `arg 0` to traverse into `f`.)  </code>",
 "2722":
 "<code class=\"docstring\">Traverses into the right subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the last argument.\nIt is a synonym for `arg -1`.\n</code>",
 "2721":
 "<code class=\"docstring\">`· conv` focuses on the main conv goal and tries to solve it using `s`. </code>",
 "2720":
 "<code class=\"docstring\">`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n</code>",
 "272": "<code>f : α → β</code>",
 "2719":
 "<code class=\"docstring\">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. </code>",
 "2718":
 "<code class=\"docstring\">`done` succeeds iff there are no goals remaining. </code>",
 "2717":
 "<code class=\"docstring\">`(convs)` runs the `convs` in sequence on the current list of targets.\nThis is pure grouping with no added effects. </code>",
 "2716":
 "<code class=\"docstring\">`{ convs }` runs the list of `convs` on the current target, and any subgoals that\nremain are trivially closed by `skip`. </code>",
 "2715":
 "<code class=\"docstring\">`repeat convs` runs the sequence `convs` repeatedly until it fails to apply. </code>",
 "2714":
 "<code class=\"docstring\">`tac &lt;;&gt; tac'` runs `tac` on the main goal and `tac'` on each produced goal, concatenating all goals\nproduced by `tac'`.\n</code>",
 "2713":
 "<code class=\"docstring\">`first | conv | ...` runs each `conv` until one succeeds, or else fails. </code>",
 "2712":
 "<code class=\"docstring\">`intro` traverses into binders. Synonym for `ext`. </code>",
 "2711":
 "<code class=\"docstring\">`rw [rules]` applies the given list of rewrite rules to the target.\nSee the `rw` tactic for more information. </code>",
 "2710":
 "<code class=\"docstring\">* `arg i` traverses into the `i`'th argument of the target. For example if the\n  target is `f a b c d` then `arg 1` traverses to `a` and `arg 3` traverses to `c`.\n  The index may be negative; `arg -1` traverses into the last argument,\n  `arg -2` into the second-to-last argument, and so on.\n* `arg @i` is the same as `arg i` but it counts all arguments instead of just the\n  explicit arguments.\n* `arg 0` traverses into the function. If the target is `f a b c d`, `arg 0` traverses into `f`. </code>",
 "271":
 "<code>IO.print.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it to the current standard\noutput (as determined by `IO.getStdout`).\n</code>",
 "2709":
 "<code class=\"docstring\">Traverses into the left subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the second to last argument.\nIt is a synonym for `arg -2`.\n</code>",
 "2708":
 "<code>Std.Do.SPred.entails.trans.{u} {σs : List (Type u)} {P Q R : Std.Do.SPred σs} : (P ⊢ₛ Q) → (Q ⊢ₛ R) → P ⊢ₛ R</code>",
 "2707":
 "<code>Std.Do.SPred.mp.{u} {σs : List (Type u)} {P Q R : Std.Do.SPred σs} (h₁ : P ⊢ₛ Q → R) (h₂ : P ⊢ₛ Q) : P ⊢ₛ R</code>",
 "2706":
 "<code class=\"docstring\">`mpure` moves a pure hypothesis from the stateful context into the pure context.\n```lean\nexample (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by\n  mintro Hφ\n  mpure Hφ\n  mexact (ψ Hφ)\n```\n</code>",
 "2705": "<code>Sort ?u.78638</code>",
 "2704": "<code>φ</code>",
 "2703":
 "<code class=\"docstring\">`mspecialize_pure` is like `mspecialize`, but it specializes a hypothesis from the\n*pure* context with hypotheses from either the pure or stateful context or pure terms.\n```lean\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by\n  mintro HQ\n  mspecialize_pure (hΨ (y + 1)) hP HQ =&gt; HΨ\n  mexact HΨ\n```\n</code>",
 "2702":
 "<code class=\"docstring\">`mspecialize` is like `specialize`, but operating on a stateful `Std.Do.SPred` goal.\nIt specializes a hypothesis from the stateful context with hypotheses from either the pure\nor stateful context or pure terms.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mspecialize HPQ HP\n  mexact HPQ\n\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by\n  mintro HQ HΨ\n  mspecialize HΨ (y + 1) hP HQ\n  mexact HΨ\n```\n</code>",
 "2701":
 "<code class=\"docstring\">`mreplace` is like `replace`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HPQ\n```\n</code>",
 "2700":
 "<code class=\"docstring\">`mhave` is like `have`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HQ\n```\n</code>",
 "270": "<code>ABC.toNat : ABC → Nat</code>",
 "27": "<code>Even.zero : Even 0</code>",
 "2699":
 "<code class=\"docstring\">Duplicate a stateful `Std.Do.SPred` hypothesis. </code>",
 "2698":
 "<code class=\"docstring\">`mclear` is like `clear`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q → Q := by\n  mintro HP\n  mintro HQ\n  mclear HP\n  mexact HQ\n```\n</code>",
 "2697":
 "<code class=\"docstring\">`mexfalso` is like `exfalso`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by\n  mintro HP\n  mexfalso\n  mexact HP\n```\n</code>",
 "2696":
 "<code class=\"docstring\">`mpure_intro` operates on a stateful `Std.Do.SPred` goal of the form `P ⊢ₛ ⌜φ⌝`.\nIt leaves the stateful proof mode (thereby discarding `P`), leaving the regular goal `φ`.\n```lean\ntheorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by\n  mpure_intro\n  exact True.intro\n```\n</code>",
 "2695":
 "<code class=\"docstring\">`mexists` is like `exists`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mexists 42\n```\n</code>",
 "2694":
 "<code class=\"docstring\">`mright` is like `right`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by\n  mintro HP\n  mright\n  mexact HP\n```\n</code>",
 "2693":
 "<code class=\"docstring\">`mleft` is like `left`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by\n  mintro HP\n  mleft\n  mexact HP\n```\n</code>",
 "2692":
 "<code class=\"docstring\">`mconstructor` is like `constructor`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by\n  mintro HQ\n  mconstructor &lt;;&gt; mexact HQ\n```\n</code>",
 "2691":
 "<code class=\"docstring\">Like `refine`, but operating on stateful `Std.Do.SPred` goals.\n```lean\nexample (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrefine ⟨HP, HR⟩\n\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mrefine ⟨⌜42⌝, H⟩\n```\n</code>",
 "2690":
 "<code class=\"docstring\">`massumption` is like `assumption`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : Q ⊢ₛ P → Q := by\n  mintro _ _\n  massumption\n```\n</code>",
 "269": "<code>abcs : List ABC</code>",
 "2689":
 "<code class=\"docstring\">`mexact` is like `exact`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q := by\n  mstart\n  mintro HQ\n  mexact HQ\n```\n</code>",
 "2688":
 "<code class=\"docstring\">Like `rcases`, but operating on stateful `Std.Do.SPred` goals.\nExample: Given a goal `h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R`,\n`mcases h with ⟨-, ⟨hq | hr⟩, hqr⟩` will yield two goals:\n`(hq : Q, hqr : Q → R) ⊢ₛ R` and `(hr : R) ⊢ₛ R`.\n\nThat is, `mcases h with pat` has the following semantics, based on `pat`:\n* `pat=□h'` renames `h` to `h'` in the stateful context, regardless of whether `h` is pure\n* `pat=⌜h'⌝` introduces `h' : φ`  to the pure local context if `h : ⌜φ⌝`\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`)\n* `pat=h'` is like `pat=⌜h'⌝` if `h` is pure\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`), otherwise it is like `pat=□h'`.\n* `pat=_` renames `h` to an inaccessible name\n* `pat=-` discards `h`\n* `⟨pat₁, pat₂⟩` matches on conjunctions and existential quantifiers and recurses via\n  `pat₁` and `pat₂`.\n* `⟨pat₁ | pat₂⟩` matches on disjunctions, matching the left alternative via `pat₁` and the right\n  alternative via `pat₂`.\n</code>",
 "2687": "<code>List (Type u_1)</code>",
 "2686": "<code>Sort ?u.76695</code>",
 "2685": "<code>σ</code>",
 "2684": "<code>Sort ?u.75641</code>",
 "2683": "<code>φᵢ</code>",
 "2682":
 "<code class=\"docstring\">`mframe` infers which hypotheses from the stateful context can be moved into the pure context.\nThis is useful because pure hypotheses \"survive\" the next application of modus ponens\n(`Std.Do.SPred.mp`) and transitivity (`Std.Do.SPred.entails.trans`).\n\nIt is used as part of the `mspec` tactic.\n\n```lean\nexample (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by\n  mintro _\n  mframe\n  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/\n  mcases h with hP\n  mexact h\n```\n</code>",
 "2681": "<code>?m.50</code>",
 "2680":
 "<code class=\"docstring\">`mrename_i` is like `rename_i`, but names inaccessible stateful hypotheses in a `Std.Do.SPred` goal.\n</code>",
 "268": "<code>abc : List ABC</code>",
 "2679":
 "<code class=\"docstring\">`mspec_no_simp $spec` first tries to decompose `Bind.bind`s before applying `$spec`.\nThis variant of `mspec_no_simp` does not; `mspec_no_bind $spec` is defined as\n```\ntry with_reducible mspec_no_bind Std.Do.Spec.bind\nmspec_no_bind $spec\n```\n</code>",
 "2678": "<code>?m.15 ?m.13</code>",
 "2677":
 "<code class=\"docstring\">Leaves the stateful proof mode of `Std.Do.SPred`, tries to eta-expand through all definitions\nrelated to the logic of the `Std.Do.SPred` and gently simplifies the resulting pure Lean\nproposition. This is often the right thing to do after `mvcgen` in order for automation to prove\nthe goal.\n</code>",
 "2676":
 "<code class=\"docstring\">Stops the stateful proof mode of `Std.Do.SPred`.\nThis will simply forget all the names given to stateful hypotheses and pretty-print\na bit differently.\n</code>",
 "2675":
 "<code class=\"docstring\">Like `intro`, but introducing stateful hypotheses into the stateful context of the `Std.Do.SPred`\nproof mode.\nThat is, given a stateful goal `(hᵢ : Hᵢ)* ⊢ₛ P → T`, `mintro h` transforms\ninto `(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T`.\n\nFurthermore, `mintro ∀s` is like `intro s`, but preserves the stateful goal.\nThat is, `mintro ∀s` brings the topmost state variable `s:σ` in scope and transforms\n`(hᵢ : Hᵢ)* ⊢ₛ T` (where the entailment is in `Std.Do.SPred (σ::σs)`) into\n`(hᵢ : Hᵢ s)* ⊢ₛ T s` (where the entailment is in `Std.Do.SPred σs`).\n\nBeyond that, `mintro` supports the full syntax of `mcases` patterns\n(`mintro pat = (mintro h; mcases h with pat`), and can perform multiple\nintroductions in sequence.\n</code>",
 "2674":
 "<code class=\"docstring\">Start the stateful proof mode of `Std.Do.SPred`.\nThis will transform a stateful goal of the form `H ⊢ₛ T` into `⊢ₛ H → T`\nupon which `mintro` can be used to re-introduce `H` and give it a name.\nIt is often more convenient to use `mintro` directly, which will\ntry `mstart` automatically if necessary.\n</code>",
 "2673": "<code>Option Nat</code>",
 "2672": "<code>Lean.Elab.Tactic.Do.VCGen.Config : Type</code>",
 "2671": "<code>instBEqFloat : BEq Float</code>",
 "2670":
 "<code class=\"docstring\">`mspec` is an `apply`-like tactic that applies a Hoare triple specification to the target of the\nstateful goal.\n\nGiven a stateful goal `H ⊢ₛ wp⟦prog⟧ Q'`, `mspec foo_spec` will instantiate\n`foo_spec : ... → ⦃P⦄ foo ⦃Q⦄`, match `foo` against `prog` and produce subgoals for\nthe verification conditions `?pre : H ⊢ₛ P` and `?post : Q ⊢ₚ Q'`.\n\n* If `prog = x &gt;&gt;= f`, then `mspec Specs.bind` is tried first so that `foo` is matched against `x`\n  instead. Tactic `mspec_no_bind` does not attempt to do this decomposition.\n* If `?pre` or `?post` follow by `.rfl`, then they are discharged automatically.\n* `?post` is automatically simplified into constituent `⊢ₛ` entailments on\n  success and failure continuations.\n* `?pre` and `?post.*` goals introduce their stateful hypothesis under an inaccessible name.\n  You can give it a name with the `mrename_i` tactic.\n* Any uninstantiated MVar arising from instantiation of `foo_spec` becomes a new subgoal.\n* If the target of the stateful goal looks like `fun s =&gt; _` then `mspec` will first `mintro ∀s`.\n* If `P` has schematic variables that can be instantiated by doing `mintro ∀s`, for example\n  `foo_spec : ∀(n:Nat), ⦃fun s =&gt; ⌜n = s⌝⦄ foo ⦃Q⦄`, then `mspec` will do `mintro ∀s` first to\n  instantiate `n = s`.\n* Right before applying the spec, the `mframe` tactic is used, which has the following effect:\n  Any hypothesis `Hᵢ` in the goal `h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T` that is\n  pure (i.e., equivalent to some `⌜φᵢ⌝`) will be moved into the pure context as `hᵢ:φᵢ`.\n\nAdditionally, `mspec` can be used without arguments or with a term argument:\n\n* `mspec` without argument will try and look up a spec for `x` registered with `@[spec]`.\n* `mspec (foo_spec blah ?bleh)` will elaborate its argument as a term with expected type\n  `⦃?P⦄ x ⦃?Q⦄` and introduce `?bleh` as a subgoal.\n  This is useful to pass an invariant to e.g., `Specs.forIn_list` and leave the inductive step\n  as a hole.\n</code>",
 "267": "<code>ABC.c : ABC</code>",
 "2669":
 "<code>Std.Do.SPred.{u} (σs : List (Type u)) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A predicate indexed by a list of states.\n```\nexample : SPred [Nat, Bool] = (Nat → Bool → ULift Prop) := rfl\n```\n</code>",
 "2668":
 "<code class=\"docstring\">Theorems tagged with the `spec` attribute are used by the `mspec` and `mvcgen` tactics.\n\n* When used on a theorem `foo_spec : Triple (foo a b c) P Q`, then `mspec` and `mvcgen` will use\n  `foo_spec` as a specification for calls to `foo`.\n* Otherwise, when used on a definition that `@[simp]` would work on, it is added to the internal\n  simp set of `mvcgen` that is used within `wp⟦·⟧` contexts to simplify match discriminants and\n  applications of constants.\n</code>",
 "2667":
 "<code class=\"docstring\">`mvcgen` will break down a Hoare triple proof goal like `⦃P⦄ prog ⦃Q⦄` into verification conditions,\nprovided that all functions used in `prog` have specifications registered with `@[spec]`.\n\n### Verification Conditions and specifications\n\nA verification condition is an entailment in the stateful logic of `Std.Do.SPred`\nin which the original program `prog` no longer occurs.\nVerification conditions are introduced by the `mspec` tactic; see the `mspec` tactic for what they\nlook like.\nWhen there's no applicable `mspec` spec, `mvcgen` will try and rewrite an application\n`prog = f a b c` with the simp set registered via `@[spec]`.\n\n### Features\n\nWhen used like `mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat]`, `mvcgen` will additionally\n\n* add a Hoare triple specification `foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄` to `spec` set for a\n  function `foo` occurring in `prog`,\n* unfold a definition `def bar_def ... := ...` in `prog`,\n* unfold any method of the `instBEqFloat : BEq Float` instance in `prog`.\n* it will no longer substitute away `let`-expressions that occur at most once in `P`, `Q` or `prog`.\n\n### Config options\n\n`+noLetElim` is just one config option of many. Check out `Lean.Elab.Tactic.Do.VCGen.Config` for all\noptions. Of particular note is `stepLimit = some 42`, which is useful for bisecting bugs in\n`mvcgen` and tracing its execution.\n\n### Extended syntax\n\nOften, `mvcgen` will be used like this:\n```\nmvcgen [...]\ncase inv1 =&gt; by exact I1\ncase inv2 =&gt; by exact I2\nall_goals (mleave; try grind)\n```\nThere is special syntax for this:\n```\nmvcgen [...] invariants\n· I1\n· I2\nwith grind\n```\nWhen `I1` and `I2` need to refer to inaccessibles (`mvcgen` will introduce a lot of them for program\nvariables), you can use case label syntax:\n```\nmvcgen [...] invariants\n| inv1 _ acc _ =&gt; I1 acc\n| _ =&gt; I2\nwith grind\n```\nThis is more convenient than the equivalent `· by rename_i _ acc _; exact I1 acc`.\n\n### Invariant suggestions\n\n`mvcgen` will suggest invariants for you if you use the `invariants?` keyword.\n```\nmvcgen [...] invariants?\n```\nThis is useful if you do not recall the exact syntax to construct invariants.\nFurthermore, it will suggest a concrete invariant encoding \"this holds at the start of the loop and\nthis must hold at the end of the loop\" by looking at the corresponding VCs.\nAlthough the suggested invariant is a good starting point, it is too strong and requires users to\ninterpolate it such that the inductive step can be proved. Example:\n```\ndef mySum (l : List Nat) : Nat := Id.run do\n  let mut acc := 0\n  for x in l do\n    acc := acc + x\n  return acc\n\n/--\ninfo: Try this:\n  invariants\n    · ⇓⟨xs, letMuts⟩ =&gt; ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝\n-/\n#guard_msgs (info) in\ntheorem mySum_suggest_invariant (l : List Nat) : mySum l = l.sum := by\n  generalize h : mySum l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants?\n  all_goals admit\n```\n</code>",
 "2666":
 "<code class=\"docstring\">The `run_tac doSeq` tactic executes code in `TacticM Unit`. </code>",
 "2665":
 "<code class=\"docstring\">`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n</code>",
 "2664":
 "<code class=\"docstring\">`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n</code>",
 "2663":
 "<code class=\"docstring\">`and_intros` applies `And.intro` until it does not make progress. </code>",
 "2662":
 "<code class=\"docstring\">Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n</code>",
 "2661":
 "<code class=\"docstring\">`trace_state` displays the current state in the info view. </code>",
 "2660":
 "<code><span class=\"literal string\">\"right\"</span> : String</code>",
 "266": "<code>ABC.b : ABC</code>",
 "2659": "<code><span class=\"literal string\">\"left\"</span> : String</code>",
 "2658": "<code><span class=\"literal string\">\"foo\"</span> : String</code>",
 "2657":
 "<code class=\"docstring\">`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n</code>",
 "2656": "<code class=\"docstring\">`admit` is a synonym for `sorry`. </code>",
 "2655":
 "<code class=\"docstring\">`get_elem_tactic_trivial` has been deprecated in favour of `get_elem_tactic_extensible`. </code>",
 "2654":
 "<code class=\"docstring\">Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. </code>",
 "2653":
 "<code class=\"docstring\">`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n</code>",
 "2652":
 "<code class=\"docstring\">The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n</code>",
 "2651":
 "<code class=\"docstring\">Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n</code>",
 "2650":
 "<code class=\"docstring\">Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n</code>",
 "265": "<code>ABC.a : ABC</code>",
 "2649":
 "<code><span class=\"literal string\">\"proof.lrat\"</span> : String</code>",
 "2648":
 "<code class=\"docstring\">This tactic works just like `bv_decide` but skips calling a SAT solver by using a proof that is\nalready stored on disk. It is called with the name of an LRAT file in the same directory as the\ncurrent Lean file:\n```\nbv_check \"proof.lrat\"\n```\n</code>",
 "2647":
 "<code class=\"docstring\">Run the normalization procedure of `bv_decide` only. Sometimes this is enough to solve basic\n`BitVec` goals already.\n\nNote: include `import Std.Tactic.BVDecide`\n</code>",
 "2646":
 "<code class=\"docstring\">Suggest a proof script for a `bv_decide` tactic call. Useful for caching LRAT proofs.\n\nNote: include `import Std.Tactic.BVDecide`\n</code>",
 "2645":
 "<code>HOr.hOr.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HOr α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `|||` in identifiers is `or`.</code>",
 "2644":
 "<code>HAnd.hAnd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAnd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&&` in identifiers is `and`.</code>",
 "2643": "<code>BitVec 64</code>",
 "2642":
 "<code class=\"docstring\">`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bitvec_to_nat] at *`.\n`bitvec_to_nat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n</code>",
 "2641":
 "<code>Int.natAbs (m : Int) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The absolute value of an integer is its distance from `0`.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `(7 : Int).natAbs = 7`\n * `(0 : Int).natAbs = 0`\n * `((-11 : Int).natAbs = 11`\n</code>",
 "2640":
 "<code>decidable_of_iff {b : Prop} (a : Prop) (h : a ↔ b) [Decidable a] : Decidable b</code><span class=\"sep\"></span><code class=\"docstring\">Transfer decidability of `a` to decidability of `b`, if the propositions are equivalent.\n**Important**: this function should be used instead of `rw` on `Decidable b`, because the\nkernel will get stuck reducing the usage of `propext` otherwise,\nand `decide` will not work. </code>",
 "264": "<code>ABC : Type</code>",
 "2639": "<code>Sort ?u.48061</code>",
 "2638":
 "<code class=\"docstring\">`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n</code>",
 "2637":
 "<code class=\"docstring\">Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n</code>",
 "2636":
 "<code class=\"docstring\">Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n</code>",
 "2635":
 "<code class=\"docstring\">The tactic `nomatch h` is shorthand for `exact nomatch h`.\n</code>",
 "2634":
 "<code class=\"docstring\">The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n</code>",
 "2633": "<code>?m.27</code>",
 "2632":
 "<code>Verso.Genre.Manual.fun_cases (motive : Prop) (case1 : motive) : motive</code>",
 "2631":
 "<code class=\"docstring\">The `fun_cases` tactic is a convenience wrapper of the `cases` tactic when using a functional\ncases principle.\n\nThe tactic invocation\n```\nfun_cases f x ... y ...`\n```\nis equivalent to\n```\ncases y, ... using f.fun_cases_unfolding x ...\n```\nwhere the arguments of `f` are used as arguments to `f.fun_cases_unfolding` or targets of the case\nanalysis, as appropriate.\n\nThe form\n```\nfun_cases f\n```\n(with no arguments to `f`) searches the goal for a unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe form `fun_cases f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` works like with `cases`.\n\nUnder `set_option tactic.fun_induction.unfolding true` (the default), `fun_induction` uses the\n`f.fun_cases_unfolding` theorem, which will try to automatically unfold the call to `f` in\nthe goal. With `set_option tactic.fun_induction.unfolding false`, it uses `f.fun_cases` instead.\n</code>",
 "2630": "<code>e = PAT</code>",
 "263": "<code>ReprAtom.mk.{u} {α : Type u} : ReprAtom α</code>",
 "2629": "<code>?m.32 x</code>",
 "2628": "<code>?m.26</code>",
 "2627": "<code>Sort ?u.40275</code>",
 "2626": "<code>ty</code>",
 "2625": "<code>?m.18</code>",
 "2624": "<code>a ∧ b ∧ c ∨ d</code>",
 "2623": "<code>Type ?u.39054</code>",
 "2622":
 "<code>tactic.customEliminators</code><span class=\"sep\"></span><code class=\"docstring\">enable using custom eliminators in the 'induction' and 'cases' tactics defined using the '@[induction_eliminator]' and '@[cases_eliminator]' attributes</code>",
 "2621":
 "<code class=\"docstring\">custom `casesOn`-like eliminator for the `cases` tactic</code>",
 "2620":
 "<code class=\"docstring\">custom `rec`-like eliminator for the `induction` tactic</code>",
 "262":
 "<code>Char : Type</code><span class=\"sep\"></span><code class=\"docstring\">Characters are Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value).\n</code>",
 "2619": "<code>(i : Fin n) → motive i.castSucc → motive i.succ</code>",
 "2618": "<code>motive 0</code>",
 "2617": "<code>Fin (n + 1) → Sort u</code>",
 "2616":
 "<code>Fin.succ {n : Nat} : Fin n → Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">The successor, with an increased bound.\n\nThis differs from adding `1`, which instead wraps around.\n\nExamples:\n* `(2 : Fin 3).succ = (3 : Fin 4)`\n* `(2 : Fin 3) + 1 = (0 : Fin 3)`\n</code>",
 "2615":
 "<code>Fin.castSucc {n : Nat} : Fin n → Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound by one.\n</code>",
 "2614": "<code>0 + i✝.castSucc = i✝.castSucc</code>",
 "2613":
 "<code>Fin.induction.{u_1} {n : Nat} {motive : Fin (n + 1) → Sort u_1} (zero : motive 0)\n  (succ : (i : Fin n) → motive i.castSucc → motive i.succ) (i : Fin (n + 1)) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by induction on the underlying `Nat` value in a `Fin (n + 1)`.\n\nFor the induction:\n * `zero` is the base case, demonstrating `motive 0`.\n * `succ` is the inductive step, assuming the motive for `i : Fin n` (lifted to `Fin (n + 1)` with\n   `Fin.castSucc`) and demonstrating it for `i.succ`.\n\n`Fin.inductionOn` is a version of this induction principle that takes the `Fin` as its first\nparameter, `Fin.cases` is the corresponding case analysis operator, and `Fin.reverseInduction` is a\nversion that starts at the greatest value instead of `0`.\n</code>",
 "2612": "<code>val &lt; n</code>",
 "2611": "<code>(val : Nat) → (isLt : val &lt; n) → motive ⟨val, isLt⟩</code>",
 "2610": "<code>Fin n → Sort u</code>",
 "261":
 "<code>UInt8 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Unsigned 8-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 8-bit value\nrather than wrapping a `BitVec 8`.\n</code>",
 "2609":
 "<code>Fin.rec.{u} {n : Nat} {motive : Fin n → Sort u} (mk : (val : Nat) → (isLt : val &lt; n) → motive ⟨val, isLt⟩) (t : Fin n) :\n  motive t</code>",
 "2608": "<code>val✝ &lt; n + 1</code>",
 "2607": "<code>Fin (n + 1)</code>",
 "2606":
 "<code class=\"docstring\">Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n</code>",
 "2605":
 "<code class=\"docstring\">Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n</code>",
 "2604": "<code>List ?m.15</code>",
 "2603": "<code>?m.15</code>",
 "2602":
 "<code class=\"docstring\">`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. </code>",
 "2601": "<code>List ?m.44</code>",
 "2600": "<code>?m.44</code>",
 "260":
 "<code>ReprAtom.{u} (α : Type u) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class for marking types that should be considered atomic by `Repr` methods.\nWe use it at `Repr (List α)` to decide whether `bracketFill` should be used or not. </code>",
 "26":
 "<code class=\"docstring\">The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>",
 "2599": "<code>a :: b = c :: d</code>",
 "2598": "<code>List ?m.38</code>",
 "2597": "<code>?m.38</code>",
 "2596": "<code>List ?m.35</code>",
 "2595": "<code>?m.35</code>",
 "2594": "<code>?m.32</code>",
 "2593":
 "<code class=\"docstring\">The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n</code>",
 "2592":
 "<code class=\"docstring\">If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>",
 "2591":
 "<code class=\"docstring\">Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n</code>",
 "2590":
 "<code>Lean.Elab.Tactic.evalUnfold : Lean.Elab.Tactic.Tactic</code><span class=\"sep\"></span><code class=\"docstring\">\"unfold \" ident+ (location)? </code>",
 "259": "<code><span class=\"literal string\">\"+\"</span> : String</code>",
 "2589": "<code>id.eq_def.{u} {α : Sort u} (a : α) : id a = a</code>",
 "2588":
 "<code class=\"docstring\">`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n</code>",
 "2587":
 "<code>Lean.Meta.Rewrite.NewGoals : Type</code><span class=\"sep\"></span><code class=\"docstring\">Controls which new mvars are turned in to goals by the `apply` tactic.\n- `nonDependentFirst`  mvars that don't depend on other goals appear first in the goal list.\n- `nonDependentOnly` only mvars that don't depend on other goals are added to goal list.\n- `all` all unassigned mvars are added to the goal list.\n</code>",
 "2586":
 "<code>Lean.Meta.Rewrite.NewGoals</code><span class=\"sep\"></span><code class=\"docstring\">How to convert the resulting metavariables into  new goals </code>",
 "2585":
 "<code>Lean.Meta.Occurrences : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for which occurrences that match an expression should be rewritten. </code>",
 "2584":
 "<code>Lean.Meta.Occurrences</code><span class=\"sep\"></span><code class=\"docstring\">Which occurrences to rewrite</code>",
 "2583":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether to support offset constraints such as `?x + 1 =?= e` </code>",
 "2582":
 "<code>Lean.Meta.TransparencyMode : Type</code><span class=\"sep\"></span><code class=\"docstring\">Which constants should be unfolded?\n</code>",
 "2581":
 "<code>Lean.Meta.TransparencyMode</code><span class=\"sep\"></span><code class=\"docstring\">The transparency mode to use for unfolding </code>",
 "2580":
 "<code>Lean.Meta.Rewrite.Config.mk (transparency : Lean.Meta.TransparencyMode) (offsetCnstrs : Bool)\n  (occs : Lean.Meta.Occurrences) (newGoals : Lean.Meta.Rewrite.NewGoals) : Lean.Meta.Rewrite.Config</code>",
 "258": "<code>AddExpr</code>",
 "2579":
 "<code class=\"docstring\">`rwa` is short-hand for `rw; assumption`. </code>",
 "2578":
 "<code class=\"docstring\">`erw [rules]` is a shorthand for `rw (transparency := .default) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). </code>",
 "2577":
 "<code class=\"docstring\">Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n</code>",
 "2576":
 "<code class=\"docstring\">`simp_all_arith!` has been deprecated. It was a shorthand for `simp_all! +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "2575":
 "<code class=\"docstring\">`simp_all_arith` has been deprecated. It was a shorthand for `simp_all +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "2574":
 "<code class=\"docstring\">`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will unfold applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be used to partially evaluate many definitions. </code>",
 "2573":
 "<code class=\"docstring\">`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will unfold applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be used to partially evaluate many definitions. </code>",
 "2572":
 "<code class=\"docstring\">`simp_arith!` has been deprecated. It was a shorthand for `simp! +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "2571":
 "<code class=\"docstring\">`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n</code>",
 "2570":
 "<code class=\"docstring\">`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will unfold applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be used to partially evaluate many definitions. </code>",
 "257": "<code>AddExpr.reprPrec : AddExpr → Nat → Std.Format</code>",
 "2569": "<code>Sort ?u.438</code>",
 "2568": "<code>Tₙ</code>",
 "2567": "<code>Sort ?u.437</code>",
 "2566": "<code>T₁</code>",
 "2565":
 "<code>Min.min.{u} {α : Type u} [self : Min α] : α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the lesser of its two arguments. </code>",
 "2564":
 "<code>BitVec.setWidth {w : Nat} (v : Nat) (x : BitVec w) : BitVec v</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a bitvector of length `w` into a bitvector of length `v`, padding with `0` as needed.\n\nThe specific behavior depends on the relationship between the starting width `w` and the final width\n`v`:\n * If `v &gt; w`, it is zero-extended; the high bits are padded with zeroes until the bitvector has `v`\n   bits.\n * If `v = w`, the bitvector is returned unchanged.\n * If `v &lt; w`, the high bits are truncated.\n\n`BitVec.setWidth`, `BitVec.zeroExtend`, and `BitVec.truncate` are aliases for this operation.\n\nSMT-LIB name: `zero_extend`.\n</code>",
 "2563":
 "<code>BitVec.msb {n : Nat} (x : BitVec n) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns the most significant bit in a bitvector. </code>",
 "2562":
 "<code>BitVec.cons {n : Nat} (msb : Bool) (lsbs : BitVec n) : BitVec (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">Prepends a single bit to the front of a bitvector, using big-endian order (see `append`).\n\nThe new bit is the most significant bit.\n</code>",
 "2561": "<code>BitVec (w + 1)</code>",
 "2560":
 "<code>List.getLastD.{u} {α : Type u} (as : List α) (fallback : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element in the list, or `fallback` if the list is empty.\n\nAlternatives include `List.getLast?`, which returns an `Option`, and `List.getLast!`, which panics\non empty lists.\n\nExamples:\n * `[\"circle\", \"rectangle\"].getLastD \"oval\" = \"rectangle\"`\n * `[\"circle\"].getLastD \"oval\" = \"circle\"`\n * `([] : List String).getLastD \"oval\" = \"oval\"`\n</code>",
 "256":
 "<code>AddExpr → AddExpr → AddExpr</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "2559": "<code>Sort ?u.22535</code>",
 "2558": "<code>Sort ?u.22534</code>",
 "2557": "<code>NoNatZeroDivisors α</code>",
 "2556": "<code>Field α</code>",
 "2555":
 "<code>Lean.Grind.NoNatZeroDivisors.{u} (α : Type u) [NatModule α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">We say a module has no natural number zero divisors if\n`k ≠ 0` and `k * a = k * b` implies `a = b` (here `k` is a natural number and `a` and `b` are element of the module).\n\nFor a module over the integers this is equivalent to\n`k ≠ 0` and `k * a = 0` implies `a = 0`.\n(See the alternative constructor `NoNatZeroDivisors.mk'`,\nand the theorem `eq_zero_of_mul_eq_zero`.)\n</code>",
 "2554":
 "<code>Lean.Grind.Field.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A field is a commutative ring with inverses for all non-zero elements.\n</code>",
 "2553": "<code>UInt8</code>",
 "2552": "<code>IsCharP α 256</code>",
 "2551":
 "<code>Lean.Grind.IsCharP.{u} (α : Type u) [Semiring α] (p : outParam Nat) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A ring `α` has characteristic `p` if `OfNat.ofNat x = 0` iff `x % p = 0`.\n\nNote that for `p = 0`, we have `x % p = x`, so this says that `OfNat.ofNat` is injective from `Nat` to `α`.\n\nIn the case of a semiring, we take the stronger condition that\n`OfNat.ofNat x = OfNat.ofNat y` iff `x % p = y % p`.\n</code>",
 "2550":
 "<code>HPow.hPow.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HPow α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.</code>",
 "255":
 "<code>AddExpr</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "2549": "<code>CommRing α</code>",
 "2548":
 "<code>Lean.Grind.CommRing.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A commutative ring, i.e. a ring with commutative multiplication.\n</code>",
 "2547":
 "<code>HMul.hMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMul α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>",
 "2546":
 "<code class=\"docstring\">`cutsat` solves linear integer arithmetic goals.\n\nIt is a implemented as a thin wrapper around the `grind` tactic, enabling only the `cutsat` solver.\nPlease use `grind` instead if you need additional capabilities.\n</code>",
 "2545":
 "<code>Verso.Genre.Manual.InlineLean.name : Verso.Doc.Elab.RoleExpanderOf NameConfig</code>",
 "2544": "<code>Rtrans {x y z : Int} : R x y → R y z → R x z</code>",
 "2543": "<code>R : Int → Int → Prop</code>",
 "2542":
 "<code>trace.grind.ematch.instance</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "2541": "<code>?m.96</code>",
 "2540": "<code>?m.39</code>",
 "254":
 "<code>Add.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. </code>",
 "2539": "<code>?m.22</code>",
 "2538": "<code>gf (x : Nat) : g (f x) = x</code>",
 "2537":
 "<code class=\"docstring\">Marks a theorem or definition for use by the `grind` tactic.\n\nAn optional modifier (e.g. `=`, `→`, `←`, `cases`, `intro`, `ext`, `inj`, etc.)\ncontrols how `grind` uses the declaration:\n* whether it is applied forwards, backwards, or both,\n* whether equalities are used on the left, right, or both sides,\n* whether case-splits, constructors, extensionality, or injectivity are applied,\n* or whether custom instantiation patterns are used.\n\nSee the individual modifier docstrings for details.\n</code>",
 "2536": "<code>g (a : Nat) : Nat</code>",
 "2535": "<code>f (a : Nat) : Nat</code>",
 "2534":
 "<code class=\"docstring\">Apply a single extensionality theorem to the current goal. </code>",
 "2533":
 "<code class=\"docstring\">`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n</code>",
 "2532":
 "<code class=\"docstring\">Registers an extensionality theorem.\n\n* When `@[ext]` is applied to a theorem, the theorem is registered for the `ext` tactic, and it generates an \"`ext_iff`\" theorem.\nThe name of the theorem is from adding the suffix `_iff` to the theorem name.\n\n* When `@[ext]` is applied to a structure, it generates an `.ext` theorem and applies the `@[ext]` attribute to it.\nThe result is an `.ext` and an `.ext_iff` theorem with the `.ext` theorem registered for the `ext` tactic.\n\n* An optional natural number argument, e.g. `@[ext 9000]`, specifies a priority for the `ext` lemma.\nHigher-priority lemmas are chosen first, and the default is `1000`.\n\n* The flag `@[ext (iff := false)]` disables generating an `ext_iff` theorem.\n\n* The flag `@[ext (flat := false)]` causes generated structure extensionality theorems to show inherited fields based on their representation,\nrather than flattening the parents' fields into the lemma's equality hypotheses.\n</code>",
 "2531": "<code>Int.add_zero (a : Int) : a + 0 = a</code>",
 "2530": "<code>↑a + ↑b = 10</code>",
 "253":
 "<code>OfNat.{u} (α : Type u) : Nat → Type u</code><span class=\"sep\"></span><code class=\"docstring\">The class `OfNat α n` powers the numeric literal parser. If you write\n`37 : α`, Lean will attempt to synthesize `OfNat α 37`, and will generate\nthe term `(OfNat.ofNat 37 : α)`.\n\nThere is a bit of infinite regress here since the desugaring apparently\nstill contains a literal `37` in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro `nat_lit 37`. Raw number literals are always of type `Nat`.\nSo it would be more correct to say that Lean looks for an instance of\n`OfNat α (nat_lit 37)`, and it generates the term `(OfNat.ofNat (nat_lit 37) : α)`.\n</code>",
 "2529": "<code>↑(a + b + 0) = 10</code>",
 "2528": "<code>↑(a + b) = 10</code>",
 "2527":
 "<code class=\"docstring\">`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n</code>",
 "2526":
 "<code class=\"docstring\">`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. </code>",
 "2525":
 "<code class=\"docstring\">Rewrites with the given rules, normalizing casts prior to each step.\n</code>",
 "2524":
 "<code class=\"docstring\">Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n</code>",
 "2523":
 "<code class=\"docstring\">Normalize casts in the goal and the given expression, then close the goal with `exact`.\n</code>",
 "2522":
 "<code class=\"docstring\">`expose_names` renames all inaccessible variables with accessible names, making them available\nfor reference in generated tactics. However, this renaming introduces machine-generated names\nthat are not fully under user control. `expose_names` is primarily intended as a preamble for\nauto-generated end-game tactic scripts. It is also useful as an alternative to\n`set_option tactic.hygienic false`. If explicit control over renaming is needed in the\nmiddle of a tactic script, consider using structured tactic scripts with\n`match .. with`, `induction .. with`, or `intro` with explicit user-defined names,\nas well as tactics such as `next`, `case`, and `rename_i`.\n</code>",
 "2521":
 "<code class=\"docstring\">`show_term e` elaborates `e`, then prints the generated term.\n</code>",
 "2520":
 "<code class=\"docstring\">`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" (prefixed by `expose_names` if necessary)\nif there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n</code>",
 "252": "<code>AddExpr.add : AddExpr → AddExpr → AddExpr</code>",
 "2519": "<code>e = x</code>",
 "2518":
 "<code class=\"docstring\">* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n</code>",
 "2517":
 "<code class=\"docstring\">* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n</code>",
 "2516": "<code>Sort ?u.14642</code>",
 "2515":
 "<code class=\"docstring\">* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n</code>",
 "2514":
 "<code class=\"docstring\">Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n</code>",
 "2513": "<code>x ≠ x</code>",
 "2512": "<code>Sort ?u.17</code>",
 "2511": "<code>Sort ?u.181</code>",
 "2510": "<code>2 + 2 = 3</code>",
 "251": "<code>AddExpr.nat : Nat → AddExpr</code>",
 "2509": "<code>Sort ?u.73</code>",
 "2508": "<code>none = some true</code>",
 "2507": "<code>Sort ?u.9</code>",
 "2506":
 "<code class=\"docstring\">`as_aux_lemma =&gt; tac` does the same as `tac`, except that it wraps the resulting expression\ninto an auxiliary lemma. In some cases, this significantly reduces the size of expressions\nbecause the proof term is not duplicated.\n</code>",
 "2505":
 "<code class=\"docstring\">`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n</code>",
 "2504":
 "<code>Lean.Meta.Tactic.Backtrack.BacktrackConfig : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration structure to control the behaviour of `backtrack`:\n* control the maximum depth and behaviour (fail or return subgoals) at the maximum depth,\n* and hooks allowing\n  * modifying intermediate goals before running the external tactic,\n  * 'suspending' goals, returning them in the result, and\n  * discharging subgoals if the external tactic fails.\n</code>",
 "2503":
 "<code class=\"docstring\">Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). </code>",
 "2502":
 "<code class=\"docstring\">`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Std.Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Std.Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n</code>",
 "2501": "<code>Nat.add_comm (n m : Nat) : n + m = m + n</code>",
 "2500":
 "<code>Std.Commutative.mk.{u} {α : Sort u} {op : α → α → α} (comm : ∀ (a b : α), op a b = op b a) : Std.Commutative op</code>",
 "250": "<code>AddExpr : Type</code>",
 "25": "<code>Even : Nat → Prop</code>",
 "2499":
 "<code>Std.Commutative.{u} {α : Sort u} (op : α → α → α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Commutative op` says that `op` is a commutative operation,\ni.e. `a ∘ b = b ∘ a`.\n</code>",
 "2498": "<code>Nat.add_assoc (n m k : Nat) : n + m + k = n + (m + k)</code>",
 "2497":
 "<code>Std.Associative.mk.{u} {α : Sort u} {op : α → α → α} (assoc : ∀ (a b c : α), op (op a b) c = op a (op b c)) :\n  Std.Associative op</code>",
 "2496":
 "<code>Std.Associative.{u} {α : Sort u} (op : α → α → α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Associative op` indicates `op` is an associative operation,\ni.e. `(a ∘ b) ∘ c = a ∘ (b ∘ c)`.\n</code>",
 "2495":
 "<code class=\"docstring\">`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Std.Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Std.Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n</code>",
 "2494":
 "<code>congr.{u, v} {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α} (h₁ : f₁ = f₂) (h₂ : a₁ = a₂) : f₁ a₁ = f₂ a₂</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in both function and argument. If `f₁ = f₂` and `a₁ = a₂` then\n`f₁ a₁ = f₂ a₂`. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "2493":
 "<code class=\"docstring\">Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ f as ≍ f bs`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n</code>",
 "2492": "<code>x = t</code>",
 "2491":
 "<code class=\"docstring\">`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n</code>",
 "2490":
 "<code class=\"docstring\">Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n</code>",
 "249":
 "<code>List.range (n : Nat) : List Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a list of the numbers from `0` to `n` exclusive, in increasing order.\n\n`O(n)`.\n\nExamples:\n* `range 5 = [0, 1, 2, 3, 4]`\n* `range 0 = []`\n* `range 2 = [0, 1]`\n</code>",
 "2489": "<code>a = b</code>",
 "2488": "<code>?m.6</code>",
 "2487":
 "<code>{a : α} → {b : β} → {c : γ} → r a b → s b c → t a c</code><span class=\"sep\"></span><code class=\"docstring\">Compose two proofs by transitivity, generalized over the relations involved. </code>",
 "2486":
 "<code>Trans.mk.{u, v, w, u_1, u_2, u_3} {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {r : α → β → Sort u} {s : β → γ → Sort v}\n  {t : outParam (α → γ → Sort w)} (trans : {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c) : Trans r s t</code>",
 "2485": "<code>outParam (α → γ → Sort w)</code>",
 "2484": "<code>β → γ → Sort v</code>",
 "2483": "<code>α → β → Sort u</code>",
 "2482":
 "<code>Verso.Genre.Manual.conv : Verso.Doc.Elab.DirectiveExpanderOf TacticDocsOptions</code>",
 "2481":
 "<code>Trans.{u, v, w, u_1, u_2, u_3} {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (r : α → β → Sort u) (s : β → γ → Sort v)\n  (t : outParam (α → γ → Sort w)) : Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a ≤ b` and `b &lt; c`\nit knows that this should be a proof of `a &lt; c` because there is an instance\n`Trans (·≤·) (·&lt;·) (·&lt;·)`.\n</code>",
 "2480":
 "<code class=\"docstring\">Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `&lt;lhs&gt;\\n  _ = &lt;rhs&gt; :=\n&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n</code>",
 "248":
 "<code><span class=\"literal string\">\"N.NatOrInt.int\"</span> : String</code>",
 "2479": "<code class=\"docstring\">symmetric relation</code>",
 "2478":
 "<code class=\"docstring\">For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. </code>",
 "2477": "<code class=\"docstring\">reflexivity relation</code>",
 "2476":
 "<code class=\"docstring\">`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. </code>",
 "2475":
 "<code class=\"docstring\">The same as `rfl`, but without trying `eq_refl` at the end.\n</code>",
 "2474":
 "<code class=\"docstring\">`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n</code>",
 "2473":
 "<code class=\"docstring\">`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n</code>",
 "2472":
 "<code class=\"docstring\">The tactic\n```\nintro\n| pat1 =&gt; tac1\n| pat2 =&gt; tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 =&gt; tac1\n| pat2 =&gt; tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n</code>",
 "2471": "<code>AllEven f✝</code>",
 "2470": "<code>AllEven (f : Nat → Nat) : Prop</code>",
 "247":
 "<code><span class=\"literal string\">\"N.NatOrInt.nat\"</span> : String</code>",
 "2469":
 "<code class=\"docstring\">`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n</code>",
 "2468":
 "<code class=\"docstring\">`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n</code>",
 "2467": "<code>Sort ?u.428</code>",
 "2466":
 "<code class=\"docstring\">`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. </code>",
 "2465":
 "<code class=\"docstring\">* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n</code>",
 "2464":
 "<code>trivial : True</code><span class=\"sep\"></span><code class=\"docstring\">`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. </code>",
 "2463":
 "<code class=\"docstring\">`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n</code>",
 "2462":
 "<code>Classical.propDecidable (a : Prop) : Decidable a</code><span class=\"sep\"></span><code class=\"docstring\">All propositions are `Decidable`. </code>",
 "2461":
 "<code class=\"docstring\">`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority\nlocal instance.\n\nNote that `classical` is a scoping tactic: it adds the instance only within the\nscope of the tactic.\n</code>",
 "2460":
 "<code class=\"docstring\">`open Foo in e` is like `open Foo` but scoped to a single term.\nIt makes the given namespaces available in the term `e`.\n</code>",
 "246": "<code>N.NatOrInt.int : Int → NatOrInt</code>",
 "2459":
 "<code class=\"docstring\">`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. </code>",
 "2458":
 "<code class=\"docstring\">`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. </code>",
 "2457":
 "<code class=\"docstring\">Similar to `let`, but using `refine'` </code>",
 "2456":
 "<code class=\"docstring\">`letI` behaves like `let`, but inlines the value instead of producing a `let` term. </code>",
 "2455":
 "<code class=\"docstring\">`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. </code>",
 "2454":
 "<code class=\"docstring\">* `clear_value x...` clears the values of the given local definitions.\n  A local definition `x : α := v` becomes a hypothesis `x : α`.\n\n* `clear_value (h : x = _)` adds a hypothesis `h : x = v` before clearing the value of `x`.\n  This is short for `have h : x = v := rfl; clear_value x`.\n  Any value definitionally equal to `v` can be used in place of `_`.\n\n* `clear_value *` clears values of all hypotheses that can be cleared.\n  Fails if none can be cleared.\n\nThese syntaxes can be combined. For example, `clear_value x y *` ensures that `x` and `y` are cleared\nwhile trying to clear all other local definitions,\nand `clear_value (hx : x = _) y * with hx` does the same while first adding the `hx : x = v` hypothesis.\n</code>",
 "2453":
 "<code class=\"docstring\">`subst x...` substitutes each hypothesis `x` with a definition found in the local context,\nthen eliminates the hypothesis.\n- If `x` is a local definition, then its definition is used.\n- Otherwise, if there is a hypothesis of the form `x = e` or `e = x`,\n  then `e` is used for the definition of `x`.\n\nIf `h : a = b`, then `subst h` may be used if either `a` or `b` unfolds to a local hypothesis.\nThis is similar to the `cases h` tactic.\n\nSee also: `subst_vars` for substituting all local hypotheses that have a defining equation.\n</code>",
 "2452": "<code>?m.23</code>",
 "2451": "<code>e = pat</code>",
 "2450": "<code>Type ?u.27670</code>",
 "245": "<code>N.NatOrInt.nat : Nat → NatOrInt</code>",
 "2449": "<code>Type ?u.27671</code>",
 "2448": "<code>Type ?u.27669</code>",
 "2447": "<code>α × β × γ</code>",
 "2446":
 "<code class=\"docstring\">`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n</code>",
 "2445":
 "<code class=\"docstring\">Similar to `have`, but using `refine'` </code>",
 "2444": "<code>Sort ?u.25915</code>",
 "2443": "<code>Sort ?u.25635</code>",
 "2442": "<code>Sort ?u.23660</code>",
 "2441":
 "<code class=\"docstring\">`let (eq := h) x := v; ...` adds the equality `h : x = v` to the context while elaborating the body.\n</code>",
 "2440": "<code>r</code>",
 "244": "<code>N.NatOrInt : Type</code>",
 "2439": "<code>q</code>",
 "2438": "<code>Sort ?u.23380</code>",
 "2437":
 "<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by `have`.\n\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `let` term.\n\n## Properties and relations\n\n* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics\n  such as `simp`, `dsimp`, `unfold`, and `subst`.\n* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.\n  The tactic might fail if the local context depends on the value of the variable.\n* The `let` tactic is preferred for data (non-propositions).\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n</code>",
 "2436":
 "<code class=\"docstring\">`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n</code>",
 "2435":
 "<code class=\"docstring\">`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n</code>",
 "2434":
 "<code class=\"docstring\">`rename t =&gt; x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n</code>",
 "2433":
 "<code class=\"docstring\">The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n</code>",
 "2432":
 "<code>tactic.hygienic</code><span class=\"sep\"></span><code class=\"docstring\">make sure tactics are hygienic</code>",
 "2431":
 "<code class=\"docstring\">`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n</code>",
 "2430":
 "<code class=\"docstring\">`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n</code>",
 "243":
 "<code>Std.Format.sbracket (f : Std.Format) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates the format `\"[\" ++ f ++ \"]\"` with a flattening group, nesting by one space.\n\n`sbracket` is short for “square bracket”.\n</code>",
 "2429": "<code>TacticM ?m.3</code>",
 "2428":
 "<code>Lean.Elab.Tactic.focus {α : Type} (x : TacticM α) : TacticM α</code><span class=\"sep\"></span><code class=\"docstring\">Runs `x` with only the first unsolved goal as the goal.\nFails if there are no goal to be solved.\n</code>",
 "2427":
 "<code class=\"docstring\">`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n</code>",
 "2426":
 "<code class=\"docstring\">`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. </code>",
 "2425":
 "<code class=\"docstring\">`any_goals tac` applies the tactic `tac` to every goal,\nconcatenating the resulting goals for successful tactic applications.\nIf the tactic fails on all of the goals, the entire `any_goals` tactic fails.\n\nThis tactic is like `all_goals try tac` except that it fails if none of the applications of `tac` succeeds.\n</code>",
 "2424": "<code>x = 2</code>",
 "2423": "<code>x = 1</code>",
 "2422": "<code>x = 1 ∨ x = 2</code>",
 "2421":
 "<code class=\"docstring\">Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n</code>",
 "2420":
 "<code class=\"docstring\">`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n</code>",
 "242":
 "<code>Std.Format.paren (f : Std.Format) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates the format `\"(\" ++ f ++ \")\"` with a flattening group, nesting by one space.\n</code>",
 "2419":
 "<code class=\"docstring\">`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 =&gt; rfl\n  | i+1 =&gt; simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n</code>",
 "2418": "<code>reduceIte : Lean.Meta.Simp.Simproc</code>",
 "2417": "<code>¬n = 0</code>",
 "2416": "<code>n = 0</code>",
 "2415": "<code>Sort ?u.11828</code>",
 "2414": "<code>t</code>",
 "2413":
 "<code class=\"docstring\">`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n</code>",
 "2412": "<code>?m.9</code>",
 "2411":
 "<code class=\"docstring\">`try tac` runs `tac` and succeeds even if `tac` failed. </code>",
 "2410":
 "<code class=\"docstring\">`fail_if_success t` fails if the tactic `t` succeeds. </code>",
 "241":
 "<code>Std.Format.bracket (l : String) (f : Std.Format) (r : String) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates a format `l ++ f ++ r` with a flattening group, nesting the contents by the length of `l`.\n\nThe group's `FlattenBehavior` is `allOrNone`; for `fill` use `Std.Format.bracketFill`.\n</code>",
 "2409":
 "<code class=\"docstring\">`fail msg` is a tactic that always fails, and produces an error using the given message. </code>",
 "2408":
 "<code class=\"docstring\">`first | tac | ...` runs each `tac` until one succeeds, or else fails. </code>",
 "2407":
 "<code>pp.mvars</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display names of metavariables when true, and otherwise display them as '?_' (for expression metavariables) and as '_' (for universe level metavariables)</code>",
 "2406":
 "<code>Nat.lt_trans {n m k : Nat} (h₁ : n &lt; m) : m &lt; k → n &lt; k</code>",
 "2405": "<code>j &lt; k</code>",
 "2404": "<code>List ?m.8</code>",
 "2403": "<code>?m.8</code>",
 "2402": "<code>Type ?u.8219</code>",
 "2401":
 "<code>pp.maxSteps</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) maximum number of expressions to visit, after which terms will pretty print as `⋯`</code>",
 "2400":
 "<code>pp.deepTerms.threshold</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) when `pp.deepTerms` is false, the depth at which terms start being replaced with `⋯`</code>",
 "240":
 "<code>reprArg.{u_1} {α : Type u_1} [Repr α] (a : α) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turns `a` into a `Format` using its `Repr` instance, with the precedence level set to that of\nfunction application.\n\nTogether with `Repr.addAppParen`, this can be used to correctly parenthesize function application\nsyntax.\n</code>",
 "24":
 "<code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List α` is the list of elements of type `α`, and is defined as follows:\n```\ninductive List (α : Type u) where\n| nil\n| cons (head : α) (tail : List α)\n```\nA list of elements of type `α` is either the empty list, `nil`,\nor an element `head : α` followed by a list `tail : List α`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>",
 "2399":
 "<code>pp.deepTerms</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display deeply nested terms, replacing them with `⋯` if set to false</code>",
 "2398": "<code>↑i &gt; 5</code>",
 "2397":
 "<code>pp.proofs.threshold</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) when `pp.proofs` is false, controls the complexity of proofs at which they begin being replaced with `⋯`</code>",
 "2396":
 "<code>pp.proofs</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display proofs when true, and replace proofs appearing within expressions by `⋯` when false</code>",
 "2395": "<code>n✝ + 1 + 1 + 1 &lt; 3</code>",
 "2394": "<code>0 + 1 + 1 &lt; 3</code>",
 "2393":
 "<code class=\"docstring\">`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n</code>",
 "2392": "<code>x &lt; 3</code>",
 "2391":
 "<code class=\"docstring\">`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. </code>",
 "2390": "<code>α → β✝</code>",
 "239":
 "<code>Repr.addAppParen (f : Std.Format) (prec : Nat) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Adds parentheses to `f` if the precedence `prec` from the context is at least that of function\napplication.\n\nTogether with `reprArg`, this can be used to correctly parenthesize function application\nsyntax.\n</code>",
 "2389": "<code>Type ?u.5080</code>",
 "2388": "<code>Type ?u.4772</code>",
 "2387": "<code>ih : xs ++ [] = xs</code>",
 "2386": "<code>xs : List α</code>",
 "2385": "<code>x : α</code>",
 "2384": "<code>xs ++ [] = xs</code>",
 "2383": "<code>Type ?u.3956</code>",
 "2382": "<code>0 + n✝ = n✝ + 0</code>",
 "2381": "<code>n✝ + k = k + n✝</code>",
 "2380":
 "<code class=\"docstring\">`case'` is similar to the `case tag =&gt; tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n</code>",
 "238":
 "<code class=\"docstring\">`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n</code>",
 "2379": "<code>β → Option γ</code>",
 "2378": "<code>α → Option β</code>",
 "2377": "<code>Option (α → β)</code>",
 "2376": "<code>Option α</code>",
 "2375": "<code>Type ?u.2178</code>",
 "2374":
 "<code>LawfulMonad.{u, v} (m : Type u → Type v) [Monad m] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lawful monads are those that satisfy a certain behavioral specification. While all instances of\n`Monad` should satisfy these laws, not all implementations are required to prove this.\n\n`LawfulMonad.mk'` is an alternative constructor that contains useful defaults for many fields.\n</code>",
 "2373":
 "<code class=\"docstring\">* `case tag =&gt; tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ =&gt; tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ =&gt; tac` is equivalent to `(case tag₁ =&gt; tac); (case tag₂ =&gt; tac)`.\n</code>",
 "2372":
 "<code class=\"docstring\">`tac &lt;;&gt; tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n</code>",
 "2371":
 "<code>CoeTC.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeTC α β</code>",
 "2370":
 "<code>CoeOTC.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeOTC α β</code>",
 "237":
 "<code>Repr.reprPrec.{u} {α : Type u} [self : Repr α] : α → Nat → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turn a value of type `α` into a `Format` at a given precedence. The precedence value can be used\nto avoid parentheses if they are not necessary.\n</code>",
 "2369":
 "<code>CoeHTC.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeHTC α β</code>",
 "2368":
 "<code>CoeHTCT.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeHTCT α β</code>",
 "2367":
 "<code>CoeHTCT.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `CoeHead* Coe* CoeTail?`.\nUsers should generally not implement this directly.\n</code>",
 "2366":
 "<code>CoeHTC.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `CoeHead CoeOut* Coe*`.\nUsers should generally not implement this directly.\n</code>",
 "2365":
 "<code>CoeOTC.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `CoeOut* Coe*`.\nUsers should generally not implement this directly.\n</code>",
 "2364":
 "<code>CoeTC.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `Coe*`.\nUsers should generally not implement this directly.\n</code>",
 "2363":
 "<code class=\"docstring\">auxiliary definition used to implement coercion (unfolded during elaboration)</code>",
 "2362": "<code>Tm [] α''</code>",
 "2361":
 "<code>Tm [] α'' → α''.interp</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "2360": "<code>Fin α''.length</code>",
 "236":
 "<code><span class=\"literal string\">\"NatOrInt.int\"</span> : String</code>",
 "2359": "<code>Tm α'' t✝</code>",
 "2358": "<code>Tm α'' (t✝.arr t)</code>",
 "2357": "<code>t✝.interp</code>",
 "2356": "<code>Tm (t✝ :: α'') t'✝</code>",
 "2355": "<code>(Ty.nat.arr (t.arr t)).interp</code>",
 "2354": "<code>Tm α'' (Ty.nat.arr (t.arr t))</code>",
 "2353": "<code>Tm α'' t</code>",
 "2352": "<code>Ty.nat.interp</code>",
 "2351": "<code>Tm α'' Ty.nat</code>",
 "2350": "<code>Env α''</code>",
 "235": "<code><span class=\"literal string\">\"))\"</span> : String</code>",
 "2349":
 "<code>Tm.interp {α'' : List Ty} {t : Ty} (ρ : Env α'') : Tm α'' t → t.interp</code>",
 "2348": "<code>i + 1 &lt; (head✝ :: tail✝).length</code>",
 "2347": "<code>Env tail✝</code>",
 "2346": "<code>head✝.interp</code>",
 "2345":
 "<code>Env.get {Γ : List Ty} (i : Fin Γ.length) (ρ : Env Γ) : Γ[i].interp</code>",
 "2344": "<code>t.interp</code>",
 "2343": "<code>Env Γ</code>",
 "2342":
 "<code>Env.extend {Γ : List Ty} {t : Ty} (ρ : Env Γ) (v : t.interp) : Env (t :: Γ)</code>",
 "2341": "<code>Env.empty : Env []</code>",
 "2340": "<code>Env : List Ty → Type</code>",
 "234":
 "<code>repr.{u_1} {α : Type u_1} [Repr α] (a : α) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turns `a` into a `Format` using its `Repr` instance. The precedence level is initially set to 0.\n</code>",
 "2339": "<code>Fin ([Ty.nat, Ty.nat, Ty.nat].length + 1)</code>",
 "2338": "<code>Fin ([Ty.nat].length + 1)</code>",
 "2337": "<code>plus : Tm [] (Ty.nat.arr (Ty.nat.arr Ty.nat))</code>",
 "2336": "<code>Fin (Γ.length + 1)</code>",
 "2335":
 "<code>Tm.v {t : Ty} {Γ : List Ty} (i : Fin (Γ.length + 1)) : Tm (t :: Γ) (t :: Γ)[i]</code>",
 "2334": "<code>Fin Γ.length</code>",
 "2333": "<code>Tm.var {Γ : List Ty} (i : Fin Γ.length) : Tm Γ Γ[i]</code>",
 "2332": "<code>Tm Γ (t.arr t')</code>",
 "2331":
 "<code>Tm.app {Γ : List Ty} {t t' : Ty} (f : Tm Γ (t.arr t')) (arg : Tm Γ t) : Tm Γ t'</code>",
 "2330": "<code>Tm (t :: Γ) t'</code>",
 "233":
 "<code><span class=\"literal string\">\"NatOrInt.nat\"</span> : String</code>",
 "2329":
 "<code>Tm.lam {t : Ty} {Γ : List Ty} {t' : Ty} (body : Tm (t :: Γ) t') : Tm Γ (t.arr t')</code>",
 "2328": "<code>Tm Γ (Ty.nat.arr (t.arr t))</code>",
 "2327": "<code>Tm Γ t</code>",
 "2326":
 "<code>Tm.rep {Γ : List Ty} {t : Ty} (n : Tm Γ Ty.nat) (start : Tm Γ t) (f : Tm Γ (Ty.nat.arr (t.arr t))) : Tm Γ t</code>",
 "2325": "<code>Tm Γ Ty.nat</code>",
 "2324": "<code>Tm.succ {Γ : List Ty} (n : Tm Γ Ty.nat) : Tm Γ Ty.nat</code>",
 "2323": "<code>List Ty</code>",
 "2322": "<code>Tm.zero {Γ : List Ty} : Tm Γ Ty.nat</code>",
 "2321": "<code>Tm : List Ty → Ty → Type</code>",
 "2320": "<code>Ty.interp : Ty → Type</code>",
 "232":
 "<code>Std.Format.nestD (f : Std.Format) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Increases the indentation level by the default amount.\n</code>",
 "2319": "<code>Ty</code>",
 "2318": "<code>Ty.arr (dom cod : Ty) : Ty</code>",
 "2317": "<code>Ty.nat : Ty</code>",
 "2316": "<code>Ty : Type</code>",
 "2315":
 "<code><span class=\"literal string\">\" hello\"</span> : String</code>",
 "2314":
 "<code><span class=\"literal string\">\"5 hello\"</span> : String</code>",
 "2313": "<code>Writer</code>",
 "2312":
 "<code>(w : Writer) → w.Writes → String → String</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "2311": "<code>stringWriter : Writer</code>",
 "2310": "<code>Nat → String → String</code>",
 "231": "<code>NatOrInt</code>",
 "2309": "<code>natWriter : Writer</code>",
 "2308":
 "<code>Writer.write.{u} (self : Writer) : self.Writes → String → String</code>",
 "2307": "<code>Writer.Writes.{u} (self : Writer) : Type u</code>",
 "2306": "<code>Writer.{u} : Type (u + 1)</code>",
 "2305": "<code>α → α''</code>",
 "2304":
 "<code>NamedFun α α'' → α → α''</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "2303": "<code>NamedFun α α''</code>",
 "2302":
 "<code>NamedFun α α'' → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>",
 "2301": "<code><span class=\"literal string\">\" ∘ \"</span> : String</code>",
 "2300": "<code>α → γ</code>",
 "230":
 "<code>NatOrInt → Nat → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turn a value of type `α` into a `Format` at a given precedence. The precedence value can be used\nto avoid parentheses if they are not necessary.\n</code>",
 "23": "<code>?_mvar.1025</code>",
 "2299": "<code>NamedFun α β</code>",
 "2298": "<code>NamedFun β γ</code>",
 "2297":
 "<code>NamedFun.comp.{u, v, u_1} {α : Type u} {β : Type v} {γ : Type u_1} (f : NamedFun β γ) (g : NamedFun α β) : NamedFun α γ</code>",
 "2296":
 "<code><span class=\"literal string\">\"append\"</span> : String</code>",
 "2295": "<code>List α → List α → List α</code>",
 "2294":
 "<code>append.{u} {α : Type u} : NamedFun (List α) (List α → List α)</code>",
 "2293":
 "<code><span class=\"literal string\">\"asString\"</span> : String</code>",
 "2292": "<code>α → String</code>",
 "2291":
 "<code>asString.{u} {α : Type u} [ToString α] : NamedFun α String</code>",
 "2290": "<code><span class=\"literal string\">\"succ\"</span> : String</code>",
 "229": "<code>NatOrInt.int : Int → NatOrInt</code>",
 "2289": "<code>Nat → Nat</code>",
 "2288": "<code>succ : NamedFun Nat Nat</code>",
 "2287":
 "<code>NamedFun.name.{u, v} {α : Type u} {β : Type v} (self : NamedFun α β) : String</code>",
 "2286":
 "<code>NamedFun.function.{u, v} {α : Type u} {β : Type v} (self : NamedFun α β) : α → β</code>",
 "2285":
 "<code>NamedFun.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code>",
 "2284":
 "<code>(f : α) → γ f</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "2283":
 "<code>CoeFun.mk.{u, v} {α : Sort u} {γ : outParam (α → Sort v)} (coe : (f : α) → γ f) : CoeFun α γ</code>",
 "2282": "<code>outParam (α → Sort v)</code>",
 "2281":
 "<code>CoeFun.{u, v} (α : Sort u) (γ : outParam (α → Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeFun α (γ : α → Sort v)` is a coercion to a function. `γ a` should be a\n(coercion-to-)function type, and this is triggered whenever an element\n`f : α` appears in an application like `f x`, which would not make sense since\n`f` does not have a function type.\n`CoeFun` instances apply to `CoeOut` as well.\n</code>",
 "2280": "<code>y : Option Type</code>",
 "228": "<code>NatOrInt.nat : Nat → NatOrInt</code>",
 "2279": "<code>↑nat</code>",
 "2278": "<code>x : ↑nat</code>",
 "2277":
 "<code>NatOrBool → Type</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to `β`, which must be a universe. </code>",
 "2276": "<code>NatOrBool.asType : NatOrBool → Type</code>",
 "2275": "<code>NatOrBool.bool : NatOrBool</code>",
 "2274": "<code>NatOrBool.nat : NatOrBool</code>",
 "2273": "<code>NatOrBool : Type</code>",
 "2272":
 "<code><span class=\"literal string\">\"hello\"</span> : String</code>",
 "2271": "<code>Monoid</code>",
 "2270":
 "<code>Monoid → Type u</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to `β`, which must be a universe. </code>",
 "227": "<code>NatOrInt : Type</code>",
 "2269": "<code>∀ (x : String), x ++ \"\" = x</code>",
 "2268": "<code>∀ (x : String), \"\" ++ x = x</code>",
 "2267":
 "<code>String.append_assoc {s₁ s₂ s₃ : String} : s₁ ++ s₂ ++ s₃ = s₁ ++ (s₂ ++ s₃)</code>",
 "2266": "<code>∀ (x y z : String), x ++ (y ++ z) = x ++ y ++ z</code>",
 "2265": "<code>String → String → String</code>",
 "2264": "<code>StringMonoid : Monoid</code>",
 "2263":
 "<code>Monoid.op_id_identity.{u} (self : Monoid) (x : self.Carrier) : self.op x self.id = x</code>",
 "2262":
 "<code>Monoid.id_op_identity.{u} (self : Monoid) (x : self.Carrier) : self.op self.id x = x</code>",
 "2261": "<code>Carrier → Carrier → Carrier</code>",
 "2260": "<code>Carrier</code>",
 "226":
 "<code>α → Nat → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turn a value of type `α` into a `Format` at a given precedence. The precedence value can be used\nto avoid parentheses if they are not necessary.\n</code>",
 "2259":
 "<code>Monoid.op_assoc.{u} (self : Monoid) (x y z : self.Carrier) : self.op x (self.op y z) = self.op (self.op x y) z</code>",
 "2258": "<code>Monoid.id.{u} (self : Monoid) : self.Carrier</code>",
 "2257":
 "<code>Monoid.op.{u} (self : Monoid) : self.Carrier → self.Carrier → self.Carrier</code>",
 "2256": "<code>Monoid.Carrier.{u} (self : Monoid) : Type u</code>",
 "2255": "<code>Monoid.{u} : Type (u + 1)</code>",
 "2254":
 "<code>α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to `β`, which must be a universe. </code>",
 "2253":
 "<code>CoeSort.mk.{u, v} {α : Sort u} {β : outParam (Sort v)} (coe : α → β) : CoeSort α β</code>",
 "2252": "<code>outParam (Sort v)</code>",
 "2251":
 "<code>CoeSort.{u, v} (α : Sort u) (β : outParam (Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeSort α β` is a coercion to a sort. `β` must be a universe, and this is\ntriggered when `a : α` appears in a place where a type is expected, like\n`(x : a)` or `a → a`.\n`CoeSort` instances apply to `CoeOut` as well.\n</code>",
 "2250":
 "<code>Int → R</code><span class=\"sep\"></span><code class=\"docstring\">The canonical map `Int → R`. </code>",
 "225":
 "<code>Repr.mk.{u} {α : Type u} (reprPrec : α → Nat → Std.Format) : Repr α</code>",
 "2249":
 "<code>IntCast.mk.{u} {R : Type u} (intCast : Int → R) : IntCast R</code>",
 "2248":
 "<code>Nat → R</code><span class=\"sep\"></span><code class=\"docstring\">The canonical map `Nat → R`. </code>",
 "2247":
 "<code>NatCast.mk.{u} {R : Type u} (natCast : Nat → R) : NatCast R</code>",
 "2246":
 "<code>Int.ofNat : Nat → Int</code><span class=\"sep\"></span><code class=\"docstring\">A natural number is an integer.\n\nThis constructor covers the non-negative integers (from `0` to `∞`).\n</code>",
 "2245":
 "<code>IntCast.{u} (R : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The canonical homomorphism `Int → R`. In most use cases, the target type will have a ring structure,\nand this homomorphism should be a ring homomorphism.\n\n`IntCast` and `NatCast` exist to allow different libraries with their own types that can be notated\nas natural numbers to have consistent `simp` normal forms without needing to create coercion\nsimplification sets that are aware of all combinations. Libraries should make it easy to work with\n`IntCast` where possible. For instance, in Mathlib there will be such a homomorphism (and thus an\n`IntCast R` instance) whenever `R` is an additive group with a `1`.\n</code>",
 "2244": "<code>friday : Weekday</code>",
 "2243": "<code>wednesday : Weekday</code>",
 "2242":
 "<code>Fin 7 → Weekday</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2241":
 "<code>Weekday → Fin 7</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2240": "<code>Fin 7</code>",
 "224":
 "<code>α → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value to a `Format` object, with no expectation that the resulting string is valid\ncode.\n</code>",
 "2239": "<code>Weekday.fromFin : Fin 7 → Weekday</code>",
 "2238": "<code>Weekday.toFin : Weekday → Fin 7</code>",
 "2237": "<code>Weekday.su : Weekday</code>",
 "2236": "<code>Weekday.sa : Weekday</code>",
 "2235": "<code>Weekday.fr : Weekday</code>",
 "2234": "<code>Weekday.th : Weekday</code>",
 "2233": "<code>Weekday.we : Weekday</code>",
 "2232": "<code>Weekday.tu : Weekday</code>",
 "2231": "<code>Weekday.mo : Weekday</code>",
 "2230": "<code>Weekday : Type</code>",
 "223":
 "<code>Std.ToFormat.mk.{u} {α : Type u} (format : α → Std.Format) : Std.ToFormat α</code>",
 "2229":
 "<code class=\"docstring\">The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b &lt; (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b &lt; 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n</code>",
 "2228": "<code>sub' (n k : Nat) : Int</code>",
 "2227":
 "<code>Sub.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HSub`: `a - b : α` where `a b : α`. </code>",
 "2226": "<code>sub (n k : Nat) : Int</code>",
 "2225": "<code>Type ?u.31</code>",
 "2224":
 "<code>NonEmptyList α</code><span class=\"sep\"></span><code class=\"docstring\">The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. </code>",
 "2223":
 "<code>List α → NonEmptyList α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2222":
 "<code>NonEmptyList.mk.{u} {α : Type u} (contents : List α) (non_empty : contents ≠ []) : NonEmptyList α</code>",
 "2221": "<code>oneTwoThree : NonEmptyList Nat</code>",
 "2220": "<code>NonEmptyList α</code>",
 "222":
 "<code>Nat → m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Exits the scope of `count` opened tags.\n</code>",
 "2219":
 "<code>NonEmptyList α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2218":
 "<code>NonEmptyList.non_empty.{u} {α : Type u} (self : NonEmptyList α) : self.contents ≠ []</code>",
 "2217":
 "<code>NonEmptyList.contents.{u} {α : Type u} (self : NonEmptyList α) : List α</code>",
 "2216": "<code>NonEmptyList.{u} (α : Type u) : Type u</code>",
 "2215":
 "<code>CoeDep.mk.{u, v} {α : Sort u} {x✝ : α} {β : Sort v} (coe : β) : CoeDep α x✝ β</code>",
 "2214": "<code>Sort ?u.15412</code>",
 "2213": "<code>Sort ?u.15397</code>",
 "2212":
 "<code>β</code><span class=\"sep\"></span><code class=\"docstring\">The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. </code>",
 "2211":
 "<code>CoeT.mk.{u, v} {α : Sort u} {x✝ : α} {β : Sort v} (coe : β) : CoeT α x✝ β</code>",
 "2210":
 "<code>CoeT.{u, v} (α : Sort u) : α → Sort v → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeT` is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation `↑x` or by double type\nascription `((x : α) : β)`.\n\nA `CoeT` chain has the grammar `CoeHead? CoeOut* Coe* CoeTail? | CoeDep`.\n</code>",
 "221":
 "<code>Nat → m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Starts a region tagged with `tag`.\n</code>",
 "2209":
 "<code>NatCast.{u} (R : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The canonical homomorphism `Nat → R`. In most use cases, the target type will have a (semi)ring\nstructure, and this homomorphism should be a (semi)ring homomorphism.\n\n`NatCast` and `IntCast` exist to allow different libraries with their own types that can be notated\nas natural numbers to have consistent `simp` normal forms without needing to create coercion\nsimplification sets that are aware of all combinations. Libraries should make it easy to work with\n`NatCast` where possible. For instance, in Mathlib there will be such a homomorphism (and thus a\n`NatCast R` instance) whenever `R` is an additive monoid with a `1`.\n\nThe prototypical example is `Int.ofNat`.\n</code>",
 "2208":
 "<code>CoeTail.mk.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} (coe : α → β) : CoeTail α β</code>",
 "2207":
 "<code>CoeHead.mk.{u, v} {α : Sort u} {β : semiOutParam (Sort v)} (coe : α → β) : CoeHead α β</code>",
 "2206": "<code>semiOutParam (Sort v)</code>",
 "2205":
 "<code>CoeOut.mk.{u, v} {α : Sort u} {β : semiOutParam (Sort v)} (coe : α → β) : CoeOut α β</code>",
 "2204": "<code>Decision.ofBool {α : Type} : Bool → Decision α</code>",
 "2203": "<code>Truthy.toBool {α : Type} : Truthy α → Bool</code>",
 "2202": "<code>Truthy.isTrue {α : Type} (self : Truthy α) : Bool</code>",
 "2201": "<code>Truthy.val {α : Type} (self : Truthy α) : α</code>",
 "2200": "<code>Decision.maybe {α : Type} (val : α) : Decision α</code>",
 "220":
 "<code>m Nat</code><span class=\"sep\"></span><code class=\"docstring\">Gets the current column at which the next string will be emitted.\n</code>",
 "22": "<code>?_mvar.1016</code>",
 "2199": "<code>Decision.no {α : Type} : Decision α</code>",
 "2198": "<code>Decision.yes {α : Type} : Decision α</code>",
 "2197": "<code>Decision (α : Type) : Type</code>",
 "2196": "<code>Truthy (α : Type) : Type</code>",
 "2195":
 "<code>CoeOut.{u, v} (α : Sort u) (β : semiOutParam (Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeOut α β` is for coercions that are applied from left-to-right.\n</code>",
 "2194":
 "<code>CoeHead.{u, v} (α : Sort u) (β : semiOutParam (Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeHead α β` is for coercions that are applied from left-to-right at most once\nat beginning of the coercion chain.\n</code>",
 "2193": "<code>Sort ?u.8578</code>",
 "2192": "<code>Sort ?u.8515</code>",
 "2191": "<code>Sort ?u.8488</code>",
 "2190": "<code>Sort ?u.8434</code>",
 "219":
 "<code>Nat → m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Emits a newline followed by `indent` columns of indentation.\n</code>",
 "2189": "<code>Sort ?u.8389</code>",
 "2188": "<code>Sort ?u.8335</code>",
 "2187":
 "<code><span class=\"literal string\">\"three\"</span> : String</code>",
 "2186":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. </code>",
 "2185": "<code><span class=\"literal string\">\"four\"</span> : String</code>",
 "2184":
 "<code>CoeDep.{u, v} (α : Sort u) : α → (β : Sort v) → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeDep α (x : α) β` is a typeclass for dependent coercions, that is, the type `β`\ncan depend on `x` (or rather, the value of `x` is available to typeclass search\nso an instance that relates `β` to `x` is allowed).\n\nDependent coercions do not participate in the transitive chaining process of\nregular coercions: they must exactly match the type mismatch on both sides.\n</code>",
 "2183": "<code>Even.mk (number : Nat) (isEven : number % 2 = 0) : Even</code>",
 "2182": "<code>four : Even</code>",
 "2181":
 "<code>Even → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2180": "<code>Even.isEven (self : Even) : self.number % 2 = 0</code>",
 "218":
 "<code>String → m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Emits the string `s`.\n</code>",
 "2179": "<code>Even.number (self : Even) : Nat</code>",
 "2178":
 "<code>CoeT.{u, v} (α : Sort u) : α → (β : Sort v) → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeT` is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation `↑x` or by double type\nascription `((x : α) : β)`.\n\nA `CoeT` chain has the grammar `CoeHead? CoeOut* Coe* CoeTail? | CoeDep`.\n</code>",
 "2177":
 "<code>Twice.mk.{u} {α : Type u} (first second : α) (first_eq_second : first = second) : Twice α</code>",
 "2176":
 "<code>α → Twice α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2175":
 "<code class=\"docstring\">`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n</code>",
 "2174": "<code>x = x</code>",
 "2173": "<code>twice.{u} {α : Type u} (x : α) : Twice α</code>",
 "2172":
 "<code>Twice.first_eq_second.{u} {α : Type u} (self : Twice α) : self.first = self.second</code>",
 "2171": "<code>Twice.second.{u} {α : Type u} (self : Twice α) : α</code>",
 "2170": "<code>Twice.first.{u} {α : Type u} (self : Twice α) : α</code>",
 "217":
 "<code>Std.Format.MonadPrettyFormat.mk {m : Type → Type} (pushOutput : String → m Unit) (pushNewline : Nat → m Unit)\n  (currColumn : m Nat) (startTag endTags : Nat → m Unit) : Std.Format.MonadPrettyFormat m</code>",
 "2169": "<code>Twice.{u} (α : Type u) : Type u</code>",
 "2168":
 "<code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `++` in identifiers is `append`.</code>",
 "2167": "<code>x &lt; 10000</code>",
 "2166": "<code>Unit → String</code>",
 "2165": "<code>Later.mk.{u} {α : Type u} (get : Unit → α) : Later α</code>",
 "2164":
 "<code><span class=\"literal string\">\"tomorrow\"</span> : String</code>",
 "2163": "<code>tomorrow : Later String</code>",
 "2162":
 "<code>CoeTail.coe.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} [self : CoeTail α β] : α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2161": "<code>Unit → α</code>",
 "2160":
 "<code>α → Later α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "216":
 "<code>Std.Format.MonadPrettyFormat (m : Type → Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that can be used to incrementally render `Format` objects.\n</code>",
 "2159":
 "<code>CoeTail.{u, v} (α : semiOutParam (Sort u)) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeTail α β` is for coercions that can only appear at the end of a\nsequence of coercions. That is, `α` can be further coerced via `Coe σ α` and\n`CoeHead τ σ` instances but `β` will only be the expected type of the expression.\n</code>",
 "2158": "<code>Later.get.{u} {α : Type u} (self : Later α) : Unit → α</code>",
 "2157": "<code>Later.{u} (α : Type u) : Type u</code>",
 "2156":
 "<code>Coe.coe.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} [self : Coe α β] : α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2155":
 "<code>α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2154":
 "<code>Coe.mk.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} (coe : α → β) : Coe α β</code>",
 "2153": "<code>semiOutParam (Sort u)</code>",
 "2152": "<code>one : Decimal</code>",
 "2151": "<code>Array (Fin 10)</code>",
 "2150": "<code>twoHundredThirteen : Decimal</code>",
 "215": "<code>optParam Nat 0</code>",
 "2149":
 "<code>Decimal → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "2148": "<code>Fin 10</code>",
 "2147":
 "<code>Array.foldl.{u, v} {α : Type u} {β : Type v} (f : β → α → β) (init : β) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over an array from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the array in order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (inclusive) to `stop` (exclusive), so no folding occurs unless `start &lt; stop`.\nBy default, the entire array is used.\n\nExamples:\n * `#[a, b, c].foldl f z  = f (f (f z a) b) c`\n * `#[1, 2, 3].foldl (· ++ toString ·) \"\" = \"123\"`\n * `#[1, 2, 3].foldl (s!\"({·} {·})\") \"\" = \"((( 1) 2) 3)\"`\n</code>",
 "2146": "<code>Decimal</code>",
 "2145": "<code>Decimal.toNat (d : Decimal) : Nat</code>",
 "2144": "<code>Decimal.digits (self : Decimal) : Array (Fin 10)</code>",
 "2143": "<code>Decimal : Type</code>",
 "2142": "<code class=\"docstring\">Adds a definition as a coercion</code>",
 "2141":
 "<code>Bin</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "2140":
 "<code>Nat → Bin</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "214":
 "<code>Std.Format.defWidth : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The default width of the targeted output, which is 120 columns. </code>",
 "2139":
 "<code class=\"docstring\">The `@[coe]` attribute on a function (which should also appear in a\n`instance : Coe A B := ⟨myFn⟩` declaration) allows the delaborator to show\napplications of this function as `↑` when printing expressions.\n</code>",
 "2138": "<code>Bin.ofNat (n : Nat) : Bin</code>",
 "2137": "<code>Bin.succ (b : Bin) : Bin</code>",
 "2136":
 "<code>Bin → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>",
 "2135": "<code><span class=\"literal string\">\"1\"</span> : String</code>",
 "2134": "<code>Bin</code>",
 "2133": "<code>Bin.toString : Bin → String</code>",
 "2132": "<code>Bin.one : Bin → Bin</code>",
 "2131": "<code>Bin.zero : Bin → Bin</code>",
 "2130": "<code>Bin.done : Bin</code>",
 "213": "<code>optParam Nat Std.Format.defWidth</code>",
 "2129": "<code>Bin : Type</code>",
 "2128":
 "<code>Int.bdiv (x : Int) (m : Nat) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Balanced division.\n\nThis returns the unique integer so that `b * (Int.bdiv a b) + Int.bmod a b = a`.\n\nExamples:\n* `(7 : Int).bdiv 0 = 0`\n* `(0 : Int).bdiv 7 = 0`\n* `(12 : Int).bdiv 6 = 2`\n* `(12 : Int).bdiv 7 = 2`\n* `(12 : Int).bdiv 8 = 2`\n* `(12 : Int).bdiv 9 = 1`\n* `(-12 : Int).bdiv 6 = -2`\n* `(-12 : Int).bdiv 7 = -2`\n* `(-12 : Int).bdiv 8 = -1`\n* `(-12 : Int).bdiv 9 = -1`\n</code>",
 "2127":
 "<code>Unit → String</code><span class=\"sep\"></span><code class=\"docstring\">Extract the getter function out of a thunk. Use `Thunk.get` instead. </code>",
 "2126":
 "<code>Thunk.mk.{u} {α : Type u} (fn : Unit → α) : Thunk α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new thunk from a function `Unit → α` that will be called when the thunk is first\nforced.\n\nThe result is cached. It is re-used when the thunk is forced again.\n</code>",
 "2125":
 "<code>Lean.Syntax.Term : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a Lean term.\n</code>",
 "2124":
 "<code>Lean.Syntax.Ident : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents an identifier.\n</code>",
 "2123": "<code>Int → String</code>",
 "2122": "<code>th (f : Int → String) (x : Nat) : Thunk String</code>",
 "2121": "<code>Fin k</code>",
 "2120":
 "<code>Lean.TSyntax (ks : Lean.SyntaxNodeKinds) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Typed syntax, which tracks the potential kinds of the `Syntax` it contains.\n\nWhile syntax quotations produce or expect `TSyntax` values of the correct kinds, this is not\notherwise enforced; it can easily be circumvented by direct use of the constructor.\n</code>",
 "212":
 "<code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.\n\nThe `Monad` API may be used directly. However, it is most commonly accessed through\n[`do`-notation](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation).\n\nMost `Monad` instances provide implementations of `pure` and `bind`, and use default implementations\nfor the other methods inherited from `Applicative`. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of `LawfulMonad` expresses that a given\nmonad's operations are lawful.\n</code>",
 "2119":
 "<code>Thunk.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Delays evaluation. The delayed code is evaluated at most once.\n\nA thunk is code that constructs a value when it is requested via `Thunk.get`, `Thunk.map`, or\n`Thunk.bind`. The resulting value is cached, so the code is executed at most once. This is also\nknown as lazy or call-by-need evaluation.\n\nThe Lean runtime has special support for the `Thunk` type in order to implement the caching\nbehavior.\n</code>",
 "2118": "<code>elem</code>",
 "2117": "<code>Inhabited elem</code>",
 "2116":
 "<code>∀ [inst : Inhabited elem] (c : cont) (i : idx),\n  c[i]! =\n    match c[i]? with\n    | some e =&gt; e\n    | none =&gt; default</code><span class=\"sep\"></span><code class=\"docstring\">`GetElem?.getElem!` succeeds and fails when `GetElem.getElem?` succeeds and fails. </code>",
 "2115": "<code>Decidable (dom c i)</code>",
 "2114": "<code>cont</code>",
 "2113":
 "<code>∀ (c : cont) (i : idx) [inst : Decidable (dom c i)], c[i]? = if h : dom c i then some c[i] else none</code><span class=\"sep\"></span><code class=\"docstring\">`GetElem?.getElem?` succeeds when the validity predicate is satisfied and fails otherwise. </code>",
 "2112":
 "<code>LawfulGetElem.mk.{u, v, w} {cont : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {dom : outParam (cont → idx → Prop)} [ge : GetElem? cont idx elem dom]\n  (getElem?_def :\n    ∀ (c : cont) (i : idx) [inst : Decidable (dom c i)],\n      c[i]? = if h : dom c i then some c[i] else none := by\n    intros\n    try simp only [getElem?] &lt;;&gt; congr)\n  (getElem!_def :\n    ∀ [inst : Inhabited elem] (c : cont) (i : idx),\n      c[i]! =\n        match c[i]? with\n        | some e =&gt; e\n        | none =&gt; default := by\n    intros\n    simp only [getElem!, getElem?, outOfBounds_eq_default]) :\n  LawfulGetElem cont idx elem dom</code>",
 "2111": "<code>GetElem? cont idx elem dom</code>",
 "2110": "<code>outParam (cont → idx → Prop)</code>",
 "211":
 "<code>Std.Format.prettyM {m : Type → Type} (f : Std.Format) (w : Nat) (indent : Nat := 0) [Monad m]\n  [Std.Format.MonadPrettyFormat m] : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Renders a `Format` using effects in the monad `m`, using the methods of `MonadPrettyFormat`.\n\nEach line is emitted as soon as it is rendered, rather than waiting for the entire document to be\nrendered.\n* `w`: the total width\n* `indent`: the initial indentation to use for wrapped lines (subsequent wrapping may increase the\n  indentation)\n</code>",
 "2109":
 "<code>GetElem?.getElem!.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {valid : outParam (coll → idx → Prop)} [self : GetElem? coll idx elem valid] [Inhabited elem] (xs : coll) (i : idx) :\n  elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]!` gets the `i`'th element of the collection `arr`,\nif it is present, and otherwise panics at runtime and returns the `default` term\nfrom `Inhabited elem`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]!` in identifiers is `getElem!`.</code>",
 "2108":
 "<code>[Inhabited elem] → coll → idx → elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]!` gets the `i`'th element of the collection `arr`,\nif it is present, and otherwise panics at runtime and returns the `default` term\nfrom `Inhabited elem`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]!` in identifiers is `getElem!`.</code>",
 "2107":
 "<code>coll → idx → Option elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]?` gets the `i`'th element of the collection `arr`,\nif it is present (and wraps it in `some`), and otherwise returns `none`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]?` in identifiers is `getElem?`.</code>",
 "2106":
 "<code>GetElem?.mk.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)} {valid : outParam (coll → idx → Prop)}\n  [toGetElem : GetElem coll idx elem valid] (getElem? : coll → idx → Option elem)\n  (getElem! : [Inhabited elem] → coll → idx → elem) : GetElem? coll idx elem valid</code>",
 "2105": "<code>Type ?u.226954</code>",
 "2104":
 "<code>GetElem.getElem.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {valid : outParam (coll → idx → Prop)} [self : GetElem coll idx elem valid] (xs : coll) (i : idx) (h : valid xs i) :\n  elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.\n\n * The recommended spelling of `xs[i]'h` in identifiers is `getElem`.</code>",
 "2103": "<code>?m.10</code>",
 "2102":
 "<code>(xs : coll) → (i : idx) → valid xs i → elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.\n\n * The recommended spelling of `xs[i]'h` in identifiers is `getElem`.</code>",
 "2101":
 "<code>GetElem.mk.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)} {valid : outParam (coll → idx → Prop)}\n  (getElem : (xs : coll) → (i : idx) → valid xs i → elem) : GetElem coll idx elem valid</code>",
 "2100": "<code>i &lt; arr.size</code>",
 "210":
 "<code>Std.Format.pretty (f : Std.Format) (width : Nat := Std.Format.defWidth) (indent column : Nat := 0) : String</code><span class=\"sep\"></span><code class=\"docstring\">Renders a `Format` to a string.\n* `width`: the total width\n* `indent`: the initial indentation to use for wrapped lines\n  (subsequent wrapping may increase the indentation)\n* `column`: begin the first line wrap `column` characters earlier than usual\n  (this is useful when the output String will be printed starting at `column`)\n</code>",
 "21": "<code>?_mvar.1015</code>",
 "2099": "<code>Type ?u.119002</code>",
 "2098":
 "<code class=\"docstring\">`get_elem_tactic_extensible` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to try `simp +arith` and `omega`\n(for doing linear arithmetic in the index).\n\n(Note that the core tactic `get_elem_tactic` has already tried\n`done` and `assumption` before the extensible tactic is called.)\n</code>",
 "2097": "<code>?m.10 xs i</code>",
 "2096":
 "<code class=\"docstring\">`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_extensible` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_extensible` instead of this tactic.\n</code>",
 "2095": "<code>idx</code>",
 "2094": "<code>coll</code>",
 "2093":
 "<code>GetElem?.{u, v, w} (coll : Type u) (idx : Type v) (elem : outParam (Type w)) (valid : outParam (coll → idx → Prop)) :\n  Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The classes `GetElem` and `GetElem?` implement lookup notation,\nspecifically `xs[i]`, `xs[i]?`, `xs[i]!`, and `xs[i]'p`.\n\nBoth classes are indexed by types `coll`, `idx`, and `elem` which are\nthe collection, the index, and the element types.\nA single collection may support lookups with multiple index\ntypes. The relation `valid` determines when the index is guaranteed to be\nvalid; lookups of valid indices are guaranteed not to fail.\n\nFor example, an instance for arrays looks like\n`GetElem (Array α) Nat α (fun xs i =&gt; i &lt; xs.size)`. In other words, given an\narray `xs` and a natural number `i`, `xs[i]` will return an `α` when `valid xs i`\nholds, which is true when `i` is less than the size of the array. `Array`\nadditionally supports indexing with `USize` instead of `Nat`.\nIn either case, because the bounds are checked at compile time,\nno runtime check is required.\n\nGiven `xs[i]` with `xs : coll` and `i : idx`, Lean looks for an instance of\n`GetElem coll idx elem valid` and uses this to infer the type of the return\nvalue `elem` and side condition `valid` required to ensure `xs[i]` yields\na valid value of type `elem`. The tactic `get_elem_tactic` is\ninvoked to prove validity automatically. The `xs[i]'p` notation uses the\nproof `p` to satisfy the validity condition.\nIf the proof `p` is long, it is often easier to place the\nproof in the context using `have`, because `get_elem_tactic` tries\n`assumption`.\n\n\nThe proof side-condition `valid xs i` is automatically dispatched by the\n`get_elem_tactic` tactic; this tactic can be extended by adding more clauses to\n`get_elem_tactic_extensible` using `macro_rules`.\n\n`xs[i]?` and `xs[i]!` do not impose a proof obligation; the former returns\nan `Option elem`, with `none` signalling that the value isn't present, and\nthe latter returns `elem` but panics if the value isn't there, returning\n`default : elem` based on the `Inhabited elem` instance.\nThese are provided by the `GetElem?` class, for which there is a default instance\ngenerated from a `GetElem` class as long as `valid xs i` is always decidable.\n\nImportant instances include:\n  * `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`: does array\n    indexing with no runtime bounds check and a proof side goal `i &lt; arr.size`.\n  * `l[i] : α` where `l : List α` and `i : Nat`: index into a list, with proof\n    side goal `i &lt; l.length`.\n\n</code>",
 "2092":
 "<code>GetElem.{u, v, w} (coll : Type u) (idx : Type v) (elem : outParam (Type w)) (valid : outParam (coll → idx → Prop)) :\n  Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The classes `GetElem` and `GetElem?` implement lookup notation,\nspecifically `xs[i]`, `xs[i]?`, `xs[i]!`, and `xs[i]'p`.\n\nBoth classes are indexed by types `coll`, `idx`, and `elem` which are\nthe collection, the index, and the element types.\nA single collection may support lookups with multiple index\ntypes. The relation `valid` determines when the index is guaranteed to be\nvalid; lookups of valid indices are guaranteed not to fail.\n\nFor example, an instance for arrays looks like\n`GetElem (Array α) Nat α (fun xs i =&gt; i &lt; xs.size)`. In other words, given an\narray `xs` and a natural number `i`, `xs[i]` will return an `α` when `valid xs i`\nholds, which is true when `i` is less than the size of the array. `Array`\nadditionally supports indexing with `USize` instead of `Nat`.\nIn either case, because the bounds are checked at compile time,\nno runtime check is required.\n\nGiven `xs[i]` with `xs : coll` and `i : idx`, Lean looks for an instance of\n`GetElem coll idx elem valid` and uses this to infer the type of the return\nvalue `elem` and side condition `valid` required to ensure `xs[i]` yields\na valid value of type `elem`. The tactic `get_elem_tactic` is\ninvoked to prove validity automatically. The `xs[i]'p` notation uses the\nproof `p` to satisfy the validity condition.\nIf the proof `p` is long, it is often easier to place the\nproof in the context using `have`, because `get_elem_tactic` tries\n`assumption`.\n\n\nThe proof side-condition `valid xs i` is automatically dispatched by the\n`get_elem_tactic` tactic; this tactic can be extended by adding more clauses to\n`get_elem_tactic_extensible` using `macro_rules`.\n\n`xs[i]?` and `xs[i]!` do not impose a proof obligation; the former returns\nan `Option elem`, with `none` signalling that the value isn't present, and\nthe latter returns `elem` but panics if the value isn't there, returning\n`default : elem` based on the `Inhabited elem` instance.\nThese are provided by the `GetElem?` class, for which there is a default instance\ngenerated from a `GetElem` class as long as `valid xs i` is always decidable.\n\nImportant instances include:\n  * `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`: does array\n    indexing with no runtime bounds check and a proof side goal `i &lt; arr.size`.\n  * `l[i] : α` where `l : List α` and `i : Nat`: index into a list, with proof\n    side goal `i &lt; l.length`.\n\n</code>",
 "2091": "<code>outParam (coll → idx → Prop)</code>",
 "2090":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`. See `HAppend`. </code>",
 "209":
 "<code>Std.Format.bracketFill (l : String) (f : Std.Format) (r : String) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates a format `l ++ f ++ r` with a flattening group, nesting the contents by the length of `l`.\n\nThe group's `FlattenBehavior` is `fill`; for `allOrNone` use `Std.Format.bracketFill`.\n</code>",
 "2089":
 "<code>Append.mk.{u} {α : Type u} (append : α → α → α) : Append α</code>",
 "2088":
 "<code>HAppend.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous append.\nThis enables the notation `a ++ b : γ` where `a : α`, `b : β`.\n</code>",
 "2087":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `++` in identifiers is `append`.</code>",
 "2086":
 "<code>HAppend.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hAppend : α → β → γ) : HAppend α β γ</code>",
 "2085":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a ^^^ b : α`. See `HXor`. </code>",
 "2084": "<code>XorOp.mk.{u} {α : Type u} (xor : α → α → α) : XorOp α</code>",
 "2083":
 "<code>HXor.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a ^^^ b : γ` where `a : α`, `b : β`. </code>",
 "2082":
 "<code>Bool.xor : Bool → Bool → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “exclusive or”. `xor x y` can be written `x ^^ y`.\n\n`x ^^ y` is `true` when precisely one of `x` or `y` is `true`. Unlike `and` and `or`, it does not\nhave short-circuiting behavior, because one argument's value never determines the final value. Also\nunlike `and` and `or`, there is no commonly-used corresponding propositional connective.\n\nExamples:\n * `false ^^ false = false`\n * `true ^^ false = true`\n * `false ^^ true = true`\n * `true ^^ true = false`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^^` in identifiers is `xor`.</code>",
 "2081":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^^^` in identifiers is `xor`.</code>",
 "2080":
 "<code>HXor.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hXor : α → β → γ) : HXor α β γ</code>",
 "208":
 "<code>Std.Format.nest (indent : Int) (f : Std.Format) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">`nest indent f` increases the current indentation level by `indent` while rendering `f`.\n\nExample:\n```lean example\nopen Std Format in\ndef fmtList (l : List Format) : Format :=\n  let f := joinSep l  (\", \" ++ Format.line)\n  group (nest 1 &lt;| \"[\" ++ f ++ \"]\")\n```\n\nThis will be written all on one line, but if the text is too large, the formatter will put in\nlinebreaks after the commas and indent later lines by 1.\n</code>",
 "2079":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a ||| b : α`. See `HOr`. </code>",
 "2078": "<code>OrOp.mk.{u} {α : Type u} (or : α → α → α) : OrOp α</code>",
 "2077":
 "<code>OrOp.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HOr`: `a ||| b : α` where `a b : α`.\n(It is called `OrOp` because `Or` is taken for the propositional connective.)\n</code>",
 "2076":
 "<code>HOr.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a ||| b : γ` where `a : α`, `b : β`. </code>",
 "2075":
 "<code>Bool.or (x y : Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “or”, also known as disjunction. `or x y` can be written `x || y`.\n\nThe corresponding propositional connective is `Or : Prop → Prop → Prop`, written with the `∨`\noperator.\n\nThe Boolean `or` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `true` then `y` is not evaluated at runtime.\n</code>",
 "2074":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `|||` in identifiers is `or`.</code>",
 "2073":
 "<code>HOr.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hOr : α → β → γ) : HOr α β γ</code>",
 "2072":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a &&& b : α`. See `HAnd`. </code>",
 "2071": "<code>AndOp.mk.{u} {α : Type u} (and : α → α → α) : AndOp α</code>",
 "2070":
 "<code>AndOp.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAnd`: `a &&& b : α` where `a b : α`.\n(It is called `AndOp` because `And` is taken for the propositional connective.)\n</code>",
 "207": "<code>Manual.pre : Verso.Doc.Elab.CodeBlockExpander</code>",
 "2069":
 "<code>HAnd.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a &&& b : γ` where `a : α`, `b : β`. </code>",
 "2068":
 "<code>Bool.and (x y : Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “and”, also known as conjunction. `and x y` can be written `x && y`.\n\nThe corresponding propositional connective is `And : Prop → Prop → Prop`, written with the `∧`\noperator.\n\nThe Boolean `and` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `false` then `y` is not evaluated at runtime.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&` in identifiers is `and`.\n\n * The recommended spelling of `||` in identifiers is `or`.</code>",
 "2067":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&&` in identifiers is `and`.</code>",
 "2066":
 "<code>HAnd.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hAnd : α → β → γ) : HAnd α β γ</code>",
 "2065":
 "<code>α → α</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "2064": "<code>Neg.mk.{u} {α : Type u} (neg : α → α) : Neg α</code>",
 "2063":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a &gt;&gt;&gt; b : α`. See `HShiftRight`. </code>",
 "2062":
 "<code>ShiftRight.mk.{u} {α : Type u} (shiftRight : α → α → α) : ShiftRight α</code>",
 "2061":
 "<code>HShiftRight.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a &gt;&gt;&gt; b : γ` where `a : α`, `b : β`. </code>",
 "2060":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &gt;&gt;&gt; b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;&gt;` in identifiers is `shiftRight`.</code>",
 "206":
 "<code>Std.ToFormat.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Specifies a “user-facing” way to convert from the type `α` to a `Format` object. There is no\nexpectation that the resulting string is valid code.\n\nThe `Repr` class is similar, but the expectation is that instances produce valid Lean code.\n</code>",
 "2059":
 "<code>HShiftRight.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hShiftRight : α → β → γ) : HShiftRight α β γ</code>",
 "2058":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a &lt;&lt;&lt; b : α`. See `HShiftLeft`. </code>",
 "2057":
 "<code>ShiftLeft.mk.{u} {α : Type u} (shiftLeft : α → α → α) : ShiftLeft α</code>",
 "2056":
 "<code>HShiftLeft.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a &lt;&lt;&lt; b : γ` where `a : α`, `b : β`. </code>",
 "2055":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &lt;&lt;&lt; b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;&lt;&lt;` in identifiers is `shiftLeft`.</code>",
 "2054":
 "<code>HShiftLeft.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hShiftLeft : α → β → γ) : HShiftLeft α β γ</code>",
 "2053":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b` where `a` and `b` both have the same type. </code>",
 "2052":
 "<code>HomogeneousPow.mk.{u} {α : Type u} (pow : α → α → α) : HomogeneousPow α</code>",
 "2051":
 "<code>α → Nat → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ n` computes `a` to the power of `n` where `n : Nat`. See `Pow`. </code>",
 "2050":
 "<code>NatPow.mk.{u} {α : Type u} (pow : α → Nat → α) : NatPow α</code>",
 "205": "<code>List Std.Format</code>",
 "2049": "<code>?m.24</code>",
 "2048":
 "<code>Pow.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HPow`: `a ^ b : α` where `a : α`, `b : β`.\n(The right argument is not the same as the left since we often want this even\nin the homogeneous case.)\n\nTypes can choose to subscribe to particular defaulting behavior by providing\nan instance to either `NatPow` or `HomogeneousPow`:\n- `NatPow` is for types whose exponents is preferentially a `Nat`.\n- `HomogeneousPow` is for types whose base and exponent are preferentially the same.\n</code>",
 "2047":
 "<code>α → β → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`. See `HPow`. </code>",
 "2046":
 "<code>Pow.mk.{u, v} {α : Type u} {β : Type v} (pow : α → β → α) : Pow α β</code>",
 "2045":
 "<code>HomogeneousPow.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The completely homogeneous version of `Pow` where the exponent has the same type as the base.\nThe purpose of this class is that it provides a default `Pow` instance,\nwhich can be used to specialize the exponent to have the same type as the base's type during elaboration.\nThis is to say, a type should provide an instance for this class in case `x ^ y` should be elaborated\nwith both `x` and `y` having the same type.\n\nFor example, the `Float` type provides an instance of this class, which causes expressions\nsuch as `(2.2 ^ 2.2 : Float)` to elaborate. </code>",
 "2044":
 "<code>NatPow.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `Pow` where the exponent is a `Nat`.\nThe purpose of this class is that it provides a default `Pow` instance,\nwhich can be used to specialize the exponent to `Nat` during elaboration.\n\nFor example, if `x ^ 2` should preferentially elaborate with `2 : Nat` then `x`'s type should\nprovide an instance for this class. </code>",
 "2043":
 "<code>HPow.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous exponentiation.\nThis enables the notation `a ^ b : γ` where `a : α`, `b : β`.\n</code>",
 "2042":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.</code>",
 "2041":
 "<code>HPow.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hPow : α → β → γ) : HPow α β γ</code>",
 "2040":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`. See `HMod`. </code>",
 "204":
 "<code>Std.Format.isNil : Std.Format → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a `Format` is the constructor `Format.nil`.\n\nThis does not check whether the resulting rendered strings are always empty. To do that, use\n`Format.isEmpty`.\n</code>",
 "2039": "<code>Mod.mk.{u} {α : Type u} (mod : α → α → α) : Mod α</code>",
 "2038":
 "<code>HMod.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous modulo / remainder.\nThis enables the notation `a % b : γ` where `a : α`, `b : β`.\n</code>",
 "2037":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `%` in identifiers is `mod`.</code>",
 "2036":
 "<code>HMod.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hMod : α → β → γ) : HMod α β γ</code>",
 "2035": "<code>?m.3</code>",
 "2034":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.</code>",
 "2033":
 "<code>Dvd.mk.{u_1} {α : Type u_1} (dvd : α → α → Prop) : Dvd α</code>",
 "2032":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a / b` computes the result of dividing `a` by `b`. See `HDiv`. </code>",
 "2031": "<code>Div.mk.{u} {α : Type u} (div : α → α → α) : Div α</code>",
 "2030":
 "<code>HDiv.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous division.\nThis enables the notation `a / b : γ` where `a : α`, `b : β`.\n</code>",
 "203":
 "<code>Std.Format.isEmpty : Std.Format → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the given format contains no characters. </code>",
 "2029":
 "<code>Int.tdiv : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer division using the T-rounding convention.\n\nIn [the T-rounding convention][t-rounding] (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0. In this convention, `Int.tmod a b + b * (Int.tdiv a b) = a`.\n\n[t-rounding]: https://dl.acm.org/doi/pdf/10.1145/128861.128862\n\nThis function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.\n\nExamples:\n* `(7 : Int).tdiv (0 : Int) = 0`\n* `(0 : Int).tdiv (7 : Int) = 0`\n* `(12 : Int).tdiv (6 : Int) = 2`\n* `(12 : Int).tdiv (-6 : Int) = -2`\n* `(-12 : Int).tdiv (6 : Int) = -2`\n* `(-12 : Int).tdiv (-6 : Int) = 2`\n* `(12 : Int).tdiv (7 : Int) = 1`\n* `(12 : Int).tdiv (-7 : Int) = -1`\n* `(-12 : Int).tdiv (7 : Int) = -1`\n* `(-12 : Int).tdiv (-7 : Int) = 1`\n</code>",
 "2028":
 "<code>Int.fdiv : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer division using the F-rounding convention.\n\nIn the F-rounding convention (flooring division), `Int.fdiv x y` satisfies `Int.fdiv x y = ⌊x / y⌋`\nand `Int.fmod` is the unique function satisfying `Int.fmod x y + (Int.fdiv x y) * y = x`.\n\nExamples:\n* `(7 : Int).fdiv (0 : Int) = 0`\n* `(0 : Int).fdiv (7 : Int) = 0`\n* `(12 : Int).fdiv (6 : Int) = 2`\n* `(12 : Int).fdiv (-6 : Int) = -2`\n* `(-12 : Int).fdiv (6 : Int) = -2`\n* `(-12 : Int).fdiv (-6 : Int) = 2`\n* `(12 : Int).fdiv (7 : Int) = 1`\n* `(12 : Int).fdiv (-7 : Int) = -2`\n* `(-12 : Int).fdiv (7 : Int) = -2`\n* `(-12 : Int).fdiv (-7 : Int) = 1`\n</code>",
 "2027":
 "<code>Int.ediv : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer division that uses the E-rounding convention. Usually accessed via the `/` operator.\nDivision by zero is defined to be zero, rather than an error.\n\nIn the E-rounding convention (Euclidean division), `Int.emod x y` satisfies `0 ≤ Int.emod x y &lt; Int.natAbs y`\nfor `y ≠ 0` and `Int.ediv` is the unique function satisfying `Int.emod x y + (Int.ediv x y) * y = x`\nfor `y ≠ 0`.\n\nThis means that `Int.ediv x y` is `⌊x / y⌋` when `y &gt; 0` and `⌈x / y⌉` when `y &lt; 0`.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n* `(7 : Int) / (0 : Int) = 0`\n* `(0 : Int) / (7 : Int) = 0`\n* `(12 : Int) / (6 : Int) = 2`\n* `(12 : Int) / (-6 : Int) = -2`\n* `(-12 : Int) / (6 : Int) = -2`\n* `(-12 : Int) / (-6 : Int) = 2`\n* `(12 : Int) / (7 : Int) = 1`\n* `(12 : Int) / (-7 : Int) = -1`\n* `(-12 : Int) / (7 : Int) = -2`\n* `(-12 : Int) / (-7 : Int) = 2`\n</code>",
 "2026":
 "<code>Rat : Type</code><span class=\"sep\"></span><code class=\"docstring\">Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n</code>",
 "2025":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b &lt; natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.</code>",
 "2024":
 "<code>HDiv.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hDiv : α → β → γ) : HDiv α β γ</code>",
 "2023":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`. See `HMul`. </code>",
 "2022": "<code>Mul.mk.{u} {α : Type u} (mul : α → α → α) : Mul α</code>",
 "2021":
 "<code>HMul.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous multiplication.\nThis enables the notation `a * b : γ` where `a : α`, `b : β`.\n</code>",
 "2020":
 "<code>M → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions. </code>",
 "202": "<code><span class=\"literal string\">\"\"</span> : String</code>",
 "2019":
 "<code>SMul.mk.{u, v} {M : Type u} {α : Type v} (smul : M → α → α) : SMul M α</code>",
 "2018":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>",
 "2017":
 "<code>HMul.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hMul : α → β → γ) : HMul α β γ</code>",
 "2016":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`. See `HSub`. </code>",
 "2015": "<code>Sub.mk.{u} {α : Type u} (sub : α → α → α) : Sub α</code>",
 "2014":
 "<code>HSub.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous subtraction.\nThis enables the notation `a - b : γ` where `a : α`, `b : β`.\n</code>",
 "2013":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>",
 "2012":
 "<code>HSub.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hSub : α → β → γ) : HSub α β γ</code>",
 "2011":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "2010": "<code>?m.20</code>",
 "201":
 "<code>Std.Format.nil : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">The empty format. </code>",
 "2009":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>",
 "2008":
 "<code>HAdd.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hAdd : α → β → γ) : HAdd α β γ</code>",
 "2007": "<code>outParam (Type w)</code>",
 "2006":
 "<code>n ≠ 0</code><span class=\"sep\"></span><code class=\"docstring\">The proposition that `n` is not zero. </code>",
 "2005":
 "<code>NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n ≠ 0) : NeZero n</code>",
 "2004": "<code>R</code>",
 "2003":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The zero element of the type. </code>",
 "2002": "<code>Zero.mk.{u} {α : Type u} (zero : α) : Zero α</code>",
 "2001": "<code>α = β</code>",
 "2000": "<code>Subsingleton α</code>",
 "200":
 "<code>Std.Format.FlattenBehavior.allOrNone : Std.Format.FlattenBehavior</code><span class=\"sep\"></span><code class=\"docstring\">Either all `Format.line`s in the group will be newlines, or all of them will be spaces.\n</code>",
 "20":
 "<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "2":
 "<code>IO : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that supports arbitrary side effects and throwing exceptions of type `IO.Error`.\n</code>",
 "1999":
 "<code>∀ (a b : α), a = b</code><span class=\"sep\"></span><code class=\"docstring\">Any two elements of a subsingleton are equal. </code>",
 "1998":
 "<code>Subsingleton.intro.{u} {α : Sort u} (allEq : ∀ (a b : α), a = b) : Subsingleton α</code><span class=\"sep\"></span><code class=\"docstring\">Prove that `α` is a subsingleton by showing that any two elements are equal. </code>",
 "1997":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "1996":
 "<code>Inhabited.mk.{u} {α : Sort u} (default : α) : Inhabited α</code>",
 "1995": "<code>¬p → q</code>",
 "1994": "<code>p → q</code>",
 "1993":
 "<code>Decidable.decide (p : Prop) [h : Decidable p] : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Converts a decidable proposition into a `Bool`.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the Boolean value\nthat is `true` if `p` is true and `false` if `p` is false.\n</code>",
 "1992": "<code>Decidable p</code>",
 "1991": "<code>α → β → Prop</code>",
 "1990": "<code>p</code>",
 "199":
 "<code>Std.Format.FlattenBehavior : Type</code><span class=\"sep\"></span><code class=\"docstring\">Determines how groups should have linebreaks inserted when the text would overfill its remaining\nspace.\n\n- `allOrNone` will make a linebreak on every `Format.line` in the group or none of them.\n  ```\n  [1,\n   2,\n   3]\n  ```\n- `fill` will only make linebreaks on as few `Format.line`s as possible:\n  ```\n  [1, 2,\n   3]\n  ```\n</code>",
 "1989": "<code>¬p</code>",
 "1988":
 "<code class=\"docstring\">Theorems tagged with the `simp` attribute are used by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nYou can instruct the simplifier to rewrite the lemma from right-to-left:\n```lean\nattribute @[simp ←] and_assoc\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nThe equational theorems of functions are applied at very low priority (100 and below).\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=\n  propext &lt;| Iff.intro (fun _ =&gt; trivial) (fun _ =&gt; Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by\n  cases d &lt;;&gt; rfl\n```\n</code>",
 "1987":
 "<code>DecidableRel.{u, v} {α : Sort u} {β : Sort v} (r : α → β → Prop) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">A decidable relation.\n\nA relation is decidable if the corresponding proposition is `Decidable` for all possible arguments.\n</code>",
 "1986":
 "<code>Max.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">An overloaded operation to find the greater of two values of type `α`.\n</code>",
 "1985":
 "<code>Min.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">An overloaded operation to find the lesser of two values of type `α`.\n</code>",
 "1984":
 "<code>maxOfLe.{u_1} {α : Type u_1} [LE α] [DecidableRel LE.le] : Max α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a `Max` instance from a decidable `≤` operation.\n</code>",
 "1983":
 "<code>minOfLe.{u_1} {α : Type u_1} [LE α] [DecidableRel LE.le] : Min α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a `Min` instance from a decidable `≤` operation.\n</code>",
 "1982":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the greater of its two arguments. </code>",
 "1981": "<code>Max.mk.{u} {α : Type u} (max : α → α → α) : Max α</code>",
 "1980":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the lesser of its two arguments. </code>",
 "198":
 "<code>optParam.{u} (α : Sort u) (default : α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n</code>",
 "1979": "<code>Min.mk.{u} {α : Type u} (min : α → α → α) : Min α</code>",
 "1978": "<code>?m.2</code>",
 "1977":
 "<code>leOfOrd.{u_1} {α : Type u_1} [Ord α] : LE α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an `LT` instance from an `Ord` instance that asserts that the result of `compare`\nsatisfies `Ordering.isLE`.\n</code>",
 "1976":
 "<code>ltOfOrd.{u_1} {α : Type u_1} [Ord α] : LT α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an `LT` instance from an `Ord` instance that asserts that the result of `compare` is\n`Ordering.lt`.\n</code>",
 "1975": "<code>sweetPotato : Vegetable</code>",
 "1974": "<code>Fin 5</code>",
 "1973": "<code>Fin 5</code>",
 "1972": "<code>broccoli : Vegetable</code>",
 "1971": "<code>Vegetable.size (self : Vegetable) : Fin 5</code>",
 "1970": "<code>Vegetable.color (self : Vegetable) : String</code>",
 "197":
 "<code>optParam Std.Format.FlattenBehavior Std.Format.FlattenBehavior.allOrNone</code>",
 "1969": "<code>Vegetable : Type</code>",
 "1968":
 "<code>Ordering.isLE : Ordering → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the ordering is `lt` or `eq`.\n</code>",
 "1967":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "1966": "<code>LE.mk.{u} {α : Type u} (le : α → α → Prop) : LE α</code>",
 "1965":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>",
 "1964": "<code>LT.mk.{u} {α : Type u} (lt : α → α → Prop) : LT α</code>",
 "1963": "<code>α → β → Ordering</code>",
 "1962":
 "<code>compareOfLessAndEq.{u_1} {α : Type u_1} (x y : α) [LT α] [Decidable (x &lt; y)] [DecidableEq α] : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Uses decidable less-than and equality relations to find an `Ordering`.\n\nIn particular, if `x &lt; y` then the result is `Ordering.lt`. If `x = y` then the result is\n`Ordering.eq`. Otherwise, it is `Ordering.gt`.\n\n`compareOfLessAndBEq` uses `BEq` instead of `DecidableEq`.\n</code>",
 "1961":
 "<code>compareOfLessAndBEq.{u_1} {α : Type u_1} (x y : α) [LT α] [Decidable (x &lt; y)] [BEq α] : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Uses a decidable less-than relation and Boolean equality to find an `Ordering`.\n\nIn particular, if `x &lt; y` then the result is `Ordering.lt`. If `x == y` then the result is\n`Ordering.eq`. Otherwise, it is `Ordering.gt`.\n\n`compareOfLessAndEq` uses `DecidableEq` instead of `BEq`.\n</code>",
 "1960": "<code>Person</code>",
 "196": "<code><span class=\"literal string\">\"]\"</span> : String</code>",
 "1959":
 "<code>Person → Person → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compare two elements in `α` using the comparator contained in an `[Ord α]` instance. </code>",
 "1958": "<code>Person.age (self : Person) : Nat</code>",
 "1957": "<code>Person.name (self : Person) : String</code>",
 "1956": "<code>Person : Type</code>",
 "1955":
 "<code>compareLex.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} (cmp₁ cmp₂ : α → β → Ordering) (a : α) (b : β) : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compares `a` and `b` lexicographically by `cmp₁` and `cmp₂`.\n\n`a` and `b` are first compared by `cmp₁`. If this returns `Ordering.eq`, `a` and `b` are compared\nby `cmp₂` to break the tie.\n\nTo lexicographically combine two `Ordering`s, use `Ordering.then`.\n</code>",
 "1954":
 "<code>Ordering.then (a b : Ordering) : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">If `a` and `b` are `Ordering`, then `a.then b` returns `a` unless it is `.eq`, in which case it\nreturns `b`. Additionally, it has “short-circuiting” behavior similar to boolean `&&`: if `a` is not\n`.eq` then the expression for `b` is not evaluated.\n\nThis is a useful primitive for constructing lexicographic comparator functions. The `deriving Ord`\nsyntax on a structure uses the `Ord` instance to compare each field in order, combining the results\nequivalently to `Ordering.then`.\n\nUse `compareLex` to lexicographically combine two comparison functions.\n\nExamples:\n```lean example\nstructure Person where\n  name : String\n  age : Nat\n\n-- Sort people first by name (in ascending order), and people with the same name by age (in\n-- descending order)\ninstance : Ord Person where\n  compare a b := (compare a.name b.name).then (compare b.age a.age)\n```\n\n```lean example\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Dana\", 50⟩\n```\n```output\nOrdering.gt\n```\n\n```lean example\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Gert\", 50⟩\n```\n```output\nOrdering.gt\n```\n\n```lean example\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Gert\", 20⟩\n```\n```output\nOrdering.lt\n```\n</code>",
 "1953": "<code>Ordering</code>",
 "1952":
 "<code>Ordering.swap : Ordering → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Swaps less-than and greater-than ordering results.\n\nExamples:\n* `Ordering.lt.swap = Ordering.gt`\n* `Ordering.eq.swap = Ordering.eq`\n* `Ordering.gt.swap = Ordering.lt`\n</code>",
 "1951":
 "<code>Ordering.eq : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Equal. </code>",
 "1950":
 "<code>Max.max.{u} {α : Type u} [self : Max α] : α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the greater of its two arguments. </code>",
 "195": "<code><span class=\"literal string\">\"[\"</span> : String</code>",
 "1949":
 "<code>List.foldl.{u, v} {α : Type u} {β : Type v} (f : α → β → α) (init : α) : List β → α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nExamples:\n * `[a, b, c].foldl f z  = f (f (f z a) b) c`\n * `[1, 2, 3].foldl (· ++ toString ·) \"\" = \"123\"`\n * `[1, 2, 3].foldl (s!\"({·} {·})\") \"\" = \"((( 1) 2) 3)\"`\n</code>",
 "1948":
 "<code>Ordering.gt : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Greater than. </code>",
 "1947":
 "<code><span class=\"literal string\">\"banana\"</span> : String</code>",
 "1946":
 "<code><span class=\"literal string\">\"apple\"</span> : String</code>",
 "1945":
 "<code>String.length (b : String) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the length of a string in Unicode code points.\n\nExamples:\n* `\"\".length = 0`\n* `\"abc\".length = 3`\n* `\"L∃∀N\".length = 4`\n</code>",
 "1944":
 "<code>compareOn.{u_1, u_2} {β : Type u_1} {α : Sort u_2} [ord : Ord β] (f : α → β) (x y : α) : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compares two values by comparing the results of applying a function.\n\nIn particular, `x` is compared to `y` by comparing `f x` and `f y`.\n\nExamples:\n* `compareOn (·.length) \"apple\" \"banana\" = .lt`\n* `compareOn (· % 3) 5 6 = .gt`\n* `compareOn (·.foldl max 0) [1, 2, 3] [3, 2, 1] = .eq`\n</code>",
 "1943": "<code>Ord β</code>",
 "1942":
 "<code>α → α → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compare two elements in `α` using the comparator contained in an `[Ord α]` instance. </code>",
 "1941":
 "<code>Ord.mk.{u} {α : Type u} (compare : α → α → Ordering) : Ord α</code>",
 "1940":
 "<code>LE.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`LE α` is the typeclass which supports the notation `x ≤ y` where `x y : α`.</code>",
 "194": "<code><span class=\"literal string\">\", \"</span> : String</code>",
 "1939":
 "<code>LT.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`LT α` is the typeclass which supports the notation `x &lt; y` where `x y : α`.</code>",
 "1938":
 "<code>Ordering : Type</code><span class=\"sep\"></span><code class=\"docstring\">The result of a comparison according to a total order.\n\nThe relationship between the compared items may be:\n* `Ordering.lt`: less than\n* `Ordering.eq`: equal\n* `Ordering.gt`: greater than\n</code>",
 "1937":
 "<code>LawfulHashable.{u} (α : Type u) [BEq α] [Hashable α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">The `BEq α` and `Hashable α` instances on `α` are compatible. This means that that `a == b` implies\n`hash a = hash b`.\n\nThis is automatic if the `BEq` instance is lawful.\n</code>",
 "1936":
 "<code>Hashable.hash.{u} {α : Sort u} [self : Hashable α] : α → UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Hashes a value into a `UInt64`. </code>",
 "1935":
 "<code>∀ (a b : α), (a == b) = true → hash a = hash b</code><span class=\"sep\"></span><code class=\"docstring\">If `a == b`, then `hash a = hash b`. </code>",
 "1934":
 "<code>LawfulHashable.mk.{u} {α : Type u} [BEq α] [Hashable α] (hash_eq : ∀ (a b : α), (a == b) = true → hash a = hash b) :\n  LawfulHashable α</code>",
 "1933":
 "<code>PartialEquivBEq.{u_1} (α : Type u_1) [BEq α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`PartialEquivBEq α` says that the `BEq` implementation is a\npartial equivalence relation, that is:\n* it is symmetric: `a == b → b == a`\n* it is transitive: `a == b → b == c → a == c`.\n</code>",
 "1932":
 "<code>EquivBEq.mk.{u_1} {α : Type u_1} [BEq α] [toPartialEquivBEq : PartialEquivBEq α] [toReflBEq : ReflBEq α] : EquivBEq α</code>",
 "1931":
 "<code>EquivBEq.{u_1} (α : Type u_1) [BEq α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`EquivBEq` says that the `BEq` implementation is an equivalence relation. </code>",
 "1930":
 "<code>∀ {a : α}, (a == a) = true</code><span class=\"sep\"></span><code class=\"docstring\">`==` is reflexive, that is, `(a == a) = true`. </code>",
 "193": "<code>fmtList (l : List Format) : Format</code>",
 "1929":
 "<code>ReflBEq.mk.{u_1} {α : Type u_1} [BEq α] (rfl : ∀ {a : α}, (a == a) = true) : ReflBEq α</code>",
 "1928": "<code>?m.11</code>",
 "1927":
 "<code>∀ {a b : α}, (a == b) = true → a = b</code><span class=\"sep\"></span><code class=\"docstring\">If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. </code>",
 "1926":
 "<code>LawfulBEq.mk.{u} {α : Type u} [BEq α] [toReflBEq : ReflBEq α] (eq_of_beq : ∀ {a b : α}, (a == b) = true → a = b) :\n  LawfulBEq α</code>",
 "1925":
 "<code>α → UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Hashes a value into a `UInt64`. </code>",
 "1924":
 "<code>Hashable.mk.{u} {α : Sort u} (hash : α → UInt64) : Hashable α</code>",
 "1923": "<code>α → α → Bool</code>",
 "1922":
 "<code>α → α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1921":
 "<code>Lean.Elab.Command.elabCommand (stx : Syntax) : CommandElabM Unit</code>",
 "1920":
 "<code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code>",
 "192": "<code>Format</code>",
 "1919": "<code>TSyntax `command</code>",
 "1918":
 "<code>Lean.Parser.Term.matchAltExpr : Parser</code><span class=\"sep\"></span><code class=\"docstring\">Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... =&gt; $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). </code>",
 "1917":
 "<code>Lean.Syntax.mkNumLit (val : String) (info : SourceInfo := SourceInfo.none) : NumLit</code>",
 "1916": "<code>NumLit</code>",
 "1915": "<code>Lean.mkIdent (val : Name) : Ident</code>",
 "1914": "<code>Ident</code>",
 "1913":
 "<code>Lean.InductiveVal.ctors (self : InductiveVal) : List Name</code><span class=\"sep\"></span><code class=\"docstring\">List of the names of the constructors for this inductive datatype. </code>",
 "1912": "<code>Array (TSyntax `Lean.Parser.Term.matchAltExpr)</code>",
 "1911":
 "<code>Lean.Parser.Term.matchAlt (rhsParser : Parser := termParser) : Parser</code>",
 "1910":
 "<code>Lean.TSyntax (ks : SyntaxNodeKinds) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Typed syntax, which tracks the potential kinds of the `Syntax` it contains.\n\nWhile syntax quotations produce or expect `TSyntax` values of the correct kinds, this is not\notherwise enforced; it can easily be circumvented by direct use of the constructor.\n</code>",
 "191": "<code>Std.Format</code>",
 "1909": "<code>Array (TSyntax `Lean.Parser.Term.matchAlt)</code>",
 "1908":
 "<code>Lean.Environment.find? (env : Environment) (n : Name) (skipRealize : Bool := false) : Option ConstantInfo</code><span class=\"sep\"></span><code class=\"docstring\">Like `findAsync?`, but blocks until the constant's info is fully available.  </code>",
 "1907": "<code>InductiveVal</code>",
 "1906":
 "<code>Lean.ConstantInfo.inductInfo (val : InductiveVal) : ConstantInfo</code>",
 "1905":
 "<code>Lean.MonadEnv.getEnv {m : Type → Type} [self : MonadEnv m] : m Environment</code>",
 "1904": "<code>Environment</code>",
 "1903": "<code>declNames.size = 1</code>",
 "1902": "<code>Array Name</code>",
 "1901":
 "<code>deriveIsEnum (declNames : Array Name) : CommandElabM Bool</code>",
 "1900":
 "<code>∀ (x : Bool),\n  (match\n      match x with\n      | false =&gt; 0\n      | true =&gt; 1 with\n    | 0 =&gt; false\n    | 1 =&gt; true) =\n    x</code>",
 "190":
 "<code>Int : Type</code><span class=\"sep\"></span><code class=\"docstring\">The integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n</code>",
 "19":
 "<code>HAdd.hAdd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAdd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>",
 "1899":
 "<code>∀ (x : Fin 2),\n  (match\n      match x with\n      | 0 =&gt; false\n      | 1 =&gt; true with\n    | false =&gt; 0\n    | true =&gt; 1) =\n    x</code>",
 "1898": "<code>Fin 2</code>",
 "1897": "<code>Fin 2 → Bool</code>",
 "1896": "<code>Bool → Fin 2</code>",
 "1895":
 "<code>IsEnum.from_to_id {α : Type} [self : IsEnum α] (x : α) : self.fromIdx (self.toIdx x) = x</code>",
 "1894": "<code>Fin size → α</code>",
 "1893": "<code>α → Fin size</code>",
 "1892": "<code>Fin size</code>",
 "1891":
 "<code>IsEnum.to_from_id {α : Type} [self : IsEnum α] (i : Fin (self.size α)) : self.toIdx (self.fromIdx i) = i</code>",
 "1890":
 "<code>IsEnum.fromIdx {α : Type} [self : IsEnum α] : Fin (self.size α) → α</code>",
 "189":
 "<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>",
 "1889":
 "<code>IsEnum.toIdx {α : Type} [self : IsEnum α] : α → Fin (self.size α)</code>",
 "1888": "<code>IsEnum.size (α : Type) [self : IsEnum α] : Nat</code>",
 "1887": "<code>IsEnum (α : Type) : Type</code>",
 "1886": "<code>Lean.Elab.DerivingHandler : Type</code>",
 "1885": "<code>DerivingHandler</code>",
 "1884": "<code>Name</code>",
 "1883":
 "<code>TypeName.{u} (α : Type u) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Dynamic type name information.\nTypes with an instance of `TypeName` can be stored in an `Dynamic`.\nThe type class contains the declaration name of the type,\nwhich must not have any universe parameters\nand be of type `Sort ..` (i.e., monomorphic).\n\nThe preferred way to declare instances of this type is using the derive\nhandler, which will internally use the unsafe `TypeName.mk` function.\n\nMorally, this is the same as:\n```lean\nclass TypeName (α : Type) where unsafe mk ::\n  typeName : Name\n```\n</code>",
 "1882":
 "<code>ReflBEq.{u_1} (α : Type u_1) [BEq α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`ReflBEq α` says that the `BEq` implementation is reflexive. </code>",
 "1881":
 "<code>LawfulBEq.{u} (α : Type u) [BEq α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A Boolean equality test coincides with propositional equality.\n\nIn other words:\n* `a == b` implies `a = b`.\n* `a == a` is true.\n</code>",
 "1880":
 "<code>Hashable.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Types that can be hashed into a `UInt64`. </code>",
 "188": "<code>Bool</code>",
 "1879":
 "<code>Lean.Elab.registerDerivingHandler (className : Name) (handler : DerivingHandler) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Registers a deriving handler for a class. This function should be called in an `initialize` block.\n\nA `DerivingHandler` is called on the fully qualified names of all types it is running for. For\nexample, `deriving instance Foo for Bar, Baz` invokes ``fooHandler #[`Bar, `Baz]``.\n</code>",
 "1878": "<code>instReprB : Repr B</code>",
 "1877": "<code>instReprA : Repr A</code>",
 "1876": "<code>instBEqB : BEq B</code>",
 "1875": "<code>instBEqA : BEq A</code>",
 "1874":
 "<code>backward.synthInstance.canonInstances</code><span class=\"sep\"></span><code class=\"docstring\">use optimization that relies on 'morally canonical' instances during type class resolution</code>",
 "1873":
 "<code>OneSmaller.shrink {α : Type} {β : semiOutParam Type} [self : OneSmaller α β] (x : α) : x ≠ OneSmaller.biggest β → β</code>",
 "1872":
 "<code>OneSmaller.shrink {α : Type} {β : semiOutParam Type} [self : OneSmaller α β] (x : α) : x ≠ self.biggest β → β</code>",
 "1871":
 "<code>OneSmaller.biggest {α : Type} (β : semiOutParam Type) [self : OneSmaller α β] : α</code>",
 "1870": "<code>semiOutParam Type</code>",
 "187":
 "<code>Std.Format.indentD (f : Format) : Format</code><span class=\"sep\"></span><code class=\"docstring\">Insert a newline and then `f`, all nested by the default indent amount. </code>",
 "1869": "<code>OneSmaller (α : Type) (β : semiOutParam Type) : Type</code>",
 "1868": "<code>Type ?u.7545</code>",
 "1867":
 "<code>OneSmaller.shrink {α : Type} {β : outParam Type} [self : OneSmaller α β] (x : α) : x ≠ OneSmaller.biggest → β</code>",
 "1866": "<code>(x : Bool) → x ≠ true → Unit</code>",
 "1865": "<code>Bool</code>",
 "1864": "<code>(x : Option Bool) → x ≠ some true → Option Unit</code>",
 "1863": "<code>Option Bool</code>",
 "1862": "<code>(x : Option α) → x ≠ none → α</code>",
 "1861": "<code>Option α</code>",
 "1860":
 "<code>OneSmaller.shrink {α : Type} {β : outParam Type} [self : OneSmaller α β] (x : α) : x ≠ self.biggest → β</code>",
 "186":
 "<code><span class=\"literal string\">\"It is:\"</span> : String</code>",
 "1859":
 "<code>OneSmaller.biggest {α : Type} {β : outParam Type} [self : OneSmaller α β] : α</code>",
 "1858": "<code>OneSmaller (α : Type) (β : outParam Type) : Type</code>",
 "1857":
 "<code>Serialize.ser {input : Type} {output : outParam Type} [self : Serialize input output] : input → output</code>",
 "1856": "<code>outParam Type</code>",
 "1855":
 "<code>Serialize (input : Type) (output : outParam Type) : Type</code>",
 "1854": "<code>α × β → γ</code>",
 "1853": "<code>Nat → String</code>",
 "1852":
 "<code>Serialize.ser {input output : Type} [self : Serialize input output] : input → output</code>",
 "1851": "<code>Serialize (input output : Type) : Type</code>",
 "1850": "<code>instInhabitedNat : Inhabited Nat</code>",
 "185":
 "<code><span class=\"literal string\">\"abc\\nxyz\\n123\"</span> : String</code>",
 "1849":
 "<code>instNonemptyOfInhabited.{u} {α : Sort u} [Inhabited α] : Nonempty α</code>",
 "1848":
 "<code>aNonemptySumInstance (α : Type) {β : Type} [inst : Nonempty α] : Nonempty (Sum α β)</code>",
 "1847":
 "<code>pp.explicit</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display implicit arguments</code>",
 "1846":
 "<code>Sum.inl.{u, v} {α : Type u} {β : Type v} (val : α) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Left injection into the sum type `α ⊕ β`. </code>",
 "1845":
 "<code>Nonempty.intro.{u} {α : Sort u} (val : α) : Nonempty α</code><span class=\"sep\"></span><code class=\"docstring\">If `val : α`, then `α` is nonempty. </code>",
 "1844": "<code>Nonempty α</code>",
 "1843":
 "<code>aNonemptySumInstance (α : Type) {β : Type} [inst : Nonempty α] : Nonempty (α ⊕ β)</code>",
 "1842":
 "<code>NatPair → NatPair → NatPair</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1841": "<code>NatPair.mk (x y : Nat) : NatPair</code>",
 "1840": "<code>Add.mk.{u} {α : Type u} (add : α → α → α) : Add α</code>",
 "184": "<code>str : Format</code>",
 "1839": "<code>NatPair</code>",
 "1838": "<code>NatPair.y (self : NatPair) : Nat</code>",
 "1837": "<code>NatPair.x (self : NatPair) : Nat</code>",
 "1836": "<code>NatPair : Type</code>",
 "1835": "<code>addPairs (p1 p2 : NatPair) : NatPair</code>",
 "1834":
 "<code>synthInstance.maxSize</code><span class=\"sep\"></span><code class=\"docstring\">maximum number of instances used to construct a solution in the type class instance synthesis procedure</code>",
 "1833": "<code>foo : Inhabited (Nat × Nat)</code>",
 "1832": "<code>Even</code>",
 "1831":
 "<code>ofNatEvenPlusTwo {n : Nat} [OfNat Even n] : OfNat Even (n + 2)</code>",
 "1830": "<code>Even.mk (half : Nat) : Even</code>",
 "183": "<code>str : Std.Format</code>",
 "1829":
 "<code>Even</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1828": "<code>ofNatEven0 : OfNat Even 0</code>",
 "1827": "<code>Even.half (self : Even) : Nat</code>",
 "1826": "<code>Even : Type</code>",
 "1825": "<code class=\"docstring\">type class default instance</code>",
 "1824": "<code>Decidable (t1 = t1)</code>",
 "1823": "<code>Decidable (t1 = t2)</code>",
 "1822": "<code>instDecidableEqStringList : DecidableEq StringList</code>",
 "1821": "<code>¬h1 = h1</code>",
 "1820": "<code>¬h1 = h2</code>",
 "182":
 "<code>Std.Format.fill (f : Format) : Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates a group in which as few `Format.line`s as possible are rendered as newlines.\n\nThis is an alias for `Format.group`, with `FlattenBehavior` set to `fill`.\n</code>",
 "1819": "<code>¬t1 = t1</code>",
 "1818": "<code>h1 = h1</code>",
 "1817": "<code>StringList.cons h1 t1 = StringList.cons h2 t2</code>",
 "1816": "<code>¬t1 = t2</code>",
 "1815": "<code>t1 = t2</code>",
 "1814": "<code>h1 = h2</code>",
 "1813": "<code>StringList</code>",
 "1812":
 "<code>StringList.cons (hd : String) (tl : StringList) : StringList</code>",
 "1811": "<code>StringList.nil : StringList</code>",
 "1810": "<code>StringList : Type</code>",
 "181": "<code>filled : Format</code>",
 "1809":
 "<code>Decidable.isFalse {p : Prop} (h : ¬p) : Decidable p</code><span class=\"sep\"></span><code class=\"docstring\">Proves that `p` is decidable by supplying a proof of `¬p` </code>",
 "1808":
 "<code>Decidable.isTrue {p : Prop} (h : p) : Decidable p</code><span class=\"sep\"></span><code class=\"docstring\">Proves that `p` is decidable by supplying a proof of `p` </code>",
 "1807": "<code>ThreeChoices.maybe : ThreeChoices</code>",
 "1806": "<code>ThreeChoices.no : ThreeChoices</code>",
 "1805": "<code>ThreeChoices.yes : ThreeChoices</code>",
 "1804": "<code>ThreeChoices : Type</code>",
 "1803":
 "<code>DecidableEq.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Propositional equality is `Decidable` for all elements of a type.\n\nIn other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is\nfor all `a b : α`.\n</code>",
 "1802": "<code>NatRoseTree</code>",
 "1801": "<code>NatRoseTree.beq (tree1 tree2 : NatRoseTree) : Bool</code>",
 "1800": "<code>Array NatRoseTree</code>",
 "180": "<code>grouped : Format</code>",
 "18":
 "<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>",
 "1799":
 "<code>NatRoseTree.node (val : Nat) (children : Array NatRoseTree) : NatRoseTree</code>",
 "1798": "<code>NatRoseTree : Type</code>",
 "1797": "<code>NatTree.beq : NatTree → NatTree → Bool</code>",
 "1796":
 "<code>NatTree → NatTree → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1795": "<code>NatTree</code>",
 "1794":
 "<code>NatTree.branch (left : NatTree) (val : Nat) (right : NatTree) : NatTree</code>",
 "1793": "<code>NatTree.leaf : NatTree</code>",
 "1792": "<code>NatTree : Type</code>",
 "1791": "<code>instBeqNatWrapper : BEq NatWrapper</code>",
 "1790": "<code>NatWrapper</code>",
 "179":
 "<code>Std.Format.fill (f : Std.Format) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates a group in which as few `Format.line`s as possible are rendered as newlines.\n\nThis is an alias for `Format.group`, with `FlattenBehavior` set to `fill`.\n</code>",
 "1789": "<code>BEq.mk.{u} {α : Type u} (beq : α → α → Bool) : BEq α</code>",
 "1788": "<code>instBEqNatWrapper : BEq NatWrapper</code>",
 "1787":
 "<code>NatWrapper → NatWrapper → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1786": "<code>NatWrapper.val (self : NatWrapper) : Nat</code>",
 "1785": "<code>NatWrapper : Type</code>",
 "1784": "<code>AddMul'.{u} (α : Type u) : Type u</code>",
 "1783": "<code>AddMul.{u} (α : Type u) : Type u</code>",
 "1782":
 "<code class=\"docstring\">Expands\n```\nclass abbrev C &lt;params&gt; := D_1, ..., D_n\n```\ninto\n```\nclass C &lt;params&gt; extends D_1, ..., D_n\nattribute [instance] C.mk\n```\n</code>",
 "1781":
 "<code>Mul.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HMul`: `a * b : α` where `a b : α`. </code>",
 "1780":
 "<code>plusTimes2.{u_1} {α : Type u_1} [AddMul' α] (x y z : α) : α</code>",
 "178": "<code>filled : Std.Format</code>",
 "1779":
 "<code>plusTimes1.{u_1} {α : Type u_1} [AddMul α] (x y z : α) : α</code>",
 "1778":
 "<code>Heap'.insert.{u_1} {α : Type u_1} [Ord α] (x : α) (xs : Heap' α) : Heap' α</code>",
 "1777": "<code>Heap' α</code>",
 "1776": "<code>Ord α</code>",
 "1775":
 "<code>Heap'.bubbleUp.{u_1} {α : Type u_1} [inst : Ord α] (i : Nat) (xs : Heap' α) : Heap' α</code>",
 "1774":
 "<code>Heap'.contents.{u} {α : Type u} [Ord α] (self : Heap' α) : Array α</code>",
 "1773": "<code>Heap'.{u} (α : Type u) [Ord α] : Type u</code>",
 "1772":
 "<code>Heap.insert.{u_1} {α : Type u_1} [Ord α] (x : α) (xs : Heap α) : Heap α</code>",
 "1771":
 "<code>Array.swap.{u} {α : Type u} (xs : Array α) (i j : Nat) (hi : i &lt; xs.size := by get_elem_tactic)\n  (hj : j &lt; xs.size := by get_elem_tactic) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps two elements of an array. The modification is performed in-place when the reference to the\narray is unique.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 0 3 = #[\"brown\", \"green\", \"blue\", \"red\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 0 2 = #[\"blue\", \"green\", \"red\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 1 2 = #[\"red\", \"blue\", \"green\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 3 0 = #[\"brown\", \"green\", \"blue\", \"red\"]`\n</code>",
 "1770": "<code>Array α</code>",
 "177": "<code>grouped : Std.Format</code>",
 "1769":
 "<code>Ordering.lt : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Less than. </code>",
 "1768":
 "<code>Ord.compare.{u} {α : Type u} [self : Ord α] : α → α → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compare two elements in `α` using the comparator contained in an `[Ord α]` instance. </code>",
 "1767": "<code>i ≥ xs.contents.size</code>",
 "1766": "<code>i = 0</code>",
 "1765": "<code>Heap α</code>",
 "1764":
 "<code>Ord.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Ord α` provides a computable total order on `α`, in terms of the\n`compare : α → α → Ordering` function.\n\nTypically instances will be transitive, reflexive, and antisymmetric,\nbut this is not enforced by the typeclass.\n\nThere is a derive handler, so appending `deriving Ord` to an inductive type or structure\nwill attempt to create an `Ord` instance.\n</code>",
 "1763":
 "<code>Heap.bubbleUp.{u_1} {α : Type u_1} [Ord α] (i : Nat) (xs : Heap α) : Heap α</code>",
 "1762":
 "<code>Heap.contents.{u} {α : Type u} (self : Heap α) : Array α</code>",
 "1761": "<code>Heap.{u} (α : Type u) : Type u</code>",
 "1760": "<code>∀ (x : α), Magma.op x ident = x</code>",
 "176":
 "<code>Nat.fold.{u} {α : Type u} (n : Nat) (f : (i : Nat) → i &lt; n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Iterates the application of a function `f` to a starting value `init`, `n` times. At each step, `f`\nis applied to the current value and to the next natural number less than `n`, in increasing order.\n\nExamples:\n* `Nat.fold 3 f init = (init |&gt; f 0 (by simp) |&gt; f 1 (by simp) |&gt; f 2 (by simp))`\n* `Nat.fold 4 (fun i _ xs =&gt; xs.push i) #[] = #[0, 1, 2, 3]`\n* `Nat.fold 0 (fun i _ xs =&gt; xs.push i) #[] = #[]`\n</code>",
 "1759": "<code>∀ (x : α), Magma.op ident x = x</code>",
 "1758":
 "<code>C2.Magma.op.{u} {α : Type u} [self : C2.Magma α] : α → α → α</code>",
 "1757":
 "<code>C2.Monoid.mk.{u} {α : Type u} [toSemigroup : C2.Semigroup α] (ident : α)\n  (ident_left : ∀ (x : α), C2.Magma.op ident x = x) (ident_right : ∀ (x : α), C2.Magma.op x ident = x) : C2.Monoid α</code>",
 "1756":
 "<code>∀ (x y z : α), Magma.op (Magma.op x y) z = Magma.op x (Magma.op y z)</code>",
 "1755":
 "<code>∀ (x y z : α), toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)</code>",
 "1754": "<code>Magma α</code>",
 "1753":
 "<code>C2.Semigroup.mk.{u} {α : Type u} [toMagma : C2.Magma α]\n  (op_assoc : ∀ (x y z : α), C2.Magma.op (C2.Magma.op x y) z = C2.Magma.op x (C2.Magma.op y z)) : C2.Semigroup α</code>",
 "1752":
 "<code>S.Semigroup.mk.{u} {α : Type u} (toMagma : S.Magma α)\n  (op_assoc : ∀ (x y z : α), toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)) : S.Semigroup α</code>",
 "1751":
 "<code>C2.Magma.mk.{u} {α : Type u} (op : α → α → α) : C2.Magma α</code>",
 "1750":
 "<code>S.Magma.mk.{u} {α : Type u} (op : α → α → α) : S.Magma α</code>",
 "175": "<code>nums : List Format</code>",
 "1749":
 "<code>S.Magma.op.{u} {α : Type u} (self : S.Magma α) : α → α → α</code>",
 "1748": "<code>S.Semigroup α</code>",
 "1747": "<code>∀ (x : α), toSemigroup.op x ident = x</code>",
 "1746": "<code>∀ (x : α), toSemigroup.op ident x = x</code>",
 "1745": "<code>Semigroup α</code>",
 "1744":
 "<code>C1.Monoid.mk.{u} {α : Type u} (toSemigroup : S.Semigroup α) (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x) (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  C1.Monoid α</code>",
 "1743":
 "<code>S.Monoid.mk.{u} {α : Type u} (toSemigroup : S.Semigroup α) (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x) (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  S.Monoid α</code>",
 "1742":
 "<code>C2.Monoid.ident_right.{u} {α : Type u} [self : Monoid α] (x : α) : Magma.op x self.ident = x</code>",
 "1741":
 "<code>C2.Monoid.ident_left.{u} {α : Type u} [self : Monoid α] (x : α) : Magma.op self.ident x = x</code>",
 "1740": "<code>C2.Monoid.ident.{u} {α : Type u} [self : Monoid α] : α</code>",
 "174": "<code>nums : List Std.Format</code>",
 "1739":
 "<code>C2.Semigroup.op_assoc.{u} {α : Type u} [self : Semigroup α] (x y z : α) :\n  Magma.op (Magma.op x y) z = Magma.op x (Magma.op y z)</code>",
 "1738":
 "<code>C2.Magma.op.{u} {α : Type u} [self : Magma α] : α → α → α</code>",
 "1737":
 "<code>C1.Monoid.ident_right.{u} {α : Type u} [self : Monoid α] (x : α) : self.op x self.ident = x</code>",
 "1736":
 "<code>C1.Monoid.ident_left.{u} {α : Type u} [self : Monoid α] (x : α) : self.op self.ident x = x</code>",
 "1735": "<code>C1.Monoid.ident.{u} {α : Type u} [self : Monoid α] : α</code>",
 "1734":
 "<code>S.Monoid.ident_right.{u} {α : Type u} (self : Monoid α) (x : α) : self.op x self.ident = x</code>",
 "1733":
 "<code>S.Monoid.ident_left.{u} {α : Type u} (self : Monoid α) (x : α) : self.op self.ident x = x</code>",
 "1732": "<code>S.Monoid.ident.{u} {α : Type u} (self : Monoid α) : α</code>",
 "1731": "<code>α → α → α</code>",
 "1730":
 "<code>S.Semigroup.op_assoc.{u} {α : Type u} (self : Semigroup α) (x y z : α) :\n  self.op (self.op x y) z = self.op x (self.op y z)</code>",
 "173": "<code>lsts : Format</code>",
 "1729":
 "<code>S.Magma.op.{u} {α : Type u} (self : Magma α) : α → α → α</code>",
 "1728": "<code>C2.Monoid.{u} (α : Type u) : Type u</code>",
 "1727": "<code>C2.Semigroup.{u} (α : Type u) : Type u</code>",
 "1726": "<code>C2.Magma.{u} (α : Type u) : Type u</code>",
 "1725": "<code>C1.Monoid.{u} (α : Type u) : Type u</code>",
 "1724": "<code>S.Monoid.{u} (α : Type u) : Type u</code>",
 "1723": "<code>S.Semigroup.{u} (α : Type u) : Type u</code>",
 "1722": "<code>S.Magma.{u} (α : Type u) : Type u</code>",
 "1721":
 "<code>outParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, Lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n</code>",
 "1720":
 "<code>Sum.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The disjoint union of types `α` and `β`, ordinarily written `α ⊕ β`.\n\nAn element of `α ⊕ β` is either an `a : α` wrapped in `Sum.inl` or a `b : β` wrapped in `Sum.inr`.\n`α ⊕ β` is not equivalent to the set-theoretic union of `α` and `β` because its values include an\nindication of which of the two types was chosen. The union of a singleton set with itself contains\none element, while `Unit ⊕ Unit` contains distinct values `inl ()` and `inr ()`.\n</code>",
 "172": "<code>lst : Std.Format</code>",
 "1719":
 "<code>Coe.{u, v} (α : semiOutParam (Sort u)) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`Coe α β` is the typeclass for coercions from `α` to `β`. It can be transitively\nchained with other `Coe` instances, and coercion is automatically used when\n`x` has type `α` but it is used in a context where `β` is expected.\nYou can use the `↑x` operator to explicitly trigger coercion.\n</code>",
 "1718":
 "<code>StateM.{u} (σ α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A tuple-based state monad.\n\nActions in `StateM σ` are functions that take an initial state and return a value paired with a\nfinal state.\n</code>",
 "1717":
 "<code>Pure.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `pure` function is overloaded via `Pure` instances.\n\n`Pure` is typically accessed via `Monad` or `Applicative` instances.\n</code>",
 "1716": "<code>Nat.add 0 n' = n'</code>",
 "1715": "<code>0 + n' = n'</code>",
 "1714": "<code>0 + n✝ = n✝</code>",
 "1713":
 "<code class=\"docstring\">`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `&lt;-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (occs := .pos L) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`(occs := .neg L)` allows skipping specified occurrences.\n</code>",
 "1712": "<code>0 ≍ n'</code>",
 "1711": "<code>?m.2 n✝</code>",
 "1710": "<code>the.{u} (α : Sort u) (x : α) : α</code>",
 "171":
 "<code>Std.Format.pretty (f : Format) (width : Nat := defWidth) (indent column : Nat := 0) : String</code><span class=\"sep\"></span><code class=\"docstring\">Renders a `Format` to a string.\n* `width`: the total width\n* `indent`: the initial indentation to use for wrapped lines\n  (subsequent wrapping may increase the indentation)\n* `column`: begin the first line wrap `column` characters earlier than usual\n  (this is useful when the output String will be printed starting at `column`)\n</code>",
 "1709":
 "<code class=\"docstring\">Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n</code>",
 "1708":
 "<code><span class=\"literal string\">\"world\"</span> : String</code>",
 "1707": "<code>x = \"world\"</code>",
 "1706": "<code>x = \"Hello\"</code>",
 "1705": "<code>isZero' : Nat → Bool</code>",
 "1704": "<code>isZero : Nat → Bool</code>",
 "1703": "<code>add : Nat → Nat → Nat</code>",
 "1702": "<code>nonzero (n : Nat) : Bool</code>",
 "1701":
 "<code>Add.add.{u} {α : Type u} [self : Add α] : α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1700": "<code>b = false</code>",
 "170":
 "<code>List.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (l : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list, returning the resulting list of values.\n\n`O(|l|)`.\n\nExamples:\n* `[a, b, c].map f = [f a, f b, f c]`\n* `[].map Nat.succ = []`\n* `[\"one\", \"two\", \"three\"].map (·.length) = [3, 3, 5]`\n* `[\"one\", \"two\", \"three\"].map (·.reverse) = [\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "17":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "1699": "<code>false = false → α</code>",
 "1698": "<code>true = true → α</code>",
 "1697": "<code>b = true</code>",
 "1696": "<code>b = false → α</code>",
 "1695": "<code>b = true → α</code>",
 "1694":
 "<code>boolCases.{u} {α : Type u} (b : Bool) (ifTrue : b = true → α) (ifFalse : b = false → α) : α</code>",
 "1693": "<code>n = 3</code>",
 "1692": "<code>f (n : Nat) (p : n = 3) : String</code>",
 "1691": "<code><span class=\"literal string\">\"ok\"</span> : String</code>",
 "1690":
 "<code>last?'.{u_1} {α : Type u_1} (xs : List α) : Except String α</code>",
 "169": "<code>lst.nums : List Format</code>",
 "1689": "<code>xs = head✝ :: tail✝</code>",
 "1688":
 "<code>Except.ok.{u, v} {ε : Type u} {α : Type v} : α → Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">A success value of type `α` </code>",
 "1687":
 "<code><span class=\"literal string\">\"Can't take first element of empty list\"</span> : String</code>",
 "1686":
 "<code>Except.error.{u, v} {ε : Type u} {α : Type v} : ε → Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">A failure value of type `ε` </code>",
 "1685": "<code>xs = []</code>",
 "1684":
 "<code>List.getLast.{u} {α : Type u} (as : List α) : as ≠ [] → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of a non-empty list.\n\nExamples:\n* `[\"circle\", \"rectangle\"].getLast (by decide) = \"rectangle\"`\n* `[\"circle\"].getLast (by decide) = \"circle\"`\n</code>",
 "1683":
 "<code>last?.{u_1} {α : Type u_1} (xs : List α) : Except String α</code>",
 "1682": "<code>?m.13</code>",
 "1681": "<code>BalancedTree ?m.13 ?m.12</code>",
 "1680":
 "<code>BalancedTree.isPerfectlyBalanced.{u} {α : Type u} (n : Nat) (t : BalancedTree α n) : Bool</code>",
 "168": "<code>lst : Format</code>",
 "1679":
 "<code>BalancedTree.filledWith.{u} {α : Type u} (x : α) (depth : Nat) : BalancedTree α depth</code>",
 "1678":
 "<code>BalancedTree.rbranch.{u} {α : Type u} {n : Nat} (left : BalancedTree α n) (val : α) (right : BalancedTree α (n + 1)) :\n  BalancedTree α (n + 2)</code>",
 "1677": "<code>BalancedTree α (n + 1)</code>",
 "1676":
 "<code>BalancedTree.lbranch.{u} {α : Type u} {n : Nat} (left : BalancedTree α (n + 1)) (val : α) (right : BalancedTree α n) :\n  BalancedTree α (n + 2)</code>",
 "1675": "<code>BalancedTree α n</code>",
 "1674":
 "<code>BalancedTree.branch.{u} {α : Type u} {n : Nat} (left : BalancedTree α n) (val : α) (right : BalancedTree α n) :\n  BalancedTree α (n + 1)</code>",
 "1673": "<code>BalancedTree.empty.{u} {α : Type u} : BalancedTree α 0</code>",
 "1672": "<code>BalancedTree.{u} (α : Type u) : Nat → Type u</code>",
 "1671": "<code>h + 1 + (h + 1) = h + h + 1 + 1</code>",
 "1670": "<code>Nat.parity (n : Nat) : Parity n</code>",
 "167": "<code><span class=\"literal string\">\")\"</span> : String</code>",
 "1669": "<code>Parity.odd (h : Nat) : Parity (h + h + 1)</code>",
 "1668": "<code>Parity.even (h : Nat) : Parity (h + h)</code>",
 "1667": "<code>Parity : Nat → Type</code>",
 "1666":
 "<code>Lean.Name : Type</code><span class=\"sep\"></span><code class=\"docstring\">Hierarchical names consist of a sequence of components, each of\nwhich is either a string or numeric, that are written separated by dots (`.`).\n\nHierarchical names are used to name declarations and for creating\nunique identifiers for free variables and metavariables.\n\nYou can create hierarchical names using a backtick:\n```\n`Lean.Meta.whnf\n```\nIt is short for `.str (.str (.str .anonymous \"Lean\") \"Meta\") \"whnf\"`.\n\nYou can use double backticks to request Lean to statically check whether the name\ncorresponds to a Lean declaration in scope.\n```\n``Lean.Meta.whnf\n```\nIf the name is not in scope, Lean will report an error.\n\nThere are two ways to convert a `String` to a `Name`:\n\n 1. `Name.mkSimple` creates a name with a single string component.\n\n 2. `String.toName` first splits the string into its dot-separated\n    components, and then creates a hierarchical name.\n</code>",
 "1665":
 "<code class=\"docstring\">mark that a definition can be used in a pattern (remark: the dependent pattern matching compiler will unfold the definition)</code>",
 "1664": "<code>xs.size ≤ 2</code>",
 "1663": "<code>Type ?u.7</code>",
 "1662": "<code>getThird.{u_1} {α : Type u_1} (xs : Array α) : α</code>",
 "1661": "<code>getThird.{u_1} {α : Type u_1} (xs : Array α) : Option α</code>",
 "1660":
 "<code>Float32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">32-bit floating-point numbers.\n\n`Float32` corresponds to the IEEE 754 *binary32* format (`float` in C or `f32` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of “not a number” values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n\n</code>",
 "166":
 "<code>Std.Format.joinSep.{u} {α : Type u} [ToFormat α] : List α → Format → Format</code><span class=\"sep\"></span><code class=\"docstring\">Intercalates the given list with the given `sep` format.\n\nThe list items are formatting using `ToFormat.format`.\n</code>",
 "1659":
 "<code>Nat → Bool → Nat → α</code><span class=\"sep\"></span><code class=\"docstring\">Produces a value from the given mantissa, exponent sign, and decimal exponent. For the exponent\nsign, `true` indicates a negative exponent.\n\n Examples:\n - `1.23` is syntax for `OfScientific.ofScientific (nat_lit 123) true (nat_lit 2)`\n - `121e100` is syntax for `OfScientific.ofScientific (nat_lit 121) false (nat_lit 100)`\n\n Note the use of `nat_lit`; there is no wrapping `OfNat.ofNat` in the resulting term.\n</code>",
 "1658":
 "<code>OfScientific.mk.{u} {α : Type u} (ofScientific : Nat → Bool → Nat → α) : OfScientific α</code>",
 "1657":
 "<code>OfScientific.ofScientific.{u} {α : Type u} [self : OfScientific α] (mantissa : Nat) (exponentSign : Bool)\n  (decimalExponent : Nat) : α</code><span class=\"sep\"></span><code class=\"docstring\">Produces a value from the given mantissa, exponent sign, and decimal exponent. For the exponent\nsign, `true` indicates a negative exponent.\n\n Examples:\n - `1.23` is syntax for `OfScientific.ofScientific (nat_lit 123) true (nat_lit 2)`\n - `121e100` is syntax for `OfScientific.ofScientific (nat_lit 121) false (nat_lit 100)`\n\n Note the use of `nat_lit`; there is no wrapping `OfNat.ofNat` in the resulting term.\n</code>",
 "1656":
 "<code>OfScientific.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">For decimal and scientific numbers (e.g., `1.23`, `3.12e10`).\nExamples:\n- `1.23` is syntax for `OfScientific.ofScientific (nat_lit 123) true (nat_lit 2)`\n- `121e100` is syntax for `OfScientific.ofScientific (nat_lit 121) false (nat_lit 100)`\n\nNote the use of `nat_lit`; there is no wrapping `OfNat.ofNat` in the resulting term.\n</code>",
 "1655": "<code>NatInterval</code>",
 "1654":
 "<code>NatInterval.mk (low high : Nat) (low_le_high : low ≤ high) : NatInterval</code>",
 "1653":
 "<code>NatInterval</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1652": "<code>lo2 ≤ hi2</code>",
 "1651": "<code>lo1 ≤ hi1</code>",
 "1650":
 "<code>NatInterval → NatInterval → NatInterval</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "165":
 "<code>Std.Format.line : Format</code><span class=\"sep\"></span><code class=\"docstring\">A position where a newline may be inserted if the current group does not fit within the allotted\ncolumn width.\n</code>",
 "1649":
 "<code>NatInterval.low_le_high (self : NatInterval) : self.low ≤ self.high</code>",
 "1648": "<code>NatInterval.high (self : NatInterval) : Nat</code>",
 "1647": "<code>NatInterval.low (self : NatInterval) : Nat</code>",
 "1646": "<code>NatInterval : Type</code>",
 "1645":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1644":
 "<code>OfNat.mk.{u} {α : Type u} {x✝ : Nat} (ofNat : α) : OfNat α x✝</code>",
 "1643":
 "<code class=\"docstring\">The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n</code>",
 "1642":
 "<code>OfNat.ofNat.{u} {α : Type u} (x✝ : Nat) [self : OfNat α x✝] : α</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1641":
 "<code>Array.reverse.{u} {α : Type u} (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Reverses an array by repeatedly swapping elements.\n\nThe original array is modified in place if there are no other references to it.\n\nExamples:\n* `(#[] : Array Nat).reverse = #[]`\n* `#[0, 1].reverse = #[1, 0]`\n* `#[0, 1, 2].reverse = #[2, 1, 0]`\n</code>",
 "1640":
 "<code>List.toArray.{u_1} {α : Type u_1} (xs : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `List α` into an `Array α`.\n\n `O(|xs|)`. At runtime, this operation is implemented by `List.toArrayImpl` and takes time linear in\nthe length of the list. `List.toArray` should be used instead of `Array.mk`.\n\nExamples:\n * `[1, 2, 3].toArray = #[1, 2, 3]`\n * `[\"monday\", \"wednesday\", friday\"].toArray = #[\"monday\", \"wednesday\", friday\"].`\n</code>",
 "164": "<code><span class=\"literal string\">\"(\"</span> : String</code>",
 "1639": "<code>Array (Array Nat)</code>",
 "1638": "<code>T.f.{u_1} {n : Nat} : Char → T n → String</code>",
 "1637": "<code>T 3</code>",
 "1636":
 "<code>List.head!.{u_1} {α : Type u_1} [Inhabited α] : List α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element in the list. If the list is empty, panics and returns `default`.\n\nSafer alternatives include:\n* `List.head`, which requires a proof that the list is non-empty,\n* `List.head?`, which returns an `Option`, and\n* `List.headD`, which returns an explicitly-provided fallback value on empty lists.\n</code>",
 "1635":
 "<code><span class=\"literal string\">\"Hello!\"</span> : String</code>",
 "1634": "<code>Nat.half : Nat → Nat</code>",
 "1633":
 "<code class=\"docstring\">mark declaration to never be pretty printed using field notation</code>",
 "1632": "<code><span class=\"literal string\">\"root\"</span> : String</code>",
 "1631": "<code>root : Username</code>",
 "1630":
 "<code><span class=\"literal string\">\"Unexpected character\"</span> : String</code>",
 "163": "<code>Int</code>",
 "1629": "<code>Username.validate.notOk (c : Char) : Bool</code>",
 "1628":
 "<code><span class=\"literal string\">\"Unexpected leading whitespace\"</span> : String</code>",
 "1627":
 "<code>MonadExcept.throw.{u, v, w} {ε : outParam (Type u)} {m : Type v → Type w} [self : MonadExcept ε m] {α : Type v} :\n  ε → m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception of type `ε` to the nearest enclosing handler.\n</code>",
 "1626": "<code>Username</code>",
 "1625":
 "<code>Char.isDigit (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is an ASCII digit.\n\nThe ASCII digits are the following: `0123456789`.\n</code>",
 "1624":
 "<code>Char.isAlpha (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is an ASCII letter.\n\nThe ASCII letters are the following: `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`.\n</code>",
 "1623":
 "<code>String.any (s : String) (p : Char → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether there is a character in a string for which the Boolean predicate `p` returns `true`.\n\nShort-circuits at the first character for which `p` returns `true`.\n\nExamples:\n* `\"brown\".any (·.isLetter) = true`\n* `\"brown\".any (·.isWhitespace) = false`\n* `\"brown and orange\".any (·.isLetter) = true`\n* `\"\".any (fun _ =&gt; false) = false`\n</code>",
 "1622":
 "<code>String.isPrefixOf (p s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first string (`p`) is a prefix of the second (`s`).\n\n`String.startsWith` is a version that takes the potential prefix after the string.\n\nExamples:\n* `\"red\".isPrefixOf \"red green blue\" = true`\n* `\"green\".isPrefixOf \"red green blue\" = false`\n* `\"\".isPrefixOf \"red green blue\" = true`\n</code>",
 "1621":
 "<code>Username.validate (name : Username) : Except String Unit</code>",
 "1620": "<code>Username : Type</code>",
 "162":
 "<code>Std.Format.group : Format → (behavior : optParam FlattenBehavior FlattenBehavior.allOrNone) → Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new flattening group for the given inner `Format`.  </code>",
 "1619": "<code>Lean.Syntax</code>",
 "1618":
 "<code>Inhabited.default.{u} {α : Sort u} [self : Inhabited α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "1617": "<code>optParam α default</code>",
 "1616":
 "<code>autoParam.{u} (α : Sort u) (tactic : Lean.Syntax) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\nthe given tactic.\nLike `optParam`, this gadget only affects elaboration.\nFor example, the tactic will *not* be invoked during type class resolution. </code>",
 "1615":
 "<code>pp.piBinderNames</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display names for pi parameters, even if they are unused; when `pp.piBinderNames.hygienic` is false then unused hygienic parameters are not displayed.</code>",
 "1614": "<code>sum3 (x y z : Nat) : Nat</code>",
 "1613": "<code>α✝</code>",
 "1612": "<code>g {α : Type} : α → α</code>",
 "1611": "<code>f ⦃α : Type⦄ : α → α</code>",
 "1610": "<code>MyList.{u_1} (α : Type u_1) : Type u_1</code>",
 "161": "<code>List Format</code>",
 "1609": "<code>D.x : Nat</code>",
 "1608": "<code><span class=\"literal string\">\"C.x\"</span> : String</code>",
 "1607": "<code>C.x : String</code>",
 "1606": "<code><span class=\"literal string\">\"B.x\"</span> : String</code>",
 "1605": "<code>B.x : String</code>",
 "1604":
 "<code><span class=\"literal string\">\"longer\"</span> : String</code>",
 "1603": "<code>y.y : A</code>",
 "1602":
 "<code><span class=\"literal string\">\"shorter\"</span> : String</code>",
 "1601": "<code>A.mk (y : String) : A</code>",
 "1600": "<code>B.mk (y : A) : B</code>",
 "160": "<code>parenSeq (xs : List Format) : Format</code>",
 "16":
 "<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode scalar values.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>",
 "1599": "<code>y : B</code>",
 "1598": "<code>B.y (self : B) : A</code>",
 "1597": "<code>B : Type</code>",
 "1596": "<code>A.y (self : A) : String</code>",
 "1595": "<code>A : Type</code>",
 "1594":
 "<code><span class=\"literal string\">\"A.B.C.x\"</span> : String</code>",
 "1593": "<code>A.B.C.x : String</code>",
 "1592": "<code><span class=\"literal string\">\"A.x\"</span> : String</code>",
 "1591": "<code>A.x : String</code>",
 "1590":
 "<code><span class=\"literal string\">\"outer\"</span> : String</code>",
 "159": "<code>parenSeq (xs : List Std.Format) : Std.Format</code>",
 "1589":
 "<code><span class=\"literal string\">\"inner\"</span> : String</code>",
 "1588":
 "<code><span class=\"literal string\">\"local\"</span> : String</code>",
 "1587":
 "<code><span class=\"literal string\">\"global\"</span> : String</code>",
 "1586": "<code>x : String</code>",
 "1585":
 "<code class=\"docstring\">Marks a theorem as an extensionality theorem</code>",
 "1584": "<code class=\"docstring\">simplification theorem</code>",
 "1583": "<code class=\"docstring\">type class instance</code>",
 "1582": "<code>or_false (p : Prop) : (p ∨ False) = p</code>",
 "1581": "<code>simpleEquality (P : Prop) : (P ∨ False) = P</code>",
 "1580":
 "<code>Classical.em (p : Prop) : p ∨ ¬p</code><span class=\"sep\"></span><code class=\"docstring\">**Diaconescu's theorem**: excluded middle from choice, Function extensionality and propositional extensionality. </code>",
 "158":
 "<code>Std.Format.tag : Nat → Format → Format</code><span class=\"sep\"></span><code class=\"docstring\">Used for associating auxiliary information (e.g. `Expr`s) with `Format` objects. </code>",
 "1579": "<code>excludedMiddle (P : Prop) : P ∨ ¬P</code>",
 "1578": "<code>addThree (n : Nat) : Nat</code>",
 "1577": "<code>lazy : (4 == 2 + 1 + 1) = true</code>",
 "1576": "<code>bigSum : (List.range 1001).sum = 500500</code>",
 "1575":
 "<code class=\"docstring\">`native_decide` is a synonym for `decide +native`.\nIt will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `Lean.ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```lean\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n</code>",
 "1574": "<code>largeNumber : Nat</code>",
 "1573":
 "<code>Lean.reduceNat (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Similar to `Lean.reduceBool` for closed `Nat` terms.\n\nRemark: we do not have plans for supporting a generic `reduceValue {α} (a : α) : α := a`.\nThe main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.\nWe believe `Lean.reduceBool` enables most interesting applications (e.g., proof by reflection).\n</code>",
 "1572":
 "<code>Lean.ofReduceNat (a b : Nat) (h : Lean.reduceNat a = b) : a = b</code><span class=\"sep\"></span><code class=\"docstring\">The axiom `ofReduceNat` is used to perform proofs by reflection. See `reduceBool`.\n\nWarning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\nThis is extra 30k lines of code. More importantly, you will probably not be able to check your development using\nexternal type checkers that do not implement this feature.\nKeep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\nSo, you are mainly losing the capability of type checking your development using external checkers.\n</code>",
 "1571":
 "<code>Lean.reduceBool (b : Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">When the kernel tries to reduce a term `Lean.reduceBool c`, it will invoke the Lean interpreter to evaluate `c`.\nThe kernel will not use the interpreter if `c` is not a constant.\nThis feature is useful for performing proofs by reflection.\n\nRemark: the Lean frontend allows terms of the from `Lean.reduceBool t` where `t` is a term not containing\nfree variables. The frontend automatically declares a fresh auxiliary constant `c` and replaces the term with\n`Lean.reduceBool c`. The main motivation is that the code for `t` will be pre-compiled.\n\nWarning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\nThis is extra 30k lines of code. More importantly, you will probably not be able to check your development using\nexternal type checkers that do not implement this feature.\nKeep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\nSo, you are mainly losing the capability of type checking your development using external checkers.\n\nRecall that the compiler trusts the correctness of all `[implemented_by ...]` and `[extern ...]` annotations.\nIf an extern function is executed, then the trusted code base will also include the implementation of the associated\nforeign function.\n</code>",
 "1570":
 "<code>Lean.ofReduceBool (a b : Bool) (h : Lean.reduceBool a = b) : a = b</code><span class=\"sep\"></span><code class=\"docstring\">The axiom `ofReduceBool` is used to perform proofs by reflection. See `reduceBool`.\n\nThis axiom is usually not used directly, because it has some syntactic restrictions.\nInstead, the `native_decide` tactic can be used to prove any proposition whose\ndecidability instance can be evaluated to `true` using the lean compiler / interpreter.\n\nWarning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\nThis is extra 30k lines of code. More importantly, you will probably not be able to check your development using\nexternal type checkers that do not implement this feature.\nKeep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\nSo, you are mainly losing the capability of type checking your development using external checkers.\n</code>",
 "157":
 "<code>Std.Format.align (force : Bool) : Format</code><span class=\"sep\"></span><code class=\"docstring\">`align` tells the formatter to pad with spaces to the current indentation level, or else add a\nnewline if we are already at or past the indent.\n\nIf `force` is true, then it will pad to the indent even if it is in a flattened group.\n\nExample:\n```lean example\nopen Std Format in\n#eval IO.println (nest 2 &lt;| \".\" ++ align ++ \"a\" ++ line ++ \"b\")\n```\n```lean output\n. a\n  b\n```\n</code>",
 "1569":
 "<code>Lean.trustCompiler : True</code><span class=\"sep\"></span><code class=\"docstring\">Depends on the correctness of the Lean compiler, interpreter, and all `[implemented_by ...]` and `[extern ...]` annotations.\n</code>",
 "1568": "<code>optParam Bool true</code>",
 "1567":
 "<code>sorryAx.{u} (α : Sort u) (synthetic : Bool) : α</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary axiom used to implement the `sorry` term and tactic.\n\nThe `sorry` term/tactic expands to `sorryAx _ (synthetic := false)`.\nIt is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can check if a declaration depends on `sorry` either directly or indirectly by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command.\n\nThe `synthetic` flag is false when a `sorry` is written explicitly by the user, but it is\nset to `true` when a tactic fails to prove a goal, or if there is a type error\nin the expression. A synthetic `sorry` acts like a regular one, except that it\nsuppresses follow-up errors in order to prevent an error from causing a cascade\nof other errors because the desired term was not constructed.\n</code>",
 "1566":
 "<code>Classical.choice.{u} {α : Sort u} : Nonempty α → α</code><span class=\"sep\"></span><code class=\"docstring\">**The axiom of choice**. `Nonempty α` is a proof that `α` has an element,\nbut the element itself is erased. The axiom `choice` supplies a particular\nelement of `α` given only this proof.\n\nThe textbook axiom of choice normally makes a family of choices all at once,\nbut that is implied from this formulation, because if `α : ι → Type` is a\nfamily of types and `h : ∀ i, Nonempty (α i)` is a proof that they are all\nnonempty, then `fun i =&gt; Classical.choice (h i) : ∀ i, α i` is a family of\nchosen elements. This is actually a bit stronger than the ZFC choice axiom;\nthis is sometimes called \"[global choice](https://en.wikipedia.org/wiki/Axiom_of_global_choice)\".\n\nIn Lean, we use the axiom of choice to derive the law of excluded middle\n(see `Classical.em`), so it will often show up in axiom listings where you\nmay not expect. You can use `#print axioms my_thm` to find out if a given\ntheorem depends on this or other axioms.\n\nThis axiom can be used to construct \"data\", but obviously there is no algorithm\nto compute it, so Lean will require you to mark any definition that would\ninvolve executing `Classical.choice` or other axioms as `noncomputable`, and\nwill not produce any executable code for such definitions.\n</code>",
 "1565": "<code>¬k % 2 = 1</code>",
 "1564": "<code>k % 2 = 1</code>",
 "1563":
 "<code class=\"docstring\">`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n</code>",
 "1562":
 "<code>HMod.hMod.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMod α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `%` in identifiers is `mod`.</code>",
 "1561":
 "<code>(if k % 2 = 1 then k else k + 1) % 2 = 1 ∧\n  ((if k % 2 = 1 then k else k + 1) = k ∨ (if k % 2 = 1 then k else k + 1) = k + 1)</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1560":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "156":
 "<code>Std.Format.nest (indent : Int) (f : Format) : Format</code><span class=\"sep\"></span><code class=\"docstring\">`nest indent f` increases the current indentation level by `indent` while rendering `f`.\n\nExample:\n```lean example\nopen Std Format in\ndef fmtList (l : List Format) : Format :=\n  let f := joinSep l  (\", \" ++ Format.line)\n  group (nest 1 &lt;| \"[\" ++ f ++ \"]\")\n```\n\nThis will be written all on one line, but if the text is too large, the formatter will put in\nlinebreaks after the commas and indent later lines by 1.\n</code>",
 "1559":
 "<code>nextOdd (k : Nat) : { n // n % 2 = 1 ∧ (n = k ∨ n = k + 1) }</code>",
 "1558": "<code>List.length'.{u_1} {α : Type u_1} : List α → Nat</code>",
 "1557": "<code>Nat.otherZero : Nat</code>",
 "1556":
 "<code>((fun xs =&gt; []) ∘ List.map fun x =&gt; 42) [()] = ((List.map fun x =&gt; 42) ∘ fun xs =&gt; xs) [()]</code>",
 "1555":
 "<code>congrFun.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : f = g) (a : α) : f a = g a</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function part of an application: If `f = g` then `f a = g a`. </code>",
 "1554":
 "<code>((fun xs =&gt; []) ∘ List.map fun x =&gt; 42) = (List.map fun x =&gt; 42) ∘ fun xs =&gt; xs</code>",
 "1553": "<code>List Unit</code>",
 "1552": "<code>Unit</code>",
 "1551":
 "<code>((fun xs =&gt; if Nat = Nat then [] else xs) ∘ List.map fun x =&gt; 42) =\n  (List.map fun x =&gt; 42) ∘ fun xs =&gt; if Unit = Nat then [] else xs</code>",
 "1550": "<code>?_mvar.129</code>",
 "155":
 "<code>Std.Format.group :\n  Std.Format → (behavior : optParam Std.Format.FlattenBehavior Std.Format.FlattenBehavior.allOrNone) → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new flattening group for the given inner `Format`.  </code>",
 "1549": "<code>Type ?u.128</code>",
 "1548":
 "<code>(nonParametric ∘ List.map fun x =&gt; 42) = (List.map fun x =&gt; 42) ∘ nonParametric</code>",
 "1547":
 "<code>List.free_theorem.{u_1} {α β : Type u_1} (f : {α : Type u_1} → List α → List α) (g : α → β) :\n  f ∘ List.map g = List.map g ∘ f</code>",
 "1546": "<code>0 = 1</code>",
 "1545": "<code>∀ (a b : Nat), a = b</code>",
 "1544": "<code>Unit = Nat</code>",
 "1543": "<code>unit_not_nat : Unit ≠ Nat</code>",
 "1542": "<code>nonParametric {α : Type} (xs : List α) : List α</code>",
 "1541": "<code>{α : Type u_1} → List α → List α</code>",
 "1540":
 "<code>List.free_theorem.{u_1} {α β : Type u_1} (f : {α : Type u_1} → List α → List α) (g : α → β) : f ∘ map g = map g ∘ f</code>",
 "154": "<code><span class=\"literal string\">\" \"</span> : String</code>",
 "1539":
 "<code>False.elim.{u} {C : Sort u} (h : False) : C</code><span class=\"sep\"></span><code class=\"docstring\">`False.elim : False → C` says that from `False`, any desired proposition\n`C` holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.\n\nThe target type is actually `C : Sort u` which means it works for both\npropositions and types. When executed, this acts like an \"unreachable\"\ninstruction: it is **undefined behavior** to run, but it will probably print\n\"unreachable code\". (You would need to construct a proof of false to run it\nanyway, which you can only do using `sorry` or unsound axioms.)\n</code>",
 "1538": "<code>two_eq_five : 2 = 5</code>",
 "1537": "<code>false_is_true : False</code>",
 "1536":
 "<code>allowUnsafeReducibility</code><span class=\"sep\"></span><code class=\"docstring\">enables users to modify the reducibility settings for declarations even when such changes are deemed potentially hazardous. For example, `simp` and type class resolution maintain term indices where reducible declarations are expanded.</code>",
 "1535": "<code>tally_eq_add {x y : Nat} : tally x y = x + y</code>",
 "1534": "<code>sum_eq_add {x y : Nat} : sum x y = x + y</code>",
 "1533": "<code>plus_eq_add {x y : Nat} : plus x y = x + y</code>",
 "1532":
 "<code>Nat.add : Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Addition of natural numbers, typically used via the `+` operator.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n</code>",
 "1531": "<code>tally : Nat → Nat → Nat</code>",
 "1530": "<code>sum : Nat → Nat → Nat</code>",
 "153": "<code><span class=\"literal string\">\"\\n\"</span> : String</code>",
 "1529": "<code>plus : Nat → Nat → Nat</code>",
 "1528":
 "<code class=\"docstring\">`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n</code>",
 "1527":
 "<code class=\"docstring\">`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n</code>",
 "1526": "<code>Sequence Nat</code>",
 "1525":
 "<code>Sequence.ofList.{u_1} {α : Type u_1} (xs : List α) : Sequence α</code>",
 "1524": "<code>Sequence.{u_1} (α : Type u_1) : Type u_1</code>",
 "1523": "<code>instToStringString : ToString String</code>",
 "1522":
 "<code><span class=\"literal string\">\"Good evening\"</span> : String</code>",
 "1521": "<code>goodEvening : Utterance</code>",
 "1520":
 "<code><span class=\"literal string\">\"Good morning\"</span> : String</code>",
 "152":
 "<code>Std.Format.line : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">A position where a newline may be inserted if the current group does not fit within the allotted\ncolumn width.\n</code>",
 "1519": "<code>goodMorning : Clause</code>",
 "1518": "<code>hello : Phrase</code>",
 "1517": "<code>Utterance : Type</code>",
 "1516": "<code>Clause : Type</code>",
 "1515": "<code>Phrase : Type</code>",
 "1514": "<code class=\"docstring\">irreducible declaration</code>",
 "1513":
 "<code>unFin_length_eq_length {n : Nat} {xs : List (Fin n)} : (unFin xs).length = xs.length</code>",
 "1512": "<code>unFin {n : Nat} (xs : List (Fin n)) : List Nat</code>",
 "1511": "<code>List (Fin n)</code>",
 "1510": "<code>unFinImpl {n : Nat} (xs : List (Fin n)) : List Nat</code>",
 "151":
 "<code>Append.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAppend`: `a ++ b : α` where `a b : α`. </code>",
 "1509":
 "<code>Tree α → Tree α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1508":
 "<code>Tree.beq.{u_1} {α : Type u_1} [BEq α] (t1 t2 : Tree α) : Bool</code>",
 "1507":
 "<code>ptrEq.{u_1} {α : Type u_1} (a b : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Compares two objects for pointer equality.\n\nTwo objects are pointer-equal if, at runtime, they are allocated at exactly the same address. This\nfunction is unsafe because it can distinguish between definitionally equal values.\n</code>",
 "1506":
 "<code>Tree.fastBEq.{u_1} {α : Type u_1} [BEq α] (t1 t2 : Tree α) : Bool</code>",
 "1505":
 "<code>Tree.branch.{u_1} {α : Sort u_1} (left : Tree α) (val : α) (right : Tree α) : Tree α</code>",
 "1504": "<code>Tree.empty.{u_1} {α : Sort u_1} : Tree α</code>",
 "1503": "<code>Tree.{u_1} (α : Sort u_1) : Sort (max 1 u_1)</code>",
 "1502":
 "<code>BEq.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`BEq α` is a typeclass for supplying a boolean-valued equality relation on\n`α`, notated as `a == b`. Unlike `DecidableEq α` (which uses `a = b`), this\nis `Bool` valued instead of `Prop` valued, and it also does not have any\naxioms like being reflexive or agreeing with `=`. It is mainly intended for\nprogramming applications. See `LawfulBEq` for a version that requires that\n`==` and `=` coincide.\n\nTypically we prefer to put the \"more variable\" term on the left,\nand the \"more constant\" term on the right.\n</code>",
 "1501": "<code>BaseIO α</code>",
 "1500":
 "<code>EIO (ε : Type) : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that can have side effects on the external world or throw exceptions of type `ε`.\n\n`BaseIO` is a version of this monad that cannot throw exceptions. `IO` sets the exception type to\n`IO.Error`.\n</code>",
 "150": "<code>String</code>",
 "15": "<code><span class=\"literal string\">\"two\"</span> : String</code>",
 "1499": "<code>EIO ε α</code>",
 "1498":
 "<code>BaseIO : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">An `IO` monad that cannot throw exceptions.\n</code>",
 "1497":
 "<code>IO.Error : Type</code><span class=\"sep\"></span><code class=\"docstring\">Exceptions that may be thrown in the `IO` monad.\n\nMany of the constructors of `IO.Error` correspond to POSIX error numbers. In these cases, the\ndocumentation string lists POSIX standard error macros that correspond to the error. This list is\nnot necessarily exhaustive, and these constructor includes a field for the underlying error number.\n</code>",
 "1496":
 "<code>Except.{u, v} (ε : Type u) (α : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">`Except ε α` is a type which represents either an error of type `ε` or a successful result with a\nvalue of type `α`.\n\n`Except ε : Type u → Type v` is a `Monad` that represents computations that may throw exceptions:\nthe `pure` operation is `Except.ok` and the `bind` operation returns the first encountered\n`Except.error`.\n</code>",
 "1495": "<code>IO α</code>",
 "1494":
 "<code>NonScalar : Type</code><span class=\"sep\"></span><code class=\"docstring\">`NonScalar` is a type that is not a scalar value in our runtime.\nIt is used as a stand-in for an arbitrary boxed value to avoid excessive\nmonomorphization, and it is only created using `unsafeCast`. It is somewhat\nanalogous to C `void*` in usage, but the type itself is not special.\n</code>",
 "1493": "<code>answer_eq_other : answerUser = answerOtherUser</code>",
 "1492": "<code><span class=\"literal string\">\"is\"</span> : String</code>",
 "1491":
 "<code><span class=\"literal string\">\"prime\"</span> : String</code>",
 "1490": "<code><span class=\"literal string\">\"next\"</span> : String</code>",
 "149":
 "<code>Std.Format.text : String → Format</code><span class=\"sep\"></span><code class=\"docstring\">A node containing a plain string.\n\nIf the string contains newlines, the formatter emits them and then indents to the current level.\n</code>",
 "1489": "<code><span class=\"literal string\">\"The\"</span> : String</code>",
 "1488":
 "<code>String.intercalate (s : String) : List String → String</code><span class=\"sep\"></span><code class=\"docstring\">Appends the strings in a list of strings, placing the separator `s` between each pair.\n\nExamples:\n* `\", \".intercalate [\"red\", \"green\", \"blue\"] = \"red, green, blue\"`\n* `\" and \".intercalate [\"tea\", \"coffee\"] = \"tea and coffee\"`\n* `\" | \".intercalate [\"M\", \"\", \"N\"] = \"M |  | N\"`\n</code>",
 "1487": "<code>answerOtherUser (n : Nat) : String</code>",
 "1486": "<code>answerUser (n : Nat) : String</code>",
 "1485": "<code>isPrime (n : Nat) : Bool</code>",
 "1484": "<code>nextPrime (n : Nat) : Nat</code>",
 "1483":
 "<code>Empty.elim.{u} {C : Sort u} : Empty → C</code><span class=\"sep\"></span><code class=\"docstring\">`Empty.elim : Empty → C` says that a value of any type can be constructed from\n`Empty`. This can be thought of as a compiler-checked assertion that a code path is unreachable.\n</code>",
 "1482":
 "<code>StateT.run.{u, v} {σ : Type u} {m : Type u → Type v} {α : Type u} (x : StateT σ m α) (s : σ) : m (α × σ)</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value paired with the final state.\n</code>",
 "1481":
 "<code>Lean.Order.monotone_stateTRun.{u_1, u_2, u_3} {γ : Sort u_1} {m : Type u_2 → Type u_3} {σ α : Type u_2} [PartialOrder γ]\n  [Monad m] [(α : Type u_2) → PartialOrder (m α)] (f : γ → StateT σ m α) (hmono : monotone f) (s : σ) :\n  monotone fun x =&gt; (f x).run s</code>",
 "1480":
 "<code>StateRefT'.run {ω σ : Type} {m : Type → Type} [Monad m] [MonadLiftT (ST ω) m] {α : Type} (x : StateRefT' ω σ m α)\n  (s : σ) : m (α × σ)</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value paired with the final state.\n\nThe monad `m` must support `ST` effects in order to create and mutate reference cells.\n</code>",
 "148":
 "<code>Std.Format.text : String → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">A node containing a plain string.\n\nIf the string contains newlines, the formatter emits them and then indents to the current level.\n</code>",
 "1479":
 "<code>Lean.Order.monotone_stateRefT'Run.{u_1} {γ : Sort u_1} {m : Type → Type} {ω σ α : Type} [PartialOrder γ] [Monad m]\n  [MonadLiftT (ST ω) m] [(α : Type) → PartialOrder (m α)] [MonoBind m] (f : γ → StateRefT' ω σ m α) (hmono : monotone f)\n  (s : σ) : monotone fun x =&gt; (f x).run s</code>",
 "1478":
 "<code>ReaderT.run.{u, v} {ρ : Type u} {m : Type u → Type v} {α : Type u} (x : ReaderT ρ m α) (r : ρ) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with a read-only value in the underlying monad `m`.\n</code>",
 "1477":
 "<code>Lean.Order.monotone_readerTRun.{u_1, u_2, u_3} {γ : Sort u_1} {m : Type u_2 → Type u_3} {α σ : Type u_2}\n  [PartialOrder γ] [Monad m] [PartialOrder (m α)] (f : γ → ReaderT σ m α) (hmono : monotone f) (s : σ) :\n  monotone fun x =&gt; (f x).run s</code>",
 "1476":
 "<code>OptionT.run.{u, v} {m : Type u → Type v} {α : Type u} (x : OptionT m α) : m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action that might fail in the underlying monad `m`, returning `none` in case of failure.\n</code>",
 "1475":
 "<code>Lean.Order.monotone_optionTRun.{u_1, u_2, u_3} {γ : Sort u_1} {m : Type u_2 → Type u_3} {α : Type u_2} [PartialOrder γ]\n  [Monad m] [(α : Type u_2) → PartialOrder (m α)] (f : γ → OptionT m α) (hmono : monotone f) :\n  monotone fun x =&gt; (f x).run</code>",
 "1474":
 "<code>ExceptT.run.{u, v} {ε : Type u} {m : Type u → Type v} {α : Type u} (x : ExceptT ε m α) : m (Except ε α)</code><span class=\"sep\"></span><code class=\"docstring\">Use a monadic action that may throw an exception as an action that may return an exception's value.\n\nThis is the inverse of `ExceptT.mk`.\n</code>",
 "1473":
 "<code>Lean.Order.monotone_exceptTRun.{u_1, u_2, u_3} {γ : Sort u_1} {m : Type u_2 → Type u_3} {ε α : Type u_2}\n  [PartialOrder γ] [Monad m] [(α : Type u_2) → PartialOrder (m α)] (f : γ → ExceptT ε m α) (hmono : monotone f) :\n  monotone fun x =&gt; (f x).run</code>",
 "1472":
 "<code>dite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : ¬c → α) : α</code><span class=\"sep\"></span><code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "1471":
 "<code>Lean.Order.monotone_dite.{u, v} {α : Sort u} {β : Sort v} [PartialOrder α] [PartialOrder β] (c : Prop) [Decidable c]\n  (k₁ : α → c → β) (k₂ : α → ¬c → β) (hmono₁ : monotone k₁) (hmono₂ : monotone k₂) :\n  monotone fun x =&gt; dite c (k₁ x) (k₂ x)</code>",
 "1470":
 "<code>Lean.Order.monotone_bind.{u, v, w} (m : Type u → Type v) [Bind m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α β : Type u} {γ : Sort w} [PartialOrder γ] (f : γ → m α) (g : γ → α → m β) (hmono₁ : monotone f)\n  (hmono₂ : monotone g) : monotone fun x =&gt; f x &gt;&gt;= g x</code>",
 "147":
 "<code>Std.Format : Type</code><span class=\"sep\"></span><code class=\"docstring\">A representation of a set of strings, in which the placement of newlines and indentation differ.\n\nGiven a specific line width, specified in columns, the string that uses the fewest lines can be\nselected.\n\nThe pretty-printing algorithm is based on Wadler's paper\n[_A Prettier Printer_](https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf).\n</code>",
 "1469":
 "<code>Lean.Order.ind_not.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ : α → Prop) (h₁ : monotone f₁) : monotone fun x =&gt; ¬f₁ x</code>",
 "1468":
 "<code>Lean.Order.ind_impl.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ f₂ : α → Prop) (h₁ : monotone f₁) (h₂ : monotone f₂) :\n  monotone fun x =&gt; f₁ x → f₂ x</code>",
 "1467":
 "<code>Lean.Order.implication_order_monotone_or.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ f₂ : α → ImplicationOrder)\n  (h₁ : monotone f₁) (h₂ : monotone f₂) : monotone fun x =&gt; f₁ x ∨ f₂ x</code>",
 "1466":
 "<code>Lean.Order.implication_order_monotone_forall.{u_1, u_2} {α : Sort u_1} [PartialOrder α] {β : Sort u_2}\n  (f : α → β → ImplicationOrder) (h : monotone f) : monotone fun x =&gt; ∀ (y : β), f x y</code>",
 "1465":
 "<code>Lean.Order.implication_order_monotone_exists.{u_1, u_2} {α : Sort u_1} [PartialOrder α] {β : Sort u_2}\n  (f : α → β → ImplicationOrder) (h : monotone f) : monotone fun x =&gt; Exists (f x)</code>",
 "1464":
 "<code>Lean.Order.implication_order_monotone_and.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ f₂ : α → ImplicationOrder)\n  (h₁ : monotone f₁) (h₂ : monotone f₂) : monotone fun x =&gt; f₁ x ∧ f₂ x</code>",
 "1463":
 "<code>Lean.Order.coind_not.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ : α → Prop) (h₁ : monotone f₁) : monotone fun x =&gt; ¬f₁ x</code>",
 "1462":
 "<code>Lean.Order.coind_monotone_or.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ f₂ : α → Prop) (h₁ : monotone f₁)\n  (h₂ : monotone f₂) : monotone fun x =&gt; f₁ x ∨ f₂ x</code>",
 "1461": "<code>_</code>",
 "1460":
 "<code>Lean.Order.coind_monotone_forall.{u_1, u_2} {α : Sort u_1} [PartialOrder α] {β : Sort u_2}\n  (f : α → β → ReverseImplicationOrder) (h : monotone f) : monotone fun x =&gt; ∀ (y : β), f x y</code>",
 "146":
 "<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "1459":
 "<code>Lean.Order.coind_monotone_exists.{u_1, u_2} {α : Sort u_1} [PartialOrder α] {β : Sort u_2}\n  (f : α → β → ReverseImplicationOrder) (h : monotone f) : monotone fun x =&gt; Exists (f x)</code>",
 "1458":
 "<code>Lean.Order.coind_monotone_and.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ f₂ : α → Prop) (h₁ : monotone f₁)\n  (h₂ : monotone f₂) : monotone fun x =&gt; f₁ x ∧ f₂ x</code>",
 "1457":
 "<code>Lean.Order.coind_impl.{u_1} {α : Sort u_1} [PartialOrder α] (f₁ f₂ : α → Prop) (h₁ : monotone f₁) (h₂ : monotone f₂) :\n  monotone fun x =&gt; f₁ x → f₂ x</code>",
 "1456":
 "<code>Lean.Order.SeqRight.monotone_seqRight.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : γ → m β)\n  (hmono₁ : monotone g) (hmono₂ : monotone f) : monotone fun x =&gt; g x *&gt; f x</code>",
 "1455":
 "<code>Lean.Order.SeqLeft.monotone_seqLeft.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : γ → m β)\n  (hmono₁ : monotone g) (hmono₂ : monotone f) : monotone fun x =&gt; g x &lt;* f x</code>",
 "1454":
 "<code>Lean.Order.Seq.monotone_seq.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : γ → m (α → β)) (hmono₁ : monotone g)\n  (hmono₂ : monotone f) : monotone fun x =&gt; g x &lt;*&gt; f x</code>",
 "1453":
 "<code>PProd.snd.{u, v} {α : Sort u} {β : Sort v} (self : α ×' β) : β</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "1452":
 "<code>Lean.Order.PProd.monotone_snd.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} [PartialOrder α] [PartialOrder β]\n  [PartialOrder γ] {f : γ → α ×' β} (hf : monotone f) : monotone fun x =&gt; (f x).snd</code>",
 "1451":
 "<code>Lean.Order.PProd.monotone_mk.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} [PartialOrder α] [PartialOrder β]\n  [PartialOrder γ] {f : γ → α} {g : γ → β} (hf : monotone f) (hg : monotone g) : monotone fun x =&gt; ⟨f x, g x⟩</code>",
 "1450":
 "<code>PProd.fst.{u, v} {α : Sort u} {β : Sort v} (self : α ×' β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "145": "<code>Tree.branches.{u} {α : Type u} : List (Tree α) → Tree α</code>",
 "1449":
 "<code>Lean.Order.PProd.monotone_fst.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} [PartialOrder α] [PartialOrder β]\n  [PartialOrder γ] {f : γ → α ×' β} (hf : monotone f) : monotone fun x =&gt; (f x).fst</code>",
 "1448":
 "<code>Option.mapM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Applicative m] (f : α → m β) :\n  Option α → m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function in some applicative functor to an optional value, returning `none` with no\neffects if the value is missing.\n\nRuns a monadic function `f` on an optional value, returning the result. If the optional value is\n`none`, the function is not called and the result is also `none`.\n\nFrom the perspective of `Option` as a container with at most one element, this is analogous to\n`List.mapM`, returning the result of running the monadic function on all elements of the container.\n\nThis function only requires `m` to be an applicative functor. An alias `Option.mapA` is provided.\n</code>",
 "1447":
 "<code>Lean.Order.Option.monotone_mapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → α → m β) (xs : Option α)\n  (hmono : monotone f) : monotone fun x =&gt; Option.mapM (f x) xs</code>",
 "1446":
 "<code>Option.getDM.{u_1, u_2} {m : Type u_1 → Type u_2} {α : Type u_1} [Pure m] (x : Option α) (y : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Gets the value in an option, monadically computing a default value on `none`.\n\nThis is the monadic analogue of `Option.getD`.\n</code>",
 "1445":
 "<code>Lean.Order.Option.monotone_getDM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  {α : Type u} {γ : Type w} [PartialOrder γ] (o : Option α) (y : γ → m α) (hmono : monotone y) :\n  monotone fun x =&gt; o.getDM (y x)</code>",
 "1444":
 "<code>Option.elimM.{u_1, u_2} {m : Type u_1 → Type u_2} {α β : Type u_1} [Monad m] (x : m (Option α)) (y : m β)\n  (z : α → m β) : m β</code><span class=\"sep\"></span><code class=\"docstring\">A monadic case analysis function for `Option`.\n\nGiven a fallback computation for `none` and a monadic operation to apply to the contents of `some`,\n`Option.elimM` checks which constructor a given `Option` consists of, and uses the appropriate\nargument.\n\n`Option.elimM` can also be seen as a combination of `Option.mapM` and `Option.getDM`. It is a\nmonadic analogue of `Option.elim`.\n</code>",
 "1443":
 "<code>Lean.Order.Option.monotone_elimM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (a : γ → m (Option α)) (n : γ → m β) (s : γ → α → m β)\n  (hmono₁ : monotone a) (hmono₂ : monotone n) (hmono₃ : monotone s) : monotone fun x =&gt; Option.elimM (a x) (n x) (s x)</code>",
 "1442":
 "<code>Option.bindM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Pure m] (f : α → m (Option β)) :\n  Option α → m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Runs the monadic action `f` on `o`'s value, if any, and returns the result, or  `none` if there is\nno value.\n\nFrom the perspective of `Option` as a collection with at most one element, the monadic the function\nis applied to the element if present, and the final result is empty if either the initial or the\nresulting collections are empty.\n</code>",
 "1441":
 "<code>Lean.Order.Option.monotone_bindM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Option α) (hmono : monotone f) :\n  monotone fun x =&gt; Option.bindM (f x) xs</code>",
 "1440":
 "<code>Lean.Order.List.monotone_mapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m β) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.mapM (f x) xs</code>",
 "144": "<code>Tree.val.{u} {α : Type u} : α → Tree α</code>",
 "1439":
 "<code>List.forM.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} (as : List α) (f : α → m PUnit) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the list, in order.\n\n`List.mapM` is a variant that collects results. `List.forA` is a variant that works on any\n`Applicative`.\n</code>",
 "1438":
 "<code>Lean.Order.List.monotone_forM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m PUnit) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; xs.forM (f x)</code>",
 "1437":
 "<code>List.forIn'.loop.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : List α)\n  (f : (a : α) → a ∈ as → β → m (ForInStep β)) (as' : List α) (b : β) : (∃ bs, bs ++ as' = as) → m β</code>",
 "1436":
 "<code>Lean.Order.List.monotone_forIn'_loop.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : List α)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (as' : List α) (b : β) (p : ∃ bs, bs ++ as' = as)\n  (hmono : monotone f) : monotone fun x =&gt; List.forIn'.loop as (f x) as' b p</code>",
 "1435":
 "<code>Lean.Order.List.monotone_forIn'.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : List α) (init : β)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn' as init (f x)</code>",
 "1434":
 "<code>Lean.Order.List.monotone_forIn.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : List α) (init : β)\n  (f : γ → α → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn as init (f x)</code>",
 "1433":
 "<code>List.foldrM.{u, v, w} {m : Type u → Type v} [Monad m] {s : Type u} {α : Type w} (f : α → s → m s) (init : s)\n  (l : List α) : m s</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over a list from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in reverse order, using `f`.\n\nExample:\n```lean example\nexample [Monad m] (f : α → β → m β) :\n  List.foldrM (m := m) f x₀ [a, b, c] = (do\n    let x₁ ← f c x₀\n    let x₂ ← f b x₁\n    let x₃ ← f a x₂\n    pure x₃)\n  := by rfl\n```\n</code>",
 "1432":
 "<code>Lean.Order.List.monotone_foldrM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → β → m β) (init : β) (xs : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.foldrM (f x) init xs</code>",
 "1431":
 "<code>List.foldlM.{u, v, w} {m : Type u → Type v} [Monad m] {s : Type u} {α : Type w} (f : s → α → m s) (init : s) :\n  List α → m s</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nExample:\n```lean example\nexample [Monad m] (f : α → β → m α) :\n    List.foldlM (m := m) f x₀ [a, b, c] = (do\n      let x₁ ← f x₀ a\n      let x₂ ← f x₁ b\n      let x₃ ← f x₂ c\n      pure x₃)\n  := by rfl\n```\n</code>",
 "1430":
 "<code>Lean.Order.List.monotone_foldlM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → β → α → m β) (init : β) (xs : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.foldlM (f x) init xs</code>",
 "143": "<code>Tree.big (n : Nat) : Tree Nat</code>",
 "1429":
 "<code>List.findSomeM?.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} {β : Type u} (f : α → m (Option β)) :\n  List α → m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the monadic function `f` to each element of the\nlist, in order. Returns `none` if `f` returns `none` for all elements.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [7, 6, 5, 8, 1, 2, 6].findSomeM? fun i =&gt; do\n  if i &lt; 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 10\n```\n</code>",
 "1428":
 "<code>Lean.Order.List.monotone_findSomeM?.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.findSomeM? (f x) xs</code>",
 "1427":
 "<code>List.findM?.{u} {m : Type → Type u} [Monad m] {α : Type} (p : α → m Bool) : List α → m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the list for which the monadic predicate `p` returns `true`, or `none`\nif no such element is found. Elements of the list are checked in order.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [7, 6, 5, 8, 1, 2, 6].findM? fun i =&gt; do\n  if i &lt; 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 1\n```\n</code>",
 "1426":
 "<code>Lean.Order.List.monotone_findM?.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.findM? (f x) xs</code>",
 "1425":
 "<code>List.filterRevM.{v} {m : Type → Type v} [Monad m] {α : Type} (p : α → m Bool) (as : List α) : m (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` on every element in the list in reverse order, from right to left,\nand returns those elements for which `p` returns `true`. The elements of the returned list are in\nthe same order as in the input list.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterRevM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 7\nChecking 7\nChecking 2\nChecking 5\nChecking 2\nChecking 1\n```\n```output\n[1, 2, 2]\n```\n</code>",
 "1424":
 "<code>Lean.Order.List.monotone_filterRevM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.filterRevM (f x) xs</code>",
 "1423":
 "<code>List.filterM.{v} {m : Type → Type v} [Monad m] {α : Type} (p : α → m Bool) (as : List α) : m (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` to every element in the list, in order from left to right, and\nreturns the list of elements for which `p` returns `true`.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 1\nChecking 2\nChecking 5\nChecking 2\nChecking 7\nChecking 7\n```\n```output\n[1, 2, 2]\n```\n</code>",
 "1422":
 "<code>Lean.Order.List.monotone_filterM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.filterM (f x) xs</code>",
 "1421":
 "<code>List.filterAuxM.{v} {m : Type → Type v} [Monad m] {α : Type} (f : α → m Bool) : List α → List α → m (List α)</code>",
 "1420":
 "<code>Lean.Order.List.monotone_filterAuxM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs acc : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.filterAuxM (f x) xs acc</code>",
 "142": "<code>Tree.{u} (α : Type u) : Type u</code>",
 "1419":
 "<code>List.anyM.{u, v} {m : Type → Type u} [Monad m] {α : Type v} (p : α → m Bool) (l : List α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns true if the monadic predicate `p` returns `true` for any element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `true`. The elements in `l` are examined in\norder from left to right.\n</code>",
 "1418":
 "<code>Lean.Order.List.monotone_anyM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.anyM (f x) xs</code>",
 "1417":
 "<code>List.allM.{u, v} {m : Type → Type u} [Monad m] {α : Type v} (p : α → m Bool) (l : List α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns true if the monadic predicate `p` returns `true` for every element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `false`. The elements in `l` are examined in\norder from left to right.\n</code>",
 "1416":
 "<code>Lean.Order.List.monotone_allM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.allM (f x) xs</code>",
 "1415":
 "<code>Lean.Order.Functor.monotone_map.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : α → β)\n  (hmono : monotone f) : monotone fun x =&gt; g &lt;$&gt; f x</code>",
 "1414":
 "<code>Array.modifyM.{u, u_1} {α : Type u} {m : Type u → Type u_1} [Monad m] (xs : Array α) (i : Nat) (f : α → m α) :\n  m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying the monadic\nfunction `f` to it. If the index is invalid, the array is returned unmodified and `f` is not called.\n\nExamples:\n```lean example\n#eval #[1, 2, 3, 4].modifyM 2 fun x =&gt; do\n  IO.println s!\"It was {x}\"\n  return x * 10\n```\n```output\nIt was 3\n```\n```output\n#[1, 2, 30, 4]\n```\n\n```lean example\n#eval #[1, 2, 3, 4].modifyM 6 fun x =&gt; do\n  IO.println s!\"It was {x}\"\n  return x * 10\n```\n```output\n#[1, 2, 3, 4]\n```\n</code>",
 "1413":
 "<code>Lean.Order.Array.monotone_modifyM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α : Type u} {γ : Type w} [PartialOrder γ] (a : Array α) (i : Nat) (f : γ → α → m α)\n  (hmono : monotone f) : monotone fun x =&gt; a.modifyM i (f x)</code>",
 "1412":
 "<code>Array.mapM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → m β) (as : Array α) :\n  m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the array, left-to-right, and returns the array\nof results.\n</code>",
 "1411":
 "<code>Lean.Order.Array.monotone_mapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (xs : Array α) (f : γ → α → m β) (hmono : monotone f) :\n  monotone fun x =&gt; Array.mapM (f x) xs</code>",
 "1410":
 "<code>Array.mapFinIdxM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : Array α)\n  (f : (i : Nat) → α → i &lt; as.size → m β) : m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the array, along with the element's index and a\nproof that the index is in bounds, from left to right. Returns the array of results.\n</code>",
 "141":
 "<code>guard_msgs.diff</code><span class=\"sep\"></span><code class=\"docstring\">When true, show a diff between expected and actual messages if they don't match. </code>",
 "1409":
 "<code>Lean.Order.Array.monotone_mapFinIdxM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (xs : Array α) (f : γ → (i : Nat) → α → i &lt; xs.size → m β)\n  (hmono : monotone f) : monotone fun x =&gt; xs.mapFinIdxM (f x)</code>",
 "1408":
 "<code>Array.forIn'.loop.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : Array α)\n  (f : (a : α) → a ∈ as → β → m (ForInStep β)) (i : Nat) (h : i ≤ as.size) (b : β) : m β</code>",
 "1407":
 "<code>Lean.Order.Array.monotone_forIn'_loop.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : Array α)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (i : Nat) (h : i ≤ as.size) (b : β) (hmono : monotone f) :\n  monotone fun x =&gt; Array.forIn'.loop as (f x) i h b</code>",
 "1406":
 "<code>ForIn'.forIn'.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)}\n  {d : outParam (Membership α ρ)} [self : ForIn' m ρ α d] {β : Type u₁} [Monad m] (x : ρ) (b : β)\n  (f : (a : α) → a ∈ x → β → m (ForInStep β)) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Monadically iterates over the contents of a collection `xs`, with a local state `b` and the\npossibility of early termination. At each iteration, the body of the loop is provided with a proof\nthat the current element is in the collection.\n\nBecause a `do` block supports local mutable bindings along with `return`, and `break`, the monadic\naction passed to `ForIn'.forIn'` takes a starting state in addition to the current element of the\ncollection with its membership proof. The action returns an updated state together with an\nindication of whether iteration should continue or terminate. If the action returns\n`ForInStep.done`, then `ForIn'.forIn'` should stop iteration and return the updated state. If the\naction returns `ForInStep.yield`, then `ForIn'.forIn'` should continue iterating if there are\nfurther elements, passing the updated state to the action.\n\nMore information about the translation of `for` loops into `ForIn'.forIn'` is available in [the\nLean reference manual](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=monad-iteration-syntax).\n</code>",
 "1405":
 "<code>Lean.Order.Array.monotone_forIn'.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : Array α) (init : β)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn' as init (f x)</code>",
 "1404":
 "<code>ForIn.forIn.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)} [self : ForIn m ρ α]\n  {β : Type u₁} [Monad m] (xs : ρ) (b : β) (f : α → β → m (ForInStep β)) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Monadically iterates over the contents of a collection `xs`, with a local state `b` and the\npossibility of early termination.\n\nBecause a `do` block supports local mutable bindings along with `return`, and `break`, the monadic\naction passed to `ForIn.forIn` takes a starting state in addition to the current element of the\ncollection and returns an updated state together with an indication of whether iteration should\ncontinue or terminate. If the action returns `ForInStep.done`, then `ForIn.forIn` should stop\niteration and return the updated state. If the action returns `ForInStep.yield`, then\n`ForIn.forIn` should continue iterating if there are further elements, passing the updated state\nto the action.\n\nMore information about the translation of `for` loops into `ForIn.forIn` is available in [the Lean\nreference manual](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=monad-iteration-syntax).\n</code>",
 "1403":
 "<code>Lean.Order.Array.monotone_forIn.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : Array α) (init : β)\n  (f : γ → α → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn as init (f x)</code>",
 "1402":
 "<code>Array.foldrM.fold.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → β → m β) (as : Array α)\n  (stop i : Nat) (h : i ≤ as.size) (b : β) : m β</code>",
 "1401":
 "<code>Lean.Order.Array.monotone_foldrM_fold.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → β → m β) (xs : Array α) (stop i : Nat)\n  (h : i ≤ xs.size) (b : β) (hmono : monotone f) : monotone fun x =&gt; Array.foldrM.fold (f x) xs stop i h b</code>",
 "1400":
 "<code>Array.foldrM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → β → m β) (init : β)\n  (as : Array α) (start : Nat := as.size) (stop : Nat := 0) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over an array from the right, accumulating a value starting with `init`.\nThe accumulated value is combined with the each element of the list in reverse order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (exclusive) to `stop` (inclusive), so no folding occurs unless `start &gt; stop`.\nBy default, the entire array is folded.\n\nExamples:\n```lean example\nexample [Monad m] (f : α → β → m β) :\n  Array.foldrM (m := m) f x₀ #[a, b, c] = (do\n    let x₁ ← f c x₀\n    let x₂ ← f b x₁\n    let x₃ ← f a x₂\n    pure x₃)\n  := by rfl\n```\n\n```lean example\nexample [Monad m] (f : α → β → m β) :\n  Array.foldrM (m := m) f x₀ #[a, b, c] (start := 2) = (do\n    let x₁ ← f b x₀\n    let x₂ ← f a x₁\n    pure x₂)\n  := by rfl\n```\n</code>",
 "140":
 "<code>String.toList (s : String) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to a list of characters.\n\nSince strings are represented as dynamic arrays of bytes containing the string encoded using\nUTF-8, this operation takes time and space linear in the length of the string.\n\nExamples:\n * `\"abc\".toList = ['a', 'b', 'c']`\n * `\"\".toList = []`\n * `\"\\n\".toList = ['\\n']`\n</code>",
 "14":
 "<code>Nat.succ (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "1399":
 "<code>Lean.Order.Array.monotone_foldrM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → β → m β) (init : β) (xs : Array α)\n  (start stop : Nat) (hmono : monotone f) : monotone fun x =&gt; Array.foldrM (f x) init xs start stop</code>",
 "1398":
 "<code>Array.foldlM.loop.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : β → α → m β) (as : Array α)\n  (stop : Nat) (h : stop ≤ as.size) (i j : Nat) (b : β) : m β</code>",
 "1397":
 "<code>Lean.Order.Array.monotone_foldlM_loop.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → β → α → m β) (xs : Array α) (stop : Nat)\n  (h : stop ≤ xs.size) (i j : Nat) (b : β) (hmono : monotone f) :\n  monotone fun x =&gt; Array.foldlM.loop (f x) xs stop h i j b</code>",
 "1396":
 "<code>Array.foldlM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : β → α → m β) (init : β)\n  (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (inclusive) to `stop` (exclusive), so no folding occurs unless `start &lt; stop`.\nBy default, the entire array is folded.\n\nExamples:\n```lean example\nexample [Monad m] (f : α → β → m α) :\n    Array.foldlM (m := m) f x₀ #[a, b, c] = (do\n      let x₁ ← f x₀ a\n      let x₂ ← f x₁ b\n      let x₃ ← f x₂ c\n      pure x₃)\n  := by rfl\n```\n\n```lean example\nexample [Monad m] (f : α → β → m α) :\n    Array.foldlM (m := m) f x₀ #[a, b, c] (start := 1) = (do\n      let x₁ ← f x₀ b\n      let x₂ ← f x₁ c\n      pure x₂)\n  := by rfl\n```\n</code>",
 "1395":
 "<code>Lean.Order.Array.monotone_foldlM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → β → α → m β) (init : β) (xs : Array α)\n  (start stop : Nat) (hmono : monotone f) : monotone fun x =&gt; Array.foldlM (f x) init xs start stop</code>",
 "1394":
 "<code>Array.flatMapM.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β : Type u_1} [Monad m] (f : α → m (Array β))\n  (as : Array α) : m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function that returns an array to each element of an array, from left to right.\nThe resulting arrays are appended.\n</code>",
 "1393":
 "<code>Lean.Order.Array.monotone_flatMapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Array β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.flatMapM (f x) xs</code>",
 "1392":
 "<code>Array.findSomeRevM?.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → m (Option β))\n  (as : Array α) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the monadic function `f` to each element of the\narray in reverse order, from right to left. Once a non-`none` result is found, no further elements\nare checked. Returns `none` if `f` returns `none` for all elements of the array.\n\nExamples:\n```lean example\n#eval #[1, 2, 0, -4, 1].findSomeRevM? (m := Except String) fun x =&gt; do\n  if x = 0 then throw \"Zero!\"\n  else if x &lt; 0 then return (some x)\n  else return none\n```\n```output\nExcept.ok (some (-4))\n```\n```lean example\n#eval #[1, 2, 0, 4, 1].findSomeRevM? (m := Except String) fun x =&gt; do\n  if x = 0 then throw \"Zero!\"\n  else if x &lt; 0 then return (some x)\n  else return none\n```\n```output\nExcept.error \"Zero!\"\n```\n</code>",
 "1391":
 "<code>Lean.Order.Array.monotone_findSomeRevM?.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.findSomeRevM? (f x) xs</code>",
 "1390":
 "<code>Array.findSomeM?.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → m (Option β))\n  (as : Array α) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the monadic function `f` to each element of the\narray, in order. Returns `none` if `f` returns `none` for all elements.\n\nExample:\n```lean example\n#eval #[7, 6, 5, 8, 1, 2, 6].findSomeM? fun i =&gt; do\n  if i &lt; 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 10\n```\n</code>",
 "139": "<code><span class=\"literal string\">\"abc\"</span> : String</code>",
 "1389":
 "<code>Lean.Order.Array.monotone_findSomeM?.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.findSomeM? (f x) xs</code>",
 "1388":
 "<code>Array.findRevM?.{w} {α : Type} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) : m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of the array for which the monadic predicate `p` returns `true`, or `none`\nif no such element is found. Elements of the array are checked in reverse, from right to left..\n\nThe monad `m` is restricted to `Type → Type` to avoid needing to use `ULift Bool` in `p`'s type.\n\nExample:\n```lean example\n#eval #[7, 5, 8, 1, 2, 6, 5, 8].findRevM? fun i =&gt; do\n  if i &lt; 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\n```\n```output\nAlmost! 5\nAlmost! 6\n```\n```output\nsome 2\n```\n</code>",
 "1387":
 "<code>Lean.Order.Array.monotone_findRevM?.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : Array α) (hmono : monotone f) :\n  monotone fun x =&gt; Array.findRevM? (f x) xs</code>",
 "1386":
 "<code>Array.findM?.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → m Bool) (as : Array α) : m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the array for which the monadic predicate `p` returns `true`, or `none`\nif no such element is found. Elements of the array are checked in order.\n\nThe monad `m` is restricted to `Type → Type` to avoid needing to use `ULift Bool` in `p`'s type.\n\nExample:\n```lean example\n#eval #[7, 6, 5, 8, 1, 2, 6].findM? fun i =&gt; do\n  if i &lt; 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 1\n```\n</code>",
 "1385":
 "<code>Lean.Order.Array.monotone_findM?.{w} {γ : Type w} [PartialOrder γ] {m : Type → Type} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : Array α) (hmono : monotone f) :\n  monotone fun x =&gt; Array.findM? (f x) xs</code>",
 "1384":
 "<code>Array.findIdxM?.{u, u_1} {α : Type u} {m : Type → Type u_1} [Monad m] (p : α → m Bool) (as : Array α) : m (Option Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Finds the index of the first element of an array for which the monadic predicate `p` returns `true`.\nElements are examined in order from left to right, and the search is terminated when an element that\nsatisfies `p` is found. If no such element exists in the array, then `none` is returned.\n</code>",
 "1383":
 "<code>Lean.Order.Array.monotone_findIdxM?.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (hmono : monotone f) :\n  monotone fun x =&gt; Array.findIdxM? (f x) xs</code>",
 "1382":
 "<code>Array.forRevM.{u, v, w} {α : Type u} {m : Type v → Type w} [Monad m] (f : α → m PUnit) (as : Array α)\n  (start : Nat := as.size) (stop : Nat := 0) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to each element of an array from right to left, in reverse order.\n\nThe optional parameters `start` and `stop` control the region of the array to which `f` should be\napplied. Iteration proceeds from `start` (exclusive) to `stop` (inclusive), so no `f` is not invoked\nunless `start &gt; stop`. By default, the entire array is used.\n</code>",
 "1381":
 "<code>Lean.Order.Array.monotone_array_forRevM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m PUnit) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.forRevM (f x) xs start stop</code>",
 "1380":
 "<code>Array.forM.{u, v, w} {α : Type u} {m : Type v → Type w} [Monad m] (f : α → m PUnit) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to each element of an array, in order.\n\nThe optional parameters `start` and `stop` control the region of the array to which `f` should be\napplied. Iteration proceeds from `start` (inclusive) to `stop` (exclusive), so `f` is not invoked\nunless `start &lt; stop`. By default, the entire array is used.\n</code>",
 "138":
 "<code>reverse.helper.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code>",
 "1379":
 "<code>Lean.Order.Array.monotone_array_forM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m PUnit) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.forM (f x) xs start stop</code>",
 "1378":
 "<code>Array.filterMapM.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β : Type u_1} [Monad m] (f : α → m (Option β))\n  (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function that returns an `Option` to each element of an array, collecting the\nnon-`none` values.\n\nOnly elements from `start` (inclusive) to `stop` (exclusive) are considered. Elements outside that\nrange are discarded. By default, the entire array is considered.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterMapM fun x =&gt; do\n  IO.println s!\"Examining {x}\"\n  if x &gt; 2 then return some (2 * x)\n  else return none\n```\n```output\nExamining 1\nExamining 2\nExamining 5\nExamining 2\nExamining 7\nExamining 7\n```\n```output\n#[10, 14, 14]\n```\n</code>",
 "1377":
 "<code>Lean.Order.Array.monotone_array_filterMapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.filterMapM (f x) xs</code>",
 "1376":
 "<code>Array.anyM.loop.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) (stop : Nat)\n  (h : stop ≤ as.size) (j : Nat) : m Bool</code>",
 "1375":
 "<code>Lean.Order.Array.monotone_anyM_loop.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (stop : Nat)\n  (h : stop ≤ xs.size) (j : Nat) (hmono : monotone f) : monotone fun x =&gt; Array.anyM.loop (f x) xs stop h j</code>",
 "1374":
 "<code>Array.anyM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the monadic predicate `p` returns `true` for any element of `as`.\n\nShort-circuits upon encountering the first `true`. The elements in `as` are examined in order from\nleft to right.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n</code>",
 "1373":
 "<code>Lean.Order.Array.monotone_anyM.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.anyM (f x) xs start stop</code>",
 "1372":
 "<code>Array.allM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the monadic predicate `p` returns `true` for every element of `as`.\n\nShort-circuits upon encountering the first `false`. The elements in `as` are examined in order from\nleft to right.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n</code>",
 "1371":
 "<code>Lean.Order.Array.monotone_allM.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.allM (f x) xs start stop</code>",
 "1370": "<code class=\"docstring\">monotonicity theorem</code>",
 "137": "<code>reverse.{u_1} {α : Type u_1} : List α → List α</code>",
 "1369":
 "<code>Lean.Order.monotone_const.{u, v} {α : Sort u} [PartialOrder α] {β : Sort v} [PartialOrder β] (c : β) :\n  monotone fun x =&gt; c</code>",
 "1368":
 "<code class=\"docstring\">`monotonicity` performs one compositional step solving `monotone` goals,\nusing lemma tagged with `@[partial_fixpoint_monotone]`.\n\nThis tactic is mostly used internally by lean in `partial_fixpoint` definitions, but\ncan be useful on its own for debugging or when proving new `@[partial_fixpoint_monotone]` lemmas.\n</code>",
 "1367":
 "<code>Lean.Order.FlatOrder.{u} {α : Sort u} (b : α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">`FlatOrder b` wraps the type `α` with the flat partial order generated by `∀ x, b ⊑ x`.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1366":
 "<code>Lean.Order.FlatOrder.instCCPO.{u} {α : Sort u} {b : α} : CCPO (FlatOrder b)</code>",
 "1365":
 "<code>Lean.Order.instCCPOPi.{u, v} {α : Sort u} {β : α → Sort v} [(x : α) → CCPO (β x)] : CCPO ((x : α) → β x)</code>",
 "1364":
 "<code>Lean.Order.instCCPOOption.{u_1} {α : Type u_1} : CCPO (Option α)</code>",
 "1363":
 "<code>Lean.Order.monotone.{u, v} {α : Sort u} [PartialOrder α] {β : Sort v} [PartialOrder β] (f : α → β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function is monotone if it maps related elements to related elements.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1362": "<code>monotone f</code>",
 "1361": "<code>α → α</code>",
 "1360":
 "<code>Lean.Order.fix_eq.{u} {α : Sort u} [CCPO α] {f : α → α} (hf : monotone f) : fix f hf = f (fix f hf)</code><span class=\"sep\"></span><code class=\"docstring\">The main fixpoint theorem for fixed points of monotone functions in chain-complete partial orders.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "136":
 "<code class=\"docstring\">`trace msg` displays `msg` in the info view. </code>",
 "1359":
 "<code>Lean.Order.fix.{u} {α : Sort u} [CCPO α] (f : α → α) (hmono : monotone f) : α</code><span class=\"sep\"></span><code class=\"docstring\">The least fixpoint of a monotone function is the least upper bound of its transfinite iteration.\n\nThe `monotone f` assumption is not strictly necessarily for the definition, but without this the\ndefinition is not very meaningful and it simplifies applying theorems like `fix_eq` if every use of\n`fix` already has the monotonicity requirement.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1358": "<code>(α → Prop) → α</code>",
 "1357":
 "<code>Lean.Order.CCPO.csup.{u} {α : Sort u} [self : CCPO α] : (α → Prop) → α</code><span class=\"sep\"></span><code class=\"docstring\">The least upper bound of a chain.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used\notherwise.\n</code>",
 "1356":
 "<code>Lean.Order.chain.{u} {α : Sort u} [PartialOrder α] (c : α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A chain is a totally ordered set (representing a set as a predicate).\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1355":
 "<code>∀ {x : α} {c : α → Prop}, chain c → (CCPO.csup c ⊑ x ↔ ∀ (y : α), c y → y ⊑ x)</code><span class=\"sep\"></span><code class=\"docstring\">`csup c` is the least upper bound of the chain `c` when all elements `x` that are at\nleast as large as `csup c` are at least as large as all elements of `c`, and vice versa.\n</code>",
 "1354":
 "<code>(α → Prop) → α</code><span class=\"sep\"></span><code class=\"docstring\">The least upper bound of a chain.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used\notherwise.\n</code>",
 "1353":
 "<code>Lean.Order.CCPO.mk.{u} {α : Sort u} [toPartialOrder : PartialOrder α] (csup : (α → Prop) → α)\n  (csup_spec : ∀ {x : α} {c : α → Prop}, chain c → (csup c ⊑ x ↔ ∀ (y : α), c y → y ⊑ x)) : CCPO α</code>",
 "1352":
 "<code>∀ {x y : α}, x ⊑ y → y ⊑ x → x = y</code><span class=\"sep\"></span><code class=\"docstring\">The “less-or-equal-to” or “approximates” relation is antisymmetric. </code>",
 "1351":
 "<code>∀ {x y z : α}, x ⊑ y → y ⊑ z → x ⊑ z</code><span class=\"sep\"></span><code class=\"docstring\">The “less-or-equal-to” or “approximates” relation is transitive. </code>",
 "1350":
 "<code>Lean.Order.PartialOrder.rel.{u} {α : Sort u} [self : PartialOrder α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A “less-or-equal-to” or “approximates” relation.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "135": "<code>Sort u_1</code>",
 "1349":
 "<code>∀ {x : α}, x ⊑ x</code><span class=\"sep\"></span><code class=\"docstring\">The “less-or-equal-to” or “approximates” relation is reflexive. </code>",
 "1348":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A “less-or-equal-to” or “approximates” relation.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1347":
 "<code>Lean.Order.PartialOrder.mk.{u} {α : Sort u} (rel : α → α → Prop) (rel_refl : ∀ {x : α}, rel x x)\n  (rel_trans : ∀ {x y z : α}, rel x y → rel y z → rel x z) (rel_antisymm : ∀ {x y : α}, rel x y → rel y x → x = y) :\n  PartialOrder α</code>",
 "1346":
 "<code>Lean.Order.CCPO.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A chain-complete partial order (CCPO) is a partial order where every chain has a least upper bound.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used\notherwise.\n</code>",
 "1345":
 "<code>Lean.Order.PartialOrder.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A partial order is a reflexive, transitive and antisymmetric relation.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1344":
 "<code class=\"docstring\">This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n</code>",
 "1343": "<code>∃ x, ys[r']? = some x ∧ p x = true</code>",
 "1342":
 "<code class=\"docstring\">The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n</code>",
 "1341": "<code>r' + 1 = r</code>",
 "1340": "<code>findIndex ys = some r'</code>",
 "134":
 "<code class=\"docstring\">`/-- ... -/ #guard_msgs in cmd` captures the messages generated by the command `cmd`\nand checks that they match the contents of the docstring.\n\nBasic example:\n```lean\n/--\nerror: Unknown identifier `x`\n-/\n#guard_msgs in\nexample : α := x\n```\nThis checks that there is such an error and then consumes the message.\n\nBy default, the command captures all messages, but the filter condition can be adjusted.\nFor example, we can select only warnings:\n```lean\n/--\nwarning: declaration uses 'sorry'\n-/\n#guard_msgs(warning) in\nexample : α := sorry\n```\nor only errors\n```lean\n#guard_msgs(error) in\nexample : α := sorry\n```\nIn the previous example, since warnings are not captured there is a warning on `sorry`.\nWe can drop the warning completely with\n```lean\n#guard_msgs(error, drop warning) in\nexample : α := sorry\n```\n\nIn general, `#guard_msgs` accepts a comma-separated list of configuration clauses in parentheses:\n```\n#guard_msgs (configElt,*) in cmd\n```\nBy default, the configuration list is\n`(check all, whitespace := normalized, ordering := exact, positions := false)`.\n\nMessage filters select messages by severity:\n- `info`, `warning`, `error`: (non-trace) messages with the given severity level.\n- `trace`: trace messages\n- `all`: all messages.\n\nThe filters can be prefixed with the action to take:\n- `check` (the default): capture and check the message\n- `drop`: drop the message\n- `pass`: let the message pass through\n\nIf no filter is specified, `check all` is assumed.  Otherwise, these filters are processed in\nleft-to-right order, with an implicit `pass all` at the end.\n\nWhitespace handling (after trimming leading and trailing whitespace):\n- `whitespace := exact` requires an exact whitespace match.\n- `whitespace := normalized` converts all newline characters to a space before matching\n  (the default). This allows breaking long lines.\n- `whitespace := lax` collapses whitespace to a single space before matching.\n\nMessage ordering:\n- `ordering := exact` uses the exact ordering of the messages (the default).\n- `ordering := sorted` sorts the messages in lexicographic order.\n  This helps with testing commands that are non-deterministic in their ordering.\n\nPosition reporting:\n- `positions := true` reports the ranges of all messages relative to the line on which\n  `#guard_msgs` appears.\n- `positions := false` does not report position info.\n\nFor example, `#guard_msgs (error, drop all) in cmd` means to check warnings and drop\neverything else.\n\nThe command elaborator has special support for `#guard_msgs` for linting.\nThe `#guard_msgs` itself wants to capture linter warnings,\nso it elaborates the command it is attached to as if it were a top-level command.\nHowever, the command elaborator runs linters for *all* top-level commands,\nwhich would include `#guard_msgs` itself, and would cause duplicate and/or uncaptured linter warnings.\nThe top-level command elaborator only runs the linters if `#guard_msgs` is not present.\n</code>",
 "1339":
 "<code class=\"docstring\">The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n</code>",
 "1338": "<code>∃ a, findIndex ys = some a ∧ a + 1 = r</code>",
 "1337":
 "<code>Option.map_eq_some_iff.{u_1, u_2} {α✝ : Type u_1} {b : α✝} {α✝¹ : Type u_2} {x : Option α✝¹} {f : α✝¹ → α✝} :\n  Option.map f x = some b ↔ ∃ a, x = some a ∧ f a = b</code>",
 "1336":
 "<code>Option.map_eq_some'.{u_1, u_2} {α✝ : Type u_1} {b : α✝} {α✝¹ : Type u_2} {x : Option α✝¹} {f : α✝¹ → α✝} :\n  Option.map f x = some b ↔ ∃ a, x = some a ∧ f a = b</code>",
 "1335":
 "<code>Option.map_eq_map.{u_1} {α✝ α✝¹ : Type u_1} {f : α✝ → α✝¹} : Functor.map f = Option.map f</code>",
 "1334": "<code>(fun x =&gt; x + 1) &lt;$&gt; findIndex ys = some r</code>",
 "1333": "<code>¬p x = true</code>",
 "1332": "<code>some 0 = some r</code>",
 "1331": "<code>p x = true</code>",
 "1330":
 "<code>(if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) = some r</code>",
 "133": "<code>Lean.versionString : String</code>",
 "1329":
 "<code class=\"docstring\">`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n</code>",
 "1328":
 "<code class=\"docstring\">`next =&gt; tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ =&gt; tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n</code>",
 "1327":
 "<code>(if p x✝ = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys✝) = some r</code>",
 "1326": "<code>none = some r</code>",
 "1325":
 "<code>(match xs with\n  | [] =&gt; none\n  | x :: ys =&gt; if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) =\n  some r</code>",
 "1324":
 "<code>∀ (xs : List α) (r : Nat), findIndex xs = some r → ∃ x, xs[r]? = some x ∧ p x = true</code>",
 "1323":
 "<code>GetElem?.getElem?.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {valid : outParam (coll → idx → Prop)} [self : GetElem? coll idx elem valid] : coll → idx → Option elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]?` gets the `i`'th element of the collection `arr`,\nif it is present (and wraps it in `some`), and otherwise returns `none`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]?` in identifiers is `getElem?`.</code>",
 "1322":
 "<code>Exists.{u} {α : Sort u} (p : α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Existential quantification. If `p : α → Prop` is a predicate, then `∃ x : α, p x`\nasserts that there is some `x` of type `α` such that `p x` holds.\nTo create an existential proof, use the `exists` tactic,\nor the anonymous constructor notation `⟨x, h⟩`.\nTo unpack an existential, use `cases h` where `h` is a proof of `∃ x : α, p x`,\nor `let ⟨x, hx⟩ := h` where `.\n\nBecause Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:\n```\nexample (h : ∃ x : Nat, x = x) : Nat :=\n  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`\n  x\n```\nThe error message `recursor 'Exists.casesOn' can only eliminate into Prop` means\nthat this only works when the current goal is another proposition:\n```\nexample (h : ∃ x : Nat, x = x) : True :=\n  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`\n  trivial\n```\n</code>",
 "1321":
 "<code>List.findIndex_implies_pred.{u_1} {α : Type u_1} {i : Nat} (xs : List α) (p : α → Bool) :\n  xs.findIndex p = some i → ∃ x, xs[i]? = some x ∧ p x = true</code>",
 "1320": "<code>List α → Option Nat</code>",
 "132":
 "<code class=\"docstring\">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed\nwith `end &lt;id&gt;`. The `end` command is optional at the end of a file.\n</code>",
 "1319":
 "<code>∀ (findIndex : List α → Option Nat),\n  (∀ (xs : List α) (r : Nat), findIndex xs = some r → motive xs r) →\n    ∀ (xs : List α) (r : Nat),\n      (match xs with\n          | [] =&gt; none\n          | x :: ys =&gt; if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) =\n          some r →\n        motive xs r</code>",
 "1318": "<code>List α → Nat → Prop</code>",
 "1317":
 "<code>List.findIndex.partial_correctness.{u_1} {α : Type u_1} (p : α → Bool) (motive : List α → Nat → Prop)\n  (h :\n    ∀ (findIndex : List α → Option Nat),\n      (∀ (xs : List α) (r : Nat), findIndex xs = some r → motive xs r) →\n        ∀ (xs : List α) (r : Nat),\n          (match xs with\n              | [] =&gt; none\n              | x :: ys =&gt; if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) =\n              some r →\n            motive xs r)\n  (xs : List α) (r✝ : Nat) : xs.findIndex p = some r✝ → motive xs r✝</code>",
 "1316":
 "<code>Functor.map.{u, v} {f : Type u → Type v} [self : Functor f] {α β : Type u} : (α → β) → f α → f β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "1315":
 "<code>List.findIndex.{u_1} {α : Type u_1} (xs : List α) (p : α → Bool) : Option Nat</code>",
 "1314": "<code>List Tree</code>",
 "1313": "<code>Tree.rev' (t : Tree) : Option Tree</code>",
 "1312": "<code>Tree.mk (cs : List Tree) : Tree</code>",
 "1311": "<code>Tree</code>",
 "1310": "<code>Tree.rev (t : Tree) : Option Tree</code>",
 "131":
 "<code class=\"docstring\">`#where` gives a description of the state of the current scope scope.\nThis includes the current namespace, `open` namespaces, `universe` and `variable` commands,\nand options set with `set_option`.\n</code>",
 "1309": "<code>Tree.cs (self : Tree) : List Tree</code>",
 "1308": "<code>Tree : Type</code>",
 "1307": "<code>ack (n m : Nat) : Option Nat</code>",
 "1306":
 "<code>List.mapM.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} {β : Type u} (f : α → m β) (as : List α) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the list, left-to-right, and returns the list of\nresults.\n\nThis implementation is tail recursive. `List.mapM'` is a a non-tail-recursive variant that may be\nmore convenient to reason about. `List.forM` is the variant that discards the results and\n`List.mapA` is the variant that works with `Applicative`.\n</code>",
 "1305":
 "<code>Bind.bind.{u, v} {m : Type u → Type v} [self : Bind m] {α β : Type u} : m α → (α → m β) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "1304":
 "<code>Lean.Order.MonoBind.{u, v} (m : Type u → Type v) [Bind m] [(α : Type u) → PartialOrder (m α)] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">The class `MonoBind m` indicates that every `m α` has a `PartialOrder`, and that the bind operation\non `m` is monotone in both arguments with regard to that order.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1303":
 "<code>Lean.Order.monotone_ite.{u, v} {α : Sort u} {β : Sort v} [PartialOrder α] [PartialOrder β] (c : Prop) [Decidable c]\n  (k₁ k₂ : α → β) (hmono₁ : monotone k₁) (hmono₂ : monotone k₂) : monotone fun x =&gt; if c then k₁ x else k₂ x</code>",
 "1302":
 "<code class=\"docstring\">`have` is used to declare local hypotheses and opaque local definitions.\n\nIt has the same syntax as `let`, and it is equivalent to `let +nondep`,\ncreating a *nondependent* let expression.\n</code>",
 "1301":
 "<code>List.findIndex.{u_1} {α : Type u_1} (xs : List α) (p : α → Bool) : Int</code>",
 "1300":
 "<code>Array.find.{u_1} {α : Type u_1} (xs : Array α) (p : α → Bool) (i : Nat := 0) : Option α</code>",
 "130":
 "<code>pp.funBinderTypes</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display types of lambda parameters</code>",
 "13":
 "<code class=\"docstring\">The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n</code>",
 "1299": "<code>loop (x : Nat) : Nat</code>",
 "1298":
 "<code class=\"docstring\">Defines a possibly non-terminating function as a fixed-point in a suitable partial order.\n\nSuch a function is compiled as if it was marked `partial`, but its equations are provided as\ntheorems, so that it can be verified.\n\nIn general it accepts functions whose return type has a `Lean.Order.CCPO` instance and whose\ndefinition is `Lean.Order.monotone` with regard to its recursive calls.\n\nCommon special cases are\n\n* Functions whose type is inhabited a-priori (as with `partial`), and where all recursive\n  calls are in tail-call position.\n* Monadic in certain “monotone chain-complete monads” (in particular, `Option`) composed using\n  the bind operator and other supported monadic combinators.\n\nBy default, the monotonicity proof is performed by the compositional `monotonicity` tactic. Using\nthe syntax `partial_fixpoint monotonicity by $tac` the proof can be done manually.\n</code>",
 "1297": "<code>find (p : Nat → Bool) (i : Nat := 0) : Nat</code>",
 "1296": "<code>Nat → Bool</code>",
 "1295":
 "<code>ite_eq_right_iff.{u_1} {α : Sort u_1} {p : Prop} [Decidable p] {x y : α} : (if p then x else y) = y ↔ p → x = y</code>",
 "1294":
 "<code>ite_false.{u_1} {α : Sort u_1} (a b : α) : (if False then a else b) = b</code>",
 "1293":
 "<code>dite_false.{u} {α : Sort u} {t : False → α} {e : ¬False → α} : dite False t e = e not_false</code>",
 "1292":
 "<code>div.eq2 {k n : Nat} : ¬k = 0 → ¬k &gt; n → div n k = 1 + div (n - k) k</code>",
 "1291": "<code>k ≤ n</code>",
 "1290": "<code>Nat.not_lt {a b : Nat} : ¬a &lt; b ↔ b ≤ a</code>",
 "129":
 "<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {α : Type u}      -- implicit\n    (a : α)           -- explicit\n    [instBEq : BEq α] -- instance implicit, named\n    [Hashable α]      -- instance implicit, anonymous\n\n  def isEqual (b : α) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : α} := a == b ↔ b == a\n\n  #check eqComm\n  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src × String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {α : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString α]  -- available in the proof as `α` is included\n  (a : α)       -- available in the proof as mentioned in the header\n  {β : Type}    -- not available in the proof\n  [ToString β]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString α]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>",
 "1289":
 "<code>ite_eq_left_iff.{u_1} {α : Sort u_1} {p : Prop} [Decidable p] {x y : α} : (if p then x else y) = x ↔ ¬p → y = x</code>",
 "1288":
 "<code>dite_eq_ite.{u_1} {P : Prop} {α✝ : Sort u_1} {a b : α✝} [Decidable P] : (if x : P then a else b) = if P then a else b</code><span class=\"sep\"></span><code class=\"docstring\">A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. </code>",
 "1287":
 "<code>gt_iff_lt.{u_1} {α : Type u_1} [LT α] {x y : α} : x &gt; y ↔ y &lt; x</code>",
 "1286": "<code>WellFoundedRelation.rel y n</code>",
 "1285":
 "<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>",
 "1284": "<code>div.eq1 {k n : Nat} : k &gt; n → div n k = 0</code>",
 "1283": "<code>div._proof_2 : WellFounded WellFoundedRelation.rel</code>",
 "1282": "<code>div.eq0 {n : Nat} : div n 0 = 0</code>",
 "1281":
 "<code class=\"docstring\">`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n</code>",
 "1280":
 "<code>GT.gt.{u} {α : Type u} [LT α] (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a &gt; b` is an abbreviation for `b &lt; a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;` in identifiers is `gt`.</code>",
 "128":
 "<code class=\"docstring\">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside\nthe section:\n* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the\n  full name `Nat.seventeen`.\n* Names introduced by `export` declarations are also prefixed by the identifier.\n* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names\n  are preferred over names introduced by outer namespaces or `open`.\n* Within a namespace, declarations can be `protected`, which excludes them from the effects of\n  opening the namespace.\n\nAs with `section`, namespaces can be nested and the scope of a namespace is terminated by a\ncorresponding `end &lt;id&gt;` or the end of the file.\n\n`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.\n</code>",
 "1279": "<code>¬k &gt; n</code>",
 "1278": "<code>¬k = 0</code>",
 "1277": "<code>k &gt; n</code>",
 "1276": "<code>k = 0</code>",
 "1275": "<code>(y : Nat) → WellFoundedRelation.rel y n → Nat</code>",
 "1274":
 "<code>WellFoundedRelation.wf.{u} {α : Sort u} [self : WellFoundedRelation α] : WellFounded WellFoundedRelation.rel</code><span class=\"sep\"></span><code class=\"docstring\">A proof that `rel` is, in fact, well-founded. </code>",
 "1273":
 "<code>inferInstanceAs.{u} (α : Sort u) [i : α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`inferInstanceAs α` synthesizes a value of any target type by typeclass\ninference. This is just like `inferInstance` except that `α` is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some `α'` which is definitionally equal to `α`,\nbut the instance we are looking for is only registered for `α` (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:\n```\n#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n```\n</code>",
 "1272": "<code>∀ (y : α), r y x → Acc r y</code>",
 "1271":
 "<code>Acc.{u} {α : Sort u} (r : α → α → Prop) : α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Acc` is the accessibility predicate. Given some relation `r` (e.g. `&lt;`) and a value `x`,\n`Acc r x` means that `x` is accessible through `r`:\n\n`x` is accessible if there exists no infinite sequence `... &lt; y₂ &lt; y₁ &lt; y₀ &lt; x`.\n</code>",
 "1270": "<code>∀ (a : α), Acc r a</code>",
 "127":
 "<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ =&gt; a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>",
 "1269":
 "<code>PSum.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">The disjoint union of arbitrary sorts `α` `β`, or `α ⊕' β`.\n\nIt differs from `α ⊕ β` in that it allows `α` and `β` to have arbitrary sorts `Sort u` and `Sort v`,\ninstead of restricting them to `Type u` and `Type v`. This means that it can be used in situations\nwhere one side is a proposition, like `True ⊕' Nat`. However, the resulting universe level\nconstraints are often more difficult to solve than those that result from `Sum`.\n</code>",
 "1268":
 "<code>WellFounded.fix_eq.{u, v} {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : WellFounded r)\n  (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α) : hwf.fix F x = F x fun y x =&gt; hwf.fix F y</code>",
 "1267": "<code>WellFoundedRelation β</code>",
 "1266":
 "<code>PSigma.{u, v} {α : Sort u} (β : α → Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Fully universe-polymorphic dependent pairs, in which the second element's type depends on the value\nof the first element and both types are allowed to be propositions. The type `PSigma β` is typically\nwritten `Σ' a : α, β a` or `(a : α) ×' β a`.\n\nIn practice, this generality leads to universe level constraints that are difficult to solve, so\n`PSigma` is rarely used in manually-written code. It is usually only used in automation that\nconstructs pairs of arbitrary types.\n\nTo pair a value with a proof that a predicate holds for it, use `Subtype`. To demonstrate that a\nvalue exists that satisfies a predicate, use `Exists`. A dependent pair with a proposition as its\nfirst component is not typically useful due to proof irrelevance: there's no point in depending on a\nspecific proof because all proofs are equal anyway.\n</code>",
 "1265": "<code>(x : α) → ((y : α) → r y x → C y) → C x</code>",
 "1264": "<code>WellFounded r</code>",
 "1263":
 "<code>WellFounded.fix.{u, v} {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : WellFounded r)\n  (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α) : C x</code><span class=\"sep\"></span><code class=\"docstring\">A well-founded fixpoint. If satisfying the motive `C` for all values that are smaller according to a\nwell-founded relation allows it to be satisfied for the current value, then it is satisfied for all\nvalues.\n\nThis function is used as part of the elaboration of well-founded recursion.\n</code>",
 "1262":
 "<code class=\"docstring\">`done` succeeds iff there are no remaining goals. </code>",
 "1261":
 "<code class=\"docstring\">`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n</code>",
 "1260":
 "<code>Lean.Parser.Category.tactic : Lean.Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n</code>",
 "126":
 "<code class=\"docstring\">A `section`/`end` pair delimits the scope of `variable`, `include`, `open`, `set_option`, and `local`\ncommands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear\nwith the matching `end`. In either case, the `end` can be omitted, in which case the section is\nclosed at the end of the file.\n</code>",
 "1259":
 "<code><span class=\"literal string\">\"sizeOf_pair_dec\"</span> : String</code>",
 "1258": "<code>Subtype P</code>",
 "1257": "<code>Subtype P</code>",
 "1256": "<code>Pair (Subtype P)</code>",
 "1255":
 "<code>Pair.map_unattach.{u_1, u_2} {α : Type u_1} {β : Type u_2} {P : α → Prop} (p : Pair (Subtype P)) (f : α → β) :\n  map f p.unattach =\n    map\n      (fun x =&gt;\n        match x with\n        | ⟨x, h⟩ =&gt; binderNameHint x f (f (wfParam x)))\n      p</code>",
 "1254":
 "<code>Pair.map_wfParam.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (p : Pair α) :\n  map f (wfParam p) = map f p.attach.unattach</code>",
 "1253": "<code>sizeOf t' &lt; sizeOf p</code>",
 "1252": "<code>t' ∈ p</code>",
 "1251":
 "<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition's value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>",
 "1250": "<code>{ x // x ∈ p }</code>",
 "125":
 "<code>intersperse.eq_unfold.{u_1} :\n  @intersperse = fun {α} x x_1 =&gt;\n    match x_1 with\n    | y :: z :: zs =&gt; y :: x :: intersperse x (z :: zs)\n    | xs =&gt; xs</code>",
 "1249":
 "<code>Pair.unattach.{u_1} {α : Type u_1} {P : α → Prop} : Pair { x // P x } → Pair α</code>",
 "1248":
 "<code>Pair.attach.{u_1} {α : Type u_1} (p : Pair α) : Pair { x // x ∈ p }</code>",
 "1247": "<code>α</code>",
 "1246": "<code>Pair.mk.{u} {α : Type u} (fst snd : α) : Pair α</code>",
 "1245": "<code>SizeOf α</code>",
 "1244": "<code>x ∈ p</code>",
 "1243":
 "<code>Pair.sizeOf_lt_of_mem.{u_1} {α : Type u_1} [SizeOf α] {p : Pair α} {x : α} (h : x ∈ p) : sizeOf x &lt; sizeOf p</code>",
 "1242":
 "<code>Pair α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>",
 "1241":
 "<code>Membership.{u, v} (α : outParam (Type u)) (γ : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a ∈ s : Prop` where `a : α`, `s : γ`.\nBecause `α` is an `outParam`, the \"container type\" `γ` determines the type\nof the elements of the container.\n</code>",
 "1240":
 "<code>Pair.Mem.snd.{u_1} {α : Type u_1} {p : Pair α} : p.Mem p.snd</code>",
 "124":
 "<code>intersperse.eq_def.{u_1} {α : Type u_1} (x : α) (x✝ : List α) :\n  intersperse x x✝ =\n    match x✝ with\n    | y :: z :: zs =&gt; y :: x :: intersperse x (z :: zs)\n    | xs =&gt; xs</code>",
 "1239":
 "<code>Pair.Mem.fst.{u_1} {α : Type u_1} {p : Pair α} : p.Mem p.fst</code>",
 "1238": "<code>Pair.Mem.{u_1} {α : Type u_1} (p : Pair α) : α → Prop</code>",
 "1237": "<code>Pair (Tree α)</code>",
 "1236": "<code>Tree.node.{u} {α : Type u} : Pair (Tree α) → Tree α</code>",
 "1235": "<code>Tree.leaf.{u} {α : Type u} : α → Tree α</code>",
 "1234":
 "<code>Tree.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A binary tree defined using `Pair` </code>",
 "1233":
 "<code>Tree.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) : Tree α → Tree β</code>",
 "1232": "<code>β</code>",
 "1231": "<code>Pair α</code>",
 "1230":
 "<code>Pair.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (p : Pair α) : Pair β</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a function over the elements of a pair </code>",
 "123":
 "<code>intersperse.{u_1} {α : Type u_1} (x : α) : List α → List α</code>",
 "1229":
 "<code>Pair.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A homogeneous pair </code>",
 "1228":
 "<code>trace.Elab.definition.wf</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "1227":
 "<code>wf.preprocess</code><span class=\"sep\"></span><code class=\"docstring\">pre-process definitions defined by well-founded recursion with the `wf_preprocess` simp set</code>",
 "1226": "<code>P x</code>",
 "1225": "<code>List { x // P x }</code>",
 "1224":
 "<code>List.map_unattach.{u_1, u_2} {α : Type u_1} {β : Type u_2} {P : α → Prop} {xs : List (Subtype P)} {f : α → β} :\n  List.map f xs.unattach =\n    List.map\n      (fun x =&gt;\n        match x with\n        | ⟨x, h⟩ =&gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))\n      xs</code>",
 "1223":
 "<code>List.unattach.{u_1} {α : Type u_1} {p : α → Prop} (l : List { x // p x }) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Maps a list of terms in a subtype to the corresponding terms in the type by forgetting that they\nsatisfy the predicate.\n\nThis is the inverse of `List.attachWith` and a synonym for `l.map (·.val)`.\n\nMostly this should not be needed by users. It is introduced as an intermediate step by lemmas such\nas `map_subtype`, and is ideally subsequently simplified away by `unattach_attach`.\n\nThis function is usually inserted automatically by Lean as an intermediate step while proving\ntermination. It is rarely used explicitly in code. It is introduced as an intermediate step during\nthe elaboration of definitions by [well-founded\nrecursion](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=well-founded-recursion). If this function is encountered in a proof\nstate, the right approach is usually the tactic `simp [List.unattach, -List.map_subtype]`.\n</code>",
 "1222":
 "<code>List.map_wfParam.{u_1, u_2} {α : Type u_1} {β : Type u_2} {xs : List α} {f : α → β} :\n  List.map f (wfParam xs) = List.map f xs.attach.unattach</code>",
 "1221": "<code>¬P</code>",
 "1220":
 "<code>binderNameHint.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} (v : α) (binder : β) (e : γ) : γ</code><span class=\"sep\"></span><code class=\"docstring\">The expression `binderNameHint v binder e` defined to be `e`.\n\nIf it is used on the right-hand side of an equation that is used for rewriting by `rw` or `simp`,\nand `v` is a local variable, and `binder` is an expression that (after beta-reduction) is a binder\n(`fun w =&gt; …` or `∀ w, …`), then it will rename `v` to the name used in that binder, and remove\nthe `binderNameHint`.\n\nA typical use of this gadget would be as follows; the gadget ensures that after rewriting, the local\nvariable is still `name`, and not `x`:\n```\ntheorem all_eq_not_any_not (l : List α) (p : α → Bool) :\n    l.all p = !l.any fun x =&gt; binderNameHint x p (!p x) := sorry\n\nexample (names : List String) : names.all (fun name =&gt; \"Waldo\".isPrefixOf name) = true := by\n  rw [all_eq_not_any_not]\n  -- ⊢ (!names.any fun name =&gt; !\"Waldo\".isPrefixOf name) = true\n```\n\nIf `binder` is not a binder, then the name of `v` attains a macro scope. This only matters when the\nresulting term is used in a non-hygienic way, e.g. in termination proofs for well-founded recursion.\n\nThis gadget is supported by\n* `simp`, `dsimp` and `rw` in the right-hand-side of an equation\n* `simp` in the assumptions of congruence rules\n\nIt is ineffective in other positions (hypotheses of rewrite rules) or when used by other tactics\n(e.g. `apply`).\n</code>",
 "122":
 "<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `∧` over `/\\`).</code>",
 "1219":
 "<code>ite_eq_dite.{u_1} {P : Prop} {α✝ : Sort u_1} {a b : α✝} [Decidable P] :\n  (if P then a else b) = if h : P then binderNameHint h () a else binderNameHint h () b</code><span class=\"sep\"></span><code class=\"docstring\">Reverse direction of `dite_eq_ite`. Used by the well-founded definition preprocessor to extend the\ncontext of a termination proof inside `if-then-else` with the condition.\n</code>",
 "1218":
 "<code>List.attach.{u_1} {α : Type u_1} (l : List α) : List { x // x ∈ l }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” the proof that the elements of `l` are in fact elements of `l`, producing a new list with\nthe same elements but in the subtype `{ x // x ∈ l }`.\n\n`O(1)`.\n\nThis function is primarily used to allow definitions by [well-founded\nrecursion](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=well-founded-recursion) that use higher-order functions (such as\n`List.map`) to prove that an value taken from a list is smaller than the list. This allows the\nwell-founded recursion mechanism to prove that the function terminates.\n</code>",
 "1217":
 "<code class=\"docstring\">In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n</code>",
 "1216":
 "<code class=\"docstring\">In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n</code>",
 "1215":
 "<code class=\"docstring\">Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined\nby well-founded recursion. They are applied to the function's body to add additional hypotheses,\nsuch as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with\n`xs.attach.map`. Also see `wfParam`.\n</code>",
 "1214":
 "<code class=\"docstring\">simp lemma used in the preprocessing of well-founded recursive function definitions, in particular to add additional hypotheses to the context. Also see `wfParam`.</code>",
 "1213":
 "<code>wfParam.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The `wfParam` gadget is used internally during the construction of recursive functions by\nwellfounded recursion, to keep track of the parameter for which the automatic introduction\nof `List.attach` (or similar) is plausible.\n</code>",
 "1212": "<code>f (n : Nat) : Nat</code>",
 "1211": "<code>g (n : Nat) : Nat</code>",
 "1210": "<code>notAck : Nat → Nat → Nat</code>",
 "121":
 "<code>HXor.hXor.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HXor α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^^^` in identifiers is `xor`.</code>",
 "1209": "<code>i &lt; j</code>",
 "1208": "<code>autoParam (j ≤ xs.size) _auto✝</code>",
 "1207":
 "<code>binarySearch.go (x : Int) (xs : Array Int) (i j : Nat) (hj : j ≤ xs.size := by omega) : Option Nat</code>",
 "1206": "<code>Array Int</code>",
 "1205": "<code>binarySearch (x : Int) (xs : Array Int) : Option Nat</code>",
 "1204": "<code>f (n m l : Nat) : Nat</code>",
 "1203":
 "<code>PSigma.mk.{u, v} {α : Sort u} {β : α → Sort v} (fst : α) (snd : β fst) : PSigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a fully universe-polymorphic dependent pair. </code>",
 "1202":
 "<code>Prod.instWellFoundedRelation.{u, v} {α : Type u} {β : Type v} [ha : WellFoundedRelation α]\n  [hb : WellFoundedRelation β] : WellFoundedRelation (α × β)</code>",
 "1201":
 "<code>PSigma.casesOn.{u_1, u, v} {α : Sort u} {β : α → Sort v} {motive : PSigma β → Sort u_1} (t : PSigma β)\n  (mk : (fst : α) → (snd : β fst) → motive ⟨fst, snd⟩) : motive t</code>",
 "1200":
 "<code>invImage.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} (f : α → β) (h : WellFoundedRelation β) : WellFoundedRelation α</code><span class=\"sep\"></span><code class=\"docstring\">The inverse image of a well-founded relation is well-founded.\n</code>",
 "120":
 "<code>Prod.mk.injEq.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) (fst✝ : α) (snd✝ : β) :\n  ((fst, snd) = (fst✝, snd✝)) = (fst = fst✝ ∧ snd = snd✝)</code>",
 "12":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "1199": "<code>(_ : Nat) ×' Nat</code>",
 "1198":
 "<code>(y : (_ : Nat) ×' Nat) →\n  (invImage (fun x =&gt; PSigma.casesOn x fun a a_1 =&gt; (a, a_1)) Prod.instWellFoundedRelation).1 y ⟨m.succ, n.succ⟩ → Nat</code>",
 "1197":
 "<code>Nat.lt (n m : Nat) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Strict inequality of natural numbers, usually accessed via the `&lt;` operator.\n\nIt is defined as `n &lt; m = n + 1 ≤ m`.\n</code>",
 "1196": "<code>a₁ ≤ a₂</code>",
 "1195":
 "<code>Prod.Lex.right'.{v} {β : Type v} (rb : β → β → Prop) {a₂ : Nat} {b₂ : β} {a₁ : Nat} {b₁ : β} (h₁ : a₁ ≤ a₂)\n  (h₂ : rb b₁ b₂) : Prod.Lex Nat.lt rb (a₁, b₁) (a₂, b₂)</code>",
 "1194":
 "<code>HDiv.hDiv.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HDiv α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b &lt; natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.</code>",
 "1193": "<code>synack : Nat → Nat → Nat</code>",
 "1192":
 "<code>Prod.Lex.{u, v} {α : Type u} {β : Type v} (ra : α → α → Prop) (rb : β → β → Prop) : α × β → α × β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A lexicographical order based on the orders `ra` and `rb` for the elements of pairs.\n</code>",
 "1191": "<code>rb b₁ b₂</code>",
 "1190": "<code>β → β → Prop</code>",
 "119":
 "<code class=\"docstring\">Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool =&gt; ...) = (fun x =&gt; ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n</code>",
 "1189": "<code>ack : Nat → Nat → Nat</code>",
 "1188":
 "<code>String.Iterator.sizeOf_next_lt_of_atEnd (i : String.Iterator) (h : ¬i.atEnd = true) : sizeOf i.next &lt; sizeOf i</code>",
 "1187":
 "<code>String.Iterator.sizeOf_next_lt_of_hasNext (i : String.Iterator) (h : i.hasNext = true) : sizeOf i.next &lt; sizeOf i</code>",
 "1186":
 "<code class=\"docstring\">This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a &lt; sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. </code>",
 "1185":
 "<code class=\"docstring\">This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a &lt; sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. </code>",
 "1184":
 "<code class=\"docstring\">This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] &lt; sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. </code>",
 "1183": "<code>Nat.pred_lt {n : Nat} : n ≠ 0 → n.pred &lt; n</code>",
 "1182":
 "<code>Nat.pred_lt_of_lt {n m : Nat} (h : m &lt; n) : n.pred &lt; n</code>",
 "1181":
 "<code>Nat.sub_succ_lt_self (a i : Nat) (h : i &lt; a) : a - (i + 1) &lt; a - i</code>",
 "1180":
 "<code class=\"docstring\">`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n</code>",
 "118": "<code>swap_eq_swap' : swap = swap'</code>",
 "1179":
 "<code>Prod.Lex.left.{u, v} {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} {a₁ : α} (b₁ : β) {a₂ : α}\n  (b₂ : β) (h : ra a₁ a₂) : Prod.Lex ra rb (a₁, b₁) (a₂, b₂)</code><span class=\"sep\"></span><code class=\"docstring\">If the first projections of two pairs are ordered, then they are lexicographically ordered.\n</code>",
 "1178":
 "<code>Prod.Lex.right.{u, v} {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} (a : α) {b₁ b₂ : β}\n  (h : rb b₁ b₂) : Prod.Lex ra rb (a, b₁) (a, b₂)</code><span class=\"sep\"></span><code class=\"docstring\">If the first projections of two pairs are equal, then they are lexicographically ordered if the\nsecond projections are ordered.\n</code>",
 "1177":
 "<code class=\"docstring\">`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). </code>",
 "1176":
 "<code>List.myMap.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (l : List α) : List β</code>",
 "1175": "<code>x ∈ xs</code>",
 "1174":
 "<code>List.sum.{u_1} {α : Type u_1} [Add α] [Zero α] : List α → α</code><span class=\"sep\"></span><code class=\"docstring\">Computes the sum of the elements of a list.\n\nExamples:\n* `[a, b, c].sum = a + (b + (c + 0))`\n* `[1, 2, 5].sum = 8`\n</code>",
 "1173": "<code>f (n : Nat) (xs : List Nat) : Nat</code>",
 "1172": "<code>List Nat</code>",
 "1171":
 "<code>Membership.mem.{u, v} {α : outParam (Type u)} {γ : Type v} [self : Membership α γ] : γ → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>",
 "1170": "<code>i ∈ [:xs.size]</code>",
 "117":
 "<code class=\"docstring\">Close fixed-width `BitVec` and `Bool` goals by obtaining a proof from an external SAT solver and\nverifying it inside Lean. The solvable goals are currently limited to\n- the Lean equivalent of [`QF_BV`](https://smt-lib.org/logics-all.shtml#QF_BV)\n- automatically splitting up `structure`s that contain information about `BitVec` or `Bool`\n```lean\nexample : ∀ (a b : BitVec 64), (a &&& b) + (a ^^^ b) = a ||| b := by\n  intros\n  bv_decide\n```\n\nIf `bv_decide` encounters an unknown definition it will be treated like an unconstrained `BitVec`\nvariable. Sometimes this enables solving goals despite not understanding the definition because\nthe precise properties of the definition do not matter in the specific proof.\n\nIf `bv_decide` fails to close a goal it provides a counter-example, containing assignments for all\nterms that were considered as variables.\n\nIn order to avoid calling a SAT solver every time, the proof can be cached with `bv_decide?`.\n\nIf solving your problem relies inherently on using associativity or commutativity, consider enabling\nthe `bv.ac_nf` option.\n\n\nNote: `bv_decide` uses `ofReduceBool` and thus trusts the correctness of the code generator.\n\nNote: include `import Std.Tactic.BVDecide`\n</code>",
 "1169":
 "<code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "1168":
 "<code>Array.take.{u} {α : Type u} (xs : Array α) (i : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new array that contains the first `i` elements of `xs`. If `xs` has fewer than `i`\nelements, the new array contains all the elements of `xs`.\n\nThe returned array is always a new array, even if it contains the same elements as the input array.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\"].take 1 = #[\"red\"]`\n* `#[\"red\", \"green\", \"blue\"].take 2 = #[\"red\", \"green\"]`\n* `#[\"red\", \"green\", \"blue\"].take 5 = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "1167":
 "<code class=\"docstring\">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.\n`break` and `continue` are supported inside `for` loops.\n`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,\nuntil at least one of them is exhausted.\nThe types of `e2` etc. must implement the `Std.ToStream` typeclass.\n</code>",
 "1166":
 "<code>Array.sum.{u_1} {α : Type u_1} [Add α] [Zero α] : Array α → α</code><span class=\"sep\"></span><code class=\"docstring\">Computes the sum of the elements of an array.\n\nExamples:\n* `#[a, b, c].sum = a + (b + (c + 0))`\n* `#[1, 2, 5].sum = 8`\n</code>",
 "1165":
 "<code>Id.run.{u_1} {α : Type u_1} (x : Id α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Runs a computation in the identity monad.\n\nThis function is the identity function. Because its parameter has type `Id α`, it causes\n`do`-notation in its arguments to use the `Monad Id` instance.\n</code>",
 "1164": "<code>f (xs : Array Nat) : Nat</code>",
 "1163": "<code>Std.Range : Type</code>",
 "1162": "<code class=\"docstring\">`skip` does nothing. </code>",
 "1161": "<code>¬n ≤ 1</code>",
 "1160": "<code>n ≤ 1</code>",
 "116":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n</code>",
 "1159":
 "<code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "1158": "<code>fib (n : Nat) : Nat</code>",
 "1157":
 "<code class=\"docstring\">Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) =&gt; `(tactic| linarith)\n```\n</code>",
 "1156": "<code>β p₁</code>",
 "1155": "<code>β a₁</code>",
 "1154": "<code>(x : α) → β x → β' → γ</code>",
 "1153":
 "<code>default.sizeOf.{u} (α : Sort u) : α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Every type `α` has a default `SizeOf` instance that just returns `0`\nfor every element of `α`.\n</code>",
 "1152":
 "<code class=\"docstring\">Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n</code>",
 "1151": "<code>Bool → Bool</code>",
 "1150": "<code>fooInst (b : Bool → Bool) : Unit</code>",
 "115": "<code>swap' (x y : BitVec 32) : BitVec 32 × BitVec 32</code>",
 "1149":
 "<code>instSizeOfDefault.{u} (α : Sort u) : SizeOf α</code><span class=\"sep\"></span><code class=\"docstring\">Every type `α` has a low priority default `SizeOf` instance that just returns `0`\nfor every element of `α`.\n</code>",
 "1148": "<code>γ</code>",
 "1147":
 "<code>SizeOf.sizeOf.{u} {α : Sort u} [self : SizeOf α] : α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The \"size\" of an element, a natural number which decreases on fields of\neach inductive type. </code>",
 "1146":
 "<code>WellFoundedRelation.rel.{u} {α : Sort u} [self : WellFoundedRelation α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A well-founded relation on `α`. </code>",
 "1145":
 "<code>WellFounded.{u} {α : Sort u} (r : α → α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A relation `r` is `WellFounded` if all elements of `α` are accessible within `r`.\nIf a relation is `WellFounded`, it does not allow for an infinite descent along the relation.\n\nIf the arguments of the recursive calls in a function definition decrease according to\na well founded relation, then the function terminates.\nWell-founded relations are sometimes called _Artinian_ or said to satisfy the “descending chain condition”.\n</code>",
 "1144":
 "<code>WellFounded WellFoundedRelation.rel</code><span class=\"sep\"></span><code class=\"docstring\">A proof that `rel` is, in fact, well-founded. </code>",
 "1143":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A well-founded relation on `α`. </code>",
 "1142":
 "<code>WellFoundedRelation.mk.{u} {α : Sort u} (rel : α → α → Prop) (wf : WellFounded rel) : WellFoundedRelation α</code>",
 "1141":
 "<code>WellFoundedRelation.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A type that has a standard well-founded relation.\n\nInstances are used to prove that functions terminate using well-founded recursion by showing that\nrecursive calls reduce some measure according to a well-founded relation. This relation can combine\nwell-founded relations on the recursive function's parameters.\n</code>",
 "1140": "<code>div (n k : Nat) : Nat</code>",
 "114":
 "<code>BitVec (w : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A bitvector of the specified width.\n\nThis is represented as the underlying `Nat` number in both the runtime\nand the kernel, inheriting all the special support for `Nat`.\n</code>",
 "1139": "<code>Nat.below n</code>",
 "1138": "<code>half'' : Nat → Nat</code>",
 "1137": "<code>(fun x =&gt; Nat) 1</code>",
 "1136": "<code>(fun x =&gt; Nat) Nat.zero</code>",
 "1135": "<code>half' : Nat → Nat</code>",
 "1134":
 "<code>half.match_1'.{u} (motive : Nat → Sort u) (x : Nat) :\n  (Unit → motive Nat.zero) → (Unit → motive 1) → ((n : Nat) → motive n.succ.succ) → motive x</code>",
 "1133":
 "<code>half.match_1.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive Nat.zero) (h_2 : Unit → motive 1)\n  (h_3 : (n : Nat) → motive n.succ.succ) : motive x✝</code>",
 "1132": "<code>(n : Nat) → motive n.succ.succ</code>",
 "1131": "<code>Unit → motive 1</code>",
 "1130": "<code>Unit → motive Nat.zero</code>",
 "113": "<code>BitVec 32</code>",
 "1129": "<code>Nat → Sort u_1</code>",
 "1128":
 "<code>pp.all</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing</code>",
 "1127":
 "<code>trace.Elab.definition.body</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "1126":
 "<code>Tree.brecOn'.{u} {α : Type u} {motive : Tree α → Sort u} (t : Tree α) (step : (ys : Tree α) → below' ys → motive ys) :\n  motive t</code>",
 "1125":
 "<code>List.brecOn'.{u} {α : Type u} {motive : List α → Sort u} (xs : List α) (step : (ys : List α) → below' ys → motive ys) :\n  motive xs</code>",
 "1124": "<code>below' (left.branch val✝ right)</code>",
 "1123": "<code>motive (left.branch val✝ right)</code>",
 "1122": "<code>below' (left.branch val right)</code>",
 "1121": "<code>motive right ×' below' right</code>",
 "1120": "<code>motive left ×' below' left</code>",
 "112": "<code>swap (x y : BitVec 32) : BitVec 32 × BitVec 32</code>",
 "1119": "<code>(ys : Tree α) → below' ys → motive ys</code>",
 "1118":
 "<code>Tree.brecOnTable.{u} {α : Type u} {motive : Tree α → Sort u} (t : Tree α)\n  (step : (ys : Tree α) → below' ys → motive ys) : motive t ×' below' t</code>",
 "1117":
 "<code>PProd.mk.{u, v} {α : Sort u} {β : Sort v} (fst : α) (snd : β) : α ×' β</code>",
 "1116": "<code>motive (x :: xs)</code>",
 "1115": "<code>motive xs ×' below' xs</code>",
 "1114": "<code>(ys : List α) → below' ys → motive ys</code>",
 "1113":
 "<code>List.brecOnTable.{u} {α : Type u} {motive : List α → Sort u} (xs : List α)\n  (step : (ys : List α) → below' ys → motive ys) : motive xs ×' below' xs</code>",
 "1112":
 "<code>Tree.brecOnTable.{u} {α : Type u} {motive : Tree α → Sort u} (t : Tree α)\n  (step : (ys : Tree α) → Tree.below' ys → motive ys) : motive t ×' Tree.below' t</code>",
 "1111":
 "<code>List.brecOnTable.{u} {α : Type u} {motive : List α → Sort u} (xs : List α)\n  (step : (ys : List α) → List.below' ys → motive ys) : motive xs ×' List.below' xs</code>",
 "1110":
 "<code>Tree.brecOn.{u_1, u} {α : Type u} {motive : Tree α → Sort u_1} (t : Tree α)\n  (F_1 : (t : Tree α) → Tree.below t → motive t) : motive t</code>",
 "111": "<code><span class=\"literal string\">\"one\"</span> : String</code>",
 "1109":
 "<code>List.brecOn.{u_1, u} {α : Type u} {motive : List α → Sort u_1} (t : List α)\n  (F_1 : (t : List α) → List.below t → motive t) : motive t</code>",
 "1108": "<code>Tree α → Sort u</code>",
 "1107":
 "<code>Tree.below'.{u} {α : Type u} {motive : Tree α → Sort u} : Tree α → Type u</code>",
 "1106": "<code>Tree α</code>",
 "1105":
 "<code>Tree.branch.{u} {α : Type u} (left : Tree α) (val : α) (right : Tree α) : Tree α</code>",
 "1104": "<code>Tree.leaf.{u} {α : Type u} : Tree α</code>",
 "1103":
 "<code>List.below'.{u} {α : Type u} {motive : List α → Sort u} : List α → Type u</code>",
 "1102":
 "<code>List.below.{u_1, u} {α : Type u} {motive : List α → Sort u_1} (t : List α) : Sort (max (u + 1) u_1)</code>",
 "1101": "<code>Nat.below x✝.succ.succ</code>",
 "1100": "<code>half''' (n : Nat) : Nat</code>",
 "110": "<code>?m.7</code>",
 "11":
 "<code>False : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "1099":
 "<code>Nat.casesOn.{u} {motive : Nat → Sort u} (t : Nat) (zero : motive Nat.zero) (succ : (n : Nat) → motive n.succ) : motive t</code>",
 "1098": "<code>(fun x =&gt; Nat) (n✝ + 2)</code>",
 "1097": "<code>(fun x =&gt; Nat) n✝</code>",
 "1096": "<code>Nat.below k</code>",
 "1095": "<code>half'' (n : Nat) : Nat</code>",
 "1094":
 "<code>Nat.brecOn.{u} {motive : Nat → Sort u} (t : Nat) (F_1 : (t : Nat) → Nat.below t → motive t) : motive t</code>",
 "1093": "<code>Nat → Sort u</code>",
 "1092":
 "<code>Nat.below.{u} {motive : Nat → Sort u} (t : Nat) : Sort (max 1 u)</code>",
 "1091": "<code>half' (n : Nat) : Nat</code>",
 "1090": "<code>(fun x =&gt; Bool → Nat) x✝</code>",
 "109":
 "<code>HAdd.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous addition.\nThis enables the notation `a + b : γ` where `a : α`, `b : β`.\n</code>",
 "1089": "<code>helper : Nat → Bool → Nat</code>",
 "1088": "<code>(fun x =&gt; Nat) k</code>",
 "1087": "<code>add' (n t : Nat) : (fun x =&gt; Nat) t</code>",
 "1086":
 "<code>Nat.zero : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "1085": "<code>add (n : Nat) : Nat → Nat</code>",
 "1084": "<code>App.numArgs : App → Nat</code>",
 "1083": "<code>Exp</code>",
 "1082": "<code>App</code>",
 "1081": "<code>App.app : App → Exp → App</code>",
 "1080": "<code>App.fn : String → App</code>",
 "108":
 "<code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">The list whose first element is `head`, where `tail` is the rest of the list.\nUsually written `head :: tail`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `::` in identifiers is `cons`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.</code>",
 "1079": "<code>App : Type</code>",
 "1078": "<code>Exp.app : App → Exp</code>",
 "1077": "<code>Exp.var : String → Exp</code>",
 "1076": "<code>Exp : Type</code>",
 "1075": "<code>App.size : App → Nat</code>",
 "1074": "<code>Exp.size : Exp → Nat</code>",
 "1073": "<code>odd : Nat → Prop</code>",
 "1072": "<code>even : Nat → Prop</code>",
 "1071": "<code>min' (nk : Nat × Nat) : Nat</code>",
 "1070": "<code>min' (n k : Nat) : Nat</code>",
 "107": "<code>?m.4</code>",
 "1069": "<code>listLen.{u} {α : Type u} : List α → Nat</code>",
 "1068":
 "<code>List.tail.{u} {α : Type u} : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. Returns `[]` when the argument is\nempty.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tail = [\"banana\", \"grape\"]`\n * `[\"apple\"].tail = []`\n * `([] : List String).tail = []`\n</code>",
 "1067": "<code>n = n' + 1 + 1</code>",
 "1066":
 "<code class=\"docstring\">Manually prove that the termination measure (as specified with `termination_by` or inferred)\ndecreases at each recursive call.\n\nBy default, the tactic `decreasing_tactic` is used.\n\nForces the use of well-founded recursion and is hence incompatible with\n`termination_by structural`.\n</code>",
 "1065": "<code>some n = some n'.succ.succ</code>",
 "1064": "<code>fib : Nat → Nat</code>",
 "1063": "<code>WithParam' p n</code>",
 "1062":
 "<code>WithParam'.succ {p n : Nat} : WithParam' p n → WithParam' p (n + 1)</code>",
 "1061": "<code>WithParam'.zero {p n : Nat} : WithParam' p (n + 1)</code>",
 "1060": "<code>WithParam' (p : Nat) : Nat → Type</code>",
 "106":
 "<code>(fun x =&gt; Nat → Nat) n ×' Nat.below (motive := fun x =&gt; Nat → Nat) n</code>",
 "1059": "<code>afterVarying (n p : Nat) (x : WithParam' p n) : Nat</code>",
 "1058": "<code>Fin' 100</code>",
 "1057": "<code>Fin'.succ {n : Nat} : Fin' n → Fin' (n + 1)</code>",
 "1056": "<code>Fin'.zero {n : Nat} : Fin' (n + 1)</code>",
 "1055": "<code>Fin' : Nat → Type</code>",
 "1054": "<code>constantIndex (x : Fin' 100) : Nat</code>",
 "1053": "<code>Nat → Nat</code>",
 "1052": "<code>notInductive (x : Nat → Nat) : Nat</code>",
 "1051": "<code>half : Nat → Nat</code>",
 "1050":
 "<code class=\"docstring\">Specify a termination measure for recursive functions.\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the arguments `a` and `b` decreases.\n\nIf the function takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c =&gt; a - b\n```\n\nBy default, a `termination_by` clause will cause the function to be constructed using well-founded\nrecursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)\nindicates the function is expected to be structural recursive on the argument. In this case\nthe body of the `termination_by` clause must be one of the function's parameters.\n\nIf omitted, a termination measure will be inferred. If written as `termination_by?`,\nthe inferred termination measure will be suggested.\n\n</code>",
 "105":
 "<code>PUnit.unit.{u} : PUnit</code><span class=\"sep\"></span><code class=\"docstring\">The only element of the universe-polymorphic unit type. </code>",
 "1049": "<code>half (n : Nat) : Nat</code>",
 "1048":
 "<code>BEq.beq.{u} {α : Type u} [self : BEq α] : α → α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1047": "<code>¬(n == 0) = true</code>",
 "1046": "<code>countdown' (n : Nat) : List Nat</code>",
 "1045": "<code>countdown (n : Nat) : List Nat</code>",
 "1044": "<code>identity.{u_1} {β : Sort u_1} (x : β) : β</code>",
 "1043": "<code>identity.{u_1} (x : sorry) : sorry</code>",
 "1042": "<code>α.{u_1} : Type</code>",
 "1041": "<code>NaturalNum</code>",
 "1040": "<code>n : NaturalNum</code>",
 "104":
 "<code>Nat.rec.{u} {motive : Nat → Sort u} (zero : motive Nat.zero) (succ : (n : Nat) → motive n → motive n.succ) (t : Nat) :\n  motive t</code>",
 "1039": "<code>NaturalNum : Type</code>",
 "1038": "<code>n.{u_1} : sorry</code>",
 "1037": "<code>NaturalNum.{u_1} : Type</code>",
 "1036":
 "<code>isExclusiveUnsafe.{u} {α : Type u} (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `a` is an exclusive object.\n\nAn object is exclusive if it is single-threaded and its reference counter is 1. This function is\nunsafe because it can distinguish between definitionally equal values.\n</code>",
 "1035":
 "<code>ptrAddrUnsafe.{u} {α : Type u} (a : α) : USize</code><span class=\"sep\"></span><code class=\"docstring\">Returns the address at which an object is allocated.\n\nThis function is unsafe because it can distinguish between definitionally equal values.\n</code>",
 "1034":
 "<code>unsafeCast.{u, v} {α : Sort u} {β : Sort v} (a : α) : β</code><span class=\"sep\"></span><code class=\"docstring\">This function will cast a value of type `α` to type `β`, and is a no-op in the\ncompiler. This function is **extremely dangerous** because there is no guarantee\nthat types `α` and `β` have the same data representation, and this can lead to\nmemory unsafety. It is also logically unsound, since you could just cast\n`True` to `False`. For all those reasons this function is marked as `unsafe`.\n\nIt is implemented by lifting both `α` and `β` into a common universe, and then\nusing `cast (lcProof : ULift (PLift α) = ULift (PLift β))` to actually perform\nthe cast. All these operations are no-ops in the compiler.\n\nUsing this function correctly requires some knowledge of the data representation\nof the source and target types. Some general classes of casts which are safe in\nthe current runtime:\n\n* `Array α` to `Array β` where `α` and `β` have compatible representations,\n  or more generally for other inductive types.\n* `Quot α r` and `α`.\n* `@Subtype α p` and `α`, or generally any structure containing only one\n  non-`Prop` field of type `α`.\n* Casting `α` to/from `NonScalar` when `α` is a boxed generic type\n  (i.e. a function that accepts an arbitrary type `α` and is not specialized to\n  a scalar type like `UInt8`).\n</code>",
 "1033":
 "<code>Empty.rec.{u} (motive : Empty → Sort u) (t : Empty) : motive t</code>",
 "1032":
 "<code class=\"docstring\">The `fun_induction` tactic is a convenience wrapper around the `induction` tactic to use the the\nfunctional induction principle.\n\nThe tactic invocation\n```\nfun_induction f x₁ ... xₙ y₁ ... yₘ\n```\nwhere `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to\n```\ninduction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ\n```\nwhere the arguments of `f` are used as arguments to `f.induct_unfolding` or targets of the\ninduction, as appropriate.\n\nThe form\n```\nfun_induction f\n```\n(with no arguments to `f`) searches the goal for a unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe forms `fun_induction f x y generalizing z₁ ... zₙ` and\n`fun_induction f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` work like with `induction.`\n\nUnder `set_option tactic.fun_induction.unfolding true` (the default), `fun_induction` uses the\n`f.induct_unfolding` induction principle, which will try to automatically unfold the call to `f` in\nthe goal. With `set_option tactic.fun_induction.unfolding false`, it uses `f.induct` instead.\n</code>",
 "1031":
 "<code class=\"docstring\">name of the Lean (probably unsafe) function that implements opaque constant</code>",
 "1030": "<code>sorry × sorry × sorry</code>",
 "103":
 "<code class=\"docstring\">`#reduce &lt;expression&gt;` reduces the expression `&lt;expression&gt;` to its normal form. This\ninvolves applying reduction rules until no further reduction is possible.\n\nBy default, proofs and types within the expression are not reduced. Use modifiers\n`(proofs := true)`  and `(types := true)` to reduce them.\nRecall that propositions are types in Lean.\n\n**Warning:** This can be a computationally expensive operation,\nespecially for complex expressions.\n\nConsider using `#eval &lt;expression&gt;` for simple evaluation/execution\nof expressions.\n</code>",
 "1029":
 "<code>select.{u_1} (choices : sorry × sorry × sorry) : Answer → sorry</code>",
 "1028":
 "<code>select.{u_1} {α : Type u_1} (choices : α × α × α) : Answer → α</code>",
 "1027":
 "<code>select.{u_1, u_2} {α : Type u_1} (choices : α × α × α) : sorry → α</code>",
 "1026": "<code class=\"docstring\">The universe parameter u_2</code>",
 "1025": "<code>Sort ?u.25</code>",
 "1024": "<code>α × α × α</code>",
 "1023":
 "<code>select.{u_1, u_2} {α : Type u_1} {Asnwer : Sort u_2} (choices : α × α × α) : Asnwer → α</code>",
 "1022": "<code>Answer.no : Answer</code>",
 "1021": "<code>Answer.maybe : Answer</code>",
 "1020": "<code>Answer.yes : Answer</code>",
 "102":
 "<code>MonadEvalT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} (monadEval : {α : Type u} → m α → n α) :\n  MonadEvalT m n</code>",
 "1019": "<code>Answer : Type</code>",
 "1018":
 "<code>relaxedAutoImplicit</code><span class=\"sep\"></span><code class=\"docstring\">When \"relaxed\" mode is enabled, any atomic nonempty identifier is eligible for auto bound implicit locals (see option `autoImplicit`).</code>",
 "1017": "<code>val✝¹ ≥ ↑i</code>",
 "1016": "<code>val✝¹ ≥ ↑i</code>",
 "1015": "<code>val✝ ≥ ↑i</code>",
 "1014": "<code>val✝ ≥ ↑i</code>",
 "1013":
 "<code>GE.ge.{u} {α : Type u} [LE α] (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≥ b` is an abbreviation for `b ≤ a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≥` in identifiers is `ge`.\n\n * The recommended spelling of `&gt;=` in identifiers is `ge` (prefer `≥` over `&gt;=`).</code>",
 "1012": "<code>Fin n✝</code>",
 "1011":
 "<code>AtLeast.mk {n : Nat} {i : Fin n} (val : Nat) (val_gt_i : val ≥ ↑i) : AtLeast i</code>",
 "1010": "<code>Fin ?m.3</code>",
 "101": "<code>Type u → Type v</code>",
 "1009": "<code>AtLeast i</code>",
 "1008":
 "<code>AtLeast.add {n✝ : Nat} {i : Fin n✝} (x y : AtLeast i) : AtLeast i</code>",
 "1007":
 "<code>Fin.val {n : Nat} (self : Fin n) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number that is strictly less than `n`.\n\n`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.\n</code>",
 "1006":
 "<code>AtLeast.val_gt_i {n : Nat} {i : Fin n} (self : AtLeast i) : self.val ≥ ↑i</code>",
 "1005":
 "<code>AtLeast.val {n : Nat} {i : Fin n} (self : AtLeast i) : Nat</code>",
 "1004": "<code>Fin n</code>",
 "1003": "<code>AtLeast {n : Nat} (i : Fin n) : Type</code>",
 "1002":
 "<code>map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (xs : List α) : List β</code>",
 "1001": "<code>sorry → sorry</code>",
 "1000":
 "<code>map.{u_1, u_2} (f : sorry → sorry) (xs : List sorry) : List sorry</code>",
 "100":
 "<code>{α : Type u} → m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Evaluates a value from monad `m` into monad `n`. </code>",
 "10": "<code>bogus : False</code>",
 "1":
 "<code class=\"docstring\">`grind` is a tactic inspired by modern SMT solvers. **Picture a virtual whiteboard**:\nevery time grind discovers a new equality, inequality, or logical fact,\nit writes it on the board, groups together terms known to be equal,\nand lets each reasoning engine read from and contribute to the shared workspace.\nThese engines work together to handle equality reasoning, apply known theorems,\npropagate new facts, perform case analysis, and run specialized solvers\nfor domains like linear arithmetic and commutative rings.\n\n`grind` is *not* designed for goals whose search space explodes combinatorially,\nthink large pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards,\nor a 200‑variable Sudoku encoded as Boolean constraints.  Such encodings require\n thousands (or millions) of case‑splits that overwhelm `grind`’s branching search.\n\nFor **bit‑level or combinatorial problems**, consider using **`bv_decide`**.\n`bv_decide` calls a state‑of‑the‑art SAT solver (CaDiCaL) and then returns a\n*compact, machine‑checkable certificate*.\n\n### Equality reasoning\n\n`grind` uses **congruence closure** to track equalities between terms.\nWhen two terms are known to be equal, congruence closure automatically deduces\nequalities between more complex expressions built from them.\nFor example, if `a = b`, then congruence closure will also conclude that `f a` = `f b`\nfor any function `f`. This forms the foundation for efficient equality reasoning in `grind`.\nHere is an example:\n```\nexample (f : Nat → Nat) (h : a = b) : f (f b) = f (f a) := by\n  grind\n```\n\n### Applying theorems using E-matching\n\nTo apply existing theorems, `grind` uses a technique called **E-matching**,\nwhich finds matches for known theorem patterns while taking equalities into account.\nCombined with congruence closure, E-matching helps `grind` discover\nnon-obvious consequences of theorems and equalities automatically.\n\nConsider the following functions and theorems:\n```\ndef f (a : Nat) : Nat :=\n  a + 1\n\ndef g (a : Nat) : Nat :=\n  a - 1\n\n@[grind =]\ntheorem gf (x : Nat) : g (f x) = x := by\n  simp [f, g]\n```\nThe theorem `gf` asserts that `g (f x) = x` for all natural numbers `x`.\nThe attribute `[grind =]` instructs `grind` to use the left-hand side of the equation,\n`g (f x)`, as a pattern for E-matching.\nSuppose we now have a goal involving:\n```\nexample {a b} (h : f b = a) : g a = b := by\n  grind\n```\nAlthough `g a` is not an instance of the pattern `g (f x)`,\nit becomes one modulo the equation `f b = a`. By substituting `a`\nwith `f b` in `g a`, we obtain the term `g (f b)`,\nwhich matches the pattern `g (f x)` with the assignment `x := b`.\nThus, the theorem `gf` is instantiated with `x := b`,\nand the new equality `g (f b) = b` is asserted.\n`grind` then uses congruence closure to derive the implied equality\n`g a = g (f b)` and completes the proof.\n\nThe pattern used to instantiate theorems affects the effectiveness of `grind`.\nFor example, the pattern `g (f x)` is too restrictive in the following case:\nthe theorem `gf` will not be instantiated because the goal does not even\ncontain the function symbol `g`.\n\n```\nexample (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n```\n\nYou can use the command `grind_pattern` to manually select a pattern for a given theorem.\nIn the following example, we instruct `grind` to use `f x` as the pattern,\nallowing it to solve the goal automatically:\n```\ngrind_pattern gf =&gt; f x\n\nexample {a b c} (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n```\nYou can enable the option `trace.grind.ematch.instance` to make `grind` print a\ntrace message for each theorem instance it generates.\n\nYou can also specify a **multi-pattern** to control when `grind` should apply a theorem.\nA multi-pattern requires that all specified patterns are matched in the current context\nbefore the theorem is applied. This is useful for theorems such as transitivity rules,\nwhere multiple premises must be simultaneously present for the rule to apply.\nThe following example demonstrates this feature using a transitivity axiom for a binary relation `R`:\n```\nopaque R : Int → Int → Prop\naxiom Rtrans {x y z : Int} : R x y → R y z → R x z\n\ngrind_pattern Rtrans =&gt; R x y, R y z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n```\nBy specifying the multi-pattern `R x y, R y z`, we instruct `grind` to\ninstantiate `Rtrans` only when both `R x y` and `R y z` are available in the context.\nIn the example, `grind` applies `Rtrans` to derive `R a c` from `R a b` and `R b c`,\nand can then repeat the same reasoning to deduce `R a d` from `R a c` and `R c d`.\n\nInstead of using `grind_pattern` to explicitly specify a pattern,\nyou can use the `@[grind]` attribute or one of its variants, which will use a heuristic to\ngenerate a (multi-)pattern. The complete list is available in the reference manual. The main ones are:\n\n- `@[grind →]` will select a multi-pattern from the hypotheses of the theorem (i.e. it will use the theorem for forwards reasoning).\n  In more detail, it will traverse the hypotheses of the theorem from left-to-right, and each time it encounters a minimal indexable\n  (i.e. has a constant as its head) subexpression which \"covers\" (i.e. fixes the value of) an argument which was not\n  previously covered, it will add that subexpression as a pattern, until all arguments have been covered.\n- `@[grind ←]` will select a multi-pattern from the conclusion of theorem (i.e. it will use the theorem for backwards reasoning).\n  This may fail if not all the arguments to the theorem appear in the conclusion.\n- `@[grind]` will traverse the conclusion and then the hypotheses left-to-right, adding patterns as they increase the coverage,\n  stopping when all arguments are covered.\n- `@[grind =]` checks that the conclusion of the theorem is an equality, and then uses the left-hand-side of the equality as a pattern.\n  This may fail if not all of the arguments appear in the left-hand-side.\n\nHere is the previous example again but using the attribute `[grind →]`\n```\nopaque R : Int → Int → Prop\n@[grind →] axiom Rtrans {x y z : Int} : R x y → R y z → R x z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n```\n\nTo control theorem instantiation and avoid generating an unbounded number of instances,\n`grind` uses a generation counter. Terms in the original goal are assigned generation zero.\nWhen `grind` applies a theorem using terms of generation `≤ n`, any new terms it creates\nare assigned generation `n + 1`. This limits how far the tactic explores when applying\ntheorems and helps prevent an excessive number of instantiations.\n\n#### Key options:\n- `grind (ematch := &lt;num&gt;)` controls the number of E-matching rounds.\n- `grind [&lt;name&gt;, ...]` instructs `grind` to use the declaration `name` during E-matching.\n- `grind only [&lt;name&gt;, ...]` is like `grind [&lt;name&gt;, ...]` but does not use theorems tagged with `@[grind]`.\n- `grind (gen := &lt;num&gt;)` sets the maximum generation.\n\n### Linear integer arithmetic (`cutsat`)\n\n`grind` can solve goals that reduce to **linear integer arithmetic (LIA)** using an\nintegrated decision procedure called **`cutsat`**.  It understands\n\n* equalities   `p = 0`\n* inequalities  `p ≤ 0`\n* disequalities `p ≠ 0`\n* divisibility  `d ∣ p`\n\nThe solver incrementally assigns integer values to variables; when a partial\nassignment violates a constraint it adds a new, implied constraint and retries.\nThis *model-based* search is **complete for LIA**.\n\n#### Key options:\n\n* `grind -cutsat` disable the solver (useful for debugging)\n* `grind +qlia` accept rational models (shrinks the search space but is incomplete for ℤ)\n\n#### Examples:\n\n```\n-- Even + even is never odd.\nexample {x y : Int} : 2 * x + 4 * y ≠ 5 := by\n  grind\n\n-- Mixing equalities and inequalities.\nexample {x y : Int} :\n    2 * x + 3 * y = 0 → 1 ≤ x → y &lt; 1 := by\n  grind\n\n-- Reasoning with divisibility.\nexample (a b : Int) :\n    2 ∣ a + 1 → 2 ∣ b + a → ¬ 2 ∣ b + 2 * a := by\n  grind\n\nexample (x y : Int) :\n    27 ≤ 11*x + 13*y →\n    11*x + 13*y ≤ 45 →\n    -10 ≤ 7*x - 9*y →\n    7*x - 9*y ≤ 4 → False := by\n  grind\n\n-- Types that implement the `ToInt` type-class.\nexample (a b c : UInt64)\n    : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n```\n\n### Algebraic solver (`ring`)\n\n`grind` ships with an algebraic solver nick-named **`ring`** for goals that can\nbe phrased as polynomial equations (or disequations) over commutative rings,\nsemirings, or fields.\n\n*Works out of the box*\nAll core numeric types and relevant Mathlib types already provide the required\ntype-class instances, so the solver is ready to use in most developments.\n\nWhat it can decide:\n\n* equalities of the form `p = q`\n* disequalities `p ≠ q`\n* basic reasoning under field inverses (`a / b := a * b⁻¹`)\n* goals that mix ring facts with other `grind` engines\n\n#### Key options:\n\n* `grind -ring` turn the solver off (useful when debugging)\n* `grind (ringSteps := n)` cap the number of steps performed by this procedure.\n\n#### Examples\n\n```\nopen Lean Grind\n\nexample [CommRing α] (x : α) : (x + 1) * (x - 1) = x^2 - 1 := by\n  grind\n\n-- Characteristic 256 means 16 * 16 = 0.\nexample [CommRing α] [IsCharP α 256] (x : α) :\n    (x + 16) * (x - 16) = x^2 := by\n  grind\n\n-- Works on built-in rings such as `UInt8`.\nexample (x : UInt8) : (x + 16) * (x - 16) = x^2 := by\n  grind\n\nexample [CommRing α] (a b c : α) :\n    a + b + c = 3 →\n    a^2 + b^2 + c^2 = 5 →\n    a^3 + b^3 + c^3 = 7 →\n    a^4 + b^4 = 9 - c^4 := by\n  grind\n\nexample [Field α] [NoNatZeroDivisors α] (a : α) :\n    1 / a + 1 / (2 * a) = 3 / (2 * a) := by\n  grind\n```\n\n### Other options\n\n- `grind (splits := &lt;num&gt;)` caps the *depth* of the search tree.  Once a branch performs `num` splits\n  `grind` stops splitting further in that branch.\n- `grind -splitIte` disables case splitting on if-then-else expressions.\n- `grind -splitMatch` disables case splitting on `match` expressions.\n- `grind +splitImp` instructs `grind` to split on any hypothesis `A → B` whose antecedent `A` is **propositional**.\n- `grind -linarith` disables the linear arithmetic solver for (ordered) modules and rings.\n\n### Additional Examples\n\n```\nexample {a b} {as bs : List α} : (as ++ bs ++ [b]).getLastD a = b := by\n  grind\n\nexample (x : BitVec (w+1)) : (BitVec.cons x.msb (x.setWidth w)) = x := by\n  grind\n\nexample (as : Array α) (lo hi i j : Nat) :\n    lo ≤ i → i &lt; j → j ≤ hi → j &lt; as.size → min lo (as.size - 1) ≤ i := by\n  grind\n```\n</code>",
 "0":
 "<code class=\"docstring\">`conv =&gt; ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee &lt;https://lean-lang.org/theorem_proving_in_lean4/conv.html&gt; for more details.\n\nBasic forms:\n* `conv =&gt; cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h =&gt; cs` will rewrite hypothesis `h`.\n* `conv in pat =&gt; cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n</code>"}