window.docContents[234].resolve({"/Basic-Types/Fixed-Precision-Integers/#fixed-int-arithmetic":{"contents":"Typically, arithmetic operations on fixed-width integers should be accessed using Lean's overloaded arithmetic notation, particularly their instances of Add, Sub, Mul, Div, and Mod, as well as Neg for signed types.\n\n\n\nNegates word-sized signed integers. Usually accessed via the - prefix operator.This function is overridden at runtime with an efficient implementation.\n\nNegates 8-bit signed integers. Usually accessed via the - prefix operator.This function is overridden at runtime with an efficient implementation.\n\nNegates 16-bit signed integers. Usually accessed via the - prefix operator.This function is overridden at runtime with an efficient implementation.\n\nNegates 32-bit signed integers. Usually accessed via the - prefix operator.This function is overridden at runtime with an efficient implementation.\n\nNegates 64-bit signed integers. Usually accessed via the - prefix operator.This function is overridden at runtime with an efficient implementation.\n\nNegation of word-sized unsigned integers, computed modulo USize.size.This function is overridden at runtime with an efficient implementation.\n\nNegation of 8-bit unsigned integers, computed modulo UInt8.size.UInt8.neg a is equivalent to 255 - a + 1.This function is overridden at runtime with an efficient implementation.\n\nNegation of 16-bit unsigned integers, computed modulo UInt16.size.UInt16.neg a is equivalent to 65_535 - a + 1.This function is overridden at runtime with an efficient implementation.\n\nNegation of 32-bit unsigned integers, computed modulo UInt32.size.UInt32.neg a is equivalent to 429_4967_295 - a + 1.This function is overridden at runtime with an efficient implementation.\n\nNegation of 64-bit unsigned integers, computed modulo UInt64.size.UInt64.neg a is equivalent to 18_446_744_073_709_551_615 - a + 1.This function is overridden at runtime with an efficient implementation.\n\nAdds two word-sized unsigned integers, wrapping around on overflow.  Usually accessed via the +\noperator.This function is overridden at runtime with an efficient implementation.\n\nAdds two word-sized signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe + operator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 8-bit unsigned integers, wrapping around on overflow. Usually accessed via the +\noperator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 8-bit signed integers, wrapping around on over- or underflow. Usually accessed via the +\noperator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 16-bit unsigned integers, wrapping around on overflow. Usually accessed via the +\noperator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 16-bit signed integers, wrapping around on over- or underflow.  Usually accessed via the +\noperator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 32-bit unsigned integers, wrapping around on overflow. Usually accessed via the +\noperator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 32-bit signed integers, wrapping around on over- or underflow.  Usually accessed via the\n+ operator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 64-bit unsigned integers, wrapping around on overflow. Usually accessed via the +\noperator.This function is overridden at runtime with an efficient implementation.\n\nAdds two 64-bit signed integers, wrapping around on over- or underflow.  Usually accessed via the\n+ operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one word-sized-bit unsigned integer from another, wrapping around on underflow. Usually\naccessed via the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one word-sized signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 8-bit unsigned integer from another, wrapping around on underflow. Usually accessed\nvia the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 8-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 16-bit unsigned integer from another, wrapping around on underflow. Usually accessed\nvia the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 16-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 32-bit unsigned integer from another, wrapping around on underflow. Usually accessed\nvia the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 32-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 64-bit unsigned integer from another, wrapping around on underflow. Usually accessed\nvia the - operator.This function is overridden at runtime with an efficient implementation.\n\nSubtracts one 64-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the - operator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two word-sized unsigned integers, wrapping around on overflow.  Usually accessed via the\n* operator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two word-sized signed integers, wrapping around on over- or underflow.  Usually accessed\nvia the * operator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 8-bit unsigned integers, wrapping around on overflow.  Usually accessed via the *\noperator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 8-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe * operator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 16-bit unsigned integers, wrapping around on overflow.  Usually accessed via the *\noperator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 16-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe * operator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 32-bit unsigned integers, wrapping around on overflow.  Usually accessed via the *\noperator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 32-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe * operator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 64-bit unsigned integers, wrapping around on overflow.  Usually accessed via the *\noperator.This function is overridden at runtime with an efficient implementation.\n\nMultiplies two 64-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe * operator.This function is overridden at runtime with an efficient implementation.\n\nUnsigned division for word-sized unsigned integers, discarding the remainder. Usually accessed\nvia the / operator.This operation is sometimes called “floor division.” Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.\n\nTruncating division for word-sized signed integers, rounding towards zero. Usually accessed via the\n/ operator.Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.Examples:* ISize.div 10 3 = 3* ISize.div 10 (-3) = (-3)* ISize.div (-10) (-3) = 3* ISize.div (-10) 3 = (-3)* ISize.div 10 0 = 0\n\nUnsigned division for 8-bit unsigned integers, discarding the remainder. Usually accessed\nvia the / operator.This operation is sometimes called “floor division.” Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.\n\nTruncating division for 8-bit signed integers, rounding towards zero. Usually accessed via the /\noperator.Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.Examples:* Int8.div 10 3 = 3* Int8.div 10 (-3) = (-3)* Int8.div (-10) (-3) = 3* Int8.div (-10) 3 = (-3)* Int8.div 10 0 = 0\n\nUnsigned division for 16-bit unsigned integers, discarding the remainder. Usually accessed\nvia the / operator.This operation is sometimes called “floor division.” Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.\n\nTruncating division for 16-bit signed integers, rounding towards zero. Usually accessed via the /\noperator.Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.Examples:* Int16.div 10 3 = 3* Int16.div 10 (-3) = (-3)* Int16.div (-10) (-3) = 3* Int16.div (-10) 3 = (-3)* Int16.div 10 0 = 0\n\nUnsigned division for 32-bit unsigned integers, discarding the remainder. Usually accessed\nvia the / operator.This operation is sometimes called “floor division.” Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.\n\nTruncating division for 32-bit signed integers, rounding towards zero. Usually accessed via the /\noperator.Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.Examples:* Int32.div 10 3 = 3* Int32.div 10 (-3) = (-3)* Int32.div (-10) (-3) = 3* Int32.div (-10) 3 = (-3)* Int32.div 10 0 = 0\n\nUnsigned division for 64-bit unsigned integers, discarding the remainder. Usually accessed\nvia the / operator.This operation is sometimes called “floor division.” Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.\n\nTruncating division for 64-bit signed integers, rounding towards zero. Usually accessed via the /\noperator.Division by zero is defined to be zero.This function is overridden at runtime with an efficient implementation.Examples:* Int64.div 10 3 = 3* Int64.div 10 (-3) = (-3)* Int64.div (-10) (-3) = 3* Int64.div (-10) 3 = (-3)* Int64.div 10 0 = 0\n\nThe modulo operator for word-sized unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the % operator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* USize.mod 5 2 = 1* USize.mod 4 2 = 0* USize.mod 4 0 = 4\n\nThe modulo operator for word-sized signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by ISize.div. Usually accessed via the %\noperator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* ISize.mod 5 2 = 1* ISize.mod 5 (-2) = 1* ISize.mod (-5) 2 = (-1)* ISize.mod (-5) (-2) = (-1)* ISize.mod 4 2 = 0* ISize.mod 4 (-2) = 0* ISize.mod 4 0 = 4* ISize.mod (-4) 0 = (-4)\n\nThe modulo operator for 8-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the % operator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* UInt8.mod 5 2 = 1* UInt8.mod 4 2 = 0* UInt8.mod 4 0 = 4\n\nThe modulo operator for 8-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by Int8.div. Usually accessed via the %\noperator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* Int8.mod 5 2 = 1* Int8.mod 5 (-2) = 1* Int8.mod (-5) 2 = (-1)* Int8.mod (-5) (-2) = (-1)* Int8.mod 4 2 = 0* Int8.mod 4 (-2) = 0* Int8.mod 4 0 = 4* Int8.mod (-4) 0 = (-4)\n\nThe modulo operator for 16-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the % operator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* UInt16.mod 5 2 = 1* UInt16.mod 4 2 = 0* UInt16.mod 4 0 = 4\n\nThe modulo operator for 16-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by Int16.div. Usually accessed via the %\noperator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* Int16.mod 5 2 = 1* Int16.mod 5 (-2) = 1* Int16.mod (-5) 2 = (-1)* Int16.mod (-5) (-2) = (-1)* Int16.mod 4 2 = 0* Int16.mod 4 (-2) = 0* Int16.mod 4 0 = 4* Int16.mod (-4) 0 = (-4)\n\nThe modulo operator for 32-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the % operator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* UInt32.mod 5 2 = 1* UInt32.mod 4 2 = 0* UInt32.mod 4 0 = 4\n\nThe modulo operator for 32-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by Int32.div. Usually accessed via the %\noperator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* Int32.mod 5 2 = 1* Int32.mod 5 (-2) = 1* Int32.mod (-5) 2 = (-1)* Int32.mod (-5) (-2) = (-1)* Int32.mod 4 2 = 0* Int32.mod 4 (-2) = 0* Int32.mod 4 0 = 4* Int32.mod (-4) 0 = (-4)\n\nThe modulo operator for 64-bit unsigned integers, which computes the remainder when dividing one\ninteger by another. Usually accessed via the % operator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* UInt64.mod 5 2 = 1* UInt64.mod 4 2 = 0* UInt64.mod 4 0 = 4\n\nThe modulo operator for 64-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by Int64.div. Usually accessed via the %\noperator.When the divisor is 0, the result is the dividend rather than an error.This function is overridden at runtime with an efficient implementation.Examples:* Int64.mod 5 2 = 1* Int64.mod 5 (-2) = 1* Int64.mod (-5) 2 = (-1)* Int64.mod (-5) (-2) = (-1)* Int64.mod 4 2 = 0* Int64.mod 4 (-2) = 0* Int64.mod 4 0 = 4* Int64.mod (-4) 0 = (-4)\n\nBase-two logarithm of word-sized unsigned integers. Returns ⌊max 0 (log₂ a)⌋.This function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.Examples:* USize.log2 0 = 0* USize.log2 1 = 0* USize.log2 2 = 1* USize.log2 4 = 2* USize.log2 7 = 2* USize.log2 8 = 3\n\nBase-two logarithm of 8-bit unsigned integers. Returns ⌊max 0 (log₂ a)⌋.This function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.Examples:* UInt8.log2 0 = 0* UInt8.log2 1 = 0* UInt8.log2 2 = 1* UInt8.log2 4 = 2* UInt8.log2 7 = 2* UInt8.log2 8 = 3\n\nBase-two logarithm of 16-bit unsigned integers. Returns ⌊max 0 (log₂ a)⌋.This function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.Examples:* UInt16.log2 0 = 0* UInt16.log2 1 = 0* UInt16.log2 2 = 1* UInt16.log2 4 = 2* UInt16.log2 7 = 2* UInt16.log2 8 = 3\n\nBase-two logarithm of 32-bit unsigned integers. Returns ⌊max 0 (log₂ a)⌋.This function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.Examples:* UInt32.log2 0 = 0* UInt32.log2 1 = 0* UInt32.log2 2 = 1* UInt32.log2 4 = 2* UInt32.log2 7 = 2* UInt32.log2 8 = 3\n\nBase-two logarithm of 64-bit unsigned integers. Returns ⌊max 0 (log₂ a)⌋.This function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.Examples:* UInt64.log2 0 = 0* UInt64.log2 1 = 0* UInt64.log2 2 = 1* UInt64.log2 4 = 2* UInt64.log2 7 = 2* UInt64.log2 8 = 3\n\nComputes the absolute value of a word-sized signed integer.This function is equivalent to if a < 0 then -a else a, so in particular ISize.minValue will be\nmapped to ISize.minValue.This function is overridden at runtime with an efficient implementation.\n\nComputes the absolute value of an 8-bit signed integer.This function is equivalent to if a < 0 then -a else a, so in particular Int8.minValue will be\nmapped to Int8.minValue.This function is overridden at runtime with an efficient implementation.\n\nComputes the absolute value of a 16-bit signed integer.This function is equivalent to if a < 0 then -a else a, so in particular Int16.minValue will be\nmapped to Int16.minValue.This function is overridden at runtime with an efficient implementation.\n\nComputes the absolute value of a 32-bit signed integer.This function is equivalent to if a < 0 then -a else a, so in particular Int32.minValue will be\nmapped to Int32.minValue.This function is overridden at runtime with an efficient implementation.\n\nComputes the absolute value of a 64-bit signed integer.This function is equivalent to if a < 0 then -a else a, so in particular Int64.minValue will be\nmapped to Int64.minValue.This function is overridden at runtime with an efficient implementation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"19.4.4.5. Arithmetic","id":"/Basic-Types/Fixed-Precision-Integers/#fixed-int-arithmetic"},"/Basic-Types/Strings/#string-api-convert":{"contents":"Converts a string to a list of characters.Since strings are represented as dynamic arrays of bytes containing the string encoded using\nUTF-8, this operation takes time and space linear in the length of the string.Examples:* \"abc\".toList = ['a', 'b', 'c']* \"\".toList = []* \"\\n\".toList = ['\\n']\n\nChecks whether the string can be interpreted as the decimal representation of a natural number.A string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.Use String.toNat? or String.toNat! to convert such a string to a natural number.Examples:* \"\".isNat = false* \"0\".isNat = true* \"5\".isNat = true* \"05\".isNat = true* \"587\".isNat = true* \"-587\".isNat = false* \" 5\".isNat = false* \"2+3\".isNat = false* \"0xff\".isNat = false\n\nInterprets a string as the decimal representation of a natural number, returning it. Returns none\nif the string does not contain a decimal natural number.A string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.Use String.isNat to check whether String.toNat? would return some. String.toNat! is an\nalternative that panics instead of returning none when the string is not a natural number.Examples:* \"\".toNat? = none* \"0\".toNat? = some 0* \"5\".toNat? = some 5* \"587\".toNat? = some 587* \"-587\".toNat? = none* \" 5\".toNat? = none* \"2+3\".toNat? = none* \"0xff\".toNat? = none\n\nInterprets a string as the decimal representation of a natural number, returning it. Panics if the\nstring does not contain a decimal natural number.A string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.Use String.isNat to check whether String.toNat! would return a value. String.toNat? is a safer\nalternative that returns none instead of panicking when the string is not a natural number.Examples:* \"0\".toNat! = 0* \"5\".toNat! = 5* \"587\".toNat! = 587\n\nChecks whether the string can be interpreted as the decimal representation of an integer.A string can be interpreted as a decimal integer if it only consists of at least one decimal digit\nand optionally - in front. Leading + characters are not allowed.Use String.toInt? or String.toInt! to convert such a string to an integer.Examples:* \"\".isInt = false* \"-\".isInt = false* \"0\".isInt = true* \"-0\".isInt = true* \"5\".isInt = true* \"587\".isInt = true* \"-587\".isInt = true* \"+587\".isInt = false* \" 5\".isInt = false* \"2-3\".isInt = false* \"0xff\".isInt = false\n\nInterprets a string as the decimal representation of an integer, returning it. Returns none if\nthe string does not contain a decimal integer.A string can be interpreted as a decimal integer if it only consists of at least one decimal digit\nand optionally - in front. Leading + characters are not allowed.Use String.isInt to check whether String.toInt? would return some. String.toInt! is an\nalternative that panics instead of returning none when the string is not an integer.Examples:* \"\".toInt? = none* \"-\".toInt? = none* \"0\".toInt? = some 0* \"5\".toInt? = some 5* \"-5\".toInt? = some (-5)* \"587\".toInt? = some 587* \"-587\".toInt? = some (-587)* \" 5\".toInt? = none* \"2-3\".toInt? = none* \"0xff\".toInt? = none\n\nInterprets a string as the decimal representation of an integer, returning it. Panics if the string\ndoes not contain a decimal integer.A string can be interpreted as a decimal integer if it only consists of at least one decimal digit\nand optionally - in front. Leading + characters are not allowed.Use String.isInt to check whether String.toInt! would return a value. String.toInt? is a safer\nalternative that returns none instead of panicking when the string is not an integer.Examples:* \"0\".toInt! = 0* \"5\".toInt! = 5* \"587\".toInt! = 587* \"-587\".toInt! = -587\n\nConverts a string to a pretty-printer document, replacing newlines in the string with\nStd.Format.line.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.2. Conversions","id":"/Basic-Types/Strings/#string-api-convert"},"/Build-Tools-and-Distribution/Lake/#lake-cli":{"contents":"\n\nLake's command-line interface is structured into a series of subcommands.\nAll of the subcommands share the ability to be configured by certain environment variables and global command-line options.\nEach subcommand should be understood as a utility in its own right, with its own required argument syntax and documentation.\n\nSome of Lake's commands delegate to other command-line utilities that are not included in a Lean distribution.\nThese utilities must be available on the PATH in order to use the corresponding features:* git is required in order to access Git dependencies.* tar is required to create or extract cloud build archives, and curl is required to fetch them.* gh is required to upload build artifacts to GitHub releases.Lean distributions include a C compiler toolchain.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake","header":"22.1.2. Command-Line Interface","id":"/Build-Tools-and-Distribution/Lake/#lake-cli"},"/Notations-and-Macros/Extending-Lean___s-Output/#unexpand-and-delab":{"contents":"Extending Lean with new syntax and implementing the new syntax with macros and elaborators allows users to express ideas to Lean more conveniently.\nHowever, Lean is an interactive theorem prover: it is also important that the feedback it provides can be readily understood.\nSyntax extensions should be used in output as well as in input.\n\nThere are two primary mechanisms for instructing Lean to use a syntax extension in its output: Unexpanders\n\nUnexpanders are the inverse of macros.\n  Macros implement new syntax in terms of the old syntax by translation, expanding the new feature into encodings in pre-existing features.\n  Like macros, unexpanders translate Syntax into Syntax; unlike macros, they transform the encodings into the new extensions.\n\n Delaborators\n\nDelaborators are the inverse of elaborators.\n  While elaborators translate Syntax into the core type theory's Expr, delaborators translate Exprs into Syntax.\n\n\n\nBefore an Expr is displayed, it is first delaborated and then unexpanded.\nThe delaborator tracks the position in the original Expr that its output originated from; this position is encoded in the resulting syntax's SourceInfo.\nJust as macro expansion automatically annotates the resulting syntax with synthetic source information that correspond to the original syntax's position, the unexpansion mechanism preserves the resulting syntax's association with the underlying Expr.\nThis association enables Lean's interactive features that provide information about the resulting syntax when it is shown in proof states and diagnostics.\n\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros","header":"20.7. Extending Lean's Output","id":"/Notations-and-Macros/Extending-Lean___s-Output/#unexpand-and-delab"}});