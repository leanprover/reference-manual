window.docContents[177].resolve({"/Basic-Types/Lazy-Computations/#Thunk":{"contents":"A thunk delays the computation of a value.\nIn particular, the Thunk type is used to delay the computation of a value in compiled code until it is explicitly requested—this request is called forcing the thunk.\nThe computed value is saved, so subsequent requests do not result in recomputation.\nComputing values at most once, when explicitly requested, is called lazy evaluation.\nThis caching is invisible to Lean's logic, in which Thunk is equivalent to a function from Unit.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.20. Lazy Computations","id":"/Basic-Types/Lazy-Computations/#Thunk"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key a or a key that is equal to a according\nto the comparator cmp. There is also a Prop-valued version\nof this: a ∈ t is equivalent to t.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for equality checks, while for tree maps, both use the given comparator cmp.\n\nGiven a proof that a mapping for the given key is present, retrieves the mapping for the given key.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, panicking if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning none if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\nReturns a list of all keys present in the tree map in ascending  order.\n\nReturns an array of all keys present in the tree map in ascending  order.\n\nReturns a list of all values present in the tree map in ascending  order.\n\nReturns an array of all values present in the tree map in ascending  order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"19.18.9.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Queries"},"/Error-Explanations/lean___inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferBinderTypeFailed":{"contents":"\n\nThis error occurs when the type of a binder in a declaration header or local binding is not fully\nspecified and cannot be inferred by Lean. Generally, this can be resolved by providing more\ninformation to help Lean determine the type of the binder, either by explicitly annotating its type\nor by providing additional type information at sites where it is used. When the binder in question\noccurs in the header of a declaration, this error is often accompanied by\nlean.inferDefTypeFailed.\n\nNote that if a declaration is annotated with an explicit resulting type—even one that contains\nholes—Lean will not use information from the definition body to infer parameter types. It may\ntherefore be necessary to explicitly specify the types of parameters whose types would otherwise be\ninferable without the resulting-type annotation; see the \"uninferred binder due to resulting type\nannotation\" example below for a demonstration. In theorem declarations, the body is never used to\ninfer the types of binders, so any binders whose types cannot be inferred from the rest of the\ntheorem type must include a type annotation.\n\nThis error may also arise when identifiers that were intended to be declaration names are\ninadvertently written in binder position instead. In these cases, the erroneous identifiers are\ntreated as binders with unspecified type, leading to a type inference failure. This frequently\noccurs when attempting to simultaneously define multiple constants of the same type using syntax\nthat does not support this. Such situations include:\n\n* Attempting to name an example by writing an identifier after the example keyword;* Attempting to define multiple constants with the same type and (if applicable) value by listing\nthem sequentially after def, opaque, or another declaration keyword;* Attempting to define multiple fields of a structure of the same type by sequentially listing their\nnames on the same line of a structure declaration; and* Omitting vertical bars between inductive constructor names.\n\nThe first three cases are demonstrated in examples below.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.inferBinderTypeFailed","id":"/Error-Explanations/lean___inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferBinderTypeFailed"}});