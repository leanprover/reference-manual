window.docContents[92].resolve({"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion":{"contents":"To explicitly use structural recursion, a function or theorem definition can be annotated with a termination_by structural clause that specifies the decreasing parameter.\nThe decreasing parameter may be a reference to a parameter named in the signature.\nWhen the signature specifies a function type, the decreasing parameter may additionally be a parameter not named in the signature; in this case, names for the remaining parameters may be introduced by writing them before an arrow (=>).\n\nSpecifying Decreasing ParametersWhen the decreasing parameter is a named parameter to the function, it can be specified by referring to its name.def half (n : Nat) : Nat :=\n  match n with\n  | 0 | 1 => 0\n  | n + 2 => half n + 1\ntermination_by structural n\nWhen the decreasing parameter is not named in the signature, a name can be introduced locally in the termination_by clause.def half : Nat → Nat\n  | 0 | 1 => 0\n  | n + 2 => half n + 1\ntermination_by structural n => n\n\n\nExplicit Structural RecursionThe termination_by structural clause introduces a decreasing parameter.The identifiers before the optional => can bring function parameters into scope that are not\nalready bound in the declaration header, and the mandatory term must indicate one of the function's parameters, whether introduced in the header or locally in the clause.\n\nThe decreasing parameter must satisfy the following conditions:\n\n* Its type must be an inductive type.* If its type is an indexed family, then all indices must be parameters of the function.* If the inductive or indexed family of the decreasing parameter has data type parameters, then these data type parameters may themselves only depend on function parameters that are part of the fixed prefix.\n\nA fixed parameter is a function parameter that is passed unmodified in all recursive calls and is not an index of the recursive parameter's type.\nThe fixed prefix is the longest prefix of the function's parameters in which all are fixed.\n\nIneligible decreasing parametersThe decreasing parameter's type must be an inductive type.\nIn notInductive, a function is specified as the decreasing parameter:def notInductive (x : Nat → Nat) : Nat :=\n  notInductive (fun n => x (n+1))\ntermination_by structural x\ncannot use specified measure for structural recursion:\n  its type is not an inductive\nIf the decreasing parameter is an indexed family, all the indices must be variables.\nIn constantIndex, the indexed family Fin' is instead applied to a constant value:inductive Fin' : Nat → Type where\n  | zero : Fin' (n+1)\n  | succ : Fin' n → Fin' (n+1)\n\ndef constantIndex (x : Fin' 100) : Nat := constantIndex .zero\ntermination_by structural x\ncannot use specified measure for structural recursion:\n  its type Fin' is an inductive family and indices are not variables\n    Fin' 100\nThe parameters of the decreasing parameter's type must not depend on function parameters that come after varying parameters or indices.\nIn afterVarying, the fixed prefix is empty, because the first parameter n varies, so p is not part of the fixed prefix:inductive WithParam' (p : Nat) : Nat → Type where\n  | zero : WithParam' p (n+1)\n  | succ : WithParam' p n → WithParam' p (n+1)\n\ndef afterVarying (n : Nat) (p : Nat) (x : WithParam' p n) : Nat :=\n  afterVarying (n+1) p .zero\ntermination_by structural x\nfailed to infer structural recursion:\nCannot use parameter x:\n  failed to eliminate recursive application\n    afterVarying (n + 1) p WithParam'.zero\n\n\nFurthermore, every recursive call of the functions must be on a strict sub-term of the decreasing\nparameter.\n\n* The decreasing parameter itself is a sub-term, but not a strict sub-term.* If a sub-term is the discriminant of a match expression or other pattern-matching syntax, the pattern that matches the discriminant is a sub-term in the right-hand side of each match alternative.\n   In particular, the rules of match generalization are used to connect the discriminant to the occurrences of the pattern term in the right-hand side; thus, it respects definitional equality.\n   The pattern is a strict sub-term if and only if the discriminant is a strict sub-term.* If a sub-term is a constructor applied to arguments, then its recursive arguments are strict sub-terms.\n\n\n\nNested Patterns and Sub-TermsIn the following example, the decreasing parameter n is matched against the nested pattern .succ (.succ n). Therefore .succ (.succ n) is a (non-strict) sub-term of n, and consequently  both n and .succ n are strict sub-terms, and the definition is accepted.def fib : Nat → Nat\n  | 0 | 1 => 1\n  | .succ (.succ n) =>  fib n + fib (.succ n)\ntermination_by structural n => n\nFor clarity, this example uses .succ n and .succ (.succ n) instead of the equivalent Nat-specific n+1 and n+2.\n\n\n\n\n\nMatching on Complex Expressions Can Prevent ElaborationIn the following example, the decreasing parameter n is not directly the discriminant of the match expression.\nTherefore, n' is not considered a sub-term of n.def half (n : Nat) : Nat :=\n  match Option.some n with\n  | .some (n' + 2) => half n' + 1\n  | _ => 0\ntermination_by structural n\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    half n'\nUsing well-founded recursion, and explicitly connecting the discriminant to the pattern of the match, this definition can be accepted.def half (n : Nat) : Nat :=\n  match h : Option.some n with\n  | .some (n' + 2) => half n' + 1\n  | _ => 0\ntermination_by n\ndecreasing_by simp_all; omega\nSimilarly, the following example fails: although xs.tail would reduce to a strict sub-term of xs, this is not visible to Lean according to the rules above.\nIn particular, xs.tail is not definitionally equal to a strict sub-term of xs.def listLen : List α → Nat\n  | [] => 0\n  | xs => listLen xs.tail + 1\ntermination_by structural xs => xs\n\n\n\n\nSimultaneous Matching vs Matching Pairs for Structural RecursionAn important consequence of the strategies that are used to prove termination is that simultaneous matching of two discriminants is not equivalent to matching a pair.\nSimultaneous matching maintains the connection between the discriminants and the patterns, allowing the pattern matching to refine the types of the assumptions in the local context as well as the expected type of the match.\nEssentially, the elaboration rules for match treat the discriminants specially, and changing discriminants in a way that preserves the run-time meaning of a program does not necessarily preserve the compile-time meaning.This function that finds the minimum of two natural numbers is defined by structural recursion on its first parameter:def min' (n k : Nat) : Nat :=\n  match n, k with\n  | 0, _ => 0\n  | _, 0 => 0\n  | n' + 1, k' + 1 => min' n' k' + 1\ntermination_by structural n\nReplacing the simultaneous pattern match on both parameters with a match on a pair causes termination analysis to fail:def min' (n k : Nat) : Nat :=\n  match (n, k) with\n  | (0, _) => 0\n  | (_, 0) => 0\n  | (n' + 1, k' + 1) => min' n' k' + 1\ntermination_by structural n\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    min' n' k'\nThis is because the analysis only considers direct pattern matching on parameters when matching recursive calls to strictly-smaller argument values.\nWrapping the discriminants in a pair breaks the connection.\n\nStructural Recursion Under PairsThis function that finds the minimum of the two components of a pair can't be elaborated via structural recursion.def min' (nk : Nat × Nat) : Nat :=\n  match nk with\n  | (0, _) => 0\n  | (_, 0) => 0\n  | (n' + 1, k' + 1) => min' (n', k') + 1\ntermination_by structural nk\nfailed to infer structural recursion:\nCannot use parameter nk:\n  the type Nat × Nat does not have a `.brecOn` recursor\nThis is because the parameter's type, Prod, is not recursive.\nThus, its constructor has no recursive parameters that can be exposed by pattern matching.This definition is accepted using well-founded recursion, however:def min' (nk : Nat × Nat) : Nat :=\n  match nk with\n  | (0, _) => 0\n  | (_, 0) => 0\n  | (n' + 1, k' + 1) => min' (n', k') + 1\ntermination_by nk\n\n\n\n\nStructural Recursion and Definitional EqualityEven though the recursive occurrence of countdown is applied to a term that is not a strict sub-term of the decreasing parameter, the following definition is accepted:def countdown (n : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n' + 1 => n' :: countdown (n' + 0)\ntermination_by structural n\nThis is because n' + 0 is definitionally equal to n', which is a strict sub-term of n.\nSub-terms that result from pattern matching are connected to the discriminant using the rules for match generalization, which respect definitional equality.In countdown', the recursive occurrence is applied to 0 + n', which is not definitionally equal to n' because addition on natural numbers is structurally recursive in its second parameter:def countdown' (n : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n' + 1 => n' :: countdown' (0 + n')\ntermination_by structural n\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    countdown' (0 + n')\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Structural Recursion","header":"7.6.2.1. Explicit Structural Recursion","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion"},"/The-Simplifier/Terminal-vs-Non-Terminal-Positions/#terminal-simp":{"contents":"To write maintainable proofs, avoid using simp without only unless it closes the goal.\nSuch uses of simp that do not close a goal are referred to as non-terminal simps.\nThis is because additions to the default simp set may make simp more powerful or just cause it to select a different sequence of rewrites and arrive at a different simp normal form.\nWhen only is specified, additional lemmas will not affect that invocation of the tactic.\nIn practice, terminal uses of simp are not nearly as likely to be broken by the addition of new simp lemmas, and when they are, it's easier to understand the issue and fix it.\n\nWhen working in non-terminal positions, simp? (or one of the other simplification tactics with ? in their names) can be used to generate an appropriate invocation with only.\nJust as apply? or rw? suggest the use of relevant lemmas, simp? suggests an invocation of simp with a minimal simp set that was used to reach the normal form.\n\nUsing simp?The non-terminal simp? in this proof suggests a smaller simp with only:example (xs : Array Unit) : xs.size = 2 → xs = #[(), ()] := by\n  intros\n  ext\n  simp?\n  assumption\nThe suggested rewrite is:Try this:\n  [apply] simp only [List.size_toArray, List.length_cons, List.length_nil, Nat.zero_add, Nat.reduceAdd]\nwhich results in the more maintainable proof:example (xs : Array Unit) : xs.size = 2 → xs = #[(), ()] := by\n  intros\n  ext\n  simp only [\n    List.size_toArray, List.length_cons, List.length_nil,\n    Nat.zero_add, Nat.reduceAdd\n  ]\n  assumption\n\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.5. Terminal vs Non-Terminal Positions","id":"/The-Simplifier/Terminal-vs-Non-Terminal-Positions/#terminal-simp"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Async":{"contents":"* #6683 introduces TCP socket support using the LibUV library, enabling\nasynchronous I/O operations with it.* #7571 fixes #7478 by modifying number specifiers from atLeast size\nto flexible size for parsing. This change allows:* 1 repetition to accept 1 or more characters* More than 1 repetition to require exactly that many characters* #7574 introduces UDP socket support using the LibUV library, enabling\nasynchronous I/O operations with it.* #7578 introduces a function called interfaceAddresses that retrieves\nan array of system’s network interfaces.* #7584 introduces a structure called FormatConfig, which provides\nadditional configuration options for GenericFormat, such as whether\nleap seconds should be allowed during parsing. By default, this option\nis set to false.* #7751 adds Std.BaseMutex.tryLock and Std.Mutex.tryAtomically as\nwell as unit tests for our locking and condition variable primitives.* #7755 adds Std.RecursiveMutex as a recursive/reentrant equivalent to\nStd.Mutex.* #7771 adds a barrier primitive as Std.Barrier.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Library","header":"Async","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Async"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Compiler":{"contents":"* #6063 updates the version of LLVM and clang used by and shipped with\nLean to 19.1.2* #7824 fixes an issue where uses of 'noncomputable' definitions can get\nincorrectly compiled, while also removing the use of 'noncomputable'\ndefinitions altogether. Some uses of 'noncomputable' definitions (e.g.\nClassical.propDecidable) do not get compiled correctly by type erasure.\nRunning the optimizer on the result can lead to them being optimized\naway, eluding the later IR-level check for uses of noncomputable\ndefinitions.* #7838 adds support for mpz objects (i.e., big nums) to the\nshareCommon functions.* #7854 introduces fundamental API to distribute module data across\nmultiple files in preparation for the module system.* #7945 fixes a potential race between IO.getTaskState and the task in\nquestion finishing, resulting in undefined behavior.* #7958 ensures that after main is finished we still wait on dedicated\ntasks instead of exiting forcefully. If users wish to violently kill\ntheir dedicated tasks at the end of main instead they can run\nIO.Process.exit at the end of main instead.* #7990 adopts lcAny in more cases of type erasure in the new code\ngenerator.* #7996 disables CSE of local function declarations in the base phase of\nthe new compiler. This was introducing sharing between lambdas to bind\ncalls w/ do notation, which caused them to later no longer be inlined.* #8006 changes the inlining heuristics of the new code generator to\nmatch the old one, which ensures that monadic folds get sufficiently\ninlined for their tail recursion to be exposed to the code generator.* #8007 changes eager lambda lifting heuristics in the new compiler to\nmatch the old compiler, which ensures that inlining/specializing monadic\ncode does not accidentally create mutual tail recursion that the code\ngenerator can't handle.* #8008 changes specialization in the new code generator to consider\ncallee params to be ground variables, which improves the specialization\nof polymorphic functions.* #8009 restricts lifting outside of cases expressions on values of a\nDecidable type, since we can't correctly represent the dependency on the\nerased proposition in the later stages of the compiler.* #8010 fixes caseOn expressions with an implemented_by to work\ncorrectly with hash consing, even when the elaborator produces terms\nthat reconstruct the discriminant rather than just reusing a variable.* #8015 fixes the IR elim_dead_branches pass to correctly handle join\npoints with no params, which currently get considered unreachable. I was\nnot able to find an easy repro of this with the old compiler, but it\noccurs when bootstrapping Lean with the new compiler.* #8017 makes the IR elim_dead_branches pass correctly handle extern\nfunctions by considering them as having a top return value. This fix is\nrequired to bootstrap the Init/ directory with the new compiler.* #8023 fixes the IR expand_reset_reuse pass to correctly handle\nduplicate projections from the same base/index. This does not occur (at\nleast easily) with the old compiler, but it occurs when bootstrapping\nLean with the new compiler.* #8124 correctly handles escaping functions in the LCNF\nelimDeadBranches pass, by setting all params to top instead of\npotentially leaving them at their default bottom value.* #8125 adds support for the init attribute to the new compiler.* #8127 adds support for borrowed params in the new compiler, which\nrequires adding support for .mdata expressions to LCNF type handling.* #8132 adds support for lowering casesOn for builtin types in the new\ncompiler.* #8156 fixes a bug where the old compiler's lcnf conversion expr cache\nwas not including all of the relevant information in the key, leading to\nterms inadvertently being erased. The root variable is used to\ndetermine whether lambda arguments to applications should get let\nbindings or not, which in turn affects later decisions about type\nerasure (erase_irrelevant assumes that any non-atomic argument is\nirrelevant).* #8236 fixes an issue where the combination of extern_lib and\nprecompileModules would lead to \"symbol not found\" errors.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Compiler","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Compiler"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Pretty-Printing":{"contents":"* #10376 modifies pretty printing of fun binders, suppressing the safe\nshadowing feature among the binders in the same fun. For example,\nrather than pretty printing as fun x x => 0, we now see fun x x_1 => 0. The calculation is done per fun, so for example fun x => id fun x => 0 pretty prints as-is, taking advantage of safe shadowing.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Pretty Printing","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Pretty-Printing"}});