window.docContents[109].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Positions--Incrementing-and-Decrementing":{"contents":"Returns the previous valid position before the given position, given a proof that the position\nis not the start position, which guarantees that such a position exists.\n\nReturns the previous valid position before the given position, or panics if the position is\nthe start position.\n\nReturns the previous valid position before the given position, or none if the position is\nthe start position.\n\nIterates p.prev n times, saturating at s.startPos if necessary.\n\nAdvances a valid position on a slice to the next valid position, given a proof that the\nposition is not the past-the-end position, which guarantees that such a position exists.\n\nAdvances a valid position on a slice to the next valid position, or panics if the given\nposition is the past-the-end position.\n\nAdvances a valid position on a slice to the next valid position, or returns none if the\ngiven position is the past-the-end position.\n\nAdvances the position p n times, saturating at s.endPos if necessary.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009Positions","header":"19.8.4.12.3.2. Incrementing and Decrementing","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Positions--Incrementing-and-Decrementing"},"/Basic-Types/Tuples/#prod-api":{"contents":"As a mere pair, the primary API for Prod is provided by pattern matching and by the first and second projections Prod.fst and Prod.snd.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples\u0009Ordered Pairs","header":"19.13.1.1. API Reference","id":"/Basic-Types/Tuples/#prod-api"},"/Functors___-Monads-and--do--Notation/Laws/#monad-laws":{"contents":"Having map, pure, seq, and bind operators with the appropriate types is not really sufficient to have a functor, applicative functor, or monad.\nThese operators must additionally satisfy certain axioms, which are often called the laws of the type class.For a functor, the map operation must preserve identity and function composition. In other words, given a purported Functor f, for all x​:​f α:* id <$> x = x, and* for all function g and h, (h ∘ g) <$> x = h <$> g <$> x.Instances that violate these assumptions can be very surprising!\nAdditionally, because Functor includes mapConst to enable instances to provide a more efficient implementation, a lawful functor's mapConst should be equivalent to its default implementation.The Lean standard library does not require proofs of these properties in every instance of Functor.\nNonetheless, if an instance violates them, then it should be considered a bug.\nWhen proofs of these properties are necessary, an instance implicit parameter of type LawfulFunctor f can be used.\nThe LawfulFunctor class includes the necessary proofs.A functor satisfies the functor laws.The Functor class contains the operations of a functor, but does not require that instances\nprove they satisfy the laws of a functor. A LawfulFunctor instance includes proofs that the laws\nare satisfied. Because Functor instances may provide optimized implementations of mapConst,\nLawfulFunctor instances must also prove that the optimized implementation is equivalent to the\nstandard implementation.The mapConst implementation is equivalent to the default implementation.The map implementation preserves identity.The map implementation preserves function composition.In addition to proving that the potentially-optimized SeqLeft.seqLeft and SeqRight.seqRight operations are equivalent to their default implementations, Applicative functors f must satisfy four laws.An applicative functor satisfies the laws of an applicative functor.The Applicative class contains the operations of an applicative functor, but does not require that\ninstances prove they satisfy the laws of an applicative functor. A LawfulApplicative instance\nincludes proofs that the laws are satisfied.Because Applicative instances may provide optimized implementations of seqLeft and seqRight,\nLawfulApplicative instances must also prove that the optimized implementation is equivalent to the\nstandard implementation.seqLeft is equivalent to the default implementation.seqRight is equivalent to the default implementation.pure before seq is equivalent to Functor.map.This means that pure really is pure when occurring immediately prior to seq.Mapping a function over the result of pure is equivalent to applying the function under pure.This means that pure really is pure with respect to Functor.map.pure after seq is equivalent to Functor.map.This means that pure really is pure when occurring just after seq.seq is associative.Changing the nesting of seq calls while maintaining the order of computations results in an\nequivalent computation. This means that seq is not doing any more than sequencing.The monad laws specify that pure followed by bind should be equivalent to function application (that is, pure has no effects), that bind followed by pure around a function application is equivalent to map, and that bind is associative.Lawful monads are those that satisfy a certain behavioral specification. While all instances of\nMonad should satisfy these laws, not all implementations are required to prove this.LawfulMonad.mk' is an alternative constructor that contains useful defaults for many fields.A bind followed by pure composed with a function is equivalent to a functorial map.This means that pure really is pure after a bind and has no effects.A bind followed by a functorial map is equivalent to Applicative sequencing.This means that the effect sequencing from Monad and Applicative are the same.pure followed by bind is equivalent to function application.This means that pure really is pure before a bind and has no effects.bind is associative.Changing the nesting of bind calls while maintaining the order of computations results in an\nequivalent computation. This means that bind is not doing more than data-dependent sequencing.An alternative constructor for LawfulMonad which has more\ndefaultable fields in the common case.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation","header":"14.1. Laws","id":"/Functors___-Monads-and--do--Notation/Laws/#monad-laws"},"/IO/Environment-Variables/#io-monad-getenv":{"contents":"Returns the value of the environment variable var, or none if it is not present in the\nenvironment.\n\n","context":"Lean Reference\u0009IO","header":"15.7. Environment Variables","id":"/IO/Environment-Variables/#io-monad-getenv"}});