window.docContents[47].resolve({"/Basic-Types/The-Empty-Type/#empty":{"contents":"The empty type Empty represents impossible values.\nIt is an inductive type with no constructors whatsoever.\n\nWhile the trivial type Unit, which has a single constructor that takes no parameters, can be used to model computations where a result is unwanted or uninteresting, Empty can be used in situations where no computation should be possible at all.\nInstantiating a polymorphic type with Empty can mark some of its constructors—those with a parameter of the corresponding type—as impossible; this can rule out certain code paths that are not desired.\n\nThe presence of a term with type Empty indicates that an impossible code path has been reached.\nThere will never be a value with this type, due to the lack of constructors.\nOn an impossible code path, there's no reason to write further code; the function Empty.elim can be used to escape an impossible path.\n\nThe universe-polymorphic equivalent of Empty is PEmpty.\n\nThe empty type. It has no constructors.Use Empty.elim in contexts where a value of type Empty is in scope.\n\nThe universe-polymorphic empty type, with no constructors.PEmpty can be used in any universe, but this flexibility can lead to worse error messages and more\nchallenges with universe level unification. Prefer the type Empty or the proposition False when\npossible.\n\nImpossible Code PathsThe type signature of the function f indicates that it might throw exceptions, but allows the exception type to be anything:def f (n : Nat) : Except ε Nat := pure n\nInstantiating f's exception type with Empty exploits the fact that f never actually throws an exception to convert it to a function whose type indicates that no exceptions will be thrown.\nIn particular, it allows Empty.elim to be used to avoid handing the impossible exception value.def g (n : Nat) : Nat :=\n  match f (ε := Empty) n with\n  | .error e =>\n    Empty.elim e\n  | .ok v => v\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.10. The Empty Type","id":"/Basic-Types/The-Empty-Type/#empty"},"/Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions":{"contents":"Definitions add a new constant to the global environment as a name that stands for a term.\nAs part of the kernel's definitional equality, this new constant may be replaced via δ-reduction with the term that it stands for.\nIn the elaborator, this replacement is governed by the constant's reducibility.\nThe new constant may be universe polymorphic, in which case occurrences may instantiate it with different universe level parameters.\n\nFunction definitions may be recursive.\nTo preserve the consistency of Lean's type theory as a logic, recursive functions must either be opaque to the kernel (e.g. by declaring them partial) or proven to terminate with one of the strategies described in the section on recursive definitions.\n\nThe headers and bodies of definitions are elaborated together.\nIf the header is incompletely specified (e.g. a parameter's type or the codomain is missing), then the body may provide sufficient information for the elaborator to reconstruct the missing parts.\nHowever, instance implicit parameters must be specified in the header or as section variables.\n\nDefinitionsDefinitions that use := associate the term on the right-hand side with the constant's name.\nThe term is wrapped in a fun for each parameter, and the type is found by binding the parameters in a function type.\nDefinitions with def are semireducible.Definitions may use pattern matching.\nThese definitions are desugared to uses of match.Values of structure types, or functions that return them, may be defined by providing values for their fields, following where:\n\nAbbreviationsAbbreviations are identical to definitions with def, except they are reducible.\n\nOpaque constants are defined constants that are not subject to δ-reduction in the kernel.\nThey are useful for specifying the existence of some function.\nUnlike axioms, opaque declarations can only be used for types that are inhabited, so they do not risk introducing inconsistency.\nAlso unlike axioms, the inhabitant of the type is used in compiled code.\nThe implemented_by attribute can be used to instruct the compiler to emit a call to some other function as the compilation of an opaque constant.\n\nOpaque ConstantsOpaque definitions with right-hand sides are elaborated like other definitions.\nThis demonstrates that the type is inhabited; the inhabitant plays no further role.Opaque constants may also be specified without right-hand sides.\nThe elaborator fills in the right-hand side by synthesizing an instance of Inhabited, or Nonempty if that fails.\n\n","context":"Lean Reference\u0009Definitions","header":"7.3. Definitions","id":"/Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions"},"/Definitions/Headers-and-Signatures/#parameter-syntax":{"contents":"After the name, if present, is the header's signature.\nThe signature specifies the declaration's parameters and type.\n\nDeclaration SignaturesA signature consists of zero or more parameters, followed by a colon and a type.\n\nOptional SignaturesSignatures are often optional.\nIn these cases, parameters may be supplied even if the type is omitted.\n\nParameters may have three forms:\n\n* An identifier, which names a parameter but does not provide a type.\n   These parameters' types must be inferred during elaboration.* An underscore (_), which indicates a parameter that is not accessible by name in the local scope.\n   These parameters' types must also be inferred during elaboration.* A bracketed binder, which may specify every aspect of one or more parameters, including their names, their types, default values, and whether they are explicit, implicit, strictly implicit, or instance-implicit.\n\n","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","header":"7.2.2. Parameters and Types","id":"/Definitions/Headers-and-Signatures/#parameter-syntax"},"/Interacting-with-Lean/#interaction":{"contents":"Lean is designed for interactive use, rather than as a batch-mode system in which whole files are fed in and then translated to either object code or error messages.\nMany programming languages designed for interactive use provide a REPL,Short for “Read-Eval-Print Loop”, because code is parsed (“read”), evaluated, and the result displayed, with this process repeated as many times as desired. at which code can be input and tested, along with commands for loading source files, type checking terms, or querying the environment.\nLean's interactive features are based on a different paradigm.\nRather than a separate command prompt outside of the program, Lean provides commands for accomplishing the same tasks in the context of a source file.\nBy convention, commands that are intended for interactive use rather than as part of a durable code artifact are prefixed with #.\n\nInformation from Lean commands is available in the message log, which accumulates output from the elaborator.\nEach entry in the message log is associated with a specific source range and has a severity.\nThere are three severities: information is used for messages that do not indicate a problem, warning indicates a potential problem, and error indicates a definite problem.\nFor interactive commands, results are typically returned as informational messages that are associated with the command's leading keyword.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"3. Interacting with Lean","id":"/Interacting-with-Lean/#interaction"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Other":{"contents":"* #7129 optimizes the performance of the unused variables linter in the\ncase of a definition with a huge Expr representation* #7173 introduces a trace node for each deriving handlers invocation\nfor the benefit of trace.profiler* #7184 adds support for LEAN_BACKTRACE on macOS. This previously only\nworked with glibc, but it can not be enabled for all Unix-like systems,\nsince e.g. Musl does not support it.* #7190 makes the stage2 Leanc build use the stage2 oleans rather than\nstage1 oleans. This was happening because Leanc's own OLEAN_OUT is at\nthe build root rather than the lib/lean subdirectory, so when the build\nadded this OLEAN_OUT to LEAN_PATH no oleans were found there and the\nsearch fell back to the stage1 installation location.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Other","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Other"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Pretty-Printing":{"contents":"* #7589 changes the structure instance notation pretty printer so that\nfields are omitted if their value is definitionally equal to the default\nvalue for the field (up to reducible transparancy). Setting\npp.structureInstances.defaults to true forces such fields to be pretty\nprinted anyway.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)","header":"Pretty Printing","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Pretty-Printing"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Highlights":{"contents":"'Unknown identifier' code actions\n\n* #7665 and #8180 add\nsupport for code actions that resolve 'Unknown identifier' errors by either importing the missing declaration or by\nchanging the identifier to one from the environment.\n\nNew Language Features\n\n* #8449 and #8516\nupstream and extend the Mathlib clear_value tactic. Given a\nlocal definition x : T := v, the tactic clear_value x replaces it\nwith a hypothesis x : T, or throws an error if the goal does not\ndepend on the value v. The syntax clear_value (h : x = _) creates a\nhypothesis h : x = _ before clearing the value of x. Any expression definitionally equal to x\ncan be used in place of the underscore.\nFurthermore, clear_value * clears all values that can be cleared, or throws an\nerror if none can be cleared.* #8512 adds a value_of% ident term that elaborates to the value of\nthe local or global constant ident. This is useful for creating\ndefinition hypotheses:let x := ... complicated expression ...\nhave hx : x = value_of% x := rfl\n* #8450 adds a feature to the subst tactic so that when x : X := v\nis a local definition, subst x substitutes v for x in the goal and\nremoves x. Previously the tactic would throw an error.* #8037 introduces a noConfusionType construction that’s sub-quadratic\nin size, and reduces faster. The previous noConfusion construction with\ntwo nested match statements is quadratic in size and reduction behavior.\nUsing some helper definitions, a linear size construction is possible.* #8104 makes fun_induction and fun_cases (try to) unfold the\nfunction application of interest in the goal. The old behavior can be\nenabled with set_option tactic.fun_induction.unfolding false. For\nfun_cases this does not work yet when the function’s result type\ndepends on one of the arguments, see issue #8296.* #8171 omits cases from functional induction/cases principles that are\nimplemented by contradiction (or, more generally, False.elim,\nabsurd or `noConfusion). Breaking change in the sense that there are\nfewer goals to prove after using functional induction.* #8106 adds a register_linter_set command for declaring linter sets.\nThe getLinterValue function now checks if the present linter is\ncontained in a set that has been enabled (using the set_option command\nor on the command line).* #8267 makes #guard_msgs to treat trace messages separate from\ninfo, warning and error. It also introduces the ability to say\n#guard_msgs (pass info), like (drop info) so far, and also adds\n(check info) as the explicit form of (info), for completeness.\n\nLibrary Highlights\n\n* #8358 introduces a very minimal version of the new iterator library.\nIt comes with list iterators and various consumers, namely toArray,\ntoList, toListRev, ForIn, fold, foldM and drain. All\nconsumers also come in a partial variant that can be used without any\nproofs. This limited version of the iterator library generates decent\ncode, even with the old code generator.* #7352 reworks the simp set around the Id monad, to not elide or\nunfold pure and Id.run* #8313 changes the definition of Vector so it no longer extends\nArray. This prevents Array API from \"leaking through\".\n\nOther Highlights\n\n* Performance optimizations in dsimp:* #6973 stops dsimp from visiting proof terms, which should make\nsimp and dsimp more efficient.* #7428 adds a dsimp cache to simp. Previously each dsimp call from\nsimp started with a fresh cache. As a result, time spent in simp while\ncompiling Mathlib is reduced by over 45%, giving an overall 8% speedup to\nMathlib compilation.* #8221 adjusts the experimental module system to not export the bodies\nof defs unless opted out by the new attribute @[expose] on the def\nor on a surrounding section.* #8559 and #8560 fix an adversarial\nsoundness attack described  in #8554. The\nattack exploits the fact that assert! no longer aborts execution, and\nthat users can redirect error messages.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Highlights","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Highlights"}});