window.docContents[110].resolve({"/Basic-Types/Fixed-Precision-Integers/#fixed-int-comparisons":{"contents":"The operators in this section are rarely invoked by name.\nTypically, comparisons operations on fixed-width integers should use the decidability of the corresponding relations, which consist of the equality type Eq and those implemented in instances of LE and LT.\n\n\n\n\n\nNon-strict inequality of word-sized unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of word-sized signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 8-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 8-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the ≤ operator.\n\nNon-strict inequality of 16-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 16-bit signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 32-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 32-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the ≤ operator.\n\nNon-strict inequality of 64-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 64-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the ≤ operator.\n\nStrict inequality of word-sized unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of word-sized signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the < operator.\n\nStrict inequality of 8-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 8-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nStrict inequality of 16-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 16-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nStrict inequality of 32-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 32-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nStrict inequality of 64-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 64-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nDecides whether two word-sized unsigned integers are equal. Usually accessed via the\nDecidableEq USize instance.This function is overridden at runtime with an efficient implementation.Examples:* USize.decEq 123 123 = .isTrue rfl* (if (6 : USize) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : USize) = 7 by decide\n\nDecides whether two word-sized signed integers are equal. Usually accessed via the\nDecidableEq ISize instance.This function is overridden at runtime with an efficient implementation.Examples:* ISize.decEq 123 123 = .isTrue rfl* (if ((-7) : ISize) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : ISize) = 7 by decide\n\nDecides whether two 8-bit unsigned integers are equal. Usually accessed via the DecidableEq UInt8\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* UInt8.decEq 123 123 = .isTrue rfl* (if (6 : UInt8) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt8) = 7 by decide\n\nDecides whether two 8-bit signed integers are equal. Usually accessed via the DecidableEq Int8\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int8.decEq 123 123 = .isTrue rfl* (if ((-7) : Int8) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int8) = 7 by decide\n\nDecides whether two 16-bit unsigned integers are equal. Usually accessed via the\nDecidableEq UInt16 instance.This function is overridden at runtime with an efficient implementation.Examples:* UInt16.decEq 123 123 = .isTrue rfl* (if (6 : UInt16) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt16) = 7 by decide\n\nDecides whether two 16-bit signed integers are equal. Usually accessed via the DecidableEq Int16\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int16.decEq 123 123 = .isTrue rfl* (if ((-7) : Int16) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int16) = 7 by decide\n\nDecides whether two 32-bit unsigned integers are equal. Usually accessed via the\nDecidableEq UInt32 instance.This function is overridden at runtime with an efficient implementation.Examples:* UInt32.decEq 123 123 = .isTrue rfl* (if (6 : UInt32) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt32) = 7 by decide\n\nDecides whether two 32-bit signed integers are equal. Usually accessed via the DecidableEq Int32\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int32.decEq 123 123 = .isTrue rfl* (if ((-7) : Int32) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int32) = 7 by decide\n\nDecides whether two 64-bit unsigned integers are equal. Usually accessed via the\nDecidableEq UInt64 instance.This function is overridden at runtime with an efficient implementation.Examples:* UInt64.decEq 123 123 = .isTrue rfl* (if (6 : UInt64) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt64) = 7 by decide\n\nDecides whether two 64-bit signed integers are equal. Usually accessed via the DecidableEq Int64\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int64.decEq 123 123 = .isTrue rfl* (if ((-7) : Int64) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int64) = 7 by decide\n\nDecides whether one word-sized unsigned integer is less than or equal to another. Usually accessed\nvia the DecidableLE USize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : USize) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : USize) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : USize) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : USize) ≤ 7 by decide\n\nDecides whether one word-sized signed integer is less than or equal to another. Usually accessed via\nthe DecidableLE ISize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : ISize) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : ISize) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : ISize) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : ISize) ≤ 7 by decide\n\nDecides whether one 8-bit unsigned integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt8) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt8) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt8) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt8) ≤ 7 by decide\n\nDecides whether one 8-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int8) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int8) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int8) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int8) ≤ 7 by decide\n\nDecides whether one 16-bit unsigned integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt16) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt16) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt16) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt16) ≤ 7 by decide\n\nDecides whether one 16-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int16) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int16) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int16) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int16) ≤ 7 by decide\n\nDecides whether one 32-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt32) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt32) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt32) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt32) ≤ 7 by decide\n\nDecides whether one 32-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int32) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int32) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int32) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int32) ≤ 7 by decide\n\nDecides whether one 64-bit unsigned integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt64) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt64) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt64) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt64) ≤ 7 by decide\n\nDecides whether one 8-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int64) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int64) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int64) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int64) ≤ 7 by decide\n\nDecides whether one word-sized unsigned integer is strictly less than another. Usually accessed via\nthe DecidableLT USize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : USize) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : USize) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : USize) < 7) by decide\n\nDecides whether one word-sized signed integer is strictly less than another. Usually accessed via the\nDecidableLT ISize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : ISize) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : ISize) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : ISize) < 7) by decide\n\nDecides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt8) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt8) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt8) < 7) by decide\n\nDecides whether one 8-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int8) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int8) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int8) < 7) by decide\n\nDecides whether one 16-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt16) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt16) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt16) < 7) by decide\n\nDecides whether one 16-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int16) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int16) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int16) < 7) by decide\n\nDecides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt32) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt32) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt32) < 7) by decide\n\nDecides whether one 32-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int32) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int32) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int32) < 7) by decide\n\nDecides whether one 64-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt64) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt64) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt64) < 7) by decide\n\nDecides whether one 8-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int64) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int64) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int64) < 7) by decide\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"19.4.4.4. Comparisons","id":"/Basic-Types/Fixed-Precision-Integers/#fixed-int-comparisons"}});