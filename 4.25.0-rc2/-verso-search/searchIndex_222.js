window.docContents[222].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Bitwise-Operators":{"contents":"These operators modify the individual bits of one or more bitvectors.\n\nBitwise and for bitvectors. Usually accessed via the &&& operator.SMT-LIB name: bvand.Example:* 0b1010#4 &&& 0b0110#4 = 0b0010#4\n\nBitwise or for bitvectors. Usually accessed via the ||| operator.SMT-LIB name: bvor.Example:* 0b1010#4 ||| 0b0110#4 = 0b1110#4\n\nBitwise complement for bitvectors. Usually accessed via the ~~~ prefix operator.SMT-LIB name: bvnot.Example:* ~~~(0b0101#4) == 0b1010\n\nBitwise xor for bitvectors. Usually accessed via the ^^^ operator.SMT-LIB name: bvxor.Example:* 0b1010#4 ^^^ 0b0110#4 = 0b1100#4\n\nTransforms a bitvector of length w into a bitvector of length v, padding with 0 as needed.The specific behavior depends on the relationship between the starting width w and the final width\nv:* If v > w, it is zero-extended; the high bits are padded with zeroes until the bitvector has v\nbits.* If v = w, the bitvector is returned unchanged.* If v < w, the high bits are truncated.BitVec.setWidth, BitVec.zeroExtend, and BitVec.truncate are aliases for this operation.SMT-LIB name: zero_extend.\n\nTransforms a bitvector of length w into a bitvector of length v, padding as needed with the most\nsignificant bit's value.If x is an empty bitvector, then the sign is treated as zero.SMT-LIB name: sign_extend.\n\nShifts a bitvector to the right. This is a logical right shift - the high bits are filled with\nzeros.As a numeric operation, this is equivalent to x / 2^s, rounding down.SMT-LIB name: bvlshr except this operator uses a Nat shift value.\n\nShifts a bitvector to the right. This is an arithmetic right shift - the high bits are filled with\nmost significant bit's value.As a numeric operation, this is equivalent to x.toInt >>> s.SMT-LIB name: bvashr except this operator uses a Nat shift value.\n\nShifts a bitvector to the right. This is an arithmetic right shift - the high bits are filled with\nmost significant bit's value.As a numeric operation, this is equivalent to a.toInt >>> s.toNat.SMT-LIB name: bvashr.\n\nShifts a bitvector to the left. The low bits are filled with zeros. As a numeric operation, this is\nequivalent to x * 2^s, modulo 2^n.SMT-LIB name: bvshl except this operator uses a Nat shift value.\n\nReturns zeroExtend (w+n) x <<< n without needing to compute x % 2^(2+n).\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"19.5.5.7. Bitwise Operators","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Bitwise-Operators"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Controlling-Output":{"contents":"These options provide allow control over the log that is produced while building.\nIn addition to showing or hiding messages, a build can be made to fail when warnings or even information is emitted; this can be used to enforce a style guide that disallows output during builds.\n\n --quiet, -q\n\nHides informational logs and the progress indicator.\n\n --verbose, -v\n\nShows trace logs (typically command invocations) and built targets.\n\n  --ansi, --no-ansi\n\nEnables or disables the use of ANSI escape codes that add colors and animations to Lake's output.\n\n  --log-level\n\nSets the minimum level of logs to be shown when builds succeed.\n  LV may be trace, info, warning, or error, compared case-insensitively.\n  When a build fails, all levels are shown.\n  The default log level is info.\n\n  --fail-level\n\nSets the threshold at which a message in the log causes a build to be considered a failure.\n  If a message is emitted to the log with a level that is greater than or equal to the threshold, the build fails.\n  LV may be trace, info, warning, or error, compared case-insensitively; it is error by default.\n\n --iofail\n\nCauses builds to fail if any I/O or other info is logged.\n  This is equivalent to --fail-level=info.\n\n --wfail\n\nCauses builds to fail if any warnings are logged.\n  This is equivalent to --fail-level=warning.\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"22.1.2.3. Controlling Output","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Controlling-Output"},"/Definitions/Recursive-Definitions/#inferring-structural-recursion":{"contents":"If no termination_by clauses are present in a recursive or mutually recursive function definition, then Lean attempts to infer a suitable structurally decreasing argument, effectively by trying all suitable parameters in sequence.\nIf this search fails, Lean then attempts to infer well-founded recursion.\n\nFor mutually recursive functions, all combinations of parameters are tried, up to a limit to avoid combinatorial explosion.\nIf only some of the mutually recursive functions have termination_by structural clauses, then only those parameters are considered, while for the other functions all parameters are considered for structural recursion.\n\nA termination_by? clause causes the inferred termination annotation to be shown.\nIt can be automatically added to the source file using the offered suggestion or code action.\n\nInferred Termination AnnotationsLean automatically infers that the function half is structurally recursive.\nThe termination_by? clause causes the inferred termination annotation to be displayed, and it can be automatically added to the source file with a single click.def half : Nat â†’ Nat\n  | 0 | 1 => 0\n  | n + 2 => half n + 1\ntermination_by?\nTry this:\n  [apply] termination_by structural x => x\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Structural Recursion","header":"7.6.2.3. Inferring Structural Recursion","id":"/Definitions/Recursive-Definitions/#inferring-structural-recursion"},"/Source-Files-and-Modules/#comments":{"contents":"Comments are stretches of the file that, despite not being whitespace, are treated as such.\nLean has two syntaxes for comments:\n\n Line comments\n\nA -- that does not occur as part of a token begins a line comment. All characters from the initial - to the newline are treated as whitespace.\n\n Block comments\n\nA /- that does not occur as part of a token and is not immediately followed by a - character begins a block comment.\n  The block comment continues until a terminating -/ is found.\n  Block comments may be nested; a -/ only terminates the comment if prior nested block comment openers /- have been terminated by a matching -/.\n\n\n\n/-- and /-! begin documentation  rather than comments, which are also terminated with -/ and may contain nested block comments.\nEven though documentation resembles comments, they are their own syntactic category; their valid placement is determined by Lean's grammar.\n\n","context":"Lean Reference\u0009Source Files and Modules\u0009Concrete Syntax","header":"5.2.2. Comments","id":"/Source-Files-and-Modules/#comments"},"/Type-Classes/Instance-Declarations/#instance-attribute":{"contents":"The instance attribute declares a name to be an instance, with the specified priority.\nLike other attributes, instance can be applied globally, locally, or only when the current namespace is opened.\nThe instance declaration is a form of definition that automatically applies the instance attribute.\n\nThe instance AttributeDeclares the definition to which it is applied to be an instance.\nIf no priority is provided, then the default priority default is used.\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Declarations","header":"11.2.5. The Instance Attribute","id":"/Type-Classes/Instance-Declarations/#instance-attribute"}});