window.docContents[141].resolve({"/Basic-Types/Natural-Numbers/#nat-api-deceq":{"contents":"A decision procedure for equality of natural numbers, usually accessed via the DecidableEq Nat\ninstance.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.Examples:* Nat.decEq 5 5 = isTrue rfl* (if 3 = 4 then \"yes\" else \"no\") = \"no\"* show 12 = 12 by decide\n\nA decision procedure for non-strict inequality of natural numbers, usually accessed via the\nDecidableLE Nat instance.Examples:* (if 3 ≤ 4 then \"yes\" else \"no\") = \"yes\"* (if 6 ≤ 4 then \"yes\" else \"no\") = \"no\"* show 12 ≤ 12 by decide* show 5 ≤ 12 by decide\n\nA decision procedure for strict inequality of natural numbers, usually accessed via the\nDecidableLT Nat instance.Examples:* (if 3 < 4 then \"yes\" else \"no\") = \"yes\"* (if 4 < 4 then \"yes\" else \"no\") = \"no\"* (if 6 < 4 then \"yes\" else \"no\") = \"no\"* show 5 < 12 by decide\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Comparisons","header":"19.1.4.5.2. Decidable Equality","id":"/Basic-Types/Natural-Numbers/#nat-api-deceq"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Packages":{"contents":"Package ConfigurationThere can only be one package declaration per Lake configuration file.\nThe defined package configuration will be available for reference as _package.\n\nPost-Update HooksDeclare a post-lake update hook for the package.\nRuns the monadic action is after a successful lake update execution\nin this package or one of its downstream dependents.ExampleThis feature enables Mathlib to synchronize the Lean toolchain and run\ncache get after a lake update:lean_exe cache\npost_update pkg do\n  let wsToolchainFile := (← getRootPackage).dir / \"lean-toolchain\"\n  let mathlibToolchain ← IO.FS.readFile <| pkg.dir / \"lean-toolchain\"\n  IO.FS.writeFile wsToolchainFile mathlibToolchain\n  let exeFile ← runBuild cache.fetch\n  let exitCode ← env exeFile.toString #[\"get\"]\n  if exitCode ≠ 0 then\n    error s!\"{pkg.name}: failed to fetch cache\"\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"22.1.3.2.2. Packages","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Packages"},"/Interacting-with-Lean/#hash-print":{"contents":"The #print family of commands are used to query Lean for information about definitions.\n\nPrinting DefinitionsPrints the definition of a constant.\n\nPrinting a definition with #print prints the definition as a term.\nTheorems that were proved using tactics may be very large when printed as terms.\n\nPrinting StringsAdds the string literal to Lean's message log.\n\nPrinting AxiomsLists all axioms that the constant transitively relies on. See the documentation for axioms for more information.\n\nPrinting AxiomsThese two functions each swap the elements in a pair of bitvectors:def swap (x y : BitVec 32) : BitVec 32 × BitVec 32 :=\n  (y, x)\n\ndef swap' (x y : BitVec 32) : BitVec 32 × BitVec 32 :=\n  let x := x ^^^ y\n  let y := x ^^^ y\n  let x := x ^^^ y\n  (x, y)\nThey can be proven equal using function extensionality, the simplifier, and bv_decide:theorem swap_eq_swap' : swap = swap' := by\n  funext x y\n  simp only [swap, swap', Prod.mk.injEq]\n  bv_decide\nThe resulting proof makes use of a number of axioms:#print axioms swap_eq_swap'\n'swap_eq_swap'' depends on axioms: [propext, Classical.choice, Lean.ofReduceBool, Lean.trustCompiler, Quot.sound]\n\n\nPrinting EquationsThe command #print equations, which can be abbreviated #print eqns, displays the equational lemmas for a function.\n\nPrinting Equationsdef intersperse (x : α) : List α → List α\n  | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n  | xs => xs\n\n#print equations intersperse\nequations:\n@[defeq] theorem intersperse.eq_1.{u_1} : ∀ {α : Type u_1} (x y z : α) (zs : List α),\n  intersperse x (y :: z :: zs) = y :: x :: intersperse x (z :: zs)\ntheorem intersperse.eq_2.{u_1} : ∀ {α : Type u_1} (x : α) (x_1 : List α),\n  (∀ (y z : α) (zs : List α), x_1 = y :: z :: zs → False) → intersperse x x_1 = x_1\nIt does not print the defining equation, nor the unfolding equation:#check intersperse.eq_def\nintersperse.eq_def.{u_1} {α : Type u_1} (x : α) (x✝ : List α) :\n  intersperse x x✝ =\n    match x✝ with\n    | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n    | xs => xs\n#check intersperse.eq_unfold\nintersperse.eq_unfold.{u_1} :\n  @intersperse = fun {α} x x_1 =>\n    match x_1 with\n    | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n    | xs => xs\n\n\nScope Information#where gives a description of the state of the current scope scope.\nThis includes the current namespace, open namespaces, universe and variable commands,\nand options set with set_option.\n\nScope InformationThe #where command displays all the modifications made to the current section scope, both in the current scope and in the scopes in which it is nested.section\nopen Nat\n\nnamespace A\nvariable (n : Nat)\nnamespace B\n\nopen List\nset_option pp.funBinderTypes true\n\n#where\n\nend A.B\nend\nnamespace A.B\n\nopen Nat List\n\nvariable (n : Nat)\n\nset_option pp.funBinderTypes true\n\n\nChecking the Lean VersionShows the current Lean version. Prints Lean.versionString.\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.5. Querying the Context","id":"/Interacting-with-Lean/#hash-print"}});