window.docContents[94].resolve({"/Basic-Types/Natural-Numbers/#nat-api":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers","header":"19.1.4. API Reference","id":"/Basic-Types/Natural-Numbers/#nat-api"},"/Interacting-with-Lean/#hash-check":{"contents":"Checking Types#check can be used to elaborate a term and check its type.If the provided term is an identifier that is the name of a global constant, then #check prints its signature.\nOtherwise, the term is elaborated as a Lean term and its type is printed.\n\nElaboration of the term in #check does not require that the term is fully elaborated; it may contain metavariables.\nIf the term as written could have a type, elaboration succeeds.\nIf a required instance could never be synthesized, then elaboration fails; synthesis problems that are due to metavariables do not block elaboration.\n\n#check and Underdetermined TypesIn this example, the type of the list's elements is not determined, so the type contains a metavariable:#check fun x => [x]\nfun x => [x] : ?m.9 → List ?m.9\nIn this example, both the type of the terms being added and the result type of the addition are unknown, because HAdd allows terms of different types to be added.\nBehind the scenes, a metavariable represents the unknown HAdd instance.#check fun x => x + x\nfun x => x + x : (x : ?m.12) → ?m.19 x\n\n\nTesting Type ErrorsThis variant of #check elaborates the term using the same process as #check.\nIf elaboration succeeds, it is an error; if it fails, there is no error.\nThe partially-elaborated term and any type information that was discovered are added to the message log.\n\nChecking for Type ErrorsAttempting to add a string to a natural number fails, as expected:#check_failure \"one\" + 1\nfailed to synthesize\n  HAdd String Nat ?m.32\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nNonetheless, a partially-elaborated term is available:\"one\" + 1 : ?m.32\n\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.3. Checking Types","id":"/Interacting-with-Lean/#hash-check"},"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_--Resource-Limits":{"contents":"Gröbner basis computation can be very expensive. You can limit the number of steps performed by the ring solver using the option grind (ringSteps := <num>)\n\nLimiting ring StepsThis example cannot be solved by performing at most 100 steps:example [CommRing α] [IsCharP α 0] (d t c : α) (d_inv PSO3_inv : α) :\n    d ^ 2 * (d + t - d * t - 2) * (d + t + d * t) = 0 →\n    -d ^ 4 * (d + t - d * t - 2) *\n      (2 * d + 2 * d * t - 4 * d * t ^ 2 + 2 * d * t^4 +\n      2 * d^2 * t^4 - c * (d + t + d * t)) = 0 →\n    d * d_inv = 1 →\n    (d + t - d * t - 2) * PSO3_inv = 1 →\n    t^2 = t + 1 := by\n  grind (ringSteps := 100)\n`grind` failed\ncase grind\nα : Type u_1\ninst : CommRing α\ninst_1 : IsCharP α 0\nd t c d_inv PSO3_inv : α\nh : d ^ 2 * (d + t - d * t - 2) * (d + t + d * t) = 0\nh_1 : -d ^ 4 * (d + t - d * t - 2) *\n    (2 * d + 2 * d * t - 4 * d * t ^ 2 + 2 * d * t ^ 4 + 2 * d ^ 2 * t ^ 4 - c * (d + t + d * t)) =\n  0\nh_2 : d * d_inv = 1\nh_3 : (d + t - d * t - 2) * PSO3_inv = 1\nh_4 : ¬t ^ 2 = t + 1\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n  [eqc] False propositions\n  [eqc] Equivalence classes\n  [ring] Ring `α`\n  [limits] Thresholds reached\n\n\nThe ring solver propagates equalities back to the grind core by normalizing terms using the computed Gröbner basis.\nIn the following example, the equations x ^ 2 * y = 1 and x * y ^ 2 = y imply the equalities x = 1 and y = 1.\nThus, the terms x * y and 1 are equal, and consequently some (x * y) = some 1 by congruence.\n\nexample (x y : Int) :\n    x ^ 2 * y = 1 →\n    x * y ^ 2 = y →\n    some (y * x) = some 1 := by\n  grind\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Algebraic Solver (Commutative Rings, Fields)","header":"17.8.2. Resource Limits","id":"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_--Resource-Limits"},"/The--grind--tactic/Error-Messages/#grind-errors":{"contents":"When grind fails, it prints the remaining subgoal followed by all the information returned by its subsystems—the contents of the “shared whiteboard.”\nIn particular, it presents equivalence classes of terms that it has determined to be equal.\nThe two largest classes are shown as True propositions and False propositions, listing every literal currently known to be provable or refutable.\nInspect these lists to spot missing facts or contradictory assumptions.\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.1. Error Messages","id":"/The--grind--tactic/Error-Messages/#grind-errors"},"/The-Type-System/Quotients/#quotient-funext":{"contents":"Because Lean's definitional equality includes a computational reduction rule for Quot.lift, quotient types are used in the standard library to prove function extensionality, which would need to be an axiom otherwise.\nThis is done by first defining a type of functions quotiented by extensional equality, for which extensional equality holds by definition.variable {α : Sort u} {β : α → Sort v}\n\ndef extEq (f g : (x : α) → β x) : Prop :=\n  ∀ x, f x = g x\n\ndef ExtFun (α : Sort u) (β : α → Sort v) :=\n  Quot (@extEq α β)\nExtensional functions can be applied just like ordinary functions.\nApplication respects extensional equality by definition: if applying to functions gives equal results, then applying them gives equal results.def extApp\n    (f : ExtFun α β)\n    (x : α) :\n    β x :=\n  f.lift (· x) fun g g' h => by\n    exact h x\nTo show that two functions that are extensionally equal are in fact equal, it suffices to show that the functions that result from extensionally applying the corresponding extensional functions are equal.\nThis is becauseextApp (Quot.mk _ f)\nis definitionally equal tofun x => (Quot.mk extEq f).lift (· x) (fun _ _ h => h x)\nwhich is definitionally equal to fun x => f x, which is definitionally equal (by η-equivalence) to f.\nA propositional version of the computation rule for Quot.lift would not suffice, because the reducible expression occurs in the body of a function and rewriting by an equality in a function would already require function extensionality.From here, it is enough to show that the extensional versions of the two functions are equal.\nThis is true due to Quot.sound: the fact that they are in the quotient's equivalence relation is an assumption.\nThis proof is a much more explicit version of the one in the standard library:theorem funext'\n    {f g : (x : α) → β x}\n    (h : ∀ x, f x = g x) :\n    f = g := by\n  suffices extApp (Quot.mk _ f) = extApp (Quot.mk _ g) by\n    unfold extApp at this\n    dsimp at this\n    exact this\n  suffices Quot.mk extEq f = Quot.mk extEq g by\n    apply congrArg\n    exact this\n  apply Quot.sound\n  exact h\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.6. Quotients and Function Extensionality","id":"/The-Type-System/Quotients/#quotient-funext"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Parallel-Elaboration":{"contents":"* #7084 enables the elaboration of theorem bodies, i.e. proofs, to\nhappen in parallel to each other as well as to other elaboration tasks.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Highlights","header":"Parallel Elaboration","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Parallel-Elaboration"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Other":{"contents":"* #10383 includes some improvements to the release process, making the\nupdating of stable branches more robust, and including cslib in the\nrelease checklist.* #10389 fixes a bug where string literal parsing ignored its trailing\nwhitespace setting.* #10460 introduces a simple script that adjusts module headers in a\npackage for use of the module system, without further minimizing import\nor annotation use.* #10476 fixes the dead let elimination code in the kernel's\ninfer_let function.* #10575 adds the necessary infrastructure for recording elaboration\ndependencies that may not be apparent from the resulting environment\nsuch as notations and other metaprograms. An adapted version of shake\nfrom Mathlib is added to script/ but may be moved to another location\nor repo in the future.* #10777 improves the scripts assisting with cutting Lean releases (by\nreporting CI status of open PRs, and adding documentation), and adds a\n.claude/commands/release.md prompt file so Claude can assist.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Other","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Other"}});