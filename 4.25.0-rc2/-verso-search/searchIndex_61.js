window.docContents[61].resolve({"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values","header":"19.12.2. API Reference","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Reasoning":{"contents":"An optional arbitrary element of a given type.If α is non-empty, then there exists some v : α and this arbitrary element is some v.\nOtherwise, it is none.\n\nGiven an optional value and a function that can be applied when the value is some, returns the\nresult of applying the function if this is possible.The function f is partial because it is only defined for the values a : α such that\no = some a. This restriction allows the function to use the fact that it can only be called when\no is not none: it can relate its argument to the optional value o. Its runtime behavior is\nequivalent to that of Option.bind.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pbind fun x h => some ⟨x, h⟩\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\nGiven an optional value and a function that can be applied when the value is some, returns the\nresult of applying the function if this is possible, or a fallback value otherwise.The function f is partial because it is only defined for the values a : α such that\no = some a. This restriction allows the function to use the fact that it can only be called when\no is not none: it can relate its argument to the optional value o. Its runtime behavior is\nequivalent to that of Option.elim.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pelim none fun x h => some ⟨x, h⟩\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\nGiven a function from the elements of α that satisfy p to β and a proof that an optional value\nsatisfies p if it's present, applies the function to the value.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pmap (fun a (h : a ∈ v) => ⟨_, h⟩) (fun _ h => h)\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.7. Reasoning","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Reasoning"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Adjustment":{"contents":"Returns the position in a string before a specified position, p. If p = ⟨0⟩, returns 0. If p\nis greater than endPos, returns the position one byte before p. Otherwise, if p occurs in the\nmiddle of a multi-byte character, returns the beginning position of that character.For example, \"L∃∀N\".prev ⟨3⟩ is ⟨1⟩, since byte 3 occurs in the middle of the multi-byte\ncharacter '∃' that starts at byte 1.This is a legacy function. The recommended alternative is String.ValidPos.prev or one of its\nvariants like String.ValidPos.prev?, combined with String.pos or another means of obtaining\na String.ValidPos.Examples:* \"abc\".get (\"abc\".endPos |> \"abc\".prev) = 'c'* \"L∃∀N\".get (\"L∃∀N\".endPos |> \"L∃∀N\".prev |> \"L∃∀N\".prev |> \"L∃∀N\".prev) = '∃'\n\nReturns the next position in a string after position p. If p is not a valid position or\np = s.endPos, returns the position one byte after p.A run-time bounds check is performed to determine whether p is at the end of the string. If a\nbounds check has already been performed, use String.next' to avoid a repeated check.This is a legacy function. The recommended alternative is String.ValidPos.next or one of its\nvariants like String.ValidPos.next?, combined with String.pos or another means of obtaining\na String.ValisPos.Some examples of edge cases:* \"abc\".next ⟨3⟩ = ⟨4⟩, since 3 = \"abc\".endPos* \"L∃∀N\".next ⟨2⟩ = ⟨3⟩, since 2 points into the middle of a multi-byte UTF-8 characterExamples:* \"abc\".get (\"abc\".next 0) = 'b'* \"L∃∀N\".get (0 |> \"L∃∀N\".next |> \"L∃∀N\".next) = '∀'\n\nReturns the next position in a string after position p. The result is unspecified if p is not a\nvalid position.Requires evidence, h, that p is within bounds. No run-time bounds check is performed, as in\nString.next.A typical pattern combines String.next' with a dependent if-expression to avoid the overhead of\nan additional bounds check. For example:def next? (s : String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else s.get (s.next' p h)\nThis is a legacy function. The recommended alternative is String.ValidPos.next, combined with\nString.pos or another means of obtaining a String.ValidPos.Example:* let abc := \"abc\"; abc.get (abc.next' 0 (by decide)) = 'b'\n\nRepeatedly increments a position in a string, as if by String.next, while the predicate p\nreturns false for the character at the position. Stops incrementing at the end of the string or\nwhen p returns true for the current character.Examples:* let s := \"   a  \"; s.get (s.nextUntil Char.isWhitespace 0) = ' '* let s := \"   a  \"; s.get (s.nextUntil Char.isLetter 0) = 'a'* let s := \"a  \"; s.get (s.nextUntil Char.isWhitespace 0) = ' '\n\nRepeatedly increments a position in a string, as if by String.next, while the predicate p\nreturns true for the character at the position. Stops incrementing at the end of the string or\nwhen p returns false for the current character.Examples:* let s := \"   a  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'a'* let s := \"a  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'a'* let s := \"ba  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'b'\n\nIncreases the byte offset of the position by 1. Not to be confused with ValidPos.next.\n\nAdvances p by n bytes. This is not an HAdd instance because it should be a relatively\nrare operation, so we use a name to make accidental use less likely. To add the size of a\ncharacter c or string s to a raw position p, you can use p + c resp. p + s.This should be seen as an \"advance\" or \"skip\".See also Pos.Raw.offsetBy, which turns relative positions into absolute positions.\n\nOffsets p by offset on the left. This is not an HAdd instance because it should be a\nrelatively rare operation, so we use a name to make accidental use less likely. To offset a position\nby the size of a character character c or string s, you can use c + p resp. s + p.This should be seen as an operation that converts relative positions into absolute positions.See also Pos.Raw.increaseBy, which is an \"advancing\" operation.\n\nDecreases the byte offset of the position by 1. Not to be confused with ValidPos.prev.\n\nMove the position p back by n bytes. This is not an HSub instance because it should be a\nrelatively rare operation, so we use a name to make accidental use less likely. To remove the size\nof a character c or string s from a raw position p, you can use p - c resp. p - s.This should be seen as the inverse of an \"advance\" or \"skip\".See also Pos.Raw.unoffsetBy, which turns absolute positions into relative positions.\n\nDecreases p by offset. This is not an HSub instance because it should be a relatively\nrare operation, so we use a name to make accidental use less likely. To unoffset a position\nby the size of a character c or string s, you can use p - c resp. p - s.This should be seen as an operation that converts absolute positions into relative positions.See also Pos.Raw.decreaseBy, which is an \"unadvancing\" operation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"19.8.4.5.4. Adjustment","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Adjustment"},"/IO/Timing/#io-timing":{"contents":"Pauses execution for the specified number of milliseconds.\n\nMonotonically increasing time since an unspecified past point in nanoseconds. There is no relation\nto wall clock time.\n\nMonotonically increasing time since an unspecified past point in milliseconds. There is no relation\nto wall clock time.\n\nReturns the number of heartbeats that have occurred during the current thread's execution. The\nheartbeat count is the number of “small” memory allocations performed in a thread.Heartbeats used to implement timeouts that are more deterministic across different hardware.\n\nAdjusts the heartbeat counter of the current thread by the given amount. This can be useful to give\nallocation-avoiding code additional “weight” and is also used to adjust the counter after resuming\nfrom a snapshot.Heartbeats are a means of implementing “deterministic” timeouts. The heartbeat counter is the number\nof “small” memory allocations performed on the current execution thread.\n\n","context":"Lean Reference\u0009IO","header":"15.8. Timing","id":"/IO/Timing/#io-timing"},"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Lists-and-Arrays":{"contents":"List and array literals contain comma-separated sequences of elements inside of brackets, with arrays prefixed by a hash mark (#).\nArray literals are interpreted as list literals wrapped in a call to a conversion.\nFor performance reasons, very large list and array literals are converted to sequences of local definitions, rather than just iterated applications of the list constructor.\n\nList Literals\n\nArray Literals\n\nLong List LiteralsThis list contains 32 elements.\nThe generated code is an iterated application of List.cons:#check\n  [1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1]\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] : List Nat\nWith 33 elements, the list literal becomes a sequence of local definitions:#check\n  [1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1]\nlet y :=\n  let y :=\n    let y := [1, 1, 1, 1, 1];\n    1 :: 1 :: 1 :: 1 :: y;\n  let y := 1 :: 1 :: 1 :: 1 :: y;\n  1 :: 1 :: 1 :: 1 :: y;\nlet y :=\n  let y := 1 :: 1 :: 1 :: 1 :: y;\n  1 :: 1 :: 1 :: 1 :: y;\nlet y := 1 :: 1 :: 1 :: 1 :: y;\n1 :: 1 :: 1 :: 1 :: y : List Nat\n\n\n","context":"Lean Reference\u0009Terms\u0009Numeric Literals","header":"10.5.4. Lists and Arrays","id":"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Lists-and-Arrays"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--New-math-project-template":{"contents":"#8866 upgrades the math template for lake init and\nlake new to meet rigorous Mathlib maintenance standards.\nIn comparison with the previous version (now available as lake new ... math-lax), the new template automatically provides:\n\n* Strict linting options matching Mathlib.* GitHub workflow for automatic upgrades to newer Lean and Mathlib releases.* Automatic release tagging for toolchain upgrades.* API documentation generated by doc-gen4 and hosted on github.io.* README with some GitHub-specific instructions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"New math project template","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--New-math-project-template"}});