window.docContents[159].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Ranges":{"contents":"The smallest number that ISize can represent: -2^(System.Platform.numBits - 1).\n\nThe largest number that ISize can represent: 2^(System.Platform.numBits - 1) - 1.\n\nThe smallest number that Int8 can represent: -2^7 = -128.\n\nThe largest number that Int8 can represent: 2^7 - 1 = 127.\n\nThe smallest number that Int16 can represent: -2^15 = -32768.\n\nThe largest number that Int16 can represent: 2^15 - 1 = 32767.\n\nThe smallest number that Int32 can represent: -2^31 = -2147483648.\n\nThe largest number that Int32 can represent: 2^31 - 1 = 2147483647.\n\nThe smallest number that Int64 can represent: -2^63 = -9223372036854775808.\n\nThe largest number that Int64 can represent: 2^63 - 1 = 9223372036854775807.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"19.4.4.2. Ranges","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Ranges"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Properties":{"contents":"The number of mappings present in the hash map\n\nReturns true if the hash map contains no mappings.Note that if your BEq instance is not reflexive or your Hashable instance is not\nlawful, then it is possible that this function returns false even though is not possible\nto get anything out of the hash map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Dependent Hash Maps","header":"19.18.5.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Properties"},"/Basic-Types/Natural-Numbers/#nat-api-comparison-bool":{"contents":"Boolean equality of natural numbers, usually accessed via the == operator.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nThe Boolean less-than-or-equal-to comparison on natural numbers.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.Examples:* Nat.ble 2 5 = true* Nat.ble 5 2 = false* Nat.ble 5 5 = true\n\nThe Boolean less-than comparison on natural numbers.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.Examples:* Nat.blt 2 5 = true* Nat.blt 5 2 = false* Nat.blt 5 5 = false\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Comparisons","header":"19.1.4.5.1. Boolean Comparisons","id":"/Basic-Types/Natural-Numbers/#nat-api-comparison-bool"},"/Coercions/Coercing-Between-Types/#ordinary-coercion":{"contents":"Coercions between types are inserted when the Lean elaborator successfully constructs a term, inferring its type, in a context where a term of some other type was expected.\nBefore signaling an error, the elaborator attempts to insert a coercion from the inferred type to the expected type by synthesizing an instance of CoeT.\nThere are two ways that this might succeed:1. There could be a chain of coercions from the inferred type to the expected type through a number of intermediate types.\n    These chained coercions are selected based on the inferred type and the expected type, but not the term being coerced.2. There could be a single dependent coercion from the inferred type to the expected type.\n    Dependent coercions take the term being coerced into account as well as the inferred and expected types, but they cannot be chained.\n\nThe simplest way to define a non-dependent coercion is by implementing a Coe instance, which is enough to synthesize a CoeT instance.\nThis instance participates in chaining, and may be applied any number of times.\nThe expected type of the expression is used to drive synthesis of Coe instances, rather than the inferred type.\nFor instances that can be used at most once, or instances in which the inferred type should drive synthesis, one of the other coercion classes may be needed.\n\nDefining CoercionsThe type Even represents the even natural numbers.structure Even where\n  number : Nat\n  isEven : number % 2 = 0\nA coercion allows even numbers to be used where natural numbers are expected.\nThe coe attribute marks the projection as a coercion so that it can be shown accordingly in proof states and error messages, as described in the section on implementing coercions.attribute [coe] Even.number\n\ninstance : Coe Even Nat where\n  coe := Even.number\nWith this coercion in place, even numbers can be used where natural numbers are expected.def four : Even := ⟨4, by omega⟩\n\n#eval (four : Nat) + 1\n5\nDue to coercion chaining, there is also a coercion from Even to Int formed by chaining the Coe Even Nat instance with the existing coercion from Nat to Int:#eval (four : Int) - 5\n-1\n\n\nDependent coercions are needed when the specific term being coerced is required in order to determine whether or how to coerce the term: for example, only decidable propositions can be coerced to Bool, so the proposition in question must occur as part of the instance's type so that it can require the Decidable instance.\nNon-dependent coercions are used whenever all values of the inferred type can be coerced to the target type.\n\nDefining Dependent CoercionsThe string \"four\" can be coerced into the natural number 4 with this instance declaration:instance : CoeDep String \"four\" Nat where\n  coe := 4\n\n#eval (\"four\" : Nat)\n4\nOrdinary type errors are produced for other strings:#eval (\"three\" : Nat)\nType mismatch\n  \"three\"\nhas type\n  String\nbut is expected to have type\n  Nat\n\n\n\n\nNon-dependent coercions may be chained: if there is a coercion from α to β and from β to γ, then there is also a coercion from α to γ.\n\nThe chain should be in the form CoeHead?CoeOut*Coe*CoeTail?, which is to say it may consist of:* An optional instance of CoeHead α α', followed by* Zero or more instances of CoeOut α' …, …, CoeOut … α'', followed by* Zero or more instances of Coe α'' …, …, Coe … β', followed by* An optional instance of CoeTail β' γMost coercions can be implemented as instances of Coe.\nCoeHead, CoeOut, and CoeTail are needed in certain special situations.\n\nCoeHead and CoeOut instances are chained from the inferred type towards the expected type.\nIn other words, information in the type found for the term is used to resolve a chain of instances.\nCoe and CoeTail instances are chained from the expected type towards the inferred type, so information in the expected type is used to resolve a chain of instances.\nIf these chains meet in the middle, a coercion has been found.\nThis is reflected in their type signatures: CoeHead and CoeOut use semi-output parameters for the coercion's target, while Coe and CoeTail use semi-output parameters for the coercions' source.\n\nWhen an instance provides a value for a semi-output parameter, the value is used during instance synthesis.\nHowever, if no value is provided, then a value may be assigned by the synthesis algorithm.\nConsequently, every semi-output parameter should be assigned a type when an instance is selected.\nThis means that CoeOut should be used when the variables that occur in the coercion's output are a subset of those in its input, and Coe should be used when the variables in the input are a subset of those in the output.\n\nCoeOut vs Coe instancesA Truthy value is a value paired with an indication of whether it should be considered to be true or false.\nA Decision is either yes, no, or maybe, with the latter containing further data for consideration.structure Truthy (α : Type) where\n  val : α\n  isTrue : Bool\n\ninductive Decision (α : Type) where\n  | yes\n  | maybe (val : α)\n  | no\n“Truthy” values can be converted to Bools by forgetting the contained value.\nBools can be converted to Decisions by discounting the maybe case.@[coe]\ndef Truthy.toBool : Truthy α → Bool :=\n  Truthy.isTrue\n\n@[coe]\ndef Decision.ofBool : Bool → Decision α\n  | true => .yes\n  | false => .no\nTruthy.toBool must be a CoeOut instance, because the target of the coercion contains fewer unknown type variables than the source, while Decision.ofBool must be a Coe instance, because the source of the coercion contains fewer variables than the target:instance : CoeOut (Truthy α) Bool := ⟨Truthy.isTrue⟩\n\ninstance : Coe Bool (Decision α) := ⟨Decision.ofBool⟩\nWith these instances, coercion chaining works:#eval ({ val := 1, isTrue := true : Truthy Nat } : Decision String)\nDecision.yes\nAttempting to use the wrong class leads to an error:instance : Coe (Truthy α) Bool := ⟨Truthy.isTrue⟩\ninstance does not provide concrete values for (semi-)out-params\n  Coe (Truthy ?α) Bool\n\n\n\n\nCoeHead α β is for coercions that are applied from left-to-right at most once\nat beginning of the coercion chain.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nCoeOut α β is for coercions that are applied from left-to-right.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nCoeTail α β is for coercions that can only appear at the end of a\nsequence of coercions. That is, α can be further coerced via Coe σ α and\nCoeHead τ σ instances but β will only be the expected type of the expression.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nInstances of CoeT can be synthesized when an appropriate chain of instances exists, or when there is a single applicable CoeDep instance.When coercing from Nat to another type, a NatCast instances also suffices.\nIf both exist, then the CoeDep instance takes priority.\n\nCoeT is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation ↑x or by double type\nascription ((x : α) : β).A CoeT chain has the grammar CoeHead? CoeOut* Coe* CoeTail? | CoeDep.The resulting value of type β. The input x : α is a parameter to\nthe type class, so the value of type β may possibly depend on additional\ntypeclasses on x.\n\n\n\nDependent coercions may not be chained.\nAs an alternative to a chain of coercions, a term e of type α can be coerced to β using an instance of CoeDep α e β.\nDependent coercions are useful in situations where only some of the values can be coerced; this mechanism is used to coerce only decidable propositions to Bool.\nThey are also useful when the value itself occurs in the coercion's target type.\n\n\n\nCoeDep α (x : α) β is a typeclass for dependent coercions, that is, the type β\ncan depend on x (or rather, the value of x is available to typeclass search\nso an instance that relates β to x is allowed).Dependent coercions do not participate in the transitive chaining process of\nregular coercions: they must exactly match the type mismatch on both sides.The resulting value of type β. The input x : α is a parameter to\nthe type class, so the value of type β may possibly depend on additional\ntypeclasses on x.\n\nDependent CoercionA type of non-empty lists can be defined as a pair of a list and a proof that it is not empty.\nThis type can be coerced to ordinary lists by applying the projection:structure NonEmptyList (α : Type u) : Type u where\n  contents : List α\n  non_empty : contents ≠ []\n\ninstance : Coe (NonEmptyList α) (List α) where\n  coe xs := xs.contents\nThe coercion works as expected:def oneTwoThree : NonEmptyList Nat := ⟨[1, 2, 3], by simp⟩\n\n#eval (oneTwoThree : List Nat) ++ [4]\nArbitrary lists cannot, however, be coerced to non-empty lists, because some arbitrarily-chosen lists may indeed be empty:instance : Coe (List α) (NonEmptyList α) where\n  coe xs := ⟨xs, _⟩\ndon't know how to synthesize placeholder for argument `non_empty`\ncontext:\nα : Type u_1\nxs : List α\n⊢ xs ≠ []\nA dependent coercion can restrict the domain of the coercion to only lists that are not empty:instance : CoeDep (List α) (x :: xs) (NonEmptyList α) where\n  coe := ⟨x :: xs, by simp⟩\n\n#eval ([1, 2, 3] : NonEmptyList Nat)\n{ contents := [1, 2, 3], non_empty := _ }\nDependent coercion insertion requires that the term to be coerced syntactically matches the term in the instance header.\nLists that are known to be non-empty, but which are not syntactically instances of (· :: ·), cannot be coerced with this instance.#check\n  fun (xs : List Nat) =>\n    let ys : List Nat := xs ++ [4]\n    (ys : NonEmptyList Nat)\nWhen coercion insertion fails, the original type error is reported:Type mismatch\n  ys\nhas type\n  List Nat\nbut is expected to have type\n  NonEmptyList Nat\n\n\nCoercionsCoercions can be explicitly placed using the prefix operator ↑.\n\nUnlike using nested type ascriptions, the ↑ syntax for placing coercions does not require the involved types to be written explicitly.\n\nControlling Coercion InsertionInstance synthesis and coercion insertion interact with one another.\nSynthesizing an instance may make type information known that later triggers coercion insertion.\nThe specific placement of coercions may matter.In this definition of sub, the Sub Int instance is synthesized based on the function's return type.\nThis instance requires that the two parameters also be Ints, but they are Nats.\nCoercions are inserted around each argument to the subtraction operator.\nThis can be seen in the output of #print.def sub (n k : Nat) : Int := n - k\n\n#print sub\ndef sub : Nat → Nat → Int :=\nfun n k => ↑n - ↑k\nPlacing the coercion operator outside the subtraction causes the elaborator to attempt to infer a type for the subtraction and then insert a coercion.\nBecause the arguments are both Nats, the Sub Nat instance is selected, leading to the difference being a Nat.\nThe difference is then coerced to an Int.def sub' (n k : Nat) : Int := ↑ (n - k)\n\n#print sub'\nThese two functions are not equivalent because subtraction of natural numbers truncates at zero:#eval sub 4 8\n-4\n#eval sub' 4 8\n0\n\n\n\n\n\n\n","context":"Lean Reference\u0009Coercions","header":"12.2. Coercing Between Types","id":"/Coercions/Coercing-Between-Types/#ordinary-coercion"},"/Definitions/Recursive-Definitions/#elab-as-course-of-values":{"contents":"In this section, the construction used to elaborate structurally recursive functions is explained in more detail.\nThis elaboration uses the below and brecOn constructions that are automatically generated from inductive types' recursors.\n\nRecursion vs RecursorsAddition of natural numbers can be defined via recursion on the second argument.\nThis function is straightforwardly structurally recursive.def add (n : Nat) : Nat → Nat\n  | .zero => n\n  | .succ k => .succ (add n k)\nDefined using Nat.rec, it is much further from the notations that most people are used to.def add' (n : Nat) :=\n  Nat.rec (motive := fun _ => Nat)\n    n\n    (fun k soFar => .succ soFar)\nStructural recursive calls made on data that isn't the immediate child of the function parameter requires either creativity or a complex yet systematic encoding.def half : Nat → Nat\n  | 0 | 1 => 0\n  | n + 2 => half n + 1\nOne way to think about this function is as a structural recursion that flips a bit at each call, only incrementing the result when the bit is set.def helper : Nat → Bool → Nat :=\n  Nat.rec (motive := fun _ => Bool → Nat)\n    (fun _ => 0)\n    (fun _ soFar =>\n      fun b =>\n        (if b then Nat.succ else id) (soFar !b))\n\ndef half' (n : Nat) : Nat := helper n false\n#eval [0, 1, 2, 3, 4, 5, 6, 7, 8].map half'\n[0, 0, 1, 1, 2, 2, 3, 3, 4]\nInstead of creativity, a general technique called course-of-values recursion can be used.\nCourse-of-values recursion uses helpers that can be systematically derived for every inductive type, defined in terms of the recursor; Lean derives them automatically.\nFor every Nat n, the type n.below (motive := mot) provides a value of type mot k for all k < n, represented as an iterated  dependent pair type.\nThe course-of-values recursor Nat.brecOn allows a function to use the result for any smaller Nat.\nUsing it to define the function is inconvenient:noncomputable def half'' (n : Nat) : Nat :=\n  Nat.brecOn n (motive := fun _ => Nat)\n    fun k soFar =>\n      match k, soFar with\n      | 0, _ | 1, _ => 0\n      | _ + 2, ⟨_, ⟨h, _⟩⟩ => h + 1\nThe function is marked noncomputable because the compiler doesn't support generating code for course-of-values recursion, which is intended for reasoning rather that efficient code.\nThe kernel can still be used to test the function, however:#reduce [0,1,2,3,4,5,6,7,8].map half''\n[0, 0, 1, 1, 2, 2, 3, 3, 4]\nThe dependent pattern matching in the body of half'' can also be encoded using recursors (specifically, Nat.casesOn), if necessary:noncomputable def half''' (n : Nat) : Nat :=\n  n.brecOn (motive := fun _ => Nat)\n    fun k =>\n      k.casesOn\n        (motive :=\n          fun k' =>\n            (k'.below (motive := fun _ => Nat)) →\n            Nat)\n        (fun _ => 0)\n        (fun k' =>\n          k'.casesOn\n            (motive :=\n              fun k'' =>\n                (k''.succ.below (motive := fun _ => Nat)) →\n                Nat)\n            (fun _ => 0)\n            (fun _ soFar => soFar.2.1.succ))\nThis definition still works.#reduce [0,1,2,3,4,5,6,7,8].map half''\n[0, 0, 1, 1, 2, 2, 3, 3, 4]\nHowever, it is now far from the original definition and it has become difficult for most people to understand.\nRecursors are an excellent logical foundation, but not an easy way to write programs or proofs.\n\nThe structural recursion analysis attempts to translate the recursive pre-definition into a use of the appropriate structural recursion constructions.\nAt this step, pattern matching has already been translated into the use of matcher functions; these are treated specially by the termination checker.\nNext, for each group of parameters, a translation using brecOn is attempted.\n\nCourse-of-Values TablesThis definition is equivalent to List.below:def List.below' {α : Type u} {motive : List α → Sort u} :\n    List α → Sort (max (u + 1) u)\n  | [] => PUnit\n  | _ :: xs => motive xs ×' xs.below' (motive := motive)\nIn other words, for a given motive, List.below' is a type that contains a realization of the motive for all suffixes of the list.More recursive arguments require further nested iterations of the product type.\nFor instance, binary trees have two recursive occurrences.inductive Tree (α : Type u) : Type u where\n  | leaf\n  | branch (left : Tree α) (val : α) (right : Tree α)\nIts corresponding course-of-values table contains the realizations of the motive for all subtrees:def Tree.below' {α : Type u} {motive : Tree α → Sort u} :\n    Tree α → Sort (max (u + 1) u)\n  | .leaf => PUnit\n  | .branch left _val right =>\n    (motive left ×' left.below' (motive := motive)) ×'\n    (motive right ×' right.below' (motive := motive))\nFor both lists and trees, the brecOn operator expects just a single case, rather than one per constructor.\nThis case accepts a list or tree along with a table of results for all smaller values; from this, it should satisfy the motive for the provided value.\nDependent case analysis of the provided value automatically refines the type of the memo table, providing everything needed.The following definitions are equivalent to List.brecOn and Tree.brecOn, respectively.\nThe primitive recursive helpers List.brecOnTable  and Tree.brecOnTable compute the course-of-values tables along with the final results, and the actual definitions of the brecOn operators simply project out the result.def List.brecOnTable {α : Type u}\n    {motive : List α → Sort u}\n    (xs : List α)\n    (step :\n      (ys : List α) →\n      ys.below' (motive := motive) →\n      motive ys) :\n    motive xs ×' xs.below' (motive := motive) :=\n  match xs with\n  | [] => ⟨step [] PUnit.unit, PUnit.unit⟩\n  | x :: xs =>\n    let res := xs.brecOnTable (motive := motive) step\n    let val := step (x :: xs) res\n    ⟨val, res⟩\ndef Tree.brecOnTable {α : Type u}\n    {motive : Tree α → Sort u}\n    (t : Tree α)\n    (step :\n      (ys : Tree α) →\n      ys.below' (motive := motive) →\n      motive ys) :\n    motive t ×' t.below' (motive := motive) :=\n  match t with\n  | .leaf => ⟨step .leaf PUnit.unit, PUnit.unit⟩\n  | .branch left val right =>\n    let resLeft := left.brecOnTable (motive := motive) step\n    let resRight := right.brecOnTable (motive := motive) step\n    let branchRes := ⟨resLeft, resRight⟩\n    let val := step (.branch left val right) branchRes\n    ⟨val, branchRes⟩\ndef List.brecOn' {α : Type u}\n    {motive : List α → Sort u}\n    (xs : List α)\n    (step :\n      (ys : List α) →\n      ys.below' (motive := motive) →\n      motive ys) :\n    motive xs :=\n  (xs.brecOnTable (motive := motive) step).1\ndef Tree.brecOn' {α : Type u}\n    {motive : Tree α → Sort u}\n    (t : Tree α)\n    (step :\n      (ys : Tree α) →\n      ys.below' (motive := motive) →\n      motive ys) :\n    motive t :=\n  (t.brecOnTable (motive := motive) step).1\n\n\nThe below construction is a mapping from each value of a type to the results of some function call on all smaller values; it can be understood as a memoization table that already contains the results for all smaller values.\nThe notion of “smaller value” that is expressed in the below construction corresponds directly to the definition of strict sub-terms.\n\nRecursors expect an argument for each of the inductive type's constructors; these arguments are called with the constructor's arguments (and the result of recursion on recursive parameters) during ι-reduction.\nThe course-of-values recursion operator brecOn, on the other hand, expects just a single case that covers all constructors at once.\nThis case is provided with a value and a below table that contains the results of recursion on all values smaller than the given value; it should use the contents of the table to satisfy the motive for the provided value.\nIf the function is structurally recursive over a given parameter (or parameter group), then the results of all recursive calls will be present in this table already.\n\nWhen the body of the recursive function is transformed into an invocation of brecOn on one of the function's parameters, the parameter and its course-of-values table are in scope.\nThe analysis traverses the body of the function, looking for recursive calls.\nIf the parameter is matched against, then its occurrences in the local context are generalized and then instantiated with the pattern; this is also true for the type of the course-of-values table.\nTypically, this pattern matching results in the type of the course-of-values table becoming more specific, which gives access to the recursive results for smaller values.\nThis generalization process implements the rule that patterns are sub-terms of match discriminants.\nWhen an recursive occurrence of the function is detected, the course-of-values table is consulted to see whether it contains a result for the argument being checked.\nIf so, the recursive call can be replaced with a projection from the table.\nIf not, then the parameter in question doesn't support structural recursion.\n\n\n\nElaboration WalkthroughThe first step in walking through the elaboration of half is to manually desugar it to a simpler form.\nThis doesn't match the way Lean works, but its output is much easier to read when there are fewer OfNat instances present.\nThis readable definition:def half : Nat → Nat\n  | 0 | 1 => 0\n  | n + 2 => half n + 1\ncan be rewritten to this somewhat lower-level version:def half : Nat → Nat\n  | .zero | .succ .zero => .zero\n  | .succ (.succ n) => half n |>.succ\nThe elaborator begins by elaborating a pre-definition in which recursion is still present but the definition is otherwise in Lean's core type theory.\nTurning on the compiler's tracing of pre-definitions, as well as making the pretty printer more explicit, makes the resulting pre-definition visible:set_option trace.Elab.definition.body true in\nset_option pp.all true in\n\ndef half : Nat → Nat\n  | .zero | .succ .zero => .zero\n  | .succ (.succ n) => half n |>.succ\nThe returned trace message is:[Elab.definition.body] half : Nat → Nat :=\n    fun (x : Nat) =>\n      half.match_1.{1} (fun (x : Nat) => Nat) x\n        (fun (_ : Unit) => Nat.zero)\n        (fun (_ : Unit) => Nat.zero)\n        fun (n : Nat) => Nat.succ (half n)\nThe auxiliary match function's definition is:#print half.match_1\ndef half.match_1.{u_1} :\n    (motive : Nat → Sort u_1) → (x : Nat) →\n    (Unit → motive Nat.zero) → (Unit → motive 1) →\n    ((n : Nat) → motive n.succ.succ) →\n    motive x :=\n  fun motive x h_1 h_2 h_3 =>\n    Nat.casesOn x (h_1 ()) fun n =>\n      Nat.casesOn n (h_2 ()) fun n =>\n        h_3 n\nFormatted more readably, this definition is:def half.match_1'.{u} :\n    (motive : Nat → Sort u) → (x : Nat) →\n    (Unit → motive Nat.zero) → (Unit → motive 1) →\n    ((n : Nat) → motive n.succ.succ) →\n    motive x :=\n  fun motive x h_1 h_2 h_3 =>\n    Nat.casesOn x (h_1 ()) fun n =>\n      Nat.casesOn n (h_2 ()) fun n =>\n        h_3 n\nIn other words, the specific configuration of patterns used in half are captured in half.match_1.This definition is a more readable version of half's pre-definition:def half' : Nat → Nat :=\n  fun (x : Nat) =>\n    half.match_1 (motive := fun _ => Nat) x\n      (fun _ => 0) -- Case for 0\n      (fun _ => 0) -- Case for 1\n      (fun n => Nat.succ (half' n)) -- Case for n + 2\nTo elaborate it as a structurally recursive function, the first step is to establish the bRecOn invocation.\nThe definition must be marked noncomputable because Lean does not support code generation for recursors such as Nat.brecOn.noncomputable\ndef half'' : Nat → Nat :=\n  fun (x : Nat) =>\n    x.brecOn fun n table =>\n      _\n/- To translate:\n    half.match_1 (motive := fun _ => Nat) x\n      (fun _ => 0) -- Case for 0\n      (fun _ => 0) -- Case for 1\n      (fun n => Nat.succ (half' n)) -- Case for n + 2\n-/\nThe next step is to replace occurrences of x in the original function body with the n provided by brecOn.\nBecause table's type depends on x, it must also be generalized when splitting cases with half.match_1, leading to a motive with an extra parameter.noncomputable\ndef half'' : Nat → Nat :=\n  fun (x : Nat) =>\n    x.brecOn fun n table =>\n      (half.match_1\n        (motive :=\n          fun k =>\n            k.below (motive := fun _ => Nat) →\n            Nat)\n        n\n        _\n        _\n        _)\n      table\n/- To translate:\n      (fun _ => 0) -- Case for 0\n      (fun _ => 0) -- Case for 1\n      (fun n => Nat.succ (half' n)) -- Case for n + 2\n-/\nThe three cases' placeholders expect the following types:don't know how to synthesize placeholder for argument `h_1`\ncontext:\nx n : Nat\ntable : Nat.below n\n⊢ Unit → (fun k => Nat.below k → Nat) Nat.zero\ndon't know how to synthesize placeholder for argument `h_2`\ncontext:\nx n : Nat\ntable : Nat.below n\n⊢ Unit → (fun k => Nat.below k → Nat) 1\ndon't know how to synthesize placeholder for argument `h_3`\ncontext:\nx n : Nat\ntable : Nat.below n\n⊢ (n : Nat) → (fun k => Nat.below k → Nat) n.succ.succ\nThe first two cases in the pre-definition are constant functions, with no recursion to check:noncomputable\ndef half'' : Nat → Nat :=\n  fun (x : Nat) =>\n    x.brecOn fun n table =>\n      (half.match_1\n        (motive :=\n          fun k =>\n            k.below (motive := fun _ => Nat) →\n            Nat)\n        n\n        (fun () _ => .zero)\n        (fun () _ => .zero)\n        _)\n      table\n/- To translate:\n      (fun n => Nat.succ (half' n)) -- Case for n + 2\n-/\nThe final case contains a recursive call.\nIt should be translated into a lookup into the course-of-values table.\nA more readable representation of the last hole's type is:(n : Nat) →\nNat.below (motive := fun _ => Nat) n.succ.succ →\nNat\nwhich is equivalent to(n : Nat) →\nNat ×' (Nat ×' Nat.below (motive := fun _ => Nat) n) →\nNat\nThe first Nat in the course-of-values table is the result of recursion on n + 1, and the second is the result of recursion on n.\nThe recursive call can thus be replaced by a lookup, and the elaboration is successful:noncomputable\ndef half'' : Nat → Nat :=\n  fun (x : Nat) =>\n    x.brecOn fun n table =>\n      (half.match_1\n        (motive :=\n          fun k =>\n            k.below (motive := fun _ => Nat) →\n            Nat)\n        n\n        (fun () _ => .zero)\n        (fun () _ => .zero)\n        (fun _ table => Nat.succ table.2.1)\n      table\nThe actual elaborator keeps track of the relationship between the parameter being checked for structural recursion and the positions in the course-of-values tables by inserting sentinel types with fresh names into the motive.\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Structural Recursion","header":"7.6.2.4. Elaboration Using Course-of-Values Recursion","id":"/Definitions/Recursive-Definitions/#elab-as-course-of-values"},"/Functors___-Monads-and--do--Notation/Syntax/#closest-do-block":{"contents":"Many features of do-notation have an effect on the current do block.\nIn particular, early return aborts the current block, causing it to evaluate to the returned value, and mutable bindings can only be mutated in the block in which they are defined.\nUnderstanding these features requires a precise definition of what it means to be in the “same” block.\n\nEmpirically, this can be checked using the Lean language server.\nWhen the cursor is on a return statement, the corresponding do keyword is highlighted.\nAttempting to mutate a mutable binding outside of the same do block results in an error message.\n\nHighlighting do  \n\nThe rules are as follows:\n\n* Each item immediately nested under the do keyword that begins a block belongs to that block.* Each item immediately nested under the do keyword that is an item in a containing do block belongs to the outer block.* Items in the branches of an if, match, or unless item belong to the same do block as the control structure that contains them. The do keyword that is part of the syntax of unless does not introduce a new do block.* Items in the body of repeat, while, and for belong to the same do block as the loop  that contains them. The do keyword that is part of the syntax of while and for does not introduce a new do block.\n\n\n\nNested do and BranchesThe following example outputs 6 rather than 7:def test : StateM Nat Unit := do\n  set 5\n  if true then\n    set 6\n    do return\n  set 7\n  return\n\n#eval test.run 0\n((), 6)\nThis is because the return statement under the if belongs to the same do as its immediate parent, which itself belongs to the same do as the if.\nIf do blocks that occurred as items in other do blocks instead created new blocks, then the example would output 7.\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.6. Identifying  do  Blocks","id":"/Functors___-Monads-and--do--Notation/Syntax/#closest-do-block"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Exception-Monads-in-Continuation-Passing-Style":{"contents":"\n\nContinuation-passing-style exception monads represent potentially-failing computations as functions that take success and failure continuations, both of which return the same type, returning that type.\nThey must work for any return type.\nAn example of such a type is (β : Type u) → (α → β) → (ε → β) → β.\nExceptCpsT is a transformer that can be applied to any monad, so ExceptCpsT ε m α is actually defined as (β : Type u) → (α → m β) → (ε → m β) → m β.\nException monads in continuation passing style have different performance characteristics than Except-based state monads; for some applications, it may be worth benchmarking them.\n\n\n\nAdds exceptions of type ε to a monad m.Instead of using Except ε to model exceptions, this implementation uses continuation passing\nstyle. This has different performance characteristics from ExceptT ε.\n\nReturns the value of a computation, forgetting whether it was an exception or a success.This corresponds to early return.\n\nUse a monadic action that may throw an exception by providing explicit success and failure\ncontinuations.\n\nUse a monadic action that may throw an exception as an action that may return an exception's value.\n\nRun an action from the transformed monad in the exception monad.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Exceptions","header":"14.5.7.5. Exception Monads in Continuation Passing Style","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Exception-Monads-in-Continuation-Passing-Style"},"/Tactic-Proofs/Naming-Bound-Variables/#bound-variable-name-hints":{"contents":"When the simplifier or the rw tactic introduce new binding forms such as function parameters, they select a name for the bound variable based on the one in the statement of the rewrite rule being applied.\nThis name is made unique if necessary.\nIn some situations, such as preprocessing definitions for termination proofs that use well-founded recursion, the names that appear in termination proof obligations should be the corresponding names written in the original function definition.\n\nThe binderNameHint gadget can be used to indicate that a bound variable should be named according to the variables bound in some other term.\nBy convention, the term () is used to indicate that a name should not be taken from the original definition.\n\nThe expression binderNameHint v binder e defined to be e.If it is used on the right-hand side of an equation that is used for rewriting by rw or simp,\nand v is a local variable, and binder is an expression that (after beta-reduction) is a binder\n(fun w => … or ∀ w, …), then it will rename v to the name used in that binder, and remove\nthe binderNameHint.A typical use of this gadget would be as follows; the gadget ensures that after rewriting, the local\nvariable is still name, and not x:theorem all_eq_not_any_not (l : List α) (p : α → Bool) :\n    l.all p = !l.any fun x => binderNameHint x p (!p x) := sorry\n\nexample (names : List String) : names.all (fun name => \"Waldo\".isPrefixOf name) = true := by\n  rw [all_eq_not_any_not]\n  -- ⊢ (!names.any fun name => !\"Waldo\".isPrefixOf name) = true\nIf binder is not a binder, then the name of v attains a macro scope. This only matters when the\nresulting term is used in a non-hygienic way, e.g. in termination proofs for well-founded recursion.This gadget is supported by* simp, dsimp and rw in the right-hand-side of an equation* simp in the assumptions of congruence rulesIt is ineffective in other positions (hypotheses of rewrite rules) or when used by other tactics\n(e.g. apply).\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.7. Naming Bound Variables","id":"/Tactic-Proofs/Naming-Bound-Variables/#bound-variable-name-hints"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Server":{"contents":"* #6279 fixes a bug in structure instance field completion that caused\nit to not function correctly for bracketed structure instances written\nin Mathlib style.* #6408 fixes a regression where goals that don't exist were being\ndisplayed. The regression was triggered by #5835 and originally caused\nby #4926.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Server","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Server"}});