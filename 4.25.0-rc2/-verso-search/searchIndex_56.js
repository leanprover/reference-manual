window.docContents[56].resolve({"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Run-Time-Representation":{"contents":"Because Bool is an enum inductive type, it is represented by a single byte in compiled code.\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans","header":"19.11.1. Run-Time Representation","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Run-Time-Representation"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Low-Level-File-API":{"contents":"At the lowest level, files are explicitly opened using Handle.mk.\nWhen the last reference to the handle object is dropped, the file is closed.\nThere is no explicit way to close a file handle other than by ensuring that there are no references to it.\n\nA reference to an opened file.File handles wrap the underlying operating system's file descriptors. There is no explicit operation\nto close a file: when the last reference to a file handle is dropped, the file is closed\nautomatically.Handles have an associated read/write cursor that determines the where reads and writes occur in the\nfile.\n\nOpens the file at fn with the given mode.An exception is thrown if the file cannot be opened.\n\nWhether a file should be opened for reading, writing, creation and writing, or appending.At the operating system level, this translates to the mode of a file handle (i.e., a set of open\nflags and an fdopen mode).None of the modes represented by this datatype translate line endings (i.e. O_BINARY on Windows).\nFurthermore, they are not inherited across process creation (i.e. O_NOINHERIT on Windows and\nO_CLOEXEC elsewhere).Operating System Specifics:* Windows:\n_open,\n_fdopen* Linux: open, fdopenThe file should be opened for reading.The read/write cursor is positioned at the beginning of the file. It is an error if the file does\nnot exist.* open flags: O_RDONLY* fdopen mode: rThe file should be opened for writing.If the file already exists, it is truncated to zero length. Otherwise, a new file is created. The\nread/write cursor is positioned at the beginning of the file.* open flags: O_WRONLY | O_CREAT | O_TRUNC* fdopen mode: wA new file should be created for writing.It is an error if the file already exists. A new file is created, with the read/write cursor\npositioned at the start.* open flags: O_WRONLY | O_CREAT | O_TRUNC | O_EXCL* fdopen mode: wThe file should be opened for both reading and writing.It is an error if the file does not already exist. The read/write cursor is positioned at the\nstart of the file.* open flags: O_RDWR* fdopen mode: r+The file should be opened for writing.If the file does not already exist, it is created. If the file already exists, it is opened, and\nthe read/write cursor is positioned at the end of the file.* open flags: O_WRONLY | O_CREAT | O_APPEND* fdopen mode: a\n\nReads up to the given number of bytes from the handle. If the returned array is empty, an\nend-of-file marker (EOF) has been reached.Encountering an EOF does not close a handle. Subsequent reads may block and return more data.\n\nReads the entire remaining contents of the file handle as a UTF-8-encoded string. An exception is\nthrown if the contents are not valid UTF-8.The underlying file is not automatically closed, and subsequent reads from the handle may block\nand/or return data.\n\nReads the entire remaining contents of the file handle until an end-of-file marker (EOF) is\nencountered.The underlying file is not automatically closed upon encountering an EOF, and subsequent reads from\nthe handle may block and/or return data.\n\nReads the entire remaining contents of the file handle until an end-of-file marker (EOF) is\nencountered.The underlying file is not automatically closed upon encountering an EOF, and subsequent reads from\nthe handle may block and/or return data.\n\nReads UTF-8-encoded text up to and including the next line break from the handle. If the returned\nstring is empty, an end-of-file marker (EOF) has been reached.Encountering an EOF does not close a handle. Subsequent reads may block and return more data.\n\nWrites the provided bytes to the the handle.Writing to a handle is typically buffered, and may not immediately modify the file on disk. Use\nIO.FS.Handle.flush to write changes to buffers to the associated device.\n\nWrites the provided string to the file handle using the UTF-8 encoding.Writing to a handle is typically buffered, and may not immediately modify the file on disk. Use\nIO.FS.Handle.flush to write changes to buffers to the associated device.\n\nWrites the contents of the string to the handle, followed by a newline. Uses UTF-8.\n\nFlushes the output buffer associated with the handle, writing any unwritten data to the associated\noutput device.\n\nRewinds the read/write cursor to the beginning of the handle's file.\n\nTruncates the handle to its read/write cursor.This operation does not automatically flush output buffers, so the contents of the output device may\nnot reflect the change immediately. This does not usually lead to problems because the read/write\ncursor includes buffered writes. However, buffered writes followed by IO.FS.Handle.rewind, then\nIO.FS.Handle.truncate, and then closing the file may lead to a non-empty file. If unsure, call\nIO.FS.Handle.flush before truncating.\n\nReturns true if a handle refers to a Windows console or a Unix terminal.\n\nAcquires an exclusive or shared lock on the handle. Blocks to wait for the lock if necessary.Acquiring a exclusive lock while already possessing a shared lock will not reliably succeed: it\nworks on Unix-like systems but not on Windows.\n\nTries to acquire an exclusive or shared lock on the handle and returns true if successful. Will\nnot block if the lock cannot be acquired, but instead returns false.Acquiring a exclusive lock while already possessing a shared lock will not reliably succeed: it\nworks on Unix-like systems but not on Windows.\n\nReleases any previously-acquired lock on the handle. Succeeds even if no lock has been acquired.\n\nOne File, Multiple HandlesThis program has two handles to the same file.\nBecause file I/O may be buffered independently for each handle, Handle.flush should be called when the buffers need to be synchronized with the file's actual contents.\nHere, the two handles proceed in lock-step through the file, with one of them a single byte ahead of the other.\nThe first handle is used to count the number of occurrences of 'A', while the second is used to replace each 'A' with '!'.\nThe second handle is opened in readWrite mode rather than write mode because opening an existing file in write mode replaces it with an empty file.\nIn this case, the buffers don't need to be flushed during execution because modifications occur only to parts of the file that will not be read again, but the write handle should be flushed after the loop has completed.open IO.FS (Handle)\n\ndef main : IO Unit := do\n  IO.println s!\"Starting contents: '{(← IO.FS.readFile \"data\").trim}'\"\n\n  let h ← Handle.mk \"data\" .read\n  let h' ← Handle.mk \"data\" .readWrite\n  h'.rewind\n\n  let mut count := 0\n  let mut buf : ByteArray ← h.read 1\n  while ok : buf.size = 1 do\n    if Char.ofUInt8 buf[0] == 'A' then\n      count := count + 1\n      h'.write (ByteArray.empty.push '!'.toUInt8)\n    else\n      h'.write buf\n    buf ← h.read 1\n\n  h'.flush\n\n  IO.println s!\"Count: {count}\"\n  IO.println s!\"Contents: '{(← IO.FS.readFile \"data\").trim}'\"\nWhen run on this file:AABAABCDAB\nthe program outputs:Starting contents: 'AABAABCDAB'\nCount: 5\nContents: '!!B!!BCD!B'\nAfterwards, the file contains:!!B!!BCD!B\n\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.1. Low-Level File API","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Low-Level-File-API"},"/The-Simplifier/Simp-Normal-Forms/#simp-normal-forms":{"contents":"The default simp set contains all the theorems and simplification procedures marked with the simp attribute.\nThe simp normal form of an expression is the result of applying the default simp set via the simp tactic until no more rules can be applied.\nWhen an expression is in simp normal form, it is as reduced as possible according to the default simp set, often making it easier to work with in proofs.\n\nThe simp tactic does not guarantee confluence, which means that the simp normal form of an expression may depend on the order in which the elements of the default simp set are applied.\nThe order in which the rules are applied can be changed by assigning priorities when setting the simp attribute.\n\nWhen designing a Lean library, it's important to think about what the appropriate simp normal form for the various combinations of the library's operators is.\nThis can serve as a guide when selecting which rules the library should add to the default simp set.\nIn particular, the right-hand side of simp lemmas should be in simp normal form; this helps ensure that simplification terminates.\nAdditionally, each concept in the library should be expressed through one simp normal form, even if there are multiple equivalent ways to state it.\nIf a concept is stated in two different ways in different simp lemmas, then some desired simplifications may not occur because the simplifier does not connect them.\n\nEven though simplification doesn't need to be confluent, striving for confluence is helpful because it makes the library more predictable and tends to reveal missing or poorly chosen simp lemmas.\nThe default simp set is as much a part of a library's interface as the type signatures of the constants that it exports.\n\nLibraries should not add rules to the default simp set that don't mention at least one constant defined in the library.\nOtherwise, importing a library could change the behavior of simp for some unrelated library.\nIf a library relies on additional simplification rules for definitions or declarations from other libraries, please create a custom simp set and either instruct users to use it or provide a dedicated tactic.\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.4. Simp Normal Forms","id":"/The-Simplifier/Simp-Normal-Forms/#simp-normal-forms"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Highlights":{"contents":"Lean v4.18 release brings a number of exciting new features:\n\n* Inlay hints for auto implicitsThe Language Server now uses inlay hints to show which variables are brought into scope implicitly, and where. The hint\nreveals its type upon hover, and double-clicking the hint will insert the variable binding explicitly.See the description of #6768 for a screenshort.Note that this feature is only visible when set_option autoImplicit true, which is the default in plain Lean projects,\nbut not in mathlib* #6935 adds the tactic expose_names. It creates a new goal whose\nlocal context has been \"exposed\" so that every local declaration has a\nclear, accessible name. If no local declarations require renaming, the\noriginal goal is returned unchanged./--\ninfo: α : Sort u_1\na b : α\nh_1 : a = b\nh_2 : True\nh_3 : True ∨ False\nh : b = a\n⊢ b = a\n-/\n#guard_msgs (info) in\nexample (a b : α) (h : a = b) (_ : True) (_ : True ∨ False) (h : b = a) : b = a := by\n  expose_names\n  trace_state\n  rw [h]\nThis tactic intended for use in auto-generated tactic suggestions, and can also be useful\nduring proof exploration. It is still best practice to name variables where they are\nbrought into scope (intro, case etc.), and not use expose_names in a finished,\npolished proof.* #7069 adds the fun_induction and fun_cases tactics, which add\nconvenience around using functional induction and functional cases\nprinciples.fun_induction foo  x y z\nelaborates foo x y z, then looks up foo.induct, and then essentially doesinduction z using foo.induct y\nincluding and in particular figuring out which arguments are parameters,\ntargets or dropped. This only works for non-mutual functions so far.Likewise there is the fun_cases tactic using foo.fun_cases.* #6744 extend the preprocessing of well-founded recursive definitions\nto bring assumptions like h✝ : x ∈ xs, if a recursive call is in the\nargument of a higher-order function like List.map, into scope automatically.\nIn many cases this removes the need to use functions like List.attach.This feature can be disabled with set_option wf.preprocess false.* #6634 adds support for changing the binder annotations of existing\nvariables to and from strict-implicit and instance-implicit using the\nvariable command.* #7100 modifies the structure syntax so that parents can be named,\nlike instructure S extends toParent : P\nBreaking change: The syntax is also modified so that the resultant\ntype comes before the extends clause, for example structure S : Prop extends P. This is necessary to prevent a parsing ambiguity, but\nalso this is the natural place for the resultant type. Implements RFC\n#7099.* #7103 gives the induction tactic the ability to name hypotheses to\nuse when generalizing targets, just like in cases. For example,\ninduction h : xs.length leads to goals with hypotheses h : xs.length = 0 and h : xs.length = n + 1. Target handling is also slightly\nmodified for multi-target induction principles: it used to be that if\nany target was not a free variable, all of the targets would be\ngeneralized (thus causing free variables to lose their connection to the\nlocal hypotheses they appear in); now only the non-free-variable targets\nare generalized.* #6869 adds a recommended_spelling command, which can be used for\nrecording the recommended spelling of a notation (for example, that the\nrecommended spelling of ∧ in identifiers is and). This information\nis then appended to the relevant docstrings for easy lookup.* #6893 adds support for plugins to the frontend and server.* #7061 provides a basic API for a premise selection tool, which can be\nprovided in downstream libraries. It does not implement premise\nselection itself!\n\nAnd many more! Check out the Language section below.\n\nNotably, a line of work has been carried out on the following\n(see the corresponding subsections in the Language section for the details):\n\n* the try? tactic, which has been re-implemented using evalAndSuggest tactic.\ntry? now supports referencing inaccessible local names and can provide\nmore complex suggestions, involving exact? and fun_induction tactics.\nNew configuration options have been added: -only, +missing, and max:=<num>,\nas well as merge.* bv_decide tactic. There are new features in preprocessing, added support\nfor enum inductives, IntX and ISize, and improved performance in LRAT trimming.* normalization for linear integer arithmetic expressions has been implemented\nand connected to simp +arith. #7043 deprecates the tactics simp_arith,\nsimp_arith!, simp_all_arith and simp_all_arith! in favor of simp +arith.\n\nImportant Library updates include:\n\n* #6914 introduces ordered map data structures, namely DTreeMap,\nTreeMap, TreeSet and their .Raw variants, into the standard\nlibrary.  A collection of lemmas about the operations on these data structures has\nbeen added in the subsequent PRs.* #7255 fixes the definition of Min (Option α). This is a breaking\nchange. This treats none as the least element,\nso min none x = min x none = none for all x : Option α. Prior to\nnightly-2025-02-27, we instead had min none (some x) = min (some x) none = some x. Also adds basic lemmas relating min, max, ≤ and\n< on Option.\n\nSignificant development has been made in the verification APIs of BitVec\nand fixed-width integer types (IntX), along with ongoing work to align\nList/Array/Vector APIs. Several lemmas about Int.ediv/fdiv/tdiv have\nbeen strengthened.\n\n#6950 adds a style guide and a naming convention for the standard library.\n\nThis summary of highlights was contributed by Violetta Sim.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Highlights","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Highlights"}});