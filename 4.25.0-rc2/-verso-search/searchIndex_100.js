window.docContents[100].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Iteration":{"contents":"Folds a function over an array from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the array in reverse order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (exclusive) to stop (inclusive), so no folding occurs unless start > stop.\nBy default, the entire array is used.Examples:* #[a, b, c].foldr f init  = f a (f b (f c init))* #[1, 2, 3].foldr (toString ¬∑ ++ ¬∑) \"\" = \"123\"* #[1, 2, 3].foldr (s!\"({¬∑} {¬∑})\") \"!\" = \"(1 (2 (3 !)))\"\n\nFolds a monadic function over an array from the right, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in reverse order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (exclusive) to stop (inclusive), so no folding occurs unless start > stop.\nBy default, the entire array is folded.Examples:example [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ≤) :\n  Array.foldrM (m := m) f x‚ÇÄ #[a, b, c] = (do\n    let x‚ÇÅ ‚Üê f c x‚ÇÄ\n    let x‚ÇÇ ‚Üê f b x‚ÇÅ\n    let x‚ÇÉ ‚Üê f a x‚ÇÇ\n    pure x‚ÇÉ)\n  := by rfl\nexample [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ≤) :\n  Array.foldrM (m := m) f x‚ÇÄ #[a, b, c] (start := 2) = (do\n    let x‚ÇÅ ‚Üê f b x‚ÇÄ\n    let x‚ÇÇ ‚Üê f a x‚ÇÅ\n    pure x‚ÇÇ)\n  := by rfl\n\n\nFolds a function over an array from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the array in order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (inclusive) to stop (exclusive), so no folding occurs unless start < stop.\nBy default, the entire array is used.Examples:* #[a, b, c].foldl f z  = f (f (f z a) b) c* #[1, 2, 3].foldl (¬∑ ++ toString ¬∑) \"\" = \"123\"* #[1, 2, 3].foldl (s!\"({¬∑} {¬∑})\") \"\" = \"((( 1) 2) 3)\"\n\nFolds a monadic function over a list from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (inclusive) to stop (exclusive), so no folding occurs unless start < stop.\nBy default, the entire array is folded.Examples:example [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ±) :\n    Array.foldlM (m := m) f x‚ÇÄ #[a, b, c] = (do\n      let x‚ÇÅ ‚Üê f x‚ÇÄ a\n      let x‚ÇÇ ‚Üê f x‚ÇÅ b\n      let x‚ÇÉ ‚Üê f x‚ÇÇ c\n      pure x‚ÇÉ)\n  := by rfl\nexample [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ±) :\n    Array.foldlM (m := m) f x‚ÇÄ #[a, b, c] (start := 1) = (do\n      let x‚ÇÅ ‚Üê f x‚ÇÄ b\n      let x‚ÇÇ ‚Üê f x‚ÇÅ c\n      pure x‚ÇÇ)\n  := by rfl\n\n\nApplies the monadic action f to each element of an array, in order.The optional parameters start and stop control the region of the array to which f should be\napplied. Iteration proceeds from start (inclusive) to stop (exclusive), so f is not invoked\nunless start < stop. By default, the entire array is used.\n\nApplies the monadic action f to each element of an array from right to left, in reverse order.The optional parameters start and stop control the region of the array to which f should be\napplied. Iteration proceeds from start (exclusive) to stop (inclusive), so no f is not invoked\nunless start > stop. By default, the entire array is used.\n\nMaps f over the array and collects the results with <|>. The result for the end of the array is\nfailure.Examples:* #[[], [1, 2], [], [2]].firstM List.head? = some 1* #[[], [], []].firstM List.head? = none* #[].firstM List.head? = none\n\nComputes the sum of the elements of an array.Examples:* #[a, b, c].sum = a + (b + (c + 0))* #[1, 2, 5].sum = 8\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.8. Iteration","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Iteration"},"/Basic-Types/Maps-and-Sets/#ExtHashMap":{"contents":"The declarations in this section should be imported using import Std.ExtHashMap.\n\nHash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.In contrast to regular hash maps, Std.ExtHashMap offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over hash maps.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.HashMap.Raw and\nStd.HashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nHashMap or ExtHashMap over HashMap.Raw.Dependent hash maps, in which keys may occur in their values' types, are available as\nStd.ExtDHashMap in the module Std.Data.ExtDHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.18.4. Extensional Hash Maps","id":"/Basic-Types/Maps-and-Sets/#ExtHashMap"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Validity":{"contents":"Returns true if p is a valid UTF-8 position in the string s.This means that p ‚â§ s.endPos and p lies on a UTF-8 character boundary. At runtime, this\noperation takes constant time.Examples:* String.Pos.isValid \"abc\" ‚ü®0‚ü© = true* String.Pos.isValid \"abc\" ‚ü®1‚ü© = true* String.Pos.isValid \"abc\" ‚ü®3‚ü© = true* String.Pos.isValid \"abc\" ‚ü®4‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®0‚ü© = true* String.Pos.isValid \"ùí´(A)\" ‚ü®1‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®2‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®3‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®4‚ü© = true\n\nEfficiently checks whether a position is at a UTF-8 character boundary of the slice s.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"19.8.4.5.1. Validity","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Validity"},"/Introduction/#history-of-lean":{"contents":"Leonardo de Moura launched the Lean project when he was at Microsoft Research in 2013, and Lean 0.1 was officially released on June 16, 2014.\nThe goal of the Lean project is to combine the high level of trust provided by a small, independently-implementable logical kernel with the convenience and automation of tools like SMT solvers, while scaling to large problems.\nThis vision still guides the development of Lean, as we invest in improved automation, improved performance, and user-friendliness; the trusted core proof checker is still minimal and independent implementations exist.\n\nThe initial versions of Lean were primarily configured as C++ libraries in which client code could carry out trustworthy proofs that were independently checkable.\nIn these early years, the design of Lean rapidly evolved towards traditional interactive provers, first with tactics written in Lua, and later with a dedicated front-end syntax.\nJanuary 20, 2017 saw the first release of the Lean 3.0 series.\nLean 3 achieved widespread adoption by mathematicians, and pioneered self-extensibility: tactics, notations, and top-level commands could all be defined in Lean itself.\nThe mathematics community built Mathlib, which at the end of Lean 3 had over one million lines of formalized mathematics, with all proofs mechanically checked.\nThe system itself, however, was still implemented in C++, which imposed limits on Lean's flexibility and made it more difficult to develop due to the diverse skills required.\n\nDevelopment of Lean 4 began in 2018, culminating in the 4.0 release on September 8, 2023.\nLean 4 represents an important milestone: as of version 4, Lean is self-hosted - approximately 90% of the code that implements Lean is itself written in Lean.\nLean 4's rich extension API provides users with the ability to adapt it to their needs, rather than relying on the core developers to add necessary features.\nAdditionally, self-hosting makes the development process much faster, so features and performance can be delivered more quickly; Lean 4 is faster and scales to larger problems than Lean 3.\nMathlib was successfully ported to Lean 4 in 2023 through a community effort supported by the Lean developers, and it has now grown to over 1.5 million lines.\nEven though Mathlib has grown by 50%, Lean 4 checks it faster than Lean 3 could check its smaller library.\nThe development process for Lean 4 was approximately as long as that of all prior versions combined, and we are now delighted with its design‚Äîno further rewrites are planned.\n\nLeonardo de Moura and his co-founder, Sebastian Ullrich, launched the Lean Focused Research Organization (FRO) nonprofit in July of 2023 within Convergent Research, with philanthropic support from the Simons Foundation International, the Alfred P. Sloan Foundation, and Richard Merkin.\nThe FRO currently has more than ten employees working to support the growth and scalability of Lean and the broader Lean community.\n\n","context":"Lean Reference\u0009Introduction","header":"1.1. History","id":"/Introduction/#history-of-lean"}});