window.docContents[85].resolve({"/Attributes/#The-Lean-Language-Reference--Attributes--Attributes-as-Modifiers":{"contents":"Attributes can be added to declarations as a declaration modifier.\nThey are placed between the documentation comment and the visibility modifiers.\n\nAttributes\n\n","context":"Lean Reference\u0009Attributes","header":"9.1. Attributes as Modifiers","id":"/Attributes/#The-Lean-Language-Reference--Attributes--Attributes-as-Modifiers"},"/Type-Classes/Instance-Declarations/#recursive-instances":{"contents":"Functions defined in where structure definition syntax are not recursive.\nBecause instance declaration is a version of structure definition, type class methods are also not recursive by default.\nInstances for recursive inductive types are common, however.\nThere is a standard idiom to work around this limitation: define a recursive function independently of the instance, and then refer to it in the instance definition.\nBy convention, these recursive functions have the name of the corresponding method, but are defined in the type's namespace.\n\nInstances are not recursiveGiven this definition of NatTree:inductive NatTree where\n  | leaf\n  | branch (left : NatTree) (val : Nat) (right : NatTree)\nthe following BEq instance fails:instance : BEq NatTree where\n  beq\n    | .leaf, .leaf =>\n      true\n    | .branch l1 v1 r1, .branch l2 v2 r2 =>\n      l1 == l2 && v1 == v2 && r1 == r2\n    | _, _ =>\n      false\nwith errors in both the left and right recursive calls that read:failed to synthesize\n  BEq NatTree\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nGiven a suitable recursive function, such as NatTree.beq:def NatTree.beq : NatTree → NatTree → Bool\n  | .leaf, .leaf =>\n    true\n  | .branch l1 v1 r1, .branch l2 v2 r2 =>\n    l1 == l2 && v1 == v2 && r1 == r2\n  | _, _ =>\n    false\nthe instance can be created in a second step:instance : BEq NatTree where\n  beq := NatTree.beq\nor, equivalently, using anonymous constructor syntax:instance : BEq NatTree := ⟨NatTree.beq⟩\n\n\nFurthermore, instances are not available for instance synthesis during their own definitions.\nThey are first marked as being available for instance synthesis after they are defined.\nNested inductive types, in which the recursive occurrence of the type occurs as a parameter to some other inductive type, may require an instance to be available to write even the recursive function.\nThe standard idiom to work around this limitation is to create a local instance in a recursively-defined function that includes a reference to the function being defined, taking advantage of the fact that instance synthesis may use every binding in the local context with the right type.\n\nInstances for nested typesIn this definition of NatRoseTree, the type being defined occurs nested under another inductive type constructor (Array):inductive NatRoseTree where\n  | node (val : Nat) (children : Array NatRoseTree)\n\nChecking the equality of rose trees requires checking equality of arrays.\nHowever, instances are not typically available for instance synthesis during their own definitions, so the following definition fails, even though NatRoseTree.beq is a recursive function and is in scope in its own definition.def NatRoseTree.beq : (tree1 tree2 : NatRoseTree) → Bool\n  | .node val1 children1, .node val2 children2 =>\n    val1 == val2 &&\n    children1 == children2\nfailed to synthesize\n  BEq (Array NatRoseTree)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nTo solve this, a local BEq NatRoseTree instance may be let-bound:partial def NatRoseTree.beq : (tree1 tree2 : NatRoseTree) → Bool\n  | .node val1 children1, .node val2 children2 =>\n    let _ : BEq NatRoseTree := ⟨NatRoseTree.beq⟩\n    val1 == val2 &&\n    children1 == children2\nThe use of array equality on the children finds the let-bound instance during instance synthesis.\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Declarations","header":"11.2.1. Recursive Instances","id":"/Type-Classes/Instance-Declarations/#recursive-instances"}});