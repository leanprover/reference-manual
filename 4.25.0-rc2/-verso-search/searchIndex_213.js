window.docContents[213].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Lookups":{"contents":"Extracts an element from the subarray.The index is relative to the start of the subarray, rather than the underlying array.\n\nExtracts an element from the subarray, or returns a default value when the index is out of bounds.The index is relative to the start and end of the subarray, rather than the underlying array. The\ndefault value is that provided by the Inhabited α instance.\n\nExtracts an element from the subarray, or returns a default value v₀ when the index is out of\nbounds.The index is relative to the start and end of the subarray, rather than the underlying array.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","header":"19.16.5.4. Lookups","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Lookups"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Queries":{"contents":"Counts the number of times an element occurs in a list.Examples:* [1, 1, 2, 3, 5].count 1 = 2* [1, 1, 2, 3, 5].count 5 = 1* [1, 1, 2, 3, 5].count 4 = 0\n\nCounts the number of elements in the list l that satisfy the Boolean predicate p.Examples:* [1, 2, 3, 4, 5].countP (· % 2 == 0) = 2* [1, 2, 3, 4, 5].countP (· < 5) = 4* [1, 2, 3, 4, 5].countP (· > 5) = 0\n\nReturns the index of the first element equal to a, or the length of the list if no element is\nequal to a.Examples:* [\"carrot\", \"potato\", \"broccoli\"].idxOf \"carrot\" = 0* [\"carrot\", \"potato\", \"broccoli\"].idxOf \"broccoli\" = 2* [\"carrot\", \"potato\", \"broccoli\"].idxOf \"tomato\" = 3* [\"carrot\", \"potato\", \"broccoli\"].idxOf \"anything else\" = 3\n\nReturns the index of the first element equal to a, or none if no element is equal to a.Examples:* [\"carrot\", \"potato\", \"broccoli\"].idxOf? \"carrot\" = some 0* [\"carrot\", \"potato\", \"broccoli\"].idxOf? \"broccoli\" = some 2* [\"carrot\", \"potato\", \"broccoli\"].idxOf? \"tomato\" = none* [\"carrot\", \"potato\", \"broccoli\"].idxOf? \"anything else\" = none\n\nReturns the index of the first element equal to a, or the length of the list if no element is\nequal to a. The index is returned as a Fin, which guarantees that it is in bounds.Examples:* [\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"carrot\" = some 0* [\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"broccoli\" = some 2* [\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"tomato\" = none* [\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"anything else\" = none\n\nReturns the first element of the list for which the predicate p returns true, or none if no\nsuch element is found.O(|l|).Examples:* [7, 6, 5, 8, 1, 2, 6].find? (· < 5) = some 1* [7, 6, 5, 8, 1, 2, 6].find? (· < 1) = none\n\nReturns the index of the first element for which p returns true, or none if there is no such\nelement. The index is returned as a Fin, which guarantees that it is in bounds.Examples:* [7, 6, 5, 8, 1, 2, 6].findFinIdx? (· < 5) = some (4 : Fin 7)* [7, 6, 5, 8, 1, 2, 6].findFinIdx? (· < 1) = none\n\nReturns the index of the first element for which p returns true, or the length of the list if\nthere is no such element.Examples:* [7, 6, 5, 8, 1, 2, 6].findIdx (· < 5) = 4* [7, 6, 5, 8, 1, 2, 6].findIdx (· < 1) = 7\n\nReturns the index of the first element for which p returns true, or none if there is no such\nelement.Examples:* [7, 6, 5, 8, 1, 2, 6].findIdx (· < 5) = some 4* [7, 6, 5, 8, 1, 2, 6].findIdx (· < 1) = none\n\nReturns the first element of the list for which the monadic predicate p returns true, or none\nif no such element is found. Elements of the list are checked in order.O(|l|).Example:#eval [7, 6, 5, 8, 1, 2, 6].findM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 6\nAlmost! 5\nsome 1\n\n\nReturns the first non-none result of applying f to each element of the list in order. Returns\nnone if f returns none for all elements of the list.O(|l|).Examples:* [7, 6, 5, 8, 1, 2, 6].findSome? (fun x => if x < 5 then some (10 * x) else none) = some 10* [7, 6, 5, 8, 1, 2, 6].findSome? (fun x => if x < 1 then some (10 * x) else none) = none\n\nReturns the first non-none result of applying the monadic function f to each element of the\nlist, in order. Returns none if f returns none for all elements.O(|l|).Example:#eval [7, 6, 5, 8, 1, 2, 6].findSomeM? fun i => do\n  if i < 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\nAlmost! 6\nAlmost! 5\nsome 10\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.6. Queries","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Queries"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key. There is also a Prop-valued version\nof this: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for comparisons, while for hash maps, both use ==.\n\nThe notation m[a] or m[a]'h is preferred over calling this function directly.Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof of\na ∈ m.\n\nThe notation m[a]! is preferred over calling this function directly.Tries to retrieve the mapping for the given key, panicking if no such mapping is present.\n\nThe notation m[a]? is preferred over calling this function directly.Tries to retrieve the mapping for the given key, returning none if no such mapping is present.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\nReturns a list of all keys present in the hash map in some order.\n\nReturns an array of all keys present in the hash map in some order.\n\nReturns a list of all values present in the hash map in some order.\n\nReturns an array of all values present in the hash map in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","header":"19.18.2.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Queries"},"/Terms/Functions/#implicit-functions":{"contents":"Lean supports implicit parameters to functions.\nThis means that Lean itself can supply arguments to functions, rather than requiring users to supply all needed arguments.\nImplicit parameters come in three varieties:\n\n Ordinary implicit parameters\n\nOrdinary implicit parameters are function parameters that Lean should determine values for via unification.\n    In other words, each call site should have exactly one potential argument value that would cause the function call as a whole to be well-typed.\n    The Lean elaborator attempts to find values for all implicit arguments at each occurrence of a function.\n    Ordinary implicit parameters are written in curly braces ({ and }).\n\n Strict implicit parameters\n\nStrict implicit parameters are identical to ordinary implicit parameters, except Lean will only attempt to find argument values when subsequent explicit arguments are provided at a call site.\n    Strict implicit parameters are written in double curly braces (⦃ and ⦄, or {{ and }}).\n\n Instance implicit parameters\n\nArguments for instance implicit parameters are found via type class synthesis.\n    Instance implicit parameters are written in square brackets ([ and ]).\n    Unlike the other kinds of implicit parameter, instance implicit parameters that are written without a : specify the parameter's type rather than providing a name.\n    Furthermore, only a single name is allowed.\n    Most instance implicit parameters omit the parameter name because instances synthesized as parameters to functions are already available in the functions' bodies, even without being named explicitly.\n\n\n\nOrdinary vs Strict Implicit ParametersThe difference between the functions f and g is that α is strictly implicit in f:def f ⦃α : Type⦄ : α → α := fun x => x\ndef g {α : Type} : α → α := fun x => x\nThese functions are elaborated identically when applied to concrete arguments:example : f 2 = g 2 := rfl\nHowever, when the explicit argument is not provided, uses of f do not require the implicit α to be solved:example := f\nHowever, uses of g do require it to be solved, and fail to elaborate if there is insufficient information available:example := g\ndon't know how to synthesize implicit argument `α`\n  @g ?m.3\ncontext:\n⊢ Type\n\n\nFunctions with Varying BindersThe most general syntax for fun accepts a sequence of binders:\n\nFunction BindersFunction binders may be identifiers:parenthesized sequences of identifiers:sequences of identifiers with a type ascription:implicit parameters, with or without a type ascription:instance implicits, anonymous or named:or strict implicit parameters, with or without a type ascription:As usual, an _ may be used instead of an identifier to create an anonymous parameter, and ⦃ and ⦄ may alternatively be written using {{ and }}, respectively.\n\nLean's core language does not distinguish between implicit, instance, and explicit parameters: the various kinds of function and function type are definitionally equal.\nThe differences can be observed only during elaboration.\n\n\n\nIf the expected type of a function includes implicit parameters, but its binders do not, then the resulting function may end up with more parameters than the binders indicated in the code.\nThis is because the implicit parameters are added automatically.\n\nImplicit Parameters from TypesThe identity function can be written with a single explicit parameter.\nAs long as its type is known, the implicit type parameter is added automatically.#check (fun x => x : {α : Type} → α → α)\nfun {α} x => x : {α : Type} → α → α\nThe following are all equivalent:#check (fun {α} x => x : {α : Type} → α → α)\nfun {α} x => x : {α : Type} → α → α\n#check (fun {α} (x : α) => x : {α : Type} → α → α)\nfun {α} x => x : {α : Type} → α → α\n#check (fun {α : Type} (x : α) => x : {α : Type} → α → α)\nfun {α} x => x : {α : Type} → α → α\n\n\n","context":"Lean Reference\u0009Terms\u0009Functions","header":"10.3.1. Implicit Parameters","id":"/Terms/Functions/#implicit-functions"},"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals":{"contents":"There are two kinds of numeric literal: natural number literals and scientific literals.\nBoth are overloaded via type classes.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Terms","header":"10.5. Numeric Literals","id":"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals"},"/The-Type-System/Quotients/#quotient-model":{"contents":"Like functions and universes, quotient types are a built-in feature of Lean's type system.\nHowever, the underlying primitives are based on the somewhat simpler Quot type rather than on Quotient, and Quotient is defined in terms of Quot.\nThe primary difference is that Quot is based on an arbitrary relation, rather than a Setoid instance.\nThe provided relation need not be an equivalence relation; the rules that govern Quot and Eq automatically extend the provided relation into its reflexive, transitive, symmetric closure.\nWhen the relation is already an equivalence relation, Quotient should be used instead of Quot so Lean can make use of the fact that the relation is an equivalence relation.\n\nThe fundamental quotient type API consists of Quot, Quot.mk, Quot.lift, Quot.ind, and Quot.sound.\nThese are used in the same way as their Quotient-based counterparts.\n\nLow-level quotient types. Quotient types coarsen the propositional equality for a type α, so that\nterms related by some relation r are considered equal in Quot r.Set-theoretically, Quot r can seen as the set of equivalence classes of α modulo r. Functions\nfrom Quot r must prove that they respect r: to define a function f : Quot r → β, it is\nnecessary to provide f' : α → β and prove that for all x : α and y : α, r x y → f' x = f' y.Quot is a built-in primitive:* Quot.mk places elements of the underlying type α into the quotient.* Quot.lift allows the definition of functions from the quotient to some other type.* Quot.sound asserts the equality of elements related by r.* Quot.ind is used to write proofs about quotients by assuming that all elements are constructed\nwith Quot.mk.The relation r is not required to be an equivalence relation; the resulting quotient type's\nequality extends r to an equivalence as a consequence of the rules for equality and quotients.\nWhen r is an equivalence relation, it can be more convenient to use the higher-level type\nQuotient.\n\nPlaces an element of a type into the quotient that equates terms according to the provided relation.Given v : α and relation r : α → α → Prop, Quot.mk r v : Quot r is like v, except all\nobservations of v's value must respect r.Quot.mk is a built-in primitive:* Quot is the built-in quotient type.* Quot.lift allows the definition of functions from the quotient to some other type.* Quot.sound asserts the equality of elements related by r.* Quot.ind is used to write proofs about quotients by assuming that all elements are constructed\nwith Quot.mk.\n\nLifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.Given a relation r : α → α → Prop and a quotient Quot r, applying a function f : α → β\nrequires a proof a that f respects r. In this case, Quot.lift f a : Quot r → β computes the\nsame values as f.Lean's type theory includes a definitional reduction from\nQuot.lift f h (Quot.mk r v) to f v.Quot.lift is a built-in primitive:* Quot is the built-in quotient type.* Quot.mk places elements of the underlying type α into the quotient.* Quot.sound asserts the equality of elements related by r* Quot.ind is used to write proofs about quotients by assuming that all elements are constructed\nwith Quot.mk; it is analogous to the recursor for a\nstructure.\n\nA reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with Quot.mk.Quot.rec is analogous to the recursor for a structure, and can\nbe used when the resulting type is not necessarily a proposition.Quot.ind is a built-in primitive:* Quot is the built-in quotient type.* Quot.mk places elements of the underlying type α into the quotient.* Quot.lift allows the definition of functions from the quotient to some other type.* Quot.sound asserts the equality of elements related by r.\n\nThe quotient axiom, which asserts the equality of elements related by the quotient's relation.The relation r does not need to be an equivalence relation to use this axiom. When r is not an\nequivalence relation, the quotient is with respect to the equivalence relation generated by r.Quot.sound is part of the built-in primitive quotient type:* Quot is the built-in quotient type.* Quot.mk places elements of the underlying type α into the quotient.* Quot.lift allows the definition of functions from the quotient to some other type.* Quot.ind is used to write proofs about quotients by assuming that all elements are constructed\nwith Quot.mk; it is analogous to the recursor for a\nstructure.Quotient types are described in more detail in the Lean Language\nReference.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.5. Logical Model","id":"/The-Type-System/Quotients/#quotient-model"}});