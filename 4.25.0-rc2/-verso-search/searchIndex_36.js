window.docContents[36].resolve({"/Basic-Types/Arrays/#array-performance":{"contents":"Despite the fact that they appear to be an ordinary constructor and projection, Array.mk and Array.toList take time linear in the size of the array in compiled code.\nThis is because converting between linked lists and packed arrays must necessarily visit each element.\n\nMutable arrays can be used to write very efficient code.\nHowever, they are a poor persistent data structure.\nUpdating a shared array rules out mutation, and requires time linear in the size of the array.\nWhen using arrays in performance-critical code, it's important to ensure that they are used linearly.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Run-Time Representation","header":"19.16.2.1. Performance Notes","id":"/Basic-Types/Arrays/#array-performance"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Lookups":{"contents":"Retrieves the byte at the indicated index. Callers must prove that the index is in bounds.Use uget for a more efficient alternative or get! for a variant that panics if the\nindex is out of bounds.\n\nRetrieves the byte at the indicated index. Callers must prove that the index is in bounds. The index\nis represented by a platform-specific fixed-width integer (either 32 or 64 bits).Because USize is big enough to address all memory on every platform that Lean supports, there are\nin practice no ByteArrays for which uget cannot retrieve all elements.\n\nRetrieves the byte at the indicated index. Panics if the index is out of bounds.\n\nCopies the bytes with indices b (inclusive) to e (exclusive) to a new\nByteArray.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.3. Lookups","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Lookups"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Properties":{"contents":"The number of mappings present in the hash map\n\nReturns true if the hash map contains no mappings.Note that if your BEq instance is not reflexive or your Hashable instance is not\nlawful, then it is possible that this function returns false even though is not possible\nto get anything out of the hash map.\n\nTwo hash maps are equivalent in the sense of Equiv iff\nall the keys and values are equal.Internal implementation detail of the hash map\n\nEquivalenceThe relation HashMap.Equiv can also be written with an infix operator, which is scoped to its namespace:\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","header":"19.18.2.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Properties"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Custom-Targets":{"contents":"Custom targets may be used to define any incrementally-built artifact whatsoever, using the Lake API.\n\nCustom TargetsDefine a new external library target for the package. Has one form:extern_lib «target-name» (pkg : NPackage _package.name) :=\n  /- build term of type `FetchM (Job FilePath)` -/\nThe pkg parameter (and its type specifier) is optional.\nIt is of type NPackage _package.name to provably demonstrate the package\nprovided is the package in which the target is defined.The term should build the external library's static library.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format\u0009Targets","header":"22.1.3.2.4.4. Custom Targets","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Custom-Targets"},"/Error-Explanations/lean___projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--lean___projNonPropFromProp--Examples":{"contents":"Attempting to use index projection on existential proofexample (a : Nat) (h : ∃ x : Nat, x > a + 1) : ∃ x : Nat, x > 0 :=\n  ⟨h.1, Nat.lt_of_succ_lt h.2⟩\n<invalid output>example (a : Nat) (h : ∃ x : Nat, x > a + 1) : ∃ x : Nat, x > a :=\n  let ⟨w, hw⟩ := h\n  ⟨w, Nat.lt_of_succ_lt hw⟩\nexample (a : Nat) (h : ∃ x : Nat, x > a + 1) : ∃ x : Nat, x > a := by\n  cases h with\n  | intro w hw =>\n    exists w\n    omega\nThe witness associated with a proof of an existential proposition cannot be extracted using an\nindex projection. Instead, it is necessary to use a pattern match: either a term like a let\nbinding or a tactic like cases.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.projNonPropFromProp","header":"Examples","id":"/Error-Explanations/lean___projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--lean___projNonPropFromProp--Examples"},"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Proving-a-Stateful-Goal":{"contents":"mspec is an apply-like tactic that applies a Hoare triple specification to the target of the\nstateful goal.Given a stateful goal H ⊢ₛ wp⟦prog⟧ Q', mspec foo_spec will instantiate\nfoo_spec : ... → ⦃P⦄ foo ⦃Q⦄, match foo against prog and produce subgoals for\nthe verification conditions ?pre : H ⊢ₛ P and ?post : Q ⊢ₚ Q'.* If prog = x >>= f, then mspec Specs.bind is tried first so that foo is matched against x\ninstead. Tactic mspec_no_bind does not attempt to do this decomposition.* If ?pre or ?post follow by .rfl, then they are discharged automatically.* ?post is automatically simplified into constituent ⊢ₛ entailments on\nsuccess and failure continuations.* ?pre and ?post.* goals introduce their stateful hypothesis under an inaccessible name.\nYou can give it a name with the mrename_i tactic.* Any uninstantiated MVar arising from instantiation of foo_spec becomes a new subgoal.* If the target of the stateful goal looks like fun s => _ then mspec will first mintro ∀s.* If P has schematic variables that can be instantiated by doing mintro ∀s, for example\nfoo_spec : ∀(n:Nat), ⦃fun s => ⌜n = s⌝⦄ foo ⦃Q⦄, then mspec will do mintro ∀s first to\ninstantiate n = s.* Right before applying the spec, the mframe tactic is used, which has the following effect:\nAny hypothesis Hᵢ in the goal h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T that is\npure (i.e., equivalent to some ⌜φᵢ⌝) will be moved into the pure context as hᵢ:φᵢ.Additionally, mspec can be used without arguments or with a term argument:* mspec without argument will try and look up a spec for x registered with @[spec].* mspec (foo_spec blah ?bleh) will elaborate its argument as a term with expected type\n⦃?P⦄ x ⦃?Q⦄ and introduce ?bleh as a subgoal.\nThis is useful to pass an invariant to e.g., Specs.forIn_list and leave the inductive step\nas a hole.\n\nLike intro, but introducing stateful hypotheses into the stateful context of the Std.Do.SPred\nproof mode.\nThat is, given a stateful goal (hᵢ : Hᵢ)* ⊢ₛ P → T, mintro h transforms\ninto (hᵢ : Hᵢ)*, (h : P) ⊢ₛ T.Furthermore, mintro ∀s is like intro s, but preserves the stateful goal.\nThat is, mintro ∀s brings the topmost state variable s:σ in scope and transforms\n(hᵢ : Hᵢ)* ⊢ₛ T (where the entailment is in Std.Do.SPred (σ::σs)) into\n(hᵢ : Hᵢ s)* ⊢ₛ T s (where the entailment is in Std.Do.SPred σs).Beyond that, mintro supports the full syntax of mcases patterns\n(mintro pat = (mintro h; mcases h with pat), and can perform multiple\nintroductions in sequence.\n\nmexact is like exact, but operating on a stateful Std.Do.SPred goal.example (Q : SPred σs) : Q ⊢ₛ Q := by\n  mstart\n  mintro HQ\n  mexact HQ\n\n\nmassumption is like assumption, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : Q ⊢ₛ P → Q := by\n  mintro _ _\n  massumption\n\n\nLike refine, but operating on stateful Std.Do.SPred goals.example (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrefine ⟨HP, HR⟩\n\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mrefine ⟨⌜42⌝, H⟩\n\n\nmconstructor is like constructor, but operating on a stateful Std.Do.SPred goal.example (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by\n  mintro HQ\n  mconstructor <;> mexact HQ\n\n\nmleft is like left, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by\n  mintro HP\n  mleft\n  mexact HP\n\n\nmright is like right, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by\n  mintro HP\n  mright\n  mexact HP\n\n\nmexists is like exists, but operating on a stateful Std.Do.SPred goal.example (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mexists 42\n\n\nmpure_intro operates on a stateful Std.Do.SPred goal of the form P ⊢ₛ ⌜φ⌝.\nIt leaves the stateful proof mode (thereby discarding P), leaving the regular goal φ.theorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by\n  mpure_intro\n  exact True.intro\n\n\nmexfalso is like exfalso, but operating on a stateful Std.Do.SPred goal.example (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by\n  mintro HP\n  mexfalso\n  mexact HP\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Verification Condition Generation\u0009Tactics for Stateful Goals in  Std.Do.SPred","header":"13.5.23.1.2. Proving a Stateful Goal","id":"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Proving-a-Stateful-Goal"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Compiler___-runtime___-and-FFI":{"contents":"* #3106 moves frontend to new snapshot architecture. Note that Frontend.processCommand and FrontendM are no longer used by Lean core, but they will be preserved.* #4919 adds missing include in runtime for AUTO_THREAD_FINALIZATION feature on Windows.* #4941 adds more LEAN_EXPORTs for Windows.* #4911 improves formatting of CLI help text for the frontend.* #4950 improves file reading and writing.* readBinFile and readFile now only require two system calls (stat + read) instead of one read per 1024 byte chunk.* Handle.getLine and Handle.putStr no longer get tripped up by NUL characters.* #4971 handles the SIGBUS signal when detecting stack overflows.* #5062 avoids overwriting existing signal handlers, like in rust-lang/rust#69685.* #4860 improves workarounds for building on Windows. Splits libleanshared on Windows to avoid symbol limit, removes the LEAN_EXPORT denylist workaround, adds missing LEAN_EXPORTs.* #4952 output panics into Lean's redirected stderr, ensuring panics ARE visible as regular messages in the language server and properly ordered in relation to other messages on the command line.* #4963 links LibUV.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Compiler, runtime, and FFI","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Compiler___-runtime___-and-FFI"},"/releases/v4.13.0/#release-v4___13___0":{"contents":"Full Changelog: https://github.com/leanprover/lean4/compare/v4.12.0...v4.13.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.13.0 (2024-11-01)","id":"/releases/v4.13.0/#release-v4___13___0"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Language-Features":{"contents":"* #5182 makes functions defined by well-founded recursion use an\nopaque well-founded proof by default. This reliably prevents kernel\nreduction of such definitions and proofs, which tends to be\nprohibitively slow (fixes #2171), and which regularly causes\nhard-to-debug kernel type-checking failures. This change renders\nunseal ineffective for such definitions. To avoid the opaque proof,\nannotate the function definition with @[semireducible].* #7166 extends the notion of “fixed parameter” of a recursive function\nalso to parameters that come after varying function. The main benefit is\nthat we get nicer induction principles.Before, the definitiondef app (as : List α) (bs : List α) : List α :=\n  match as with\n  | [] => bs\n  | a::as => a :: app as bs\nproducedapp.induct.{u_1} {α : Type u_1} (motive : List α → List α → Prop) (case1 : ∀ (bs : List α), motive [] bs)\n  (case2 : ∀ (bs : List α) (a : α) (as : List α), motive as bs → motive (a :: as) bs) (as bs : List α) : motive as bs\nand now you getapp.induct.{u_1} {α : Type u_1} (motive : List α → Prop) (case1 : motive [])\n  (case2 : ∀ (a : α) (as : List α), motive as → motive (a :: as)) (as : List α) : motive as\nbecause bs is fixed throughout the recursion (and can completely be dropped from the principle).This is a breaking change when such an induction principle is used explicitly. Using fun_induction makes proof tactics robust against this change.See the PR description for the rules for when a parameter is considered fixed.Note that in a definition likedef app : List α → List α → List α\n  | [], bs => bs\n  | a::as, bs => a :: app as bs\nthe bs is not considered fixed, as it goes through the matcher machinery.* #7431 changes the syntax of location modifiers for tactics like simp\nand rw (e.g., simp at h ⊢) to allow the turnstile ⊢ to appear\nanywhere in the sequence of locations.* #7457 ensures info tree users such as linters and request handlers\nhave access to info subtrees created by async elab task by introducing\nAPI to leave holes filled by such tasks.Breaking change: other metaprogramming users of Command.State.infoState may need to call InfoState.substituteLazy on it manually to fill all holes.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Highlights","header":"Language Features","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Language-Features"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Pretty-Printing":{"contents":"* #8041 changes the behavior of pp.showLetValues to use a hoverable\n⋯ to hide let values. This is now false by default, and there is a new\noption pp.showLetValues.threshold for allowing small expressions to be\nshown anyway. For tactic metavariables, there is an additional option\npp.showLetValues.tactic.threshold, which by default is set to the\nmaximal value, since in tactic states local values are usually\nsignificant.* #8372 modifies the pretty printer to use have syntax instead of\nlet_fun syntax.* #8457 fixes an issue when including a hard line break in a Format\nthat caused subsequent (ordinary) line breaks to be erroneously\nflattened to spaces.* #8504 modifies the pretty printer so that dot notation is used for\nclass parent projections. Previously, dot notation was never used for\nclasses.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Pretty Printing","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Pretty-Printing"},"/releases/v4.22.0/#release-v4___22___0":{"contents":"For this release, 468 changes landed. In addition to the 185 feature additions and 85 fixes listed below there were 15 refactoring changes, 5 documentation improvements, 4 performance improvements, 0 improvements to the test suite and 174 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.22.0 (2025-08-14)","id":"/releases/v4.22.0/#release-v4___22___0"}});