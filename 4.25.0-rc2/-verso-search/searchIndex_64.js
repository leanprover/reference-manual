window.docContents[64].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Syntax":{"contents":"These operations exist to support the OfScientific Float and OfScientific Float32 instances and are normally invoked indirectly as a result of a literal value.\n\nConstructs a Float from the given mantissa, sign, and exponent values.This function is part of the implementation of the OfScientific Float instance that is used to\ninterpret floating-point literals.\n\nConstructs a Float32 from the given mantissa, sign, and exponent values.This function is part of the implementation of the OfScientific Float32 instance that is used to\ninterpret floating-point literals.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"19.6.2.2. Syntax","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Syntax"},"/Basic-Types/Integers/#Int":{"contents":"The integers are whole numbers, both positive and negative.\nIntegers are arbitrary-precision, limited only by the capability of the hardware on which Lean is running; for fixed-width integers that are used in programming and computer science, please see the section on fixed-precision integers.\n\nIntegers are specially supported by Lean's implementation.\nThe logical model of the integers is based on the natural numbers: each integer is modeled as either a natural number or the negative successor of a natural number.\nOperations on the integers are specified using this model, which is used in the kernel and in interpreted code.\nIn these contexts, integer code inherits the performance benefits of the natural numbers' special support.\nIn compiled code, integers are represented as efficient arbitrary-precision integers, and sufficiently small numbers are stored as values that don't require indirection through a pointer.\nArithmetic operations are implemented by primitives that take advantage of the efficient representations.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.2. Integers","id":"/Basic-Types/Integers/#Int"},"/Definitions/Headers-and-Signatures/#signature-syntax":{"contents":"The header of a definition or declaration consists of the constant being declared or defined, if relevant, together with its signature.\nThe signature of a constant specifies how it can be used.\nThe information present in the signature is more than just the type, including information such as universe level parameters and the default values of its optional parameters.\nIn Lean, signatures are written in a consistent format in different kinds of declarations.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions","header":"7.2. Headers and Signatures","id":"/Definitions/Headers-and-Signatures/#signature-syntax"},"/Introduction/#code-samples":{"contents":"This document contains many Lean code examples.\nThey are formatted as follows:\n\ndef hello : IO Unit := IO.println \"Hello, world!\"\n\n\nCompiler output (which may be errors, warnings, or just information) is shown both in the code and separately:\n\n#eval s!\"The answer is {2 + 2}\"\n\ntheorem bogus : False := by sorry\n\nexample := Nat.succ \"two\"\n\n\nInformative output, such as the result of #eval, is shown like this:\n\n\"The answer is 4\"\n\n\nWarnings are shown like this:\n\ndeclaration uses 'sorry'\n\n\nError messages are shown like this:\n\nApplication type mismatch: The argument\n  \"two\"\nhas type\n  String\nbut is expected to have type\n  Nat\nin the application\n  Nat.succ \"two\"\n\n\nThe presence of tactic proof states is indicated by the presence of small lozenges that can be clicked to show the proof state, such as after rfl below:\n\nexample : 2 + 2 = 4 := by rfl\n\n\nProof states may also be shown on their own.\nWhen attempting to prove that 2 + 2 = 4, the initial proof state is:⊢ 2 + 2 = 4\nAfter using rfl, the resulting state is:\n\n\nIdentifiers in code examples are hyperlinked to their documentation.\n\nExamples of code with syntax errors are shown with an indicator of where the parser error occurred, along with the error message:\n\ndef f : Option Nat → Type\n  | some 0 => Unit\n  | => Option (f t)\n  | none => Empty\n\n\n<example>:3:3-3:6: unexpected token '=>'; expected term\n\n\n","context":"Lean Reference\u0009Introduction\u0009Typographical Conventions","header":"1.2.1. Lean Code","id":"/Introduction/#code-samples"}});