window.docContents[248].resolve({"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Iteration--Folds":{"contents":"Folds are operators that combine the elements of a list using a function.\nThey come in two varieties, named after the nesting of the function calls: Left folds\n\nLeft folds combine the elements from the head of the list towards the end.\n  The head of the list is combined with the initial value, and the result of this operation is then combined with the next value, and so forth.\n\n Right folds\n\nRight folds combine the elements from the end of the list towards the start, as if each cons constructor were replaced by a call to the combining function and nil were replaced by the initial value.\n\nMonadic folds, indicated with an -M suffix, allow the combining function to use effects in a monad, which may include stopping the fold early.\n\nFolds a function over a list from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in order, using f.Examples:* [a, b, c].foldl f z  = f (f (f z a) b) c* [1, 2, 3].foldl (· ++ toString ·) \"\" = \"123\"* [1, 2, 3].foldl (s!\"({·} {·})\") \"\" = \"((( 1) 2) 3)\"\n\nFolds a monadic function over a list from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in order, using f.Example:example [Monad m] (f : α → β → m α) :\n    List.foldlM (m := m) f x₀ [a, b, c] = (do\n      let x₁ ← f x₀ a\n      let x₂ ← f x₁ b\n      let x₃ ← f x₂ c\n      pure x₃)\n  := by rfl\n\n\nA reasoning principle for proving propositions about the result of List.foldl by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.Because the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.Example:example {xs : List Nat} : xs.foldl (· + ·) 1 > 0 := by\n  apply List.foldlRecOn\n  . show 0 < 1; trivial\n  . show ∀ (b : Nat), 0 < b → ∀ (a : Nat), a ∈ xs → 0 < b + a\n    intros; omega\n\n\nFolds a function over a list from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in reverse order, using f.O(|l|). Replaced at runtime with List.foldrTR.Examples:* [a, b, c].foldr f init  = f a (f b (f c init))* [1, 2, 3].foldr (toString · ++ ·) \"\" = \"123\"* [1, 2, 3].foldr (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"\n\nFolds a monadic function over a list from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in reverse order, using f.Example:example [Monad m] (f : α → β → m β) :\n  List.foldrM (m := m) f x₀ [a, b, c] = (do\n    let x₁ ← f c x₀\n    let x₂ ← f b x₁\n    let x₃ ← f a x₂\n    pure x₃)\n  := by rfl\n\n\nA reasoning principle for proving propositions about the result of List.foldr by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.Because the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.Example:example {xs : List Nat} : xs.foldr (· + ·) 1 > 0 := by\n  apply List.foldrRecOn\n  . show 0 < 1; trivial\n  . show ∀ (b : Nat), 0 < b → ∀ (a : Nat), a ∈ xs → 0 < a + b\n    intros; omega\n\n\nFolds a function over a list from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in reverse order, using f.O(|l|). This is the tail-recursive replacement for List.foldr in runtime code.Examples:* [a, b, c].foldrTR f init  = f a (f b (f c init))* [1, 2, 3].foldrTR (toString · ++ ·) \"\" = \"123\"* [1, 2, 3].foldrTR (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference\u0009Iteration","header":"19.15.3.10.1. Folds","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Iteration--Folds"},"/Interacting-with-Lean/#Format":{"contents":"A FormatThe API described here is an adaptation of Wadler's () It has been modified to be efficient in a strict language and with support for additional features such as metadata tags. is a compact representation of a set of strings.\nThe most important Format operations are: Strings\n\nA String can be made into a Format using the text constructor.\n  This constructor is registered as a coercion from String to Format, so it is often unnecessary to invoke it explicitly.\n  text str represents the singleton set that contains only str.\n  If the string contains newline characters ('\\n'), then they are unconditionally inserted as newlines into the resulting output, regardless of groups.\n  They are, however, indented according to the current indentation level.\n\n Appending\n\nTwo Formats can be appended using the ++ operator from the Append Format instance.\n\n Groups and Newlines\n\nThe constructor line represents the set that contains both \"\\n\" ++ indent and \" \", where indent is a string with enough spaces to indent the line correctly.\n  Imperatively, it can be thought of as a newline that will be “flattened” to a space if there is sufficient room on the current line.\n  Newlines occur in groups: the nearest enclosing application of the group operator determines which group the newline belongs to.\n  By default, either all lines in a group represent \"\\n\" or all represent \" \"; groups may also be configured to fill lines, in which case the minimal number of lines in the group represent \"\\n\".\n  Uses of line that do not belong to a group always represent \"\\n\".\n\n Indentation\n\nWhen a newline is inserted, the output is also indented.\n  nest n increases the indentation of a document by n spaces.\n  This is not sufficient to represent all Lean syntax, which sometimes requires that columns align exactly.\n  align is a document that ensures that the output string is at the current indentation level, inserting just spaces if possible, or a newline followed by spaces if needed.\n\n Tagging\n\nLean's interactive features require the ability to associate output with the underlying values that they represent.\n  This allows Lean development environments to present elaborated terms when hovering over terms proof states or error messages, for example.\n  Documents can be tagged with a Nat value n using tag n; these Nats should be mapped to the underlying value in a side table.\n\n\n\nWidths and Newlinesopen Std Format\nThe helper parenSeq creates a parenthesized sequence, with grouping and indentation to make it responsive to different output widths.def parenSeq (xs : List Format) : Format :=\n  group <|\n    nest 2 (text \"(\" ++ line ++ joinSep xs line) ++\n    line ++\n    \")\"\nThis document represents a parenthesized sequence of numbers:def lst : Format := parenSeq nums\nwhere nums := [1, 2, 3, 4, 5].map (text s!\"{·}\")\nRendering it with the default line width of 120 characters places the entire sequence on one line:#eval IO.println lst.pretty\n( 1 2 3 4 5 )\nBecause all the lines belong to the same group, they will either all be rendered as spaces or all be rendered as newlines.\nIf only 9 characters are available, all of the lines in lst become newlines:#eval IO.println (lst.pretty (width := 9))\n(\n  1\n  2\n  3\n  4\n  5\n)\nThis document contains three copies of lst in a further parenthesized sequence:def lsts := parenSeq [lst, lst, lst]\nAt the default width, it remains on one line:#eval IO.println lsts.pretty\n( ( 1 2 3 4 5 ) ( 1 2 3 4 5 ) ( 1 2 3 4 5 ) )\nIf only 20 characters are available, each occurrence of lst ends up on its own line.\nThis is because converting the outer group to newlines is sufficient to keep the string within 20 columns:#eval IO.println (lsts.pretty (width := 20))\n(\n  ( 1 2 3 4 5 )\n  ( 1 2 3 4 5 )\n  ( 1 2 3 4 5 )\n)\nIf only 10 characters are available, each number must be on its own line:#eval IO.println (lsts.pretty (width := 10))\n(\n  (\n    1\n    2\n    3\n    4\n    5\n  )\n  (\n    1\n    2\n    3\n    4\n    5\n  )\n  (\n    1\n    2\n    3\n    4\n    5\n  )\n)\n\n\nGrouping and Fillingopen Std Format\nThe helper parenSeq creates a parenthesized sequence, with each element placed on a new line and indented:def parenSeq (xs : List Format) : Format :=\n  nest 2 (text \"(\" ++ line ++ joinSep xs line) ++\n  line ++\n  \")\"\nnums contains the numbers one through twenty, as a list of formats:def nums : List Format :=\n  Nat.fold 20 (init := []) fun i _ ys =>\n    text s!\"{20 - i}\" :: ys\n#eval nums\nBecause parenSeq does not introduce any groups, the resulting document is rendered on a single line:#eval IO.println (pretty (parenSeq nums))\nThis can be fixed by grouping them.\ngrouped does so with group, while filled does so with fill.def grouped := group (parenSeq nums)\ndef filled := fill (parenSeq nums)\nBoth grouping operators cause uses of line to render as spaces.\nGiven sufficient space, both render on a single line:#eval IO.println (pretty grouped)\n( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 )\n#eval IO.println (pretty filled)\n( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 )\nHowever, difference become apparent when there is not sufficient space on a single line.\nUnless all newlines in a group can be spaces, none can:#eval IO.println (pretty (width := 30) grouped)\n(\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n  10\n  11\n  12\n  13\n  14\n  15\n  16\n  17\n  18\n  19\n  20\n)\nUsing fill, on the other hand, only inserts newlines as required to avoid being two wide:#eval IO.println (pretty (width := 30) filled)\n( 1 2 3 4 5 6 7 8 9 10 11 12\n  13 14 15 16 17 18 19 20 )\nThe behavior of fill can be seen clearly with longer sequences:#eval IO.println <|\n  pretty (width := 30) (fill (parenSeq (nums ++ nums ++ nums ++ nums)))\n( 1 2 3 4 5 6 7 8 9 10 11 12\n  13 14 15 16 17 18 19 20 1 2\n  3 4 5 6 7 8 9 10 11 12 13 14\n  15 16 17 18 19 20 1 2 3 4 5\n  6 7 8 9 10 11 12 13 14 15 16\n  17 18 19 20 1 2 3 4 5 6 7 8\n  9 10 11 12 13 14 15 16 17 18\n  19 20 )\n\n\nNewline Characters in StringsIncluding a newline character in a string causes the rendering process to unconditionally insert a newline.\nThese newlines do, however, respect the current indentation level.The document str consists of an embedded string with two newlines:open Std Format\n\ndef str : Format := text \"abc\\nxyz\\n123\"\nPrinting the string both with and without grouping results in the newlines being used:#eval IO.println str.pretty\nabc\nxyz\n123\n#eval IO.println (group str).pretty\nabc\nxyz\n123\nBecause the string does not terminate with a newline, the last line of the first string is on the same line as the first line of the second string:#eval IO.println (str ++ str).pretty\nabc\nxyz\n123abc\nxyz\n123\nIncreasing the indentation level, however, causes all three lines of the string to begin at the same column:#eval IO.println (text \"It is:\" ++ indentD str).pretty\nIt is:\n  abc\n  xyz\n  123\n#eval IO.println (nest 8 <| text \"It is:\" ++ align true ++ str).pretty\nIt is:  abc\n        xyz\n        123\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output","header":"3.7.1. Format","id":"/Interacting-with-Lean/#Format"},"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Library":{"contents":"* Nat* #4597 adds bitwise lemmas Nat.and_le_(left|right).* #4874 adds simprocs for simplifying bit expressions.* Int* #4903 fixes performance of HPow Int Nat Int synthesis by rewriting it as a NatPow Int instance.* UInt* and Fin* #4605 adds lemmas.* #4629 adds *.and_toNat.* Option* #4599 adds get lemmas.* #4600 adds Option.or, a version of Option.orElse that is strict in the second argument.* GetElem* #4603 adds getElem_congr to help with rewriting indices.* List and Array* Upstreamed from Batteries: #4586 upstreams List.attach and Array.attach, #4697 upstreams List.Subset and List.Sublist and API, #4706 upstreams basic material on List.Pairwise and List.Nodup, #4720 upstreams more List.erase API, #4836 and #4837 upstream List.IsPrefix/List.IsSuffix/List.IsInfix and add Decidable instances, #4855 upstreams List.tail, List.findIdx, List.indexOf, List.countP, List.count, and List.range', #4856 upstreams more List lemmas, #4866 upstreams List.pairwise_iff_getElem, #4865 upstreams List.eraseIdx lemmas.* #4687 adjusts List.replicate simp lemmas and simprocs.* #4704 adds characterizations of List.Sublist.* #4707 adds simp normal form tests for List.Pairwise and List.Nodup.* #4708 and #4815 reorganize lemmas on list getters.* #4765 adds simprocs for literal array accesses such as #[1,2,3,4,5][2].* #4790 removes typeclass assumptions for List.Nodup.eraseP.* #4801 adds efficient usize functions for array types.* #4820 changes List.filterMapM to run left-to-right.* #4835 fills in and cleans up gaps in List API.* #4843, #4868, and #4877 correct List.Subset lemmas.* #4863 splits Init.Data.List.Lemmas into function-specific files.* #4875 fixes statement of List.take_takeWhile.* Lemmas: #4602, #4627, #4678 for List.head and list.getLast, #4723 for List.erase, #4742* ByteArray* #4582 eliminates partial from ByteArray.toList and ByteArray.findIdx?.* BitVec* #4568 adds recurrence theorems for bitblasting multiplication.* #4571 adds shiftLeftRec lemmas.* #4872 adds ushiftRightRec and lemmas.* #4873 adds getLsb_replicate.* Std.HashMap added:* #4583 adds Std.HashMap as a verified replacement for Lean.HashMap. See the PR for naming differences, but #4725 renames HashMap.remove to HashMap.erase.* #4682 adds Inhabited instances.* #4732 improves BEq argument order in hash map lemmas.* #4759 makes lemmas resolve instances via unification.* #4771 documents that hash maps should be used linearly to avoid expensive copies.* #4791 removes bif from hash map lemmas, which is inconvenient to work with in practice.* #4803 adds more lemmas.* SMap* #4690 upstreams SMap.foldM.* BEq* #4607 adds PartialEquivBEq, ReflBEq, EquivBEq, and LawfulHashable classes.* IO* #4660 adds IO.Process.Child.tryWait.* #4747, #4730, and #4756 add ×' syntax for PProd. Adds a delaborator for PProd and MProd values to pretty print as flattened angle bracket tuples.* Other fixes or improvements* #4604 adds lemmas for cond.* #4619 changes some definitions into theorems.* #4616 fixes some names with duplicated namespaces.* #4620 fixes simp lemmas flagged by the simpNF linter.* #4666 makes the Antisymm class be a Prop.* #4621 cleans up unused arguments flagged by linter.* #4680 adds imports for orphaned Init modules.* #4679 adds imports for orphaned Std.Data modules.* #4688 adds forward and backward directions of not_exists.* #4689 upstreams eq_iff_true_of_subsingleton.* #4709 fixes precedence handling for Repr instances for negative numbers for Int and Float.* #4760 renames TC (\"transitive closure\") to Relation.TransGen.* #4842 fixes List deprecations.* #4852 upstreams some Mathlib attributes applied to lemmas.* 93ac63 improves proof.* #4862 and #4878 generalize the universe for PSigma.exists and rename it to Exists.of_psigma_prop.* Typos: #4737, 7d2155* Docs: #4782, #4869, #4648\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.11.0 (2024-09-02)","header":"Library","id":"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Library"},"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Library":{"contents":"* Array* #5687 deprecates Array.data.* #5705 uses a better default value for Array.swapAt!.* #5748 moves Array.mapIdx lemmas to a new file.* #5749 simplifies signature of Array.mapIdx.* #5758 upstreams Array.reduceOption.* #5786 adds simp lemmas for Array.isEqv and BEq.* #5796 renames Array.shrink to Array.take, and relates it to List.take.* #5798 upstreams List.modify, adds lemmas, relates to Array.modify.* #5799 relates Array.forIn and List.forIn.* #5833 adds Array.forIn', and relates to List.* #5848 fixes deprecations in Init.Data.Array.Basic to not recommend the deprecated constant.* #5895 adds LawfulBEq (Array α) ↔ LawfulBEq α.* #5896 moves @[simp] from back_eq_back? to back_push.* #5897 renames Array.back to back!.* List* #5605 removes List.redLength.* #5696 upstreams List.mapIdx and adds lemmas.* #5697 upstreams List.foldxM_map.* #5701 renames List.join to List.flatten.* #5703 upstreams List.sum.* #5706 marks prefix_append_right_inj as a simp lemma.* #5716 fixes List.drop_drop addition order.* #5731 renames List.bind and Array.concatMap to flatMap.* #5732 renames List.pure to List.singleton.* #5742 upstreams ne_of_mem_of_not_mem.* #5743 upstreams ne_of_apply_ne.* #5816 adds more List.modify lemmas.* #5879 renames List.groupBy to splitBy.* #5913 relates for loops over List with foldlM.* Nat* #5694 removes instBEqNat, which is redundant with instBEqOfDecidableEq but not defeq.* #5746 deprecates Nat.sum.* #5785 adds Nat.forall_lt_succ and variants.* Fixed width integers* #5323 redefine unsigned fixed width integers in terms of BitVec.* #5735 adds UIntX.[val_ofNat, toBitVec_ofNat].* #5790 defines Int8.* #5901 removes native code for UInt8.modn.* BitVec* #5604 completes BitVec.[getMsbD|getLsbD|msb] for shifts (@luisacicolini).* #5609 adds lemmas for division when denominator is zero (@bollu).* #5620 documents Bitblasting (@bollu)* #5623 moves BitVec.udiv/umod/sdiv/smod after add/sub/mul/lt (@tobiasgrosser).* #5645 defines udiv normal form to be /, resp. umod and % (@bollu).* #5646 adds lemmas about arithmetic inequalities (@bollu).* #5680 expands relationship with toFin (@tobiasgrosser).* #5691 adds BitVec.(getMSbD, msb)_(add, sub) and BitVec.getLsbD_sub (@luisacicolini).* #5712 adds BitVec.[udiv|umod]_[zero|one|self] (@tobiasgrosser).* #5718 adds BitVec.sdiv_[zero|one|self] (@tobiasgrosser).* #5721 adds BitVec.(msb, getMsbD, getLsbD)_(neg, abs) (@luisacicolini).* #5772 adds BitVec.toInt_sub, simplifies BitVec.toInt_neg (@tobiasgrosser).* #5778 prove that intMin the smallest signed bitvector (@alexkeizer).* #5851 adds (msb, getMsbD)_twoPow (@luisacicolini).* #5858 adds BitVec.[zero_ushiftRight|zero_sshiftRight|zero_mul] and cleans up BVDecide (@tobiasgrosser).* #5865 adds BitVec.(msb, getMsbD)_concat (@luisacicolini).* #5881 adds Hashable (BitVec n)* String/Char* #5728 upstreams String.dropPrefix?.* #5745 changes String.dropPrefix? signature.* #5747 adds Hashable Char instance* HashMap* #5880 adds interim implementation of HashMap.modify/alter* Other* #5704 removes @[simp] from Option.isSome_eq_isSome.* #5739 upstreams material on Prod.* #5740 moves Antisymm to Std.Antisymm.* #5741 upstreams basic material on Sum.* #5756 adds Nat.log2_two_pow (@spinylobster).* #5892 removes duplicated ForIn instances.* #5900 removes @[simp] from Sum.forall and Sum.exists.* #5812 removes redundant Decidable assumptions (@FR-vdash-bot).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.14.0 (2024-12-02)","header":"Library","id":"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Library"},"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Breaking-changes":{"contents":"* Due to the major Lake build refactor, code using the affected parts of the Lake API or relying on the previous output format of Lake builds is likely to have been broken. We have tried to minimize the breakages and, where possible, old definitions have been marked @[deprecated] with a reference to the new alternative.* Executables configured with supportInterpreter := true on Windows should now be run via lake exe to function properly.* Automatically generated equational theorems are now named using suffix .eq_<idx> instead of ._eq_<idx>, and .eq_def instead of ._unfold. Example:\n\ndef fact : Nat → Nat\n  | 0 => 1\n  | n+1 => (n+1) * fact n\n\ntheorem ex : fact 0 = 1 := by unfold fact; decide\n\n#check fact.eq_1\n-- fact.eq_1 : fact 0 = 1\n\n#check fact.eq_2\n-- fact.eq_2 (n : Nat) : fact (Nat.succ n) = (n + 1) * fact n\n\n#check fact.eq_def\n/-\nfact.eq_def :\n  ∀ (x : Nat),\n    fact x =\n      match x with\n      | 0 => 1\n      | Nat.succ n => (n + 1) * fact n\n-/\n\n\n* The coercion from String to Name was removed. Previously, it was Name.mkSimple, which does not separate strings at dots, but experience showed that this is not always the desired coercion. For the previous behavior, manually insert a call to Name.mkSimple.* The Subarray fields as, h₁ and h₂ have been renamed to array, start_le_stop, and stop_le_array_size, respectively. This more closely follows standard Lean conventions. Deprecated aliases for the field projections were added; these will be removed in a future release.* The change to the instance name algorithm (described above) can break projects that made use of the auto-generated names.* Option.toMonad has been renamed to Option.getM and the unneeded [Monad m] instance argument has been removed.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.8.0 (2024-06-05)","header":"Breaking changes","id":"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Breaking-changes"}});