window.docContents[98].resolve({"/Notations-and-Macros/Macros/#macro_rules":{"contents":"Rule-Based Macros With macro_rulesThe macro_rules command takes a sequence of rewrite rules, specified as syntax pattern matches, and adds each as a macro.\nThe rules are attempted in order, before previously-defined macros, and later macro definitions may add further macro rules.\n\nThe patterns in the macros must be quotation patterns.\nThey may match syntax from any syntax category, but a given pattern can only ever match a single syntax kind.\nIf no category or parser is specified for the quotation, then it may match terms or (sequences of) commands, but never both.\nIn case of ambiguity, the term parser is chosen.\n\nInternally, macros are tracked in a table that maps each syntax kind to its macros.\nThe macro_rules command may be explicitly annotated with a syntax kind.\n\nIf a syntax kind is explicitly provided, the macro definition checks that each quotation pattern has that kind.\nIf the parse result for the quotation was a choice node (that is, if the parse was ambiguous), then the pattern is duplicated once for each alternative with the specified kind.\nIt is an error if none of the alternatives have the specified kind.\n\nIf no kind is provided explicitly, then the kind determined by the parser is used for each pattern.\nThe patterns are not required to all have the same syntax kind; macros are defined for each syntax kind used by at least one of the patterns.\nIt is an error if the parse result for a quotation pattern was a choice node (that is, if the parse was ambiguous).\n\nThe documentation comment associated with macro_rules is displayed to users if the syntax itself has no documentation comment.\nOtherwise, the documentation comment for the syntax itself is shown.\n\nAs with notations and operators, macro rules may be declared scoped or local.\nScoped macros are only active when the current namespace is open, and local macro rules are only active in the current section scope.\n\nIdiom BracketsIdiom brackets are an alternative syntax for working with applicative functors.\nIf the idiom brackets contain a function application, then the function is wrapped in pure and applied to each argument using <*>. \nLean does not support idiom brackets by default, but they can be defined using a macro.syntax (name := idiom) \"⟦\" (term:arg)+ \"⟧\" : term\n\nmacro_rules\n  | `(⟦$f $args*⟧) => do\n    let mut out ← `(pure $f)\n    for arg in args do\n      out ← `($out <*> $arg)\n    return out\nThis new syntax can be used immediately.def addFirstThird [Add α] (xs : List α) : Option α :=\n  ⟦Add.add xs[0]? xs[2]?⟧\n#eval addFirstThird (α := Nat) []\nnone\n#eval addFirstThird [1]\nnone\n#eval addFirstThird [1,2,3,4]\nsome 4\n\n\nScoped MacrosScoped macro rules are active only in their namespace.\nWhen the namespace ConfusingNumbers is open, numeric literals will be assigned an incorrect meaning.namespace ConfusingNumbers\nThe following macro recognizes terms that are odd numeric literals, and replaces them with double their value.\nIf it unconditionally replaced them with double their value, then macro expansion would become an infinite loop because the same rule would always match the output.scoped macro_rules\n  | `($n:num) => do\n    if n.getNat % 2 = 0 then Lean.Macro.throwUnsupported\n    let n' := (n.getNat * 2)\n    `($(Syntax.mkNumLit (info := n.raw.getHeadInfo) (toString n')))\nOnce the namespace ends, the macro is no longer used.end ConfusingNumbers\nWithout opening the namespace, numeric literals function in the usual way.#eval (3, 4)\n(3, 4)\nWhen the namespace is open, the macro replaces 3 with 6.open ConfusingNumbers\n\n#eval (3, 4)\n(6, 4)\nIt is not typically useful to change the interpretation of numeric or other literals in macros.\nHowever, scoped macros can be very useful when adding new rules to extensible tactics such as trivial that work well with the contents of the namespaces but should not always be used.\n\nBehind the scenes, a macro_rules command generates one macro function for each syntax kind that is matched in its quote patterns.\nThis function has a default case that throws the unsupportedSyntax exception, so further macros may be attempted.\n\nA single macro_rules command with two rules is not always equivalent to two separate single-match commands.\nFirst, the rules in a macro_rules are tried from top to bottom, but recently-declared macros are attempted first, so the order would need to be reversed.\nAdditionally, if an earlier rule in the macro throws the unsupportedSyntax exception, then the later rules are not tried; if they were instead in separate macro_rules commands, then they would be attempted.\n\nOne vs. Two Sets of Macro RulesThe arbitrary! macro is intended to expand to some arbitrarily-determined value of a given type.syntax (name := arbitrary!) \"arbitrary! \" term:arg : term\nmacro_rules\n  | `(arbitrary! ()) => `(())\n  | `(arbitrary! Nat) => `(42)\n  | `(arbitrary! ($t1 × $t2)) => `((arbitrary! $t1, arbitrary! $t2))\n  | `(arbitrary! Nat) => `(0)\nUsers may extend it by defining further sets of macro rules, such as this rule for Empty that fails:macro_rules\n  | `(arbitrary! Empty) => throwUnsupported\n#eval arbitrary! (Nat × Nat)\n(42, 42)\nIf all of the macro rules had been defined as individual cases, then the result would have instead used the later case for Nat.\nThis is because the rules in a single macro_rules command are checked from top to bottom, but more recently-defined macro_rules commands take precedence over earlier ones.macro_rules\n  | `(arbitrary! ()) =>\n    `(())\nmacro_rules\n  | `(arbitrary! Nat) =>\n    `(42)\nmacro_rules\n  | `(arbitrary! ($t1 × $t2)) =>\n    `((arbitrary! $t1, arbitrary! $t2))\nmacro_rules\n  | `(arbitrary! Nat) =>\n    `(0)\nmacro_rules\n  | `(arbitrary! Empty) =>\n    throwUnsupported\n#eval arbitrary! (Nat × Nat)\n(0, 0)\nAdditionally, if any rule throws the unsupportedSyntax exception, no further rules in that command are checked.macro_rules\n  | `(arbitrary! (List Nat)) => throwUnsupported\n  | `(arbitrary! (List $_)) => `([])\n\nmacro_rules\n  | `(arbitrary! (Array Nat)) => `(#[42])\nmacro_rules\n  | `(arbitrary! (Array $_)) => throwUnsupported\nThe case for List Nat fails to elaborate, because macro expansion did not translate the arbitrary! syntax into something supported by the elaborator.#eval arbitrary! (List Nat)\nelaboration function for `arbitrary!` has not been implemented\n  arbitrary! (List Nat)\nThe case for Array Nat succeeds, because the first set of macro rules are attempted after the second throws the exception.#eval arbitrary! (Array Nat)\n#[42]\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009Defining Macros","header":"20.5.5.1. The  macro_rules  Command","id":"/Notations-and-Macros/Macros/#macro_rules"},"/Tactic-Proofs/Running-Tactics/#by":{"contents":"\n\nTactic Proofs with byTactics are included in terms using by, which is followed by a sequence of tactics in which each has the same indentation:Alternatively, explicit braces and semicolons may be used:\n\nTactics are invoked using the by term.\nWhen the elaborator encounters by, it invokes the tactic interpreter to construct the resulting term.\nTactic proofs may be embedded via by in any context in which a term can occur.\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.1. Running Tactics","id":"/Tactic-Proofs/Running-Tactics/#by"},"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-problem":{"contents":"Here is Rustan Leino's original description of the problem, as posted by Leonardo de Moura on the Lean Zulip:\n\nThe data structure is an expression with Boolean literals, variables, and if-then-else expressions.\n\n\n\nThe goal is to normalize such expressions into a form where:\n\na) No nested ifs: the condition part of an if-expression is not itself an if-expression\n\nb) No constant tests: the condition part of an if-expression is not a constant\n\nc) No redundant ifs: the then and else branches of an if are not the same\n\nd) Each variable is evaluated at most once: the free variables of the condition are disjoint from those in the then branch, and also disjoint from those in the else branch.\n\n\n\nOne should show that a normalization function produces an expression satisfying these four conditions, and one should also prove that the normalization function preserves the meaning of the given expression.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if - then - else  Normalization","header":"17.10.2.1. The problem","id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-problem"},"/Type-Classes/Instance-Declarations/#default-instances":{"contents":"The default_instance attribute specifies that an instance should be used as a fallback in situations where there is not enough information to select it otherwise.\nIf no priority is specified, then the default priority default is used.\n\nThe default_instance Attribute\n\nDefault InstancesA default instance of OfNat Nat is used to select Nat for natural number literals in the absence of other type information.\nIt is declared in the Lean standard library with priority 100.\nGiven this representation of even numbers, in which an even number is represented by half of it:structure Even where\n  half : Nat\nthe following instances allow numeric literals to be used for small Even values (a limit on the depth of type class instance search prevents them from being used for arbitrarily large literals):instance ofNatEven0 : OfNat Even 0 where\n  ofNat := ⟨0⟩\n\ninstance ofNatEvenPlusTwo [OfNat Even n] : OfNat Even (n + 2) where\n  ofNat := ⟨(OfNat.ofNat n : Even).half + 1⟩\n\n#eval (0 : Even)\n#eval (34 : Even)\n#eval (254 : Even)\n{ half := 0 }\n{ half := 17 }\n{ half := 127 }\nSpecifying them as default instances with a priority greater than or equal to 100 causes them to be used instead of Nat:attribute [default_instance 100] ofNatEven0\nattribute [default_instance 100] ofNatEvenPlusTwo\n#eval 0\n#eval 34\n{ half := 0 }\n{ half := 17 }\nNon-even numerals still use the OfNat Nat instance:#eval 5\n5\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Declarations","header":"11.2.4. Default Instances","id":"/Type-Classes/Instance-Declarations/#default-instances"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Separators-in-numeric-literals":{"contents":"#6204 lets _ be used in numeric literals as a separator. For\nexample, 1_000_000, 0xff_ff or 0b_10_11_01_00. New lexical syntax:\n\nnumeral10 : [0-9]+ (\"_\"+ [0-9]+)*\nnumeral2  : \"0\" [bB] (\"_\"* [0-1]+)+\nnumeral8  : \"0\" [oO] (\"_\"* [0-7]+)+\nnumeral16 : \"0\" [xX] (\"_\"* hex_char+)+\nfloat     : numeral10 \".\" numeral10? [eE[+-]numeral10]\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)\u0009Highlights","header":"Separators in numeric literals","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Separators-in-numeric-literals"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Compiler":{"contents":"* #9631 makes IO.RealWorld opaque. It also adds a new compiler -only\nlcRealWorld constant to represent this type within the compiler. By\ndefault, an opaque type definition is treated like lcAny, whereas we\nwant a more efficient representation. At the moment, this isn't a big\ndifference, but in the future we would like to completely erase\nIO.RealWorld at runtime.* #9922 changes internalizeCode to replace all substitutions with\nnon-param-bound fvars in Exprs (which are all types) with lcAny,\npreserving the invariant that there are no such dependencies. The\nviolation of this invariant across files caused test failures in a\npending PR, but it is difficult to write a direct test for it. In the\nfuture, we should probably change the LCNF checker to detect this.* #9972 fixes an issue when running Mathlib's FintypeCat as code,\nwhere an erased type former is passed to a polymorphic function. We were\nlowering the arrow type toobject, which conflicts with the runtime\nrepresentation of an erased value as a tagged scalar.* #9977 adds support for compilation of casesOn recursors of\nsubsingleton predicates.* #10023 adds support for correctly handling computations on fields in\ncasesOn for inductive predicates that support large elimination. In\nany such predicate, the only relevant fields allowed are those that are\nalso used as an index, in which case we can find the supplied index and\nuse that term instead.* #10032 changes the handling of overapplied constructors when lowering\nLCNF to IR from a (slightly implicit) assertion failure to producing\nunreachable. Transformations on inlined unreachable code can produce\nconstructor applications with additional arguments.* #10040 changes the toMono pass to replace decls with their _redArg\nequivalent, which has the consequence of not considering arguments\ndeemed useless by the reduceArity pass for the purposes of the\nnoncomputable check.* #10070 fixes the compilation of noConfusion by repairing an oversight\nmade when porting this code from the old compiler. The old compiler only\nrepeatedly expanded the major for each non-Prop field of the inductive\nunder consideration, mirroring the construction of noConfusion itself,\nwhereas the new compiler erroneously counted all fields.* #10133 fixes compatibility of Lean-generated executables with Unicode\nfile system paths on Windows* #10214 fixes #10213.* #10256 corrects a mistake in toIR where it could over-apply a\nfunction that has an IR decl but no mono decl.* #10355 changes toLCNF to convert .proj for builtin types to use\nprojection functions instead.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Compiler","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Compiler"}});