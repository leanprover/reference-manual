window.docContents[182].resolve({"/Basic-Types/Natural-Numbers/#nat-performance":{"contents":"Using Lean's built-in arithmetic operators, rather than redefining them, is essential.\nThe logical model of Nat is essentially a linked list, so addition would take time linear in the size of one argument.\nStill worse, multiplication takes quadratic time in this model.\nWhile defining arithmetic from scratch can be a useful learning exercise, these redefined operations will not be nearly as fast.\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009Run-Time Representation","header":"19.1.2.1. Performance Notes","id":"/Basic-Types/Natural-Numbers/#nat-performance"},"/The--grind--tactic/Constraint-Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint-Propagation--Propagation___Only-Examples":{"contents":"These goals are closed purely by constraint propagation—no case splits, no theory solvers:\n\n-- Boolean connective: a && !a is always false.\nexample (a : Bool) : (a && !a) = false := by\n  grind\n\n-- Conditional (ite):\n-- once the condition is true, ite picks the 'then' branch.\nexample (c : Bool) (t e : Nat) (h : c = true) :\n    (if c then t else e) = t := by\n  grind\n\n-- Negation propagates truth downwards.\nexample (a : Bool) (h : (!a) = true) : a = false := by\n  grind\n\n\nThese snippets run instantly because the relevant propagators (propagateBoolAndUp, propagateIte, propagateBoolNotDown) fire as soon as the hypotheses are internalized.\nSetting the option trace.grind.eqc to true causes grind to print a line every time two equivalence classes merge, which is handy for seeing propagation in action.\n\n\n\nThe set of propagation rules is expanded and refined over time, so the InfoView will show increasingly rich True and False buckets.\nThe full equivalence classes are displayed automatically only when grind fails, and only for the first subgoal that it could not close—use this output to inspect missing facts and understand why the subgoal remains open.\n\nIdentifying Missing FactsIn this example, grind fails:example :\n    x = y ∧ y = z →\n    w = x ∨ w = v →\n    w = z := by\n  grind\nThe resulting error message includes the identified equivalence classes along with the true and false propositions:`grind` failed\ncase grind\nα : Sort u_1\nx y z w v : α\nleft : x = y\nright : y = z\nh_1 : w = x ∨ w = v\nh_2 : ¬w = z\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n    [prop] w = x ∨ w = v\n    [prop] w = v\n  [eqc] False propositions\n    [prop] w = x\n    [prop] w = z\n  [eqc] Equivalence classes\n    [eqc] {x, y, z}\n    [eqc] {w, v}\nBoth x = y and y = z were discovered by constraint propagation from the x = y ∧ y = z premise.\nIn this proof, grind performed a case split on w = x ∨ w = v.\nIn the second branch, it could not place w and z in the same equivalence class.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Constraint Propagation","header":"17.4.1. Propagation‑Only Examples","id":"/The--grind--tactic/Constraint-Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint-Propagation--Propagation___Only-Examples"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Breaking-changes":{"contents":"#6330 removes unnecessary parameters from the functional induction\nprinciples. This is a breaking change; broken code can typically be adjusted\nsimply by passing fewer parameters.\n\nThis highlights section was contributed by Violetta Sim.\n\nFor this release, 201 changes landed. In addition to the 74 feature additions and 44 fixes listed below there were 7 refactoring changes, 5 documentation improvements and 62 chores.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)\u0009Highlights","header":"Breaking changes","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Breaking-changes"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Documentation":{"contents":"* #10632 adds missing docstrings for ByteArray and makes existing ones\nconsistent with our style.* #10640 adds a missing docstring and applies our style guide to parts of\nthe String API.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Documentation","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Documentation"}});