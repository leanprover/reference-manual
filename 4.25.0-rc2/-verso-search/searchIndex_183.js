window.docContents[183].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design":{"contents":"All the basic operations on maps and sets are fully verified.\nThey are proven correct with respect to simpler models implemented with lists.\nAt the same time, maps and sets have predictable performance.\n\nSome types include additional operations that are not yet fully verified.\nThese operations are useful, and not all programs need full verification.\nExamples include HashMap.partition and TreeMap.filterMap.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.18.1. Library Design","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design"},"/Basic-Types/Strings/#string-ffi":{"contents":"The representation of strings in C. See the description of run-time Strings for more details.\n\nReturns true if o is a string, or false otherwise.\n\nPerforms a runtime check that o is indeed a string. If o is not a string, an assertion fails.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings","header":"19.8.5. FFI","id":"/Basic-Types/Strings/#string-ffi"},"/Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation--The-Kernel":{"contents":"Lean's trusted kernel is a small, robust implementation of a type checker for the core type theory.\nIt does not include a syntactic termination checker, nor does it perform unification; termination is guaranteed by elaborating all recursive functions into uses of primitive recursors, and unification is expected to have already been carried out by the elaborator.\nBefore new inductive types or definitions are added to the environment by the command or term elaborators, they must be checked by the kernel to guard against potential bugs in elaboration.\n\nLean's kernel is written in C++.\nThere are independent re-implementations in Rust and Lean, and the Lean project is interested in having as many implementations as possible so that they can be cross-checked against each other.\n\nThe language implemented by the kernel is a version of the Calculus of Constructions, a dependent type theory with the following features:\n\n* Full dependent types* Inductively-defined types that may be mutually inductive or include recursion nested under other inductive types* An impredicative, definitionally proof-irrelevant, extensional universe of propositions* A predicative, non-cumulative hierarchy of universes of data* Quotient types with a definitional computation rule* Propositional function extensionalityFunction extensionality is a theorem that can be proved using quotient types, but it is such an important consequence that it's worth listing separately.* Definitional η-equality for functions and products* Universe-polymorphic definitions* Consistency: there is no axiom-free closed term of type False\n\n\n\nThis theory is rich enough to express leading-edge research mathematics, and yet simple enough to admit a small, efficient implementation.\nThe presence of explicit proof terms makes it feasible to implement independent proof checkers, increasing our confidence.\nIt is described in detail by  and .\n\nLean's type theory does not feature subject reduction, the definitional equality is not necessarily transitive, and it is possible to make the type checker fail to terminate.\nNone of these metatheoretic properties cause problems in practice—failures of transitivity are exceedingly rare, and as far as we know, non-termination has not occurred except when crafting code specifically to exercise it.\nMost importantly, logical soundness is not affected.\nIn practice, apparent non-termination is indistinguishable from sufficiently slow programs; the latter are the causes observed in the wild.\nThese metatheoretic properties are a result of having impredicativity, quotient types that compute, definitional proof irrelevance, and propositional extensionality; these features are immensely valuable both to support ordinary mathematical practice and to enable automation.\n\n","context":"Lean Reference\u0009Elaboration and Compilation","header":"2.3. The Kernel","id":"/Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation--The-Kernel"},"/Terms/#terms":{"contents":"Terms are the principal means of writing mathematics and programs in Lean.\nThe elaborator translates them to Lean's minimal core language, which is then checked by the kernel and compiled for execution.\nThe syntax of terms is arbitrarily extensible; this chapter documents the term syntax that Lean provides out-of-the-box.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"10. Terms","id":"/Terms/#terms"},"/The-Type-System/#type-system":{"contents":"Terms, also known as expressions, are the fundamental units of meaning in Lean's core language.\nThey are produced from user-written syntax by the elaborator.\nLean's type system relates terms to their types, which are also themselves terms.\nTypes can be thought of as denoting sets, while terms denote individual elements of these sets.\nA term is well-typed if it has a type under the rules of Lean's type theory.\nOnly well-typed terms have a meaning.\n\nTerms are a dependently typed λ-calculus: they include function abstraction, application, variables, and let-bindings.\nIn addition to bound variables, variables in the term language may refer to constructors, type constructors, recursors, defined constants, or opaque constants.\nConstructors, type constructors, recursors, and opaque constants are not subject to substitution, while defined constants may be replaced with their definitions.\n\nA derivation demonstrates the well-typedness of a term by explicitly indicating the precise inference rules that are used.\nImplicitly, well-typed terms can stand in for the derivations that demonstrate their well-typedness.\nLean's type theory is explicit enough that derivations can be reconstructed from well-typed terms, which greatly reduces the overhead that would be incurred from storing a complete derivation, while still being expressive enough to represent modern research mathematics.\nThis means that proof terms are sufficient evidence of the truth of a theorem and are amenable to independent verification.\n\nIn addition to having types, terms are also related by definitional equality.\nThis is the mechanically-checkable relation that syntactically equates terms modulo their computational behavior.\nDefinitional equality includes the following forms of reduction:\n\n β (beta)\n\nApplying a function abstraction to an argument by substitution for the bound variable\n\n δ (delta)\n\nReplacing occurrences of defined constants by the definition's value\n\n ι (iota)\n\nReduction of recursors whose targets are constructors (primitive recursion)\n\n ζ (zeta)\n\nReplacement of let-bound variables by their defined values\n\n Quotient reduction\n\nReduction of the quotient type's function lifting operator when applied to an element of a quotient\n\n\n\nTerms in which all possible reductions have been carried out are in normal form.\n\nDefinitional equality includes η-equivalence of functions and single-constructor inductive types.\nThat is, fun x => f x is definitionally equal to f, and S.mk x.f1 x.f2 is definitionally equal to x, if S is a structure with fields f1 and f2.\nIt also features proof irrelevance: any two proofs of the same proposition are definitionally equal.\nIt is reflexive and symmetric, but not transitive.\n\nDefinitional equality is used by conversion: if two terms are definitionally equal, and a given term has one of them as its type, then it also has the other as its type.\nBecause definitional equality includes reduction, types can result from computations over data.\n\nComputing typesWhen passed a natural number, the function LengthList computes a type that corresponds to a list with precisely that many entries in it:def LengthList (α : Type u) : Nat → Type u\n  | 0 => PUnit\n  | n + 1 => α × LengthList α n\nBecause Lean's tuples nest to the right, multiple nested parentheses are not needed:example : LengthList Int 0 := ()\n\nexample : LengthList String 2 :=\n  (\"Hello\", \"there\", ())\nIf the length does not match the number of entries, then the computed type will not match the term:example : LengthList String 5 :=\n  (\"Wrong\", \"number\", ())\nApplication type mismatch: The argument\n  ()\nhas type\n  Unit\nbut is expected to have type\n  LengthList String 3\nin the application\n  (\"number\", ())\n\n\nThe basic types in Lean are universes, function types, the quotient former Quot, and type constructors of inductive types.\nDefined constants, applications of recursors, function application, axioms or opaque constants may additionally give types, just as they can give rise to terms in any other type.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"4. The Type System","id":"/The-Type-System/#type-system"}});