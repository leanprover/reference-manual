window.docContents[31].resolve({"/Basic-Types/Subtypes/#Subtype":{"contents":"The structure Subtype represents the elements of a type that satisfy some predicate.\nThey are used pervasively both in mathematics and in programming; in mathematics, they are used similarly to subsets, while in programming, they allow information that is known about a value to be represented in a way that is visible to Lean's logic.\n\nSyntactically, an element of a Subtype resembles a tuple of the base type's element and the proof that it satisfies the proposition.\nThey differ from dependent pair types (Sigma) in that the second element is a proof of a proposition rather than data, and from existential quantification in that the entire Subtype is a type rather than a proposition.\nEven though they are pairs syntactically, Subtype should really be thought of as elements of the base type with associated proof obligations.\n\nSubtypes are trivial wrappers.\nThey are thus represented identically to the base type in compiled code.\n\nAll the elements of a type that satisfy a predicate.Subtype p, usually written { x : α // p x } or { x // p x }, contains all elements x : α for\nwhich p x is true. Its constructor is a pair of the value and the proof that it satisfies the\npredicate. In run-time code, { x : α // p x } is represented identically to α.There is a coercion from { x : α // p x } to α, so elements of a subtype may be used where the\nunderlying type is expected.Examples:* { n : Nat // n % 2 = 0 } is the type of even numbers.* { xs : Array String // xs.size = 5 } is the type of arrays with five Strings.* Given xs : List α, List { x : α // x ∈ xs } is the type of lists in which all elements are\ncontained in xs.Conventions for notations in identifiers:* The recommended spelling of { x // p x } in identifiers is subtype.The value in the underlying type that satisfies the predicate.The proof that val satisfies the predicate p.\n\nSubtypes{ x : α // p } is a notation for Subtype fun (x : α) => p.The type ascription may be omitted:{ x // p } is a notation for Subtype fun (x : _) => p.\n\nDue to proof irrelevance and η-equality, two elements of a subtype are definitionally equal when the elements of the base type are definitionally equal.\nIn a proof, the ext tactic can be used to transform a goal of equality of elements of a subtype into equality of their values.\n\nDefinitional Equality of SubtypesThe non-empty strings s1 and s2 are definitionally equal despite the fact that their embedded proof terms are different.\nNo case splitting is needed in order to prove that they are equal.def NonEmptyString := { x : String // x ≠ \"\" }\n\ndef s1 : NonEmptyString :=\n  ⟨\"equal\", ne_of_beq_false rfl⟩\n\ndef s2 : NonEmptyString where\n  val := \"equal\"\n  property :=\n    fun h =>\n      List.cons_ne_nil _ _ (String.data_eq_of_eq h)\n\ntheorem s1_eq_s2 : s1 = s2 := by rfl\n\n\nExtensional Equality of SubtypesThe non-empty strings s1 and s2 are definitionally equal.\nIgnoring that fact, the equality of the embedded strings can be used to prove that they are equal.\nThe ext tactic transforms a goal that consists of equality of non-empty strings into a goal that consists of equality of the strings.abbrev NonEmptyString := { x : String // x ≠ \"\" }\n\ndef s1 : NonEmptyString :=\n  ⟨\"equal\", ne_of_beq_false rfl⟩\n\ndef s2 : NonEmptyString where\n  val := \"equal\"\n  property :=\n    fun h =>\n      List.cons_ne_nil _ _ (String.data_eq_of_eq h)\n\ntheorem s1_eq_s2 : s1 = s2 := by\n  ext\n  dsimp only [s1, s2]\n  rfl\n\n\nThere is a coercion from a subtype to its base type.\nThis allows subtypes to be used in positions where the base type is expected, essentially erasing the proof that the value satisfies the predicate.\n\nSubtype CoercionsElements of subtypes can be coerced to their base type.\nHere, nine is coerced from a subtype of Nat that contains multiples of 3 to Nat.abbrev DivBy3 := { x : Nat // x % 3 = 0 }\n\ndef nine : DivBy3 := ⟨9, by rfl⟩\n\nset_option eval.type true in\n#eval Nat.succ nine\n10 : Nat\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.19. Subtypes","id":"/Basic-Types/Subtypes/#Subtype"},"/Definitions/Recursive-Definitions/#mutual-well-founded-recursion":{"contents":"Lean supports the definition of mutually recursive functions using well-founded recursion.\nMutual recursion may be introduced using a mutual block, but it also results from let rec expressions and where blocks.\nThe rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the elaboration steps for mutual groups.\n\nIf any function in the mutual group has a termination_by or decreasing_by clause, well-founded recursion is attempted.\nIf a termination measure is specified using termination_by for any function in the mutual group, then all functions in the group must specify a termination measure, and they have to have the same type.\n\nIf no termination argument is specified, the termination argument is inferred, as described above. In the case of mutual recursion, a third class of basic measures is considered during inference, namely for each function in the mutual group the measure that is 1 for that function and 0 for the others. This allows Lean to order the functions so that some calls from one function to another are allowed even if the parameters do not decrease.\n\nMutual recursion without parameter decreaseIn the following mutual function definitions, the parameter does not decrease in the call from g to f.\nNonetheless, the definition is accepted due to the ordering imposed on the functions themselves by the additional basic measure.mutual\n  def f : (n : Nat) → Nat\n    | 0 => 0\n    | n + 1 => g n\n  termination_by?\n\n  def g (n : Nat) : Nat := (f n) + 1\n  termination_by?\nend\nThe inferred termination argument for f is:Try this:\n  [apply] termination_by n => (n, 0)\nThe inferred termination argument for g is:Try this:\n  [apply] termination_by (n, 1)\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","header":"7.6.3.5. Mutual Well-Founded Recursion","id":"/Definitions/Recursive-Definitions/#mutual-well-founded-recursion"},"/Tactic-Proofs/Reading-Proof-States/#hiding-terms-in-proof-states":{"contents":"Terms in proof states can be quite big, and there may be many assumptions.\nBecause of definitional proof irrelevance, proof terms typically give little useful information.\nBy default, they are not shown in goals in proof states unless they are atomic, meaning that they contain no subterms.\nHiding proofs is controlled by two options: pp.proofs turns the feature on and off, while pp.proofs.threshold determines a size threshold for proof hiding.\n\nHiding Proof TermsIn this proof state, the proof that 0 < n is hidden.n : Nat\ni : Fin n\ngt : ↑i > 5\n⊢ ⟨0, ⋯⟩ < i\n\n(pretty printer) display proofs when true, and replace proofs appearing within expressions by ⋯ when false\n\n(pretty printer) when pp.proofs is false, controls the complexity of proofs at which they begin being replaced with ⋯\n\nAdditionally, non-proof terms may be hidden when they are too large.\nIn particular, Lean will hide terms that are below a configurable depth threshold, and it will hide the remainder of a term once a certain amount in total has been printed.\nShowing deep terms can be enabled or disabled with the option pp.deepTerms, and the depth threshold can be configured with the option pp.deepTerms.threshold.\nThe maximum number of pretty printer steps can be configured with the option pp.maxSteps.\nPrinting very large terms can lead to slowdowns or even stack overflows in tooling; please be conservative when adjusting these options' values.\n\n(pretty printer) display deeply nested terms, replacing them with ⋯ if set to false\n\n(pretty printer) when pp.deepTerms is false, the depth at which terms start being replaced with ⋯\n\n(pretty printer) maximum number of expressions to visit, after which terms will pretty print as ⋯\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Reading Proof States","header":"13.2.1. Hiding Proofs and Large Terms","id":"/Tactic-Proofs/Reading-Proof-States/#hiding-terms-in-proof-states"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-decision":{"contents":"decide attempts to prove the main goal (with target type p) by synthesizing an instance of Decidable p\nand then reducing that instance to evaluate the truth value of p.\nIf it reduces to isTrue h, then h is a proof of p that closes the goal.The target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the revert tactic with these local variables to move them into the target,\nor you can use the +revert option, described below.Options:* decide +revert begins by reverting local variables that the target depends on,\nafter cleaning up the local context of irrelevant variables.\nA variable is relevant if it appears in the target, if it appears in a relevant variable,\nor if it is a proposition that refers to a relevant variable.* decide +kernel uses kernel for reduction instead of the elaborator.\nIt has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\nand (2) it reduces the Decidable instance only once instead of twice.* decide +native uses the native code compiler (#eval) to evaluate the Decidable instance,\nadmitting the result via the Lean.ofReduceBool axiom.\nThis can be significantly more efficient than using reduction, but it is at the cost of increasing the size\nof the trusted code base.\nNamely, it depends on the correctness of the Lean compiler and all definitions with an @[implemented_by] attribute.\nLike with +kernel, the Decidable instance is evaluated only once.Limitation: In the default mode or +kernel mode, since decide uses reduction to evaluate the term,\nDecidable instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on Decidable instances with Eq.rec terms.\nThese can appear in instances defined using tactics (such as rw and simp).\nTo avoid this, create such instances using definitions such as decidable_of_iff instead.ExamplesProving inequalities:example : 2 + 2 ≠ 5 := by decide\nTrying to prove a false proposition:example : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\nTrying to prove a proposition whose Decidable instance fails to reduceopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\nProperties and relationsFor equality goals for types with decidable equality, usually rfl can be used in place of decide.example : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n\n\nnative_decide is a synonym for decide +native.\nIt will attempt to prove a goal of type p by synthesizing an instance\nof Decidable p and then evaluating it to isTrue ... Unlike decide, this\nuses #eval to evaluate the decidability instance.This should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom Lean.ofReduceBool will show up in #print axioms for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using decide, and for very\nlarge computations this is one way to run external programs and trust the result.example : (List.range 1000).length = 1000 := by native_decide\n\n\nThe omega tactic, for resolving integer and natural linear arithmetic problems.It is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.We handle hypotheses of the form x = y, x < y, x ≤ y, and k ∣ x for x y in Nat or Int\n(and k a literal), along with negations of these statements.We decompose the sides of the inequalities as linear combinations of atoms.If we encounter x / k or x % k for literal integers k we introduce new auxiliary variables\nand the relevant inequalities.On the first pass, we do not perform case splits on natural subtraction.\nIf omega fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.The optionsomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\ncan be used to:* splitDisjunctions: split any disjunctions found in the context,\nif the problem is not otherwise solvable.* splitNatSub: for each appearance of ((a - b : Nat) : Int), split on a ≤ b if necessary.* splitNatAbs: for each appearance of Int.natAbs a, split on 0 ≤ a if necessary.* splitMinMax: for each occurrence of min a b, split on min a b = a ∨ min a b = b\nCurrently, all of these are on by default.\n\nbv_omega is omega with an additional preprocessor that turns statements about BitVec into statements about Nat.\nCurrently the preprocessor is implemented as try simp only [bitvec_to_nat] at *.\nbitvec_to_nat is a @[simp] attribute that you can (cautiously) add to more theorems.\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.17. Decision Procedures","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-decision"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Experimental___-module-system":{"contents":"The new module system (enabled by the module keyword before import statements) is available\nfor experimentation.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Experimental: module system","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Experimental___-module-system"},"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--DevOps":{"contents":"* #3984 adds a script (script/rebase-stage0.sh) for git rebase -i that automatically updates each stage0.* #4108 finishes renamings from transition to Std to Batteries.* #4109 adjusts the Github bug template to mention testing using live.lean-lang.org.* #4136 makes CI rerun only when full-ci label is added or removed.* #4175 and 72b345\nswitch to using #guard_msgs to run tests as much as possible.* #3125 explains the Lean4 pygments lexer.* #4247 sets up a procedure for preparing release notes.* #4032 modernizes build instructions and workflows.* #4255 moves some expensive checks from merge queue to releases.* #4265 adds aarch64 macOS as native compilation target for CI.* f05a82 restores macOS aarch64 install suffix in CI* #4317 updates build instructions for macOS.* #4333 adjusts workflow to update Batteries in manifest when creating lean-pr-testing-NNNN Mathlib branches.* #4355 simplifies lean4checker step of release checklist.* #4361 adds installing elan to pr-release CI step.* #4628 fixes the Windows build, which was missing an exported symbol.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.9.0 (2024-07-01)","header":"DevOps","id":"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--DevOps"}});