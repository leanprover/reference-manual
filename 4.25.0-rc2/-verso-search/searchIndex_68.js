window.docContents[68].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Creation":{"contents":"Creates a new empty tree map. It is also possible and recommended to\nuse the empty collection notations ∅ and {} to create an empty tree map. simp replaces\nempty with ∅.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps","header":"19.18.8.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Creation"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Equality":{"contents":"Checks whether s1 and s2 represent the same string, even if they are slices of\ndifferent base strings or different slices within the same string.The implementation is an efficient equivalent of s1.copy == s2.copy\n\nChecks whether s1 == s2 if ASCII upper/lowercase are ignored.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.11. Equality","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Equality"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors":{"contents":"\n\nApplicative Operatorsg <*> x is short for Seq.seq g (fun () => x).\nThe function is inserted to delay evaluation because control might not reach the argument.e1 *> e2 is short for SeqRight.seqRight e1 (fun () => e2).e1 <* e2 is short for SeqLeft.seqLeft e1 (fun () => e2).\n\nMany applicative functors also support failure and recovery via the Alternative type class.\nThis class also has an infix operator.\n\nAlternative Operatorse <|> e' is short for OrElse.orElse e (fun () => e').\nThe function is inserted to delay evaluation because control might not reach the argument.\n\n\n\nstructure User where\n  name : String\n  favoriteNat : Nat\ndef main : IO Unit := pure ()\nInfix Functor and Applicative OperatorsA common functional programming idiom is to use a pure function in some context with effects by applying it via Functor.map and Seq.seq.\nThe function is applied to its sequence of arguments using <$>, and the arguments are separated by <*>.In this example, the constructor User.mk is applied via this idiom in the body of main.def getName : IO String := do\n  IO.println \"What is your name?\"\n  return (← (← IO.getStdin).getLine).trimRight\n\npartial def getFavoriteNat : IO Nat := do\n  IO.println \"What is your favorite natural number?\"\n  let line ← (← IO.getStdin).getLine\n  if let some n := line.trim.toNat? then\n    return n\n  else\n    IO.println \"Let's try again.\"\n    getFavoriteNat\n\nstructure User where\n  name : String\n  favoriteNat : Nat\nderiving Repr\n\ndef main : IO Unit := do\n  let user ← User.mk <$> getName <*> getFavoriteNat\n  IO.println (repr user)\nWhen run with this input:A. Lean User\nNone\n42\nit produces this output:What is your name?\nWhat is your favorite natural number?\nLet's try again.\nWhat is your favorite natural number?\n{ name := \"A. Lean User\", favoriteNat := 42 }\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009Infix Operators","header":"14.3.1.2. Applicative Functors","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--grind-Tactic":{"contents":"The grind tactic is still is experimental and still under development. Avoid using it in production projects\n\n* #6902 ensures simp diagnostic information in included in the grind\ndiagnostic message.* #6937 improves grind error and trace messages by cleaning up local\ndeclaration names.* #6940 improves how the grind tactic performs case splits on p <-> q.* #7102 modifies grind to run with the reducible transparency\nsetting. We do not want grind to unfold arbitrary terms during\ndefinitional equality tests. also fixes several issues\nintroduced by this change. The most common problem was the lack of a\nhint in proofs, particularly in those constructed using proof by\nreflection. also introduces new sanity checks when set_option grind.debug true is used.* #7231 implements functions for constructing disequality proofs in\ngrind.\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"grind Tactic","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--grind-Tactic"}});