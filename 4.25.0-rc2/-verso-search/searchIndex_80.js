window.docContents[80].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Size":{"contents":"Gets the number of elements stored in an array.This is a cached value, so it is O(1) to access. The space allocated for an array, referred to as\nits capacity, is at least as large as its size, but may be larger. The capacity of an array is an\ninternal detail that's not observable by Lean code.\n\nReturns the size of the array as a platform-native unsigned integer.This is a low-level version of Array.size that directly queries the runtime system's\nrepresentation of arrays. While this is not provable, Array.usize always returns the exact size of\nthe array since the implementation only supports arrays of size less than USize.size.\n\nChecks whether an array is empty.An array is empty if its size is 0.Examples:* (#[] : Array String).isEmpty = true* #[1, 2].isEmpty = false* #[()].isEmpty = false\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.2. Size","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Size"},"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--Syntax":{"contents":"Lean does not have dedicated floating-point literals.\nInstead, floating-point literals are resolved via the appropriate instances of the OfScientific and Neg type classes.\n\nFloating-Point LiteralsThe term(-2.523 : Float)\nis syntactic sugar for(Neg.neg (OfScientific.ofScientific 22523 true 4) : Float)\nand the term(413.52 : Float32)\nis syntactic sugar for(OfScientific.ofScientific 41352 true 2 : Float32)\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers","header":"19.6.1. Syntax","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--Syntax"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key. There is also a Prop-valued version\nof this: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for comparisons, while for hash maps, both use ==.\n\nRetrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof\nof a ∈ m.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, panicking if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning none if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Dependent Hash Maps","header":"19.18.5.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Queries"},"/Basic-Types/Optional-Values/#option":{"contents":"Option α is the type of values which are either some v for some v﻿:﻿α, or none.\nIn functional programming, this type is used similarly to nullable types: none represents the absence of a value.\nAdditionally, partial functions from α to β can be represented by the type α → Option β, where none results when the function is undefined for some input.\nComputationally, these partial functions represent the possibility of failure or errors, and they correspond to a program that can terminate early but not throw an informative exception.Option can also be thought of as being similar to a list that contains at most one element.\nFrom this perspective, iterating over Option consists of carrying out an operation only when a value is present.\nThe Option API makes frequent use of this perspective.Options as NullabilityThe function Std.HashMap.get? looks up a specified key a : α inside a HashMap α β:Std.HashMap.get?.{u, v} {α : Type u} {β : Type v}\n  [BEq α] [Hashable α]\n  (m : HashMap α β) (a : α) :\n  Option β\nBecause there is no way to know in advance whether the key is actually in the map, the return type is Option β, where none means the key was not in the map, and some b means that the key was found and b is the value retrieved.The xs[i] syntax, which is used to index into collections when there is an available proof that i is a valid index into xs, has a variant xs[i]? that returns an optional value depending on whether the given index is valid.\nIf m﻿:﻿HashMap α β and a﻿:﻿α, then m[a]? is equivalent to HashMap.get? m a.Options as Safe NullabilityIn many programming languages, it is important to remember to check for the null value.\nWhen using Option, the type system requires these checks in the right places: Option α and α are not the same type, and converting from one to the other requires handling the case of none.\nThis can be done via helpers such as Option.getD, or with pattern matching.def postalCodes : Std.HashMap Nat String :=\n  .empty |>.insert 12345 \"Schenectady\"\n#eval postalCodes[12346]?.getD \"not found\"\n\"not found\"\n#eval\n  match postalCodes[12346]? with\n  | none => \"not found\"\n  | some city => city\n\"not found\"\n#eval\n  if let some city := postalCodes[12345]? then\n    city\n  else\n    \"not found\"\n\"Schenectady\"\n\n\nOptional values, which are either some around a value from the underlying type or none.Option can represent nullable types or computations that might fail. In the codomain of a function\ntype, it can also represent partiality.No value.Some value of type α.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.12. Optional Values","id":"/Basic-Types/Optional-Values/#option"},"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Ordering":{"contents":"Lexicographical order for products.Two pairs are lexicographically ordered if their first elements are ordered or if their first\nelements are equal and their second elements are ordered.\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples\u0009Ordered Pairs\u0009API Reference","header":"19.13.1.1.3. Ordering","id":"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Ordering"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-lemmas":{"contents":"exact e closes the main goal if its target type matches that of e.\n\napply e tries to match the current goal against the conclusion of e's type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.The apply tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n\nrefine e behaves like exact e, except that named (?x) or unnamed (?_)\nholes in e that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n\nrefine' e behaves like refine e, except that unsolved placeholders (_)\nand implicit parameters are also converted into new goals.\n\nsolve_by_elim calls apply on the main goal to find an assumption whose head matches\nand then repeatedly calls apply on the generated subgoals until no subgoals remain,\nperforming at most maxDepth (defaults to 6) recursive steps.solve_by_elim discharges the current goal or fails.solve_by_elim performs backtracking if subgoals can not be solved.By default, the assumptions passed to apply are the local context, rfl, trivial,\ncongrFun and congrArg.The assumptions can be modified with similar syntax as for simp:* solve_by_elim [h₁, h₂, ..., hᵣ] also applies the given expressions.* solve_by_elim only [h₁, h₂, ..., hᵣ] does not include the local context,\nrfl, trivial, congrFun, or congrArg unless they are explicitly included.* solve_by_elim [-h₁, ... -hₙ] removes the given local hypotheses.* solve_by_elim using [a₁, ...] uses all lemmas which have been labelled\nwith the attributes aᵢ (these attributes must be created using register_label_attr).solve_by_elim* tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)Optional arguments passed via a configuration argument as solve_by_elim (config := { ... })* maxDepth: number of attempts at discharging generated subgoals* symm: adds all hypotheses derived by symm (defaults to true).* exfalso: allow calling exfalso and trying again if solve_by_elim fails\n(defaults to true).* transparency: change the transparency mode when calling apply. Defaults to .default,\nbut it is often useful to change to .reducible,\nso semireducible definitions will not be unfolded when trying to apply a lemma.See also the doc-comment for Lean.Meta.Tactic.Backtrack.BacktrackConfig for the options\nproc, suspend, and discharge which allow further customization of solve_by_elim.\nBoth apply_assumption and apply_rules are implemented via these hooks.\n\napply_rules [l₁, l₂, ...] tries to solve the main goal by iteratively\napplying the list of lemmas [l₁, l₂, ...] or by applying a local hypothesis.\nIf apply generates new goals, apply_rules iteratively tries to solve those goals.\nYou can use apply_rules [-h] to omit a local hypothesis.apply_rules will also use rfl, trivial, congrFun and congrArg.\nThese can be disabled, as can local hypotheses, by using apply_rules only [...].You can use apply_rules using [a₁, ...] to use all lemmas which have been labelled\nwith the attributes aᵢ (these attributes must be created using register_label_attr).You can pass a further configuration via the syntax apply_rules (config := {...}).\nThe options supported are the same as for solve_by_elim (and include all the options for apply).apply_rules will try calling symm on hypotheses and exfalso on the goal as needed.\nThis can be disabled with apply_rules (config := {symm := false, exfalso := false}).You can bound the iteration depth using the syntax apply_rules (config := {maxDepth := n}).Unlike solve_by_elim, apply_rules does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n\nas_aux_lemma => tac does the same as tac, except that it wraps the resulting expression\ninto an auxiliary lemma. In some cases, this significantly reduces the size of expressions\nbecause the proof term is not duplicated.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.6. Lemmas","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-lemmas"}});