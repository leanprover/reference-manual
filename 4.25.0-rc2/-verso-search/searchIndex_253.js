window.docContents[253].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Bytes":{"contents":"Accesses the indicated byte in the UTF-8 encoding of a string slice.At runtime, this function is implemented by efficient, constant-time code.\n\nAccesses the indicated byte in the UTF-8 encoding of the string slice, or panics if the position\nis out-of-bounds.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.5. Bytes","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Bytes"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Library":{"contents":"* #6182 adds BitVec.[toInt|toFin]_concat and moves a couple of\ntheorems into the concat section, as BitVec.msb_concat is needed for\nthe toInt_concat proof.* #6188 completes the toNat theorems for the bitwise operations\n(and, or, xor, shiftLeft, shiftRight) of the UInt types and\nadds toBitVec theorems as well. It also renames and_toNat to\ntoNat_and to fit with the current naming convention.* #6238 adds theorems characterizing the value of the unsigned shift\nright of a bitvector in terms of its 2s complement interpretation as an\ninteger.\nUnsigned shift right by at least one bit makes the value of the\nbitvector less than or equal to 2^(w-1),\nmakes the interpretation of the bitvector Int and Nat agree.\nIn the case when n = 0, then the shift right value equals the integer\ninterpretation.* #6244 changes the implementation of HashMap.toList, so the ordering\nagrees with HashMap.toArray.* #6272 introduces the basic theory of permutations of Arrays and\nproves Array.swap_perm.* #6282 moves IO.Channel and IO.Mutex from Init to Std.Sync and\nrenames them to Std.Channel and Std.Mutex.* #6294 upstreams List.length_flatMap, countP_flatMap and\ncount_flatMap from Mathlib. These were not possible to state before we\nupstreamed List.sum.* #6315 adds protected to Fin.cast and BitVec.cast, to avoid\nconfusion with _root_.cast. These should mostly be used via\ndot-notation in any case.* #6316 adds lemmas simplifying for loops over Option into\nOption.pelim, giving parity with lemmas simplifying for loops of\nList into List.fold.* #6317 completes the basic API for BitVec.ofBool.* #6318 generalizes the universe level for Array.find?, by giving it a\nseparate implementation from Array.findM?.* #6324 adds GetElem lemmas for the basic Vector operations.* #6333 generalizes the panic functions to a type of Sort u rather\nthan Type u. This better supports universe polymorphic types and\navoids confusing errors.* #6334 adds Nat theorems for distributing >>> over bitwise\noperations, paralleling those of BitVec.* #6338 adds BitVec.[toFin|getMsbD]_setWidth and\n[getMsb|msb]_signExtend as well as ofInt_toInt.* #6341 generalizes DecidableRel to allow a heterogeneous relation.* #6353 reproduces the API around List.any/all for Array.any/all.* #6364 makes fixes suggested by the Batteries environment linters,\nparticularly simpNF, and unusedHavesSuffices.* #6365 expands the Array.set and Array.setIfInBounds lemmas to\nmatch existing lemmas for List.set.* #6367 brings Vector lemmas about membership and indexing to parity\nwith List and Array.* #6369 adds lemmas about Vector.set, anyM, any, allM, and\nall.* #6376 adds theorems about == on Vector, reproducing those already\non List and Array.* #6379 replaces the inductive predicate List.lt with an upstreamed version of List.Lex from Mathlib.\n(Previously Lex.lt was defined in terms of <; now it is generalized to take an arbitrary relation.)\nThis subtly changes the notion of ordering on List α.List.lt was a weaker relation: in particular if l₁ < l₂, then a :: l₁ < b :: l₂ may hold according to List.lt even if a and b are merely incomparable (either neither a < b nor b < a), whereas according to List.Lex this would require a = b.When < is total, in the sense that ¬ · < · is antisymmetric, then the two relations coincide.Mathlib was already overriding the order instances for List α, so this change should not be noticed by anyone already using Mathlib.We simultaneously add the boolean valued List.lex function, parameterised by a BEq typeclass and an arbitrary lt function. This will support the flexibility previously provided for List.lt, via a == function which is weaker than strict equality.* #6390 redefines Range.forIn' and Range.forM, in preparation for\nwriting lemmas about them.* #6391 requires that the step size in Std.Range is positive, to avoid\nill-specified behaviour.* #6396 adds lemmas reducing for loops over Std.Range to for loops\nover List.range'.* #6399 adds basic lemmas about lexicographic order on Array and Vector,\nachieving parity with List.* #6423 adds missing lemmas about lexicographic order on\nList/Array/Vector.* #6477 adds the necessary domain theory that backs the\npartial_fixpoint feature.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Library","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Library"}});