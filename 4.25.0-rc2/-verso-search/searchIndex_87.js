window.docContents[87].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Constructing-Arrays":{"contents":"Constructs a new empty array with initial capacity 0.Use Array.emptyWithCapacity to create an array with a greater initial capacity.\n\nConstructs a new empty array with initial capacity c.\n\nConstructs a single-element array that contains v.Examples:* Array.singleton 5 = #[5]* Array.singleton \"one\" = #[\"one\"]\n\nConstructs an array that contains all the numbers from 0 to n, exclusive.Examples:* Array.range 5 := #[0, 1, 2, 3, 4]* Array.range 0 := #[]* Array.range 1 := #[0]\n\nConstructs an array of numbers of size size, starting at start and increasing by\nstep at each element.In other words, Array.range' start size step is #[start, start+step, ..., start+(len-1)*step].Examples:* Array.range' 0 3 (step := 1) = #[0, 1, 2]* Array.range' 0 3 (step := 2) = #[0, 2, 4]* Array.range' 0 4 (step := 2) = #[0, 2, 4, 6]* Array.range' 3 4 (step := 2) = #[3, 5, 7, 9]\n\nReturns an array of all elements of Fin n in order, starting at 0.Examples:* Array.finRange 0 = (#[] : Array (Fin 0))* Array.finRange 2 = (#[0, 1] : Array (Fin 2))\n\nCreates an array by applying f to each potential index in order, starting at 0.Examples:* Array.ofFn (n := 3) toString = #[\"0\", \"1\", \"2\"]* Array.ofFn (fun i => #[\"red\", \"green\", \"blue\"].get i.val i.isLt) = #[\"red\", \"green\", \"blue\"]\n\nCreates an array that contains n repetitions of v.The corresponding List function is List.replicate.Examples:* Array.replicate 2 true = #[true, true]* Array.replicate 3 () = #[(), (), ()]* Array.replicate 0 \"anything\" = #[]\n\nAppends two arrays. Normally used via the ++ operator.Appending arrays takes time proportional to the length of the second array.Examples:* #[1, 2, 3] ++ #[4, 5] = #[1, 2, 3, 4, 5].* #[] ++ #[4, 5] = #[4, 5].* #[1, 2, 3] ++ #[] = #[1, 2, 3].\n\nAppends an array and a list.Takes time proportional to the length of the list..Examples:* #[1, 2, 3].appendList [4, 5] = #[1, 2, 3, 4, 5].* #[].appendList [4, 5] = #[4, 5].* #[1, 2, 3].appendList [] = #[1, 2, 3].\n\nPads xs : Array α on the left with repeated occurrences of a : α until it is of size n. If xs\nalready has at least n elements, it is returned unmodified.Examples:* #[1, 2, 3].leftpad 5 0 = #[0, 0, 1, 2, 3]* #[\"red\", \"green\", \"blue\"].leftpad 4 \"blank\" = #[\"blank\", \"red\", \"green\", \"blue\"]* #[\"red\", \"green\", \"blue\"].leftpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]* #[\"red\", \"green\", \"blue\"].leftpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]\n\nPads xs : Array α on the right with repeated occurrences of a : α until it is of length n. If\nl already has at least n elements, it is returned unmodified.Examples:* #[1, 2, 3].rightpad 5 0 = #[1, 2, 3, 0, 0]* #[\"red\", \"green\", \"blue\"].rightpad 4 \"blank\" = #[\"red\", \"green\", \"blue\", \"blank\"]* #[\"red\", \"green\", \"blue\"].rightpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]* #[\"red\", \"green\", \"blue\"].rightpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.1. Constructing Arrays","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Constructing-Arrays"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Patterns":{"contents":"String slices feature generalized search patterns.\nRather than being defined to work only for characters or for strings, many operations on slices accept arbitrary patterns.\nNew types can be made into patterns by defining instances of the classes in this section.\nThe Lean standard library provides instances that allow the following types to be used for both forward and backward searching:\n\n* Pattern Type* Meaning* Char* Matches the provided character\n* Char → Bool* Matches any character that satisfies the predicate* String* Matches occurrences of the given string* String.Slice* Matches occurrences of the string represented by the slice\n\nProvides a conversion from a pattern to an iterator of SearchStep that searches for matches\nof the pattern from the start towards the end of a Slice.Builds an iterator of SearchStep corresponding to matches of pat along the slice\ns. The SearchSteps returned by this iterator must contain ranges that are\nadjacent, non-overlapping and cover all of s.\n\nProvides simple pattern matching capabilities from the start of a Slice.While these operations can be implemented on top of ToForwardSearcher some patterns allow\nfor more efficient implementations. This class can be used to specialize for them. If there is no\nneed to specialize in this fashion, then\nForwardPattern.defaultImplementation can be used\nto automatically derive an instance.Checks whether the slice starts with the pattern.Checks whether the slice starts with the pattern. If it does, the slice is returned with the\nprefix removed; otherwise the result is none.\n\nProvides a conversion from a pattern to an iterator of SearchStep searching for matches of\nthe pattern from the end towards the start of a Slice.Build an iterator of SearchStep corresponding to matches of pat along the slice\ns. The SearchSteps returned by this iterator must contain ranges that are\nadjacent, non-overlapping and cover all of s.\n\nProvides simple pattern matching capabilities from the end of a Slice.While these operations can be implemented on top of ToBackwardSearcher, some patterns allow\nfor more efficient implementations. This class can be used to specialize for them. If there is no\nneed to specialize in this fashion, then\nBackwardPattern.defaultImplementation can be\nused to automatically derive an instance.Checks whether the slice ends with the pattern.Checks whether the slice ends with the pattern. If it does, the slice is returned with the\nsuffix removed; otherwise the result is none.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices","header":"19.8.4.12.2. Patterns","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Patterns"},"/Build-Tools-and-Distribution/#build-tools-and-distribution":{"contents":"The Lean toolchain is the collection of command-line tools that are used to check proofs and compile programs in collections of Lean files.\nToolchains are managed by elan, which installs toolchains as needed.\nLean toolchains are designed to be self-contained, and most command-line users will never need to explicitly invoke any other than lake and elan.\nThey contain the following tools: lean\n\nThe Lean compiler, used to elaborate and compile a Lean source file.\n\n lake\n\nThe Lean build tool, used to incrementally invoke lean and other tools while tracking dependencies.\n\n leanc\n\nThe C compiler that ships with Lean, which is a version of Clang.\n\n leanmake\n\nAn implementation of the make build tool, used for compiling C dependencies.\n\n leanchecker\n\nA tool that replays elaboration results from .olean files through the Lean kernel, providing additional assurance that all terms were properly checked.\n\n\n\nIn addition to these build tools, toolchains contain files that are needed to build Lean code.\nThis includes source code, .olean files, compiled libraries, C header files, and the compiled Lean run-time system.\nThey also include external proof automation tools that are used by tactics included with Lean, such as cadical for bv_decide.\n\n\n\n\n\n","context":"Lean Reference","header":"22. Build Tools and Distribution","id":"/Build-Tools-and-Distribution/#build-tools-and-distribution"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Inhabited-Types":{"contents":"Inhabited α is a typeclass that says that α has a designated element,\ncalled (default : α). This is sometimes referred to as a \"pointed type\".This class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, Array.get! arr i : α returns\na value of type α when arr : Array α, but if i is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type α (and in fact this is required\nfor logical consistency), so in this case it returns default.default is a function that produces a \"default\" element of any\nInhabited type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value.\n\nNonempty α is a typeclass that says that α is not an empty type,\nthat is, there exists an element in the type. It differs from Inhabited α\nin that Nonempty α is a Prop, which means that it does not actually carry\nan element of α, only a proof that there exists such an element.\nGiven Nonempty α, you can construct an element of α nonconstructively\nusing Classical.choice.If val : α, then α is nonempty.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.5. Inhabited Types","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Inhabited-Types"},"/Type-Classes/Class-Declarations/#class-inductive":{"contents":"Most type classes follow the paradigm of a set of overloaded methods from which clients may choose freely.\nThis is naturally modeled by a product type, from which the overloaded methods are projections.\nSome classes, however, are sum types: they require that the recipient of the synthesized instance first check which of the available instance constructors was provided.\nTo account for these classes, a class declaration may consist of an arbitrary inductive type, not just an extended form of structure declaration.\n\nClass Inductive Type Declarations\n\nClass inductive types are just like other inductive types, except they may participate in instance synthesis.\nThe paradigmatic example of a class inductive is Decidable: synthesizing an instance in a context with free variables amounts to synthesizing the decision procedure, but if there are no free variables, then the truth of the proposition can be established by instance synthesis alone (as is done by the decide tactic).\n\n","context":"Lean Reference\u0009Type Classes\u0009Class Declarations","header":"11.1.1. Sum Types as Classes","id":"/Type-Classes/Class-Declarations/#class-inductive"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Displaying-import-hierarchy":{"contents":"#8654 (together with #620 for vscode-lean4) adds\na new module hierarchy component in\nVS Code that can be used to navigate both the import tree of a module\nand the imported-by tree of a module.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Displaying import hierarchy","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Displaying-import-hierarchy"}});