window.docContents[140].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Transformation":{"contents":"Applies a function to each element of the array, returning the resulting array of values.Examples:* #[a, b, c].map f = #[f a, f b, f c]* #[].map Nat.succ = #[]* #[\"one\", \"two\", \"three\"].map (·.length) = #[3, 3, 5]* #[\"one\", \"two\", \"three\"].map (·.reverse) = #[\"eno\", \"owt\", \"eerht\"]\n\nApplies a function to each element of an array, returning the array of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new array if the result of each function call is\npointer-equal to its argument.\n\nApplies the monadic action f to every element in the array, left-to-right, and returns the array\nof results.\n\nApplies the monadic action f to every element in the array, left-to-right, and returns the array\nof results. Furthermore, the resulting array's type guarantees that it contains the same number of\nelements as the input array.\n\nApplies a monadic function to each element of an array, returning the array of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new array if the result of each function call is\npointer-equal to its argument.\n\nApplies a function to each element of the array along with the index at which that element is found,\nreturning the array of results.Array.mapFinIdx is a variant that additionally provides the function with a proof that the index\nis valid.\n\nApplies the monadic action f to every element in the array, along with the element's index, from\nleft to right. Returns the array of results.\n\nApplies a function to each element of the array along with the index at which that element is found,\nreturning the array of results. In addition to the index, the function is also provided with a proof\nthat the index is valid.Array.mapIdx is a variant that does not provide the function with evidence that the index is\nvalid.\n\nApplies the monadic action f to every element in the array, along with the element's index and a\nproof that the index is in bounds, from left to right. Returns the array of results.\n\nApplies a function that returns an array to each element of an array. The resulting arrays are\nappended.Examples:* #[2, 3, 2].flatMap Array.range = #[0, 1, 0, 1, 2, 0, 1]* #[['a', 'b'], ['c', 'd', 'e']].flatMap List.toArray = #['a', 'b', 'c', 'd', 'e']\n\nApplies a monadic function that returns an array to each element of an array, from left to right.\nThe resulting arrays are appended.\n\nCombines two arrays into an array of pairs in which the first and second components are the\ncorresponding elements of each input array. The resulting array is the length of the shorter of the\ninput arrays.Examples:* #[\"Mon\", \"Tue\", \"Wed\"].zip #[1, 2, 3] = #[(\"Mon\", 1), (\"Tue\", 2), (\"Wed\", 3)]* #[\"Mon\", \"Tue\", \"Wed\"].zip #[1, 2] = #[(\"Mon\", 1), (\"Tue\", 2)]* #[x₁, x₂, x₃].zip #[y₁, y₂, y₃, y₄] = #[(x₁, y₁), (x₂, y₂), (x₃, y₃)]\n\nApplies a function to the corresponding elements of two arrays, stopping at the end of the shorter\narray.Examples:* #[1, 2].zipWith (· + ·) #[5, 6] = #[6, 8]* #[1, 2, 3].zipWith (· + ·) #[5, 6, 10] = #[6, 8, 13]* #[].zipWith (· + ·) #[5, 6] = #[]* #[x₁, x₂, x₃].zipWith f #[y₁, y₂, y₃, y₄] = #[f x₁ y₁, f x₂ y₂, f x₃ y₃]\n\nApplies a function to the corresponding elements of both arrays, stopping when there are no more\nelements in either array. If one array is shorter than the other, the function is passed none for\nthe missing elements.Examples:* #[1, 6].zipWithAll min #[5, 2] = #[some 1, some 2]* #[1, 2, 3].zipWithAll Prod.mk #[5, 6] = #[(some 1, some 5), (some 2, some 6), (some 3, none)]* #[x₁, x₂].zipWithAll f #[y] = #[f (some x₁) (some y), f (some x₂) none]\n\nPairs each element of an array with its index, optionally starting from an index other than 0.Examples:* #[a, b, c].zipIdx = #[(a, 0), (b, 1), (c, 2)]* #[a, b, c].zipIdx 5 = #[(a, 5), (b, 6), (c, 7)]\n\nSeparates an array of pairs into two arrays that contain the respective first and second components.Examples:* #[(\"Monday\", 1), (\"Tuesday\", 2)].unzip = (#[\"Monday\", \"Tuesday\"], #[1, 2])* #[(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzip = (#[x₁, x₂, x₃], #[y₁, y₂, y₃])* (#[] : Array (Nat × String)).unzip = ((#[], #[]) : List Nat × List String)\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.9. Transformation","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Transformation"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key. There is also a Prop-valued version\nof this: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for comparisons, while for hash maps, both use ==.\n\nThe notation m[a] or m[a]'h is preferred over calling this function directly.Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof of\na ∈ m.\n\nThe notation m[a]! is preferred over calling this function directly.Tries to retrieve the mapping for the given key, panicking if no such mapping is present.\n\nThe notation m[a]? is preferred over calling this function directly.Tries to retrieve the mapping for the given key, returning none if no such mapping is present.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Maps","header":"19.18.4.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Queries"},"/Interacting-with-Lean/#hash-guard_msgs":{"contents":"The #guard_msgs command can be used to ensure that the messages output by a command are as expected.\nTogether with the interaction commands in this section, it can be used to construct a file that will only elaborate if the output is as expected; such a file can be used as a test driver in Lake.\n\nDocumenting Expected Output/-- ... -/ #guard_msgs in cmd captures the messages generated by the command cmd\nand checks that they match the contents of the docstring.Basic example:/--\nerror: Unknown identifier `x`\n-/\n#guard_msgs in\nexample : α := x\nThis checks that there is such an error and then consumes the message.By default, the command captures all messages, but the filter condition can be adjusted.\nFor example, we can select only warnings:/--\nwarning: declaration uses 'sorry'\n-/\n#guard_msgs(warning) in\nexample : α := sorry\nor only errors#guard_msgs(error) in\nexample : α := sorry\nIn the previous example, since warnings are not captured there is a warning on sorry.\nWe can drop the warning completely with#guard_msgs(error, drop warning) in\nexample : α := sorry\nIn general, #guard_msgs accepts a comma-separated list of configuration clauses in parentheses:#guard_msgs (configElt,*) in cmd\nBy default, the configuration list is\n(check all, whitespace := normalized, ordering := exact, positions := false).Message filters select messages by severity:* info, warning, error: (non-trace) messages with the given severity level.* trace: trace messages* all: all messages.The filters can be prefixed with the action to take:* check (the default): capture and check the message* drop: drop the message* pass: let the message pass throughIf no filter is specified, check all is assumed.  Otherwise, these filters are processed in\nleft-to-right order, with an implicit pass all at the end.Whitespace handling (after trimming leading and trailing whitespace):* whitespace := exact requires an exact whitespace match.* whitespace := normalized converts all newline characters to a space before matching\n(the default). This allows breaking long lines.* whitespace := lax collapses whitespace to a single space before matching.Message ordering:* ordering := exact uses the exact ordering of the messages (the default).* ordering := sorted sorts the messages in lexicographic order.\nThis helps with testing commands that are non-deterministic in their ordering.Position reporting:* positions := true reports the ranges of all messages relative to the line on which\n#guard_msgs appears.* positions := false does not report position info.For example, #guard_msgs (error, drop all) in cmd means to check warnings and drop\neverything else.The command elaborator has special support for #guard_msgs for linting.\nThe #guard_msgs itself wants to capture linter warnings,\nso it elaborates the command it is attached to as if it were a top-level command.\nHowever, the command elaborator runs linters for all top-level commands,\nwhich would include #guard_msgs itself, and would cause duplicate and/or uncaptured linter warnings.\nThe top-level command elaborator only runs the linters if #guard_msgs is not present.\n\nTesting Return ValuesThe #guard_msgs command can ensure that a set of test cases pass:def reverse : List α → List α := helper []\nwhere\n  helper acc\n    | [] => acc\n    | x :: xs => helper (x :: acc) xs\n\n/-- info: [] -/\n#guard_msgs in\n#eval reverse ([] : List Nat)\n\n/-- info: ['c', 'b', 'a'] -/\n#guard_msgs in\n#eval reverse \"abc\".toList\n\n\nThe behavior of the #guard_msgs command can be specified in three ways:1. Providing a filter that selects a subset of messages to be checked2. Specifying a whitespace comparison strategy3. Deciding to sort messages by their content or by the order in which they were producedThese configuration options are provided in parentheses, separated by commas.\n\nSpecifying #guard_msgs BehaviorThere are three kinds of options for #guard_msgs: filters, whitespace comparison strategies, and orderings.\n\nOutput Filters for #guard_msgsA message filter specification for #guard_msgs.* info, warning, error: capture (non-trace) messages with the given severity level.* trace: captures trace messages* all: capture all messages.The filters can be prefixed with* check (the default): capture and check the message* drop: drop the message* pass: let the message pass throughIf no filter is specified, check all is assumed.  Otherwise, these filters are processed in\nleft-to-right order, with an implicit pass all at the end.\n\nWhitespace Comparison for #guard_msgsLeading and trailing whitespace is always ignored when comparing messages. On top of that, the following settings are available:* whitespace := exact requires an exact whitespace match.* whitespace := normalized converts all newline characters to a space before matching (the default). This allows breaking long lines.* whitespace := lax collapses whitespace to a single space before matching.\n\nThe option guard_msgs.diff controls the content of the error message that #guard_msgs produces when the expected message doesn't match the produced message.\nBy default, #guard_msgs shows a line-by-line difference, with a leading + used to indicate lines from the produced message and a leading - used to indicate lines from the expected message.\nWhen messages are large and only differ by a small amount, this can make it easier to notice where they differ.\nSetting guard_msgs.diff to false causes #guard_msgs to instead show just the produced message, which can be compared with the expected message in the source file.\nThis can be convenient if the difference between the message is confusing or overwhelming.\n\nWhen true, show a diff between expected and actual messages if they don't match.\n\nDisplaying DifferencesThe #guard_msgs command can be used to test definition of a rose tree Tree and a function Tree.big that creates them:inductive Tree (α : Type u) : Type u where\n  | val : α → Tree α\n  | branches : List (Tree α) → Tree α\n\ndef Tree.big (n : Nat) : Tree Nat :=\n  if n = 0 then .val 0\n  else if n = 1 then .branches [.big 0]\n  else .branches [.big (n / 2), .big (n / 3)]\nHowever, it can be difficult to spot where test failures come from when the output is large:set_option guard_msgs.diff false\n/--\ninfo: Tree.branches\n  [Tree.branches\n     [Tree.branches [Tree.branches [Tree.branches [Tree.val 0], Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 2], Tree.branches [Tree.val 0]]],\n   Tree.branches\n     [Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 0], Tree.val 0]]]\n-/\n#guard_msgs in\n#eval Tree.big 20\nThe evaluation produces:Tree.branches\n  [Tree.branches\n     [Tree.branches [Tree.branches [Tree.branches [Tree.val 0], Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]]],\n   Tree.branches\n     [Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 0], Tree.val 0]]]\nWithout guard_msgs.diff, the #guard_msgs command reports this error:❌️ Docstring on `#guard_msgs` does not match generated message:\n\ninfo: Tree.branches\n  [Tree.branches\n     [Tree.branches [Tree.branches [Tree.branches [Tree.val 0], Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]]],\n   Tree.branches\n     [Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 0], Tree.val 0]]]\nEnabling guard_msgs.diff highlights the differences instead, making the error more apparent:set_option guard_msgs.diff true in\n/--\ninfo: Tree.branches\n  [Tree.branches\n     [Tree.branches [Tree.branches [Tree.branches [Tree.val 0], Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 2], Tree.branches [Tree.val 0]]],\n   Tree.branches\n     [Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]],\n      Tree.branches [Tree.branches [Tree.val 0], Tree.val 0]]]\n-/\n#guard_msgs in\n#eval Tree.big 20\n❌️ Docstring on `#guard_msgs` does not match generated message:\n\n  info: Tree.branches\n    [Tree.branches\n       [Tree.branches [Tree.branches [Tree.branches [Tree.val 0], Tree.val 0], Tree.branches [Tree.val 0]],\n-       Tree.branches [Tree.branches [Tree.val 2], Tree.branches [Tree.val 0]]],\n+       Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]]],\n     Tree.branches\n       [Tree.branches [Tree.branches [Tree.val 0], Tree.branches [Tree.val 0]],\n        Tree.branches [Tree.branches [Tree.val 0], Tree.val 0]]]\n\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.6. Testing Output with  #guard_msgs","id":"/Interacting-with-Lean/#hash-guard_msgs"},"/The-Type-System/Quotients/#The-Lean-Language-Reference--The-Type-System--Quotients--Logical-Model--Low-Level-Quotient-API":{"contents":"Quot.liftOn is an version of Quot.lift that takes the quotient type's value first, by analogy to Quotient.liftOn.\n\nLifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.Given a relation r : α → α → Prop and a quotient's value q : Quot r, applying a f : α → β\nrequires a proof c that f respects r. In this case, Quot.liftOn q f h : β evaluates\nto the result of applying f to the underlying value in α from q.Quot.liftOn is a version of the built-in primitive Quot.lift with its parameters re-ordered.Quotient types are described in more detail in the Lean Language\nReference.\n\nLean also provides convenient elimination from Quot into any subsingleton without further proof obligations, along with dependent elimination principles that correspond to those used for Quotient.\n\nAn alternative induction principle for quotients that can be used when the target type is a\nsubsingleton, in which all elements are equal.In these cases, the proof that the function respects the quotient's relation is trivial, so any\nfunction can be lifted.Quot.rec does not assume that the type is a subsingleton.\n\nA dependent recursion principle for Quot. It is analogous to the\nrecursor for a structure, and can be used when the resulting type\nis not necessarily a proposition.While it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:* Quot.lift is useful for defining non-dependent functions.* Quot.ind is useful for proving theorems about quotients.* Quot.recOnSubsingleton can be used whenever the target type is a Subsingleton.* Quot.hrecOn uses heterogeneous equality instead of rewriting with\nQuot.sound.Quot.recOn is a version of this recursor that takes the quotient parameter first.\n\nA dependent recursion principle for Quot that takes the quotient first. It is analogous to the\nrecursor for a structure, and can be used when the resulting type\nis not necessarily a proposition.While it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:* Quot.lift is useful for defining non-dependent functions.* Quot.ind is useful for proving theorems about quotients.* Quot.recOnSubsingleton can be used whenever the target type is a Subsingleton.* Quot.hrecOn uses heterogeneous equality instead of rewriting with\nQuot.sound.Quot.rec is a version of this recursor that takes the quotient parameter last.\n\nA dependent recursion principle for Quot that uses heterogeneous\nequality, analogous to a recursor for\na structure.Quot.recOn is a version of this recursor that uses Eq instead of HEq.\n\n","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Logical Model","header":"4.5.5.3. Low-Level Quotient API","id":"/The-Type-System/Quotients/#The-Lean-Language-Reference--The-Type-System--Quotients--Logical-Model--Low-Level-Quotient-API"}});