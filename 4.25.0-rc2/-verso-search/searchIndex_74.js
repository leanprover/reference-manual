window.docContents[74].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties":{"contents":"Returns true if the tree set contains no mappings.\n\nReturns the number of mappings present in the map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","header":"19.18.10.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties"},"/Definitions/Headers-and-Signatures/#automatic-implicit-parameters":{"contents":"By default, otherwise-unbound names that occur in signatures are converted into implicit parameters when possible\nThese parameters are called automatic implicit parameters.\nThis is possible when they are not in the function position of an application and when there is sufficient information available in the signature to infer their type and any ordering constraints on them.\nThis process is iterated: if the inferred type for the freshly-inserted implicit parameter has dependencies that are not uniquely determined, then these dependencies are replaced with further implicit parameters.\n\nImplicit parameters that don't correspond to names written in signatures are assigned names akin to those of inaccessible hypotheses in proofs, which cannot be referred to.\nThey show up in signatures with a trailing dagger ('✝').\nThis prevents an arbitrary choice of name by Lean from becoming part of the API by being usable as a named argument.\n\nAutomatic Implicit ParametersIn this definition of map, α and β are not explicitly bound.\nRather than this being an error, they are converted into implicit parameters.\nBecause they must be types, but nothing constrains their universes, the universe parameters u and v are also inserted.def map (f : α → β) : (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nThe full signature of map is:map.{u, v} {α : Type u} {β : Type v}\n  (f : α → β) (xs : List α) :\n  List β\n\n\nNo Automatic Implicit ParametersIn this definition, α and β are not explicitly bound.\nBecause autoImplicit is disabled, this is an error:set_option autoImplicit false\n\ndef map (f : α → β) : (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nUnknown identifier `α`\nUnknown identifier `β`\nThe full signature allows the definition to be accepted:set_option autoImplicit false\n\ndef map.{u, v} {α : Type u} {β : Type v}\n    (f : α → β) :\n    (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nUniverse parameters are inserted automatically for parameters without explicit type annotations.\nThe type parameters' universes can be inferred, and the appropriate universe parameters inserted, even when autoImplicit is disabled:set_option autoImplicit false\n\ndef map {α β} (f : α → β) :\n    (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\n\n\nIterated Automatic Implicit ParametersGiven a number bounded by n, represented by the type Fin n, an AtLeast i is a natural number paired with a proof that it is at least as large as i.structure AtLeast (i : Fin n) where\n  val : Nat\n  val_gt_i : val ≥ i.val\nThese numbers can be added:def AtLeast.add (x y : AtLeast i) : AtLeast i :=\n  AtLeast.mk (x.val + y.val) <| by\n    cases x\n    cases y\n    dsimp only\n    omega\nThe signature of AtLeast.add requires multiple rounds of automatic implicit parameter insertion.\nFirst, i is inserted; but its type depends on the upper bound n of Fin n.\nIn the second round, n is inserted, using a machine-chosen name.\nBecause n's type is Nat, which has no dependencies, the process terminates.\nThe final signature can be seen with #check:#check AtLeast.add\nAtLeast.add {n✝ : Nat} {i : Fin n✝} (x y : AtLeast i) : AtLeast i\n\n\nAutomatic implicit parameter insertion takes place after the insertion of parameters due to section variables.\nParameters that correspond to section variables have the same name as the corresponding variable, even when they do not correspond to a name written directly in the signature, and disabling automatic implicit parameters has no effect the parameters that correspond to section variables.\nHowever, when automatic implicit parameters are enabled, section variable declarations that contain otherwise-unbound variables receive additional section variables that follow the same rules as those for implicit parameters.\n\nAutomatic implicit parameters insertion is controlled by two options.\nBy default, automatic implicit parameter insertion is relaxed, which means that any unbound identifier may be a candidate for automatic insertion.\nSetting the option relaxedAutoImplicit to false disables relaxed mode and causes only identifiers that consist of a single character followed by zero or more digits to be considered for automatic insertion.\n\nWhen \"relaxed\" mode is enabled, any atomic nonempty identifier is eligible for auto bound implicit locals (see option autoImplicit).\n\nUnbound local variables in declaration headers become implicit arguments. In \"relaxed\" mode (default), any atomic identifier is eligible, otherwise only single character followed by numeric digits are eligible. For example, def f (x : Vector α n) : Vector α n := automatically introduces the implicit variables {α n}.\n\nRelaxed vs Non-Relaxed Automatic Implicit ParametersMisspelled identifiers or missing imports can end up as unwanted implicit parameters, as in this example:inductive Answer where\n  | yes\n  | maybe\n  | no\ndef select (choices : α × α × α) : Asnwer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nThe resulting error message states that the argument's type is not a constant, so dot notation cannot be used in the pattern:Invalid dotted identifier notation: The expected type of `.yes`\n  Asnwer\nis not of the form `C ...` or `... → C ...` where C is a constant\nThis is because the signature is:select.{u_1, u_2}\n  {α : Type u_1}\n  {Asnwer : Sort u_2}\n  (choices : α × α × α) :\n  Asnwer → α\nDisabling relaxed automatic implicit parameters makes the error more clear, while still allowing the type to be inserted automatically:set_option relaxedAutoImplicit false\n\ndef select (choices : α × α × α) : Asnwer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nUnknown identifier `Asnwer`\nCorrecting the error allows the definition to be accepted.set_option relaxedAutoImplicit false\n\ndef select (choices : α × α × α) : Answer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nTurning off automatic implicit parameters entirely leads to the definition being rejected:set_option autoImplicit false\n\ndef select (choices : α × α × α) : Answer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nUnknown identifier `α`\n\n\n","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","header":"7.2.4. Automatic Implicit Parameters","id":"/Definitions/Headers-and-Signatures/#automatic-implicit-parameters"},"/Error-Explanations/lean___inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferBinderTypeFailed--Examples":{"contents":"Binder type requires new type variabledef identity x :=\n  x\n<invalid output>def identity (x : α) :=\n  x\nIn the code above, the type of x is unconstrained; as this example demonstrates, Lean does not\nautomatically generate fresh type variables for such binders. Instead, the type α of x must be\nspecified explicitly. Note that if automatic implicit parameter insertion is enabled (as it is by\ndefault), a binder for α itself need not be provided; Lean will insert an implicit binder for this\nparameter automatically.\n\nUninferred binder type due to resulting type annotationdef plusTwo x : Nat :=\n  x + 2\n<invalid output>def plusTwo (x : Nat) : Nat :=\n  x + 2\nEven though x is inferred to have type Nat in the body of plusTwo, this information is not\navailable when elaborating the type of the definition because its resulting type (Nat) has been\nexplicitly specified. Considering only the information in the header, the type of x cannot be\ndetermined, resulting in the shown error. It is therefore necessary to include the type of x in\nits binder.\n\nAttempting to name an example declarationexample trivial_proof : True :=\n  trivial\n<invalid output>example : True :=\n  trivial\nThis code is invalid because it attempts to give a name to an example declaration. Examples cannot\nbe named, and an identifier written where a name would appear in other declaration forms is instead\nelaborated as a binder, whose type cannot be inferred. If a declaration must be named, it should be\ndefined using a declaration form that supports naming, such as def or theorem.\n\nAttempting to define multiple opaque constants at onceopaque m n : Nat\n<invalid output>opaque m : Nat\nopaque n : Nat\nThis example incorrectly attempts to define multiple constants with a single opaque declaration.\nSuch a declaration can define only one constant: it is not possible to list multiple identifiers\nafter opaque or def to define them all to have the same type (or value). Such a declaration is\ninstead elaborated as defining a single constant (e.g., m above) with parameters given by the\nsubsequent identifiers (n), whose types are unspecified and cannot be inferred. To define multiple\nglobal constants, it is necessary to declare each separately.\n\nAttempting to define multiple structure fields on the same linestructure Person where\n  givenName familyName : String\n  age : Nat\n<invalid output>structure Person where\n  givenName : String\n  familyName : String\n  age : Nat\nstructure Person where\n  (givenName familyName : String)\n  age : Nat\nThis example incorrectly attempts to define multiple structure fields (givenName and familyName)\nof the same type by listing them consecutively on the same line. Lean instead interprets this as\ndefining a single field, givenName, parametrized by a binder familyName with no specified type.\nThe intended behavior can be achieved by either listing each field on a separate line, or enclosing\nthe line specifying multiple field names in parentheses (see the manual section on\nInductive Types for further details about structure\ndeclarations).\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.inferBinderTypeFailed","header":"Examples","id":"/Error-Explanations/lean___inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferBinderTypeFailed--Examples"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Mutexes":{"contents":"The types and functions in this section are available after importing Std.Sync.Mutex.\n\nMutual exclusion primitive (lock) guarding shared state of type α.The type Mutex α is similar to IO.Ref α, except that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n\nCreates a new mutex.\n\nmutex.atomically k runs k with access to the mutex's state while locking the mutex.Calling mutex.atomically while already holding the underlying BaseMutex in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using RecursiveMutex.\n\nmutex.atomicallyOnce condvar pred k runs k, waiting on condvar until pred returns true.\nBoth k and pred have access to the mutex's state.Calling mutex.atomicallyOnce while already holding the underlying BaseMutex in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using RecursiveMutex.\n\nAtomicT α m is the monad that can be atomically executed inside mutual exclusion primitives like\nMutex α with outside monad m.\nThe action has access to the state α of the mutex (via get and set).\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads\u0009Communication Between Tasks","header":"15.11.6.2. Mutexes","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Mutexes"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Breaking-changes":{"contents":"* Char.csize is replaced by Char.utf8Size (#4357).* Library lemmas now are in terms of (· == a) over (a == ·) (#3056).* Now the normal forms for indexing into List and Array is xs[n] and xs[n]? rather than using functions like List.get (#4400).* Sometimes terms created via a sequence of unifications will be more eta reduced than before and proofs will require adaptation (#4387).* The GetElem class has been split into two; see the docstrings for GetElem and GetElem? for more information (#4560).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"Breaking changes","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Breaking-changes"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Language":{"contents":"* #4595 implements Simp.Config.implicitDefEqsProofs. When true\n(default: true), simp will not create a proof term for a\nrewriting rule associated with an rfl-theorem. Rewriting rules are\nprovided by users by annotating theorems with the attribute @[simp].\nIf the proof of the theorem is just rfl (reflexivity), and\nimplicitDefEqProofs := true, simp will not create a proof term\nwhich is an application of the annotated theorem.* #5429 avoid negative environment lookup* #5501 ensure instantiateMVarsProfiling adds a trace node* #5856 adds a feature to the the mutual def elaborator where the\ninstance command yields theorems instead of definitions when the class\nis a Prop.* #5907 unset trailing for simpa? \"try this\" suggestion* #5920 changes the rule for which projections become instances. Before,\nall parents along with all indirect ancestors that were represented as\nsubobject fields would have their projections become instances. Now only\nprojections for direct parents become instances.* #5934 make all_goals admit goals on failure* #5942 introduce synthetic atoms in bv_decide* #5945 adds a new definition Message.kind which returns the top-level\ntag of a message. This is serialized as the new field kind in\nSerialMessaege so that i can be used by external consumers (e.g.,\nLake) to identify messages via lean --json.* #5968 arg conv tactic misreported number of arguments on error* #5979 BitVec.twoPow in bv_decide* #5991 simplifies the implementation of omega.* #5992 fix style in bv_decide normalizer* #5999 adds configuration options for\ndecide/decide!/native_decide and refactors the tactics to be\nfrontends to the same backend. Adds a +revert option that cleans up\nthe local context and reverts all local variables the goal depends on,\nalong with indirect propositional hypotheses. Makes native_decide fail\nat elaboration time on failure without sacrificing performance (the\ndecision procedure is still evaluated just once). Now native_decide\nsupports universe polymorphism.* #6010 changes bv_decide's configuration from lots of set_option to\nan elaborated config like simp or omega. The notable exception is\nsat.solver which is still a set_option such that users can configure\na custom SAT solver globally for an entire project or file. Additionally\nit introduces the ability to set maxSteps for the simp preprocessing\nrun through the new config.* #6012 improves the validation of new syntactic tokens. Previously, the\nvalidation code had inconsistencies: some atoms would be accepted only\nif they had a leading space as a pretty printer hint. Additionally,\natoms with internal whitespace are no longer allowed.* #6016 removes the decide! tactic in favor of decide +kernel\n(breaking change).* #6019 removes @[specilize] from MkBinding.mkBinding, which is a\nfunction that cannot be specialized (as none of its arguments are\nfunctions). As a result, the specializable function Nat.foldRevM.loop\ndoesn't get specialized, which leads to worse performing code.* #6022 makes the change tactic and conv tactic use the same\nelaboration strategy. It works uniformly for both the target and local\nhypotheses. Now change can assign metavariables, for example:\n\nexample (x y z : Nat) : x + y = z := by\n  change ?a = _\n  let w := ?a\n  -- now `w : Nat := x + y`\n\n\n* #6024 fixes a bug where the monad lift coercion elaborator would\npartially unify expressions even if they were not monads. This could be\ntaken advantage of to propagate information that could help elaboration\nmake progress, for example the first change worked because the monad\nlift coercion elaborator was unifying @Eq _ _ with @Eq (Nat × Nat) p:\n\nexample (p : Nat × Nat) : p = p := by\n  change _ = ⟨_, _⟩ -- used to work (yielding `p = (p.fst, p.snd)`), now it doesn't\n  change ⟨_, _⟩ = _ -- never worked\n\n\nAs such, this is a breaking change; you may need to adjust expressions\nto include additional implicit arguments.\n\n* #6029 adds a normalization rule to bv_normalize (which is used by\nbv_decide) that converts x / 2^k into x >>> k under suitable\nconditions. This allows us to simplify the expensive division circuits\nthat are used for bitblasting into much cheaper shifting circuits.\nConcretely, it allows for the following canonicalization:* #6030 fixes simp only [· ∈ ·] after #5020.* #6035 introduces the and flattening pre processing pass from Bitwuzla\nto bv_decide. It splits hypotheses of the form (a && b) = true into\na = true and b = true which has synergy potential with the already\nexisting embedded constraint substitution pass.* #6037 fixes bv_decide's embedded constraint substitution to generate\ncorrect counter examples in the corner case where duplicate theorems are\nin the local context.* #6045 add LEAN_ALWAYS_INLINE to some functions* #6048 fixes simp? suggesting output with invalid indentation* #6051 mark Meta.Context.config as private* #6053 fixes the caching infrastructure for whnf and isDefEq,\nensuring the cache accounts for all relevant configuration flags. It\nalso cleans up the WHNF.lean module and improves the configuration of\nwhnf.* #6061 adds a simp_arith benchmark.* #6062 optimize Nat.Linear.Expr.toPoly* #6064 optimize Nat.Linear.Poly.norm* #6068 improves the asymptotic performance of simp_arith when there are many variables to consider.* #6077 adds options to bv_decide's configuration structure such that\nall non mandatory preprocessing passes can be disabled.* #6082 changes how the canonicalizer handles forall and lambda,\nreplacing bvars with temporary fvars. Fixes a bug reported by @hrmacbeth\non\nzulip.* #6093 use mkFreshUserName in ArgsPacker* #6096 improves the #print command for structures to show all fields\nand which parents the fields were inherited from, hiding internal\ndetails such as which parents are represented as subobjects. This\ninformation is still present in the constructor if needed. The pretty\nprinter for private constants is also improved, and it now handles\nprivate names from the current module like any other name; private names\nfrom other modules are made hygienic.* #6098 modifies Lean.MVarId.replaceTargetDefEq and\nLean.MVarId.replaceLocalDeclDefEq to use Expr.equal instead of\nExpr.eqv when determining whether the expression has changed. This is\njustified on the grounds that binder names and binder infos are\nuser-visible and affect elaboration.* #6105 fixes a stack overflow caused by a cyclic assignment in the\nmetavariable context. The cycle is unintentionally introduced by the\nstructure instance elaborator.* #6108 turn off pp.mvars in apply? results* #6109 fixes an issue in the injection tactic. This tactic may\nexecute multiple sub-tactics. If any of them fail, we must backtrack the\npartial assignment. This issue was causing the error: \"mvarId is\nalready assigned\" in issue #6066. The issue is not yet resolved, as the\nequation generator for the match expressions is failing in the example\nprovided in this issue.* #6112 makes stricter requirements for the @[deprecated] attribute,\nrequiring either a replacement identifier as @[deprecated bar] or\nsuggestion text @[deprecated \"Past its use by date\"], and also\nrequires a since := \"...\" field.* #6114 liberalizes atom rules by allowing '' to be a prefix of an\natom, after #6012 only added an exception for '' alone, and also adds\nsome unit tests for atom validation.* #6116 fixes a bug where structural recursion did not work when indices\nof the recursive argument appeared as function parameters in a different\norder than in the argument's type's definition.* #6125 adds support for structure in mutual blocks, allowing\ninductive types defined by inductive and structure to be mutually\nrecursive. The limitations are (1) that the parents in the extends\nclause must be defined before the mutual block and (2) mutually\nrecursive classes are not allowed (a limitation shared by class inductive). There are also improvements to universe level inference for\ninductive types and structures. Breaking change: structure parents now\nelaborate with the structure in scope (fix: use qualified names or\nrename the structure to avoid shadowing), and structure parents no\nlonger elaborate with autoimplicits enabled.* #6128 does the same fix as #6104, but such that it doesn't break the\ntest/the file in Plausible. This is done by not creating unused let\nbinders in metavariable types that are made by elimMVar. (This is also\na positive thing for users looking at metavariable types, for example in\nerror messages)* #6129 fixes a bug at isDefEq when zetaDelta := false. See new test\nfor a small example that exposes the issue.* #6131 fixes a bug at the definitional equality test (isDefEq). At\nunification constraints of the form c.{u} =?= c.{v}, it was not trying\nto unfold c. This bug did not affect the kernel.* #6141 make use of recursive structures in snapshot types* #6145 fixes the revert tactic so that it creates a syntheticOpaque\nmetavariable as the new goal, instead of a natural metavariable* #6146 fixes a non-termination bug that occurred when generating the\nmatch-expression splitter theorem. The bug was triggered when the proof\nautomation for the splitter theorem repeatedly applied injection to\nthe same local declaration, as it could not be removed due to forward\ndependencies. See issue #6065 for an example that reproduces this issue.* #6165 modifies structure instance notation and where notation to use\nthe same notation for fields. Structure instance notation now admits\nbinders, type ascriptions, and equations, and where notation admits\nfull structure lvals. Examples of these for structure instance notation:\n\nstructure PosFun where\n  f : Nat → Nat\n  pos : ∀ n, 0 < f n\n\n\n* #6168 extends the \"motive is not type correct\" error message for the\nrewrite tactic to explain what it means. It also pretty prints the\ntype-incorrect motive and reports the type error.* #6170 adds core metaprogramming functions for forking off background\ntasks from elaboration such that their results are visible to reporting\nand the language server* #6175 fixes a bug with the structure/class command where if there\nare parents that are not represented as subobjects but which used other\nparents as instances, then there would be a kernel error. Closes #2611.* #6180 fixes a non-termination bug that occurred when generating the\nmatch-expression equation theorems. The bug was triggered when the proof\nautomation for the equation theorem repeatedly applied injection( to\nthe same local declaration, as it could not be removed due to forward\ndependencies. See issue #6067 for an example that reproduces this issue.* #6189 changes how generalized field notation (\"dot notation\") resolves\nthe function. The new resolution rule is that if x : S, then x.f\nresolves the name S.f relative to the root namespace (hence it now\naffected by export and open). Breaking change: aliases now resolve\ndifferently. Before, if x : S, and if S.f is an alias for S'.f,\nthen x.f would use S'.f and look for an argument of type S'. Now,\nit looks for an argument of type S, which is more generally useful\nbehavior. Code making use of the old behavior should consider defining\nS or S' in terms of the other, since dot notation can unfold\ndefinitions during resolution.* #6206 makes it possible to write rw (occs := [1,2]) ... instead of\nrw (occs := .pos [1,2]) ... by adding a coercion from List.Nat to\nLean.Meta.Occurrences.* #6220 adds proper support for let_fun in simp.* #6236 fixes an issue where edits to a command containing a nested\ndocstring fail to reparse the entire command.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Language","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Language"}});