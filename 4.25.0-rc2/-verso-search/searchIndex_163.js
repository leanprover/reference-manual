window.docContents[163].resolve({"/Basic-Types/Characters/#char-runtime":{"contents":"As a trivial wrapper, characters are represented identically to UInt32.\nIn particular, characters are represented as 32-bit immediate values in monomorphic contexts.\nIn other words, a field of a constructor or structure of type Char does not require indirection to access.\nIn polymorphic contexts, characters are boxed.\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters","header":"19.7.2. Run-Time Representation","id":"/Basic-Types/Characters/#char-runtime"},"/Basic-Types/Lazy-Computations/#Thunk-coercions":{"contents":"There is a coercion from any type α to Thunk α that converts a term e into Thunk.mk fun () => e.\nBecause the elaborator unfolds coercions, evaluation of the original term e is delayed; the coercion is not equivalent to Thunk.pure.\n\nLazy ListsLazy lists are lists that may contain thunks.\nThe delayed constructor causes part of the list to be computed on demand.inductive LazyList (α : Type u) where\n  | nil\n  | cons : α → LazyList α → LazyList α\n  | delayed : Thunk (LazyList α) → LazyList α\nderiving Inhabited\nLazy lists can be converted to ordinary lists by forcing all the embedded thunks.def LazyList.toList : LazyList α → List α\n  | .nil => []\n  | .cons x xs => x :: xs.toList\n  | .delayed xs => xs.get.toList\nMany operations on lazy lists can be implemented without forcing the embedded thunks, instead building up further thunks.\nThe body of delayed does not need to be an explicit call to Thunk.mk because of the coercion.def LazyList.take : Nat → LazyList α → LazyList α\n  | 0, _ => .nil\n  | _, .nil => .nil\n  | n + 1, .cons x xs => .cons x <| .delayed <| take n xs\n  | n + 1, .delayed xs => .delayed <| take (n + 1) xs.get\n\ndef LazyList.ofFn (f : Fin n → α) : LazyList α :=\n  Fin.foldr n (init := .nil) fun i xs =>\n    .delayed <| LazyList.cons (f i) xs\n\ndef LazyList.append (xs ys : LazyList α) : LazyList α :=\n  .delayed <|\n    match xs with\n    | .nil => ys\n    | .cons x xs' => LazyList.cons x (append xs' ys)\n    | .delayed xs' => append xs'.get ys\nLaziness is ordinarily invisible to Lean programs: there is no way to check whether a thunk has been forced.\nHowever, dbg_trace can be used to gain insight into thunk evaluation.def observe (tag : String) (i : Fin n) : Nat :=\n  dbg_trace \"{tag}: {i.val}\"\n  i.val\nThe lazy lists xs and ys emit traces when evaluated.def xs := LazyList.ofFn (n := 3) (observe \"xs\")\ndef ys := LazyList.ofFn (n := 3) (observe \"ys\")\nConverting xs to an ordinary list forces all of the embedded thunks:#eval xs.toList\nxs: 0\nxs: 1\nxs: 2\n[0, 1, 2]\nLikewise, converting xs.append ys to an ordinary list forces the embedded thunks:#eval xs.append ys |>.toList\nxs: 0\nxs: 1\nxs: 2\nys: 0\nys: 1\nys: 2\n[0, 1, 2, 0, 1, 2]\nAppending xs to itself before forcing the thunks results in a single set of traces, because each thunk's code is evaluated just once:#eval xs.append xs |>.toList\nxs: 0\nxs: 1\nxs: 2\n[0, 1, 2, 0, 1, 2]\nFinally, taking a prefix of xs.append ys results in only some of the thunks in ys being evaluated:#eval xs.append ys |>.take 4 |>.toList\nxs: 0\nxs: 1\nxs: 2\nys: 0\n[0, 1, 2, 0]\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Lazy Computations","header":"19.20.3. Coercions","id":"/Basic-Types/Lazy-Computations/#Thunk-coercions"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Prefix-and-Suffix":{"contents":"Returns the longest common prefix of two substrings.The returned substring uses the same underlying string as s.\n\nReturns the longest common suffix of two substrings.The returned substring uses the same underlying string as s.\n\nIf pre is a prefix of s, returns the remainder. Returns none otherwise.The substring pre is a prefix of s if there exists a t : Substring such that\ns.toString = pre.toString ++ t.toString. If so, the result is the substring of s without the\nprefix.\n\nIf suff is a suffix of s, returns the remainder. Returns none otherwise.The substring suff is a suffix of s if there exists a t : Substring such that\ns.toString = t.toString ++ suff.toString. If so, the result the substring of s without the\nsuffix.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Substrings","header":"19.8.4.11.5. Prefix and Suffix","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Prefix-and-Suffix"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-control":{"contents":"first | conv | ... runs each conv until one succeeds, or else fails.\n\ntry tac runs tac and succeeds even if tac failed.\n\ntac <;> tac' runs tac on the main goal and tac' on each produced goal, concatenating all goals\nproduced by tac'.\n\nrepeat convs runs the sequence convs repeatedly until it fails to apply.\n\nskip does nothing.\n\n{ convs } runs the list of convs on the current target, and any subgoals that\nremain are trivially closed by skip.\n\n(convs) runs the convs in sequence on the current list of targets.\nThis is pure grouping with no added effects.\n\ndone succeeds iff there are no goals remaining.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.1. Control Structures","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-control"},"/The-Type-System/Inductive-Types/#structures":{"contents":"Structure DeclarationsDeclares a new structure type.\n\nStructures are inductive types that have only a single constructor and no indices.\nIn exchange for these restrictions, Lean generates code for structures that offers a number of conveniences: projection functions are generated for each field, an additional constructor syntax based on field names rather than positional arguments is available, a similar syntax may be used to replace the values of certain named fields, and structures may extend other structures.\nJust like other inductive types, structures may be recursive; they are subject to the same restrictions regarding strict positivity.\nStructures do not add any expressive power to Lean; all of their features are implemented in terms of code generation.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.2. Structure Declarations","id":"/The-Type-System/Inductive-Types/#structures"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Lake":{"contents":"* #5684 update toolchain on lake update* #6026 adds a newline at end of each Lean file generated by lake new\ntemplates.* #6218 makes Lake no longer automatically fetch GitHub cloud releases\nif the package build directory is already present (mirroring the\nbehavior of the Reservoir cache). This prevents the cache from\nclobbering existing prebuilt artifacts. Users can still manually fetch\nthe cache and clobber the build directory by running lake build <pkg>:release.* #6225 makes lake build also eagerly print package materialization\nlog lines. Previously, only a lake update performed eager logging.* #6231 improves the errors Lake produces when it fails to fetch a\ndependency from Reservoir. If the package is not indexed, it will\nproduce a suggestion about how to require it from GitHub.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Lake","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Lake"},"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Library":{"contents":"* #4059 upstreams many List and Array operations and theorems from Batteries.* #4055 removes the unused Inhabited instance for Subtype.* #3967 adds dates in existing @[deprecated] attributes.* #4231 adds boilerplate Char, UInt, and Fin theorems.* #4205 fixes the MonadStore type classes to use semiOutParam.* #4350 renames IsLawfulSingleton to LawfulSingleton.* Nat* #4094 swaps Nat.zero_or and Nat.or_zero.* #4098 and #4145\nchange the definition of Nat.mod so that n % (m + n) reduces when n is literal without relying on well-founded recursion,\nwhich becomes irreducible by default in #4061.* #4188 redefines Nat.testBit to be more performant.* Theorems: #4199.* Array* #4074 improves the functional induction principle Array.feraseIdx.induct.* List* #4172 removes @[simp] from List.length_pos.* Option* #4037 adds theorems to simplify Option-valued dependent if-then-else.* #4314 removes @[simp] from Option.bind_eq_some.* BitVec* Theorems: #3920, #4095,\n#4075, #4148,\n#4165, #4178,\n#4200, #4201,\n#4298, #4299,\n#4257, #4179,\n#4321, #4187.* #4193 adds simprocs for reducing x >>> i and x <<< i where i is a bitvector literal.* #4194 adds simprocs for reducing (x <<< i) <<< j and (x >>> i) >>> j where i and j are natural number literals.* #4229 redefines rotateLeft/rotateRight to use modulo reduction of shift offset.* 0d3051 makes <num>#<term> bitvector literal notation global.* Char/String* #4143 modifies String.substrEq to avoid linter warnings in downstream code.* #4233 adds simprocs for Char and String inequalities.* #4348 upstreams Mathlib lemmas.* #4354 upstreams basic String lemmas.* HashMap* #4248 fixes implicitness of typeclass arguments in HashMap.ofList.* IO* #4036 adds IO.Process.getCurrentDir and IO.Process.setCurrentDir for adjusting the current process's working directory.* Cleanup: #4077, #4189,\n#4304.* Docs: #4001, #4166,\n#4332.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.9.0 (2024-07-01)","header":"Library","id":"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Library"}});