window.docContents[16].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Modifications":{"contents":"Replaces the character at position p in the string s with the result of applying f to that\ncharacter.If both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.Examples:* (\"abc\".pos ⟨1⟩ (by decide)).modify Char.toUpper (by decide) = \"aBc\"\n\nReturns the byte at the position pos of a string.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Positions","header":"19.8.4.4.3. Modifications","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Modifications"},"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Natural-Number-Ranges":{"contents":"Checks whether a predicate holds for all natural numbers in a range.In particular, (start, stop).allI f returns true if f is true for all natural numbers from\nstart (inclusive) to stop (exclusive).Examples:* (5, 8).allI (fun j _ _ => j < 10) = (5 < 10) && (6 < 10) && (7 < 10)* (5, 8).allI (fun j _ _ => j % 2 = 0) = false* (6, 7).allI (fun j _ _ => j % 2 = 0) = true\n\nChecks whether a predicate holds for any natural number in a range.In particular, (start, stop).allI f returns true if f is true for any natural number from\nstart (inclusive) to stop (exclusive).Examples:* (5, 8).anyI (fun j _ _ => j == 6) = (5 == 6) || (6 == 6) || (7 == 6)* (5, 8).anyI (fun j _ _ => j % 2 = 0) = true* (6, 6).anyI (fun j _ _ => j % 2 = 0) = false\n\nCombines an initial value with each natural number from a range, in increasing order.In particular, (start, stop).foldI f init applies fon all the numbers\nfrom start (inclusive) to stop (exclusive) in increasing order:Examples:* (5, 8).foldI (fun j _ _ xs => xs.push j) #[] = (#[] |>.push 5 |>.push 6 |>.push 7)* (5, 8).foldI (fun j _ _ xs => xs.push j) #[] = #[5, 6, 7]* (5, 8).foldI (fun j _ _ xs => toString j :: xs) [] = [\"7\", \"6\", \"5\"]\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples\u0009Ordered Pairs\u0009API Reference","header":"19.13.1.1.2. Natural Number Ranges","id":"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Natural-Number-Ranges"},"/Error-Explanations/#The-Lean-Language-Reference--Error-Explanations":{"contents":"This section provides explanations of errors and warnings that may be generated\nby Lean when processing a source file. All error names listed below have the\nlean package prefix.\n\n* Name* Summary* Severity* Since* * Resulting type of constructor was not the inductive type being declared.* Error* 4.22.0* * Declaration depends on noncomputable definitions but is not marked as noncomputable* Error* 4.22.0* * Invalid parameter in an occurrence of an inductive type in one of its constructors.* Error* 4.22.0* * Parameter not present in an occurrence of an inductive type in one of its constructors.* Error* 4.22.0* * The type of a binder could not be inferred.* Error* 4.23.0* * The type of a definition could not be inferred.* Error* 4.23.0* * Dotted identifier notation used with invalid or uninferrable expected type.* Error* 4.22.0* * Tried to project data from a proof.* Error* 4.23.0* * Attempted to eliminate a proof into a higher type universe.* Error* 4.23.0* * Match alternative will never be reached.* Error* 4.22.0* * Failed to resolve identifier to variable or constant.* Error* 4.23.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"Error Explanations","id":"/Error-Explanations/#The-Lean-Language-Reference--Error-Explanations"},"/Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Namespaces-and-Section-Scopes":{"contents":"Every section scope has a current namespace, which is determined by the namespace command.The namespace command is described in the section on commands that introduce section scopes.\nNames that are declared within the section scope are added to the current namespace.\nIf the declared name has more than one component, then its namespace is nested within the current namespace; the body of the declaration's current namespace is the nested namespace.\nSection scopes also include a set of opened namespaces, which are namespaces whose contents are in scope without additional qualification.\nResolving an identifier to a particular name takes the current namespace and opened namespaces into account.\nHowever, protected declarations (that is, those with the protected modifier) are not brought into scope when their namespace is opened.\nThe rules for resolving identifiers into names that take the current namespace and opened namespaces into account are described in the section on identifiers as terms.\n\nCurrent NamespaceDefining an inductive type results in the type's constructors being placed in its namespace, in this case as HotDrink.coffee, HotDrink.tea, and HotDrink.cocoa.inductive HotDrink where\n  | coffee\n  | tea\n  | cocoa\nOutside the namespace, these names must be qualified unless the namespace is opened:#check HotDrink.tea\nHotDrink.tea : HotDrink\n#check tea\nUnknown identifier `tea`\nsection\nopen HotDrink\n#check tea\nend\nHotDrink.tea : HotDrink\nIf a function is defined directly inside the HotDrink namespace, then the body of the function is elaborated with the current namespace set to HotDrink.\nThe constructors are in scope:def HotDrink.ofString? : String → Option HotDrink\n  | \"coffee\" => some coffee\n  | \"tea\" => some tea\n  | \"cocoa\" => some cocoa\n  | _ => none\nDefining another inductive type creates a new namespace:inductive ColdDrink where\n  | water\n  | juice\nFrom within the HotDrink namespace, HotDrink.toString can be defined without an explicit prefix.\nDefining a function in the ColdDrink namespace requires an explicit _root_ qualifier to avoid defining HotDrink.ColdDrink.toString:namespace HotDrink\n\ndef toString : HotDrink → String\n  | coffee => \"coffee\"\n  | tea => \"tea\"\n  | cocoa => \"cocoa\"\n\ndef _root_.ColdDrink.toString : ColdDrink → String\n  | .water => \"water\"\n  | .juice => \"juice\"\n\nend HotDrink\n\n\nThe open command opens a namespace, making its contents available in the current section scope.\nThere are many variations on opening namespaces, providing flexibility in managing the local scope.\n\nOpening NamespacesThe open command is used to open a namespace:\n\nOpening Entire NamespacesA sequence of one or more identifiers results in each namespace in the sequence being opened:Each namespace in the sequence is considered relative to all currently-open namespaces, yielding a set of namespaces.\nEvery namespace in this set is opened before the next namespace in the sequence is processed.\n\nOpening Nested NamespacesNamespaces to be opened are considered relative to the currently-open namespaces.\nIf the same component occurs in different namespace paths, a single open command can be used to open all of them by iteratively bringing each into scope.\nThis example defines names in a variety of namespaces:namespace A -- _root_.A\ndef a1 := 0\nnamespace B -- _root_.A.B\ndef a2 := 0\nnamespace C -- _root_.A.B.C\ndef a3 := 0\nend C\nend B\nend A\nnamespace B -- _root_.B\ndef a4 := 0\nnamespace C -- _root_.B.C\ndef a5 := 0\nend C\nend B\nnamespace C -- _root_.C\ndef a6 := 0\nend C\nThe names are:* A.a1* A.B.a2* A.B.C.a3* B.a4* B.C.a5* C.a6All six names can be brought into scope with a single iterated open command:section\nopen A B C\nexample := [a1, a2, a3, a4, a5, a6]\nend\nIf the initial namespace in the command is A.B instead, then neither _root_.A, _root_.B, nor _root_.B.C is opened:section\nopen A.B C\nexample := [a1, a2, a3, a4, a5, a6]\nend\nUnknown identifier `a1`\nUnknown identifier `a4`\nUnknown identifier `a5`\nOpening A.B makes A.B.C visible as C along with _root_.C, so the subsequent C opens both.\n\nHiding NamesA hiding declaration specifies a set of names that should not be brought into scope.\nIn contrast to opening an entire namespace, the provided identifier must uniquely designate a namespace to be opened.\n\n\n\nRenamingA renaming declaration allows some names from the opened namespace to be renamed; they are accessible under the new name in the current section scope.\nThe provided identifier must uniquely designate a namespace to be opened.An ASCII arrow (->) may be used instead of the Unicode arrow (→).\n\n\n\nRestricted OpeningParentheses indicate that only the  names listed in the parentheses should be brought into scope.The indicated namespace is added to each currently-opened namespace, and each name is considered in each resulting namespace.\nAll of the listed names must be unambiguous; that is, they must exist in exactly one of the considered namespaces.\n\n\n\nScoped Declarations OnlyThe scoped keyword indicates that all scoped attributes, instances, and syntax from the provided namespaces should be opened, while not making any of the names available.\n\nOpening Scoped DeclarationsIn this example, a scoped notation and a definition are created in the namespace NS:namespace NS\nscoped notation \"{!{\" e \"}!}\" => (e, e)\ndef three := 3\nend NS\nOutside of the namespace, the notation is not available:def x := {!{ \"pear\" }!}\n<example>:1:21-1:22: unexpected token '!'; expected '}'\nAn open scoped command makes the notation available:open scoped NS\ndef x := {!{ \"pear\" }!}\nHowever, the name NS.three is not in scope:def y := three\nUnknown identifier `three`\n\n\n","context":"Lean Reference\u0009Namespaces and Sections\u0009Namespaces","header":"6.1.1. Namespaces and Section Scopes","id":"/Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Namespaces-and-Section-Scopes"}});