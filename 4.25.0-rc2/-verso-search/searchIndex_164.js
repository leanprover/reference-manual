window.docContents[164].resolve({"/Basic-Types/Bitvectors/#BitVec-automation":{"contents":"In addition to the full suite of automation and tools provided by Lean for every type, the bv_decide tactic can solve many bitvector-related problems.\nThis tactic invokes an external automated theorem prover (cadical) and reconstructs the proof that it provides in Lean's own logic.\nThe resulting proofs rely only on the axiom Lean.ofReduceBool; the external prover is not part of the trusted code base.\n\nPopcountThe function popcount returns the number of set bits in a bitvector.\nIt can be implemented as a 32-iteration loop that tests each bit, incrementing a counter if the bit is set:def popcount_spec (x : BitVec 32) : BitVec 32 :=\n  (32 : Nat).fold (init := 0) fun i _ pop =>\n    pop + ((x >>> i) &&& 1)\nAn alternative implementation of popcount is described in Hacker's Delight, Second Edition, by Henry S. Warren,\nJr. in Figure 5-2 on p. 82.\nIt uses low-level bitwise operations to compute the same value with far fewer operations:def popcount (x : BitVec 32) : BitVec 32 :=\n  let x := x - ((x >>> 1) &&& 0x55555555)\n  let x := (x &&& 0x33333333) + ((x >>> 2) &&& 0x33333333)\n  let x := (x + (x >>> 4)) &&& 0x0F0F0F0F\n  let x := x + (x >>> 8)\n  let x := x + (x >>> 16)\n  let x := x &&& 0x0000003F\n  x\nThese two implementations can be proven equivalent using bv_decide:theorem popcount_correct : popcount = popcount_spec := by\n  funext x\n  simp [popcount, popcount_spec]\n  bv_decide\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors","header":"19.5.4. Automation","id":"/Basic-Types/Bitvectors/#BitVec-automation"},"/Interacting-with-Lean/#The-Lean-Language-Reference--Interacting-with-Lean--Formatted-Output--Format--The--ToFormat--Class":{"contents":"The Std.ToFormat class is used to provide a standard means to format a value, with no expectation that this formatting be valid Lean syntax.\nThese instances are used in error messages and by some of the sequence concatenation operators.\n\nSpecifies a “user-facing” way to convert from the type α to a Format object. There is no\nexpectation that the resulting string is valid code.The Repr class is similar, but the expectation is that instances produce valid Lean code.Converts a value to a Format object, with no expectation that the resulting string is valid\ncode.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.7. The  ToFormat  Class","id":"/Interacting-with-Lean/#The-Lean-Language-Reference--Interacting-with-Lean--Formatted-Output--Format--The--ToFormat--Class"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.5. Tactic Reference","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-hygiene":{"contents":"Behind the scenes, tactics generate proof terms.\nThese proof terms exist in a local context, because assumptions in proof states correspond to local binders in terms.\nUses of assumptions correspond to variable references.\nIt is very important that the naming of assumptions be predictable; otherwise, small changes to the internal implementation of a tactic could either lead to variable capture or to a broken reference if they cause different names to be selected.\n\nLean's tactic language is hygienic. \nThis means that the tactic language respects lexical scope: names that occur in a tactic refer to the enclosing binding in the source code, rather than being determined by the generated code, and the tactic framework is responsible for maintaining this property.\nVariable references in tactic scripts refer either to names that were in scope at the beginning of the script or to bindings that were explicitly introduced as part of the tactics, rather than to the names chosen for use in the proof term behind the scenes.\n\nA consequence of hygienic tactics is that the only way to refer to an assumption is to explicitly name it.\nTactics cannot assign assumption names themselves, but must rather accept names from users; users are correspondingly obligated to provide names for assumptions that they wish to refer to.\nWhen an assumption does not have a user-provided name, it is shown in the proof state with a dagger ('†', DAGGER\u00090x2020).\nThe dagger indicates that the name is inaccessible and cannot be explicitly referred to.\n\nHygiene can be disabled by setting the option tactic.hygienic to false.\nThis is not recommended, as many tactics rely on the hygiene system to prevent capture and thus do not incur the overhead of careful manual name selection.\n\nmake sure tactics are hygienic\n\nTactic hygiene: inaccessible assumptionsWhen proving that ∀ (n : Nat), 0 + n = n, the initial proof state is:⊢ ∀ (n : Nat), 0 + n = n\nThe tactic intro results in a proof state with an inaccessible assumption:n✝ : Nat\n⊢ 0 + n✝ = n✝\n\n\nTactic hygiene: accessible assumptionsWhen proving that ∀ (n : Nat), 0 + n = n, the initial proof state is:⊢ ∀ (n : Nat), 0 + n = n\nThe tactic intro n, with the explicit name n, results in a proof state with an accessibly-named assumption:n : Nat\n⊢ 0 + n = n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","header":"13.3.2. Names and Hygiene","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-hygiene"},"/The-Type-System/Propositions/#propositions":{"contents":"Propositions are meaningful statements that admit proof. \nNonsensical statements are not propositions, but false statements are.\nAll propositions are classified by Prop.\n\nPropositions have the following properties:\n\n Definitional proof irrelevance\n\nAny two proofs of the same proposition are completely interchangeable.\n\n Run-time irrelevance\n\nPropositions are erased from compiled code.\n\n Impredicativity\n\nPropositions may quantify over types from any universe whatsoever.\n\n Restricted Elimination\n\nWith the exception of subsingletons, propositions cannot be eliminated into non-proposition types.\n\n Extensionality \n\nAny two logically equivalent propositions can be proven to be equal with the propext axiom.\n\n\n\nThe axiom of propositional extensionality. It asserts that if\npropositions a and b are logically equivalent (that is, if a can be proved from b and vice\nversa), then a and b are equal, meaning a can be replaced with b in all contexts.The standard logical connectives provably respect propositional extensionality. However, an axiom is\nneeded for higher order expressions like P a where P : Prop → Prop is unknown, as well as for\nequality. Propositional extensionality is intuitionistically valid.\n\n","context":"Lean Reference\u0009Type System","header":"4.2. Propositions","id":"/The-Type-System/Propositions/#propositions"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Server":{"contents":"* #6329 enables the language server to present multiple disjoint line\nranges as being worked on. Even before parallelism lands, we make use of\nthis feature to show post-elaboration tasks such as kernel checking on\nthe first line of a declaration to distinguish them from the final\ntactic step.* #6768 adds preliminary support for inlay hints, as well as support for\ninlay hints that denote the auto-implicits of a function. Hovering over\nan auto-implicit displays its type and double-clicking the auto-implicit\ninserts it into the text document.Breaking Change: The semantic highlighting request handler is not a pure\nrequest handler anymore, but a stateful one. Notably, this means that clients\nthat extend the semantic highlighting of the Lean language server with the\nchainLspRequestHandler function must now use the chainStatefulLspRequestHandler\nfunction instead.* #6887 fixes a bug where the goal state selection would sometimes\nselect incomplete incremental snapshots on whitespace, leading to an\nincorrect \"no goals\" response. Fixes #6594, a regression that was\noriginally introduced in 4.11.0 by #4727.* #6959 implements a number of refinements for the auto-implicit inlay\nhints implemented in #6768.\nSpecifically:* In #6768, there was a bug where the inlay hint edit delay could\naccumulate on successive edits, which meant that it could sometimes take\nmuch longer for inlay hints to show up. implements the basic\ninfrastructure for request cancellation and implements request\ncancellation for semantic tokens and inlay hints to resolve the issue.\nWith this edit delay bug fixed, it made more sense to increase the edit\ndelay slightly from 2000ms to 3000ms.* In #6768, we applied the edit delay to every single inlay hint request\nin order to reduce the amount of inlay hint flickering. This meant that\nthe edit delay also had a significant effect on how far inlay hints\nwould lag behind the file progress bar. adjusts the edit delay\nlogic so that it only affects requests sent directly after a\ncorresponding didChange notification. Once the edit delay is used up,\nall further semantic token requests are responded to without delay, so\nthat the only latency that affects how far the inlay hints lag behind\nthe progress bar is how often we emit refresh requests and how long VS\nCode takes to respond to them.* For inlay hints, refresh requests are now emitted 500ms after a\nresponse to an inlay hint request, not 2000ms, which means that after\nthe edit delay, inlay hints should only lag behind the progress bar by\nabout up to 500ms. This is justifiable for inlay hints because the\nresponse should be much smaller than e.g. is the case for semantic\ntokens.* In #6768, 'Restart File' did not prompt a refresh, but it does now.* VS Code does not immediately remove old inlay hints from the document\nwhen they are applied. In #6768, this meant that inlay hints would\nlinger around for a bit once applied. To mitigate this issue, this PR\nadjusts the inlay hint edit delay logic to identify edits sent from the\nclient as being inlay hint applications, and sets the edit delay to 0ms\nfor the inlay hint requests following it. This means that inlay hints\nare now applied immediately.* In #6768, hovering over single-letter auto-implicit inlay hints was a\nbit finicky because VS Code uses the regular cursor icon on inlay hints,\nnot the thin text cursor icon, which means that it is easy to put the\ncursor in the wrong spot. We now add the separation character (  or\n{) preceding an auto-implicit to the hover range as well, which makes\nhovering over inlay hints much smoother.* #6978 fixes a bug where both the inlay hint change invalidation logic\nand the inlay hint edit delay logic were broken in untitled files.\nThanks to @Julian for spotting this!* #7054 adds language server support for request cancellation to the\nfollowing expensive requests: Code actions, auto-completion, document\nsymbols, folding ranges and semantic highlighting. This means that when\nthe client informs the language server that a request is stale (e.g.\nbecause it belongs to a previous state of the document), the language\nserver will now prematurely cancel the computation of the response in\norder to reduce the CPU load for requests that will be discarded by the\nclient anyways.* #7087 ensures that all tasks in the language server either use\ndedicated tasks or reuse an existing thread from the thread pool. This\nensures that elaboration tasks cannot prevent language server tasks from\nbeing scheduled. This is especially important with parallelism right\naround the corner and elaboration becoming more likely to starve the\nlanguage server of computation, which could drive up language server\nlatencies significantly on machines with few cores.* #7112 adds a tooltip describing what the auto-implicit inlay hints\ndenote, as well as auto-implicit inlay hints for instances.* #7134 significantly improves the performance of auto-completion by\noptimizing individual requests by a factor of ~2 and by giving language\nclients like VS Code the opportunity to reuse the state of previous\ncompletion requests, thus greatly reducing the latency for the\nauto-completion list to update when adding more characters to an\nidentifier.* #7143 makes the server consistently not report newlines between trace\nnodes to the info view, enabling it to render them on dedicates lines\nwithout extraneous spacing between them in all circumstances.* #7149 adds a fast path to the inlay hint request that makes it re-use\nalready computed inlay hints from previous requests instead of\nre-computing them. This is necessary because for some reason VS Code\nemits an inlay hint request for every line you scroll, so we need to be\nable to respond to these requests against the same document state\nquickly. Otherwise, every single scrolled line would result in a request\nthat can take a few dozen ms to be responded to in long files, putting\nunnecessary pressure on the CPU.\nIt also filters the result set by the inlay hints that have been\nrequested.* #7153 changes the server to run lake setup-file on Lake\nconfiguration files (e.g., lakefile.lean).* #7175 fixes an Elab.async regression where elaboration tasks are\ncancelled on document edit even though their result may be reused in the\nnew document version, reporting an incomplete result.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Server","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Server"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Lake":{"contents":"* #9749 refactors the Lake codebase to use the new module system\nthroughout. Every module in Lake is now a module.* #10276 moves the verLit syntax into the Lake.DSL namespace to be\nconsistent with other code found in Lake.DSL.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Lake","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Lake"},"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Library":{"contents":"* Bool/Prop* #3508 improves simp confluence for Bool and Prop terms.* Theorems: #3604* Nat* #3579 makes Nat.succ_eq_add_one be a simp lemma, now that induction/cases uses n + 1 instead of Nat.succ n.* #3808 replaces Nat.succ simp rules with simprocs.* #3876 adds faster Nat.repr implementation in C.* Int* Theorems: #3890* UInts* #3960 improves performance of upcasting.* Array and Subarray* #3676 removes Array.eraseIdxAux, Array.eraseIdxSzAux, and Array.eraseIdx'.* #3648 simplifies Array.findIdx?.* #3851 renames fields of Subarray.* List* #3785 upstreams tail-recursive List operations and @[csimp] lemmas.* BitVec* Theorems: #3593,\n#3593, #3597,\n#3598, #3721,\n#3729, #3880,\n#4039.* #3884 protects Std.BitVec.* String* #3832 fixes String.splitOn.* #3959 adds String.Pos.isValid.* #3959 UTF-8 string validation.* #3961 adds a model implementation for UTF-8 encoding and decoding.* IO* #4097 adds IO.getTaskState which returns whether a task is finished, actively running, or waiting on other Tasks to finish.* Refactors* #3605 reduces imports for Init.Data.Nat and Init.Data.Int.* #3613 reduces imports for Init.Omega.Int.* #3634 upstreams Std.Data.Nat\nand #3635 upstreams Std.Data.Int.* #3790 reduces more imports for omega.* #3694 extends GetElem interface with getElem! and getElem? to simplify containers like RBMap.* #3865 renames Option.toMonad (see breaking changes below).* #3882 unifies lexOrd with compareLex.* Other fixes or improvements* #3765 makes Quotient.sound be a theorem.* #3645 fixes System.FilePath.parent in the case of absolute paths.* #3660 ByteArray.toUInt64LE! and ByteArray.toUInt64BE! were swapped.* #3881, #3887 fix linearity issues in HashMap.insertIfNew, HashSet.erase, and HashMap.erase.\nThe HashMap.insertIfNew fix improves import performance.* #3830 ensures linearity in Parsec.many*Core.* #3930 adds FS.Stream.isTty field.* #3866 deprecates Option.toBool in favor of Option.isSome.* #3975 upstreams Data.List.Init and Data.Array.Init material from Std.* #3942 adds instances that make ac_rfl work without Mathlib.* #4010 changes Fin.induction to use structural induction.* 02753f\nfixes bug in reduceLeDiff simproc.* #4097\nadds IO.TaskState and IO.getTaskState to get the task from the Lean runtime's task manager.* Docs: #3615, #3664,\n#3707, #3734,\n#3868, #3861,\n#3869, #3858,\n#3856, #3857,\n#3867, #3864,\n#3860, #3859,\n#3871, #3919.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.8.0 (2024-06-05)","header":"Library","id":"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Library"}});