window.docContents[27].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants":{"contents":"Unbundled maps separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the modules Std.HashSet.Raw and Std.HashSet.RawLemmas.\n\nHash sets without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer HashSet\nover HashSet.Raw. Lemmas about the operations on Std.Data.HashSet.Raw are available in the\nmodule Std.Data.HashSet.RawLemmas.This is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash set is used linearly to\navoid expensive copies.The hash set uses == (provided by the BEq typeclass) to compare elements and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.Internal implementation detail of the hash set.\n\nWell-formedness predicate for hash sets. Users of HashSet will not need to interact with this.\nUsers of HashSet.Raw will need to provide proofs of WF to lemmas and should use lemmas like\nWF.empty and WF.insert (which are always named exactly like the operations they are about) to\nshow that set operations preserve well-formedness.Internal implementation detail of the hash set\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"19.18.6.7. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases":{"contents":"A number of aliases are provided for commonly-used typed syntax varieties.\nThese aliases allow code to be written at a higher level of abstraction.\n\nSyntax that represents a Lean term.\n\nSyntax that represents a command.\n\nSyntax that represents a universe level.\n\nSyntax that represents a tactic.\n\nSyntax that represents a precedence (e.g. for an operator).\n\nSyntax that represents a priority (e.g. for an instance declaration).\n\nSyntax that represents an identifier.\n\nSyntax that represents a string literal.\n\nSyntax that represents a character literal.\n\nSyntax that represents a quoted name literal that begins with a back-tick.\n\nSyntax that represents a numeric literal.\n\nSyntax that represents a scientific numeric literal that may have decimal and exponential parts.\n\nSyntax that represents macro hygiene info.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.8. Aliases","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--DevOps___CI":{"contents":"* #4427 uses Namespace runners for CI for leanprover/lean4.* #4440 fixes speedcenter tests in CI.* #4441 fixes that workflow change would break CI for unrebased PRs.* #4442 fixes Wasm release-ci.* 6d265b fixes for github.event.pull_request.merge_commit_sha sometimes not being available.* 16cad2 adds optimization for CI to not fetch complete history.* #4544 causes releases to be marked as prerelease on GitHub.* #4446 switches Lake to using src/lake/lakefile.toml to avoid needing to load a version of Lake to build Lake.* Nix* 5eb5fa fixes update-stage0-commit for Nix.* #4476 adds gdb to Nix shell.* e665a0 fixes update-stage0 for Nix.* 4808eb fixes cacheRoots for Nix.* #3811 adds platform-dependent flag to lib target.* #4587 adds linking of -lStd back into nix build flags on darwin.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"DevOps/CI","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--DevOps___CI"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Grind-is-released___":{"contents":"Lean now includes a new SMT-style tactic grind, along with annotations for the Lean standard library.\ngrind ships theory-specific solvers, including cutsat (superseding omega, with model construction)\nand a new Gr√∂bner basis solver.\n\nAlso see the chapter on grind in the reference manual.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Grind is released!","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Grind-is-released___"}});