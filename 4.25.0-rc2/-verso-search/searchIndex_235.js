window.docContents[235].resolve({"/Coercions/#coercions":{"contents":"\n\nWhen the Lean elaborator is expecting one type but produces a term with a different type, it attempts to automatically insert a coercion, which is a specially designated function from the term's type to the expected type.\nCoercions make it possible to use specific types to represent data while interacting with APIs that expect less-informative types.\nThey also allow mathematical developments to follow the usual practice of “punning”, where the same symbol is used to stand for both an algebraic structure and its carrier set, with the precise meaning determined by context.\n\nLean's standard library and metaprogramming APIs define many coercions.\nSome examples include:* A Nat may be used where an Int is expected.* A Fin may be used where a Nat is expected.* An α may be used where an Option α is expected. The coercion wraps the value in some.* An α may be used where a Thunk α is expected. The coercion wraps the term in a function to delay its evaluation.* When one syntax category c1 embeds into another category c2, a coercion from TSyntax c1 to TSyntax c2 performs any necessary wrapping to construct a valid syntax tree.Coercions are found using type class synthesis.\nThe set of coercions can be extended by adding further instances of the appropriate type classes.\n\n\n\nCoercionsAll of the following examples rely on coercions:example (n : Nat) : Int := n\nexample (n : Fin k) : Nat := n\nexample (x : α) : Option α := x\n\ndef th (f : Int → String) (x : Nat) : Thunk String := f x\n\nopen Lean in\nexample (n : Ident) : Term := n\nIn the case of th, using #print demonstrates that evaluation of the function application is delayed until the thunk's value is requested:#print th\ndef th : (Int → String) → Nat → Thunk String :=\nfun f x => { fn := fun x_1 => f ↑x }\n\n\n\n\nCoercions are not used to resolve generalized field notation: only the inferred type of the term is considered.\nHowever, a type ascription can be used to trigger a coercion to the type that has the desired generalized field.\nCoercions are also not used to resolve OfNat instances: even though there is a default instance for OfNat Nat, a coercion from Nat to α does not allow natural number literals to be used for α.\n\n\n\n\n\nCoercions and Generalized Field NotationThe name Nat.bdiv is not defined, but Int.bdiv exists.\nThe coercion from Nat to Int is not considered when looking up the field bdiv:example (n : Nat) := n.bdiv 2\nInvalid field `bdiv`: The environment does not contain `Nat.bdiv`\n  n\nhas type\n  Nat\nThis is because coercions are only inserted when there is an expected type that differs from an inferred type, and generalized fields are resolved based on the inferred type of the term before the dot.\nCoercions can be triggered by adding a type ascription, which additionally causes the inferred type of the entire ascription term to be Int, allowing the function Int.bdiv to be found.example (n : Nat) := (n : Int).bdiv 2\n\n\nCoercions and OfNatBin is an inductive type that represents binary numbers.inductive Bin where\n  | done\n  | zero : Bin → Bin\n  | one : Bin → Bin\n\ndef Bin.toString : Bin → String\n  | .done => \"\"\n  | .one b => b.toString ++ \"1\"\n  | .zero b => b.toString ++ \"0\"\n\ninstance : ToString Bin where\n  toString\n    | .done => \"0\"\n    | b => Bin.toString b\nBinary numbers can be converted to natural numbers by repeatedly applying Bin.succ:def Bin.succ (b : Bin) : Bin :=\n  match b with\n  | .done => Bin.done.one\n  | .zero b => .one b\n  | .one b => .zero b.succ\n\ndef Bin.ofNat (n : Nat) : Bin :=\n  match n with\n  | 0 => .done\n  | n + 1 => (Bin.ofNat n).succ\nEven if Bin.ofNat is registered as a coercion, natural number literals cannot be used for Bin:attribute [coe] Bin.ofNat\n\ninstance : Coe Nat Bin where\n  coe := Bin.ofNat\n\n#eval (9 : Bin)\nfailed to synthesize\n  OfNat Bin 9\nnumerals are polymorphic in Lean, but the numeral `9` cannot be used in a context where the expected type is\n  Bin\ndue to the absence of the instance above\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nThis is because coercions are inserted in response to mismatched types, but a failure to synthesize an OfNat instance is not a type mismatch.The coercion can be used in the definition of the OfNat Bin instance:instance : OfNat Bin n where\n  ofNat := n\n\n#eval (10 : Bin)\n1010\n\n\nMost new coercions can be defined by declaring an instance of the Coe type class and applying the coe attribute to the function that performs the coercion.\nTo enable more control over coercions or to enable them in more contexts, Lean provides further classes that can be implemented, described in the rest of this chapter.\n\nDefining Coercions: Decimal NumbersDecimal numbers can be defined as arrays of digits.structure Decimal where\n  digits : Array (Fin 10)\nAdding a coercion allows them to be used in contexts that expect Nat, but also contexts that expect any type that Nat can be coerced to.@[coe]\ndef Decimal.toNat (d : Decimal) : Nat :=\n  d.digits.foldl (init := 0) fun n d => n * 10 + d.val\n\ninstance : Coe Decimal Nat where\n  coe := Decimal.toNat\nThis can be demonstrated by treating a Decimal as an Int as well as a Nat:def twoHundredThirteen : Decimal where\n  digits := #[2, 1, 3]\n\ndef one : Decimal where\n  digits := #[1]\n\n#eval (one : Int) - (twoHundredThirteen : Nat)\n-212\n\n\nCoe α β is the typeclass for coercions from α to β. It can be transitively\nchained with other Coe instances, and coercion is automatically used when\nx has type α but it is used in a context where β is expected.\nYou can use the ↑x operator to explicitly trigger coercion.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"12. Coercions","id":"/Coercions/#coercions"}});