window.docContents[50].resolve({"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Element-Predicates":{"contents":"Finds the index of the first byte in a for which p returns true. If no byte\nin a satisfies p, then the result is none.The variant findFinIdx? additionally returns a proof that the found index is in bounds.\n\nFinds the index of the first byte in a for which p returns true. If no byte\nin a satisfies p, then the result is none.The index is returned along with a proof that it is a valid index in the array.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.9. Element Predicates","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Element-Predicates"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Properties":{"contents":"Returns true if the hash set contains no elements.Note that if your BEq instance is not reflexive or your Hashable instance is not\nlawful, then it is possible that this function returns false even though m.contains a = false\nfor all a.\n\nThe number of elements present in the set\n\nTwo hash sets are equivalent in the sense of Equiv iff all their values are equal.Internal implementation detail of the hash map\n\nEquivalenceThe relation HashSet.Equiv can also be written with an infix operator, which is scoped to its namespace:\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"19.18.6.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Properties"},"/Basic-Types/Natural-Numbers/#nat-api-elim":{"contents":"The recursion principle that is automatically generated for Nat results in proof goals that are phrased in terms of Nat.zero and Nat.succ.\nThis is not particularly user-friendly, so an alternative logically-equivalent recursion principle is provided that results in goals that are phrased in terms of 0 and n + 1.\nCustom eliminators for the induction and cases tactics can be supplied using the induction_eliminator and cases_eliminator attributes.\n\nA recursor for Nat that uses the notations 0 for Nat.zero and n + 1 for Nat.succ.It is otherwise identical to the default recursor Nat.rec. It is used by the induction tactic\nby default for Nat.\n\nA case analysis principle for Nat that uses the notations 0 for Nat.zero and n + 1 for\nNat.succ.It is otherwise identical to the default recursor Nat.casesOn. It is used as the default Nat\ncase analysis principle for Nat by the cases tactic.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"19.1.4.8. Elimination","id":"/Basic-Types/Natural-Numbers/#nat-api-elim"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Configuration-Value-Types":{"contents":"Lake equivalent of CMake's\nCMAKE_BUILD_TYPE.Debug optimization, asserts enabled, custom debug code enabled, and\ndebug info included in executable (so you can step through the code with a\ndebugger and have address to source-file:line-number translation).\nFor example, passes -Og -g when compiling C code.Optimized, with debug info, but no debug code or asserts\n(e.g., passes -O3 -g -DNDEBUG when compiling C code).Same as release but optimizing for size rather than speed\n(e.g., passes -Os -DNDEBUG when compiling C code).High optimization level and no debug info, code, or asserts\n(e.g., passes -O3 -DNDEBUG when compiling C code).\n\nIn Lake's DSL, globs are patterns that match sets of module names.\nThere is a coercion from names to globs that match the name in question, and there are two postfix operators for constructing further globs.\n\n\n\nGlob SyntaxThe glob pattern N.* matches N or any submodule for which N is a prefix.The glob pattern N.* matches any submodule for which N is a strict prefix, but not N itself.Whitespace is not permitted between the name and .* or .+.\n\nA specification of a set of module names.Selects just the specified module name.Selects all submodules of the specified module, but not the module itself.Selects the specified module and all submodules.\n\nAn option that is used by Lean as if it was passed using -D.The option's name.The option's value.\n\nCompiler backend with which to compile Lean.Force the C backend.Force the LLVM backend.Use the default backend. Can be overridden by more specific configuration.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"22.1.3.2.5. Configuration Value Types","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Configuration-Value-Types"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Monad-Type-Classes":{"contents":"Using type classes like MonadState and MonadExcept allow client code to be polymorphic with respect to monads.\nTogether with automatic lifting, this allows programs to be re-usable in many different monads and makes them more robust to refactoring.\n\nIt's important to be aware that effects in a monad may not interact in only one way.\nFor example, a monad with state and exceptions may or may not roll back state changes when an exception is thrown.\nIf this matters for the correctness of a function, then it should use a more specific signature.\n\nEffect OrderingThe function sumNonFives adds the contents of a list using a state monad, terminating early if it encounters a 5.def sumNonFives {m}\n    [Monad m] [MonadState Nat m] [MonadExcept String m]\n    (xs : List Nat) :\n    m Unit := do\n  for x in xs do\n    if x == 5 then\n      throw \"Five was encountered\"\n    else\n      modify (· + x)\nRunning it in one monad returns the state at the time that 5 was encountered:#eval\n  sumNonFives (m := ExceptT String (StateM Nat))\n    [1, 2, 3, 4, 5, 6] |>.run |>.run 0\n(Except.error \"Five was encountered\", 10)\nIn another, the state is discarded:#eval\n  sumNonFives (m := StateT Nat (Except String))\n    [1, 2, 3, 4, 5, 6] |>.run 0\nExcept.error \"Five was encountered\"\nIn the second case, an exception handler would roll back the state to its value at the start of the try.\nThe following function is thus incorrect:/-- Computes the sum of the non-5 prefix of a list. -/\ndef sumUntilFive {m}\n    [Monad m] [MonadState Nat m] [MonadExcept String m]\n    (xs : List Nat) :\n    m Nat := do\n  MonadState.set 0\n  try\n    sumNonFives xs\n  catch _ =>\n    pure ()\n  get\nIn one monad, the answer is correct:#eval\n  sumUntilFive (m := ExceptT String (StateM Nat))\n    [1, 2, 3, 4, 5, 6] |>.run |>.run' 0\nExcept.ok 10\nIn the other, it is not:#eval\n  sumUntilFive (m := StateT Nat (Except String))\n    [1, 2, 3, 4, 5, 6] |>.run' 0\nExcept.ok 0\n\n\nA single monad may support multiple version of the same effect.\nFor example, there might be a mutable Nat and a mutable String or two separate reader parameters.\nAs long as they have different types, it should be convenient to access both.\nIn typical use, some monadic operations that are overloaded in type classes have type information available for instance synthesis, while others do not.\nFor example, the argument passed to set determines the type of the state to be used, while get takes no such argument.\nThe type information present in applications of set can be used to pick the correct instance when multiple states are available, which suggests that the type of the mutable state should be an input parameter or semi-output parameter so that it can be used to select instances.\nThe lack of type information present in uses of get, on the other hand, suggests that the type of the mutable state should be an output parameter in MonadState, so type class synthesis determines the state's type from the monad itself.\n\nThis dichotomy is solved by having two versions of many of the effect type classes.\nThe version with a semi-output parameter has the suffix -Of, and its operations take types explicitly as needed.\nExamples include MonadStateOf, MonadReaderOf, and MonadExceptOf.\nThe operations with explicit type parameters have names ending in -The, such as getThe, readThe, and tryCatchThe.\nThe name of the version with an output parameter is undecorated.\nThe standard library exports a mix of operations from the -Of and undecorated versions of each type class, based on what has good inference behavior in typical use cases.\n\n* Operation* From Class* Notes\n  * get* MonadState* Output parameter improves type inference\n  * set* MonadStateOf* Semi-output parameter uses type information from set's argument\n  * modify* MonadState* Output parameter is needed to allow functions without annotations\n  * modifyGet* MonadState* Output parameter is needed to allow functions without annotations\n  * read* MonadReader* Output parameter is needed due to lack of type information from arguments\n  * readThe* MonadReaderOf* Semi-output parameter uses the provided type to guide synthesis\n  * withReader* MonadWithReader* Output parameter avoids the need for type annotations on the function\n  * withTheReader* MonadWithReaderOf* Semi-output parameter uses provided type to guide synthesis\n  * throw* MonadExcept* Output parameter enables the use of constructor dot notation for the exception\n  * throwThe* MonadExceptOf* Semi-output parameter uses provided type to guide synthesis\n  * tryCatch* MonadExcept* Output parameter enables the use of constructor dot notation for the exception\n  * tryCatchThe* MonadExceptOf* Semi-output parameter uses provided type to guide synthesis\n\n\n\nState TypesThe state monad M has two separate states: a Nat and a String.abbrev M := StateT Nat (StateM String)\nBecause get is an alias for MonadState.get, the state type is an output parameter.\nThis means that Lean selects a state type automatically, in this case the one from the outermost monad transformer:#check (get : M _)\nget : M Nat\nOnly the outermost may be used, because the type of the state is an output parameter.#check (get : M String)\nfailed to synthesize\n  MonadState String M\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nProviding the state type explicitly using getThe from MonadStateOf allows both states to be read.#check ((getThe String, getThe Nat) : M String × M Nat)\n(getThe String, getThe Nat) : M String × M Nat\nSetting a state works for either type, because the state type is a semi-output parameter on MonadStateOf.#check (set 4 : M Unit)\nset 4 : M PUnit\n#check (set \"Four\" : M Unit)\nset \"Four\" : M PUnit\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.1. Monad Type Classes","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Monad-Type-Classes"},"/Terms/Functions/#function-terms":{"contents":"Terms with function types can be created via abstractions, introduced with the fun keyword.In various communities, function abstractions are also known as lambdas, due to Alonzo Church's notation for them, or anonymous functions because they don't need to be defined with a name in the global environment.\nWhile abstractions in the core type theory only allow a single variable to be bound, function terms are quite flexible in the high-level Lean syntax.\n\nFunction AbstractionThe most basic function abstraction introduces a variable to stand for the function's parameter:At elaboration time, Lean must be able to determine the function's domain.\nA type ascription is one way to provide this information:\n\nFunction definitions defined with keywords such as def desugar to fun.\nInductive type declarations, on the other hand, introduce new values with function types (constructors and type constructors) that cannot themselves be implemented using just fun.\n\nCurried FunctionsMultiple parameter names are accepted after fun:Different type annotations for multiple parameters require parentheses:These are equivalent to writing nested fun terms.\n\nThe => may be replaced by ↦ in all of the syntax described in this section.\n\nFunction abstractions may also use pattern matching syntax as part of their parameter specification, avoiding the need to introduce a local variable that is immediately destructured.\nThis syntax is described in the section on pattern matching.\n\n\n\n","context":"Lean Reference\u0009Terms","header":"10.3. Functions","id":"/Terms/Functions/#function-terms"},"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat":{"contents":"The linear integer arithmetic solver, cutsat, implements a model-based decision procedure for linear integer arithmetic.\nThe solver can process four categories of linear polynomial constraints (where p is a linear polynomial): Equality\n\np = 0\n\n Divisibility\n\nd ∣ p\n\n Inequality\n\np ≤ 0\n\n Disequality\n\np ≠ 0\n\nIt is complete for linear integer arithmetic, and natural numbers are supported by converting them to integers with Int.ofNat.\nSupport for additional types that can be embedded into Int can be added via instances of Lean.Grind.ToInt.\nNonlinear terms (e.g. x * x) are allowed, and are represented as variables.\nThe solver is additionally capable of propagating information back to the metaphorical grind whiteboard, which can trigger further progress from the other subsystems.\n\nExamples of cutsatAll of these statements can be proved using cutsat.\nIn the first example, the left-hand side must be a multiple of 2, and thus cannot be 5:example {x y : Int} : 2 * x + 4 * y ≠ 5 := by\n  grind\nThe solver supports mixing equalities and inequalities:example {x y : Int} :\n    2 * x + 3 * y = 0 →\n    1 ≤ x →\n    y < 1 := by\n  grind\nIt also supports linear divisibility constraints:example (a b : Int) :\n    2 ∣ a + 1 →\n    2 ∣ b + a →\n    ¬ 2 ∣ b + 2 * a := by\n  grind\nWithout cutsat, grind cannot prove the statement:example (a b : Int) :\n    2 ∣ a + 1 →\n    2 ∣ b + a →\n    ¬ 2 ∣ b + 2 * a := by\n  grind -cutsat\n`grind` failed\ncase grind\na b : Int\nh : 2 ∣ a + 1\nh_1 : 2 ∣ a + b\nh_2 : 2 ∣ 2 * a + b\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n  [linarith] Linarith assignment for `Int`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.7. Linear Integer Arithmetic","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights":{"contents":"Lean 4.24.0 release brings continued improvements to the module system and the verification framework,\nstrengthens the grind tactic, and advances the standard library.\nThe release also introduces more efficient constructions of DecidableEq instances and noConfusion (#10152 and #10300),\noptimizing compilation.\n\nAs an example for our continuous improvements to performance:\n\n* #10249 speeds up auto-completion by a factor of ~3.5x through various\nperformance improvements in the language server.\n\nAs always, there are plenty of bug fixes and new features, some of which are listed below:\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Highlights","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights"}});