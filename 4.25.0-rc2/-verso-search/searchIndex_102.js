window.docContents[102].resolve({"/Basic-Types/Linked-Lists/#list-api-reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists","header":"19.15.3. API Reference","id":"/Basic-Types/Linked-Lists/#list-api-reference"},"/Tactic-Proofs/Reading-Proof-States/#metavariables-in-proofs":{"contents":"Terms that begin with a question mark are metavariables that correspond to an unknown value.\nThey may stand for either universe levels or for terms.\nSome metavariables arise as part of Lean's elaboration process, when not enough information is yet available to determine a value.\nThese metavariables' names have a numeric component at the end, such as ?m.392 or ?u.498.\nOther metavariables come into existence as a result of tactics or synthetic holes.\nThese metavariables' names do not have a numeric component.\nMetavariables that result from tactics frequently appear as goals whose case labels match the name of the metavariable.\n\nUniverse Level MetavariablesIn this proof state, the universe level of α is unknown:α : Type ?u.8219\nx : α\nxs : List α\nelem : x ∈ xs\n⊢ xs.length > 0\n\nType MetavariablesIn this proof state, the type of list elements is unknown.\nThe metavariable is repeated because the unknown type must be the same in both positions.x : ?m.8\nxs : List ?m.8\nelem : x ∈ xs\n⊢ xs.length > 0\n\nMetavariables in ProofsIn this proof state,i j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ i < k\napplying the tactic apply Nat.lt_trans results in the following proof state, in which the middle value of the transitivity step ?m is unknown:case h₁\ni j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ i < ?m\n\ncase a\ni j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ ?m < k\n\ncase m\ni j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ Nat\n\n\nExplicitly-Created MetavariablesExplicit named holes are represented by metavariables, and additionally give rise to proof goals.\nIn this proof state,i j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ i < k\napplying the tactic apply @Nat.lt_trans i ?middle k ?p1 ?p2 results in the following proof state, in which the middle value of the transitivity step ?middle is unknown and goals have been created for each of the named holes in the term:case middle\ni j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ Nat\n\ncase p1\ni j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ i < ?middle\n\ncase p2\ni j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ ?middle < k\n\n\nThe display of metavariable numbers can be disabled using the pp.mvars.\nThis can be useful when using features such as #guard_msgs that match Lean's output against a desired string, which is very useful when writing tests for custom tactics.\n\n(pretty printer) display names of metavariables when true, and otherwise display them as '?' (for expression metavariables) and as '' (for universe level metavariables)\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Reading Proof States","header":"13.2.2. Metavariables","id":"/Tactic-Proofs/Reading-Proof-States/#metavariables-in-proofs"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Compiler":{"contents":"* #6535 avoids a linker warning on Windows.* #6547 should prevent Lake from accidentally picking up other linkers\ninstalled on the machine.* #6574 actually prevents Lake from accidentally picking up other\ntoolchains installed on the machine.* #6664 changes the toMono pass to longer filter out type class\ninstances, because they may actually be needed for later compilation.* #6665 adds a new lcAny constant to Prelude, which is meant for use in\nLCNF to represent types whose dependency on another term has been erased\nduring compilation. This is in addition to the existing lcErased\nconstant, which represents types that are irrelevant.* #6678 modifies LCNF.toMonoType to use a more refined type erasure\nscheme, which distinguishes between irrelevant/erased information\n(represented by lcErased) and erased type dependencies (represented by\nlcAny). This corresponds to the irrelevant/object distinction in the old\ncode generator.* #6680 makes the new code generator skip generating code for decls with\nan implemented_by decl, just like the old code generator.* #6757 adds support for applying crimp theorems in toLCNF.* #6758 prevents deadlocks from non-cyclical task waits that may\notherwise occur during parallel elaboration with small threadpool sizes.* #6837 adds Float32 to the LCNF builtinRuntimeTypes list. This was\nmissed during the initial Float32 implementation, but this omission has\nthe side effect of lowering Float32 to obj in the IR.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Compiler","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Compiler"}});