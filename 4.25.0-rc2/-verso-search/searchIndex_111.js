window.docContents[111].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Proof-Automation":{"contents":"\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"19.5.5.10. Proof Automation","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Proof-Automation"},"/Coercions/Implementation-Details/#coercion-chain-impl":{"contents":"Coercion chaining is implemented through a collection of auxiliary type classes.\nUsers should not write instances of these classes directly, but knowledge of their structure can be useful when diagnosing the reason why a coercion was not inserted as expected.\nThe specific rules governing the ordering of instances in the chain (namely, that it should match CoeHead﻿?CoeOut﻿*Coe﻿*CoeTail﻿?) are implemented by the following type classes:* CoeTC is the transitive closure of Coe instances.* CoeOTC is the middle of the chain, consisting of the transitive closure of CoeOut instances followed by CoeTC.* CoeHTC is the start of the chain, consisting of at most one CoeHead instance followed by CoeOTC.* CoeHTCT is the whole chain, consisting of CoeHTC followed by at most one CoeTail instance. Alternatively, it might be a NatCast instance.* CoeT represents the entire chain: it is either a CoeHTCT chain or a single CoeDep instance.\n\nAuxiliary Classes for Coercions \n\nAuxiliary class implementing CoeHead* Coe* CoeTail?.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nAuxiliary class implementing CoeHead CoeOut* Coe*.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nAuxiliary class implementing CoeOut* Coe*.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nAuxiliary class implementing Coe*.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\n","context":"Lean Reference\u0009Coercions\u0009Implementation Details","header":"12.5.2. Coercion Chaining","id":"/Coercions/Implementation-Details/#coercion-chain-impl"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-reduction":{"contents":"Reduces the target to Weak Head Normal Form. This reduces definitions\nin \"head position\" until a constructor is exposed. For example, List.map f [a, b, c]\nweak head normalizes to f a :: List.map f [b, c].\n\nPuts term in normal form, this tactic is meant for debugging purposes only.\n\nExpands let-declarations and let-variables.\n\ndelta id1 id2 ... unfolds all occurrences of id1, id2, ... in the target.\nLike the delta tactic, this ignores any definitional equations and uses\nprimitive delta-reduction instead, which may result in leaking implementation details.\nUsers should prefer unfold for unfolding definitions.\n\n* unfold id unfolds all occurrences of definition id in the target.* unfold id1 id2 ... is equivalent to unfold id1; unfold id2; ....Definitions can be either global or local definitions.For non-recursive global definitions, this tactic is identical to delta.\nFor recursive global definitions, it uses the \"unfolding lemma\" id.eq_def,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to simp only [id], which unfolds definition id recursively.This is the conv version of the unfold tactic.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv\u0009Changing the Goal","header":"13.6.4.1. Reduction","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-reduction"},"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Language-features___-tactics___-and-metaprograms":{"contents":"* Definition transparency* #4053 adds the seal and unseal commands, which make definitions locally be irreducible or semireducible.* #4061 marks functions defined by well-founded recursion with @[irreducible] by default,\nwhich should prevent the expensive and often unfruitful unfolding of such definitions (see breaking changes below).* Incrementality* #3940 extends incremental elaboration into various steps inside of declarations:\ndefinition headers, bodies, and tactics.Screen recording.* 250994\nand 67338b\nadd @[incremental] attribute to mark an elaborator as supporting incremental elaboration.* #4259 improves resilience by ensuring incremental commands and tactics are reached only in supported ways.* #4268 adds special handling for := by so that stray tokens in tactic blocks do not inhibit incrementality.* #4308 adds incremental have tactic.* #4340 fixes incorrect info tree reuse.* #4364 adds incrementality for careful command macros such as set_option in theorem, theorem foo.bar, and lemma.* #4395 adds conservative fix for whitespace handling to avoid incremental reuse leading to goals in front of the text cursor being shown.* #4407 fixes non-incremental commands in macros blocking further incremental reporting.* #4436 fixes incremental reporting when there are nested tactics in terms.* #4459 adds incrementality support for next and if tactics.* #4554 disables incrementality for tactics in terms in tactics.* Functional induction* #4135 ensures that the names used for functional induction are reserved.* #4327 adds support for structural recursion on reflexive types.\nFor example,inductive Many (α : Type u) where\n  | none : Many α\n  | more : α → (Unit → Many α) → Many α\n\ndef Many.map {α β : Type u} (f : α → β) : Many α → Many β\n  | .none => .none\n  | .more x xs => .more (f x) (fun _ => (xs ()).map f)\n\n#check Many.map.induct\n/-\nMany.map.induct {α β : Type u} (f : α → β) (motive : Many α → Prop)\n  (case1 : motive Many.none)\n  (case2 : ∀ (x : α) (xs : Unit → Many α), motive (xs ()) → motive (Many.more x xs)) :\n  ∀ (a : Many α), motive a\n-/\n* #3903 makes the Lean frontend normalize all line endings to LF before processing.\nThis lets Lean be insensitive to CRLF vs LF line endings, improving the cross-platform experience and making Lake hashes be faithful to what Lean processes.* #4130 makes the tactic framework be able to recover from runtime errors (for example, deterministic timeouts or maximum recursion depth errors).* split tactic* #4211 fixes split at h when h has forward dependencies.* #4349 allows split for if-expressions to work on non-propositional goals.* apply tactic* #3929 makes error message for apply show implicit arguments in unification errors as needed.\nModifies MessageData type (see breaking changes below).* cases tactic* #4224 adds support for unification of offsets such as x + 20000 = 20001 in cases tactic.* omega tactic* #4073 lets omega fall back to using classical Decidable instances when setting up contradiction proofs.* #4141 and #4184 fix bugs.* #4264 improves omega error message if no facts found in local context.* #4358 improves expression matching in omega by using match_expr.* simp tactic* #4176 makes names of erased lemmas clickable.* #4208 adds a pretty printer for discrimination tree keys.* #4202 adds Simp.Config.index configuration option,\nwhich controls whether to use the full discrimination tree when selecting candidate simp lemmas.\nWhen index := false, only the head function is taken into account, like in Lean 3.\nThis feature can help users diagnose tricky simp failures or issues in code from libraries\ndeveloped using Lean 3 and then ported to Lean 4.In the following example, it will report that foo is a problematic theorem.opaque f : Nat → Nat → Nat\n\n@[simp] theorem foo : f x (x, y).2 = y := by sorry\n\nexample : f a b ≤ b := by\n  set_option diagnostics true in\n  simp (config := { index := false })\n/-\n[simp] theorems with bad keys\n  foo, key: f _ (@Prod.mk ℕ ℕ _ _).2\n-/\nWith the information above, users can annotate theorems such as foo using no_index for problematic subterms. Example:opaque f : Nat → Nat → Nat\n\n@[simp] theorem foo : f x (no_index (x, y).2) = y := by sorry\n\nexample : f a b ≤ b := by\n  simp -- `foo` is still applied with `index := true`\n* #4274 prevents internal match equational theorems from appearing in simp trace.* #4177 and #4359 make simp continue even if a simp lemma does not elaborate, if the tactic state is in recovery mode.* #4341 fixes panic when applying @[simp] to malformed theorem syntax.* #4345 fixes simp so that it does not use the forward version of a user-specified backward theorem.* #4352 adds missing dsimp simplifications for fixed parameters of generated congruence theorems.* #4362 improves trace messages for simp so that constants are hoverable.* Elaboration* #4046 makes subst notation (he ▸ h) try rewriting in both directions even when there is no expected type available.* #3328 adds support for identifiers in autoparams (for example, rfl in (h : x = y := by exact rfl)).* #4096 changes how the type in let and have is elaborated, requiring that any tactics in the type be evaluated before proceeding, improving performance.* #4215 ensures the expression tree elaborator commits to the computed \"max type\" for the entire arithmetic expression.* #4267 cases signature elaboration errors to show even if there are parse errors in the body.* #4368 improves error messages when numeric literals fail to synthesize an OfNat instance,\nincluding special messages warning when the expected type of the numeral can be a proposition.* #4643 fixes issue leading to nested error messages and info trees vanishing, where snapshot subtrees were not restored on reuse.* #4657 calculates error suppression per snapshot, letting elaboration errors appear even when there are later parse errors (RFC #3556).* Metaprogramming* #4167 adds Lean.MVarId.revertAll to revert all free variables.* #4169 adds Lean.MVarId.ensureNoMVar to ensure the goal's target contains no expression metavariables.* #4180 adds cleanupAnnotations parameter to forallTelescope methods.* #4307 adds support for parser aliases in syntax quotations.* Work toward implementing grind tactic* 0a515e\nand #4164\nadd grind_norm and grind_norm_proc attributes and @[grind_norm] theorems.* #4170, #4221,\nand #4249 create grind preprocessor and core module.* #4235 and d6709e\nadd special cases tactic to grind along with @[grind_cases] attribute to mark types that this cases tactic should automatically apply to.* #4243 adds special injection? tactic to grind.* Other fixes or improvements* #4065 fixes a bug in the Nat.reduceLeDiff simproc.* #3969 makes deprecation warnings activate even for generalized field notation (\"dot notation\").* #4132 fixes the sorry term so that it does not activate the implicit lambda feature* 9803c5\nand 47c8e3\nmove cdot and calc parsers to Lean namespace.* #4252 fixes the case tactic so that it is usable in macros by having it erase macro scopes from the tag.* 26b671\nand cc33c3\nextract haveId syntax.* #4335 fixes bugs in partial calc tactic when there is mdata or metavariables.* #4329 makes termination_by? report unused each unused parameter as _.* Docs: #4238, #4294,\n#4338.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.9.0 (2024-07-01)","header":"Language features, tactics, and metaprograms","id":"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Language-features___-tactics___-and-metaprograms"}});