window.docContents[219].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Properties":{"contents":"The number of mappings present in the hash map\n\nReturns true if the hash map contains no mappings.Note that if your BEq instance is not reflexive or your Hashable instance is not\nlawful, then it is possible that this function returns false even though is not possible\nto get anything out of the hash map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Maps","header":"19.18.4.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Properties"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Modification":{"contents":"Inserts the given element into the set. If the hash set already contains an element that is\nequal (with regard to ==) to the given element, then the hash set is returned unchanged.Note: this non-replacement behavior is true for HashSet and HashSet.Raw.\nThe insert function on HashMap, DHashMap, HashMap.Raw and DHashMap.Raw behaves\ndifferently: it will overwrite an existing mapping.\n\nInserts multiple mappings into the hash set by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the first occurrence takes precedence.Note: this precedence behavior is true for HashSet and HashSet.Raw. The insertMany function on\nHashMap, DHashMap, HashMap.Raw and DHashMap.Raw behaves differently: it will prefer the last\nappearance.\n\nRemoves the element if it exists.\n\nRemoves all elements from the hash set for which the given function returns false.\n\nChecks whether an element is present in a set and inserts the element if it was not found.\nIf the hash set already contains an element that is equal (with regard to ==) to the given\nelement, then the hash set is returned unchanged.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nPartition a hashset into two hashsets based on a predicate.\n\nComputes the union of the given hash sets.This function always merges the smaller set into the larger set, so the expected runtime is\nO(min(m₁.size, m₂.size)).\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"19.18.6.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Modification"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-self":{"contents":"Elan can manage its own installation.\nIt can upgrade itself, remove itself, and help configure tab completion for many popular shells.\n\n\n\n\n\nDownloads and installs updates to Elan itself.\n\nUninstalls Elan.\n\n\n\nGenerates shell completion scripts for Elan, enabling tab completion for Elan commands in a variety of shells.\nSee the output of elan help completions for a description of how to install them.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Command-Line Interface","header":"22.2.3.6. Managing Elan","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-self"},"/Definitions/Example-Declarations/#The-Lean-Language-Reference--Definitions--Example-Declarations":{"contents":"An example is an anonymous definition that is elaborated and then discarded.\nExamples are useful for incremental testing during development and to make it easier to understand a file.\n\nExamples\n\n","context":"Lean Reference\u0009Definitions","header":"7.5. Example Declarations","id":"/Definitions/Example-Declarations/#The-Lean-Language-Reference--Definitions--Example-Declarations"},"/Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads":{"contents":"When one monad is at least as capable as another, then actions from the latter monad can be used in a context that expects actions from the former.\nThis is called lifting the action from one monad to another.\nLean automatically inserts lifts when they are available; lifts are defined in the MonadLift type class.\nAutomatic monad lifting is attempted before the general coercion mechanism.Computations in the monad m can be run in the monad n. These translations are inserted\nautomatically by the compiler.Usually, n consists of some number of monad transformers applied to m, but this is not\nmandatory.New instances should use this class, MonadLift. Clients that require one monad to be liftable into\nanother should instead request MonadLiftT, which is the reflexive, transitive closure of\nMonadLift.Translates an action from monad m into monad n.Lifting between monads is reflexive and transitive:* Any monad can run its own actions.* Lifts from m to m' and from m' to n can be composed to yield a lift from m to n.\nThe utility type class MonadLiftT constructs lifts via the reflexive and transitive closure of MonadLift instances.\nUsers should not define new instances of MonadLiftT, but it is useful as an instance implicit parameter to a polymorphic function that needs to run actions from multiple monads in some user-provided monad.Computations in the monad m can be run in the monad n. These translations are inserted\nautomatically by the compiler.Usually, n consists of some number of monad transformers applied to m, but this is not\nmandatory.This is the reflexive, transitive closure of MonadLift. Clients that require one monad to be\nliftable into another should request an instance of MonadLiftT. New instances should instead be\ndefined for MonadLift itself.Translates an action from monad m into monad n.Monad Lifts in Function SignaturesThe function IO.withStdin has the following signature:IO.withStdin.{u} {m : Type → Type u} {α : Type}\n  [Monad m] [MonadFinally m] [MonadLiftT BaseIO m]\n  (h : IO.FS.Stream) (x : m α) :\n  m α\nBecause it doesn't require its parameter to precisely be in IO, it can be used in many monads, and the body does not need to restrict itself to IO.\nThe instance implicit parameter MonadLiftT BaseIO m allows the reflexive transitive closure of MonadLift to be used to assemble the lift.When a term of type n β is expected, but the provided term has type m α, and the two types are not definitionally equal, Lean attempts to insert lifts and coercions before reporting an error.\nThere are the following possibilities:1. If m and n can be unified to the same monad, then α and β are not the same.\n    In this case, no monad lifts are necessary, but the value in the monad must be coerced.\n    If the appropriate coercion is found, then a call to Lean.Internal.coeM is inserted, which has the following signature:Lean.Internal.coeM.{u, v} {m : Type u → Type v} {α β : Type u}\n  [(a : α) → CoeT α a β] [Monad m]\n  (x : m α) :\n  m β\n2. If α and β can be unified, then the monads differ.\n    In this case, a monad lift is necessary to transform an expression with type m α to n α.\n    If m can be lifted to n (that is, there is an instance of MonadLiftT m n) then a call to liftM, which is an alias for MonadLiftT.monadLift, is inserted.liftM.{u, v, w}\n  {m : Type u → Type v} {n : Type u → Type w}\n  [self : MonadLiftT m n] {α : Type u} :\n  m α → n α\n3. If neither m and n nor α and β can be unified, but m can be lifted into n and α can be coerced to β, then a lift and a coercion can be combined.\n    This is done by inserting a call to Lean.Internal.liftCoeM:Lean.Internal.liftCoeM.{u, v, w}\n  {m : Type u → Type v} {n : Type u → Type w}\n  {α β : Type u}\n  [MonadLiftT m n] [(a : α) → CoeT α a β] [Monad n]\n  (x : m α) :\n  n β\nAs their names suggest, Lean.Internal.coeM and Lean.Internal.liftCoeM are implementation details, not part of the public API.\nIn the resulting terms, occurrences of Lean.Internal.coeM, Lean.Internal.liftCoeM, and coercions are unfolded.\n\nLifting IO MonadsThere is an instance of MonadLift BaseIO IO, so any BaseIO action can be run in IO as well:def fromBaseIO (act : BaseIO α) : IO α := act\nBehind the scenes, liftM is inserted:#check fun {α} (act : BaseIO α) => (act : IO α)\nfun {α} act => liftM act : {α : Type} → BaseIO α → EIO IO.Error α\n\n\nLifting Transformed MonadsThere are also instances of MonadLift for most of the standard library's monad transformers, so base monad actions can be used in transformed monads without additional work.\nFor example, state monad actions can be lifted across reader and exception transformers, allowing compatible monads to be intermixed freely:def incrBy (n : Nat) : StateM Nat Unit := modify (· + n)\n\ndef incrOrFail : ReaderT Nat (ExceptT String (StateM Nat)) Unit := do\n  if (← read) > 5 then throw \"Too much!\"\n  incrBy (← read)\nDisabling lifting causes an error:set_option autoLift false\n\ndef incrBy (n : Nat) : StateM Nat Unit := modify (. + n)\n\ndef incrOrFail : ReaderT Nat (ExceptT String (StateM Nat)) Unit := do\n  if (← read) > 5 then throw \"Too much!\"\n  incrBy (← read)\nType mismatch\n  incrBy __do_lift✝\nhas type\n  StateM Nat Unit\nbut is expected to have type\n  ReaderT Nat (ExceptT String (StateM Nat)) Unit\n\n\nAutomatic lifting can be disabled by setting autoLift to false.\n\nInsert monadic lifts (i.e., liftM and coercions) when needed.\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation","header":"14.2. Lifting Monads","id":"/Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads"},"/IO/Processes/#io-processes":{"contents":"\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.9. Processes","id":"/IO/Processes/#io-processes"},"/Run-Time-Code/Foreign-Function-Interface/#ffi-types":{"contents":"\n\nIn the ABI, Lean types are translated to C types as follows:\n\n* The integer types UInt8, …, UInt64, USize are represented by the C types uint8_t, ..., uint64_t, size_t, respectively.\n  If their run-time representation requires boxing, then they are unboxed at the FFI boundary.* Char is represented by uint32_t.* Float is represented by double.* Nat and Int are represented by lean_object *.\n  Their runtime values is either a pointer to an opaque bignum object or, if the lowest bit of the \"pointer\" is 1 (lean_is_scalar), an encoded natural number or integer (lean_box/lean_unbox).* A universe Sort u, type constructor ... → Sort u, or proposition p​ : Prop is irrelevant and is either statically erased (see above) or represented as a lean_object * with the runtime value lean_box(0)* The ABI for other inductive types that don't have special compiler support depends on the specifics of the type.\n  It is the same as the run-time representation of these types.\n  Its runtime value is either a pointer to an object of a subtype of lean_object (see the \"Inductive types\" section below) or it is the value lean_box(cidx) for the cidxth constructor of an inductive type if this constructor does not have any relevant parameters.\n\nUnit in the ABIThe runtime value of u​:Unit is always lean_box(0).\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Foreign Function Interface\u0009The Lean ABI","header":"21.4.1.1. Translating Types from Lean to C","id":"/Run-Time-Code/Foreign-Function-Interface/#ffi-types"},"/The-Type-System/Inductive-Types/#run-time-inductives":{"contents":"An inductive type's run-time representation depends both on how many constructors it has, how many arguments each constructor takes, and whether these arguments are relevant.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.4. Run-Time Representation","id":"/The-Type-System/Inductive-Types/#run-time-inductives"}});