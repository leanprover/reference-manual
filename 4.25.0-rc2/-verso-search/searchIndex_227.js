window.docContents[227].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Element-Predicates":{"contents":"Tests each element in a subarray with a Boolean predicate in reverse order, stopping at the first\nelement that satisfies the predicate. The element that satisfies the predicate is returned, or\nnone if no element satisfies the predicate.Examples:* #[\"red\", \"green\", \"blue\"].toSubarray.findRev? (·.length ≠ 4) = some \"green\"* #[\"red\", \"green\", \"blue\"].toSubarray.findRev? (fun _ => true) = some \"blue\"* #[\"red\", \"green\", \"blue\"].toSubarray 0 0 |>.findRev? (fun _ => true) = none\n\nApplies a monadic Boolean predicate to each element in a subarray in reverse order, stopping at the\nfirst element that satisfies the predicate. The element that satisfies the predicate is returned, or\nnone if no element satisfies it.Example:#eval #[\"red\", \"green\", \"blue\"].toSubarray.findRevM? fun x => do\n  IO.println x\n  return (x.length = 5)\nblue\ngreen\nsome 5\n\n\nApplies a monadic function to each element in a subarray in reverse order, stopping at the first\nelement for which the function succeeds by returning a value other than none. The succeeding value\nis returned, or none if there is no success.Example:#eval #[\"red\", \"green\", \"blue\"].toSubarray.findSomeRevM? fun x => do\n  IO.println x\n  return Option.guard (· = 5) x.length\nblue\ngreen\nsome 5\n\n\nChecks whether all of the elements in a subarray satisfy a Boolean predicate.The elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that does not satisfy the predicate is found.\n\nChecks whether all of the elements in a subarray satisfy a monadic Boolean predicate.The elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that does not satisfy the predicate is found.Example:#eval #[\"red\", \"green\", \"blue\", \"orange\"].toSubarray.popFront.allM fun x => do\n  IO.println x\n  pure (x.length == 5)\ngreen\nblue\nfalse\n\n\nChecks whether any of the elements in a subarray satisfy a Boolean predicate.The elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that satisfies the predicate is found.\n\nChecks whether any of the elements in a subarray satisfy a monadic Boolean predicate.The elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that satisfies the predicate is found.Example:#eval #[\"red\", \"green\", \"blue\", \"orange\"].toSubarray.popFront.anyM fun x => do\n  IO.println x\n  pure (x == \"blue\")\ngreen\nblue\ntrue\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","header":"19.16.5.6. Element Predicates","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Element-Predicates"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Creation":{"contents":"Creates a new empty hash map. The optional parameter capacity can be supplied to presize the\nmap so that it can hold the given number of mappings without reallocating. It is also possible to\nuse the empty collection notations ∅ and {} to create an empty hash map with the default\ncapacity.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Maps","header":"19.18.4.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Creation"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Queries":{"contents":"Returns true if the given key is present in the set. There is also a Prop-valued version of\nthis: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains use\n== for comparisons, while for hash sets, both use ==.\n\nRetrieves the key from the set that matches a. Ensures that such a key exists by requiring a proof\nof a ∈ m. The result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise fallback.\nIf they key is contained the result is guaranteed to be pointer equal to the key in the set.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"19.18.6.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Queries"},"/Namespaces-and-Sections/#scopes":{"contents":"Many commands have an effect for the current section scope (sometimes just called \"scope\" when clear).\nEvery Lean module has a section scope.\nNested scopes are created via the namespace and section commands, as well as the in command combinator.\n\nThe following data are tracked in section scopes:\n\n The Current Namespace\n\nThe current namespace is the namespace into which new declarations will be defined.\n  Additionally, name resolution includes all prefixes of the current namespace in the scope for global names.\n\n Opened Namespaces\n\nWhen a namespace is opened, its names become available without an explicit prefix in the current scope.\n  Additionally, scoped attributes and scoped syntax extensions in namespaces that have been opened are active in the current section scope.\n\n Options\n\nCompiler options are reverted to their original values at the end of the scope in which they were modified.\n\n Section Variables\n\nSection variables are names (or instance implicit parameters) that are automatically added as parameters to definitions.\n  They are also added as universally-quantified assumptions to theorems when they occur in the theorem's statement.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Namespaces and Sections","header":"6.2. Section Scopes","id":"/Namespaces-and-Sections/#scopes"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Unique-sorrys":{"contents":"#5757 makes it harder to create \"fake\" theorems about definitions that\nare stubbed-out with sorry by ensuring that each sorry is not\ndefinitionally equal to any other. For example, this now fails:\n\nexample : (sorry : Nat) = sorry := rfl -- fails\n\n\nHowever, this still succeeds, since the sorry is a single\nindeterminate Nat:\n\ndef f (n : Nat) : Nat := sorry\nexample : f 0 = f 1 := rfl -- succeeds\n\n\nOne can be more careful by putting parameters to the right of the colon:\n\ndef f : (n : Nat) → Nat := sorry\nexample : f 0 = f 1 := rfl -- fails\n\n\nMost sources of synthetic sorries (recall: a sorry that originates from\nthe elaborator) are now unique, except for elaboration errors, since\nmaking these unique tends to cause a confusing cascade of errors. In\ngeneral, however, such sorries are labeled. This enables \"go to\ndefinition\" on sorry in the Infoview, which brings you to its origin.\nThe option set_option pp.sorrySource true causes the pretty printer to\nshow source position information on sorries.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)\u0009Highlights","header":"Unique sorrys","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Unique-sorrys"}});