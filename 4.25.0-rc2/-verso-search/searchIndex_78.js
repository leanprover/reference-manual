window.docContents[78].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Conversions":{"contents":"Converts an Array α into a List α that contains the same elements in the same order.At runtime, this is implemented by Array.toListImpl and is O(n) in the length of the\narray.\n\nConverts an array to a list that contains the same elements in the opposite order.This is equivalent to, but more efficient than, Array.toList ∘ List.reverse.Examples:* #[1, 2, 3].toListRev = [3, 2, 1]* #[\"blue\", \"yellow\"].toListRev = [\"yellow\", \"blue\"]\n\nPrepends an array to a list. The elements of the array are at the beginning of the resulting list.Equivalent to as.toList ++ l.Examples:* #[1, 2].toListAppend [3, 4] = [1, 2, 3, 4]* #[1, 2].toListAppend [] = [1, 2]* #[].toListAppend [3, 4, 5] = [3, 4, 5]\n\nConverts an array to a vector. The resulting vector's size is the array's size.\n\nReturns a subarray of an array, with the given bounds.If start or stop are not valid bounds for a subarray, then they are clamped to array's size.\nAdditionally, the starting index is clamped to the ending index.\n\nAllocates a new array that contains the contents of the subarray.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.5. Conversions","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Conversions"},"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic":{"contents":"If no decreasing_by clause is given, then the decreasing_tactic is used implicitly, and applied to each proof obligation separately.\n\nThe tactic decreasing_tactic mainly deals with lexicographic ordering of tuples, applying Prod.Lex.right if the left components of the product are definitionally equal, and Prod.Lex.left otherwise.\nAfter preprocessing tuples this way, it calls the decreasing_trivial tactic.\n\nExtensible helper tactic for decreasing_tactic. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.macro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\nThe tactic decreasing_trivial is an extensible tactic that applies a few common heuristics to solve a termination goal.\nIn particular, it tries the following tactics and theorems:* simp_arith* assumption* theorems Nat.sub_succ_lt_self, Nat.pred_lt_of_lt, and Nat.pred_lt, which handle common arithmetic goals* omega* array_get_dec and array_mem_dec, which prove that the size of array elements is less than the size of the array* sizeOf_list_dec that the size of list elements is less than the size of the list* String.Iterator.sizeOf_next_lt_of_hasNext and String.Iterator.sizeOf_next_lt_of_atEnd, to handle iteration through a string using  forThis tactic is intended to be extended with further heuristics using macro_rules.\n\nNo Backtracking of Lexicographic OrderA classic example of a recursive function that needs a more complex measure is the Ackermann function:def ack : Nat → Nat → Nat\n  | 0,     n     => n + 1\n  | m + 1, 0     => ack m 1\n  | m + 1, n + 1 => ack m (ack (m + 1) n)\ntermination_by m n => (m, n)\nThe measure is a tuple, so every recursive call has to be on arguments that are lexicographically smaller than the parameters.\nThe default decreasing_tactic can handle this.In particular, note that the third recursive call has a second argument that is smaller than the second parameter and a first argument that is definitionally equal to the first parameter.\nThis allowed  decreasing_tactic to apply Prod.Lex.right.Prod.Lex.right {α β} {ra : α → α → Prop} {rb : β → β → Prop}\n  (a : α) {b₁ b₂ : β}\n  (h : rb b₁ b₂) :\n  Prod.Lex ra rb (a, b₁) (a, b₂)\nIt fails, however, with the following modified function definition, where the third recursive call's first argument is provably smaller or equal to the first parameter, but not syntactically equal:def synack : Nat → Nat → Nat\n  | 0,     n     => n + 1\n  | m + 1, 0     => synack m 1\n  | m + 1, n + 1 => synack m (synack (m / 2 + 1) n)\ntermination_by m n => (m, n)\nfailed to prove termination, possible solutions:\n  - Use `have`-expressions to prove the remaining goals\n  - Use `termination_by` to specify a different well-founded relation\n  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\ncase h\nm n : Nat\n⊢ m / 2 + 1 < m + 1\nBecause Prod.Lex.right is not applicable, the tactic used Prod.Lex.left, which resulted in the unprovable goal above.This function definition may require a manual proof that uses the more general theorem Prod.Lex.right', which allows the first component of the tuple (which must be of type Nat) to be less or equal instead of strictly equal:Prod.Lex.right' {β} (rb : β → β → Prop)\n  {a₂ : Nat} {b₂ : β} {a₁ : Nat} {b₁ : β}\n  (h₁ : a₁ ≤ a₂) (h₂ : rb b₁ b₂) :\n  Prod.Lex Nat.lt rb (a₁, b₁) (a₂, b₂)\ndef synack : Nat → Nat → Nat\n  | 0, n => n + 1\n  | m + 1, 0 => synack m 1\n  | m + 1, n + 1 => synack m (synack (m / 2 + 1) n)\ntermination_by m n => (m, n)\ndecreasing_by\n  · apply Prod.Lex.left\n    omega\n  -- the next goal corresponds to the third recursive call\n  · apply Prod.Lex.right'\n    · omega\n    · omega\n  · apply Prod.Lex.left\n    omega\nThe decreasing_tactic tactic does not use the stronger Prod.Lex.right' because it would require backtracking on failure.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","header":"7.6.3.3. Default Termination Proof Tactic","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Interacting-with-the-Filesystem":{"contents":"Some operations on paths consult the filesystem.\n\nFile metadata.The metadata for a file can be accessed with System.FilePath.metadata/\nSystem.FilePath.symlinkMetadata.File access time.File modification time.The size of the file in bytes.Whether the file is an ordinary file, a directory, a symbolic link, or some other kind of file.\n\nReturns metadata for the indicated file, following symlinks. Throws an exception if the file does\nnot exist or the metadata cannot be accessed.\n\nReturns metadata for the indicated file without following symlinks. Throws an exception if the file\ndoes not exist or the metadata cannot be accessed.\n\nChecks whether the indicated path points to a file that exists. This function will traverse\nsymlinks.\n\nChecks whether the indicated path can be read and is a directory. This function will traverse\nsymlinks.\n\nAn entry in a directory on a filesystem.The directory in which the entry is found.The name of the entry.\n\nThe path of the file indicated by the directory entry.\n\nReturns the contents of the indicated directory. Throws an exception if the file does not exist or\nis not a directory.\n\nTraverses a filesystem starting at the path p and exploring directories that satisfy enter,\nreturning the paths visited.The traversal is a preorder traversal, in which parent directories occur prior to any of their\nchildren. Symbolic links are followed.\n\nPOSIX-style file permissions.The FileRight structure describes these permissions for a file's owner, members of it's designated\ngroup, and all others.The file can be read.The file can be written to.The file can be executed.\n\nConverts individual POSIX-style file permissions to their conventional three-bit representation.This is the bitwise or of the following:* If the file can be read, 0x4, otherwise 0.* If the file can be written, 0x2, otherwise 0.* If the file can be executed, 0x1, otherwise 0.Examples:* {read := true : AccessRight}.flags = 4* {read := true, write := true : AccessRight}.flags = 6* {read := true, execution := true : AccessRight}.flags = 5\n\nPOSIX-style file permissions that describe access rights for a file's owner, members of its\nassigned group, and all others.The owner's permissions to access the file.The assigned group's permissions to access the file.The permissions that all others have to access the file.\n\nConverts POSIX-style file permissions to their numeric representation, with three bits each for the\nowner's permissions, the group's permissions, and others' permissions.\n\nSets the POSIX-style permissions for a file.\n\nRemoves (deletes) a file from the filesystem.To remove a directory, use IO.FS.removeDir or IO.FS.removeDirAll instead.\n\nMoves a file or directory old to the new location new.This function coincides with the POSIX rename\nfunction.\n\nRemoves (deletes) a directory.Removing a directory fails if the directory is not empty. Use IO.FS.removeDirAll to remove\ndirectories along with their contents.\n\nReturns the contents of a UTF-8-encoded text file as an array of lines.Newline markers are not included in the lines.\n\nCreates a temporary file in the most secure manner possible and calls f with both a Handle to\nthe already-opened file and its path. Afterwards, the temporary file is deleted.There are no race conditions in the file’s creation. The file is readable and writable only by the\ncreating user ID. Additionally on UNIX style platforms the file is executable by nobody.Use IO.FS.createTempFile to avoid the automatic deletion of the temporary file.\n\nCreates a temporary directory in the most secure manner possible, providing a its path to an IO\naction. Afterwards, all files in the temporary directory are recursively deleted, regardless of how\nor when they were created.There are no race conditions in the directory’s creation. The directory is readable and writable\nonly by the creating user ID. Use IO.FS.createTempDir to avoid the automatic deletion of the\ndirectory's contents.\n\nCreates a directory at the specified path, creating all missing parents as directories.\n\nWrite the provided bytes to a binary file at the specified path.\n\nOpens the file fn with the specified mode and passes the resulting file handle to f.The file handle is closed when the last reference to it is dropped. If references escape f, then\nthe file remains open even after IO.FS.withFile has finished.\n\nFully remove given directory by deleting all contained files and directories in an unspecified order.\nSymlinks are deleted but not followed. Fails if any contained entry cannot be deleted or was newly\ncreated during execution.\n\nCreates a temporary file in the most secure manner possible, returning both a Handle to the\nalready-opened file and its path.There are no race conditions in the file’s creation. The file is readable and writable only by the\ncreating user ID. Additionally on UNIX style platforms the file is executable by nobody.It is the caller's job to remove the file after use. Use withTempFile to ensure that the temporary\nfile is removed.\n\nCreates a temporary directory in the most secure manner possible, returning the new directory's\npath. There are no race conditions in the directory’s creation. The directory is readable and\nwritable only by the creating user ID.It is the caller's job to remove the directory after use. Use withTempDir to ensure that the\ntemporary directory is removed.\n\nReads the entire contents of the UTF-8-encoded file at the given path as a String.An exception is thrown if the contents of the file are not valid UTF-8. This is in addition to\nexceptions that may always be thrown as a result of failing to read files.\n\nResolves a path to an absolute path that contains no '.', '..', or symbolic links.This function coincides with the POSIX realpath\nfunction.\n\nWrite contents of a string to a file at the specified path using UTF-8 encoding.\n\nReads the entire contents of the binary file at the given path as an array of bytes.\n\nCreates a directory at the specified path. The parent directory must already exist.Throws an exception if the directory cannot be created.\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.4. Interacting with the Filesystem","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Interacting-with-the-Filesystem"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Language":{"contents":"* #6672 filters out all declarations from Lean.*, *.Tactic.*, and\n*.Linter.* from the results of exact? and rw?.* #7395 changes the show t tactic to match its documentation.\nPreviously it was a synonym for change t, but now it finds the first\ngoal that unifies with the term t and moves it to the front of the\ngoal list.* #7639 changes the generated below and brecOn implementations for\nreflexive inductive types to support motives in Sort u rather than\nType u.* #8337 adjusts the experimental module system to not export any private\ndeclarations from modules.* #8373 enables transforming nondependent lets into haves in a\nnumber of contexts: the bodies of nonrecursive definitions, equation\nlemmas, smart unfolding definitions, and types of theorems. A motivation\nfor this change is that when zeta reduction is disabled, simp can only\neffectively rewrite have expressions (e.g. split uses simp with\nzeta reduction disabled), and so we cache the nondependence calculations\nby transforming lets to haves. The transformation can be disabled\nusing set_option cleanup.letToHave false.* #8387 improves the error messages produced by end and prevents\ninvalid end commands from closing scopes on failure.* #8419 introduces an explicit defeq attribute to mark theorems that\ncan be used by dsimp. The benefit of an explicit attribute over the\nprior logic of looking at the proof body is that we can reliably omit\ntheorem bodies across module boundaries. It also helps with intra-file\nparallelism.* #8519 makes the equational theorems of non-exposed defs private. If\nthe author of a module chose not to expose the body of their function,\nthen they likely don't want that implementation to leak through\nequational theorems. Helps with #8419.* #8543 adds typeclasses for grind to embed types into Int, for\ncutsat. This allows, for example, treating Fin n, or Mathlib's ℕ+ in\na uniform and extensible way.* #8568 modifies the structure elaborator to add local terminfo for\nstructure fields and explicit parent projections, enabling \"go to\ndefinition\" when there are dependent fields.* #8574 adds an additional diff mode to the error-message hint\nsuggestion widget that displays diffs per word rather than per\ncharacter.* #8596 makes guard_msgs.diff=true the default. The main usage of\n#guard_msgs is for writing tests, and this makes staring at altered\ntest outputs considerably less tiring.* #8609 uses grind to shorten some proofs in the LRAT checker. The\nintention is not particularly to improve the quality or maintainability\nof these proofs (although hopefully this is a side effect), but just to\ngive grind a work out.* #8619 fixes an internalization (aka preprocessing) issue in grind\nwhen applying injectivity theorems.* #8621 fixes a bug in the equality-resolution procedure used by\ngrind.\nThe procedure now performs a topological sort so that every simplified\ntheorem declaration is emitted before any place where it is\nreferenced.\nPreviously, applying equality resolution toh : ∀ x, p x a → ∀ y, p y b → x ≠ y\nin the exampleexample\n  (p : Nat → Nat → Prop)\n  (a b c : Nat)\n  (h  : ∀ x, p x a → ∀ y, p y b → x ≠ y)\n  (h₁ : p c a)\n  (h₂ : p c b) :\n  False := by\n  grind\ncaused grind to produce the incorrect termp ?y a → ∀ y, p y b → False\nThe patch eliminates this error, and the following correct simplified\ntheorem is generated∀ y, p y a → p y b → False\n* #8622 adds a test case / use case example for grind, setting up the\nvery basics of IndexMap, modelled on Rust's\nindexmap. It is not\nintended as a complete implementation: just enough to exercise grind.* #8625 improves the diagnostic information produced by grind when it\nsucceeds. We now include the list of case-splits performed, and the\nnumber of application per function symbol.* #8633 implements case-split tracking in grind. The information is\ndisplayed when grind fails or diagnostic information is requested.\nExamples:* Failure* #8637 adds background theorems for normalizing IntModule expressions\nusing reflection.* #8638 improves the diagnostic information produced by grind. It now\nsorts the equivalence classes by generation and then Expr. lt.* #8639 completes the ToInt family of typeclasses which grind will\nuse to embed types into the integers for cutsat. It contains instances\nfor the usual concrete data types (Fin, UIntX, IntX, BitVec),\nand is extensible (e.g. for Mathlib's PNat).* #8641 adds the #print sig $ident variant of the #print command,\nwhich omits the body. This is useful for testing meta-code, in the#guard_msgs (drop trace, all) in #print sig foo\nidiom. The benefit over #check is that it shows the declaration kind,\nreducibility attributes (and in the future more built-in attributes,\nlike @[defeq] in #8419). (One downside is that #check shows unused\nfunction parameter names, e.g. in induction principles; this could\nprobably be refined.)* #8645 adds many helper theorems for the future IntModule linear\narithmetic procedure in grind.\nIt also adds helper theorems for normalizing input atoms and support for\ndisequality in the new linear arithmetic procedure in grind.* #8650 adds helper theorems for coefficient normalization and equality\ndetection. This theorems are for the linear arithmetic procedure in\ngrind.* #8662 adds a warn.sorry option (default true) that logs the\n\"declaration uses 'sorry'\" warning when declarations contain sorryAx.\nWhen false, the warning is not logged.* #8670 adds helper theorems that will be used to interface the\nCommRing module with the linarith procedure in grind.* #8671 allow structures to have non-bracketed binders, making it\nconsistent with inductive.* #8677 adds the basic infrastructure for the linarith module in\ngrind.* #8680 adds the reify? and denoteExpr for the new linarith module\nin grind.* #8682 uses the CommRing module to normalize linarith inequalities.* #8687 implements the infrastructure for constructing proof terms in\nthe linarith procedure in grind. It also adds the ToExpr instances\nfor the reified objects.* #8689 implements proof term generation for the CommRing and\nlinarith interface. It also fixes the CommRing helper theorems.* #8690 implements the main framework of the model search procedure for\nthe linarith component in grind. It currently handles only inequalities.\nIt can already solve simple goals such asexample [IntModule α] [Preorder α] [IntModule.IsOrdered α] (a b c : α)\n    : a < b → b < c → c < a → False := by\n  grind\n\n* #8693 fixes the denotation functions used to interface the ring and\nlinarith modules in grind.* #8694 implements special support for One.one in linarith when the\nstructure is a ordered ring. It also fixes bugs during initialization.* #8697 implements support for inequalities in the grind linear\narithmetic procedure and simplifies its design. Some examples that can\nalready be solved:open Lean.Grind\nexample [IntModule α] [Preorder α] [IntModule.IsOrdered α] (a b c d : α)\n    : a + d < c → b = a + (2:Int)*d → b - d > c → False := by\n  grind\n\n* #8708 fixes an internalization bug in the interface between linarith\nand ring modules in grind. The CommRing module may create new terms\nduring normalization.* #8713 fixes a bug in the commutative ring module used in grind. It\nwas missing simplification opportunities.* #8715 implements the basic infrastructure for processing disequalities\nin the grind linarith module. We still have to implement backtracking.* #8723 implements a finally section following a (potentially empty)\nwhere block. where ... finally opens a tactic sequence block in\nwhich the goals are the unassigned metavariables from the definition\nbody and its auxiliary definitions that arise from use of let rec and\nwhere.* #8730 adds support for throwing named errors with associated error\nexplanations. In particular, it adds elaborators for the syntax defined\nin #8649, which use the error-explanation infrastructure added in #8651.\nThis includes completions, hovers, and jump-to-definition for error\nnames.* #8733 implements disequality splitting and non-chronological\nbacktracking for the grind linarith procedure.example [IntModule α] [LinearOrder α] [IntModule.IsOrdered α] (a b c d : α)\n    : a ≤ b → a - c ≥ 0 + d → d ≤ 0 → d ≥ 0 → b = c → a ≠ b → False := by\n  grind\n* #8751 adds the nondep field of Expr.letE to the C++ data model.\nPreviously this field has been unused, and in followup PRs the\nelaborator will use it to encode have expressions (non-dependent\nlets). The kernel does not verify that nondep is correctly applied\nduring typechecking. The letE delaborator now prints haves when\nnondep is true, though have still elaborates as letFun for now.\nBreaking change: Expr.updateLet! is renamed to Expr.updateLetE!.* #8753 fixes a bug in simp where it was not resetting the set of\nzeta-delta reduced let definitions between simp calls. It also fixes a\nbug where simp would report zeta-delta reduced let definitions that\nweren't given as simp arguments (these extraneous let definitions appear\ndue to certain processes temporarily setting zetaDelta := true). This\nPR also modifies the metaprogramming interface for the zeta-delta\ntracking functions to be re-entrant and to prevent this kind of no-reset\nbug from occurring again. Closes #6655.* #8756 implements counterexamples for grind linarith. Example:example [CommRing α] [LinearOrder α] [Ring.IsOrdered α] (a b c d : α)\n    : b ≥ 0 → c > b → d > b → a ≠ b + c → a > b + c → a < b + d →  False := by\n  grind\nproduces the counterexamplea := 7/2\nb := 1\nc := 2\nd := 3\n* #8759 implements model-based theory combination for grind linarith.\nExample:example [CommRing α] [LinearOrder α] [Ring.IsOrdered α] (f : α → α → α) (x y z : α)\n    : z ≤ x → x ≤ 1 → z = 1 → f x y = 2 → f 1 y = 2 := by\n  grind\n* #8763 corrects the handling of explicit monotonicity proofs for\nmutual partial_fixpoint definitions.* #8773 implements support for the heterogeneous (k : Nat) * (a : R)\nin ordered modules. Example:variable (R : Type u) [IntModule R] [LinearOrder R] [IntModule.IsOrdered R]\n\n* #8774 adds an option for disabling the cutsat procedure in grind.\nThe linarith module takes over linear integer/nat constraints. Example:set_option trace.grind.cutsat.assert true in -- cutsat should **not** process the following constraints\nexample (x y z : Int) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) : ¬ 12*y - 4* z < 0 := by\n  grind -cutsat -- `linarith` module solves it\n* #8775 adds a grind normalization theorem for Int.negSucc. Example:example (p : Int) (n : Nat) (hmp : Int.negSucc (n + 1) + 1 = p)\n    (hnm : Int.negSucc (n + 1 + 1) + 1 = Int.negSucc (n + 1)) : p = Int.negSucc n := by\n  grind\n* #8776 ensures that user provided natCast application are properly\ninternalized in the grind cutsat module.* #8777 implements basic Field support in the commutative ring module\nin grind. It is just division by numerals for now. Examples:open Lean Grind\n\n* #8780 makes Lean code generation respect the module name provided\nthrough lean --setup.* #8786 improves the support for fields in grind. New supported\nexamples:example [Field α] [IsCharP α 0] (x : α) : x ≠ 0 → (4 / x)⁻¹ * ((3 * x^3) / x)^2 * ((1 / (2 * x))⁻¹)^3 = 18 * x^8 := by grind\nexample [Field α] (a : α) : 2 * a ≠ 0 → 1 / a + 1 / (2 * a) = 3 / (2 * a) := by grind\nexample [Field α] [IsCharP α 0] (a : α) : 1 / a + 1 / (2 * a) = 3 / (2 * a) := by grind\nexample [Field α] [IsCharP α 0] (a b : α) : 2*b - a = a + b → 1 / a + 1 / (2 * a) = 3 / b := by grind\nexample [Field α] [NoNatZeroDivisors α] (a : α) : 1 / a + 1 / (2 * a) = 3 / (2 * a) := by grind\nexample [Field α] {x y z w : α} : x / y = z / w → y ≠ 0 → w ≠ 0 → x * w = z * y := by grind\nexample [Field α] (a : α) : a = 0 → a ≠ 1 := by grind\nexample [Field α] (a : α) : a = 0 → a ≠ 1 - a := by grind\n* #8789 implements the Rabinowitsch transformation for Field\ndisequalities in grind. For example, this transformation is necessary\nfor solving:example [Field α] (a : α) : a^2 = 0 → a = 0 := by\n  grind\n* #8791 ensures the grind linarith module is activated for any type\nthat implements only IntModule. That is, the type does not need to be\na preorder anymore.* #8792 makes the clear_value tactic preserve the order of variables\nin the local context. This is done by adding\nLean.MVarId.withRevertedFrom, which reverts all local variables\nstarting from a given variable, rather than only the ones that depend on\nit.* #8794 adds a module Lean.Util.CollectLooseBVars with a function\nExpr.collectLooseBVars that collects the set of loose bound variables\nin an expression. That is, it computes the set of all i such that\ne.hasLooseBVar i is true.* #8795 ensures that auxliary terms are not internalized by the ring and\nlinarith modules.* #8796 fixes grind linarith term internalization and support for\nHSMul.* #8798 adds the following instanceinstance [Field α] [LinearOrder α] [Ring.IsOrdered α] : IsCharP α 0\nThe goal is to ensure we do not perform unnecessary case-splits in our\ntest suite.* #8804 implements first-class support for nondependent let expressions\nin the elaborator; recall that a let expression let x : t := v; b is\ncalled nondependent if fun x : t => b typechecks, and the notation\nfor a nondependent let expression is have x := v; b. Previously we\nencoded have using the letFun function, but now we make use of the\nnondep flag in the Expr.letE constructor for the encoding. This has\nbeen given full support throughout the metaprogramming interface and the\nelaborator. Key changes to the metaprogramming interface:* Local context ldecls with nondep := true are generally treated as\ncdecls. This is because in the body of a have expression the\nvariable is opaque. Functions like LocalDecl.isLet by default return\nfalse for nondependent ldecls. In the rare case where it is needed,\nthey take an additional optional allowNondep : Bool flag (defaults to\nfalse) if the variable is being processed in a context where the value\nis relevant.* Functions such as mkLetFVars by default generalize nondependent let\nvariables and create lambda expressions for them. The\ngeneralizeNondepLet flag (default true) can be set to false if have\nexpressions should be produced instead. Breaking change: Uses of\nletLambdaTelescope/mkLetFVars need to use generalizeNondepLet := false. See the next item.* There are now some mapping functions to make telescoping operations\nmore convenient. See mapLetTelescope and mapLambdaLetTelescope.\nThere is also mapLetDecl as a counterpart to withLetDecl for\ncreating let/have expressions.* Important note about the generalizeNondepLet flag: it should only be\nused for variables in a local context that the metaprogram \"owns\". Since\nnondependent let variables are treated as constants in most cases, the\nvalue field might refer to variables that do not exist, if for example\nthose variables were cleared or reverted. Using mapLetDecl is always\nfine.* The simplifier will cache its let dependence calculations in the\nnondep field of let expressions.* The intro tactic still produces dependent local variables. Given\nthat the simplifier will transform lets into haves, it would be\nsurprising if that would prevent intro from creating a local variable\nwhose value cannot be used.* #8809 introduces the basic theory of ordered modules over Nat (i.e.\nwithout subtraction), for grind. We'll solve problems here by\nembedding them in the IntModule envelope.* #8810 implements equality elimination in grind linarith. The current\nimplementation supports only IntModule and IntModule +\nNoNatZeroDivisors* #8813 adds some basic lemmas about grind internal notions of\nmodules.* #8815 refactors the way simp arguments are elaborated: Instead of\nchanging the SimpTheorems structure as we go, this elaborates each\nargument to a more declarative description of what it does, and then\napply those. This enables more interesting checks of simp arguments that\nneed to happen in the context of the eventually constructed simp context\n(the checks in #8688), or after simp has run (unused argument linter\n#8901).* #8828 extends the experimental module system to support resolving\nprivate names imported (transitively) through import all.* #8835 defines the embedding of a CommSemiring into its CommRing\nenvelope, injective when the CommSemiring is cancellative. This will\nbe used by grind to prove results in Nat.* #8836 generalizes #8835 to the noncommutative case, allowing us to\nembed a Lean.Grind.Semiring into a Lean.Grind.Ring.* #8845 implements the proof-by-reflection infrastructure for embedding\nsemiring terms as ring ones.* #8847 relaxes the assumptions for Lean.Grind.IsCharP from Ring to\nSemiring, and provides an alternative constructor for rings.* #8848 generalizes the internal grind instanceinstance [Field α] [LinearOrder α] [Ring.IsOrdered α] : IsCharP α 0\ntoinstance [Ring α] [Preorder α] [Ring.IsOrdered α] : IsCharP α 0\n* #8855 refactors Lean.Grind.NatModule/IntModule/Ring.IsOrdered.* #8859 shows the equivalence between Lean.Grind.NatModule.IsOrdered\nand Lean.Grind.IntModule.IsOrdered over an IntModule.* #8865 allows simp to recognize and warn about simp lemmas that are\nlikely looping in the current simp set. It does so automatically\nwhenever simplification fails with the dreaded “max recursion depth”\nerror fails, but it can be made to do it always with set_option linter.loopingSimpArgs true. This check is not on by default because it\nis somewhat costly, and can warn about simp calls that still happen to\nwork.* #8874 skips attempting to compute a module name from the file name and\nroot directory (i.e., lean -R) if a name is already provided via lean --setup.* #8880 makes simp consult its own cache more often, to avoid\nreplicating work.* #8882 adds @[expose] annotations to terms that appear in grind\nproof certificates, so grind can be used in the module system. It's\npossible/likely that I haven't identified all of them yet.* #8890 adds doc-strings to the Lean.Grind algebra typeclasses, as\nthese will appear in the reference manual explaining how to extend\ngrind algebra solvers to new types. Also removes some redundant\nfields.* #8892 corrects the pretty printing of grind modifiers. Previously\n@[grind →] was being pretty printed as @[grind→ ] (Space on the\nright of the symbol, rather than left.) This fixes the pretty printing\nof attributes, and preserves the presence of spaces after the symbol in\nthe output of grind?.* #8893 fixes a bug in the dvd propagation function in cutsat.* #8901 adds a linter (linter.unusedSimpArgs) that complains when a\nsimp argument (simp [foo]) is unused. It should do the right thing if\nthe simp invocation is run multiple times, e.g. inside all_goals. It\ndoes not trigger when the simp call is inside a macro. The linter\nmessage contains a clickable hint to remove the simp argument.* #8903 make sure that the local instance cache calculation applies more\nreductions. In #2199 there was an issue where metavariables could\nprevent local variables from being considered as local instances. We use\na slightly different approach that ensures that, for example, lets at\nthe ends of telescopes do not cause similar problems. These reductions\nwere already being calculated, so this does not require any additional\nwork to be done.* #8909 refactors the NoNatZeroDivisors to make sure it will work with\nthe new Semiring support.* #8910 adds the NoNatZeroDivisors instance for OfSemiring.Q α* #8913 cleans up grind's internal order typeclasses, removing\nunnecessary duplication.* #8914 modifies let and have term syntaxes to be consistent with\neach other. Adds configuration options; for example, have is\nequivalent to let +nondep, for nondependent lets. Other options\ninclude +usedOnly (for let_tmp), +zeta (for letI/haveI), and\n+postponeValue (for let_delayed). There is also let (eq := h) x := v; b for introducing h : x = v when elaborating b. The eq option\nworks for pattern matching as well, for example let (eq := h) (x, y) := p; b.* #8918 fixes the guard_msgs.diff default behavior so that the default\nspecified in the option definition is actually used everywhere.* #8921 implements support for (commutative) semirings in grind. It\nuses the Grothendieck completion to construct a (commutative) ring\nLean.Grind.Ring.OfSemiring.Q α from a (commutative) semiring α. This\nconstruction is mostly useful for semirings that implement\nAddRightCancel α. Otherwise, the function toQ is not injective.\nExamples:example (x y : Nat) : x^2*y = 1 → x*y^2 = y → y*x = 1 := by\n  grind\n\n* #8935 adds the +generalize option to the let and have syntaxes.\nFor example, have +generalize n := a + b; body replaces all instances\nof a + b in the expected type with n when elaborating body. This\ncan be likened to a term version of the generalize tactic. One can\ncombine this with eq in have +generalize (eq := h) n := a + b; body\nas an analogue of generalize h : n = a + b.* #8937 changes the output universe of the generated below\nimplementation for non-reflexive inductive types to match the\nimplementation for reflexive inductive types in #7639.* #8940 introduces antitonicity lemmas that support the elaboration of\nmixed inductive-coinductive predicates defined using the\nleast_fixpoint / greatest_fixpoint constructs.* #8943 adds helper theorems for normalizing semirings that do not\nimplement AddRightCancel.* #8953 implements support for normalization for commutative semirings\nthat do not implement AddRightCancel. Examples:variable (R : Type u) [CommSemiring R]\n\n* #8954 adds a procedure that efficiently transforms let expressions\ninto have expressions (Meta.letToHave). This is exposed as the\nlet_to_have tactic.* #8955 fixes Lean.MVarId.deltaLocalDecl, which previously replaced\nthe local definition with the target.* #8957 adds configuration options to the let/have tactic syntaxes.\nFor example, let (eq := h) x := v adds h : x = v to the local\ncontext. The configuration options are the same as those for the\nlet/have term syntaxes.* #8958 improves the case splitting strategy used in grind, and\nensures grind also considers simple match-conditions for\ncase-splitting. Example:example (x y : Nat)\n    : 0 < match x, y with\n          | 0, 0   => 1\n          | _, _ => x + y := by -- x or y must be greater than 0\n  grind\n* #8959 add instances showing that the Grothendieck (i.e. additive)\nenvelope of a semiring is an ordered ring if the original semiring is\nordered (and satisfies ExistsAddOfLE), and in this case the embedding is\nmonotone.* #8963 embeds a NatModule into its IntModule completion, which is\ninjective when we have AddLeftCancel, and monotone when the modules are\nordered. Also adds some (failing) grind test cases that can be verified\nonce grind uses this embedding.* #8964 adds @[expose] attributes to proof terms constructed by\ngrind that need to be evaluated in the kernel.* #8965 revises @[grind] annotations on Nat bitwise operations.* #8968 adds the following features to simp:* A routine for simplifying have telescopes in a way that avoids\nquadratic complexity arising from locally nameless expression\nrepresentations, like what #6220 did for letFun telescopes.\nFurthermore, simp converts letFuns into haves (nondependent lets),\nand we remove the #6220 routine since we are moving away from letFun\nencodings of nondependent lets.* A +letToHave configuration option (enabled by default) that converts\nlets into haves when possible, when -zeta is set. Previously Lean\nwould need to do a full typecheck of the bodies of lets, but the\nletToHave procedure can skip checking some subexpressions, and it\nmodifies the lets in an entire expression at once rather than one at a\ntime.* A +zetaHave configuration option, to turn off zeta reduction of\nhaves specifically. The motivation is that dependent lets can only\nbe dsimped by let, so zeta reducing just the dependent lets is a\nreasonable way to make progress. The +zetaHave option is also added to\nthe meta configuration.* When simp is zeta reducing, it now uses an algorithm that avoids\ncomplexity quadratic in the depth of the let telescope.* Additionally, the zeta reduction routines in simp, whnf, and\nisDefEq now all are consistent with how they apply the zeta,\nzetaHave, and zetaUnused configurations.* #8971 fixes linter.simpUnusedSimpArgs to check the syntax kind, to\nnot fire on simp calls behind macros. Fixes #8969* #8973 refactors the juggling of universes in the linear\nnoConfusionType construction: Instead of using PUnit.{…} →  in the\nto get the branches of withCtorType to the same universe level, we use\nPULift.* #8978 updates the solveMonoStep function used in the monotonicity\ntactic to check for definitional equality between the current goal and\nthe monotonicity proof obtained from a recursive call. This ensures\nsoundness by preventing incorrect applications when\nLean.Order.PartialOrder instances differ—an issue that can arise with\nmutual blocks defined using the partial_fixpoint keyword, where\ndifferent Lean.Order.CCPO structures may be involved.* #8980 improves the consistency of error message formatting by\nrendering addenda of several existing error messages as labeled notes\nand hints.* #8983 fixes a bug in congruence proof generation in grind for\nover-applied functions.* #8986 improves the error messages produced by invalid projections and\nfield notation. It also adds a hint to the \"function expected\" error\nmessage noting the argument to which the term is being applied, which\ncan be helpful for debugging spurious \"function expected\" messages\nactually caused by syntax errors.* #8991 adds some missing ToInt.X typeclass instances for grind.* #8995 introduces a Hoare logic for monadic programs in\nStd.Do.Triple, and assorted tactics:* mspec for applying Hoare triple specifications* mvcgen to turn a Hoare triple proof obligation ⦃P⦄ prog ⦃Q⦄ into\npure verification conditoins (i.e., without any traces of Hoare triples\nor weakest preconditions reminiscent of prog). The resulting\nverification conditions in the stateful logic of Std.Do.SPred can be\ndischarged manually with the tactics coming with its custom proof mode\nor with automation such as simp and grind.* #8996 provides the remaining instances for the Lean.Grind.ToInt\ntypeclasses.* #9004 ensures that type-class synthesis failure errors in interpolated\nstrings are displayed at the interpolant at which they occurred.* #9005 changes the definition of Lean.Grind.ToInt.OfNat, introducing\na wrap on the right-hand-side.* #9008 implements the basic infrastructure for the generic ToInt\nsupport in cutsat.* #9022 completes the generic toInt infrastructure for embedding terms\nimplementing the ToInt type classes into Int.* #9026 implements support for (non strict) ToInt inequalities in\ngrind cutsat. grind cutsat can solve simple problems such as:example (a b c : Fin 11) : a ≤ b → b ≤ c → a ≤ c := by\n  grind\n\n* #9030 fixes a couple of bootstrapping-related hiccups in the newly\nadded Std.Do module. More precisely,* #9035 extends the list of acceptable characters to all the french ones\nas well as some others,\nby adding characters from the Latin-1-Supplement add Latin-Extended-A\nunicode block.* #9038 adds test cases for the VC generator and implements a few small\nand tedious fixes to ensure they pass.* #9041 makes mspec detect more viable assignments by rfl instead of\ngenerating a VC.* #9044 adjusts the experimental module system to make private the\ndefault visibility modifier in modules, introducing public as a new\nmodifier instead. public section can be used to revert the default for\nan entire section, though this is more intended to ease gradual adoption\nof the new semantics such as in Init (and soon Std) where they\nshould be replaced by a future decl-by-decl re-review of visibilities.* #9045 fixes a type error in mvcgen and makes it turn fewer natural\ngoals into synthetic opaque ones, so that tactics such as trivial may\ninstantiate them more easily.* #9048 implements support for strict inequalities in the ToInt\nadapter used in grind cutsat. Example:example (a b c : Fin 11) : c ≤ 9 → a ≤ b → b < c → a < c + 1 := by\n  grind\n* #9050 ensures the ToInt bounds are asserted for every toInt a\napplication internalized in grind cutsat.* #9051 implements support for equalities and disequalities in grind cutsat. We still have to improve the encoding. Examples:example (a b c : Fin 11) : a ≤ 2 → b ≤ 3 → c = a + b → c ≤ 5 := by\n  grind\n\n* #9057 introduces a simple variable-reordering heuristic for cutsat.\nIt is needed by the ToInt adapter to support finite types such as\nUInt64. The current encoding into Int produces large coefficients,\nwhich can enlarge the search space when an unfavorable variable order is\nused. Example:example (a b c : UInt64) : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n* #9059 adds helper theorems for normalizing coefficients in rings of\nunknown characteristic.* #9062 implements support for equations <num> = 0 in rings and fields\nof unknown characteristic. Examples:example [Field α] (a : α) : (2 * a)⁻¹ = a⁻¹ / 2 := by grind\n\n* #9065 improves the counterexamples produced by the cutsat procedure\nin grind when using the ToInt gadget.* #9067 adds a docstring for the grind tactic.* #9069 implements support for the type class LawfulEqCmp. Examples:example (a b c : Vector (List Nat) n)\n    : b = c → a.compareLex (List.compareLex compare) b = o → o = .eq → a = c := by\n  grind\n\n* #9073 copies #9069 to handle ReflCmp the same way; we need to call\nthis in propagateUp rather than propagateDown.* #9074 uses the commutative ring module to normalize nonlinear\npolynomials in grind cutsat. Examples:example (a b : Nat) (h₁ : a + 1 ≠ a * b * a) (h₂ : a * a * b ≤ a + 1) : b * a^2 < a + 1 := by\n  grind\n\n* #9076 adds an unexpander for OfSemiring.toQ. This an auxiliary\nfunction used by the ring module in grind, but we want to reduce the\nclutter in the diagnostic information produced by grind. Example:example [CommSemiring α] [AddRightCancel α] [IsCharP α 0] (x y : α)\n    : x^2*y = 1 → x*y^2 = y → x + y = 2 → False := by\n  grind\nproduces  [ring] Ring `Ring.OfSemiring.Q α` ▼\n    [basis] Basis ▼\n      [_] ↑x + ↑y + -2 = 0\n      [_] ↑y + -1 = 0\n* #9086 deprecates let_fun syntax in favor of have and removes\nletFun support from WHNF and simp.* #9087 removes the irreducible attribute from letFun, which is one\nstep toward removing special letFun support; part of #9086.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Language","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Language"}});