window.docContents[192].resolve({"/Build-Tools-and-Distribution/Lake/#automatic-toolchain-updates":{"contents":"The update command checks for changes to dependencies, fetching their sources and updating the manifest accordingly.\nBy default, update also attempts to update the root package's toolchain file when a new version of a dependency specifies an updated toolchain.\nThis behavior can be disabled with the --keep-toolchain flag.\n\nIf multiple dependencies specify newer toolchains, Lake selects the newest compatible toolchain, if it exists.\nTo determine the newest compatible toolchain, Lake parses the toolchain listed in the packages' lean-toolchain files into four categories:* Releases, which are compared by version number (e.g., v4.4.0 < v4.8.0 and v4.6.0-rc1 < v4.6.0)* Nightly builds, which are compared by date (e.g., nightly-2024-01-10 < nightly-2024-10-01)* Builds from pull requests to the Lean compiler, which are incomparable* Other versions, which are also incomparableToolchain versions from multiple categories are incomparable.\nIf there is not a single newest toolchain, Lake will print a warning and continue updating without changing the toolchain.\n\nIf Lake does find a new toolchain, then it updates the workspace's lean-toolchain file accordingly and restarts the update using the new toolchain's Lake.\nIf Elan is detected, it will spawn the new Lake process via elan run with the same arguments Lake was initially run with.\nIf Elan is missing, it will prompt the user to restart Lake manually and exit with a special error code (namely, 4).\nThe Elan executable used by Lake can be configured using the ELAN environment variable.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"22.1.2.4. Automatic Toolchain Updates","id":"/Build-Tools-and-Distribution/Lake/#automatic-toolchain-updates"},"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed--Examples":{"contents":"Implicit argument cannot be inferreddef emptyNats :=\n  []\n<invalid output>def emptyNats : List Nat :=\n  []\ndef emptyNats :=\n  List.nil (α := Nat)\nHere, Lean is unable to infer the value of the parameter α of the List type constructor, which\nin turn prevents it from inferring the type of the definition. Two fixes are possible: specifying\nthe expected type of the definition allows Lean to infer the appropriate implicit argument to the\nList.nil constructor; alternatively, making this implicit argument explicit in the function body\nprovides sufficient information for Lean to infer the definition's type.\n\nDefinition type uninferrable due to unknown parameter typedef identity x :=\n  x\n<invalid output>def identity (x : α) :=\n  x\nIn this example, the type of identity is determined by the type of x, which cannot be inferred.\nBoth the indicated error and\nlean.inferBinderTypeFailed therefore\nappear (see that explanation for additional discussion of this example). Resolving the latter—by\nexplicitly specifying the type of x—provides Lean with sufficient information to infer the\ndefinition type.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.inferDefTypeFailed","header":"Examples","id":"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed--Examples"},"/Tactic-Proofs/The-Tactic-Language/#tactic-config":{"contents":"Many tactics are configurable.\nBy convention, tactics share a configuration syntax, described using optConfig.\nThe specific options available to each tactic are described in the tactic's documentation.\n\nTactic ConfigurationA tactic configuration consists of zero or more configuration items:\n\nTactic Configuration ItemsEach configuration item has a name that corresponds to an underlying tactic option.\nBoolean options may be enabled or disabled using prefix + and -:Options may be assigned specific values using a syntax similar to that for named function arguments:Finally, the name config is reserved; it is used to pass an entire set of options as a data structure.\nThe specific type expected depends on the tactic.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","header":"13.3.5. Configuration","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-config"},"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Language-features___-tactics___-and-metaprograms":{"contents":"* structure command* #5511 allows structure parents to be type synonyms.* #5531 allows default values for structure fields to be noncomputable.* rfl and apply_rfl tactics* #3714, #3718 improve the rfl tactic and give better error messages.* #3772 makes rfl no longer use kernel defeq for ground terms.* #5329 tags Iff.refl with @[refl] (@Parcly-Taxel)* #5359 ensures that the rfl tactic tries Iff.rfl (@Parcly-Taxel)* unfold tactic* #4834 let unfold do zeta-delta reduction of local definitions, incorporating functionality of the Mathlib unfold_let tactic.* omega tactic* #5382 fixes spurious error in #5315* #5523 supports Int.toNat* simp tactic* #5479 lets simp apply rules with higher-order patterns.* induction tactic* #5494 fixes induction’s \"pre-tactic\" block to always be indented, avoiding unintended uses of it.* ac_nf tactic* #5524 adds ac_nf, a counterpart to ac_rfl, for normalizing expressions with respect to associativity and commutativity. Tests it with BitVec expressions.* bv_decide* #5211 makes extractLsb' the primitive bv_decide understands, rather than extractLsb (@alexkeizer)* #5365 adds bv_decide diagnoses.* #5375 adds bv_decide normalization rules for ofBool (a.getLsbD i) and ofBool a[i] (@alexkeizer)* #5423 enhances the rewriting rules of bv_decide* #5433 presents the bv_decide counterexample at the API* #5484 handles BitVec.ofNat with Nat fvars in bv_decide* #5506, #5507 add bv_normalize rules.* #5568 generalize the bv_normalize pipeline to support more general preprocessing passes* #5573 gets bv_normalize up-to-date with the current BitVec rewrites* Cleanups: #5408, #5493, #5578* Elaboration improvements* #5266 preserve order of overapplied arguments in elab_as_elim procedure.* #5510 generalizes elab_as_elim to allow arbitrary motive applications.* #5283, #5512 refine how named arguments suppress explicit arguments. Breaking change: some previously omitted explicit arguments may need explicit _ arguments now.* #5376 modifies projection instance binder info for instances, making parameters that are instance implicit in the type be implicit.* #5402 localizes universe metavariable errors to let bindings and fun binders if possible. Makes \"cannot synthesize metavariable\" errors take precedence over unsolved universe level errors.* #5419 must not reduce ite in the discriminant of match-expression when reducibility setting is .reducible* #5474 have autoparams report parameter/field on failure* #5530 makes automatic instance names about types with hygienic names be hygienic.* Deriving handlers* #5432 makes Repr deriving instance handle explicit type parameters* Functional induction* #5364 adds more equalities in context, more careful cleanup.* Linters* #5335 fixes the unused variables linter complaining about match/tactic combinations* #5337 fixes the unused variables linter complaining about some wildcard patterns* Other fixes* #4768 fixes a parse error when .. appears with a . on the next line* Metaprogramming* #3090 handles level parameters in Meta.evalExpr (@eric-wieser)* #5401 instance for Inhabited (TacticM α) (@alexkeizer)* #5412 expose Kernel.check for debugging purposes* #5556 improves the \"invalid projection\" type inference error in inferType.* #5587 allows MVarId.assertHypotheses to set BinderInfo and LocalDeclKind.* #5588 adds MVarId.tryClearMany', a variant of MVarId.tryClearMany.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.13.0 (2024-11-01)","header":"Language features, tactics, and metaprograms","id":"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Language-features___-tactics___-and-metaprograms"},"/releases/v4.2.0/#release-v4___2___0":{"contents":"* isDefEq cache for terms not containing metavariables..* Make Environment.mk and Environment.add private, and add replay as a safer alternative.* IO.Process.output no longer inherits the standard input of the caller.* Do not inhibit caching of default-level match reduction.* List the valid case tags when the user writes an invalid one.* The derive handler for DecidableEq now handles mutual inductive types.* Show path of failed import in Lake.* Fix linker warnings on macOS.* Lake: Add postUpdate? package configuration option. Used by a package to specify some code which should be run after a successful lake update of the package or one of its downstream dependencies. (lake#185)* Improvements to Lake startup time (#2572, #2573)* refine e now replaces the main goal with metavariables which were created during elaboration of e and no longer captures pre-existing metavariables that occur in e (#2502).* This is accomplished via changes to withCollectingNewGoalsFrom, which also affects elabTermWithHoles, refine', calc (tactic), and specialize. Likewise, all of these now only include newly-created metavariables in their output.* Previously, both newly-created and pre-existing metavariables occurring in e were returned inconsistently in different edge cases, causing duplicated goals in the infoview (issue #2495), erroneously closed goals (issue #2434), and unintuitive behavior due to refine e capturing previously-created goals appearing unexpectedly in e (no issue; see PR).\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.2.0 (2023-10-31)","id":"/releases/v4.2.0/#release-v4___2___0"}});