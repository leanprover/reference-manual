window.docContents[35].resolve({"/Tactic-Proofs/Reading-Proof-States/#proof-states":{"contents":"The goals in a proof state are displayed in order, with the main goal on top.\nGoals may be either named or anonymous.\nNamed goals are indicated with case at the top (called a case label), while anonymous goals have no such indicator.\nTactics assign goal names, typically on the basis of constructor names, parameter names, structure field names, or the nature of the reasoning step implemented by the tactic.\n\nNamed goalsThis proof state contains four goals, all of which are named.\nThis is part of a proof that the Monad Option instance is lawful (that is, to provide the LawfulMonad Option instance), and the case names (highlighted below) come from the names of the fields of LawfulMonad.case bind_pure_comp\nα β : Type ?u.2178\nf : α → β\nx : Option α\n⊢ (do\n      let a ← x\n      pure (f a)) =\n    f <$> x\n\ncase bind_map\nα β : Type ?u.2178\nf : Option (α → β)\nx : Option α\n⊢ (do\n      let x_1 ← f\n      x_1 <$> x) =\n    f <*> x\n\ncase pure_bind\nα β : Type ?u.2178\nx : α\nf : α → Option β\n⊢ pure x >>= f = f x\n\ncase bind_assoc\nα β γ : Type ?u.2178\nx : Option α\nf : α → Option β\ng : β → Option γ\n⊢ x >>= f >>= g = x >>= fun x => f x >>= g\n\nAnonymous GoalsThis proof state contains a single anonymous goal.n k : Nat\n⊢ n + k = k + n\n\nThe case and case' tactics can be used to select a new main goal using the desired goal's name.\nWhen names are assigned in the context of a goal which itself has a name, the new goals' names are appended to the main goal's name with a dot ('.', Unicode FULL STOP (0x2e)) between them.\n\nHierarchical Goal NamesIn the course of an attempt to prove ∀ (n k : Nat), n + k = k + n, this proof state can occur:case zero\nk : Nat\n⊢ 0 + k = k + 0\n\ncase succ\nk n✝ : Nat\na✝ : n✝ + k = k + n✝\n⊢ n✝ + 1 + k = k + (n✝ + 1)\nAfter induction k, the two new cases' names have zero as a prefix, because they were created in a goal named zero:case zero.zero\n⊢ 0 + 0 = 0 + 0\n\ncase zero.succ\nn✝ : Nat\na✝ : 0 + n✝ = n✝ + 0\n⊢ 0 + (n✝ + 1) = n✝ + 1 + 0\n\ncase succ\nk n✝ : Nat\na✝ : n✝ + k = k + n✝\n⊢ n✝ + 1 + k = k + (n✝ + 1)\n\n\nEach goal consists of a sequence of assumptions and a desired conclusion.\nEach assumption has a name and a type; the conclusion is a type.\nAssumptions are either arbitrary elements of some type or statements that are presumed true.\n\nAssumption Names and ConclusionThis goal has four assumptions:case cons\nα : Type ?u.3956\nx : α\nxs : List α\nih : xs ++ [] = xs\n⊢ x :: xs ++ [] = x :: xsThey are:* α, an arbitrary type* x, an arbitrary α* xs, an arbitrary List α* ih, an induction hypothesis that asserts that appending the empty list to xs is equal to xs.The conclusion is the statement that prepending x to both sides of the equality in the induction hypothesis results in equal lists.\n\nSome assumptions are inaccessible,   which means that they cannot be referred to explicitly by name.\nInaccessible assumptions occur when an assumption is created without a specified name or when the assumption's name is shadowed by a later assumption.\nInaccessible assumptions should be regarded as anonymous; they are presented as if they had names because they may be referred to in later assumptions or in the conclusion, and displaying a name allows these references to be distinguished from one another.\nIn particular, inaccessible assumptions are presented with daggers (†) after their names.\n\nAccessible Assumption NamesIn this proof state, all assumptions are accessible.case bind_pure_comp\nα β : Type ?u.4772\nf : α → β\nx : Option α\n⊢ (do\n      let a ← x\n      pure (f a)) =\n    f <$> x\n\nInaccessible Assumption NamesIn this proof state, only the first and third assumptions are accessible.\nThe second and fourth are inaccessible, and their names include a dagger to indicate that they cannot be referenced.case bind_pure_comp\nα β✝ : Type ?u.5080\nf : α → β✝\nx✝ : Option α\n⊢ (do\n      let a ← x✝\n      pure (f a)) =\n    f <$> x✝\n\nInaccessible assumptions can still be used.\nTactics such as assumption or simp can scan the entire list of assumptions, finding one that is useful, and contradiction can eliminate the current goal by finding an impossible assumption without naming it.\nOther tactics, such as rename_i and next, can be used to name inaccessible assumptions, making them accessible.\nAdditionally, assumptions can be referred to by their type, by writing the type in single guillemets.\n\nAssumptions by TypeSingle guillemets around a term represent a reference to some term in scope with that type.This can be used to refer to local lemmas by their theorem statement rather than by name, or to refer to assumptions regardless of whether they have explicit names.\n\nAssumptions by TypeIn the following proof, cases is repeatedly used to analyze a number.\nAt the beginning of the proof, the number is named x, but cases generates an inaccessible name for subsequent numbers.\nRather than providing names, the proof takes advantage of the fact that there is a single assumption of type Nat at any given time and uses ‹Nat› to refer to it.\nAfter the iteration, there is an assumption that n + 3 < 3, which contradiction can use to remove the goal from consideration.example : x < 3 → x ∈ [0, 1, 2] := by\n  intros\n  iterate 3\n    cases ‹Nat›\n    . decide\n  contradiction\n\n\nAssumptions by Type, Outside ProofsSingle-guillemet syntax also works outside of proofs:#eval\n  let x := 1\n  let y := 2\n  ‹Nat›\n2\nThis is generally not a good idea for non-propositions, however—when it matters which element of a type is selected, it's better to select it explicitly.\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.2. Reading Proof States","id":"/Tactic-Proofs/Reading-Proof-States/#proof-states"},"/Terms/Conditionals/#if-then-else":{"contents":"The conditional expression is used to check whether a proposition is true or false.Despite their syntactic similarity, the if used in the tactic language and the if used in do-notation are separate syntactic forms, documented in their own sections.\nThis requires that the proposition has a Decidable instance, because it's not possible to check whether arbitrary propositions are true or false.\nThere is also a coercion from Bool to Prop that results in a decidable proposition (namely, that the Bool in question is equal to true), described in the section on decidability.\n\nThere are two versions of the conditional expression: one simply performs a case distinction, while the other additionally adds an assumption about the proposition's truth or falsity to the local context.\nThis allows run-time checks to generate compile-time evidence that can be used to statically rule out errors.\n\nConditionalsWithout a name annotation, the conditional expression expresses only control flow.With the name annotation, the branches of the if have access to a local assumption that the proposition is respectively true or false.\n\nChecking Array BoundsArray indexing requires evidence that the index in question is within the bounds of the array, so getThird does not elaborate.def getThird (xs : Array α) : α := xs[2]\nfailed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nα : Type ?u.7\nxs : Array α\n⊢ 2 < xs.size\nRelaxing the return type to Option and adding a bounds check results in the same error.\nThis is because the proof that the index is in bounds was not added to the local context.def getThird (xs : Array α) : Option α :=\n  if xs.size ≤ 2 then none\n  else xs[2]\nfailed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nα : Type ?u.7\nxs : Array α\n⊢ 2 < xs.size\nNaming the proof h is sufficient to enable the tactics that perform bounds checking to succeed, even though it does not occur explicitly in the text of the program.def getThird (xs : Array α) : Option α :=\n  if h : xs.size ≤ 2 then none\n  else xs[2]\n\n\nThere is also a pattern-matching version of if.\nIf the pattern matches, then it takes the first branch, binding the pattern variables.\nIf the pattern does not match, then it takes the second branch.\n\nPattern-Matching Conditionals\n\nIf a Bool-only conditional statement is ever needed, the bif variant can be used.\n\nBoolean-Only Conditional\n\n","context":"Lean Reference\u0009Terms","header":"10.7. Conditionals","id":"/Terms/Conditionals/#if-then-else"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Other":{"contents":"* #7785 adds further automation to the release process, taking care of\ntagging, and creating new bump/v4.X.0 branches automatically, and\nfixing some bugs.* #7789 fixes lean potentially changing or interpreting arguments\nafter --run.* #8060 fixes a bug in the Lean kernel. During reduction of Nat.pow,\nthe kernel did not validate that the WHNF of the first argument is a\nNat literal before interpreting it as an mpz number. adds\nthe missing check.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Other","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Other"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Experimental___-sharing-oleans-between-different-checkouts-of-the-same-repository":{"contents":"#8922 introduces a local artifact cache for Lake. When enabled, Lake\nwill share build artifacts (built files) across different instances of\nthe same package using an input- and content-addressed cache. Requires export LAKE_ARTIFACT_CACHE=true for now.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Experimental: sharing oleans between different checkouts of the same repository","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Experimental___-sharing-oleans-between-different-checkouts-of-the-same-repository"}});