window.docContents[119].resolve({"/Basic-Types/Maps-and-Sets/#DHashMap":{"contents":"The declarations in this section should be imported using import Std.DHashMap.\n\nDependent hash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.DHashMap.Raw and\nStd.DHashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nDHashMap over DHashMap.Raw.For a variant that is more convenient for use in proofs because of extensionalities, see\nStd.ExtDHashMap which is defined in the module Std.Data.ExtDHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.18.3. Dependent Hash Maps","id":"/Basic-Types/Maps-and-Sets/#DHashMap"},"/The--grind--tactic/Congruence-Closure/#congruence-closure":{"contents":"Congruence closure maintains equivalence classes of terms under the reflexive, symmetric, and transitive closure of “is equal to” and the rule that equal arguments yield equal function results.\nFormally, if a = a' and b = b', then f a b = f a' b' is added.\nThe algorithm merges equivalence classes until a fixed point is reached.\nIf a contradiction is discovered, then the goal can be closed immediately.\n\nUsing the analogy of the shared whiteboard:1. Every hypothesis h : t₁ = t₂ writes a line connecting t₁ and t₂.2. Whenever two terms are connected by one or more lines, they're considered to be equal.\n   Soon, whole constellations (f a, g (f a), …) are connected.3. If two different constructors of the same inductive type are connected by one or more lines, then a contradiction is discovered and the goal is closed.\n   For example, equating True and False or none and some 1 would be a contradiction.\n\nCongruence ClosureThis theorem is proved using congruence closure:example {α} (f g : α → α) (x y : α)\n    (h₁ : x = y) (h₂ : f y = g y) :\n    f x = g x := by\n  grind\nInitially, f y, g y, x, and y are in separate equivalence classes.\nThe congruence closure engine uses h₁ to merge x and y, after which the equivalence classes are {x, y}, f y, and g y.\nNext, h₂ is used to merge f y and g y, after which the classes are {x, y} and {f y, g y}.\nThis is sufficient to prove that f x = g x, because y and x are in the same class.Similar reasoning is used for constructors:example (a b c : Nat) (h : a = b) : (a, c) = (b, c) := by\n  grind\nBecause the pair constructor Prod.mk obeys congruence, the tuples become equal as soon as a and b are placed in the same class.\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.3. Congruence Closure","id":"/The--grind--tactic/Congruence-Closure/#congruence-closure"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Highlights--New-Language-Features":{"contents":"* Partial Fixpoint#6355 adds the ability to define possibly non-terminating functions\nand still be able to reason about them equationally, as long as they are\ntail-recursive, or operate within certain monads such as OptionTypical examples:def ack : (n m : Nat) → Option Nat\n  | 0,   y   => some (y+1)\n  | x+1, 0   => ack x 1\n  | x+1, y+1 => do ack x (← ack (x+1) y)\npartial_fixpoint\n\ndef whileSome (f : α → Option α) (x : α) : α :=\n  match f x with\n  | none => x\n  | some x' => whileSome f x'\npartial_fixpoint\n\ndef computeLfp {α : Type u} [DecidableEq α] (f : α → α) (x : α) : α :=\n  let next := f x\n  if x ≠ next then\n    computeLfp f next\n  else\n    x\npartial_fixpoint\nSee the reference manual\nfor more details.* #6905 adds a first draft of the try?\ninteractive tactic, which tries various tactics, including induction:@[simp] def revAppend : List Nat → List Nat → List Nat\n| [],    ys => ys\n| x::xs, ys => revAppend xs (x::ys)\n\nexample : (revAppend xs ys).length = xs.length + ys.length := by\n  try?\n  /-\n  Try these:\n  • · induction xs, ys using revAppend.induct\n      · simp\n      · simp +arith [*]\n  • · induction xs, ys using revAppend.induct\n      · simp only [revAppend, List.length_nil, Nat.zero_add]\n      · simp +arith only [revAppend, List.length_cons, *]\n  -/\n* induction with zero alternatives#6486 modifies the induction/cases syntax so that the with\nclause does not need to be followed by any alternatives. This improves\nfriendliness of these tactics, since this lets them surface the names of\nthe missing alternatives:example (n : Nat) : True := by\n  induction n with\n/-            ~~~~\nalternative 'zero' has not been provided\nalternative 'succ' has not been provided\n-/\n* simp? and dsimp? tactics in conversion mode#6593 adds support for the simp? and dsimp? tactics in conversion\nmode.* fun_cases#6261 adds foo.fun_cases, an automatically generated theorem that\nsplits the goal according to the branching structure of foo, much like\nthe Functional Induction Principle, but for all functions (not just\nrecursive ones), and without providing inductive hypotheses.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)\u0009Highlights","header":"New Language Features","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Highlights--New-Language-Features"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--Parallel-Elaboration":{"contents":"* #7084 enables the elaboration of theorem bodies, i.e. proofs, to\nhappen in parallel to each other as well as to other elaboration tasks.* #7247 makes generation of match equations and splitters compatible\nwith parallelism.* #7261 ensures all equation, unfold, induction, and partial fixpoint\ntheorem generators in core are compatible with parallelism.* #7348 ensures all equation and unfold theorem generators in core are\ncompatible with parallelism.* #7457 ensures info tree users such as linters and request handlers\nhave access to info subtrees created by async elab task by introducing\nAPI to leave holes filled by such tasks.* #8101 fixes a parallelism regression where linters that e.g. check for\nerrors in the command would no longer find such messages.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Language","header":"Parallel Elaboration","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--Parallel-Elaboration"}});