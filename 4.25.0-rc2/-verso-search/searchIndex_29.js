window.docContents[29].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion":{"contents":"Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence.\n\nTransforms the hash map into an array of mappings in some order.\n\nTransforms the hash map into a list of mappings in some order.\n\nCreates a hash map from an array of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofArray, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\nCreates a hash map from a list of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofList, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","header":"19.18.2.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion"},"/Basic-Types/Strings/#string-api-props":{"contents":"Checks whether a string is empty.Empty strings are equal to \"\" and have length and end position 0.Examples:* \"\".isEmpty = true* \"empty\".isEmpty = false* \" \".isEmpty = false\n\nReturns the length of a string in Unicode code points.Examples:* \"\".length = 0* \"abc\".length = 3* \"L∃∀N\".length = 4\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.3. Properties","id":"/Basic-Types/Strings/#string-api-props"},"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Lifting":{"contents":"When a type's universe is smaller than the one expected in some context, universe lifting operators can bridge the gap.\nThese are wrappers around terms of a given type that are in larger universes than the wrapped type.\nThere are two lifting operators:\n\n* PLift can lift any type, including propositions, by one level. It can be used to include proofs in data structures such as lists.* ULift can lift any non-proposition type by any number of levels.\n\nLifts a proposition or type to a higher universe level.PLift α wraps a proof or value of type α. The resulting type is in the next largest universe\nafter that of α. In particular, propositions become data.The related type ULift can be used to lift a non-proposition type by any number of levels.Examples:* (False : Prop)* (PLift False : Type)* ([.up (by trivial), .up (by simp), .up (by decide)] : List (PLift True))* (Nat : Type 0)* (PLift Nat : Type 1)Wraps a proof or value to increase its type's universe level by 1.Extracts a wrapped proof or value from a universe-lifted proposition or type.\n\nLifts a type to a higher universe level.ULift α wraps a value of type α. Instead of occupying the same universe as α, which would be\nthe minimal level, it takes a further level parameter and occupies their maximum. The resulting type\nmay occupy any universe that's at least as large as that of α.The resulting universe of the lifting operator is the first parameter, and may be written explicitly\nwhile allowing α's level to be inferred.The related type PLift can be used to lift a proposition or type by one level.Examples:* (Nat : Type 0)* (ULift Nat : Type 0)* (ULift Nat : Type 1)* (ULift Nat : Type 5)* (ULift.{7} (PUnit : Type 3) : Type 7)Wraps a value to increase its type's universe level.Extracts a wrapped value from a universe-lifted type.\n\n","context":"Lean Reference\u0009Type System\u0009Universes\u0009Polymorphism","header":"4.3.2.3. Universe Lifting","id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Lifting"},"/Type-Classes/Basic-Classes/#decidable-propositions":{"contents":"A proposition is decidable if it can be checked algorithmically.\nThe Law of the Excluded Middle means that every proposition is true or false, but it provides no way to check which of the two cases holds, which can often be useful.\nBy default, only algorithmic Decidable instances for which code can be generated are in scope; opening the Classical namespace makes every proposition decidable.\n\nEither a proof that p is true or a proof that p is false. This is equivalent to a Bool paired\nwith a proof that the Bool is true if and only if p is true.Decidable instances are primarily used via if-expressions and the tactic decide. In\nconditional expressions, the Decidable instance for the proposition is used to select a branch. At\nrun time, this case distinction code is identical to that which would be generated for a\nBool-based conditional. In proofs, the tactic decide synthesizes an instance of Decidable p,\nattempts to reduce it to isTrue h, and then succeeds with the proof h if it can.Because Decidable carries data, when writing @[simp] lemmas which include a Decidable instance\non the LHS, it is best to use {_ : Decidable p} rather than [Decidable p] so that non-canonical\ninstances can be found via unification rather than instance synthesis.Proves that p is decidable by supplying a proof of ¬pProves that p is decidable by supplying a proof of p\n\nA decidable predicate.A predicate is decidable if the corresponding proposition is Decidable for each possible argument.\n\nA decidable relation.A relation is decidable if the corresponding proposition is Decidable for all possible arguments.\n\nPropositional equality is Decidable for all elements of a type.In other words, an instance of DecidableEq α is a means of deciding the proposition a = b is\nfor all a b : α.\n\nAbbreviation for DecidableRel (· < · : α → α → Prop).\n\nAbbreviation for DecidableRel (· ≤ · : α → α → Prop).\n\nConverts a decidable proposition into a Bool.If p : Prop is decidable, then decide p : Bool is the Boolean value\nthat is true if p is true and false if p is false.\n\nConstruct a q if some proposition p is decidable, and both the truth and falsity of p are\nsufficient to construct a q.This is a synonym for dite, the dependent if-then-else operator.\n\nExcluded Middle and DecidableThe equality of functions from Nat to Nat is not decidable:example (f g : Nat → Nat) : Decidable (f = g) := inferInstance\nfailed to synthesize\n  Decidable (f = g)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nOpening Classical makes every proposition decidable; however, declarations and examples that use this fact must be marked noncomputable to indicate that code should not be generated for them.open Classical\nnoncomputable example (f g : Nat → Nat) : Decidable (f = g) := inferInstance\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.4. Decidability","id":"/Type-Classes/Basic-Classes/#decidable-propositions"},"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--DevOps___CI":{"contents":"* Workflows* #4531 makes release trigger an update of release.lean-lang.org.* #4598 adjusts pr-release to the new lakefile.lean syntax.* #4632 makes pr-release use the correct tag name.* #4638 adds ability to manually trigger nightly release.* #4640 adds more debugging output for restart-on-label CI.* #4663 bumps up waiting for 10s to 30s for restart-on-label.* #4664 bumps versions for actions/checkout and actions/upload-artifacts.* 582d6e bumps version for actions/download-artifact.* 6d9718 adds back dropped check-stage3.* 0768ad adds Jira sync (for FRO).* #4830 adds support to report CI errors on FRO Zulip.* #4838 adds trigger for nightly_bump_toolchain on mathlib4 upon nightly release.* abf420 fixes msys2.* #4895 deprecates Nix-based builds and removes interactive components. Users who prefer the flake build should maintain it externally.* #4693, #4458, and #4876 update the release checklist.* #4669 fixes the \"max dynamic symbols\" metric per static library.* #4691 improves compatibility of tests/list_simp for retesting simp normal forms with Mathlib.* #4806 updates the quickstart guide.* c02aa9 documents the triage team in the contribution guide.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.11.0 (2024-09-02)","header":"DevOps/CI","id":"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--DevOps___CI"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Functional-Induction-Tactic":{"contents":"* #7069 adds the fun_induction and fun_cases tactics, which add\nconvenience around using functional induction and functional cases\nprinciples.* #7101 implements fun_induction foo, which is like fun_induction foo x y z, only that it picks the arguments to use from a unique suitable\ncall to foo in the goal.* #7127 follows up on #7103 which changes the generaliziation behavior\nof induction, to keep fun_induction in sync. Also fixes a Syntax\nindexing off-by-one error.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"Functional Induction Tactic","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Functional-Induction-Tactic"}});