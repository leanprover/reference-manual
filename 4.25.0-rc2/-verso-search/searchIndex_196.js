window.docContents[196].resolve({"/Basic-Propositions/Propositional-Equality/#HEq":{"contents":"Heterogeneous equality is a version of propositional equality that does not require that the two equated terms have the same type.\nHowever, proving that the terms are equal using its version of rfl requires that both the types and the terms are definitionally equal.\nIn other words, it allows more statements to be formulated.\n\nHeterogeneous equality is typically less convenient in practice than ordinary propositional equality.\nThe greater flexibility afforded by not requiring both sides of the equality to have the same type means that it has fewer useful properties.\nIt is often encountered as a result of dependent pattern matching: the split tactic and functional induction add heterogeneous equality assumptions to the context when the ordinary equality assumptions that are needed to accurate reflect the corresponding control flow would not be type correct.\nIn these cases, the built-in automation has no choice but to use heterogeneous equality.\n\nHeterogeneous equality. a ≍ b asserts that a and b have the same\ntype, and casting a across the equality yields b, and vice versa.You should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as Eq, because the assumption that the types of\na and b are equal is often too weak to prove theorems of interest. One\npublic important non-theorem is the analogue of congr: If f ≍ g and x ≍ y\nand f x and g y are well typed it does not follow that f x ≍ g y.\n(This does follow if you have f = g instead.) However if a and b have\nthe same type then a = b and a ≍ b are equivalent.Conventions for notations in identifiers:* The recommended spelling of ≍ in identifiers is heq.Reflexivity of heterogeneous equality.\n\nHeterogeneous EqualityHeterogeneous equality HEq x y can be written x ≍ y.\n\nA version of HEq.refl with an implicit argument.\n\nHeterogeneous EqualityThe type Vector α n is a wrapper around an Array α that includes a proof that the array has size n.\nAppending Vectors is associative, but this fact cannot be straightforwardly stated using ordinary propositional equality:variable\n  {xs : Vector α l₁} {ys : Vector α l₂} {zs : Vector α l₃}\nset_option linter.unusedVariables false\ntheorem Vector.append_associative :\n    xs ++ (ys ++ zs) = (xs ++ ys) ++ zs := by sorry\nThe problem is that the associativity of addition of natural numbers holds propositionally, but not definitionally:Type mismatch\n  xs ++ ys ++ zs\nhas type\n  Vector α (l₁ + l₂ + l₃)\nbut is expected to have type\n  Vector α (l₁ + (l₂ + l₃))\nOne solution to this problem is to use the associativity of natural number addition in the statement:theorem Vector.append_associative' :\n    xs ++ (ys ++ zs) =\n    Nat.add_assoc _ _ _ ▸ ((xs ++ ys) ++ zs) := by\n  sorry\nHowever, such proof statements can be difficult to work with in certain circumstances.Another is to use heterogeneous equality:theorem Vector.append_associative :\n    HEq (xs ++ (ys ++ zs)) ((xs ++ ys) ++ zs) := by sorry\nIn this case, the simplifier can rewrite both sides of the equation without having to preserve their types.\nHowever, proving the theorem does require eventually proving that the lengths nonetheless match.theorem Vector.append_associative :\n    HEq (xs ++ (ys ++ zs)) ((xs ++ ys) ++ zs) := by\n  cases xs; cases ys; cases zs\n  simp\n  congr 1\n  . omega\n  . apply heq_of_eqRec_eq\n    . rfl\n    . apply propext\n      constructor <;> intro h <;> simp_all +arith\n\n\nHEq.ndrec variant\n\nNon-dependent recursor for HEq\n\nHEq.ndrec variant\n\nSubstitution with heterogeneous equality.\n\nIf two heterogeneously equal terms have the same type, then they are propositionally equal.\n\nPropositionally equal terms are also heterogeneously equal.\n\nIf casting a term with Eq.rec to another type makes it equal to some other term, then the two\nterms are heterogeneously equal.\n\nRewriting inside φ using Eq.recOn yields a term that's heterogeneously equal to the original\nterm.\n\nThe result of casting a term with cast is heterogeneously equal to the original term.\n\nHeterogeneous equality precomposes with propositional equality.\n\nIf two terms are heterogeneously equal then their types are propositionally equal.\n\n","context":"Lean Reference\u0009Basic Propositions\u0009Propositional Equality","header":"18.4.2. Heterogeneous Equality","id":"/Basic-Propositions/Propositional-Equality/#HEq"},"/Basic-Types/Fixed-Precision-Integers/#fixed-int-runtime":{"contents":"In compiled code in contexts that require boxed representations, fixed-width integer types that fit in one less bit than the platform's pointer size are always represented without additional allocations or indirections.\nThis always includes Int8, UInt8, Int16, and UInt16.\nOn 64-bit architectures, Int32 and UInt32 are also represented without pointers.\nOn 32-bit architectures, Int32 and UInt32 require a pointer to an object on the heap.\nISize, USize, Int64 and UInt64 may require pointers on all architectures.\n\nEven though some fixed-with integer types require boxing in general, the compiler is able to represent them without boxing or pointer indirections in code paths that use only a specific fixed-width type rather than being polymorphic, potentially after a specialization pass.\nThis applies in most practical situations where these types are used: their values are represented using the corresponding unsigned fixed-width C type when a constructor parameter, function parameter, function return value, or intermediate result is known to be a fixed-width integer type.\nThe Lean run-time system includes primitives for storing fixed-width integers in constructors of inductive types, and the primitive operations are defined on the corresponding C types, so boxing tends to happen at the “edges” of integer calculations rather than for each intermediate result.\nIn contexts where other types might occur, such as the contents of polymorphic containers like Array, these types are boxed, even if an array is statically known to contain only a single fixed-width integer type.The monomorphic array type ByteArray avoids boxing for arrays of UInt8.\nLean does not specialize the representation of inductive types or arrays.\nInspecting a function's type in Lean is not sufficient to determine how fixed-width integer values will be represented, because boxed values are not eagerly unboxed—a function that projects an Int64 from an array returns a boxed integer value.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","header":"19.4.2. Run-Time Representation","id":"/Basic-Types/Fixed-Precision-Integers/#fixed-int-runtime"},"/Basic-Types/Tuples/#sigma-types":{"contents":"Dependent pairs, also known as dependent sums or Σ-types, are pairs in which the second term's type may depend on the value of the first term.\nThey are closely related to the existential quantifier and Subtype.\nUnlike existentially quantified statements, dependent pairs are in the Type universe and are computationally relevant data.\nUnlike subtypes, the second term is also computationally relevant data.\nLike ordinary pairs, dependent pairs may be nested; this nesting is right-associative.\n\nDependent Pair TypesDependent pair types bind one or more variables, which are then in scope in the final term.\nIf there is one variable, then its type is a that of the first element in the pair and the final term is the type of the second element in the pair.\nIf there is more than one variable, the types are nested right-associatively.\nThe identifiers may also be _.\nWith parentheses, multiple bound variables may have different types, while the unparenthesized variant requires that all have the same type.\n\nNested Dependent Pair TypesThe typeΣ n k : Nat, Fin (n * k)\nis equivalent toΣ n : Nat, Σ k : Nat, Fin (n * k)\nand(n : Nat) × (k : Nat) × Fin (n * k)\nThe typeΣ (n k : Nat) (i : Fin (n * k)) , Fin i.val\nis equivalent toΣ (n : Nat), Σ (k : Nat), Σ (i : Fin (n * k)) , Fin i.val\nand(n : Nat) × (k : Nat) × (i : Fin (n * k)) × Fin i.val\nThe two styles of annotation cannot be mixed in a single Σ-type:Σ n k (i : Fin (n * k)) , Fin i.val\n<example>:1:5-1:7: unexpected token '('; expected ','\n\n\n\n\nDependent pairs are typically used in one of two ways:1. They can be used to “package” a concrete type index together with a value of the indexed family, used when the index value is not known ahead of time.\n    The type Σ n, Fin n is a pair of a natural number and some other number that's strictly smaller.\n    This is the most common way to use dependent pairs.2. The first element can be thought of as a “tag” that's used to select from among different types for the second term.\n    This is similar to the way that selecting a constructor of a sum type determines the types of the constructor's arguments.\n    For example, the typeΣ (b : Bool), if b then Unit else α\nis equivalent to Option α, where none is ⟨true, ()⟩ and some x is ⟨false, x⟩.\n    Using dependent pairs this way is uncommon, because it's typically much easier to define a special-purpose inductive type directly.\n\n\n\nDependent pairs, in which the second element's type depends on the value of the first element. The\ntype Sigma β is typically written Σ a : α, β a or (a : α) × β a.Although its values are pairs, Sigma is sometimes known as the dependent sum type, since it is\nthe type level version of an indexed summation.Constructs a dependent pair.Using this constructor in a context in which the type is not known usually requires a type\nascription to determine β. This is because the desired relationship between the two values can't\ngenerally be determined automatically.The first component of a dependent pair.The second component of a dependent pair. Its type depends on the first component.\n\nDependent Pairs with DataThe type Vector, which associates a known length with an array, can be placed in a dependent pair with the length itself.\nWhile this is logically equivalent to just using Array, this construction is sometimes necessary to bridge gaps in an API.def getNLinesRev : (n : Nat) → IO (Vector String n)\n  | 0 => pure #v[]\n  | n + 1 => do\n    let xs ← getNLinesRev n\n    return xs.push (← (← IO.getStdin).getLine)\n\ndef getNLines (n : Nat) : IO (Vector String n) := do\n  return (← getNLinesRev n).reverse\n\npartial def getValues : IO (Σ n, Vector String n) := do\n  let stdin ← IO.getStdin\n\n  IO.println \"How many lines to read?\"\n  let howMany ← stdin.getLine\n\n  if let some howMany := howMany.trim.toNat? then\n    return ⟨howMany, (← getNLines howMany)⟩\n  else\n    IO.eprintln \"Please enter a number.\"\n    getValues\n\ndef main : IO Unit := do\n  let values ← getValues\n  IO.println s!\"Got {values.fst} values. They are:\"\n  for x in values.snd do\n    IO.println x.trim\nWhen calling the program with this standard input:4\nApples\nQuince\nPlums\nRaspberries\nthe output is:How many lines to read?\nGot 4 values. They are:\nRaspberries\nPlums\nQuince\nApples\n\n\nDependent Pairs as SumsSigma can be used to implement sum types.\nThe Bool in the first projection of Sum' indicates which type the second projection is drawn from.def Sum' (α : Type) (β : Type) : Type :=\n  Σ (b : Bool),\n    match b with\n    | true => α\n    | false => β\nThe injections pair a tag (a Bool) with a value of the indicated type.\nAnnotating them with match_pattern allows them to be used in patterns as well as in ordinary terms.variable {α β : Type}\n\n@[match_pattern]\ndef Sum'.inl (x : α) : Sum' α β := ⟨true, x⟩\n\n@[match_pattern]\ndef Sum'.inr (x : β) : Sum' α β := ⟨false, x⟩\n\ndef Sum'.swap : Sum' α β → Sum' β α\n  | .inl x => .inr x\n  | .inr y => .inl y\n\n\nJust as Prod has a variant PProd that accepts propositions as well as types, PSigma allows its projections to be propositions.\nThis has the same drawbacks as PProd: it is much more likely to lead to failures of universe level unification.\nHowever, PSigma can be necessary when implementing custom proof automation or in some rare, advanced use cases.\n\nFully-Polymorphic Dependent Pair TypesThe rules for nesting Σ', as well as those that govern its binding structure, are the same as those for Σ.\n\nFully universe-polymorphic dependent pairs, in which the second element's type depends on the value\nof the first element and both types are allowed to be propositions. The type PSigma β is typically\nwritten Σ' a : α, β a or (a : α) ×' β a.In practice, this generality leads to universe level constraints that are difficult to solve, so\nPSigma is rarely used in manually-written code. It is usually only used in automation that\nconstructs pairs of arbitrary types.To pair a value with a proof that a predicate holds for it, use Subtype. To demonstrate that a\nvalue exists that satisfies a predicate, use Exists. A dependent pair with a proposition as its\nfirst component is not typically useful due to proof irrelevance: there's no point in depending on a\nspecific proof because all proofs are equal anyway.Constructs a fully universe-polymorphic dependent pair.The first component of a dependent pair.The second component of a dependent pair. Its type depends on the first component.\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples","header":"19.13.2. Dependent Pairs","id":"/Basic-Types/Tuples/#sigma-types"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Executable-Targets":{"contents":"A Lean executable's declarative configuration.The executable's name.The subdirectory of the package's source directory containing the executable's\nLean source file. Defaults simply to said srcDir.(This will be passed to lean as the -R option.)The root module of the binary executable.\nShould include a main definition that will serve\nas the entry point of the program.The root is built by recursively building its\nlocal imports (i.e., fellow modules of the workspace).Defaults to the name of the target.The name of the binary executable.\nDefaults to the target name with any . replaced with a -.An Array of targets to build before the executable's modules.Deprecated. Use needs instead.\nAn Array of target names to build before the executable's modules.Enables the executable to interpret Lean files (e.g., via\nLean.Elab.runFrontend) by exposing symbols within the  executable\nto the Lean interpreter.Implementation-wise, on Windows, the Lean shared libraries are linked\nto the executable and, on other systems, the executable is linked with\n-rdynamic. This increases the size of the binary on Linux and, on Windows,\nrequires libInit_shared.dll and libleanshared.dll to  be co-located\nwith the executable or part of PATH (e.g., via lake exe). Thus, this\nfeature should only be enabled when necessary.Defaults to false.The mode in which the modules should be built (e.g., debug, release).\nDefaults to release.An Array of additional options to pass to both the Lean language server\n(i.e., lean --server) launched by lake serve and to lean when compiling\na module's Lean source files.Additional arguments to pass to lean\nwhen compiling a module's Lean source files.Additional arguments to pass to lean\nwhen compiling a module's Lean source files.Unlike moreLeanArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLeanArgs.Additional arguments to pass to leanc\nwhen compiling a module's C source files generated by lean.Lake already passes some flags based on the buildType,\nbut you can change this by, for example, adding -O0 and -UNDEBUG.Additional options to pass to the Lean language server\n(i.e., lean --server) launched by lake serve.Additional arguments to pass to leanc\nwhen compiling a module's C source files generated by lean.Unlike moreLeancArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLeancArgs.Additional target objects to use when linking (both static and shared).\nThese will come after the paths of native facets.Additional target libraries to pass to leanc when linking\n(e.g., for shared libraries or binary executables).\nThese will come after the paths of other link objects.Additional arguments to pass to leanc when linking (e.g., for shared\nlibraries or binary executables). These will come after the paths of\nthe linked objects.Additional arguments to pass to leanc when linking (e.g., for shared\nlibraries or binary executables). These will come after the paths of\nthe linked objects.Unlike moreLinkArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLinkArgs.Asserts whether Lake should assume Lean modules are platform-independent.* If false, Lake will add System.Platform.target to the module traces\nwithin the code unit (e.g., package or library). This will force Lean code\nto be re-elaborated on different platforms.* If true, Lake will exclude platform-dependent elements\n(e.g., precompiled modules, external libraries) from a module's trace,\npreventing re-elaboration on different platforms. Note that this will not\neffect  modules outside the code unit in question. For example, a\nplatform-independent package which depends on a platform-dependent library\nwill still be platform-dependent.* If none, Lake will construct traces as natural. That is, it will include\nplatform-dependent artifacts in the trace if they module depends on them,\nbut otherwise not force modules to be platform-dependent.There is no check  for correctness here, so a configuration can lie\nand Lake will not catch it. Defaults to none.\n\nMinimal Executable TargetThis executable declaration supplies only a name:[[lean_exe]]\nname = \"trustworthytool\"\nThe executable's main function is expected in a module named trustworthytool.lean in the package's default source file path.\nThe resulting executable is named trustworthytool.\n\nConfigured Executable TargetThe name trustworthy-tool is not a valid Lean name due to the dash (-).\nTo use this name for an executable target, an explicit module root must be supplied.\nEven though trustworthy-tool is a perfectly acceptable name for an executable, the target also specifies that the result of compilation and linking should be named tt.[[lean_exe]]\nname = \"trustworthy-tool\"\nroot = \"TrustworthyTool\"\nexeName = \"tt\"\nThe executable's main function is expected in a module named TrustworthyTool.lean in the package's default source file path.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Declarative TOML Format","header":"22.1.3.1.4. Executable Targets","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Executable-Targets"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-other":{"contents":"rfl closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting).\n\nnorm_cast tactic in conv mode.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.7. Other","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-other"},"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Language-features___-tactics___-and-metaprograms":{"contents":"* The variable inclusion mechanism has been changed. Like before, when a definition mentions a variable, Lean will add it as an argument of the definition, but now in theorem bodies, variables are not included based on usage in order to ensure that changes to the proof cannot change the statement of the overall theorem. Instead, variables are only available to the proof if they have been mentioned in the theorem header or in an include command or are instance implicit and depend only on such variables. The omit command can be used to omit included variables.See breaking changes below.PRs: #4883, #4814, #5000, #5036, #5138, 0edf1b.* Recursive definitions* Structural recursion can now be explicitly requested usingtermination_by structural x\nin analogy to the existing termination_by x syntax that causes well-founded recursion to be used.\n#4542* #4672 fixes a bug that could lead to ill-typed terms.* The termination_by? syntax no longer forces the use of well-founded recursion, and when structural\nrecursion is inferred, it will print the result using the termination_by structural syntax.* Mutual structural recursion is now supported. This feature supports both mutual recursion over a non-mutual\ndata type, as well as recursion over mutual or nested data types:mutual\ndef Even : Nat → Prop\n  | 0 => True\n  | n+1 => Odd n\n\ndef Odd : Nat → Prop\n  | 0 => False\n  | n+1 => Even n\nend\n\nmutual\ninductive A\n| other : B → A\n| empty\ninductive B\n| other : A → B\n| empty\nend\n\nmutual\ndef A.size : A → Nat\n| .other b => b.size + 1\n| .empty => 0\n\ndef B.size : B → Nat\n| .other a => a.size + 1\n| .empty => 0\nend\n\ninductive Tree where | node : List Tree → Tree\n\nmutual\ndef Tree.size : Tree → Nat\n| node ts => Tree.list_size ts\n\ndef Tree.list_size : List Tree → Nat\n| [] => 0\n| t::ts => Tree.size t + Tree.list_size ts\nend\nFunctional induction principles are generated for these functions as well (A.size.induct, A.size.mutual_induct).Nested structural recursion is still not supported.PRs: #4639, #4715, #4642, #4656, #4684, #4715, #4728, #4575, #4731, #4658, #4734, #4738, #4718, #4733, #4787, #4788, #4789, #4807, #4772* #4809 makes unnecessary termination_by clauses cause warnings, not errors.* #4831 improves handling of nested structural recursion through non-recursive types.* #4839 improves support for structural recursive over inductive predicates when there are reflexive arguments.* simp tactic* #4784 sets configuration Simp.Config.implicitDefEqProofs to true by default.* omega tactic* #4612 normalizes the order that constraints appear in error messages.* #4695 prevents pushing casts into multiplications unless it produces a non-trivial linear combination.* #4989 fixes a regression.* decide tactic* #4711 switches from using default transparency to at least default transparency when reducing the Decidable instance.* #4674 adds detailed feedback on decide tactic failure. It tells you which Decidable instances it unfolded, if it get stuck on Eq.rec it gives a hint about avoiding tactics when defining Decidable instances, and if it gets stuck on Classical.choice it gives hints about classical instances being in scope. During this process, it processes Decidable.recs and matches to pin blame on a non-reducing instance.* @[ext] attribute* #4543 and #4762 make @[ext] realize ext_iff theorems from user ext theorems. Fixes the attribute so that @[local ext] and @[scoped ext] are usable. The @[ext (iff := false)] option can be used to turn off ext_iff realization.* #4694 makes \"go to definition\" work for the generated lemmas. Also adjusts the core library to make use of ext_iff generation.* #4710 makes ext_iff theorem preserve inst implicit binder types, rather than making all binder types implicit.* #eval command* #4810 introduces a safer #eval command that prevents evaluation of terms that contain sorry. The motivation is that failing tactics, in conjunction with operations such as array accesses, can lead to the Lean process crashing. Users can use the new #eval! command to use the previous unsafe behavior. (#4829 adjusts a test.)* #4447 adds #discr_tree_key and #discr_tree_simp_key commands, for helping debug discrimination tree failures. The #discr_tree_key t command prints the discrimination tree keys for a term t (or, if it is a single identifier, the type of that constant). It uses the default configuration for generating keys. The #discr_tree_simp_key command is similar to #discr_tree_key, but treats the underlying type as one of a simp lemma, that is it transforms it into an equality and produces the key of the left-hand side.For example,#discr_tree_key (∀ {a n : Nat}, bar a (OfNat.ofNat n))\n-- bar _ (@OfNat.ofNat Nat _ _)\n\n#discr_tree_simp_key Nat.add_assoc\n-- @HAdd.hAdd Nat Nat Nat _ (@HAdd.hAdd Nat Nat Nat _ _ _) _\n* #4741 changes option parsing to allow user-defined options from the command line. Initial options are now re-parsed and validated after importing. Command line option assignments prefixed with weak. are silently discarded if the option name without the prefix does not exist.* Deriving handlers* 7253ef and a04f3c improve the construction of the BEq deriving handler.* 86af04 makes BEq deriving handler work when there are dependently typed fields.* #4826 refactors the DecidableEq deriving handle to use termination_by structural.* Metaprogramming* #4593 adds unresolveNameGlobalAvoidingLocals.* #4618 deletes deprecated functions from 2022.* #4642 adds Meta.lambdaBoundedTelescope.* #4731 adds Meta.withErasedFVars, to enter a context with some fvars erased from the local context.* #4777 adds assignment validation at closeMainGoal, preventing users from circumventing the occurs check for tactics such as exact.* #4807 introduces Lean.Meta.PProdN module for packing and projecting nested PProds.* #5170 fixes Syntax.unsetTrailing. A consequence of this is that \"go to definition\" now works on the last module name in an import block (issue #4958).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.11.0 (2024-09-02)","header":"Language features, tactics, and metaprograms","id":"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Language-features___-tactics___-and-metaprograms"},"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Language-features___-tactics___-and-metaprograms":{"contents":"* structure and inductive commands* #5517 improves universe level inference for the resulting type of an inductive or structure. Recall that a Prop-valued inductive type is a syntactic subsingleton if it has at most one constructor and all the arguments to the constructor are in Prop. Such types have large elimination, so they could be defined in Type or Prop without any trouble. The way inference has changed is that if a type is a syntactic subsingleton with exactly one constructor, and the constructor has at least one parameter/field, then the inductive/structure command will prefer creating a Prop instead of a Type. The upshot is that the : Prop in structure S : Prop is often no longer needed. (With @arthur-adjedj).* #5842 and #5783 implement a feature where the structure command can now define recursive inductive types:structure Tree where\n  n : Nat\n  children : Fin n → Tree\n\ndef Tree.size : Tree → Nat\n  | {n, children} => Id.run do\n    let mut s := 0\n    for h : i in [0 : n] do\n      s := s + (children ⟨i, h.2⟩).size\n    pure s\n* #5814 fixes a bug where Mathlib's Type* elaborator could lead to incorrect universe parameters with the inductive command.* #3152 and #5844 fix bugs in default value processing for structure instance notation (with @arthur-adjedj).* #5399 promotes instance synthesis order calculation failure from a soft error to a hard error.* #5542 deprecates := variants of inductive and structure (see breaking changes).* Application elaboration improvements* #5671 makes @[elab_as_elim] require at least one discriminant, since otherwise there is no advantage to this alternative elaborator.* #5528 enables field notation in explicit mode. The syntax @x.f elaborates as @S.f with x supplied to the appropriate parameter.* #5692 modifies the dot notation resolution algorithm so that it can apply CoeFun instances. For example, Mathlib has Multiset.card : Multiset α →+ Nat, and now with m : Multiset α, the notation m.card resolves to ⇑Multiset.card m.* #5658 fixes a bug where 'don't know how to synthesize implicit argument' errors might have the incorrect local context when the eta arguments feature is activated.* #5933 fixes a bug where .. ellipses in patterns made use of optparams and autoparams.* #5770 makes dot notation for structures resolve using all ancestors. Adds a resolution order for generalized field notation. This is the order of namespaces visited during resolution when trying to resolve names. The algorithm to compute a resolution order is the commonly used C3 linearization (used for example by Python), which when successful ensures that immediate parents' namespaces are considered before more distant ancestors' namespaces. By default we use a relaxed version of the algorithm that tolerates inconsistencies, but using set_option structure.strictResolutionOrder true makes inconsistent parent orderings into warnings.* Recursion and induction principles* #5619 fixes functional induction principle generation to avoid over-eta-expanding in the preprocessing step.* #5766 fixes structural nested recursion so that it is not confused when a nested type appears first.* #5803 fixes a bug in functional induction principle generation when there are let bindings.* #5904 improves functional induction principle generation to unfold aux definitions more carefully.* #5850 refactors code for Predefinition.Structural.* Error messages* #5276 fixes a bug in \"type mismatch\" errors that would structurally assign metavariables during the algorithm to expose differences.* #5919 makes \"type mismatch\" errors add type ascriptions to expose differences for numeric literals.* #5922 makes \"type mismatch\" errors expose differences in the bodies of functions and pi types.* #5888 improves the error message for invalid induction alternative names in match expressions (@josojo).* #5719 improves calc error messages.* #5627 and #5663 improve the #eval command and introduce some new features.* Now results can be pretty printed if there is a ToExpr instance, which means hoverable output. If ToExpr fails, it then tries looking for a Repr or ToString instance like before. Setting set_option eval.pp false disables making use of ToExpr instances.* There is now auto-derivation of Repr instances, enabled with the pp.derive.repr option (default to true). For example:inductive Baz\n| a | b\n\n#eval Baz.a\n-- Baz.a\nIt simply does deriving instance Repr for Baz when there's no way to represent Baz.* The option eval.type controls whether or not to include the type in the output. For now the default is false.* Now expressions such as #eval do return 2, where monad is unknown, work. It tries unifying the monad with CommandElabM, TermElabM, or IO.* The classes Lean.Eval and Lean.MetaEval have been removed. These each used to be responsible for adapting monads and printing results. Now the MonadEval class is responsible for adapting monads for evaluation (it is similar to MonadLift, but instances are allowed to use default data when initializing state), and representing results is handled through a separate process.* Error messages about failed instance synthesis are now more precise. Once it detects that a MonadEval class applies, then the error message will be specific about missing ToExpr/Repr/ToString instances.* Fixes bugs where evaluating MetaM and CoreM wouldn't collect log messages.* Fixes a bug where let rec could not be used in #eval.* partial definitions* #5780 improves the error message when partial fails to prove a type is inhabited. Add delta deriving.* #5821 gives partial inhabitation the ability to create local Inhabited instances from parameters.* New tactic configuration syntax. The configuration syntax for all core tactics has been given an upgrade. Rather than simp (config := { contextual := true, maxSteps := 22}), one can now write simp +contextual (maxSteps := 22). Tactic authors can migrate by switching from (config)? to optConfig in tactic syntaxes and potentially deleting mkOptionalNode in elaborators. #5883, #5898,  #5928, and #5932. (Tactic authors, see breaking changes.)* simp tactic* #5632 fixes the simpproc for Fin literals to reduce more consistently.* #5648 fixes a bug in simpa ... using t where metavariables in t were not properly accounted for, and also improves the type mismatch error.* #5838 fixes the docstring of simp! to actually talk about simp!.* #5870 adds support for attribute [simp ←] (note the reverse direction). This adds the reverse of a theorem as a global simp theorem.* decide tactic* #5665 adds decide! tactic for using kernel reduction (warning: this is renamed to decide +kernel in a future release).* bv_decide tactic* #5714 adds inequality regression tests (@alexkeizer).* #5608 adds bv_toNat tag for toNat_ofInt (@bollu).* #5618 adds support for at in ac_nf and uses it in bv_normalize (@tobiasgrosser).* #5628 adds udiv support.* #5635 adds auxiliary bitblasters for negation and subtraction.* #5637 adds more getLsbD bitblaster theory.* #5652 adds umod support.* #5653 adds performance benchmark for modulo.* #5655 reduces error on bv_check to warning.* #5670 adds ~~~(-x) support.* #5673 disables ac_nf by default.* #5675 fixes context tracking in bv_decide counter example.* #5676 adds an error when the LRAT proof is invalid.* #5781 introduces uninterpreted symbols everywhere.* #5823 adds BitVec.sdiv support.* #5852 adds BitVec.ofBool support.* #5855 adds if support.* #5869 adds support for all the SMTLIB BitVec divison/remainder operations.* #5886 adds embedded constraint substitution.* #5918 fixes loose mvars bug in bv_normalize.* Documentation:* #5636 adds remarks about multiplication.* conv mode* #5861 improves the congr conv tactic to handle \"over-applied\" functions.* #5894 improves the arg conv tactic so that it can access more arguments and so that it can handle \"over-applied\" functions (it generates a specialized congruence lemma for the specific argument in question). Makes arg 1 and arg 2 apply to pi types in more situations. Adds negative indexing, for example arg -2 is equivalent to the lhs tactic. Makes the enter [...] tactic show intermediate states like rw.* Other tactics* #4846 fixes a bug where generalize ... at * would apply to implementation details (@ymherklotz).* #5730 upstreams the classical tactic combinator.* #5815 improves the error message when trying to unfold a local hypothesis that is not a local definition.* #5862 and #5863 change how apply and simp elaborate, making them not disable error recovery. This improves hovers and completions when the term has elaboration errors.* deriving clauses* #5899 adds declaration ranges for delta-derived instances.* #5265 removes unused syntax in deriving clauses for providing arguments to deriving handlers (see breaking changes).* #5065 upstreams and updates #where, a command that reports the current scope information.* Linters* #5338 makes the unused variables linter ignore variables defined in tactics by default now, avoiding performance bottlenecks.* #5644 ensures that linters in general do not run on #guard_msgs itself.* Metaprogramming interface* #5720 adds pushGoal/pushGoals and popGoal for manipulating the goal state. These are an alternative to replaceMainGoal and getMainGoal, and with them you don't need to worry about making sure nothing clears assigned metavariables from the goal list between assigning the main goal and using replaceMainGoal. Modifies closeMainGoalUsing, which is like a TacticM version of liftMetaTactic. Now the callback is run in a context where the main goal is removed from the goal list, and the callback is free to modify the goal list. Furthermore, the checkUnassigned argument has been replaced with checkNewUnassigned, which checks whether the value assigned to the goal has any new metavariables, relative to the start of execution of the callback. Modifies withCollectingNewGoalsFrom to take the parentTag argument explicitly rather than indirectly via getMainTag. Modifies elabTermWithHoles to optionally take parentTag?.* #5563 fixes getFunInfo and inferType to use withAtLeastTransparency rather than withTransparency.* #5679 fixes RecursorVal.getInduct to return the name of major argument’s type. This makes \"structure eta\" work for nested inductives.* #5681 removes unused mkRecursorInfoForKernelRec.* #5686 makes discrimination trees index the domains of foralls, for better performance of the simplify and type class search.* #5760 adds Lean.Expr.name? recognizer for Name expressions.* #5800 modifies liftCommandElabM to preserve more state, fixing an issue where using it would drop messages.* #5857 makes it possible to use dot notation in m! strings, for example m!\"{.ofConstName n}\".* #5841 and #5853 record the complete list of structure parents in the StructureInfo environment extension.* Other fixes or improvements* #5566 fixes a bug introduced in #4781 where heartbeat exceptions were no longer being handled properly. Now such exceptions are tagged with runtime.maxHeartbeats (@eric-wieser).* #5708 modifies the proof objects produced by the proof-by-reflection tactics ac_nf0 and simp_arith so that the kernel is less prone to reducing expensive atoms.* #5768 adds a #version command that prints Lean's version information.* #5822 fixes elaborator algorithms to match kernel algorithms for primitive projections (Expr.proj).* #5811 improves the docstring for the rwa tactic.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.14.0 (2024-12-02)","header":"Language features, tactics, and metaprograms","id":"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Language-features___-tactics___-and-metaprograms"},"/releases/v4.4.0/#release-v4___4___0":{"contents":"* Lake and the language server now support per-package server options using the moreServerOptions config field, as well as options that apply to both the language server and lean using the leanOptions config field. Setting either of these fields instead of moreServerArgs ensures that viewing files from a dependency uses the options for that dependency. Additionally, moreServerArgs is being deprecated in favor of the moreGlobalServerArgs field. See PR #2858.A Lakefile with the following deprecated package declaration:def moreServerArgs := #[\n  \"-Dpp.unicode.fun=true\"\n]\ndef moreLeanArgs := moreServerArgs\n\npackage SomePackage where\n  moreServerArgs := moreServerArgs\n  moreLeanArgs := moreLeanArgs\n... can be updated to the following package declaration to use per-package options:package SomePackage where\n  leanOptions := #[⟨`pp.unicode.fun, true⟩]\n* Rename request handler.* Import auto-completion.* `pp.beta`` to apply beta reduction when pretty printing.* Embed and check githash in .olean.* Guess lexicographic order for well-founded recursion.* Allow trailing comma in tuples, lists, and tactics.\n\nBug fixes for #2628, #2883,\n#2810, #2925, and #2914.\n\nLake:\n\n* lake init . and a bare lake init and will now use the current directory as the package name. #2890* lake new and lake init will now produce errors on invalid package names such as .., foo/bar, Init, Lean, Lake, and Main. See issue #2637 and PR #2890.* lean_lib no longer converts its name to upper camel case (e.g., lean_lib bar will include modules named bar.* rather than Bar.*). See issue #2567 and PR #2889.* Lean and Lake now properly support non-identifier library names (e.g., lake new 123-hello and import «123Hello» now work correctly). See issue #2865 and PR #2889.* Lake now filters the environment extensions loaded from a compiled configuration (lakefile.olean) to include only those relevant to Lake's workspace loading process. This resolves segmentation faults caused by environment extension type mismatches (e.g., when defining custom elaborators via elab in configurations). See issue #2632 and PR #2896.* Cloud releases will now properly be re-unpacked if the build directory is removed. See PR #2928.* Lake's math template has been simplified. See PR #2930.* lake exe <target> now parses target like a build target (as the help text states it should) rather than as a basic name. For example, lake exe @mathlib/runLinter should now work. See PR #2932.* lake new foo.bar [std] now generates executables named foo-bar and lake new foo.bar exe properly creates foo/bar.lean. See PR #2932.* Later packages and libraries in the dependency tree are now preferred over earlier ones. That is, the later ones \"shadow\" the earlier ones. Such an ordering is more consistent with how declarations generally work in programming languages. This will break any package that relied on the previous ordering. See issue #2548 and PR #2937.* Executable roots are no longer mistakenly treated as importable. They will no longer be picked up by findModule?. See PR #2937.\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.4.0 (2023-12-31)","id":"/releases/v4.4.0/#release-v4___4___0"}});