window.docContents[45].resolve({"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction":{"contents":"\n\nThis section gives a very brief glimpse into the mathematical constructions that underlie termination proofs via well-founded recursion, which may surface occasionally.\nThe elaboration of functions defined by well-founded recursion is based on the WellFounded.fix operator.\n\nA well-founded fixpoint. If satisfying the motive C for all values that are smaller according to a\nwell-founded relation allows it to be satisfied for the current value, then it is satisfied for all\nvalues.This function is used as part of the elaboration of well-founded recursion.\n\nThe type α is instantiated with the function's (varying) parameters, packed into one type using PSigma.\nThe WellFounded relation is constructed from the termination measure via invImage.\n\nThe inverse image of a well-founded relation is well-founded.\n\nThe function's body is passed to WellFounded.fix, with parameters suitably packed and unpacked, and recursive calls are replaced with a call to the value provided by WellFounded.fix.\nThe termination proofs generated by the decreasing_by tactics are inserted in the right place.\n\nFinally, the equational and unfolding theorems for the recursive function are proved from WellFounded.fix_eq.\nThese theorems hide the details of packing and unpacking arguments and describe the function's behavior in terms of the original definition.\n\nIn the case of mutual recursion, an equivalent non-mutual function is constructed by combining the function's arguments using PSum, and pattern-matching on that sum type in the result type and the body.\n\nThe definition of WellFounded builds on the notion of accessible elements of the relation:\n\nA relation r is WellFounded if all elements of α are accessible within r.\nIf a relation is WellFounded, it does not allow for an infinite descent along the relation.If the arguments of the recursive calls in a function definition decrease according to\na well founded relation, then the function terminates.\nWell-founded relations are sometimes called Artinian or said to satisfy the “descending chain condition”.If all elements are accessible via r, then r is well-founded.\n\nAcc is the accessibility predicate. Given some relation r (e.g. <) and a value x,\nAcc r x means that x is accessible through r:x is accessible if there exists no infinite sequence ... < y₂ < y₁ < y₀ < x.A value is accessible if for all y such that r y x, y is also accessible.\nNote that if there exists no y such that r y x, then x is accessible. Such an x is called a\nbase case.\n\nDivision by Iterated Subtraction: Termination ProofThe definition of division by iterated subtraction can be written explicitly using well-founded recursion.noncomputable def div (n k : Nat) : Nat :=\n  (inferInstanceAs (WellFoundedRelation Nat)).wf.fix\n    (fun n r =>\n      if h : k = 0 then 0\n      else if h : k > n then 0\n      else 1 + (r (n - k) <| by\n        show (n - k) < n\n        omega))\n    n\nThe definition must be marked noncomputable because well-founded recursion is not supported by the compiler.\nLike recursors, it is part of Lean's logic.The definition of division should satisfy the following equations:* ∀{n k : Nat}, (k = 0) → div n k = 0* ∀{n k : Nat}, (k > n) → div n k = 0* ∀{n k : Nat}, (k ≠ 0) → (¬ k > n) → div n k = div (n - k) kThis reduction behavior does not hold definitionally:theorem div.eq0 : div n 0 = 0 := by rfl\nTactic `rfl` failed: The left-hand side\n  div n 0\nis not definitionally equal to the right-hand side\n  0\n\nn : Nat\n⊢ div n 0 = 0\nHowever, using WellFounded.fix_eq to unfold the well-founded recursion, the three equations can be proved to hold:theorem div.eq0 : div n 0 = 0 := by\n  unfold div\n  apply WellFounded.fix_eq\n\ntheorem div.eq1 : k > n → div n k = 0 := by\n  intro h\n  unfold div\n  rw [WellFounded.fix_eq]\n  simp only [gt_iff_lt, dite_eq_ite, ite_eq_left_iff, Nat.not_lt]\n  intros; omega\n\ntheorem div.eq2 :\n    ¬ k = 0 → ¬ (k > n) →\n    div n k = 1 + div (n - k) k := by\n  intros\n  unfold div\n  rw [WellFounded.fix_eq]\n  simp_all only [\n    gt_iff_lt, Nat.not_lt,\n    dite_false, dite_eq_ite,\n    ite_false, ite_eq_right_iff\n  ]\n  omega\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","header":"7.6.3.7. Theory and Construction","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Paths":{"contents":"Paths are represented by strings.\nDifferent platforms have different conventions for paths: some use slashes (/) as directory separators, others use backslashes (\\).\nSome are case-sensitive, others are not.\nDifferent Unicode encodings and normal forms may be used to represent filenames, and some platforms consider filenames to be byte sequences rather than strings.\nA string that represents an absolute path on one system may not even be a valid path on another system.\n\nTo write Lean code that is as compatible as possible with multiple systems, it can be helpful to use Lean's path manipulation primitives instead of raw string manipulation.\nHelpers such as System.FilePath.join take platform-specific rules for absolute paths into account, System.FilePath.pathSeparator contains the appropriate path separator for the current platform, and System.FilePath.exeExtension contains any necessary extension for executable files.\nAvoid hard-coding these rules.\n\nThere is an instance of the Div type class for FilePath which allows the slash operator to be used to concatenate paths.\n\nA path on the file system.Paths consist of a sequence of directories followed by the name of a file or directory. They are\ndelimited by a platform-dependent separator character (see System.FilePath.pathSeparator).The string representation of the path.\n\nConstructs a path from a list of file names by interspersing them with the current platform's path\nseparator.\n\nAppends two paths, taking absolute paths into account. This operation is also accessible via the /\noperator.If sub is an absolute path, then p is discarded and sub is returned. If sub is a relative\npath, then it is attached to p with the platform-specific path separator.\n\nNormalizes a path, returning an equivalent path that may better follow platform conventions.In particular:* On Windows, drive letters are made uppercase.* On platforms that support multiple path separators (that is, where\nSystem.FilePath.pathSeparators has length greater than one), alternative path separators are\nreplaced with the preferred path separator.There is no guarantee that two equivalent paths normalize to the same path.\n\nAn absolute path starts at the root directory or a drive letter. Accessing files through an absolute\npath does not depend on the current working directory.\n\nA relative path is one that depends on the current working directory for interpretation. Relative\npaths do not start with the root directory or a drive letter.\n\nReturns the parent directory of a path, if there is one.If the path is that of the root directory or the root of a drive letter, none is returned.\nOtherwise, the path's parent directory is returned.\n\nSplits a path into a list of individual file names at the platform-specific path separator.\n\nExtracts the last element of a path if it is a file or directory name.Returns none if the last entry is a special name (such as . or ..) or if the path is the root\ndirectory.\n\nExtracts the stem (non-extension) part of p.fileName.If the filename contains multiple extensions, then only the last one is removed. Returns none if\nthere is no file name at the end of the path.Examples:* (\"app.exe\" : System.FilePath).fileStem = some \"app\"* (\"file.tar.gz\" : System.FilePath).fileStem = some \"file.tar\"* (\"files/\" : System.FilePath).fileStem = none* (\"files/picture.jpg\" : System.FilePath).fileStem = some \"picture\"\n\nExtracts the extension part of p.fileName.If the filename contains multiple extensions, then only the last one is extracted. Returns none if\nthere is no file name at the end of the path.Examples:* (\"app.exe\" : System.FilePath).extension = some \"exe\"* (\"file.tar.gz\" : System.FilePath).extension = some \"gz\"* (\"files/\" : System.FilePath).extension = none* (\"files/picture.jpg\" : System.FilePath).extension = some \"jpg\"\n\nAppends the extension ext to a path p.ext should not have leading ., as this function adds one. If ext is the empty string, no\n. is added.Unlike System.FilePath.withExtension, this does not remove any existing extension.\n\nReplaces the current extension in a path p with ext, adding it if there is no extension. If the\npath has multiple file extensions, only the last one is replaced. If the path has no filename, or if\next is the empty string, then the filename is returned unmodified.ext should not have a leading ., as this function adds one.Examples:* (\"files/picture.jpeg\" : System.FilePath).withExtension \"jpg\" = ⟨\"files/picture.jpg\"⟩* (\"files/\" : System.FilePath).withExtension \"zip\" = ⟨\"files/\"⟩* (\"files\" : System.FilePath).withExtension \"zip\" = ⟨\"files.zip\"⟩* (\"files/archive.tar.gz\" : System.FilePath).withExtension \"xz\" = ⟨\"files.tar.xz\"⟩\n\nReplaces the file name at the end of the path p with fname, placing fname in the parent\ndirectory of p.If p has no parent directory, then fname is returned unmodified.\n\nThe character that separates directories.On platforms that support multiple separators, System.FilePath.pathSeparator is the “ideal” one expected by users\non the platform. System.FilePath.pathSeparators lists all supported separators.\n\nThe list of all path separator characters supported on the current platform.On platforms that support multiple separators, System.FilePath.pathSeparator is the “ideal” one\nexpected by users on the platform.\n\nThe character that separates file extensions from file names.\n\nThe file extension expected for executable binaries on the current platform, or \"\" if there is no\nsuch extension.\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.3. Paths","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Paths"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Other":{"contents":"* #6479 speeds up JSON serialisation by using a lookup table to check\nwhether a string needs to be escaped.* #6519 adds a script to automatically generate release notes using the\nnew changelog-* labels and \"...\" conventions.* #6542 introduces a script that automates checking whether major\ndownstream repositories have been updated for a new toolchain release.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Other","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Other"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Updates-to-the-try___-Tactic":{"contents":"* #6961 adds the auxiliary tactic evalAndSuggest. It will be used to\nrefactor try?.* #6965 re-implements the try? tactic using the new evalAndSuggest\ninfrastructure.* #6967 ensures try? can suggest tactics that need to reference\ninaccessible local names.\nExample:/--\ninfo: Try these:\n• · expose_names; induction as, bs_1 using app.induct <;> grind [= app]\n• · expose_names; induction as, bs_1 using app.induct <;> grind only [app]\n-/\n#guard_msgs (info) in\nexample : app (app as bs) cs = app as (app bs cs) := by\n  have bs := 20 -- shadows `bs` in the target\n  try?\n* #6979 adds support for more complex suggestions in try?.\nExample:example (as : List α) (a : α) : concat as a = as ++ [a] := by\n  try?\nsuggestionTry this: · induction as, a using concat.induct\n  · rfl\n  · simp_all\n* #6980 improves the try? tactic runtime validation and error\nmessages. It also simplifies the implementation, and removes unnecessary\ncode.* #6981 adds new configuration options to try?.* try? -only omits simp only and grind only suggestions* try? +missing enables partial solutions where some subgoals are\n\"solved\" using sorry, and must be manually proved by the user.* try? (max:=<num>) sets the maximum number of suggestions produced\n(default is 8).* #6991 improves how suggestions for the <;> combinator are generated.* #6994 adds the Try.Config.merge flag (true by default) to the\ntry? tactic. When set to true, try? compresses suggestions such\nas:· induction xs, ys using bla.induct\n    · grind only [List.length_reverse]\n    · grind only [bla]\ninto:induction xs, ys using bla.induct <;> grind only [List.length_reverse, bla]\n* #6995 implements support for exact? in the try? tactic.* #7082 makes try? use fun_induction instead of induction … using foo.induct. It uses the argument-free short-hand fun_induction foo if\nthat is unambiguous. Avoids expose_names if not necessary by simply\ntrying without first.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"Updates to the try? Tactic","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Updates-to-the-try___-Tactic"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Pretty-Printing":{"contents":"* #7074 modifies the signature pretty printer to add hover information\nfor parameters in binders. This makes the binders be consistent with the\nhovers in pi types.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Pretty Printing","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Pretty-Printing"}});