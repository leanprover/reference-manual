window.docContents[15].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Runtime-Representation":{"contents":"Bitvectors are represented as a Fin with the corresponding range.\nBecause BitVec is a trivial wrapper around Fin and Fin is a trivial wrapper around Nat, bitvectors use the same runtime representation as Nat in compiled code.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors","header":"19.5.2. Runtime Representation","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Runtime-Representation"},"/Definitions/Recursive-Definitions/#unsafe":{"contents":"Unsafe definitions have even fewer safeguards than partial functions.\nTheir codomains do not need to be inhabited, they are not restricted to function definitions, and they have access to features of Lean that might violate internal invariants or break abstractions.\nAs a result, they cannot be used at all as part of mathematical reasoning.\n\nWhile partial functions are treated as opaque constants by the type theory, unsafe definitions may only be referenced from other unsafe definitions.\nAs a consequence, any function that calls an unsafe function must be unsafe itself.\nTheorems are not allowed to be declared unsafe.\n\nIn addition to unrestricted use of recursion, unsafe functions can cast from one type to another, check whether two values are the very same object in memory, retrieve pointer values, and run IO actions from otherwise-pure code.\nUsing these operators requires a thorough understanding of the Lean implementation.\n\nThis function will cast a value of type α to type β, and is a no-op in the\ncompiler. This function is extremely dangerous because there is no guarantee\nthat types α and β have the same data representation, and this can lead to\nmemory unsafety. It is also logically unsound, since you could just cast\nTrue to False. For all those reasons this function is marked as unsafe.It is implemented by lifting both α and β into a common universe, and then\nusing cast (lcProof : ULift (PLift α) = ULift (PLift β)) to actually perform\nthe cast. All these operations are no-ops in the compiler.Using this function correctly requires some knowledge of the data representation\nof the source and target types. Some general classes of casts which are safe in\nthe current runtime:* Array α to Array β where α and β have compatible representations,\nor more generally for other inductive types.* Quot α r and α.* @Subtype α p and α, or generally any structure containing only one\nnon-Prop field of type α.* Casting α to/from NonScalar when α is a boxed generic type\n(i.e. a function that accepts an arbitrary type α and is not specialized to\na scalar type like UInt8).\n\nCompares two objects for pointer equality.Two objects are pointer-equal if, at runtime, they are allocated at exactly the same address. This\nfunction is unsafe because it can distinguish between definitionally equal values.\n\nCompares two lists of objects for element-wise pointer equality. Returns true if both lists are\nthe same length and the objects at the corresponding indices of each list are pointer-equal.Two objects are pointer-equal if, at runtime, they are allocated at exactly the same address. This\nfunction is unsafe because it can distinguish between definitionally equal values.\n\nReturns the address at which an object is allocated.This function is unsafe because it can distinguish between definitionally equal values.\n\nReturns true if a is an exclusive object.An object is exclusive if it is single-threaded and its reference counter is 1. This function is\nunsafe because it can distinguish between definitionally equal values.\n\nA monad that can have side effects on the external world or throw exceptions of type ε.BaseIO is a version of this monad that cannot throw exceptions. IO sets the exception type to\nIO.Error.\n\nExecutes arbitrary side effects in a pure context, with exceptions indicated via Except. This a\ndangerous operation that can easily undermine important assumptions about the meaning of Lean\nprograms, and it should only be used with great care and a thorough understanding of compiler\ninternals, and even then only to implement observationally pure operations.This function is not a good way to convert an EIO α or IO α into an α. Instead, use\ndo-notation.Because the resulting value is treated as a side-effect-free term, the compiler may re-order,\nduplicate, or delete calls to this function. The side effect may even be hoisted into a constant,\ncausing the side effect to occur at initialization time, even if it would otherwise never be called.\n\nExecutes arbitrary side effects in a pure context. This a dangerous operation that can easily\nundermine important assumptions about the meaning of Lean programs, and it should only be used with\ngreat care and a thorough understanding of compiler internals, and even then only to implement\nobservationally pure operations.This function is not a good way to convert a BaseIO α into an α. Instead, use\ndo-notation.Because the resulting value is treated as a side-effect-free term, the compiler may re-order,\nduplicate, or delete calls to this function. The side effect may even be hoisted into a constant,\ncausing the side effect to occur at initialization time, even if it would otherwise never be called.\n\nFrequently, unsafe operators are used to write fast code that takes advantage of low-level details.\nJust as Lean code may be replaced at runtime with C code via the FFI, safe Lean code may be replaced with unsafe Lean code for runtime programs.\nThis is accomplished by adding the implemented_by attribute to the function that is to be replaced, which is often an opaque definition.\nWhile this does not threaten Lean's soundness as a logic because the constant to be replaced has already been checked by the kernel and the unsafe replacement is only used in run-time code, it is still risky.\nBoth C code and unsafe code may execute arbitrary side effects.\n\nReplacing Run-Time ImplementationsThe implemented_by attribute instructs the compiler to replace one constant with another in compiled code.\nThe replacement constant may be unsafe.\n\nChecking Equality with PointersOrdinarily, a BEq instance's equality predicate must fully traverse both of its arguments to determine whether they are equal.\nIf they are, in fact, the very same object in memory, this is wasteful indeed.\nA pointer equality test can be used prior to the traversal to catch this case.The type being compared is Tree, a type of binary trees.inductive Tree α where\n  | empty\n  | branch (left : Tree α) (val : α) (right : Tree α)\nAn unsafe function may use pointer equality to terminate the structural equality test more quickly, falling back to structural checks when pointer equality fails.unsafe def Tree.fastBEq [BEq α] (t1 t2 : Tree α) : Bool :=\n  if ptrEq t1 t2 then\n    true\n  else\n    match t1, t2 with\n    | .empty, .empty => true\n    | .branch l1 x r1, .branch l2 y r2 =>\n      if ptrEq x y || x == y then\n        l1.fastBEq l2 && r1.fastBEq r2\n      else false\n    | _, _ => false\nAn implemented_by attribute on an opaque definition bridges the worlds of safe and unsafe code.@[implemented_by Tree.fastBEq]\nopaque Tree.beq [BEq α] (t1 t2 : Tree α) : Bool\n\ninstance [BEq α] : BEq (Tree α) where\n  beq := Tree.beq\n\n\nTaking Advantage of Run-Time RepresentationsBecause a Fin is represented identically to its underlying Nat, List.map Fin.val can be replaced by unsafeCast to avoid a linear-time traversal that, in practice, does nothing:unsafe def unFinImpl (xs : List (Fin n)) : List Nat :=\n  unsafeCast xs\n\n@[implemented_by unFinImpl]\ndef unFin (xs : List (Fin n)) : List Nat :=\n  xs.map Fin.val\nFrom the perspective of the Lean kernel, unFin is defined using List.map:theorem unFin_length_eq_length {xs : List (Fin n)} :\n    (unFin xs).length = xs.length := by\n  simp [unFin]\nIn compiled code, there is no traversal of the list.This kind of replacement is risky: the correspondence between the proof and the compiled code depends fully on the equivalence of the two implementations, which cannot be proved in Lean.\nThe correspondence relies on details of Lean's implementation.\nThese “escape hatches” should be used very carefully.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial and Unsafe Definitions","header":"7.6.5.2. Unsafe Definitions","id":"/Definitions/Recursive-Definitions/#unsafe"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--grind-Tactic--Cutsat-Procedure-_LPAR_Solver-for-Linear-Integer-Arithmetic-Problems_RPAR_":{"contents":"* #7077 proves the helper theorems for justifying the \"Div-Solve\" rule\nin the cutsat procedure.* #7091 adds helper theorems for normalizing divisibility constraints.\nThey are going to be used to implement the cutsat procedure in the\ngrind tactic.* #7092 implements divisibility constraint normalization in simp +arith.* #7097 implements several modifications for the cutsat procedure in\ngrind.* The maximal variable is now at the beginning of linear polynomials.* The old LinearArith.Solver was deleted, and the normalizer was moved\nto Simp.* cutsat first files were created, and basic infrastructure for\nrepresenting divisibility constraints was added.* #7122 implements the divisibility constraint solver for the cutsat\nprocedure in the grind tactic.* #7124 adds the helper theorems for justifying the divisibility\nconstraint solver in the cutsat procedure used by the grind tactic.* #7138 implements proof generation for the divisibility constraint\nsolver in grind.* #7139 uses a let-expression for storing the (shared) context in\nproofs produced by the cutsat procedure in grind.* #7152 implements the infrastructure for supporting integer inequality\nconstraints in the cutsat procedure.* #7155 implements some infrastructure for the model search procedure in\ncutsat.* #7156 adds a helper theorem that will be used in divisibility\nconstraint conflict resolution during model construction.* #7176 implements model construction for divisibility constraints in\nthe cutsat procedure.* #7183 improves the cutsat model search procedure.* #7186 simplifies the proofs and data structures used by cutsat.* #7193 adds basic infrastructure for adding support for equalities in\ncutsat.* #7194 adds support theorems for solving equality in cutsat.* #7202 adds support for internalizing terms relevant to the cutsat\nmodule. This is required to implement equality propagation.* #7203 improves the support for equalities in cutsat. It also\nsimplifies a few support theorems used to justify cutsat rules.* #7217 improves the support for equalities in cutsat.* #7220 implements the missing cases for equality propagation from the\ngrind core to the cutsat module.* #7234 implements dIsequality propagation from grind core module to\ncutsat.* #7244 adds support for disequalities in the cutsat procedure used in\ngrind.* #7248 implements simple equality propagation in cutsat p <= 0 -> -p <= 0 -> p = 0* #7252 implements inequality refinement using disequalities. It\nminimizes the number of case splits cutsat will have to perform.* #7267 improves the cutsat search procedure. It adds support for find\nan approximate rational solution, checks disequalities, and adds stubs\nfor all missing cases.* #7278 adds counterexamples for linear integer constraints in the\ngrind tactic. This feature is implemented in the cutsat procedure.* #7279 adds support theorems for the Cooper-Dvd-Left conflict\nresolution rule used in the cutsat procedure. During model construction,\nwhen attempting to extend the model to a variable x, cutsat may find a\nconflict that involves two inequalities (the lower and upper bounds for\nx) and a divisibility constraint:a * x + p ≤ 0\nb * x + q ≤ 0\nd ∣ c * x + s\n* #7284 implements non-choronological backtracking for the cutsat\nprocedure. The procedure has two main kinds of case-splits:\ndisequalities and Cooper resolvents. focus on the first kind.* #7290 adds support theorems for the Cooper-Left conflict\nresolution rule used in the cutsat procedure. During model\nconstruction,when attempting to extend the model to a variable x,\ncutsat may find a conflict that involves two inequalities (the lower and\nupper bounds for x). This is a special case of Cooper-Dvd-Left when\nthere is no divisibility constraint.* #7292 adds support theorems for the Cooper-Dvd-Right conflict\nresolution rule used in the cutsat procedure. During model construction,\nwhen attempting to extend the model to a variable x, cutsat may find a\nconflict that involves two inequalities (the lower and upper bounds for\nx) and a divisibility constraint.* #7293 adds support theorems for the Cooper-Right conflict resolution\nrule used in the cutsat procedure. During model construction, when\nattempting to extend the model to a variable x, cutsat may find a\nconflict that involves two inequalities (the lower and upper bounds for\nx). This is a special case of Cooper-Dvd-Right when there is no\ndivisibility constraint.* #7409 allows the use of dsimp during preprocessing of well-founded\ndefinitions. This fixes regressions when using if-then-else without\ngiving a name to the condition, but where the condition is needed for\nthe termination proof, in cases where that subexpression is reachable\nonly by dsimp, but not by simp (e.g. inside a dependent let)\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language\u0009grind Tactic","header":"Cutsat Procedure (Solver for Linear Integer Arithmetic Problems)","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--grind-Tactic--Cutsat-Procedure-_LPAR_Solver-for-Linear-Integer-Arithmetic-Problems_RPAR_"}});