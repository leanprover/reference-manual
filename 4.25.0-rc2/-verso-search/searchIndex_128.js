window.docContents[128].resolve({"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Properties":{"contents":"Returns the “sign” of the integer as another integer:* 1 for positive numbers,* -1 for negative numbers, and* 0 for 0.Examples:* Int.sign 34 = 1* Int.sign 2 = 1* Int.sign 0 = 0* Int.sign -1 = -1* Int.sign -362 = -1\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","header":"19.2.4.1. Properties","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Properties"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Head-and-Tail":{"contents":"Returns the first element of a non-empty list.\n\nReturns the first element in the list, if there is one. Returns none if the list is empty.Use List.headD to provide a fallback value for empty lists, or List.head! to panic on empty\nlists.Examples:* ([] : List Nat).head? = none* [3, 2, 1].head? = some 3\n\nReturns the first element in the list if there is one, or fallback if the list is empty.Use List.head? to return an Option, and List.head! to panic on empty lists.Examples:* [].headD \"empty\" = \"empty\"* [].headD 2 = 2* [\"head\", \"shoulders\", \"knees\"].headD \"toes\" = \"head\"\n\nReturns the first element in the list. If the list is empty, panics and returns default.Safer alternatives include:* List.head, which requires a proof that the list is non-empty,* List.head?, which returns an Option, and* List.headD, which returns an explicitly-provided fallback value on empty lists.\n\nDrops the first element of a nonempty list, returning the tail. Returns [] when the argument is\nempty.Examples:* [\"apple\", \"banana\", \"grape\"].tail = [\"banana\", \"grape\"]* [\"apple\"].tail = []* ([] : List String).tail = []\n\nDrops the first element of a nonempty list, returning the tail. If the list is empty, this function\npanics when executed and returns the empty list.Safer alternatives include* tail, which returns the empty list without panicking,* tail?, which returns an Option, and* tailD, which returns a fallback value when passed the empty list.Examples:* [\"apple\", \"banana\", \"grape\"].tail! = [\"banana\", \"grape\"]* [\"banana\", \"grape\"].tail! = [\"grape\"]\n\nDrops the first element of a nonempty list, returning the tail. Returns none when the argument is\nempty.Alternatives include List.tail, which returns the empty list on failure, List.tailD, which\nreturns an explicit fallback value, and List.tail!, which panics on the empty list.Examples:* [\"apple\", \"banana\", \"grape\"].tail? = some [\"banana\", \"grape\"]* [\"apple\"].tail? = some []* ([] : List String).tail = none\n\nDrops the first element of a nonempty list, returning the tail. Returns none when the argument is\nempty.Alternatives include List.tail, which returns the empty list on failure, List.tail?, which\nreturns an Option, and List.tail!, which panics on the empty list.Examples:* [\"apple\", \"banana\", \"grape\"].tailD [\"orange\"] = [\"banana\", \"grape\"]* [\"apple\"].tailD [\"orange\"] = []* [].tailD [\"orange\"] = [\"orange\"]\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.4. Head and Tail","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Head-and-Tail"},"/Definitions/Recursive-Definitions/#partial-functions":{"contents":"The partial modifier may only be applied to function definitions.\nPartial functions are not required to demonstrate termination, and Lean does not attempt to do so.\nThese functions are “partial” in the sense that they do not necessarily specify a mapping from each element of the domain to an element of the codomain, because they might fail to terminate for some or all elements of the domain.\nThey are elaborated into pre-definitions that contain explicit recursion, and type checked using the kernel; however, they are subsequently treated as opaque constants by the logic.\n\nThe function's return type must be inhabited; this ensures soundness.\nOtherwise, a partial function could have a type such as Unit → Empty.\nTogether with Empty.elim, the existence of such a function could be used to prove False even if it does not reduce.\n\nWith partial definitions, the kernel is responsible for the following:\n\n* It ensures that the pre-definition's type is indeed a well-formed type.* It checks that the pre-definition's type is a function type.* It ensures that the function's codomain is inhabited by demanding a Nonempty or Inhabited instance.* It checks that the resulting term would be type-correct if Lean had recursive definitions.\n\nEven though recursive definitions are not part of the kernel's type theory, the kernel can still be used to check that the body of the definition has the right type.\nThis works the same way as in other functional languages: uses of recursion are type checked by checking the body in an environment in which the definition is already associated with its type.\nHaving ensured that it type checks, the body is discarded and only the opaque constant is retained by the kernel.\nAs with all Lean functions, the compiler generates code from the elaborated pre-definition.\n\nEven though partial functions are not unfolded by the kernel, it is still possible to reason about other functions that call them so long as this reasoning doesn't depend on the implementation of the partial function itself.\n\nPartial Functions in ProofsThe recursive function nextPrime inefficiently computes the next prime number after a given number by repeatedly testing candidates with trial division.\nBecause there are infinitely many prime numbers, it always terminates; however, formulating this proof would be nontrivial.\nIt is thus marked partial.def isPrime (n : Nat) : Bool := Id.run do\n  for i in [2:n] do\n    if i * i > n then return true\n    if n % i = 0 then return false\n  return true\n\npartial def nextPrime (n : Nat) : Nat :=\n  let n := n + 1\n  if isPrime n then n else nextPrime n\nIt is nonetheless possible to prove that the following two functions are equal:def answerUser (n : Nat) : String :=\n  s!\"The next prime is {nextPrime n}\"\n\ndef answerOtherUser (n : Nat) : String :=\n  \" \".intercalate [\n    \"The\",\n    \"next\",\n    \"prime\",\n    \"is\",\n    toString (nextPrime n)\n  ]\nIn fact, the proof is by rfl:theorem answer_eq_other : answerUser = answerOtherUser := by\n  rfl\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial and Unsafe Definitions","header":"7.6.5.1. Partial Functions","id":"/Definitions/Recursive-Definitions/#partial-functions"},"/Introduction/#reference-boxes":{"contents":"Definitions, inductive types, syntax formers, and tactics have specific descriptions.\nThese descriptions are marked as follows:\n\n/--\nEvenness: a number is even if it can be evenly divided by two.\n-/\ninductive Even : Nat → Prop where\n  | /-- 0 is considered even here -/\n    zero : Even 0\n  | /-- If `n` is even, then so is `n + 2`. -/\n    plusTwo : Even n → Even (n + 2)\nEvenness: a number is even if it can be evenly divided by two.0 is considered even hereIf n is even, then so is n + 2.\n\n","context":"Lean Reference\u0009Introduction\u0009Typographical Conventions","header":"1.2.4. Constant, Syntax, and Tactic References","id":"/Introduction/#reference-boxes"},"/Notations-and-Macros/#language-extension":{"contents":"Different mathematical fields have their own notational conventions, and many notations are re-used with differing meanings in different fields.\nIt is important that formal developments are able to use established notations: formalizing mathematics is already difficult, and the mental overhead of translating between syntaxes can be substantial.\nAt the same time, it's important to be able to control the scope of notational extensions.\nMany fields use related notations with very different meanings, and it should be possible to combine developments from these separate fields in a way where both readers and the system know which convention is in force in any given region of a file.\n\nLean addresses the problem of notational extensibility with a variety of mechanisms, each of which solves a different aspect of the problem.\nThey can be combined flexibly to achieve the necessary results:\n\n* The extensible parser  allows a great variety of notational conventions to be implemented declaratively, and combined flexibly.* Macros allow new syntax to be easily mapped to existing syntax, which is a simple way to provide meaning to new constructs.\n  Due to hygiene and automatic propagation of source positions, this process doesn't interfere with Lean's interactive features.* Elaborators provide new syntax with the same tools available to Lean's own syntax in cases where a macro is insufficiently expressive.* Notations allow the simultaneous definition of a parser extension, a macro, and a pretty printer.\n   When defining infix, prefix, or postfix operators, custom operators automatically take care of precedence and associativity.* Low-level parser extensions allow the parser to be extended in ways that modify its rules for tokens and whitespace, or that even completely replace Lean's syntax. This is an advanced topic that requires familiarity with Lean internals; nevertheless, the possibility of doing this without modifying the compiler is important. This reference manual is written using a language extension that replaces Lean's concrete syntax with a Markdown-like language for writing documents, but the source files are still Lean files.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"20. Notations and Macros","id":"/Notations-and-Macros/#language-extension"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-classical":{"contents":"classical tacs runs tacs in a scope where Classical.propDecidable is a low priority\nlocal instance.Note that classical is a scoping tactic: it adds the instance only within the\nscope of the tactic.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.1. Classical Logic","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-classical"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Documentation":{"contents":"* #6009 fixes a typo in the docstring for prec and makes the text\nslightly more precise.* #6040 join → flatten in docstring* #6110 does some mild refactoring of the Lean.Elab.StructInst module\nwhile adding documentation.* #6144 converts 3 doc-string to module docs since it seems that this is\nwhat they were intended to be!* #6150 refine kernel code comments* #6158 adjust file reference in Data.Sum* #6239 explains the order in which Expr.abstract introduces de Bruijn\nindices.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Documentation","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Documentation"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Language":{"contents":"* #7844 adds a simple implementation of MePo, from \"Lightweight\nrelevance filtering for machine-generated resolution problems\" by Meng\nand Paulson.* #10158 adds information about definitions blocked from unfolding via\nthe module system to type defeq errors.* #10268 adds an alternative implementation of DerivingBEq based on\ncomparing .ctorIdx and using a dedicated matcher for comparing same\nconstructors (added in #10152), to avoid the quadratic overhead of the\ndefault match implementation. The new option\nderiving.beq.linear_construction_threshold sets the constructor count\nthreshold (10 by default) for using the new construction. Such instances\nalso allow deriving ReflBEq, LawfulBeq, although these proofs for\nthese properties are still quadratic.* #10270 adds an alternative implementation of Deriving Ord based on\ncomparing .ctorIdx and using a dedicated matcher for comparing same\nconstructors (added in #10152). The new option\nderiving.ord.linear_construction_threshold sets the constructor count\nthreshold (10 by default) for using the new construction.* #10302 introduces the @[specs] attribute. It can be applied to\n(certain) type class instances and define “specification theorems” for\nthe class’ operations, by taking the equational theorems of the\nimplementation function mentioned in the type class instance and\nrephrasing them in terms of the overloaded operations. Fixes #5295.* #10333 introduces a coinductive keyword, that can be used to define\ncoinductive predicates via a syntax identical to the one for inductive\nkeyword. The machinery relies on the implementation of elaboration of\ninductive types and extracts an endomap on the appropriate space of the\npredicates from the definition that is then fed to the\nPartialFixpoint. Upon elaborating definitions, all the constructors\nare declared through automatically generated lemmas.* #10346 lets deriving BEq and deriving Ord use @[method_specs]\nfrom #10302 when applicable (i.e. when not using partial).* #10351 adds the ability to do deriving ReflBEq, LawfulBEq. Both\nclasses have to listed in the deriving clause. For ReflBEq, a simple\nsimp-based proof is used. For LawfulBEq, a dedicated,\nsyntax-directed tactic is used that should work for derived BEq\ninstances. This is meant to work with deriving BEq (but you can try to\nuse it on hand-rolled @[methods_specs] instance : BEq… instances).\nDoes not support mutual or nested inductives.* #10375 adds support for non-commutative ring normalization in grind.\nThe new normalizer also accounts for the IsCharP type class. Examples:open Lean Grind\n\nvariable (R : Type u) [Ring R]\nexample (a b : R) : (a + 2 * b)^2 = a^2 + 2 * a * b + 2 * b * a + 4 * b^2 := by grind\nexample (a b : R) : (a + 2 * b)^2 = a^2 + 2 * a * b + -b * (-4) * a - 2*b*a + 4 * b^2 := by grind\n\nvariable [IsCharP R 4]\nexample (a b : R) : (a - b)^2 = a^2 - a * b - b * 5 * a + b^2 := by grind\nexample (a b : R) : (a - b)^2 = 13*a^2 - a * b - b * 5 * a + b*3*b*3 := by grind\n* #10377 fixes an issue where the \"eta feature\" in the app elaborator,\nwhich is invoked when positional arguments are skipped due to named\narguments, results in variables that can be captured by those named\narguments. Now the temporary local variables that implement this feature\nget fresh names. The names used for the closed lambda expression still\nuse the original parameter names.* #10378 enables using notation items in\ninfix/infixl/infixr/prefix/postfix. The motivation for this is\nto enable being able to use pp.unicode-aware parsers. A followup PR\ncan combine core parsers as such:infixr:30 unicode(\" ∨ \", \" \\\\/ \") => Or\n* #10379 modifies the syntax for tactic configurations. Previously just\n(ident would commit to tactic configuration item parsing, but now it\nneeds to be (ident :=. This enables reliably using tactic\nconfigurations before the term category. For example, given syntax \"my_tac\" optConfig term : tactic, it used to be that my_tac (x + y)\nwould have an error on + with \"expected :=\", but now it parses the\nterm.* #10380 implements sanity checks in the grind ring module to ensure\nthe instances synthesized by type class resolution are definitionally\nequal to the corresponding ones in the grind core classes. The\ndefinitional equality test is performed with reduction restricted to\nreducible definitions and instances.* #10382 makes the builtin Verso docstring elaborators bootstrap\ncorrectly, adds the ability to postpone checks (which is necessary for\nresolving forward references and bootstrapping issues), and fixes a\nminor parser bug.* #10388 fixes a bug where definitions with nested proofs that contain\nsorry might not report \"warning: declaration uses 'sorry'\" if the\nproof has the same type as another nested proof from a previous\ndeclaration. The bug only affected log messages; #print axioms would\nstill correctly report uses of sorryAx.* #10391 gives anonymous constructor notation (⟨x,y⟩) an error recovery\nmechanism where if there are not enough arguments then synthetic sorries\nare inserted for the missing arguments and an error is logged, rather\nthan outright failing.* #10392 fixes an issue with the if tactic where errors were not placed\nat the correct source ranges. It also adds some error recovery to avoid\nadditional errors about unsolved goals on the if token when the tactic\nhas incomplete syntax.* #10394 adds the reduceBEq and reduceOrd simprocs. They rewrite\noccurrences of _ == _ resp. Ord.compare _ _ if both arguments are\nconstructors and the corresponding instance has been marked with\n@[method_specs] (introduced in #10302), which now by default is the\ncase for derived instances.* #10406 improves upon #10302 to properly make the method spec theorems\nprivate if the implementation function is not exposed.* #10415 changes the order of steps tried when proving equational\ntheorems for structural recursion. In order to avoid goals that split\ncannot handle, avoid unfolding the LHS of the equation to .brecOn and\n.rec until after the RHS has been split into its final cases.* #10417 changes the automation in deriving_LawfulEq_tactic_step to use\nwith_reducible when asserting the shape of the goal using change, so\nthat we do not accidentally unfold x == x' calls here. Fixes #10416.* #10419 adds the helper theorem eq_normS_nc for normalizing\nnon-commutative semirings. We will use this theorem to justify\nnormalization steps in the grind ring module.* #10421 adds a normalizer for non-commutative semirings to grind.\nExamples:open Lean.Grind\nvariable (R : Type u) [Semiring R]\n\nexample (a b c : R) : a * (b + c) = a * c + a * b := by grind\nexample (a b : R) : (a + 2 * b)^2 = a^2 + 2 * a * b + 2 * b * a + 4 * b^2 := by grind\nexample (a b : R) : b^2 + (a + 2 * b)^2 = a^2 + 2 * a * b + b * (1+1) * a * 1 + 5 * b^2 := by grind\nexample (a b : R) : a^3 + a^2*b + a*b*a + b*a^2 + a*b^2 + b*a*b + b^2*a + b^3 = (a+b)^3 := by grind\n* #10422 implements the new E-matching pattern inference heuristic for\ngrind. It is not enabled yet. You can activate the new behavior using\nset_option backward.grind.inferPattern false. Here is a summary of the\nnew behavior.* #10425 lets the split tactic generalize discriminants that are not\nfree variables and proofs using generalize. If the only\nnon-fvar-discriminants are proofs, then this avoids the more elaborate\ngeneralization strategy of split, which can fail with dependent\nmotives, thus mitigating issue #10424.* #10428 makes explicit missing grind modifiers, and ensures grind\nuses \"minIndexable\" for local theorems.* #10430 ensures users can select the \"minimal indexable subexpression\"\ncondition in grind parameters. Example, they can now write grind [! -> thmName]. grind? will include the ! modifier whenever users had\nused @[grind!]. also fixes a missing case in the new pattern\ninference procedure.\nIt also adjusts some grind annotations and tests in preparation for\nsetting the new pattern inference heuristic as the new default.* #10432 enables the new E-matching pattern inference heuristic for\ngrind, implemented in PR #10422.\nImportant: Users can still use the old pattern inference heuristic\nby setting:set_option backward.grind.inferPattern true\n* #10434 adds reprove N by T, which effectively elaborates example type_of% N := by T. It supports multiple identifiers. This is useful\nfor testing tactics.* #10438 fixes an issue where notations and other overloadings would\nsignal kernel errors even though there exists a successful\ninterpretation.* #10440 adds the reduceCtorIdx simproc which recognizes and reduces\nctorIdx applications. This is not on by default yet because it does\nnot use the discrimination tree (yet).* #10453 makes mvcgen reduce through lets, so that it progresses over\n(have t := 42; fun _ => foo t) 23 by reduction to have t := 42; foo t and then introducing t.* #10456 implements mvcgen invariants? for providing initial invariant\nskeletons for the user to flesh out. When the loop body has an early\nreturn, it will helpfully suggest Invariant.withEarlyReturn ... as a\nskeleton.* #10479 implements module docstrings in Verso syntax, as well as adding\na number of improvements and fixes to Verso docstrings in general. In\nparticular, they now have language server support and are parsed at\nparse time rather than elaboration time, so the snapshot's syntax tree\nincludes the parsed documentation.* #10506 annotates the shadowing main definitions of bv_decide,\nmvcgen and similar tactics in Std with the semantically richer\ntactic_alt attribute so that verso will not warn about overloads.* #10507 makes the missing docs linter aware of tactic_alt.* #10508 allows .congr_simp theorems to be created not just for\ndefinitoins, but any constant. This is important to make the machinery\nwork across module boundaries.* #10512 adds some helper functions for the premise selection API, to\nassist implementers.* #10533 adds a docstring role for module names, called module. It also\nimproves the suggestions provided for code elements, making them more\nrelevant and proposing lit.* #10535 ensures that #guard can be called under the module system\nwithout issues.* #10536 fixes simp in -zeta -zetaUnused mode from producing\nincorrect proofs if in a have telescope a variable occurrs in the\ntype of the body only transitively. Fixes #10353.* #10543 lets #print T.rec show more information about a recursor, in\nparticular it's reduction rules.* #10560 adds highlighted Lean code to Verso docstrings and fixes smaller\nquality-of-life issues.* #10563 moves some ReduceEval instances about basic types up from the\nquote4 library.* #10566 improves mvcgen invariants? to suggest concrete invariants\nbased on how invariants are used in VCs.\nThese suggestions are intentionally simplistic and boil down to \"this\nholds at the start of the loop and this must hold at the end of the\nloop\":def mySum (l : List Nat) : Nat := Id.run do\n  let mut acc := 0\n  for x in l do\n    acc := acc + x\n  return acc\n\n/--\ninfo: Try this:\n  invariants\n    · ⇓⟨xs, letMuts⟩ => ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝\n-/\n#guard_msgs (info) in\ntheorem mySum_suggest_invariant (l : List Nat) : mySum l = l.sum := by\n  generalize h : mySum l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants?\n  all_goals admit\n* #10567 fixes argument index calculation in Lean.Expr.getArg!'.* #10570 adds support for case label like syntax in mvcgen invariants\nin order to refer to inaccessible names. Example:def copy (l : List Nat) : Id (Array Nat) := do\n  let mut acc := #[]\n  for x in l do\n    acc := acc.push x\n  return acc\n\ntheorem copy_labelled_invariants (l : List Nat) : ⦃⌜True⌝⦄ copy l ⦃⇓ r => ⌜r = l.toArray⌝⦄ := by\n  mvcgen [copy] invariants\n  | inv1 acc => ⇓ ⟨xs, letMuts⟩ => ⌜acc = l.toArray⌝\n  with admit\n* #10571 ensures that SPred proof mode tactics such as mspec,\nmintro, etc. immediately replace the main goal when entering the proof\nmode. This prevents No goals to be solved errors.* #10612 fixes an issue reported on\nZulip\nwhere abstractMVars (which is used in typeclass inference and simp\nargument elaboration) was not instantiating metavariables in the types\nof metavariables, causing it to abstract already-assigned metavariables.* #10618 removes superfluous Monad instances from the spec lemmas of\nthe MonadExceptOf lifting framework.* #10638 disables the \"experimental\" warning for mvcgen by changing its\ndefault.* #10639 fixes hygiene of the local context for all goals generated by\nmvcgen, not just those that get a fresh MVar as in #9781.* #10641 ensures that the mspec and mvcgen tactics no longer\nspuriously instantiate loop invariants by rfl.* #10644 explicitly tries to synthesize synthetic MVars in mspec. Doing\nso resolves a bug triggered by use of the loop invariant lemma for\nStd.PRange.* #10650 improves the error message for mstart when the goal is not a\nProp.* #10654 avoid reducing at transparency all in equational theorem\ngeneration. Fixes #10651.* #10663 disables {name} suggestions for .anonymous and adds syntax\nsuggestions.* #10682 changes the instance name for deriving ToExpr to be consistent\nwith other derived instance since #10271. Fixes #10678.* #10697 lets induction print a warning if a variable occurring in the\nusing clause is generalized. Fixes #10683.* #10712 lets MVarId.cleanup chase local declarations (a bit as if they\nwere equalities). Fixes #10710.* #10714 removes support for reducible well-founded recursion, a Breaking\nChange. Using @[semireducible] on a definition by well-founded\nrecursion prints a warning that this is no longer effective.* #10716 adds a new helper parser for implementing parsers that contain\nhexadecimal numbers. We are going to use it to implement anchors in the\ngrind interactive mode.* #10720 re-enables the \"experimental\" warning for mvcgen by changing\nits default. The official release has been postponed to justify small\nbreaking changes in the semantic foundations in the near future.* #10722 changes where errors are displayed when trying to use\ncoinductive keyword when targeting things that do not live in Prop.\nInstead of displaying the error above the first element of the mutual\nblock, it is displayed above the erroneous definition.* #10733 unfolds auxillary theorems more aggressively during termination\nchecking. This fixes #10721.* #10734 follows upon #10606 and creates equational theorems uniformly\nfrom the unfold theorem, there is only one handler registered in\nregisterGetEqnsFn.* #10780 improves the error message when decide +kernel fails in the\nkernel, but not the elaborator. Fixes #10766.* #10782 implements a hint tactic mvcgen?, expanding to mvcgen invariants?* #10783 ensures that error messages such as “redundant alternative” have\nthe right error location even if the arms share their RHS. Fixes #10781.* #10793 fixes #10792.* #10796 changes match compilation to reject some pattern matches that\nwere previously accepted due to inaccessible patterns sometimes treated\nlike accessible ones. Fixes #10794.* #10807 introduces the backward.privateInPublic option to aid in\nporting projects to the module system by temporarily allowing access to\nprivate declarations from the public scope, even across modules. A\nwarning will be generated by such accesses unless\nbackward.privateInPublic.warn is disabled.* #10839 exposes the optionValue parser used to implement the\nset_option notation.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Language","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Language"}});