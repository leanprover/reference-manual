window.docContents[21].resolve({"/Basic-Types/Natural-Numbers/#nat-api-minmax":{"contents":"Returns the lesser of two natural numbers. Usually accessed via Min.min.Returns n if n ≤ m, or m if m ≤ n.Examples:* min 0 5 = 0* min 4 5 = 4* min 4 3 = 3* min 8 8 = 8\n\nReturns the greater of two natural numbers. Usually accessed via Max.max.Returns m if n ≤ m, or n if m ≤ n.Examples:* max 0 5 = 5* max 4 5 = 5* max 4 3 = 4* max 8 8 = 8\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"19.1.4.2. Minimum and Maximum","id":"/Basic-Types/Natural-Numbers/#nat-api-minmax"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Positions--Lookups":{"contents":"Because they retain a reference to the slice from which they were drawn, slice positions allow individual characters or bytes to be looked up.\n\nReturns the byte at a position in a slice that is not the end position.\n\nObtains the character at the given position in the string.\n\nReturns the byte at the given position in the string, or panicks if the position is the end\nposition.\n\nReturns the byte at the given position in the string, or none if the position is the end\nposition.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009Positions","header":"19.8.4.12.3.1. Lookups","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Positions--Lookups"},"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts--Reversible-Lifting-with--MonadControl":{"contents":"A way to lift a computation from one monad to another while providing the lifted computation with a\nmeans of interpreting computations from the outer monad. This provides a means of lifting\nhigher-order operations automatically.Clients should typically use control or controlAt, which request an instance of MonadControlT:\nthe reflexive, transitive closure of MonadControl. New instances should be defined for\nMonadControl itself.A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.Lifts an action from the inner monad m to the outer monad n. The inner monad has access to a\nreverse lifting operator that can run an n action, returning a value and state together.Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to liftWith's parameter.\n\nA way to lift a computation from one monad to another while providing the lifted computation with a\nmeans of interpreting computations from the outer monad. This provides a means of lifting\nhigher-order operations automatically.Clients should typically use control or controlAt, which request an instance of MonadControlT:\nthe reflexive, transitive closure of MonadControl. New instances should be defined for\nMonadControl itself.A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.Lifts an action from the inner monad m to the outer monad n. The inner monad has access to a\nreverse lifting operator that can run an n action, returning a value and state together.Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to liftWith's parameter.\n\nLifts an operation from an inner monad to an outer monad, providing it with a reverse lifting\noperator that allows outer monad computations to be run in the inner monad. The lifted operation is\nrequired to return extra information that is required in order to reconstruct the reverse lift's\neffects in the outer monad; this extra information is determined by stM.This function takes the inner monad as an implicit parameter. Use controlAt to specify it\nexplicitly.\n\nLifts an operation from an inner monad to an outer monad, providing it with a reverse lifting\noperator that allows outer monad computations to be run in the inner monad. The lifted operation is\nrequired to return extra information that is required in order to reconstruct the reverse lift's\neffects in the outer monad; this extra information is determined by stM.This function takes the inner monad as an explicit parameter. Use control to infer the monad.\n\nExceptions and LiftingOne example is Except.tryCatch:Except.tryCatch.{u, v} {ε : Type u} {α : Type v}\n  (ma : Except ε α) (handle : ε → Except ε α) :\n  Except ε α\nBoth of its parameters are in Except ε.\nMonadLift can lift the entire application of the handler.\nThe function getBytes, which extracts the single bytes from an array of Nats using state and exceptions, is written without do-notation or automatic lifting in order to make its structure explicit.set_option autoLift false\n\ndef getByte (n : Nat) : Except String UInt8 :=\n  if n < 256 then\n    pure n.toUInt8\n  else throw s!\"Out of range: {n}\"\n\ndef getBytes (input : Array Nat) :\n    StateT (Array UInt8) (Except String) Unit := do\n  input.forM fun i =>\n    liftM (Except.tryCatch (some <$> getByte i) fun _ => pure none) >>=\n      fun\n        | some b => modify (·.push b)\n        | none => pure ()\n#eval getBytes #[1, 58, 255, 300, 2, 1000000] |>.run #[] |>.map (·.2)\nExcept.ok #[1, 58, 255, 2]\ngetBytes uses an Option returned from the lifted action to signal the desired state updates.\nThis quickly becomes unwieldy if there is more than one way to react to the inner action, such as saving handled exceptions.\nIdeally, state updates would be performed within the tryCatch call directly.Attempting to save bytes and handled exceptions does not work, however, because the arguments to Except.tryCatch have type Except String Unit:def getBytes' (input : Array Nat) :\n    StateT (Array String)\n      (StateT (Array UInt8)\n        (Except String)) Unit := do\n  input.forM fun i =>\n    liftM\n      (Except.tryCatch\n        (getByte i >>= fun b =>\n         modifyThe (Array UInt8) (·.push b))\n        fun e =>\n          modifyThe (Array String) (·.push e))\nfailed to synthesize\n  MonadStateOf (Array String) (Except String)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nBecause StateT has a MonadControl instance, control can be used instead of liftM.\nIt provides the inner action with an interpreter for the outer monad.\nIn the case of StateT, this interpreter expects that the inner monad returns a tuple that includes the updated state, and takes care of providing the initial state and extracting the updated state from the tuple.def getBytes' (input : Array Nat) :\n    StateT (Array String)\n      (StateT (Array UInt8)\n        (Except String)) Unit := do\n  input.forM fun i =>\n    control fun run =>\n      (Except.tryCatch\n        (getByte i >>= fun b =>\n         run (modifyThe (Array UInt8) (·.push b))))\n        fun e =>\n          run (modifyThe (Array String) (·.push e))\n#eval\n  getBytes' #[1, 58, 255, 300, 2, 1000000]\n  |>.run #[] |>.run #[]\n  |>.map (fun (((), bytes), errs) => (bytes, errs))\nExcept.ok (#[\"Out of range: 300\", \"Out of range: 1000000\"], #[1, 58, 255, 2])\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Lifting Monads\u0009Reversing Lifts","header":"14.2.1.2. Reversible Lifting with  MonadControl","id":"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts--Reversible-Lifting-with--MonadControl"},"/The-Simplifier/Invoking-the-Simplifier/#simp-tactic-params":{"contents":"The simplification tactics have the following grammar:\n\nSimplification Tactics\n\nIn other words, an invocation of a simplification tactic takes the following modifiers, in order, all of which are optional:\n\n* A set of configuration options, which should include the fields of Lean.Meta.Simp.Config or Lean.Meta.DSimp.Config, depending on whether the simplifier being invoked is a version of simp or a version of dsimp.* The only modifier excludes the default simp set, instead beginning with an emptyTechnically, the simp set always includes eq_self and iff_self in order to discharge reflexive cases. simp set.* The lemma list adds or removes lemmas from the simp set. There are three ways to specify lemmas in the lemma list:* *, which adds all assumptions in the proof state to the simp set* - followed by a lemma, which removes the lemma from the simp set* A lemma specifier, consisting of the following in sequence:* An optional ↓ or ↑, which respectively cause the lemma to be applied before or after entering a subterm (↑ is the default). The simplifier typically simplifies subterms before attempting to simplify parent terms, as simplified arguments often make more rules applicable; ↓ causes the parent term to be simplified with the rule prior to the simplification of subterms.* An optional ←, which causes equational lemmas to be used from right to left rather than from left to right.* A mandatory lemma, which can be a simp set name, a lemma name, or a term. Terms are treated as if they were named lemmas with fresh names.* A location specifier, preceded by at, which consists of a sequence of locations. Locations may be:* The name of an assumption, indicating that its type should be simplified* An asterisk *, indicating that all assumptions and the conclusion should be simplified* A turnstile ⊢, indicating that the conclusion should be simplifiedBy default, only the conclusion is simplified.\n\nLocation specifiers for simpIn this proof state,p : Nat → Prop\nx : Nat\nh : p (x + 5 + 2)\nh' : p (3 + x + 9)\n⊢ p (6 + x + 1)\nthe tactic simp +arith simplifies only the goal:p : Nat → Prop\nx : Nat\nh : p (x + 5 + 2)\nh' : p (3 + x + 9)\n⊢ p (x + 7)\nInvoking simp +arith at h yields a goal in which the hypothesis h has been simplified:p : Nat → Prop\nx : Nat\nh' : p (3 + x + 9)\nh : p (x + 7)\n⊢ p (6 + x + 1)\nThe conclusion can be additionally simplified by adding ⊢, that is, simp +arith at h ⊢:p : Nat → Prop\nx : Nat\nh' : p (3 + x + 9)\nh : p (x + 7)\n⊢ p (x + 7)\nUsing simp +arith at * simplifies all assumptions together with the conclusion:p : Nat → Prop\nx : Nat\nh : p (x + 7)\nh' : p (x + 12)\n⊢ p (x + 7)\n\n\n","context":"Lean Reference\u0009The Simplifier\u0009Invoking the Simplifier","header":"16.1.1. Parameters","id":"/The-Simplifier/Invoking-the-Simplifier/#simp-tactic-params"},"/The-Type-System/Quotients/#squash-types":{"contents":"\n\nSquash types are a quotient by the relation that relates all elements, transforming it into a subsingleton.\nIn other words, if α is inhabited, then Squash α has a single element, and if α is uninhabited, then Squash α is also uninhabited.\nUnlike Nonempty α, which is a proposition stating that α is inhabited and is thus represented by a dummy value at runtime, Squash α is a type that is represented identically to α.\nBecause Squash α is in the same universe as α, it is not subject to the restrictions on computing data from propositions.\n\n\n\nThe quotient of α by the universal relation. The elements of Squash α are those of α, but all\nof them are equal and cannot be distinguished.Squash α is a Subsingleton: it is empty if α is empty, otherwise it has just one element. It\nis the “universal Subsingleton” mapped from α.Nonempty α also has these properties. It is a proposition, which means that its elements (i.e.\nproofs) are erased from compiled code and represented by a dummy value. Squash α is a Type u,\nand its representation in compiled code is identical to that of α.Consequently, Squash.lift may extract an α value into any subsingleton type β, while\nNonempty.rec can only do the same when β is a proposition.\n\nPlaces a value into its squash type, in which it cannot be distinguished from any other.\n\nExtracts a squashed value into any subsingleton type.If β is a subsingleton, a function α → β cannot distinguish between elements of α and thus\nautomatically respects the universal relation that Squash quotients with.\n\nA reasoning principle that allows proofs about squashed types to assume that all values are\nconstructed with Squash.mk.\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.7. Squash Types","id":"/The-Type-System/Quotients/#squash-types"}});