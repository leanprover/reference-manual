window.docContents[211].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms":{"contents":"Computes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog.\n\nComputes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlogf.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10f.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2f.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"19.6.2.6. Logarithms","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams":{"contents":"Lean provides a consistent filesystem API on all supported platforms.\nThese are the key concepts:\n\n Files\n\nFiles are an abstraction provided by operating systems that provide random access to persistently-stored data, organized hierarchically into directories.\n\n Directories\n\nDirectories, also known as folders, may contain files or other directories.\n  Fundamentally, a directory maps names to the files and/or directories that it contains.\n\n File Handles\n\nFile handles (Handle) are abstract references to files that have been opened for reading and/or writing.\n  A file handle maintains a mode that determines whether reading and/or writing are allowed, along with a cursor that points at a specific location in the file.\n  Reading from or writing to a file handle advances the cursor.\n  File handles may be buffered, which means that reading from a file handle may not return the current contents of the persistent data, and writing to a file handle may not modify them immediately.\n\n Paths\n\nFiles are primarily accessed via paths (System.FilePath).\n  A path is a sequence of directory names, potentially terminated by a file name.\n  They are represented by strings in which separator characters The current platform's separator characters are listed in System.FilePath.pathSeparators. delimit the names.The details of paths are platform-specific.\n  Absolute paths begin in a root directory; some operating systems have a single root, while others may have multiple root directories.\n  Relative paths do not begin in a root directory and require that some other directory be taken as a starting point.\n  In addition to directories, paths may contain the special directory names ., which refers to the directory in which it is found, and .., which refers to prior directory in the path.Filenames, and thus paths, may end in one or more extensions that identify the file's type.\n  Extensions are delimited by the character System.FilePath.extSeparator.\n  On some platforms, executable files have a special extension (System.FilePath.exeExtension).\n\n Streams\n\nStreams are a higher-level abstraction over files, both providing additional functionality and hiding some details of files.\n  While file handles are essentially a thin wrapper around the operating system's representation, streams are implemented in Lean as a structure called IO.FS.Stream.\n  Because streams are implemented in Lean, user code can create additional streams, which can be used seamlessly together with those provided in the standard library.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.5. Files, File Handles, and Streams","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams"},"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices":{"contents":"Type constructors may take two kinds of arguments: parameters  and indices.\nParameters must be used consistently in the entire definition; all occurrences of the type constructor in each constructor in the declaration must take precisely the same argument.\nIndices may vary among the occurrences of the type constructor.\nAll parameters must precede all indices in the type constructor's signature.\n\nParameters that occur prior to the colon (':') in the type constructor's signature are considered parameters to the entire inductive type declaration.\nThey are always parameters that must be uniform throughout the type's definition.\nGenerally speaking, parameters that occur after the colon are indices that may vary throughout the definition of the type.\nHowever, if the option inductive.autoPromoteIndices is true, then syntactic indices that could have been parameters are made into parameters.\nAn index could have been a parameter if all of its type dependencies are themselves parameters and it is used uniformly as an uninstantiated variable in all occurrences of the inductive type's type constructor in all constructors.\n\nPromote indices to parameters in inductive types whenever possible.\n\nIndices can be seen as defining a family of types.\nEach choice of indices selects a type from the family, which has its own set of available constructors.\nType constructors with indices are said to specify indexed families  of types.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","header":"4.4.1.1. Parameters and Indices","id":"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Server":{"contents":"* #10365 implements the server-side for a new trace search mechanism in\nthe InfoView.* #10442 ensures that unknown identifier code actions are provided on\nauto-implicits.* #10524 adds support for interactivity to the combined \"try this\"\nmessages that were introduced in #9966. In doing so, it moves the link\nto apply a suggestion to a separate [apply] button in front of the\nsuggestion. Hints with diffs remain unchanged, as they did not\npreviously support interacting with terms in the diff, either.* #10538 fixes deadlocking exit calls in the language server.* #10584 causes Verso docstrings to search for a name in the environment\nthat is at least as long as the current name, providing it as a\nsuggestion.* #10609 fixes an LSP-non-compliance in the FileSystemWatcher that was\nintroduced in #925.* #10619 fixes a bug in the unknown identifier code actions where it\nwould yield non-sensical suggestions for nested open declarations like\nopen Foo.Bar.* #10660 adds auto-completion for identifiers after end. It also fixes\na bug where completion in the whitespace after set_option would not\nyield the full option list.* #10662 re-enables semantic tokens for Verso docstrings, after a prior\nchange accidentally disabled them. It also adds a test to prevent this\nfrom happening again.* #10738 fixes a regression introduced by #10307, where hovering the name\nof an inductive type or constructor in its own declaration didn't show\nthe docstring. In the process, a bug in docstring handling for\ncoinductive types was discovered and also fixed. Tests are added to\nprevent the regression from repeating in the future.* #10757 fixes a bug in combination with VS Code where Lean code that\nlooks like CSS color codes would display a color picker decoration.* #10797 fixes a bug in the unknown identifier code actions where the\nidentifiers wouldn't be correctly minimized in nested namespaces. It\nalso fixes a bug where identifiers would sometimes be minimized to\n[anonymous].\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Server","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Server"}});