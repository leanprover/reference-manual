window.docContents[147].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Queries":{"contents":"Counts the number of times an element occurs in an array.Examples:* #[1, 1, 2, 3, 5].count 1 = 2* #[1, 1, 2, 3, 5].count 5 = 1* #[1, 1, 2, 3, 5].count 4 = 0\n\nCounts the number of elements in the array as that satisfy the Boolean predicate p.Examples:* #[1, 2, 3, 4, 5].countP (· % 2 == 0) = 2* #[1, 2, 3, 4, 5].countP (· < 5) = 4* #[1, 2, 3, 4, 5].countP (· > 5) = 0\n\nReturns the index of the first element equal to a, or the size of the array if no element is equal\nto a.Examples:* #[\"carrot\", \"potato\", \"broccoli\"].idxOf \"carrot\" = 0* #[\"carrot\", \"potato\", \"broccoli\"].idxOf \"broccoli\" = 2* #[\"carrot\", \"potato\", \"broccoli\"].idxOf \"tomato\" = 3* #[\"carrot\", \"potato\", \"broccoli\"].idxOf \"anything else\" = 3\n\nReturns the index of the first element equal to a, or none if no element is equal to a.Examples:* #[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"carrot\" = some 0* #[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"broccoli\" = some 2* #[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"tomato\" = none* #[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"anything else\" = none\n\nReturns the index of the first element equal to a, or the size of the array if no element is equal\nto a. The index is returned as a Fin, which guarantees that it is in bounds.Examples:* #[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"carrot\" = some 0* #[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"broccoli\" = some 2* #[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"tomato\" = none* #[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"anything else\" = none\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.4. Queries","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Queries"},"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From--Nat":{"contents":"Converts an arbitrary-precision natural number to an unsigned word-sized integer, wrapping around on\noverflow.This function is overridden at runtime with an efficient implementation.\n\nConverts an arbitrary-precision natural number to a word-sized signed integer, wrapping around on\noverflow.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to an 8-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* UInt8.ofNat 5 = 5* UInt8.ofNat 255 = 255* UInt8.ofNat 256 = 0* UInt8.ofNat 259 = 3* UInt8.ofNat 32770 = 2\n\nConverts a natural number to an 8-bit signed integer, wrapping around on overflow.This function is overridden at runtime with an efficient implementation.Examples:* Int8.ofNat 53 = 53* Int8.ofNat 127 = 127* Int8.ofNat 128 = -128* Int8.ofNat 255 = -1\n\nConverts a natural number to a 16-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* UInt16.ofNat 5 = 5* UInt16.ofNat 255 = 255* UInt16.ofNat 32770 = 32770* UInt16.ofNat 65537 = 1\n\nConverts a natural number to a 16-bit signed integer, wrapping around on overflow.This function is overridden at runtime with an efficient implementation.Examples:* Int16.ofNat 127 = 127* Int16.ofNat 32767 = 32767* Int16.ofNat 32768 = -32768* Int16.ofNat 32770 = -32766\n\nConverts a natural number to a 32-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* UInt32.ofNat 5 = 5* UInt32.ofNat 65539 = 65539* UInt32.ofNat 4_294_967_299 = 3\n\nConverts a natural number to a 32-bit signed integer, wrapping around on overflow.This function is overridden at runtime with an efficient implementation.Examples:* Int32.ofNat 127 = 127* Int32.ofNat 32770 = 32770* Int32.ofNat 2_147_483_647 = 2_147_483_647* Int32.ofNat 2_147_483_648 = -2_147_483_648\n\nConverts a natural number to a 64-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* UInt64.ofNat 5 = 5* UInt64.ofNat 65539 = 65539* UInt64.ofNat 4_294_967_299 = 4_294_967_299* UInt64.ofNat 18_446_744_073_709_551_620 = 4\n\nConverts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.This function is overridden at runtime with an efficient implementation.Examples:* Int64.ofNat 127 = 127* Int64.ofNat 2_147_483_648 = 2_147_483_648* Int64.ofNat 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807* Int64.ofNat 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808* Int64.ofNat 18_446_744_073_709_551_618 = 0\n\nConverts a natural number to a USize. Overflow is impossible on any supported platform because\nUSize.size is either 2^32 or 2^64.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to a USize. Requires a proof that the number is small enough to be\nrepresentable without overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to an 8-bit unsigned integer. Requires a proof that the number is small\nenough to be representable without overflow; it must be smaller than 2^8.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to a 16-bit unsigned integer. Requires a proof that the number is small\nenough to be representable without overflow; it must be smaller than 2^16.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to a 32-bit unsigned integer. Requires a proof that the number is small\nenough to be representable without overflow; it must be smaller than 2^32.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to a 64-bit unsigned integer. Requires a proof that the number is small\nenough to be representable without overflow; it must be smaller than 2^64.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to USize, returning the largest representable value if the number is too\nlarge.Returns USize.size - 1, which is  2^64 - 1 or 2^32 - 1 depending on the platform, for natural\nnumbers greater than or equal to USize.size.\n\nConverts a natural number to an 8-bit unsigned integer, returning the largest representable value if\nthe number is too large.Returns 2^8 - 1 for natural numbers greater than or equal to 2^8.\n\nConverts a natural number to a 16-bit unsigned integer, returning the largest representable value if\nthe number is too large.Returns 2^16 - 1 for natural numbers greater than or equal to 2^16.\n\nConverts a natural number to a 32-bit unsigned integer, returning the largest representable value if\nthe number is too large.Returns 2^32 - 1 for natural numbers greater than or equal to 2^32.\n\nConverts a natural number to a 64-bit unsigned integer, returning the largest representable value if\nthe number is too large.Returns 2^64 - 1 for natural numbers greater than or equal to 2^64.\n\nConverts a word-sized unsigned integer to an arbitrary-precision natural number.This function is overridden at runtime with an efficient implementation.\n\nConverts a word-sized signed integer to a natural number, mapping all negative numbers to 0.Use ISize.toBitVec to obtain the two's complement representation.\n\nConverts an 8-bit unsigned integer to an arbitrary-precision natural number.This function is overridden at runtime with an efficient implementation.\n\nConverts an 8-bit signed integer to a natural number, mapping all negative numbers to 0.Use Int8.toBitVec to obtain the two's complement representation.\n\nConverts a 16-bit unsigned integer to an arbitrary-precision natural number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 16-bit signed integer to a natural number, mapping all negative numbers to 0.Use Int16.toBitVec to obtain the two's complement representation.\n\nConverts a 32-bit unsigned integer to an arbitrary-precision natural number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 32-bit signed integer to a natural number, mapping all negative numbers to 0.Use Int32.toBitVec to obtain the two's complement representation.\n\nConverts a 64-bit unsigned integer to an arbitrary-precision natural number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 64-bit signed integer to a natural number, mapping all negative numbers to 0.Use Int64.toBitVec to obtain the two's complement representation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","header":"19.4.4.3.2. To and From  Nat","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From--Nat"},"/Tactic-Proofs/Tactic-Reference/#simp-tactics":{"contents":"The simplifier is described in greater detail in its dedicated chapter.\n\nThe simp tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:* simp simplifies the main goal target using lemmas tagged with the attribute [simp].* simp [h₁, h₂, ..., hₙ] simplifies the main goal target using the lemmas tagged\nwith the attribute [simp] and the given hᵢ's, where the hᵢ's are expressions.-* If an hᵢ is a defined constant f, then f is unfolded. If f has equational lemmas associated\nwith it (and is not a projection or a reducible definition), these are used to rewrite with f.* simp [*] simplifies the main goal target using the lemmas tagged with the\nattribute [simp] and all hypotheses.* simp only [h₁, h₂, ..., hₙ] is like simp [h₁, h₂, ..., hₙ] but does not use [simp] lemmas.* simp [-id₁, ..., -idₙ] simplifies the main goal target using the lemmas tagged\nwith the attribute [simp], but removes the ones named idᵢ.* simp at h₁ h₂ ... hₙ simplifies the hypotheses h₁ : T₁ ... hₙ : Tₙ. If\nthe target or another hypothesis depends on hᵢ, a new simplified hypothesis\nhᵢ is introduced, but the old one remains in the local context.* simp at * simplifies all the hypotheses and the target.* simp [*] at * simplifies target and all (propositional) hypotheses using the\nother hypotheses.\n\nsimp! is shorthand for simp with autoUnfold := true.\nThis will unfold applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be used to partially evaluate many definitions.\n\nsimp? takes the same arguments as simp, but reports an equivalent call to simp only\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\nThis command can also be used in simp_all and dsimp.\n\nsimp? takes the same arguments as simp, but reports an equivalent call to simp only\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\nThis command can also be used in simp_all and dsimp.\n\nsimp_arith has been deprecated. It was a shorthand for simp +arith +decide.\nNote that +decide is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n\nsimp_arith! has been deprecated. It was a shorthand for simp! +arith +decide.\nNote that +decide is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n\nThe dsimp tactic is the definitional simplifier. It is similar to simp but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n\ndsimp! is shorthand for dsimp with autoUnfold := true.\nThis will unfold applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be used to partially evaluate many definitions.\n\nsimp? takes the same arguments as simp, but reports an equivalent call to simp only\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\nThis command can also be used in simp_all and dsimp.\n\nsimp? takes the same arguments as simp, but reports an equivalent call to simp only\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\nThis command can also be used in simp_all and dsimp.\n\nsimp_all is a stronger version of simp [*] at * where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n\nsimp_all! is shorthand for simp_all with autoUnfold := true.\nThis will unfold applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be used to partially evaluate many definitions.\n\nsimp? takes the same arguments as simp, but reports an equivalent call to simp only\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\nThis command can also be used in simp_all and dsimp.\n\nsimp? takes the same arguments as simp, but reports an equivalent call to simp only\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\nThis command can also be used in simp_all and dsimp.\n\nsimp_all_arith has been deprecated. It was a shorthand for simp_all +arith +decide.\nNote that +decide is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n\nsimp_all_arith! has been deprecated. It was a shorthand for simp_all! +arith +decide.\nNote that +decide is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n\nThis is a \"finishing\" tactic modification of simp. It has two forms.* simpa [rules, ⋯] using e will simplify the goal and the type of\ne using rules, then try to close the goal using e.Simplifying the type of e makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.* simpa [rules, ⋯] will simplify the goal and the type of a\nhypothesis this if present in the context, then try to close the goal using\nthe assumption tactic.\n\nThis is a \"finishing\" tactic modification of simp. It has two forms.* simpa [rules, ⋯] using e will simplify the goal and the type of\ne using rules, then try to close the goal using e.Simplifying the type of e makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.* simpa [rules, ⋯] will simplify the goal and the type of a\nhypothesis this if present in the context, then try to close the goal using\nthe assumption tactic.\n\nThis is a \"finishing\" tactic modification of simp. It has two forms.* simpa [rules, ⋯] using e will simplify the goal and the type of\ne using rules, then try to close the goal using e.Simplifying the type of e makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.* simpa [rules, ⋯] will simplify the goal and the type of a\nhypothesis this if present in the context, then try to close the goal using\nthe assumption tactic.\n\nThis is a \"finishing\" tactic modification of simp. It has two forms.* simpa [rules, ⋯] using e will simplify the goal and the type of\ne using rules, then try to close the goal using e.Simplifying the type of e makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.* simpa [rules, ⋯] will simplify the goal and the type of a\nhypothesis this if present in the context, then try to close the goal using\nthe assumption tactic.\n\nUnfold definitions commonly used in well founded relation definitions.Since Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to simp_wf can be removed or replaced\nby plain calls to simp.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.12. Simplification","id":"/Tactic-Proofs/Tactic-Reference/#simp-tactics"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Library-Highlights":{"contents":"#8004 adds extensional hash maps and hash sets under the names\nStd.ExtDHashMap, Std.ExtHashMap and Std.ExtHashSet. Extensional\nhash maps work like regular hash maps, except that they have\nextensionality lemmas which make them easier to use in proofs. This\nhowever makes it also impossible to regularly iterate over its entries.\n\nOther notable library developments in this release include:\n\n* Updates to the Option API,* Async runtime developments: added support for multiplexing via UDP and TCP sockets, as well as channels,* New BitVec definitions related to overflow handling,* New lemmas for Nat.lcm, and Int variants for Nat.gcd and Nat.lcm,* Upstreams from Mathlib related to Nat and Int,* Additions to numeric types APIs, such as UIntX.ofInt, Fin.ofNat'_mul and Fin.mul_ofNat', Int.toNat_sub'',* Updates to Perm API in Array, List, and added support for Vector,* Additional lemmas for Array/List/Vector.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)\u0009Highlights","header":"Library Highlights","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Library-Highlights"},"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Language-server-and-IDE-extensions":{"contents":"* #3602 enables import auto-completions.* #3608 fixes issue leanprover/vscode-lean4#392.\nDiagnostic ranges had an off-by-one error that would misplace goal states for example.* #3014 introduces snapshot trees, foundational work for incremental tactics and parallelism.\n#3849 adds basic incrementality API.* #3271 adds support for server-to-client requests.* #3656 fixes jump to definition when there are conflicting names from different files.\nFixes issue #1170.* #3691, #3925,\n#3932 keep semantic tokens synchronized (used for semantic highlighting), with performance improvements.* #3247 and #3730\nadd diagnostics to run \"Restart File\" when a file dependency is saved.* #3722 uses the correct module names when displaying references.* #3728 makes errors in header reliably appear and makes the \"Import out of date\" warning be at \"hint\" severity.\n#3739 simplifies the text of this warning.* #3778 fixes #3462,\nwhere info nodes from before the cursor would be used for computing completions.* #3985 makes trace timings appear in Infoview.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.8.0 (2024-06-05)","header":"Language server and IDE extensions","id":"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Language-server-and-IDE-extensions"}});