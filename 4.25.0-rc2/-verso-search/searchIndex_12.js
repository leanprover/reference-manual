window.docContents[12].resolve({"/Basic-Propositions/#basic-props":{"contents":"With the exception of implication and universal quantification, logical connectives and quantifiers are implemented as inductive types in the Prop universe.\nIn some sense, the connectives described in this chapter are not special—they could be implemented by any user.\nHowever, these basic connectives are used pervasively in the standard library and built-in proof automation tools.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"18. Basic Propositions","id":"/Basic-Propositions/#basic-props"},"/Coercions/Coercing-to-Function-Types/#fun-coercion":{"contents":"Another situation where an expected type is not generally available is the function position in a function application term.\nDependent function types are common; together with implicit parameters, they cause information to flow from the elaboration of one argument to the elaboration of the others.\nAttempting to deduce the type required for the function from the expected type of the entire application term and individually-inferred types of arguments will often fail.\nIn these situations, Lean uses the CoeFun type class to coerce a non-function in an application position into a function.\nLike CoeSort, CoeFun instances do not chain with other coercions while inserting a function coercion, but they can be used as CoeOut instances during ordinary coercion insertion.\n\nThe second parameter to CoeFun is an output parameter that determines the resulting function type.\nThis output parameter is function that computes the function type from the term that's being coerced, rather than the function type itself.\nUnlike CoeDep, the term itself is not taken into account during instance synthesis; it can, however, be used to create dependently typed coercions where the function type is determined by the term.\n\nCoeFun α (γ : α → Sort v) is a coercion to a function. γ a should be a\n(coercion-to-)function type, and this is triggered whenever an element\nf : α appears in an application like f x, which would not make sense since\nf does not have a function type.\nCoeFun instances apply to CoeOut as well.Coerces a value f : α to type γ f, which should be either be a\nfunction type or another CoeFun type, in order to resolve a mistyped\napplication f x.\n\nExplicit Coercion to Functions\n\n\n\nCoercing Decorated Functions to Function TypesThe structure NamedFun α β pairs a function from α to β with a name.structure NamedFun (α : Type u) (β : Type v) where\n  function : α → β\n  name : String\nExisting functions can be named:def succ : NamedFun Nat Nat where\n  function n := n + 1\n  name := \"succ\"\n\ndef asString [ToString α] : NamedFun α String where\n  function := ToString.toString\n  name := \"asString\"\n\ndef append : NamedFun (List α) (List α → List α) where\n  function := (· ++ ·)\n  name := \"append\"\nNamed functions can also be composed:def NamedFun.comp\n    (f : NamedFun β γ)\n    (g : NamedFun α β) :\n    NamedFun α γ where\n  function := f.function ∘ g.function\n  name := f.name ++ \" ∘ \" ++ g.name\nUnlike ordinary functions, named functions have a reasonable representation as a string:instance : ToString (NamedFun α α'') where\n  toString f := s!\"#<{f.name}>\"\n#eval asString.comp succ\n#<asString ∘ succ>\nA CoeFun instance allows them to be applied just like ordinary functions:instance : CoeFun (NamedFun α α'') (fun _ => α → α'') where\n  coe | ⟨f, _⟩ => f\n#eval append [1, 2, 3] [4, 5, 6]\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nDependent Coercion to FunctionsSometimes, the type of the resulting function depends on the specific value that is being coerced.\nA Writer represents a means of appending a representation of some value to a string:structure Writer where\n  Writes : Type u\n  write : Writes → String → String\n\ndef natWriter : Writer where\n  Writes := Nat\n  write n out := out ++ toString n\n\ndef stringWriter : Writer where\n  Writes := String\n  write s out := out ++ s\nBecause the type of the parameter expected by the inner function depend on the Writer.Writes field, the CoeFun instance extracts the field:instance :\n    CoeFun Writer (·.Writes → String → String) where\n  coe w := w.write\nWith this instance, concrete Writers can be used as functions:#eval \"\" |> natWriter (5 : Nat) |> stringWriter \" hello\"\n\"5 hello\"\n\n\nCoercing to Function TypesA well-typed interpreter is an interpreter for a programming language that uses indexed families to rule out run-time type errors.\nFunctions written in the interpreted language can be interpreted as Lean functions, but their underlying source code can also be inspected.The first step in the well-typed interpreter is to select the subset of Lean types that can be used.\nThese types are represented by an inductive type of codes Ty and a function that maps these codes to actual types.inductive Ty where\n  | nat\n  | arr (dom cod : Ty)\n\nabbrev Ty.interp : Ty → Type\n  | .nat => Nat\n  | .arr t t' => t.interp → t'.interp\nThe language itself is represented by an indexed family over variable contexts and result types.\nVariables are represented by de Bruijn indices.inductive Tm : List Ty → Ty → Type where\n  | zero : Tm Γ .nat\n  | succ (n : Tm Γ .nat) : Tm Γ .nat\n  | rep (n : Tm Γ .nat)\n    (start : Tm Γ t)\n    (f : Tm Γ (.arr .nat (.arr t t))) :\n    Tm Γ t\n  | lam (body : Tm (t :: Γ) t') : Tm Γ (.arr t t')\n  | app (f : Tm Γ (.arr t t')) (arg : Tm Γ t) : Tm Γ t'\n  | var (i : Fin Γ.length) : Tm Γ Γ[i]\nderiving Repr\nBecause the OfNat instance for Fin requires that the upper bound be non-zero, Tm.var can be inconvenient to use with numeric literals.\nThe helper Tm.v can be used to avoid the need for type annotations in these cases.def Tm.v\n    (i : Fin (Γ.length + 1)) :\n    Tm (t :: Γ) (t :: Γ)[i] :=\n  .var (Γ := t :: Γ) i\nA function that adds two natural numbers uses the rep operation to apply the successor Tm.succ repeatedly.def plus : Tm [] (.arr .nat (.arr .nat .nat)) :=\n  .lam <| .lam <| .rep (.v 1) (.v 0) (.lam (.lam (.succ (.v 0))))\nEach typing context can be interpreted as a type of run-time environments that provide a value for each variable in the context:def Env : List Ty → Type\n  | [] => Unit\n  | t :: Γ => t.interp × Env Γ\n\ndef Env.empty : Env [] := ()\n\ndef Env.extend (ρ : Env Γ) (v : t.interp) : Env (t :: Γ) :=\n  (v, ρ)\n\ndef Env.get (i : Fin Γ.length) (ρ : Env Γ) : Γ[i].interp :=\n  match Γ, ρ, i with\n  | _::_, (v, _), ⟨0, _⟩ => v\n  | _::_, (_, ρ'), ⟨i+1, _⟩ => ρ'.get ⟨i, by simp_all⟩\nFinally, the interpreter is a recursive function over the term:def Tm.interp (ρ : Env α'') : Tm α'' t → t.interp\n  | .zero => 0\n  | .succ n => n.interp ρ + 1\n  | .rep n start f =>\n    let f' := f.interp ρ\n    (n.interp ρ).fold (fun n _ x => f' n x) (start.interp ρ)\n  | .lam body => fun x => body.interp (ρ.extend x)\n  | .app f arg => f.interp ρ (arg.interp ρ)\n  | .var i => ρ.get i\nCoercing a Tm to a function consists of calling the interpreter.instance : CoeFun (Tm [] α'') (fun _ => α''.interp) where\n  coe f := f.interp .empty\nBecause functions are represented by a first-order inductive type, their code can be inspected:#eval plus\nTm.lam (Tm.lam (Tm.rep (Tm.var 1) (Tm.var 0) (Tm.lam (Tm.lam (Tm.succ (Tm.var 0))))))\nAt the same time, due to the coercion, they can be applied just like native Lean functions:#eval plus 3 5\n8\n\n\n","context":"Lean Reference\u0009Coercions","header":"12.4. Coercing to Function Types","id":"/Coercions/Coercing-to-Function-Types/#fun-coercion"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Streams":{"contents":"A pure-Lean abstraction of POSIX streams. These streams may represent an underlying POSIX stream or\nbe implemented by Lean code.Because standard input, standard output, and standard error are all IO.FS.Streams that can be\noverridden, Lean code may capture and redirect input and output.Flushes the stream's output buffers.Reads up to the given number of bytes from the stream.If the returned array is empty, an end-of-file marker (EOF) has been reached. An EOF does not\nactually close a stream, so further reads may block and return more data.Writes the provided bytes to the stream.If the stream represents a physical output device such as a file on disk, then the results may be\nbuffered. Call FS.Stream.flush to synchronize their contents.Reads text up to and including the next newline from the stream.If the returned string is empty, an end-of-file marker (EOF) has been reached.\nAn EOF does not actually close a stream, so further reads may block and return more data.Writes the provided string to the stream.Returns true if a stream refers to a Windows console or Unix terminal.\n\nCreates a stream from a mutable reference to a buffer.The resulting stream simulates a file, mutating the contents of the reference in response to writes\nand reading from it in response to reads. These streams can be used with IO.withStdin,\nIO.setStdin, and the corresponding operators for standard output and standard error to redirect\ninput and output.\n\nCreates a Lean stream from a file handle. Each stream operation is implemented by the corresponding\nfile handle operation.\n\nWrites the contents of the string to the stream, followed by a newline.\n\nA byte buffer that can simulate a file in memory.Use IO.FS.Stream.ofBuffer to create a stream from a buffer.The contents of the buffer.The read/write cursor's position in the buffer.\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.2. Streams","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Streams"},"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Starting-and-Stopping-the-Proof-Mode":{"contents":"Start the stateful proof mode of Std.Do.SPred.\nThis will transform a stateful goal of the form H ⊢ₛ T into ⊢ₛ H → T\nupon which mintro can be used to re-introduce H and give it a name.\nIt is often more convenient to use mintro directly, which will\ntry mstart automatically if necessary.\n\nStops the stateful proof mode of Std.Do.SPred.\nThis will simply forget all the names given to stateful hypotheses and pretty-print\na bit differently.\n\nLeaves the stateful proof mode of Std.Do.SPred, tries to eta-expand through all definitions\nrelated to the logic of the Std.Do.SPred and gently simplifies the resulting pure Lean\nproposition. This is often the right thing to do after mvcgen in order for automation to prove\nthe goal.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Verification Condition Generation\u0009Tactics for Stateful Goals in  Std.Do.SPred","header":"13.5.23.1.1. Starting and Stopping the Proof Mode","id":"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Starting-and-Stopping-the-Proof-Mode"},"/releases/#release-notes":{"contents":"This section provides release notes about recent versions of Lean. When updating to a new version, please\nread the corresponding release notes. They may contain advice that will help you understand\nthe differences with the previous version and upgrade your projects.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"Release Notes","id":"/releases/#release-notes"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Metaprogramming-notes":{"contents":"* #10306 fixes a few bugs in the rw tactic.Metaprogramming API: Instead of Lean.MVarId.rewrite prefer Lean.Elab.Tactic.elabRewrite\nfor elaborating rewrite theorems and applying rewrites to expressions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)\u0009Highlights","header":"Metaprogramming notes","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Metaprogramming-notes"}});