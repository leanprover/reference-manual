window.docContents[130].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Iteration":{"contents":"Updates the values of the map by applying the given function to all mappings.\n\nFolds the given function over the mappings in the map in ascending order.\n\nFolds the given monadic function over the mappings in the map in ascending order.\n\nSupport for the for loop construct in do blocks. Iteration happens in ascending order.\n\nCarries out a monadic action on each mapping in the tree map in ascending order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"19.18.9.5. Iteration","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Iteration"},"/Basic-Types/Natural-Numbers/#nat-api-bitwise":{"contents":"Shifts the binary representation of a value left by the specified number of bits. Usually accessed\nvia the <<< operator.Examples:* 1 <<< 2 = 4* 1 <<< 3 = 8* 0 <<< 3 = 0* 0xf1 <<< 4 = 0xf10\n\nShifts the binary representation of a value right by the specified number of bits. Usually accessed\nvia the >>> operator.Examples:* 4 >>> 2 = 1* 8 >>> 2 = 2* 8 >>> 3 = 1* 0 >>> 3 = 0* 0xf13a >>> 8 = 0xf1\n\nBitwise exclusive or. Usually accessed via the ^^^ operator.Each bit of the resulting value is set if the corresponding bit is set in exactly one of the inputs.\n\nBitwise or. Usually accessed via the ||| operator.Each bit of the resulting value is set if the corresponding bit is set in at least one of the inputs.\n\nBitwise and. Usually accessed via the &&& operator.Each bit of the resulting value is set if the corresponding bit is set in both of the inputs.\n\nA helper for implementing bitwise operators on Nat.Each bit of the resulting Nat is the result of applying f to the corresponding bits of the input\nNats, up to the position of the highest set bit in either input.\n\nReturns true if the (n+1)th least significant bit is 1, or false if it is 0.\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Arithmetic","header":"19.1.4.1.1. Bitwise Operations","id":"/Basic-Types/Natural-Numbers/#nat-api-bitwise"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Dependencies":{"contents":"Dependencies are specified in the [[require]] field array of a package configuration, which specifies both the name and the source of each package.\nThere are three kinds of sources:\n\n* Reservoir, or an alternative package registry* Git repositories, which may be local paths or URLs* Local paths\n\nA Dependency of a package.\nIt specifies a package which another package depends on.\nThis encodes the information contained in the require DSL syntax.The path and git fields specify an explicit source for a dependency.\nIf neither are provided, then the dependency is fetched from Reservoir, or an alternative registry if one has been configured.\nThe scope field is required when fetching a package from Reservoir.A dependency on the local filesystem, specified by its path.A dependency in a Git repository, specified either by its URL as a string or by a table with the keys:* url: the repository URL* subDir: the subdirectory of the Git repository that contains the package's source codeFor Git or Reservoir dependencies, this field specifies the Git revision, which may be a branch name, a tag name, or a specific hash.\nOn Reservoir, the version field takes precedence over this field.A dependency source, specified as a self-contained table, which is used when neither the git nor the path key is present.\nThe key type should be either the string \"git\" or the string \"path\".\nIf the type is \"path\", then there must be a further key \"path\" whose value is a string that provides the location of the package on disk.\nIf the type is \"git\", then the following keys should be present:* url: the repository URL* rev: the Git revision, which may be a branch name, a tag name, or a specific hash (optional)* subDir: the subdirectory of the Git repository that contains the package's source codeThe target version of the dependency.\nA Git revision can be specified with the syntax git#<rev>.The package name of the dependency.\nThis name must match the one declared in its configuration file,\nas that name is used to index its target data types. For this reason,\nthe package name must also be unique across packages in the dependency graph.An additional qualifier used to distinguish packages of the same\nname in a Lake registry. On Reservoir, this is the package owner.\n\nRequiring Packages from ReservoirThe package example can be required from Reservoir using this TOML configuration:[[require]]\nname = \"example\"\nversion = \"2.12\"\nscope = \"exampleDev\"\n\n\nRequiring Packages from GitThe package example can be required from a Git repository using this TOML configuration:[[require]]\nname = \"example\"\ngit = \"https://git.example.com/example.git\"\nrev = \"main\"\nversion = \"2.12\"\nIn particular, the package will be checked out from the main branch, and the version number specified in the package's configuration should match 2.12.\n\nRequiring Packages from a Git tagThe package example can be required from the tag v2.12 in a Git repository using this TOML configuration:[[require]]\nname = \"example\"\ngit = \"https://git.example.com/example.git\"\nrev = \"v2.12\"\nThe version number specified in the package's configuration is not used.\n\nRequiring Reservoir Packages from a Git tagThe package example, found using Reservoir, can be required from the tag v2.12 in its Git repository using this TOML configuration:[[require]]\nname = \"example\"\nrev = \"v2.12\"\nscope = \"exampleDev\"\nThe version number specified in the package's configuration is not used.\n\nRequiring Packages from PathsThe package example can be required from the local path ../example using this TOML configuration:[[require]]\nname = \"example\"\npath = \"../example\"\nDependencies on local paths are useful when developing multiple packages in a single repository, or when testing whether a change to a dependency fixes a bug in a downstream package.\n\nSources as TablesThe information about the package source can be written in an explicit table.[[require]]\nname = \"example\"\nsource = {type = \"git\", url = \"https://example.com/example.git\"}\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Declarative TOML Format","header":"22.1.3.1.2. Dependencies","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Dependencies"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-transformers":{"contents":"A monad transformer is a function that, when provided with a monad, gives back a new monad.\nTypically, this new monad has all the effects of the original monad along with some additional ones.\n\n\n\nA monad transformer consists of the following:\n\n* A function T that constructs the new monad's type from an existing monad* A run function that adapts a T m α into some variant of m, often requiring additional parameters and returning a more specific type under m* An instance of [Monad m] → Monad (T m) that allows the transformed monad to be used as a monad* An instance of MonadLift that allows the original monad's code to be used in the transformed monad* If possible, an instance of MonadControl m (T m) that allows actions from the transformed monad to be used in the original monad\n\nTypically, a monad transformer also provides instances of one or more type classes that describe the effects that it introduces.\nThe transformer's Monad and MonadLift instances make it practical to write code in the transformed monad, while the type class instances allow the transformed monad to be used with polymorphic functions.\n\nThe Identity Monad Transformer The identity monad transformer neither adds nor removes capabilities to the transformed monad.\nIts definition is the identity function, suitably specialized:def IdT (m : Type u → Type v) : Type u → Type v := m\nSimilarly, the run function requires no additional arguments and just returns an m α:def IdT.run (act : IdT m α) : m α := act\nThe monad instance relies on the monad instance for the transformed monad, selecting it via type ascriptions:instance [Monad m] : Monad (IdT m) where\n  pure x := (pure x : m _)\n  bind x f := (x >>= f : m _)\nBecause IdT m is definitionally equal to m, the MonadLift m (IdT m) instance doesn't need to modify the action being lifted:instance : MonadLift m (IdT m) where\n  monadLift x := x\nThe MonadControl instance is similarly simple.instance [Monad m] : MonadControl m (IdT m) where\n  stM α := α\n  liftWith f := f (fun x => Id.run <| pure x)\n  restoreM v := v\n\n\nThe Lean standard library provides transformer versions of many different monads, including ReaderT, ExceptT, and StateT, along with variants using other representations such as StateCpsT, StateRefT, and ExceptCpsT.\nAdditionally, the EStateM monad is equivalent to combining ExceptT and StateT, but it can use a more specialized representation to improve performance.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.2. Monad Transformers","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-transformers"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-requirements":{"contents":"The inductive types declared in a mutual block are considered as a group; they must collectively satisfy generalized versions of the well-formedness criteria for non-mutually-recursive inductive types.\nThis is true even if they could be defined without the mutual block, because they are not in fact mutually recursive.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","header":"4.4.5.1. Requirements","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-requirements"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Documentation":{"contents":"* #6450 adds a docstring to the @[app_delab] attribute.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Documentation","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Documentation"}});