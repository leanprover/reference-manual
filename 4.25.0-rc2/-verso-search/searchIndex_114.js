window.docContents[114].resolve({"/Basic-Types/Maps-and-Sets/#ExtHashSet":{"contents":"Hash sets.This is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash set is used linearly to\navoid expensive copies.The hash set uses == (provided by the BEq typeclass) to compare elements and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.In contrast to regular hash sets, Std.ExtHashSet offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over hash sets.These hash sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.HashSet.Raw and\nStd.HashSet.Raw.WF unbundle the invariant from the hash set. When in doubt, prefer\nHashSet or ExtHashSet over HashSet.Raw.Internal implementation detail of the hash set.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.18.7. Extensional Hash Sets","id":"/Basic-Types/Maps-and-Sets/#ExtHashSet"},"/Source-Files-and-Modules/#module-encoding":{"contents":"Lean modules are Unicode text files encoded in UTF-8. \nLines may end either with newline characters (\"\\n\", Unicode 'LINE FEED (LF)' (U+000A)) or with a form feed and newline sequence (\"\\r\\n\", Unicode 'CARRIAGE RETURN (CR)' (U+000D) followed by 'LINE FEED (LF)' (U+000A)).\nHowever, Lean normalizes line endings when parsing or comparing files, so all files are compared as if all their line endings are \"\\n\".\n\n\n\n","context":"Lean Reference\u0009Source Files and Modules","header":"5.1. Encoding and Representation","id":"/Source-Files-and-Modules/#module-encoding"},"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#NoNatZeroDivisors":{"contents":"The class NoNatZeroDivisors is used to control coefficient growth.\nFor example, the polynomial 2 * x * y + 4 * z = 0 is simplified to x * y + 2 * z = 0.\nIt also used when processing disequalities.\n\nUsing NoNatZeroDivisorsIn this example, grind relies on the NoNatZeroDivisors instance to simplify the goal:example [CommRing α] [NoNatZeroDivisors α] (a b : α) :\n    2 * a + 2 * b = 0 →\n    b ≠ -a → False := by\n  grind\nWithout it, the proof fails:example [CommRing α] (a b : α) :\n    2 * a + 2 * b = 0 →\n    b ≠ -a → False := by\n  grind\n`grind` failed\ncase grind\nα : Type u_1\ninst : CommRing α\na b : α\nh : 2 * a + 2 * b = 0\nh_1 : ¬b = -a\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] False propositions\n  [eqc] Equivalence classes\n  [ring] Ring `α`\n\n\nWe say a module has no natural number zero divisors if\nk ≠ 0 and k * a = k * b implies a = b (here k is a natural number and a and b are element of the module).For a module over the integers this is equivalent to\nk ≠ 0 and k * a = 0 implies a = 0.\n(See the alternative constructor NoNatZeroDivisors.mk',\nand the theorem eq_zero_of_mul_eq_zero.)If k * a ≠ k * b then k ≠ 0 or a ≠ b.\n\nAlternative constructor for NoNatZeroDivisors when we have an IntModule.\n\nThe ring module also performs case-analysis for terms a⁻¹ on whether a is zero or not.\nIn the following example, if 2*a is zero, then a is also zero since\nwe have NoNatZeroDivisors α, and all terms are zero and the equality hold. Otherwise,\nring adds the equalities a*a⁻¹ = 1 and 2*a*(2*a)⁻¹ = 1, and closes the goal.\n\nexample [Field α] [NoNatZeroDivisors α] (a : α) :\n    1 / a + 1 / (2 * a) = 3 / (2 * a) := by\n  grind\n\n\nWithout NoNatZeroDivisors, grind will perform case splits on numerals being zero as needed:\n\nexample [Field α] (a : α) : (2 * a)⁻¹ = a⁻¹ / 2 := by grind\n\n\nIn the following example, ring does not need to perform any case split because\nthe goal contains the disequalities y ≠ 0 and w ≠ 0.\n\nexample [Field α] {x y z w : α} :\n    x / y = z / w →\n    y ≠ 0 → w ≠ 0 →\n    x * w = z * y := by\n  grind (splits := 0)\n\n\nYou can disable the ring solver using the option grind -ring.\n\nexample [CommRing α] (x y : α) :\n    x ^ 2 * y = 1 →\n    x * y ^ 2 = y →\n    y * x = 1 := by\n  grind -ring\n\n\n`grind` failed\ncase grind\nα : Type u_1\ninst : CommRing α\nx y : α\nh : x ^ 2 * y = 1\nh_1 : x * y ^ 2 = y\nh_2 : ¬y * x = 1\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] False propositions\n  [eqc] Equivalence classes\n  [linarith] Linarith assignment for `α`\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Algebraic Solver (Commutative Rings, Fields)\u0009Solver Type Classes","header":"17.8.1.3. Natural Number Zero Divisors","id":"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#NoNatZeroDivisors"}});