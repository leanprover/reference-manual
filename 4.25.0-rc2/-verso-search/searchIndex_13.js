window.docContents[13].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic--Unsigned-Operations":{"contents":"Unsigned division of bitvectors using the Lean convention where division by zero returns zero.\nUsually accessed via the / operator.\n\nUnsigned division of bitvectors using the\nSMT-LIB convention,\nwhere division by zero returns BitVector.allOnes n.SMT-LIB name: bvudiv.\n\nUnsigned modulo for bitvectors. Usually accessed via the % operator.SMT-LIB name: bvurem.\n\nChecks whether addition of x and y results in unsigned overflow.SMT-LIB name: bvuaddo.\n\nChecks whether subtraction of x and y results in unsigned overflow.SMT-Lib name: bvusubo.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference\u0009Arithmetic","header":"19.5.5.8.1. Unsigned Operations","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic--Unsigned-Operations"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Modification":{"contents":"Adds an element to the end of an array. The resulting array's size is one greater than the input\narray. If there are no other references to the array, then it is modified in-place.This takes amortized O(1) time because ByteArray is represented by a dynamic array.\n\nReplaces the byte at the given index.No bounds check is performed, but the function requires a proof that the index is in bounds. This\nproof can usually be omitted, and will be synthesized automatically.The array is modified in-place if there are no other references to it.\n\nReplaces the byte at the given index.No bounds check is performed, but the function requires a proof that the index is in bounds. This\nproof can usually be omitted, and will be synthesized automatically.The array is modified in-place if there are no other references to it.\n\nReplaces the byte at the given index.The array is modified in-place if there are no other references to it.If the index is out of bounds, the array is returned unmodified.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.5. Modification","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Modification"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Unbundled-Variants":{"contents":"Unbundled maps separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the modules Std.HashMap.Raw and Std.HashMap.RawLemmas.\n\nHash maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer HashMap\nover HashMap.Raw. Lemmas about the operations on Std.Data.HashMap.Raw are available in the\nmodule Std.Data.HashMap.RawLemmas.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.Dependent hash maps, in which keys may occur in their values' types, are available as\nStd.Data.Raw.DHashMap.Internal implementation detail of the hash map\n\nWell-formedness predicate for hash maps. Users of HashMap will not need to interact with this.\nUsers of HashMap.Raw will need to provide proofs of WF to lemmas and should use lemmas\nWF.empty and WF.insert (which are always named exactly like the operations they are about) to\nshow that map operations preserve well-formedness.Internal implementation detail of the hash map\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","header":"19.18.2.7. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Unbundled-Variants"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Configuration-Files":{"contents":"\n\nTranslates the loaded package's configuration into another of Lake's supported configuration languages (i.e., either lean or toml).\nThe produced file is written to out-file or, if not provided, the path of the configuration file with the new language's extension.\nIf the output file already exists, Lake will error.Translation is lossy.\nIt does not preserve comments or formatting and non-declarative configuration is discarded.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"22.1.2.11. Configuration Files","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Configuration-Files"}});