window.docContents[81].resolve({"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Recursion-Helpers":{"contents":"“Attaches” a proof that an optional value, if present, is indeed this value, returning a subtype\nthat expresses this fact.This function is primarily used to allow definitions by well-founded recursion that use iteration\noperators (such as Option.map) to prove that an optional value drawn from a parameter is smaller\nthan the parameter. This allows the well-founded recursion mechanism to prove that the function\nterminates.\n\n“Attaches” a proof that some predicate holds for an optional value, if present, returning a subtype\nthat expresses this fact.This function is primarily used to implement Option.attach, which allows definitions by\nwell-founded recursion that use iteration operators (such as Option.map) to prove that an optional\nvalue drawn from a parameter is smaller than the parameter. This allows the well-founded recursion\nmechanism to prove that the function terminates.\n\nRemove an attached proof that the value in an Option is indeed that value.This function is usually inserted automatically by Lean, rather than explicitly in code. It is\nintroduced as an intermediate step during the elaboration of definitions by well-founded recursion.If this function is encountered in a proof state, the right approach is usually the tactic\nsimp [Option.unattach, -Option.map_subtype].It is a synonym for Option.map Subtype.val.\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.6. Recursion Helpers","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Recursion-Helpers"},"/IO/Tasks-and-Threads/#concurrency":{"contents":"Tasks are the fundamental primitive for writing multi-threaded code.\nA Task α represents a computation that, at some point, will resolve to a value of type α; it may be computed on a separate thread.\nWhen a task has resolved, its value can be read; attempting to get the value of a task before it resolves causes the current thread to block until the task has resolved.\nTasks are similar to promises in JavaScript, JoinHandle in Rust, and Future in Scala.Tasks may either carry out pure computations or IO actions.\nThe API of pure tasks resembles that of thunks: Task.spawn creates a Task α from a function in Unit → α, and Task.get waits until the function's value has been computed and then returns it.\nThe value is cached, so subsequent requests do not need to recompute it.\nThe key difference lies in when the computation occurs: while the values of thunks are not computed until they are forced, tasks execute opportunistically in a separate thread.Tasks in IO are created using IO.asTask.\nSimilarly, BaseIO.asTask and EIO.asTask create tasks in other IO monads.\nThese tasks may have side effects, and can communicate with other tasks.\n\nWhen the last reference to a task is dropped it is cancelled.\nPure tasks created with Task.spawn are terminated upon cancellation.\nTasks spawned with IO.asTask, EIO.asTask, or BaseIO.asTask continue executing and must explicitly check for cancellation using IO.checkCanceled.\nTasks may be explicitly cancelled using IO.cancel.\n\nThe Lean runtime maintains a thread pool for running tasks.\nThe size of the thread pool is determined by the environment variable LEAN_NUM_THREADS if it is set, or by the number of logical processors on the current machine otherwise.\nThe size of the thread pool is not a hard limit; in certain situations it may be exceeded to avoid deadlocks.\nBy default, these threads are used to run tasks; each task has a priority (Task.Priority), and higher-priority tasks take precedence over lower-priority tasks.\nTasks may also be assigned to dedicated threads by spawning them with a sufficiently high priority.\n\nTask α is a primitive for asynchronous computation.\nIt represents a computation that will resolve to a value of type α,\npossibly being computed on another thread. This is similar to Future in Scala,\nPromise in Javascript, and JoinHandle in Rust.The tasks have an overridden representation in the runtime.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.11. Tasks and Threads","id":"/IO/Tasks-and-Threads/#concurrency"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-mvcgen":{"contents":"mvcgen will break down a Hoare triple proof goal like ⦃P⦄ prog ⦃Q⦄ into verification conditions,\nprovided that all functions used in prog have specifications registered with @[spec].Verification Conditions and specificationsA verification condition is an entailment in the stateful logic of Std.Do.SPred\nin which the original program prog no longer occurs.\nVerification conditions are introduced by the mspec tactic; see the mspec tactic for what they\nlook like.\nWhen there's no applicable mspec spec, mvcgen will try and rewrite an application\nprog = f a b c with the simp set registered via @[spec].FeaturesWhen used like mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat], mvcgen will additionally* add a Hoare triple specification foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄ to spec set for a\nfunction foo occurring in prog,* unfold a definition def bar_def ... := ... in prog,* unfold any method of the instBEqFloat : BEq Float instance in prog.* it will no longer substitute away let-expressions that occur at most once in P, Q or prog.Config options+noLetElim is just one config option of many. Check out Lean.Elab.Tactic.Do.VCGen.Config for all\noptions. Of particular note is stepLimit = some 42, which is useful for bisecting bugs in\nmvcgen and tracing its execution.Extended syntaxOften, mvcgen will be used like this:mvcgen [...]\ncase inv1 => by exact I1\ncase inv2 => by exact I2\nall_goals (mleave; try grind)\nThere is special syntax for this:mvcgen [...] invariants\n· I1\n· I2\nwith grind\nWhen I1 and I2 need to refer to inaccessibles (mvcgen will introduce a lot of them for program\nvariables), you can use case label syntax:mvcgen [...] invariants\n| inv1 _ acc _ => I1 acc\n| _ => I2\nwith grind\nThis is more convenient than the equivalent · by rename_i _ acc _; exact I1 acc.Invariant suggestionsmvcgen will suggest invariants for you if you use the invariants? keyword.mvcgen [...] invariants?\nThis is useful if you do not recall the exact syntax to construct invariants.\nFurthermore, it will suggest a concrete invariant encoding \"this holds at the start of the loop and\nthis must hold at the end of the loop\" by looking at the corresponding VCs.\nAlthough the suggested invariant is a good starting point, it is too strong and requires users to\ninterpolate it such that the inductive step can be proved. Example:def mySum (l : List Nat) : Nat := Id.run do\n  let mut acc := 0\n  for x in l do\n    acc := acc + x\n  return acc\n\n/--\ninfo: Try this:\n  invariants\n    · ⇓⟨xs, letMuts⟩ => ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝\n-/\n#guard_msgs (info) in\ntheorem mySum_suggest_invariant (l : List Nat) : mySum l = l.sum := by\n  generalize h : mySum l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants?\n  all_goals admit\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.23. Verification Condition Generation","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-mvcgen"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-goal-selection":{"contents":"Most tactics affect the main goal.\nGoal selection tactics provide a way to treat a different goal as the main one, rearranging the sequence of goals in the proof state.\n\n* case tag => tac focuses on the goal with case name tag and solves it using tac,\nor else fails.* case tag x₁ ... xₙ => tac additionally renames the n most recent hypotheses\nwith inaccessible names to the given names.* case tag₁ | tag₂ => tac is equivalent to (case tag₁ => tac); (case tag₂ => tac).\n\ncase' is similar to the case tag => tac tactic, but does not ensure the goal\nhas been solved after applying tac, nor admits the goal if tac failed.\nRecall that case closes the goal using sorry when tac fails, and\nthe tactic execution is not interrupted.\n\nrotate_left n rotates goals to the left by n. That is, rotate_left 1\ntakes the main goal and puts it to the back of the subgoal list.\nIf n is omitted, it defaults to 1.\n\nRotate the goals to the right by n. That is, take the goal at the back\nand push it to the front n times. If n is omitted, it defaults to 1.\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures","header":"13.3.1.3. Goal Selection","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-goal-selection"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language":{"contents":"* #6634 adds support for changing the binder annotations of existing\nvariables to and from strict-implicit and instance-implicit using the\nvariable command.* #6744 extends the preprocessing of well-founded recursive definitions,\nsee the highlights section for details.* #6823 adds a builtin tactic and a builtin attribute that are required\nfor the tree map. The tactic, as_aux_lemma, can generally be used to\nwrap the proof term generated by a tactic sequence into a separate\nauxiliary lemma in order to keep the proof term small. This can, in rare\ncases, be necessary if the proof term will appear multiple times in the\nencompassing term. The new attribute, Std.Internal.tree_tac, is\ninternal and should not be used outside of Std.* #6853 adds support for anonymous equality proofs in match\nexpressions of the form match _ : e with ....* #6869 adds a recommended_spelling command; see the highlights\nsection for details.* #6891 modifies rewrite/rw to abort rewriting if the elaborated\nlemma has any immediate elaboration errors (detected by presence of\nsynthetic sorries). Rewriting still proceeds if there are elaboration\nissues arising from pending synthetic metavariables, like instance\nsynthesis failures. The purpose of the change is to avoid obscure\n\"tactic 'rewrite' failed, equality or iff proof expected ?m.5\" errors\nwhen for example a lemma does not exist.* #6893 adds support for plugins to the frontend and server.* #6935 adds the tactic expose_names; see the highlights section\nfor details.* #6936 fixes the #discr_tree_simp_key command, because it displays\nthe keys for just lhs in lhs ≠ rhs, but it should be lhs = rhs,\nsince that is what simp indexes.* #6939 adds error messages for inductive declarations with\nconflicting constructor names and mutual declarations with conflicting\nnames.* #6947 adds the binderNameHint gadget. It can be used in rewrite and\nsimp rules to preserve a user-provided name where possible.The expression binderNameHint v binder e defined to be e.If it is used on the right-hand side of an equation that is applied by\na tactic like rw or simp, and v is a local variable, and binder\nis an expression that (after beta-reduction) is a binder (so fun w => … or ∀ w, …),\nthen it will rename v to the name used in the binder, and remove the binderNameHint.A typical use of this gadget would be as follows; the gadget ensures\nthat after rewriting, the local variable is still name, and not x:theorem all_eq_not_any_not (l : List α) (p : α → Bool) :\n    l.all p = !l.any fun x => binderNameHint x p (!p x) := sorry\n\nexample (names : List String) : names.all (fun name => \"Waldo\".isPrefixOf name) = true := by\n  rw [all_eq_not_any_not]\n  -- ⊢ (!names.any fun name => !\"Waldo\".isPrefixOf name) = true\nThis gadget is supported by simp, dsimp and rw in the right-hand-side\nof an equation, but not in hypotheses or by other tactics.* #6951 adds line breaks and indentations to simp's trace messages to\nmake them easier to read (IMHO).* #6964 adds a convenience command #info_trees in, which prints the\ninfo trees generated by the following command. It is useful for\ndebugging or learning about InfoTree.* #7039 improves the well-founded definition preprocessing to propagate\nwfParam through let expressions.* #7053 makes simp heed the binderNameHint also in the assumptions\nof congruence rules. Fixes #7052.* #7055 improves array and vector literal syntax by allowing trailing\ncommas. For example, #[1, 2, 3,].* #7061 provides a basic API for a premise selection tool; see the\nhighlights section for details.* #7078 implements simprocs for Int and Nat divides predicates.* #7088 fixes the behavior of the indexed-access notation xs[i] in\ncases where the proof of i's validity is filled in during unification.* #7090 strips lib prefixes and _shared suffixes from plugin names.\nIt also moves most of the dynlib processing code to Lean to make such\npreprocessing more standard.* #7100 modifies the structure syntax; see the highlights section for details.* #7103 gives the induction tactic the ability to name hypotheses; see\nthe highlights section for details.* #7119 makes linter names clickable in the trace.profiler output.* #7191 fixes the indentation of \"Try this\" suggestions in widget-less\nmultiline messages, as they appear in #guard_msgs outputs.* #7192 prevents exact? and apply? from suggesting tactics that\ncorrespond to correct proofs but do not elaborate, and it allows these\ntactics to suggest expose_names when needed.* #7200 allows the debug form of DiscrTree.Key to line-wrap.* #7213 adds SetConsoleOutputCP(CP_UTF8) during runtime initialization\nto properly display Unicode on the Windows console. This effects both\nthe Lean executable itself and user executables (including Lake).* #7224 make induction … using and cases … using complain if more\ntargets were given than expected by that eliminator.* #7294 fixes bugs in Std.Internal.Rat.floor and\nStd.Internal.Rat.ceil.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Language","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language"}});