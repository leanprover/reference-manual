window.docContents[39].resolve({"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed":{"contents":"\n\nThis error occurs when the type of a definition is not fully specified and Lean is unable to infer\nits type from the available information. If the definition has parameters, this error refers only to\nthe resulting type after the colon (the error\nlean.inferBinderTypeFailed indicates\nthat a parameter type could not be inferred).\n\nTo resolve this error, provide additional type information in the definition. This can be done\nstraightforwardly by providing an explicit resulting type after the colon in the definition\nheader. Alternatively, if an explicit resulting type is not provided, adding further type\ninformation to the definition's body—such as by specifying implicit type arguments or giving\nexplicit types to let binders—may allow Lean to infer the type of the definition. Look for type\ninference or implicit argument synthesis errors that arise alongside this one to identify\nambiguities that may be contributing to this error.\n\nNote that when an explicit resulting type is provided—even if that type contains holes—Lean will not\nuse information from the definition body to help infer the type of the definition or its parameters.\nThus, adding an explicit resulting type may also necessitate adding type annotations to parameters\nwhose types were previously inferrable. Additionally, it is always necessary to provide an explicit\ntype in a theorem declaration: the theorem syntax requires a type annotation, and the elaborator\nwill never attempt to use the theorem body to infer the proposition being proved.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.inferDefTypeFailed","id":"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed"},"/The-Type-System/Inductive-Types/#recursors":{"contents":"Every inductive type is equipped with a recursor.\nThe recursor is completely determined by the signatures of the type constructor and the constructors.\nRecursors have function types, but they are primitive and are not definable using fun.\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model","header":"4.4.3.1. Recursors","id":"/The-Type-System/Inductive-Types/#recursors"},"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Compiler___-runtime___-and-FFI":{"contents":"* #4685 fixes a typo in the C run_new_frontend signature* #4729 has IR checker suggest using noncomputable* #5143 adds a shared library for Lake* #5437 removes (syntactically) duplicate imports (@euprunin)* #5462 updates src/lake/lakefile.toml to the adjusted Lake build process* #5541 removes new shared libs before build to better support Windows* #5558 make lean.h compile with MSVC (@kant2002)* #5564 removes non-conforming size-0 arrays (@eric-wieser)\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.13.0 (2024-11-01)","header":"Compiler, runtime, and FFI","id":"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Compiler___-runtime___-and-FFI"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Pretty-Printing":{"contents":"* #10122 adds support for pretty printing using generalized field\nnotation (dot notation) for private definitions on public types. It also\nmodifies dot notation elaboration to resolve names after removing the\nprivate prefix, which enables using dot notation for private definitions\non private imported types.* #10373 adds a pp.unicode option and a unicode(\"→\", \"->\") syntax\ndescription alias for the lower-level unicodeSymbol \"→\" \"->\" parser.\nThe syntax is added to the notation command as well. When pp.unicode\nis true (the default) then the first form is used when pretty printing,\nand otherwise the second ASCII form is used. A variant, unicode(\"→\", \"->\", preserveForPP) causes the -> form to be preferred; delaborators\ncan insert → directly into the syntax, which will be pretty printed\nas-is; this allows notations like fun to use custom options such as\npp.unicode.fun to opt into the unicode form when pretty printing.* #10374 adds the options pp.piBinderNames and\npp.piBinderNames.hygienic. Enabling pp.piBinderNames causes\nnon-dependent pi binder names to be pretty printed, rather than be\nomitted. When pp.piBinderNames.hygienic is false (the default) then\nonly non-hygienic such biner names are pretty printed. Setting pp.all\nenables pp.piBinderNames if it is not otherwise explicitly set.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Pretty Printing","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Pretty-Printing"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Tactics":{"contents":"* #10445 adds helper definitions in preparation for the upcoming\ninjective function support in grind.* #10447 adds the [grind inj] attribute for marking injectivity\ntheorems for grind.* #10448 modifies the \"issues\" grind diagnostics prints. Previously we\nwould just describe synthesis failures. These messages were confusing to\nusers, as in fact the linarith module continues to work, but less\ncapably. For most of the issues, we now explain the resulting change in\nbehaviour. There is a still a TODO to explain the change when\nIsOrderedRing is not available.* #10449 ensures that issues reported by the E-matching module are\ndisplayed only when set_option grind.debug true is enabled. Users\nreported that these messages are too distracting and not very useful.\nThey are more valuable for library developers when annotating their\nlibraries.* #10461 fixes unnecessary case splits generated by the grind mbtc\nmodule. Here, mbtc stands for model-based theory combination.* #10463 adds Nat.sub_zero as a grind normalization rule.* #10465 skips cast-like helper grind functions during grind mbtc* #10466 reduces noise in the 'Equivalence classes' section of the\ngrind diagnostics. It now uses a notion of support expressions.\nRight now, it is hard-coded, but we will probably make it extensible in\nthe future. The current definition is* #10469 fixes an incorrect optimization in the grind canonicalizer.\nSee the new test for an example that exposes the problem.* #10472 adds a code action for grind parameters. We need to use\nset_option grind.param.codeAction true to enable the option. The PR\nalso adds a modifier to instruct grind to use the \"default\" pattern\ninference strategy.* #10473 ensures the code action messages produced by grind include the\nfull context* #10474 adds a doc string for the ! parameter modifier in grind.* #10477 ensures sorts are internalized by grind.* #10480 fixes a bug in the equality resolution frontend used in grind.* #10481 generalizes the theorem activation function used in grind.\nThe goal is to reuse it to implement the injective function module.* #10482 fixes symbol collection for the @[grind inj] attribute.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Tactics","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Tactics"}});