window.docContents[136].resolve({"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Transformer":{"contents":"Adds exceptions of type ε to a monad m.\n\nRuns a computation from an underlying monad in the transformed monad with exceptions.\n\nUse a monadic action that may throw an exception as an action that may return an exception's value.This is the inverse of ExceptT.mk.\n\nReturns the value a without throwing exceptions or having any other effect.\n\nSequences two actions that may throw exceptions. Typically used via do-notation or the >>=\noperator.\n\nHandles exceptions thrown by an action that can have no effects other than throwing exceptions.\n\nHandles exceptions produced in the ExceptT ε transformer.\n\nUse a monadic action that may return an exception's value as an action in the transformed monad that\nmay throw the corresponding exception.This is the inverse of ExceptT.run.\n\nTransforms a successful computation's value using f. Typically used via the <$> operator.\n\nTransforms exceptions using the function f.This is the ExceptT version of Except.mapError.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Exceptions","header":"14.5.7.4. Transformer","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Transformer"},"/Run-Time-Code/Foreign-Function-Interface/#The-Lean-Language-Reference--Run-Time-Code--Foreign-Function-Interface--The-Lean-ABI":{"contents":"The Lean Application Binary Interface (ABI) describes how the signature of a Lean declaration is encoded in the platform-native calling convention.\nIt is based on the standard C ABI and calling convention of the target platform.\nLean declarations can be marked for interaction with foreign functions using either the attribute extern \"sym\", which causes compiled code to use the C declaration sym as the implementation, or the attribute export sym, which makes the declaration available as sym to C.In both cases, the C declaration's type is derived from the Lean type of the declaration with the attribute.\nLet α₁ → ... → αₙ → β be the declaration's normalized type.\nIf n is 0, the corresponding C declaration isextern s sym;\nwhere s is the C translation of β as specified in the next section.\nIn the case of a definition marked extern, the symbol's value is only guaranteed to be initialized after calling the Lean module's initializer or that of an importing module.\nThe section on initialization describes initializers in greater detail.If n is greater than 0, the corresponding C declaration iss sym(t₁, ..., tₙ);\nwhere the parameter types tᵢ are the C translations of the types αᵢ.\nIn the case of extern, all irrelevant types are removed first.\n\n\n\n\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Foreign Function Interface","header":"21.4.1. The Lean ABI","id":"/Run-Time-Code/Foreign-Function-Interface/#The-Lean-Language-Reference--Run-Time-Code--Foreign-Function-Interface--The-Lean-ABI"},"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Documentation":{"contents":"* #9093 adds a missing docstring for ToFormat.toFormat.* #9152 fixes an obsolete docstring for registerDerivingHandler* #9593 simplifies the docstring for propext significantly.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.23.0 (2025-09-15)","header":"Documentation","id":"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Documentation"}});