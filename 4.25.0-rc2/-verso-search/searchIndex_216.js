window.docContents[216].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"19.4.4.3. Conversions","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions"},"/Error-Explanations/lean___inductiveParamMissing/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMissing--Examples":{"contents":"Omitting parameter in argument to higher-order predicateinductive List.All {α : Type u} (P : α → Prop) : List α → Prop\n  | nil : All P []\n  | cons {x xs} : P x → All P xs → All P (x :: xs)\n\nstructure RoseTree (α : Type u) where\n  val : α\n  children : List (RoseTree α)\n\ninductive RoseTree.All {α : Type u} (P : α → Prop) (t : RoseTree α) : Prop\n  | intro : P t.val → List.All (All P) t.children → All P t\n<invalid output>inductive List.All {α : Type u} (P : α → Prop) : List α → Prop\n  | nil : All P []\n  | cons {x xs} : P x → All P xs → All P (x :: xs)\n\nstructure RoseTree (α : Type u) where\n  val : α\n  children : List (RoseTree α)\n\ninductive RoseTree.All {α : Type u} (P : α → Prop) : RoseTree α → Prop\n  | intro : P t.val → List.All (All P) t.children → All P t\nBecause the RoseTree.All type constructor must be partially applied in the argument to List.All,\nthe unspecified argument (t) must not be a parameter of the RoseTree.All predicate. Making it an\nindex to the right of the colon in the header of RoseTree.All allows this partial application to\nsucceed.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.inductiveParamMissing","header":"Examples","id":"/Error-Explanations/lean___inductiveParamMissing/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMissing--Examples"},"/Interacting-with-Lean/#hash-reduce":{"contents":"The #reduce command repeatedly applies reductions to a term until no further reductions are possible.\nReductions are performed under binders, but to avoid unexpected slowdowns, proofs and types are skipped unless the corresponding options to #reduce are enabled.\nUnlike #eval command, reduction cannot have side effects and the result is displayed as a term rather than via a ToString or Repr instance.\n\nGenerally speaking, #reduce is primarily useful for diagnosing issues with definitional equality and proof terms, while #eval is more suitable for computing the value of a term.\nIn particular, functions defined using well-founded recursion or as partial fixpoints are either very slow to compute with the reduction engine, or will not reduce at all.\n\nReducing Terms#reduce <expression> reduces the expression <expression> to its normal form. This\ninvolves applying reduction rules until no further reduction is possible.By default, proofs and types within the expression are not reduced. Use modifiers\n(proofs := true)  and (types := true) to reduce them.\nRecall that propositions are types in Lean.Warning: This can be a computationally expensive operation,\nespecially for complex expressions.Consider using #eval <expression> for simple evaluation/execution\nof expressions.\n\nReducing FunctionsReducing a term results in its normal form in Lean's logic.\nBecause the underlying term is reduced and then displayed, there is no need for a ToString or Repr instance.\nFunctions can be displayed just as well as any other term.In some cases, this normal form is short and resembles a term that a person might write:#reduce (fun x => x + 1)\nfun x => x.succ\nIn other cases, the details of the elaboration of functions such as addition to Lean's core logic are exposed:#reduce (fun x => 1 + x)\nfun x => (Nat.rec ⟨fun x => x, PUnit.unit⟩ (fun n n_ih => ⟨fun x => (n_ih.1 x).succ, n_ih⟩) x).1 1\n\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.2. Reducing Terms","id":"/Interacting-with-Lean/#hash-reduce"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-debug":{"contents":"The sorry tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using exact sorry.This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses sorry, so you aren't likely to miss it,\nbut you can double check if a theorem depends on sorry by looking for sorryAx in the output\nof the #print axioms my_thm command, the axiom used by the implementation of sorry.\n\nadmit is a synonym for sorry.\n\ndbg_trace \"foo\" prints foo when elaborated.\nUseful for debugging tactic control flow:example : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n\n\ntrace_state displays the current state in the info view.\n\ntrace msg displays msg in the info view.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.21. Debugging Utilities","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-debug"},"/The-Type-System/Functions/#function-api":{"contents":"The Function namespace contains general-purpose helpers for working with functions.\n\nFunction composition, usually written with the infix operator ∘. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.Examples:* Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]* (List.reverse ∘ List.drop 2) [3, 2, 4, 1] = [1, 4]Conventions for notations in identifiers:* The recommended spelling of ∘ in identifiers is comp.\n\nThe constant function that ignores its argument.If a : α, then Function.const β a : β → α is the “constant function with value a”. For all\narguments b : β, Function.const β a b = a.Examples:* Function.const Bool 10 true = 10* Function.const Bool 10 false = 10* Function.const String 10 \"any string\" = 10\n\nTransforms a function from pairs into an equivalent two-parameter function.Examples:* Function.curry (fun (x, y) => x + y) 3 5 = 8* Function.curry Prod.swap 3 \"five\" = (\"five\", 3)\n\nTransforms a two-parameter function into an equivalent function from pairs.Examples:* Function.uncurry List.drop (1, [\"a\", \"b\", \"c\"]) = [\"b\", \"c\"]* [(\"orange\", 2), (\"android\", 3) ].map (Function.uncurry String.take) = [\"or\", \"and\"]\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Functions","header":"4.1.5. API Reference","id":"/The-Type-System/Functions/#function-api"}});