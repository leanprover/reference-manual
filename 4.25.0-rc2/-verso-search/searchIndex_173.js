window.docContents[173].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Partitioning":{"contents":"Returns a pair of arrays that together contain all the elements of as. The first array contains\nthose elements for which p returns true, and the second contains those for which p returns\nfalse.as.partition p is equivalent to (as.filter p, as.filter (not ∘ p)), but it is\nmore efficient since it only has to do one pass over the array.Examples:* #[1, 2, 5, 2, 7, 7].partition (· > 2) = (#[5, 7, 7], #[1, 2, 2])* #[1, 2, 5, 2, 7, 7].partition (fun _ => false) = (#[], #[1, 2, 5, 2, 7, 7])* #[1, 2, 5, 2, 7, 7].partition (fun _ => true) = (#[1, 2, 5, 2, 7, 7], #[])\n\nGroups the elements of an array xs according to the function key, returning a hash map in which\neach group is associated with its key. Groups preserve the relative order of elements in xs.Example:#eval #[0, 1, 2, 3, 4, 5, 6].groupByKey (· % 2)\nStd.HashMap.ofList [(0, #[0, 2, 4, 6]), (1, #[1, 3, 5])]\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.11. Partitioning","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Partitioning"},"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch":{"contents":"\n\nIn an inductive declaration, the resulting type of each constructor must match the type being\ndeclared; if it does not, this error is raised. That is, every constructor of an inductive type must\nreturn a value of that type. See the Inductive Types manual\nsection for additional details. Note that it is possible to omit the resulting type for a\nconstructor if the inductive type being defined has no indices.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.ctorResultingTypeMismatch","id":"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch"},"/Error-Explanations/lean___propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--lean___propRecLargeElim":{"contents":"\n\nThis error occurs when attempting to eliminate a proof of a proposition into a higher type universe.\nBecause Lean's type theory does not allow large elimination from Prop, it is invalid to\npattern-match on such values—e.g., by using let or match—to produce a piece of data in a\nnon-propositional universe (i.e., Type u). More precisely, the motive of a propositional recursor\nmust be a proposition. (See the manual section on\nSubsingleton Elimination for exceptions to this\nrule.)\n\nNote that this error will arise in any expression that eliminates from a proof into a\nnon-propositional universe, even if that expression occurs within another expression of\npropositional type (e.g., in a let binding in a proof). The \"Defining an intermediate data value\nwithin a proof\" example below demonstrates such an occurrence. Errors of this kind can usually be\nresolved by moving the recursor application \"outward,\" so that its motive is the proposition being\nproved rather than the type of data-valued term.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.propRecLargeElim","id":"/Error-Explanations/lean___propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--lean___propRecLargeElim"}});