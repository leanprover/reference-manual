window.docContents[49].resolve({"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Building-and-Running":{"contents":"\n\nBuilds the specified facts of the specified targets.Each of the targets is specified by a string of the form:The optional @ and + markers can be used to disambiguate packages and modules from file paths as well as executables, and libraries, which are specified by name as target.\nIf not provided, package defaults to the workspace's root package.\nIf the same target name exists in multiple packages in the workspace, then the first occurrence of the target name found in a topological sort of the package dependency graph is selected.\nModule targets may also be specified by their filename, with an optional facet after a colon.The available facets depend on whether a package, library, executable, or module is to be built.\nThey are listed in the section on facets.When using the local artifact cache, the -o option saves a mappings file that tracks the inputs and outputs of each step in the build.\nThis file can be used with cache get and cache put to interact with a remote cache.\nThe mappings file is in JSON Lines format, with one valid JSON object per line, and its filename extension is conventionally .jsonl.\n\nTarget and Facet Specifications* a* The default facet(s) of target a\n* @a* The default targets of package a\n* +A* The Lean artifacts of module A (because the default facet of modules is leanArts)\n* @a/b* The default facet of target b of package a\n* @a/+A:c* The C file compiled from module A of package a\n* :foo* The root package's facet foo\n* A/B/C.lean:o* The compiled object code for the module in the file A/B/C.lean\n\n\n\nExits with code 0 if the workspace's root package has any default targets configured.\nErrors (with exit code 1) otherwise.check-build does not verify that the configured default targets are valid.\nIt merely verifies that at least one is specified.\n\n\n\n\n\nBuilds a set of targets, reporting progress on standard error and outputting the results on standard out.\nTarget results are output in the same order they are listed and end with a newline.\nIf --json is set, results are formatted as JSON.\nOtherwise, they are printed as raw strings.Targets which do not have output configured will be printed as an empty string or null.\nFor executable targets, the output is the path to the built executable.Targets are specified using the same syntax as in build.\n\nLooks for the executable target exe-target in the workspace, builds it if it is out of date, and then runs\nit with the given args in Lake's environment.See build for the syntax of target specifications and env for a description of how the environment is set up.\n\n\n\nIf no package is specified, deletes the build directories of every package in the workspace.\nOtherwise, it just deletes those of the specified packages.\n\n\n\nWhen cmd is provided, it is executed in the Lake environment with arguments args.If cmd is not provided, Lake prints the environment in which it runs tools.\nThis environment is system-specific.\n\n\n\nBuilds the imports of the given file and then runs lean on it using the workspace's root package's additional Lean arguments and the given args, in that order.\nThe lean process is executed in Lake's environment.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"22.1.2.6. Building and Running","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Building-and-Running"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Development-Tools--Tests-and-Linters":{"contents":"\n\nTest the workspace's root package using its configured test driver.A test driver that is an executable will be built and then run with the package configuration's testDriverArgs plus the CLI args.\nA test driver that is a Lake script is run with the same arguments as an executable test driver.\nA library test driver will just be built; it is expected that tests are implemented such that failures cause the build to fail via elaboration-time errors.\n\n\n\nLint the workspace's root package using its configured lint driverA script lint driver will be run with the  package configuration's\nlintDriverArgs plus the CLI args. An executable lint driver will be\nbuilt and then run like a script.\n\n\n\nCheck if there is a properly configured test driverExits with code 0 if the workspace's root package has a properly\nconfigured lint driver. Errors (with code 1) otherwise.Does NOT verify that the configured test driver actually exists in the\npackage or its dependencies. It merely verifies that one is specified.This is useful for distinguishing between failing tests and incorrectly configured packages.\n\n\n\nCheck if there is a properly configured lint driverExits with code 0 if the workspace's root package has a properly\nconfigured lint driver. Errors (with code 1) otherwise.Does NOT verify that the configured lint driver actually exists in the\npackage or its dependencies. It merely verifies that one is specified.This is useful for distinguishing between failing lints and incorrectly configured packages.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface\u0009Development Tools","header":"22.1.2.7.1. Tests and Linters","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Development-Tools--Tests-and-Linters"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--___Finally___-Computations":{"contents":"Monads that provide the ability to ensure an action happens, regardless of exceptions or other\nfailures.MonadFinally.tryFinally' is used to desugar try ... finally ... syntax.Runs an action, ensuring that some other action always happens afterward.More specifically, tryFinally' x f runs x and then the “finally” computation f. If x\nsucceeds with some value a : α, f (some a) is returned. If x fails for m's definition of\nfailure, f none is returned.tryFinally' can be thought of as performing the same role as a finally block in an imperative\nprogramming language.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Exceptions","header":"14.5.7.3. “Finally” Computations","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--___Finally___-Computations"},"/Namespaces-and-Sections/#section-variables":{"contents":"Section variables are parameters that are automatically added to declarations that mention them.\nThis occurs whether or not the option autoImplicit is true.\nSection variables may be implicit, strict implicit, or explicit; instance implicit section variables are treated specially.\n\nWhen the name of a section variable is encountered in a non-theorem declaration, it is added as a parameter.\nAny instance implicit section variables that mention the variable are also added.\nIf any of the variables that were added depend on other variables, then those variables are added as well; this process is iterated until no more dependencies remain.\nAll section variables are added in the order in which they are declared, before all other parameters.\nSection variables are added only when they occur in the statement of a theorem.\nOtherwise, modifying the proof of a theorem could change its statement if the proof term made use of a section variable.\n\nVariables are declared using the variable command.\n\nVariable Declarations\n\nThe bracketed binders allowed after variable match the syntax used in definition headers.\n\nSection VariablesIn this section, automatic implicit parameters are disabled, but a number of section variables are defined.section\nset_option autoImplicit false\nuniverse u\nvariable {α : Type u} (xs : List α) [Zero α] [Add α]\nBecause automatic implicit parameters are disabled, the following definition fails:def addAll (lst : List β) : β :=\n  lst.foldr (init := 0) (· + ·)\nUnknown identifier `β`\nOn the other hand, not even xs needs to be written directly in the definition:def addAll :=\n  xs.foldr (init := 0) (· + ·)\n\n\nTo add a section variable to a theorem even if it is not explicitly mentioned in the statement, mark the variable with the include command.\nAll variables marked for inclusion are added to all theorems.\nThe omit command removes the inclusion mark from a variable; it's typically a good idea to use it with in.\n\n\n\nIncluded and Omitted Section VariablesThis section's variables include a predicate as well as everything needed to prove that it holds universally, along with a useless extra assumption.section\nvariable {p : Nat → Prop}\nvariable (pZero : p 0) (pStep : ∀ n, p n → p (n + 1))\nvariable (pFifteen : p 15)\nHowever, only p is added to this theorem's assumptions, so it cannot be proved.theorem p_all : ∀ n, p n := by\n  intro n\n  induction n\nThe include command causes the additional assumptions to be added unconditionally:include pZero pStep pFifteen\n\ntheorem p_all : ∀ n, p n := by\n  intro n\n  induction n <;> simp [*]\nBecause the spurious assumption pFifteen was inserted, Lean issues a warning:automatically included section variable(s) unused in theorem `p_all`:\n  pFifteen\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit pFifteen in theorem ...\n\nNote: This linter can be disabled with `set_option linter.unusedSectionVars false`\nThis can be avoided by using omitto remove pFifteen:include pZero pStep pFifteen\n\nomit pFifteen in\ntheorem p_all : ∀ n, p n := by\n  intro n\n  induction n <;> simp [*]\nend\n\n\n\n\n","context":"Lean Reference\u0009Namespaces and Sections\u0009Section Scopes","header":"6.2.2. Section Variables","id":"/Namespaces-and-Sections/#section-variables"},"/The-Type-System/Inductive-Types/#mutual-inductive-types":{"contents":"Inductive types may be mutually recursive.\nMutually recursive definitions of inductive types are specified by defining the types in a mutual ... end block.\n\nMutually Defined Inductive TypesThe type EvenOddList in a prior example used a Boolean index to select whether the list in question should have an even or odd number of elements.\nThis distinction can also be expressed by the choice of one of two mutually inductive types EvenList and OddList:mutual\n  inductive EvenList (α : Type u) : Type u where\n    | nil : EvenList α\n    | cons : α → OddList α → EvenList α\n  inductive OddList (α : Type u) : Type u where\n    | cons : α → EvenList α → OddList α\nend\n\nexample : EvenList String := .cons \"x\" (.cons \"y\" .nil)\nexample : OddList String := .cons \"x\" (.cons \"y\" (.cons \"z\" .nil))\nexample : OddList String := .cons \"x\" (.cons \"y\" .nil)\nUnknown constant `OddList.nil`\n\nNote: Inferred this name from the expected resulting type of `.nil`:\n  OddList String\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.5. Mutual Inductive Types","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types"},"/Type-Classes/Instance-Synthesis/#instance-synth":{"contents":"Instance synthesis is a recursive search procedure that either finds an instance for a given type class or fails.\nIn other words, given a type that is registered as a type class, instance synthesis attempts to construct a term with said type.\nIt respects reducibility: semireducible or irreducible definitions are not unfolded, so instances for a definition are not automatically treated as instances for its unfolding unless it is reducible.\nThere may be multiple possible instances for a given class; in this case, declared priorities and order of declaration are used as tiebreakers, in that order, with more recent instances taking precedence over earlier ones with the same priority.\n\nThis search procedure is efficient in the presence of diamonds and does not loop indefinitely when there are cycles.\nDiamonds occur when there is more than one route to a given goal, and cycles are situations when two instances each could be solved if the other were solved.\nDiamonds occur regularly in practice when encoding mathematical concepts using type classes, and Lean's coercion feature  naturally leads to cycles, e.g. between finite sets and finite multisets.\n\nInstance synthesis can be tested using the #synth command.\nAdditionally, inferInstance and inferInstanceAs can be used to synthesize an instance in a position where the instance itself is needed.\n\ninferInstance synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the [i : α] argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\nα is not a class.) Example:#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n\n\ninferInstanceAs α synthesizes a value of any target type by typeclass\ninference. This is just like inferInstance except that α is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some α' which is definitionally equal to α,\nbut the instance we are looking for is only registered for α (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"11.3. Instance Synthesis","id":"/Type-Classes/Instance-Synthesis/#instance-synth"},"/platforms/#platforms":{"contents":"\n\n\n\n","context":"Lean Reference","header":"Supported Platforms","id":"/platforms/#platforms"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Other":{"contents":"* #7326 updates the release notes script to better indent PR\ndescriptions.* #7453 adds \"(kernel)\" to the message for the kernel-level application\ntype mismatch error.* #7769 fixes a number of bugs in the release automation scripts, adds a\nscript to merge tags into remote stable branches, and makes the main\nrelease_checklist.py script give suggestions to call the\nmerge_remote.py and release_steps.py scripts when needed.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)","header":"Other","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Other"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Library":{"contents":"* #9258 adds support for signal handlers to the Lean standard library.* #9298 adds support the Count Trailing Zeros operation BitVec.ctz to\nthe bitvector library and to bv_decide, relying on the existing clz\ncircuit. We also build some theory around BitVec.ctz (analogous to the\ntheory existing for BitVec.clz) and introduce lemmas\nBitVec.[ctz_eq_reverse_clz, clz_eq_reverse_ctz, ctz_lt_iff_ne_zero, getLsbD_false_of_lt_ctz, getLsbD_true_ctz_of_ne_zero, two_pow_ctz_le_toNat_of_ne_zero, reverse_reverse_eq, reverse_eq_zero_iff].* #9932 adds LawfulMonad and WPMonad instances for Option and\nOptionT.* #10304 redefines String to be the type of byte arrays b for which\nb.IsValidUtf8.* #10319 \"monomorphizes\" the structure Std.PRange shape α, replacing it\nwith nine distinct structures Std.Rcc, Std.Rco, Std.Rci etc., one\nfor each possible shape of a range's bounds. This change was necessary\nbecause the shape polymorphism is detrimental to attempts of automation.* #10366 refactors the Async module to use the Async type in all of the\nAsync files.* #10367 adds vectored write for TCP and UDP (that helps a lot with not\ncopying the arrays over and over) and fix a RC issue in TCP and UDP\ncancel functions with the line lean_dec((lean_object*)udp_socket); and\na similar one that tries to decrement the object inside of the socket.* #10368 adds Notify that is a structure that is similar to CondVar\nbut it's used for concurrency. The main difference between\nStd.Sync.Notify and Std.Condvar is that depends on a Std.Mutex and\nblocks the entire thread that the Task is using while waiting.* #10369 adds a multi-consumer, multi-producer channel to Std.Sync.* #10370 adds async type classes for streams.* #10400 adds the StreamMap type that enables multiplexing in\nasynchronous streams.* #10407 adds @[method_specs_simp] in Init for type classes like\nHAppend.* #10457 introduces safe alternatives to String.Pos and Substring\nthat can only represent valid positions/slices.* #10487 adds vectored write and fix rc issues in tcp and udp cancel\nfunctions.* #10510 adds a Std.CancellationToken type* #10514 defines the new String.Slice API.* #10552 ensures that Substring.beq is reflexive, and in particular\nsatisfies the equivalence ss1 == ss2 <-> ss1.toString = ss2.toString.* #10611 adds adds union operation on DHashMap/HashMap/HashSet and\ntheir raw variants and provides lemmas about union operations.* #10618 removes superfluous Monad instances from the spec lemmas of\nthe MonadExceptOf lifting framework.* #10624 renames String.Pos to String.Pos.Raw.* #10627 adds lemmas forall_fin_zero and exists_fin_zero. It also\nmarks lemmas forall_fin_zero, forall_fin_one, forall_fin_two,\nexists_fin_zero, exists_fin_one, exists_fin_two with simp\nattribute.* #10630 aims to fix the Timer API selector to make it finish as soon as\npossible when unregistered. This change makes the Selectable.one\nfunction drop the selectables array as soon as possible, so when\ncombined with finalizers that have some effects like the TCP socket\nfinalizer, it runs it as soon as possible.* #10631 exposes the definitions about Int*. The main reason is that\nthe SInt simprocs require many of them to be exposed. Furthermore,\ndecide now works with Int* operations. This fixes #10631.* #10633 provides range support for the signed finite number types\nInt{8,16,32,64} and ISize. The proof obligations are handled by\nreducing all of them to proofs about an internal UpwardEnumerable\ninstance for BitVec interpreted as signed numbers.* #10634 defines ByteArray.validateUTF8, uses it to show that\nByteArray.IsValidUtf8 is decidable and redefines String.fromUTF8 and\nfriends to use it.* #10636 renames String.getUtf8Byte to String.getUTF8Byte in order to\nadhere to the standard library naming convention.* #10642 introduces List.Cursor.pos as an abbreviation for\nprefix.length.* #10645 renames Stream to Std.Stream so that the name becomes\navailable to mathlib after a deprecation cycle.* #10649 renames Nat.and_distrib_right to Nat.and_or_distrib_right.\nThis is to make the name consistent with other theorems in the same file\n(e.g. Nat.and_or_distrib_left).* #10653 adds equational lemmas about (filter-)mapping and then folding\niterators.* #10667 adds more selectors for TCP and Signals.* #10676 adds the IO.FS.hardLink function, which can be used to create\nhard links.* #10685 introduces LT and LE instances on String.ValidPos and\nString.Slice.Pos.* #10686 introduces any, anyM, all and allM for pure and monadic\niterators. It also provides lemmas about them.* #10713 enforces rules around arithmetic of String.Pos.Raw.* #10728 introduces the flatMap iterator combinator. It also adds\nlemmas relating flatMap to toList and toArray.* #10735 moves many operations involving String.Pos.Raw to a the\nString.Pos.Raw namespace with the eventual aim of freeing up the\nString namespace to contain operations using String.ValidPos (to be\nrenamed to String.Pos) instead.* #10761 provides iterators on hash maps.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Library","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Library"}});