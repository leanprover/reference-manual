window.docContents[125].resolve({"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-channels":{"contents":"Toolchains are specified by providing a toolchain identifier that is either a channel, which identifies a particular type of Lean release, and optionally an origin, or a custom toolchain name established by toolchain link.\nChannels may be:\n\n stable\n\nThe latest stable Lean release. Elan automatically tracks stable releases and offers to upgrade when a new one is released.\n\n beta\n\nThe latest release candidate. Release candidates are builds of Lean that are intended to become the next stable release. They are made available for widespread user testing.\n\n nightly\n\nThe latest nightly build. Nightly builds are useful for experimenting with new Lean features to provide feedback to the developers.\n\n A version number or specific nightly release\n\nEach Lean version number identifies a channel that contains only that release.\n    The version number may optionally be preceded with a v, so v4.17.0 and 4.17.0 are equivalent.\n    Similarly, nightly-YYYY-MM-DD specifies the nightly release from the specified date.\n    A project's toolchain file should typically contain a specific version of Lean, rather than a general channel, to make it easier to coordinate between developers and to build and test older versions of the project.\n    An archive of Lean releases and nightly builds is maintained.\n\n A custom local toolchain\n\nThe command toolchain link can be used to establish a custom toolchain name in Elan for a local build of Lean.\n    This is especially useful when working on the Lean compiler itself.\n\n\n\nSpecifying an origin instructs Elan to install Lean toolchains from a particular source.\nBy default, this is the official project repository on GitHub, identified as leanprover/lean4.\nIf specified, an origin should precede the channel, with a colon, so stable is equivalent to leanprover/lean4:stable.\nWhen installing nightly releases, -nightly is appended to the origin, so leanprover/lean4:nightly-2025-03-25 consults the leanprover/lean4-nightly repository to download releases.\nOrigins are not used for custom toolchain names.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Selecting Toolchains","header":"22.2.1.1. Toolchain Identifiers","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-channels"},"/Notations-and-Macros/Elaborators/#elaborators":{"contents":"While macros allow Lean to be extended by translating new syntax into existing syntax, elaborators allow the new syntax to be processed directly.\nElaborators have access to everything that Lean itself uses to implement each feature of the language.\nDefining a new elaborator allows a language extension to be just as powerful as any built-in feature of Lean.\n\nElaborators come in two varieties:* Command elaborators are used to add new commands to Lean.\n   Commands are implemented as side effects: they may add new constants to the global environment, extend compile-time tables such as the one that tracks instances, they can provide feedback in the form of information, warnings, or errors, and they have full access to the IO monad.\n   Command elaborators are associated with the syntax kinds that they can handle.* Term elaborators are used to implement new terms by translating the syntax into Lean's core type theory.\n   They can do everything that command elaborators can do, and they additionally have access to the local context in which the term is being elaborated.\n   Term elaborators can look up bound variables, bind new variables, unify two terms, and much more.\n   A term elaborator must return a value of type Lean.Expr, which is the AST of the core type theory.\n\nThis section provides an overview and a few examples of elaborators.\nBecause Lean's own elaborator uses the same tools, the source code of the elaborator is a good source of further examples.\nJust like macros, multiple elaborators may be associated with a syntax kind; they are tried in order, and elaborators may delegate to the next elaborator in the table by throwing the unsupportedSyntax exception.\n\nElaboration RulesThe elab_rules command takes a sequence of elaboration rules, specified as syntax pattern matches, and adds each as an elaborator.\nThe rules are attempted in order, before previously-defined elaborators, and later elaborators may add further options.\n\nCommands, terms, and tactics each maintain a table that maps syntax kinds to elaborators.\nThe syntax category for which the elaborator should be used is specified after the colon, and must be term, command, or tactic.\nThe <= binds the provided identifier to the current expected type in the context in which a term is being elaborated; it may only be used for term elaborators, and if present, then term is implied as the syntax category.\n\nElaborator AttributeElaborators can be directly associated with syntax kinds by applying the appropriate attributes.\nEach takes the name of a syntax kind and associates the definition with the kind.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros","header":"20.6. Elaborators","id":"/Notations-and-Macros/Elaborators/#elaborators"},"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Candidate-Instances":{"contents":"Instance synthesis uses both local and global instances in its search.\nLocal instances are those available in the local context; they may be either parameters to a function or locally defined with let. \nLocal instances do not need to be indicated specially; any local variable whose type is a type class is a candidate for instance synthesis.\nGlobal instances are those available in the global environment; every global instance is a defined name with the instance attribute applied.instance declarations automatically apply the instance attribute.\n\nLocal InstancesIn this example, addPairs contains a locally-defined instance of Add NatPair:structure NatPair where\n  x : Nat\n  y : Nat\n\ndef addPairs (p1 p2 : NatPair) : NatPair :=\n  let _ : Add NatPair :=\n    ⟨fun ⟨x1, y1⟩ ⟨x2, y2⟩ => ⟨x1 + x2, y1 + y2⟩⟩\n  p1 + p2\nThe local instance is used for the addition, having been found by instance synthesis.\n\nLocal Instances Have PriorityHere, addPairs contains a locally-defined instance of Add NatPair, even though there is a global instance:structure NatPair where\n  x : Nat\n  y : Nat\n\ninstance : Add NatPair where\n  add\n    | ⟨x1, y1⟩, ⟨x2, y2⟩ => ⟨x1 + x2, y1 + y2⟩\n\ndef addPairs (p1 p2 : NatPair) : NatPair :=\n  let _ : Add NatPair :=\n    ⟨fun _ _ => ⟨0, 0⟩⟩\n  p1 + p2\nThe local instance is selected instead of the global one:#eval addPairs ⟨1, 2⟩ ⟨5, 2⟩\n{ x := 0, y := 0 }\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.3. Candidate Instances","id":"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Candidate-Instances"},"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Documentation":{"contents":"* #5617 fixes MSYS2 build instructions.* #5725 points out that OfScientific is called with raw literals (@eric-wieser).* #5794 adds a stub for application ellipsis notation (@eric-wieser).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.14.0 (2024-12-02)","header":"Documentation","id":"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Documentation"}});