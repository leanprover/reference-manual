window.docContents[20].resolve({"/Basic-Types/Strings/#string-performance":{"contents":"Despite the fact that they appear to be an ordinary constructor and projection, String.ofByteArray and String.bytes take time linear in the length of the string.\nThis is because byte arrays and strings do not have an identical representation, so the contents of the byte array must be copied to a new object.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009Run-Time Representation","header":"19.8.2.1. Performance Notes","id":"/Basic-Types/Strings/#string-performance"},"/Notations-and-Macros/Macros/#macro-monad":{"contents":"The macro monad MacroM is sufficiently powerful to implement hygiene and report errors.\nMacro expansion does not have the ability to modify the environment directly, to carry out unification, to examine the current local context, or to do anything else that only makes sense in one particular context.\nThis allows the same macro mechanism to be used throughout Lean, and it makes macros much easier to write than elaborators.\n\nThe MacroM monad is the main monad for macro expansion. It has the\ninformation needed to handle hygienic name generation, and is the monad that\nmacro definitions live in.Notably, this is a (relatively) pure monad: there is no IO and no access to\nthe Environment. That means that things like declaration lookup are\nimpossible here, as well as IO.Ref or other side-effecting operations.\nFor more capabilities, macros can instead be written as elab using adaptExpander.\n\nexpandMacro? stx returns some stxNew if stx is a macro,\nand stxNew is its expansion.\n\nAdd a new trace message, with the given trace class and message.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros","header":"20.5.2. The Macro Monad","id":"/Notations-and-Macros/Macros/#macro-monad"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-namespaces-options":{"contents":"Namespaces and options can be adjusted in tactic scripts using the same syntax as in terms.\n\nset_option opt val in tacs (the tactic) acts like set_option opt val at the command level,\nbut it sets the option only within the tactics tacs.\n\nopen Foo in tacs (the tactic) acts like open Foo at command level,\nbut it opens a namespace only within the tactics tacs.\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","header":"13.3.6. Namespace and Option Management","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-namespaces-options"}});