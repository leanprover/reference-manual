window.docContents[107].resolve({"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-from-Mutable-References":{"contents":"\n\nThe monad StateRefT σ m is a specialized state monad transformer that can be used when m is a monad to which ST computations can be lifted.\nIt implements the operations of MonadState using an ST.Ref, rather than pure functions.\nThis ensures that mutation is actually used at run time.\n\nST and EST require a phantom type parameter that's used together with runST's polymorphic function argument to encapsulate mutability.\nRather than require this as a parameter to the transformer, an auxiliary type class STWorld is used to propagate it directly from m.\n\nThe transformer itself is defined as a syntax extension and an elaborator, rather than an ordinary function.\nThis is because STWorld has no methods: it exists only to propagate information from the inner monad to the transformed monad.\nNonetheless, its instances are terms; keeping them around could lead to unnecessarily large types.\n\nAn auxiliary class used to infer the “state” of EST and ST monads.\n\nStateRefTThe syntax for StateRefT σ m accepts two arguments:Its elaborator synthesizes an instance of STWorld ω m to ensure that m supports mutable references.\nHaving discovered the value of ω, it then produces the term StateRefT' ω σ m, discarding the synthesized instance.\n\nA state monad that uses an actual mutable reference cell (i.e. an ST.Ref ω σ).The macro StateRefT σ m α infers ω from m. It should normally be used instead.\n\nRetrieves the current value of the monad's mutable state.This increments the reference count of the state, which may inhibit in-place updates.\n\nReplaces the mutable state with a new value.\n\nApplies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.It is equivalent to a get followed by a set. However, using modifyGet may lead to higher\nperformance because it doesn't add a new reference to the state value. Additional references can\ninhibit in-place updates of data.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value paired with the final state.The monad m must support ST effects in order to create and mutate reference cells.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value, discarding the final state.The monad m must support ST effects in order to create and mutate reference cells.\n\nRuns an action from the underlying monad in the monad with state. The state is not modified.This function is typically implicitly accessed via a MonadLiftT instance as part of automatic\nlifting.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009State","header":"14.5.4.4. State Monads from Mutable References","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-from-Mutable-References"},"/Notations-and-Macros/Notations/#operators-and-notations":{"contents":"Internally, operator declarations are translated into notation declarations.\nTerm notation items are inserted where the operator would expect arguments, and in the corresponding positions in the expansion.\nFor prefix and postfix operators, the notation's precedence as well as the precedences of its term items is the operator's declared precedence.\nFor non-associative infix operators, the notation's precedence is the declared precedence, but both arguments are parsed at a precedence level that is one higher, which prevents successive uses of the notation without parentheses.\nAssociative infix operators use the operator's precedence for the notation and for one argument, while a precedence that is one level higher is used for the other argument; this prevents successive applications in one direction only.\nLeft-associative operators use the higher precedence for their right argument, while right-associative operators use the higher precedence for their left argument.\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Notations","header":"20.3.1. Operators and Notations","id":"/Notations-and-Macros/Notations/#operators-and-notations"},"/The--grind--tactic/Case-Analysis/#grind-split":{"contents":"In addition to congruence closure and constraint propagation, grind performs case analysis.\nDuring case analysis, grind considers each possible way that a term could have been built, or each possbile value of a particular term, in a manner similar to the cases and split tactics.\nThis case analysis is not exhaustive: grind only recursively splits cases up to a configured depth limit, and configuration options and annotations control which terms are candidates for splitting.\n\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.5. Case Analysis","id":"/The--grind--tactic/Case-Analysis/#grind-split"},"/The-Type-System/Quotients/#quotient-elim":{"contents":"Functions from quotients can be defined by proving that a function from the underlying type respects the quotient's equivalence relation.\nThis is accomplished using Quotient.lift or its binary counterpart Quotient.lift₂.\nThe variants Quotient.liftOn and Quotient.liftOn₂ place the quotient parameter first rather than last in the parameter list.\n\nLifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.Given s : Setoid α and a quotient Quotient s, applying a function f : α → β requires a proof\nh that f respects the equivalence relation s.r. In this case, the function\nQuotient.lift f h : Quotient s → β computes the same values as f.Quotient.liftOn is a version of this operation that takes the quotient value as its first explicit\nparameter.\n\nLifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.Given s : Setoid α and a quotient value q : Quotient s, applying a function f : α → β requires\na proof c that f respects the equivalence relation s.r. In this case, the term\nQuotient.liftOn q f h : β reduces to the result of applying f to the underlying α value.Quotient.lift is a version of this operation that takes the quotient value last, rather than\nfirst.\n\nLifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.Quotient.lift is a version of this operation for unary functions. Quotient.liftOn₂ is a version\nthat take the quotient parameters first.\n\nLifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.Quotient.liftOn is a version of this operation for unary functions. Quotient.lift₂ is a version\nthat take the quotient parameters last.\n\nInteger Negation and AdditionGiven the encoding Z of integers as a quotient of pairs of natural numbers, negation can be implemented by swapping the first and second projections:def neg' : Z' → Z\n  | (x, y) => .mk (y, x)\nThis can be transformed into a function from Z to Z by proving that negation respects the equivalence relation:instance : Neg Z where\n  neg :=\n    Quotient.lift neg' <| by\n      intro n k equiv\n      apply Quotient.sound\n      simp only [· ≈ ·, Setoid.r, Z.eq] at *\n      omega\nSimilarly, Quotient.lift₂ is useful for defining binary functions from a quotient type.\nAddition is defined point-wise:def add' (n k : Nat × Nat) : Z :=\n  .mk (n.1 + k.1, n.2 + k.2)\nLifting it to the quotient requires a proof that addition respects the equivalence relation:instance : Add Z where\n  add (n : Z) :=\n    n.lift₂ add' <| by\n      intro n k n' k'\n      intro heq heq'\n      apply Quotient.sound\n      cases n; cases k; cases n'; cases k'\n      simp_all only [· ≈ ·, Setoid.r, Z.eq]\n      omega\n\n\nWhen the function's result type is a subsingleton, Quotient.recOnSubsingleton or Quotient.recOnSubsingleton₂ can be used to define the function.\nBecause all elements of a subsingleton are equal, such a function automatically respects the equivalence relation, so there is no proof obligation.\n\nAn alternative recursion or induction principle for quotients that can be used when the target type\nis a subsingleton, in which all elements are equal.In these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.Quotient.rec does not assume that the target type is a subsingleton.\n\nAn alternative induction or recursion operator for defining binary operations on quotients that can\nbe used when the target type is a subsingleton.In these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.\n\n","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Quotient API","header":"4.5.4.2. Eliminating Quotients","id":"/The-Type-System/Quotients/#quotient-elim"}});