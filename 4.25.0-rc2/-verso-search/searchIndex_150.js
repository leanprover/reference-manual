window.docContents[150].resolve({"/Basic-Types/Arrays/#array-runtime":{"contents":"Lean's arrays are dynamic arrays, which are blocks of continuous memory with a defined capacity, not all of which is typically in use.\nAs long as the number of elements in the array is less than the capacity, new items can be added to the end without reallocating or moving the data.\nAdding items to an array that has no extra space results in a reallocation that doubles the capacity.\nThe amortized overhead scales linearly with the size of the array.\nThe values in the array are represented as described in the section on the foreign function interface.\n\nMemory layout of arrays \n\nAfter the object header, an array contains:\n\n size\n\nThe number of objects currently stored in the array\n\n capacity\n\nThe number of objects that fit in the memory allocated for the array\n\n data\n\nThe values in the array\n\n\n\nMany array functions in the Lean runtime check whether they have exclusive access to their argument by consulting the reference count in the object header.\nIf they do, and the array's capacity is sufficient, then the existing array can be mutated rather than allocating fresh memory.\nOtherwise, a new array must be allocated.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays","header":"19.16.2. Run-Time Representation","id":"/Basic-Types/Arrays/#array-runtime"},"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-Floating-Point-Numbers":{"contents":"Obtains a Float whose value is near the given ISize.It will be exactly the value of the given ISize if such a Float exists. If no such Float\nexists, the returned value will either be the smallest Float that is larger than the given value,\nor the largest Float that is smaller than the given value.This function does not reduce in the kernel.\n\nObtains a Float32 whose value is near the given ISize.It will be exactly the value of the given ISize if such a Float32 exists. If no such Float32\nexists, the returned value will either be the smallest Float32 that is larger than the given\nvalue, or the largest Float32 that is smaller than the given value.This function does not reduce in the kernel.\n\nObtains the Float whose value is the same as the given Int8.This function does not reduce in the kernel.\n\nObtains the Float32 whose value is the same as the given Int8.This function does not reduce in the kernel.\n\nObtains the Float whose value is the same as the given Int16.This function does not reduce in the kernel.\n\nObtains the Float32 whose value is the same as the given Int16.This function does not reduce in the kernel.\n\nObtains the Float whose value is the same as the given Int32.This function does not reduce in the kernel.\n\nObtains a Float32 whose value is near the given Int32.It will be exactly the value of the given Int32 if such a Float32 exists. If no such Float32\nexists, the returned value will either be the smallest Float32 that is larger than the given\nvalue, or the largest Float32 that is smaller than the given value.This function does not reduce in the kernel.\n\nObtains a Float whose value is near the given Int64.It will be exactly the value of the given Int64 if such a Float exists. If no such Float\nexists, the returned value will either be the smallest Float that is larger than the given value,\nor the largest Float that is smaller than the given value.This function does not reduce in the kernel.\n\nObtains a Float32 whose value is near the given Int64.It will be exactly the value of the given Int64 if such a Float32 exists. If no such Float32\nexists, the returned value will either be the smallest Float32 that is larger than the given\nvalue, or the largest Float32 that is smaller than the given value.This function does not reduce in the kernel.\n\nObtains a Float whose value is near the given USize.It will be exactly the value of the given USize if such a Float exists. If no such Float\nexists, the returned value will either be the smallest Float that is larger than the given value,\nor the largest Float that is smaller than the given value.This function is opaque in the kernel, but is overridden at runtime with an efficient\nimplementation.\n\nObtains a Float32 whose value is near the given USize.It will be exactly the value of the given USize if such a Float32 exists. If no such Float32\nexists, the returned value will either be the smallest Float32 that is larger than the given\nvalue, or the largest Float32 that is smaller than the given value.This function is opaque in the kernel, but is overridden at runtime with an efficient\nimplementation.\n\nObtains the Float whose value is the same as the given UInt8.\n\nObtains the Float32 whose value is the same as the given UInt8.\n\nObtains the Float whose value is the same as the given UInt16.\n\nObtains the Float32 whose value is the same as the given UInt16.\n\nObtains the Float whose value is the same as the given UInt32.\n\nObtains a Float32 whose value is near the given UInt32.It will be exactly the value of the given UInt32 if such a Float32 exists. If no such Float32\nexists, the returned value will either be the smallest Float32 that is larger than the given\nvalue, or the largest Float32 that is smaller than the given value.This function is opaque in the kernel, but is overridden at runtime with an efficient\nimplementation.\n\nObtains a Float whose value is near the given UInt64.It will be exactly the value of the given UInt64 if such a Float exists. If no such Float\nexists, the returned value will either be the smallest Float that is larger than the given value,\nor the largest Float that is smaller than the given value.This function is opaque in the kernel, but is overridden at runtime with an efficient\nimplementation.\n\nObtains a Float32 whose value is near the given UInt64.It will be exactly the value of the given UInt64 if such a Float32 exists. If no such Float32\nexists, the returned value will either be the smallest Float32 that is larger than the given\nvalue, or the largest Float32 that is smaller than the given value.This function is opaque in the kernel, but is overridden at runtime with an efficient\nimplementation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","header":"19.4.4.3.4. To Floating-Point Numbers","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-Floating-Point-Numbers"},"/Definitions/Recursive-Definitions/#reducibility":{"contents":"While checking proofs and programs, Lean takes reducibility, also known as transparency, into account.\nA definition's reducibility controls the contexts in which it is unfolded during elaboration and proof execution.\n\nThere are three levels of reducibility:\n\n Reducible\n\nReducible definitions are unfolded essentially everywhere, on demand.\n  Type class instance synthesis, definitional equality checks, and the rest of the language treat the definition as being essentially an abbreviation.\n  This is the setting applied by the abbrev command.\n\n Semireducible\n\nSemireducible definitions are not unfolded by potentially expensive automation such as type class instance synthesis or simp, but they are unfolded while checking definitional equality and while resolving generalized field notation.\n  The def command generally creates semireducible definitions unless a different reducibility level is specified with an attribute; however, definitions that use well-founded recursion are irreducible by default.\n\n Irreducible\n\nIrreducible definitions are not unfolded at all during elaboration.\n  Definitions can be made irreducible by applying the irreducible attribute.\n\n\n\nReducibility and Instance SynthesisThese three aliases for String are respectively reducible, semireducible, and irreducible.abbrev Phrase := String\n\ndef Clause := String\n\n@[irreducible]\ndef Utterance := String\nThe reducible and semireducible aliases are unfolded during the elaborator's definitional equality check, causing them to be considered equivalent to String:def hello : Phrase := \"Hello\"\n\ndef goodMorning : Clause := \"Good morning\"\nThe irreducible alias, on the other hand, is rejected as the type for a string, because the elaborator's definitional equality test does not unfold it:def goodEvening : Utterance := \"Good evening\"\nType mismatch\n  \"Good evening\"\nhas type\n  String\nbut is expected to have type\n  Utterance\nBecause Phrase is reducible, the ToString String instance can be used as a ToString Phrase instance:#synth ToString Phrase\nHowever, Clause is semireducible, so the ToString String instance cannot be used:#synth ToString Clause\nfailed to synthesize\n  ToString Clause\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nThe instance can be explicitly enabled by creating a ToString Clause instance that reduces to the ToString String instance.\nThis example works because semireducible definitions are unfolded while checking definitional equality:instance : ToString Clause := inferInstanceAs (ToString String)\n\n\nReducibility and Generalized Field NotationGeneralized field notation unfolds reducible and semireducible declarations while searching for matching names.\nGiven the semireducible alias Sequence for List:def Sequence := List\n\ndef Sequence.ofList (xs : List α) : Sequence α := xs\ngeneralized field notation allows List.reverse to be accessed from a term of type Sequence Nat.#check let xs : Sequence Nat := .ofList [1,2,3]; xs.reverse\nHowever, declaring Sequence to be irreducible prevents the unfolding:attribute [irreducible] Sequence\n\n#check let xs : Sequence Nat := .ofList [1,2,3]; xs.reverse\nInvalid field `reverse`: The environment does not contain `Sequence.reverse`\n  xs\nhas type\n  Sequence Nat\n\n\nReducibility AnnotationsA definition's reducibility can be set using one of the three reducibility attributes:These attributes can only be applied globally in the same file as the definition being modified, but they may be locally applied anywhere.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.6. Controlling Reduction","id":"/Definitions/Recursive-Definitions/#reducibility"},"/Functors___-Monads-and--do--Notation/#monads-and-do":{"contents":"The type classes Functor, Applicative, and Monad provide fundamental tools for functional programming.An introduction to programming with these abstractions is available in Functional Programming in Lean.\nWhile they are inspired by the concepts of functors and monads in category theory, the versions used for programming are more limited.\nThe type classes in Lean's standard library represent the concepts as used for programming, rather than the general mathematical definition.\n\nInstances of Functor allow an operation to be applied consistently throughout some polymorphic context.\nExamples include transforming each element of a list by applying a function and creating new IO actions by arranging for a pure function to be applied to the result of an existing IO action.\nInstances of Monad allow side effects with data dependencies to be encoded; examples include using a tuple to simulate mutable state, a sum type to simulate exceptions, and representing actual side effects with IO.\nApplicative functors occupy a middle ground: like monads, they allow functions computed with effects to be applied to arguments that are computed with effects, but they do not allow sequential data dependencies where the output of an effect forms an input into another effectful operation.\n\nThe additional type classes Pure, Bind, SeqLeft, SeqRight, and Seq capture individual operations from Applicative and Monad, allowing them to be overloaded and used with types that are not necessarily Applicative functors or Monads.\nThe Alternative type class describes applicative functors that additionally have some notion of failure and recovery.\n\nA functor in the sense used in functional programming, which means a function f : Type u → Type v\nhas a way of mapping a function over its contents. This map operator is written <$>, and\noverloaded via Functor instances.This map function should respect identity and function composition. In other words, for all terms\nv : f α, it should be the case that:* id <$> v = v* For all functions h : β → γ and g : α → β, (h ∘ g) <$> v = h <$> g <$> vWhile all Functor instances should live up to these requirements, they are not required to prove\nthat they do. Proofs may be required or provided via the LawfulFunctor class.Assuming that instances are lawful, this definition corresponds to the category-theoretic notion of\nfunctor in the special case where the category is the\ncategory of types and functions between them.Applies a function inside a functor. This is used to overload the <$> operator.When mapping a constant function, use Functor.mapConst instead, because it may be more\nefficient.Conventions for notations in identifiers:* The recommended spelling of <$> in identifiers is map.Mapping a constant function.Given a : α and v : f α, mapConst a v is equivalent to Function.const _ a <$> v. For some\nfunctors, this can be implemented more efficiently; for all other functors, the default\nimplementation may be used.\n\nThe pure function is overloaded via Pure instances.Pure is typically accessed via Monad or Applicative instances.Given a : α, then pure a : f α represents an action that does nothing and returns a.Examples:* (pure \"hello\" : Option String) = some \"hello\"* (pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"* (pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)\n\nThe <*> operator is overloaded using the function Seq.seq.While <$> from the class Functor allows an ordinary function to be mapped over its contents,\n<*> allows a function that's “inside” the functor to be applied. When thinking about f as\npossible side effects, this captures evaluation order: seq arranges for the effects that produce\nthe function to occur prior to those that produce the argument value.For most applications, Applicative or Monad should be used rather than Seq itself.The implementation of the <*> operator.In a monad, mf <*> mx is the same as do let f ← mf; x ← mx; pure (f x): it evaluates the\nfunction first, then the argument, and applies one to the other.To avoid surprising evaluation semantics, mx is taken \"lazily\", using a Unit → f α function.Conventions for notations in identifiers:* The recommended spelling of <*> in identifiers is seq.\n\nThe <* operator is overloaded using seqLeft.When thinking about f as potential side effects, <* evaluates first the left and then the right\nargument for their side effects, discarding the value of the right argument and returning the value\nof the left argument.For most applications, Applicative or Monad should be used rather than SeqLeft itself.Sequences the effects of two terms, discarding the value of the second. This function is usually\ninvoked via the <* operator.Given x : f α and y : f β, x <* y runs x, then runs y, and finally returns the result of\nx.The evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from f.Conventions for notations in identifiers:* The recommended spelling of <* in identifiers is seqLeft.\n\nThe *> operator is overloaded using seqRight.When thinking about f as potential side effects, *> evaluates first the left and then the right\nargument for their side effects, discarding the value of the left argument and returning the value\nof the right argument.For most applications, Applicative or Monad should be used rather than SeqLeft itself.Sequences the effects of two terms, discarding the value of the first. This function is usually\ninvoked via the *> operator.Given x : f α and y : f β, x *> y runs x, then runs y, and finally returns the result of\ny.The evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from f.Conventions for notations in identifiers:* The recommended spelling of *> in identifiers is seqRight.\n\nAn applicative functor is more powerful than a Functor, but\nless powerful than a Monad.Applicative functors capture sequencing of effects with the <*> operator, overloaded as seq, but\nnot data-dependent effects. The results of earlier computations cannot be used to control later\neffects.Applicative functors should satisfy four laws. Instances of Applicative are not required to prove\nthat they satisfy these laws, which are part of the LawfulApplicative class.\n\nLists with Lengths as Applicative FunctorsThe structure LenList pairs a list with a proof that it has the desired length.\nAs a consequence, its zipWith operator doesn't require a fallback in case the lengths of its inputs differ.structure LenList (length : Nat) (α : Type u) where\n  list : List α\n  lengthOk : list.length = length\n\ndef LenList.head (xs : LenList (n + 1) α) : α :=\n  xs.list.head <| by\n    intro h\n    cases xs\n    simp_all\n    subst_eqs\n\ndef LenList.tail (xs : LenList (n + 1) α) : LenList n α :=\n  match xs with\n  | ⟨_ :: xs', _⟩ => ⟨xs', by simp_all⟩\n\ndef LenList.map (f : α → β) (xs : LenList n α) : LenList n β where\n  list := xs.list.map f\n  lengthOk := by\n    cases xs\n    simp [List.length_map, *]\n\ndef LenList.zipWith (f : α → β → γ)\n    (xs : LenList n α) (ys : LenList n β) :\n    LenList n γ where\n  list := xs.list.zipWith f ys.list\n  lengthOk := by\n    cases xs; cases ys\n    simp [List.length_zipWith, *]\nThe well-behaved Applicative instance applies functions to arguments element-wise.\nBecause Applicative extends Functor, a separate Functor instance is not necessary, and map can be defined as part of the Applicative instance.instance : Applicative (LenList n) where\n  map := LenList.map\n  pure x := {\n    list := List.replicate n x\n    lengthOk := List.length_replicate\n  }\n  seq {α β} fs xs := fs.zipWith (· ·) (xs ())\nThe well-behaved Monad instance takes the diagonal of the results of applying the function:@[simp]\ntheorem LenList.list_length_eq (xs : LenList n α) :\n    xs.list.length = n := by\n  cases xs\n  simp [*]\n\ndef LenList.diagonal (square : LenList n (LenList n α)) : LenList n α :=\n  match n with\n  | 0 => ⟨[], rfl⟩\n  | n' + 1 => {\n    list :=\n      square.head.head :: (square.tail.map (·.tail)).diagonal.list\n    lengthOk := by simp\n  }\n\n\nAn Alternative functor is an Applicative functor that can \"fail\" or be \"empty\"\nand a binary operation <|> that “collects values” or finds the “left-most success”.Important instances include* Option, where failure := none and <|> returns the left-most some.* Parser combinators typically provide an Applicative instance for error-handling and\nbacktracking.Error recovery and state can interact subtly. For example, the implementation of Alternative for OptionT (StateT σ Id) keeps modifications made to the state while recovering from failure, while StateT σ (OptionT Id) discards them.Produces an empty collection or recoverable failure.  The <|> operator collects values or recovers\nfrom failures. See Alternative for more details.Depending on the Alternative instance, collects values or recovers from failures by\nreturning the leftmost success. Can be written using the <|> operator syntax.\n\nThe >>= operator is overloaded via instances of bind.Bind is typically used via Monad, which extends it.Sequences two computations, allowing the second to depend on the value computed by the first.If x : m α and f : α → m β, then x >>= f : m β represents the result of executing x to get\na value of type α and then passing it to f.Conventions for notations in identifiers:* The recommended spelling of >>= in identifiers is bind.\n\nMonads are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.The Monad API may be used directly. However, it is most commonly accessed through\ndo-notation.Most Monad instances provide implementations of pure and bind, and use default implementations\nfor the other methods inherited from Applicative. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of LawfulMonad expresses that a given\nmonad's operations are lawful.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"14. Functors, Monads and  do -Notation","id":"/Functors___-Monads-and--do--Notation/#monads-and-do"},"/Interacting-with-Lean/#hash-synth":{"contents":"Synthesizing InstancesThe #synth command attempts to synthesize an instance for the provided class.\nIf it succeeds, then the resulting instance term is output.\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.4. Synthesizing Instances","id":"/Interacting-with-Lean/#hash-synth"},"/The-Type-System/Inductive-Types/#structure-constructors":{"contents":"Structure constructors may be explicitly named by providing the constructor name and :: prior to the fields.\nIf no name is explicitly provided, then the constructor is named mk in the structure type's namespace.\nDeclaration modifiers may additionally be provided along with an explicit constructor name.\n\nNon-default constructor nameThe structure  Palindrome contains a string and a proof that the string is the same when reversed:structure Palindrome where\n  ofString ::\n  text : String\n  is_palindrome : text.data.reverse = text.data\nIts constructor is named Palindrome.ofString, rather than Palindrome.mk.\n\nModifiers on structure constructorThe structure NatStringBimap maintains a finite bijection between natural numbers and strings.\nIt consists of a pair of maps, such that the keys each occur as values exactly once in the other map.\nBecause the constructor is private, code outside the defining module can't construct new instances and must use the provided API, which maintains the invariants of the type.\nAdditionally, providing the default constructor name explicitly is an opportunity to attach a documentation comment to the constructor.structure NatStringBimap where\n  /--\n  Build a finite bijection between some\n  natural numbers and strings\n  -/\n  private mk ::\n  natToString : Std.HashMap Nat String\n  stringToNat : Std.HashMap String Nat\n\ndef NatStringBimap.empty : NatStringBimap := ⟨{}, {}⟩\n\ndef NatStringBimap.insert\n    (nat : Nat) (string : String)\n    (map : NatStringBimap) :\n    Option NatStringBimap :=\n  if map.natToString.contains nat ||\n      map.stringToNat.contains string then\n    none\n  else\n    some <|\n      NatStringBimap.mk\n        (map.natToString.insert nat string)\n        (map.stringToNat.insert string nat)\n\n\nBecause structures are represented by single-constructor inductive types, their constructors can be invoked or matched against using anonymous constructor syntax.\nAdditionally, structures may be constructed or matched against using structure instance notation, which includes the names of the fields together with values for them.\n\nStructure InstancesConstructs a value of a constructor type given values for named fields.\nField specifiers may take two forms:A structInstLVal is a field name (an identifier), a field index (a natural number), or a term in square brackets, followed by a sequence of zero or more subfields.\nSubfields are either a field name or index preceded by a dot, or a term in square brackets.This syntax is elaborated to applications of structure constructors.\nThe values provided for fields are by name, and they may be provided in any order.\nThe values provided for subfields are used to initialize fields of constructors of structures that are themselves found in fields.\nTerms in square brackets are not allowed when constructing a structure; they are used in structure updates.Field specifiers that do not contain := are field abbreviations.\nIn this context, the identifier f is an abbreviation for f := f; that is, the value of f in the current scope is used to initialize the field f.Every field that does not have a default value must be provided.\nIf a tactic is specified as the default argument, then it is run at elaboration time to construct the argument's value.In a pattern context, field names are mapped to patterns that match the corresponding projection, and field abbreviations bind a pattern variable that is the field's name.\nDefault arguments are still present in patterns; if a pattern does not specify a value for a field with a default value, then the pattern only matches the default.The optional type annotation allows the structure type to be specified in contexts where it is not otherwise determined.\n\nPatterns and default valuesThe structure AugmentedIntList contains a list together with some extra information, which is empty if omitted:structure AugmentedIntList where\n  list : List Int\n  augmentation : String := \"\"\nWhen testing whether the list is empty, the function isEmpty is also testing whether the augmentation field is empty, because the omitted field's default value is also used in pattern contexts:def AugmentedIntList.isEmpty : AugmentedIntList → Bool\n  | {list := []} => true\n  | _ => false\n\n#eval {list := [], augmentation := \"extra\" : AugmentedIntList}.isEmpty\nfalse\n\n\nStructure UpdatesUpdates a value of a constructor type.\nThe term that precedes the with clause is expected to have a structure type; it is the value that is being updated.\nA new instance of the structure is created in which every field not specified is copied from the value that is being updated, and the specified fields are replaced with their new values.\nWhen updating a structure, array values may also be replaced by including the index to be updated in square brackets.\nThis updating does not require that the index expression be in bounds for the array, and out-of-bounds updates are discarded.\n\nUpdating arraysUpdating structures may use array indices as well as projection names.\nUpdates at indices that are out of bounds are ignored:structure AugmentedIntArray where\n  array : Array Int\n  augmentation : String := \"\"\nderiving Repr\n\ndef one : AugmentedIntArray := {array := #[1]}\ndef two : AugmentedIntArray := {one with array := #[1, 2]}\ndef two' : AugmentedIntArray := {two with array[0] := 2}\ndef two'' : AugmentedIntArray := {two with array[99] := 3}\n#eval (one, two, two', two'')\n({ array := #[1], augmentation := \"\" },\n { array := #[1, 2], augmentation := \"\" },\n { array := #[2, 2], augmentation := \"\" },\n { array := #[1, 2], augmentation := \"\" })\n\n\nValues of structure types may also be declared using where, followed by definitions for each field.\nThis may only be used as part of a definition, not in an expression context.\n\nwhere for structuresThe product type in Lean is a structure named Prod.\nProducts can be defined using their projections:def location : Float × Float where\n  fst := 22.807\n  snd := -13.923\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Structure Declarations","header":"4.4.2.3. Structure Constructors","id":"/The-Type-System/Inductive-Types/#structure-constructors"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Parallelizing-Elaboration":{"contents":"* #6770 enables code generation to proceed in parallel to further\nelaboration.* #6988 ensures interrupting the kernel does not lead to wrong, sticky\nerror messages in the editor* #7047 removes the save and checkpoint tactics that have been\nsuperseded by incremental elaboration* #7076 introduces the central parallelism API for ensuring that helper\ndeclarations can be generated lazily without duplicating work or\ncreating conflicts across threads.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"Parallelizing Elaboration","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Parallelizing-Elaboration"}});