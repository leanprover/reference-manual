window.docContents[254].resolve({"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Options":{"contents":"For performance, the elaborator and many tactics construct indices and caches.\nMany of these take reducibility into account, and there's no way to invalidate and regenerate them if reducibility changes globally.\nUnsafe changes to reducibility settings that could have unpredictable results are disallowed by default, but they can be enabled by using the allowUnsafeReducibility option.\n\nenables users to modify the reducibility settings for declarations even when such changes are deemed potentially hazardous. For example, simp and type class resolution maintain term indices where reducible declarations are expanded.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Controlling Reduction","header":"7.6.6.3. Options","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Options"},"/Interacting-with-Lean/#format-repr":{"contents":"The Repr type class is used to provide a standard representation for data that can be parsed and evaluated to obtain an equivalent value.\nThis is not a strict correctness criterion: for some types, especially those with embedded propositions, it is impossible to achieve.\nHowever, the output produced by a Repr instance should be as close as possible to something that can be parsed and evaluated.\n\nIn addition to being machine-readable, this representation should be convenient for humans to understand—in particular, lines should not be too long, and nested values should be indented.\nThis is achieved through a two-step process:1. The Repr instance produces an intermediate document of type Std.Format, which compactly represents a set of strings that differ with respect to the placement of newlines and indentation.2. A rendering process selects the “best” representative from the set, according to criteria such as a desired maximum line length.In particular, Std.Format can be built compositionally, so Repr instances don't need to take the surrounding indentation context into account.\n\n\n\n\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.7. Formatted Output","id":"/Interacting-with-Lean/#format-repr"},"/Notations-and-Macros/Defining-New-Syntax/#syntax-data":{"contents":"Lean's parser produces a concrete syntax tree, of type Lean.Syntax.\nLean.Syntax is an inductive type that represents all of Lean's syntax, including commands, terms, tactics, and any custom extensions.\nAll of these are represented by a few basic building blocks:\n\n Atoms\n\nAtoms are the fundamental terminals of the grammar, including literals (such as those for characters and numbers), parentheses, operators, and keywords.\n\n Identifiers\n\nIdentifiers represent names, such as x, Nat, or Nat.add.\n  Identifier syntax includes a list of pre-resolved names that the identifier might refer to.\n\n Nodes\n\nNodes represent the parsing of nonterminals.\n  Nodes contain a syntax kind, which identifies the syntax rule that the node results from, along with an array of child Syntax values.\n\n Missing Syntax\n\nWhen the parser encounters an error, it returns a partial result, so Lean can provide some feedback about partially-written programs or programs that contain mistakes.\n  Partial results contain one or more instances of missing syntax.\n\n\n\nAtoms and identifiers are collectively referred to as tokens.\n\nLean syntax trees.Syntax trees are used pervasively throughout Lean: they are produced by the parser, transformed by\nthe macro expander, and elaborated. They are also produced by the delaborator and presented to\nusers.A portion of the syntax tree that is missing because of a parse error.The indexing operator on Syntax also returns Syntax.missing when the index is out of bounds.A node in the syntax tree that may have further syntax as child nodes. The node's kind\ndetermines its interpretation.For nodes produced by the parser, the info field is typically Lean.SourceInfo.none, and source\ninformation is stored in the corresponding fields of identifiers and atoms. This field is used in\ntwo ways:1. The delaborator uses it to associate nodes with metadata that are used to implement\ninteractive features.2. Nodes created by quotations use the field to mark the syntax as synthetic (storing the result\nof Lean.SourceInfo.fromRef) even when its leading or trailing tokens are not.A non-identifier atomic component of syntax.All of the following are atoms:* keywords, such as def, fun, and inductive* literals, such as numeric or string literals* punctuation and delimiters, such as (, ), and =>.Identifiers are represented by the Lean.Syntax.ident constructor. Atoms also correspond to\nquoted strings inside syntax declarations.An identifier.In addition to source information, identifiers have the following fields:* rawVal is the literal substring from the input file* val is the parsed Lean name, potentially including macro scopes.* preresolved is the list of possible declarations this could refer to, populated by\nquotations.\n\nA possible binding of an identifier in the context in which it was quoted.Identifiers in quotations may refer to either global declarations or to namespaces that are in scope\nat the site of the quotation. These are saved in the Syntax.ident constructor and are part of the\nimplementation of hygienic macros.A potential namespace referenceA potential global constant or section variable reference, with additional field accesses\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.1. Syntax Model","id":"/Notations-and-Macros/Defining-New-Syntax/#syntax-data"},"/The-Type-System/Quotients/#quotient-api":{"contents":"The quotient API relies on a pre-existing Setoid instance.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.4. Quotient API","id":"/The-Type-System/Quotients/#quotient-api"},"/Type-Classes/Class-Declarations/#class-abbrev":{"contents":"In some cases, many related type classes may co-occur throughout a codebase.\nRather than writing all the names repeatedly, it would be possible to define a class that extends all the classes in question, contributing no new methods itself.\nHowever, this new class has a disadvantage: its instances must be declared explicitly.\n\nThe class abbrev command allows the creation of class abbreviations in which one name is short for a number of other class parameters.\nBehind the scenes, a class abbreviation is represented by a class that extends all the others.\nIts constructor is additionally declared to be an instance so the new class can be constructed by instance synthesis alone.\n\nClass AbbreviationsBoth plusTimes1 and plusTimes2 require that their parameters' type have Add and Mul instances:class abbrev AddMul (α : Type u) := Add α, Mul α\n\ndef plusTimes1 [AddMul α] (x y z : α) := x + y * z\n\nclass AddMul' (α : Type u) extends Add α, Mul α\n\ndef plusTimes2 [AddMul' α] (x y z : α) := x + y * z\nBecause AddMul is a class abbrev, no additional declarations are necessary to use plusTimes1 with Nat:#eval plusTimes1 2 5 7\n37\nHowever, plusTimes2 fails, because there is no AddMul' Nat instance—no instances whatsoever have yet been declared:#eval plusTimes2 2 5 7\nfailed to synthesize\n  AddMul' ?m.22\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nDeclaring a very general instance takes care of the problem for Nat and every other type:instance [Add α] [Mul α] : AddMul' α where\n\n#eval plusTimes2 2 5 7\n37\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Class Declarations","header":"11.1.2. Class Abbreviations","id":"/Type-Classes/Class-Declarations/#class-abbrev"},"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Instance-Search-Summary":{"contents":"Generally speaking, instance synthesis is a recursive search procedure that may, in general, backtrack arbitrarily.\nSynthesis may succeed with an instance term, fail if no such term can be found, or get stuck if there is insufficient information.\nA detailed description of the instance synthesis algorithm is available in .\nAn instance search problem is given by a type class applied to concrete arguments; these argument values may or may not be known.\nInstance search attempts every locally-bound variable whose type is a class, as well as each registered instance, in order of priority and definition.\nWhen candidate instances themselves have instance-implicit parameters, they impose further synthesis tasks.\n\nA problem is only attempted when all of the input parameters to the type class are known.\nWhen a problem cannot yet be attempted, then that branch is stuck; progress in other subproblems may result in the problem becoming solvable.\nOutput or semi-output parameters may be either known or unknown at the start of instance search.\nOutput parameters are ignored when checking whether an instance matches the problem, while semi-output parameters are considered.\n\nEvery candidate solution for a given problem is saved in a table; this prevents infinite regress in case of cycles as well as exponential search overheads in the presence of diamonds (that is, multiple paths by which the same goal can be achieved).\nA branch of the search fails when any of the following occur:\n\n* All potential instances have been attempted, and the search space is exhausted.* The instance size limit specified by the option synthInstance.maxSize is reached.* The synthesized value of an output parameter does not match the specified value in the search problem.\nFailed branches are not retried.\n\nIf search would otherwise fail or get stuck, the search process attempts to use matching default instances in order of priority.\nFor default instances, the input parameters do not need to be fully known, and may be instantiated by the instances parameter values.\nDefault instances may take instance-implicit parameters, which induce further recursive search.\n\nSuccessful branches in which the problem is fully known (that is, in which there are no unsolved metavariables) are pruned, and further potentially-successful instances are not attempted, because no later instance could cause the previously-succeeding branch to fail.\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.1. Instance Search Summary","id":"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Instance-Search-Summary"}});