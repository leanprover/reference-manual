window.docContents[42].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic--Signed-Operations":{"contents":"Returns the absolute value of a signed bitvector.\n\nNegation of bitvectors. This can be interpreted as either signed or unsigned negation modulo 2^n.\nUsually accessed via the - prefix operator.SMT-LIB name: bvneg.\n\nSigned T-division (using the truncating rounding convention) for bitvectors. This function obeys the\nLean convention that division by zero returns zero.Examples:* (7#4).sdiv 2 = 3#4* (-9#4).sdiv 2 = -4#4* (5#4).sdiv -2 = -2#4* (-7#4).sdiv (-2) = 3#4\n\nSigned division for bitvectors using the SMT-LIB using the\nSMT-LIB convention,\nwhere division by zero returns BitVector.allOnes n.Specifically, x.smtSDiv 0 = if x >= 0 then -1 else 1SMT-LIB name: bvsdiv.\n\nRemainder for signed division rounded to negative infinity.SMT-LIB name: bvsmod.\n\nRemainder for signed division rounding to zero.SMT-LIB name: bvsrem.\n\nChecks whether addition of x and y results in signed overflow, treating x and y as 2's\ncomplement signed bitvectors.SMT-LIB name: bvsaddo.\n\nChecks whether the subtraction of x and y results in signed overflow, treating x and y as\n2's complement signed bitvectors.SMT-Lib name: bvssubo.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference\u0009Arithmetic","header":"19.5.5.8.2. Signed Operations","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic--Signed-Operations"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Boundaries":{"contents":"A UTF-8 byte position that points at the end of a string, just after the last character.* \"abc\".endPos = ⟨3⟩* \"L∃∀N\".endPos = ⟨8⟩\n\nReturns true if a specified byte position is greater than or equal to the position which points to\nthe end of a string. Otherwise, returns false.Examples:* (0 |> \"abc\".next |> \"abc\".next |> \"abc\".atEnd) = false* (0 |> \"abc\".next |> \"abc\".next |> \"abc\".next |> \"abc\".next |> \"abc\".atEnd) = true* (0 |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".atEnd) = false* (0 |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".atEnd) = true* \"abc\".atEnd ⟨4⟩ = true* \"L∃∀N\".atEnd ⟨7⟩ = false* \"L∃∀N\".atEnd ⟨8⟩ = true\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"19.8.4.5.2. Boundaries","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Boundaries"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Utilities":{"contents":"The Current DirectoryA macro that expands to the path of package's directory\nduring the Lakefile's elaboration.\n\nConfiguration OptionsA macro that expands to the specified configuration option (or none,\nif the option has not been set) during the Lakefile's elaboration.Configuration arguments are set either via the Lake CLI (by the -K option)\nor via the with clause in a require statement.\n\nCompile-Time ConditionalsThe meta if command has two forms:meta if <c:term> then <a:command>\nmeta if <c:term> then <a:command> else <b:command>\nIt expands to the command a if the term c evaluates to true\n(at elaboration time). Otherwise, it expands to command b (if an else\nclause is provided).One can use this command to specify, for example, external library targets\nonly available on specific platforms:meta if System.Platform.isWindows then\nextern_lib winOnlyLib := ...\nelse meta if System.Platform.isOSX then\nextern_lib macOnlyLib := ...\nelse\nextern_lib linuxOnlyLib := ...\n\n\nCommand SequencesThe do command syntax groups multiple similarly indented commands together.\nThe group can then be passed to another command that usually only accepts a\nsingle command (e.g., meta if).\n\nCompile-Time Side EffectsExecutes a term of type IO α at elaboration-time\nand produces an expression corresponding to the result via ToExpr α.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"22.1.3.2.7. Utilities","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Utilities"},"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent--Examples":{"contents":"Insufficient type informationdef reverseDuplicate (xs : List α) :=\n  .reverse (xs ++ xs)\n<invalid output>def reverseDuplicate (xs : List α) : List α :=\n  .reverse (xs ++ xs)\nBecause the return type of reverseDuplicate is not specified, the expected type of .reverse\ncannot be determined. Lean will not use the type of the argument xs ++ xs to infer the omitted\nnamespace. Adding the return type List α allows Lean to infer the type of .reverse and thus the\nappropriate namespace (List) in which to resolve this identifier.Note that this means that changing the return type of reverseDuplicate changes how .reverse\nresolves: if the return type is  T, then Lean will (attempt to) resolve .reverse to a function\nT.reverse whose return type is T—even if T.reverse does not take an argument of type\nList α.\n\nDotted identifier where type universe expectedexample (n : Nat) :=\n  match n > 42 with\n  | .true  => n - 1\n  | .false => n + 1\n<invalid output>example (n : Nat) :=\n  match decide (n > 42) with\n  | .true  => n - 1\n  | .false => n + 1\nThe proposition n > 42 has type Prop, which, being a type universe, does not support\ndotted-identifier notation. As this example demonstrates, attempting to use this notation in such a\ncontext is almost always an error. The intent in this example was for .true and .false to be\nBooleans, not propositions; however, match expressions do not automatically perform this coercion\nfor decidable propositions. Explicitly adding decide makes the discriminant a Bool and allows\nthe dotted-identifier resolution to succeed.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.invalidDottedIdent","header":"Examples","id":"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent--Examples"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Files-and-Directories":{"contents":"Returns the current working directory of the executing process.\n\nReturns the file name of the currently-running executable.\n\nReturns the directory that the current executable is located in.\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.6. Files and Directories","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Files-and-Directories"},"/Notations-and-Macros/Macros/#macro-monad-hygiene":{"contents":"Hygiene is implemented by adding macro scopes to the identifiers that occur in syntax.\nOrdinarily, the process of quotation adds all necessary scopes, but macros that construct syntax directly must add macro scopes to the identifiers that they introduce.\n\nIncrements the macro scope counter so that inside the body of x the macro\nscope is fresh.\n\nAdd a new macro scope to the name n.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009The Macro Monad","header":"20.5.2.2. Hygiene-Related Operations","id":"/Notations-and-Macros/Macros/#macro-monad-hygiene"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Other":{"contents":"* #6285 upstreams the ToLevel typeclass from mathlib and uses it to\nfix the existing ToExpr instances so that they are truly universe\npolymorphic (previously it generated malformed expressions when the\nuniverse level was nonzero). We improve on the mathlib definition of\nToLevel to ensure the class always lives in Type, irrespective of\nthe universe parameter.* #6363 fixes errors at load time in the comparison mode of the Firefox\nprofiler.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Other","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Other"},"/releases/v4.16.0/#release-v4___16___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.16.0 (2025-02-03)","id":"/releases/v4.16.0/#release-v4___16___0"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Pretty-Printing":{"contents":"* #7954 improves pp.oneline, where it now preserves tags when\ntruncating formatted syntax to a single line. Note that the [...]\ncontinuation does not yet have any functionality to enable seeing the\nuntruncated syntax. Closes #3681.* #8617 fixes (1) an issue where private names are not unresolved when\nthey are pretty printed, (2) an issue where in pp.universes mode names\nwere allowed to shadow local names, (3) an issue where in match\npatterns constants shadowing locals wouldn't use _root_, and (4) an\nissue where tactics might have an incorrect \"try this\" when\npp.fullNames is set. Adds more delaboration tests for name\nunresolution.* #8626 closes #3791, making sure that the Syntax formatter inserts\nwhitespace before and after comments in the leading and trailing text of\nSyntax to avoid having comments comment out any following syntax, and to\navoid comments' lexical syntax from being interpreted as being part of\nanother syntax. If the text contains newlines before or after any\ncomments, they are formatted as hard newlines rather than soft newlines.\nFor example, -- comments will have a hard newline after them. Note:\nmetaprograms generating Syntax with comments should be sure to include\nnewlines at the ends of -- comments.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Pretty Printing","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Pretty-Printing"},"/releases/v4.25.0/#release-v4___25___0":{"contents":"For this release, 398 changes landed. In addition to the 141 feature additions and 83 fixes listed below there were 21 refactoring changes, 9 documentation improvements, 4 performance improvements, 5 improvements to the test suite and 135 other changes.\n\n* #10483 completes support for injective functions in grind. See\nexamples:/-! Add some injectivity theorems. -/\n\ndef double (x : Nat) := 2*x\n\n@[grind inj] theorem double_inj : Function.Injective double := by\n  grind [Function.Injective, double]\n\nstructure InjFn (α : Type) (β : Type) where\n  f : α → β\n  h : Function.Injective f\n\ninstance : CoeFun (InjFn α β) (fun _ => α → β) where\n  coe s := s.f\n\n@[grind inj] theorem fn_inj (F : InjFn α β) : Function.Injective (F : α → β) := by\n  grind [Function.Injective, cases InjFn]\n\ndef toList (a : α) : List α := [a]\n\n@[grind inj] theorem toList_inj : Function.Injective (toList : α → List α) := by\n  grind [Function.Injective, toList]\n\n/-! Examples -/\n\nexample (x y : Nat) : toList (double x) = toList (double y) → x = y := by\n  grind\n\nexample (f : InjFn (List Nat) α) (x y z : Nat)\n    : f (toList (double x)) = f (toList y) →\n      y = double z →\n      x = z := by\n  grind\n* #10486 adds and expands grind related docstrings.* #10529 adds some helper theorems for the upcoming grind order solver.* #10553 implements infrastructure for the new grind order module.* #10562 simplifies the grind order module, and internalizes the order\nconstraints. It removes the Offset type class because it introduced\ntoo much complexity. We now cover the same use cases with a simpler\napproach:* Any type that implements at least Std.IsPreorder* Arbitrary ordered rings.* Nat by the Nat.ToInt adapter.* #10583 allows users to declare additional grind constraint\npropagators for declarations that already include propagators in core.* #10589 adds helper theorems for implementing  grind order* #10590 implements proof term construction for grind order.* #10594 implements proof construction for theory propagation in grind order.* #10596 implements the function for adding new edges to the graph used\nby grind order. The graph maintains the transitive closure of all\nasserted constraints.* #10598 implements support for positive constraints in grind order.\nThe new module can already solve problems such as:example [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsPreorder α]\n    (a b c : α) : a ≤ b → b ≤ c → c < a → False := by\n  grind\n\nexample [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsPreorder α]\n    (a b c d : α) : a ≤ b → b ≤ c → c < d → d ≤ a → False := by\n  grind\n\nexample [LE α] [Std.IsPreorder α]\n    (a b c : α) : a ≤ b → b ≤ c → a ≤ c := by\n  grind\n\nexample [LE α] [Std.IsPreorder α]\n    (a b c d : α) : a ≤ b → b ≤ c → c ≤ d → a ≤ d := by\n  grind\n* #10599 fixes the support for Nat in grind order. This module uses\nthe Nat.ToInt adapter.* #10600 implements support for negative constraints in grind order.\nExamples:open Lean Grind\nexample [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsLinearPreorder α]\n    (a b c d : α) : a ≤ b → ¬ (c ≤ b) → ¬ (d ≤ c) → d < a → False := by\n  grind -linarith (splits := 0)\n\nexample [LE α] [Std.IsLinearPreorder α]\n    (a b c d : α) : a ≤ b → ¬ (c ≤ b) → ¬ (d ≤ c) → ¬ (a ≤ d) → False := by\n  grind -linarith (splits := 0)\n\nexample [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsLinearPreorder α] [CommRing α] [OrderedRing α]\n    (a b c d : α) : a - b ≤ 5 → ¬ (c ≤ b) → ¬ (d ≤ c + 2) → d ≤ a - 8 → False := by\n  grind -linarith (splits := 0)\n* #10601 fixes a panic in grind order when order is not a partial\norder.* #10604 implements the method processNewEq in grind order. It is\nresponsible for processing equalities propagated by the grind E-graph.\n\n* #10607 adds infrastructure for the upcoming grind tactic mode, which\nwill be similar to the conv mode. The goal is to extend grind from a\nterminal tactic into an interactive mode: grind => ….* #10677 implements the basic tactics for the new grind interactive\nmode. While many additional grind tactics will be added later, the\nfoundational framework is already operational. The following grind\ntactics are currently implemented: skip, done, finish, lia, and\nring.\nalso removes the notion of grind fallback procedure since it\nis subsumed by the new framework. Examples:example (x y : Nat) : x ≥ y + 1 → x > 0 := by\n  grind => skip; lia; done\n* #10679 fixes an issue where \"Invalid alternative name\" errors from\ninduction stick around after removing the offending alternative.* #10690 adds the instantiate, show_true, show_false,\nshow_asserted, and show_eqcs tactics for the grind interactive\nmode. The show tactic take an optional \"filter\" and are used to probe\nthe grind state. Example:example (as bs cs : Array α) (v₁ v₂ : α)\n        (i₁ i₂ j : Nat)\n        (h₁ : i₁ < as.size)\n        (h₂ : bs = as.set i₁ v₁)\n        (h₃ : i₂ < bs.size)\n        (h₃ : cs = bs.set i₂ v₂)\n        (h₄ : i₁ ≠ j ∧ i₂ ≠ j)\n        (h₅ : j < cs.size)\n        (h₆ : j < as.size)\n        : cs[j] = as[j] := by\n  grind =>\n    instantiate\n    -- Display asserted facts with `generation > 0`\n    show_asserted gen > 0\n    -- Display propositions known to be `True`, containing `j`, and `generation > 0`\n    show_true j && gen > 0\n    -- Display equivalence classes with terms that contain `as` or `bs`\n    show_eqcs as || bs\n    instantiate\n* #10695 fixes an issue where non-macro members of a mutual block\nwere discarded if there was at least one macro present.* #10706 adds the have tactic for the grind interactive mode.\nExample:example {a b c d e : Nat}\n    : a > 0 → b > 0 → 2*c + e <= 2 → e = d + 1 → a*b + 2 > 2*c + d := by\n  grind =>\n    have : a*b > 0 := Nat.mul_pos h h_1\n    lia\n* #10707 ensures the finish tactic in grind interactive mode fails\nand reports diagnostics when goal is not closed.* #10709 implements anchors (also known as stable hash codes) for\nreferencing terms occurring in a grind goal. It also introduces the\ncommands show_splits and show_state. The former displays the anchors\nfor candidate case splits in the current grind goal.* #10715 improves anchor stability (aka stable hash codes) used to\nreference terms in a grind goal.\n\n* #10731 adds the following tactics to the grind interactive mode:* focus <grind_tac_seq>* next => <grind_tac_seq>* any_goals <grind_tac_seq>* all_goals <grind_tac_seq>* grind_tac <;> grind_tac* cases <anchor>* tactic => <tac_seq>* #10737 adds the tactics linarith, ac, fail, first, try,\nfail_if_success, and admit to grind interactive mode.* #10740 improves the tactics ac, linarith, lia, ring tactics in\ngrind interactive mode. They now fail if no progress has been made.\nThey also generate an info message with counterexample/basis if the goal\nwas not closed.* #10746 implements parameters for the instantiate tactic in the\ngrind interactive mode. Users can now select both global and local\ntheorems. Local theorems are selected using anchors. It also adds the\nshow_thms tactic for displaying local theorems. Example:example (as bs cs : Array α) (v₁ v₂ : α)\n        (i₁ i₂ j : Nat)\n        (h₁ : i₁ < as.size)\n        (h₂ : bs = as.set i₁ v₁)\n        (h₃ : i₂ < bs.size)\n        (h₃ : cs = bs.set i₂ v₂)\n        (h₄ : i₁ ≠ j ∧ i₂ ≠ j)\n        (h₅ : j < cs.size)\n        (h₆ : j < as.size)\n        : cs[j] = as[j] := by\n  grind =>\n    instantiate = Array.getElem_set\n    instantiate Array.getElem_set\n\n\n* #10747 implements infrastructure for finish? and grind? tactics.* #10748 implements the repeat tactical for the grind interactive\nmode.* #10767 implements the new control interface for implementing grind\nsearch strategies. It will replace the SearchM framework.* #10778 ensures that grind interactive mode is hygienic. It also adds\ntactics for renaming inaccessible names: rename_i h_1 ... h_n and\nnext h_1 ... h_n => .., and expose_names for automatically generated\ntactic scripts. The PR also adds helper functions for implementing\ncase-split actions.* #10779 implements hover information for grind anchors. Anchors are\nstable hash codes for referencing terms in the grind state. The anchors\nwill be used when auto generating tactic scripts.* #10791 adds a silent info message with the grind state in its\ninteractive mode. The message is shown only when there is exactly one\ngoal in the grind interactive mode. The condition is a workaround for\ncurrent limitations of our InfoTree.* #10798 implements the grind actions intro, intros, assertNext,\nassertAll.* #10801 implements the splitNext action for grind.* #10808 implements support for compressing auto-generated grind tactic\nsequences.\n\n* #10811 implements proper case-split anchor generation in the\nsplitNext action, which will be used to implement grind? and\nfinish?.* #10812 implements lia, linarith, and ac actions for grind\ninteractive mode.* #10824 implements the cases? tactic for the grind interactive mode.\nIt provides a convenient way to select anchors. Users can filter the\ncandidates using the filter language.* #10828 implements a compact notation for inspecting the grind state\nin interactive mode. Within a grind tactic block, each tactic may\noptionally have a suffix of the form | filter?.* #10833 implements infrastructure for evaluating grind tactics in the\nGrindM monad. We are going to use it to check whether auto-generated\ntactics can effectively close the original goal.* #10834 implements the ring action for grind.* #10836 implements support for Action in the grind solver extensions\n(SolverExtension). It also provides the Solvers.mkAction function\nthat constructs an Action using all registered solvers. The generated\naction is \"fair,\" that is, a solver cannot prevent other solvers from\nmaking progress.* #10837 implements the finish? tactic for the grind interactive\nmode. When it successfully closes the goal, it produces a code action\nthat allows the user to close the goal using explicit grind tactic\nsteps, i.e., without any search. It also makes explicit which solvers\nhave been used.* #10841 improves the grind tactic generated by the instantiate\naction in tracing mode. It also updates the syntax for the instantiate\ntactic, making it similar to simp. For example:* instantiate only [thm1, thm2] instantiates only theorems thm1 and\nthm2.* instantiate [thm1, thm2] instantiates theorems marked with the\n@[grind] attribute and theorems thm1 and thm2.* #10843 implements the set_option tactic in grind interactive mode.* #10846 fixes a few issues on instance only [...] tactic generation at\nfinish?.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.25.0-rc2 (2025-10-22)","id":"/releases/v4.25.0/#release-v4___25___0"}});