window.docContents[208].resolve({"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Conversions":{"contents":"Converts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans\u0009API Reference","header":"19.11.4.3. Conversions","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Conversions"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Conversions":{"contents":"Converts a packed array of bytes to a linked list.\n\nInterprets a ByteArray of size 8 as a big-endian UInt64.Panics if the array's size is not 8.\n\nInterprets a ByteArray of size 8 as a little-endian UInt64.Panics if the array's size is not 8.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.4. Conversions","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Conversions"},"/Basic-Types/Integers/#int-div":{"contents":"The Div Int and Mod Int instances implement Euclidean division, described in the reference for Int.ediv.\nThis is not, however, the only sensible convention for rounding and remainders in division.\nFour pairs of division and modulus functions are available, implementing various conventions.\n\nDivision by 0In all integer division conventions, division by 0 is defined to be 0:#eval Int.ediv 5 0\n#eval Int.ediv 0 0\n#eval Int.ediv (-5) 0\n#eval Int.bdiv 5 0\n#eval Int.bdiv 0 0\n#eval Int.bdiv (-5) 0\n#eval Int.fdiv 5 0\n#eval Int.fdiv 0 0\n#eval Int.fdiv (-5) 0\n#eval Int.tdiv 5 0\n#eval Int.tdiv 0 0\n#eval Int.tdiv (-5) 0\nAll evaluate to 0.0\n\n\nInteger division that uses the E-rounding convention. Usually accessed via the / operator.\nDivision by zero is defined to be zero, rather than an error.In the E-rounding convention (Euclidean division), Int.emod x y satisfies 0 ≤ Int.emod x y < Int.natAbs y\nfor y ≠ 0 and Int.ediv is the unique function satisfying Int.emod x y + (Int.ediv x y) * y = x\nfor y ≠ 0.This means that Int.ediv x y is ⌊x / y⌋ when y > 0 and ⌈x / y⌉ when y < 0.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* (7 : Int) / (0 : Int) = 0* (0 : Int) / (7 : Int) = 0* (12 : Int) / (6 : Int) = 2* (12 : Int) / (-6 : Int) = -2* (-12 : Int) / (6 : Int) = -2* (-12 : Int) / (-6 : Int) = 2* (12 : Int) / (7 : Int) = 1* (12 : Int) / (-7 : Int) = -1* (-12 : Int) / (7 : Int) = -2* (-12 : Int) / (-7 : Int) = 2\n\nInteger modulus that uses the E-rounding convention. Usually accessed via the % operator.In the E-rounding convention (Euclidean division), Int.emod x y satisfies 0 ≤ Int.emod x y < Int.natAbs y\nfor y ≠ 0 and Int.ediv is the unique function satisfying Int.emod x y + (Int.ediv x y) * y = x\nfor y ≠ 0.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* (7 : Int) % (0 : Int) = 7* (0 : Int) % (7 : Int) = 0* (12 : Int) % (6 : Int) = 0* (12 : Int) % (-6 : Int) = 0* (-12 : Int) % (6 : Int) = 0* (-12 : Int) % (-6 : Int) = 0* (12 : Int) % (7 : Int) = 5* (12 : Int) % (-7 : Int) = 5* (-12 : Int) % (7 : Int) = 2* (-12 : Int) % (-7 : Int) = 2\n\nInteger division using the T-rounding convention.In the T-rounding convention (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0. In this convention, Int.tmod a b + b * (Int.tdiv a b) = a.This function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.Examples:* (7 : Int).tdiv (0 : Int) = 0* (0 : Int).tdiv (7 : Int) = 0* (12 : Int).tdiv (6 : Int) = 2* (12 : Int).tdiv (-6 : Int) = -2* (-12 : Int).tdiv (6 : Int) = -2* (-12 : Int).tdiv (-6 : Int) = 2* (12 : Int).tdiv (7 : Int) = 1* (12 : Int).tdiv (-7 : Int) = -1* (-12 : Int).tdiv (7 : Int) = -1* (-12 : Int).tdiv (-7 : Int) = 1\n\nInteger modulo using the T-rounding convention.In the T-rounding convention (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0 and Int.tmod a 0 = a.In this convention, Int.tmod a b + b * (Int.tdiv a b) = a. Additionally,\nInt.natAbs (Int.tmod a b) = Int.natAbs a % Int.natAbs b, and when b does not divide a,\nInt.tmod a b has the same sign as a.This function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.Examples:* (7 : Int).tmod (0 : Int) = 7* (0 : Int).tmod (7 : Int) = 0* (12 : Int).tmod (6 : Int) = 0* (12 : Int).tmod (-6 : Int) = 0* (-12 : Int).tmod (6 : Int) = 0* (-12 : Int).tmod (-6 : Int) = 0* (12 : Int).tmod (7 : Int) = 5* (12 : Int).tmod (-7 : Int) = 5* (-12 : Int).tmod (7 : Int) = -5* (-12 : Int).tmod (-7 : Int) = -5\n\nBalanced division.This returns the unique integer so that b * (Int.bdiv a b) + Int.bmod a b = a.Examples:* (7 : Int).bdiv 0 = 0* (0 : Int).bdiv 7 = 0* (12 : Int).bdiv 6 = 2* (12 : Int).bdiv 7 = 2* (12 : Int).bdiv 8 = 2* (12 : Int).bdiv 9 = 1* (-12 : Int).bdiv 6 = -2* (-12 : Int).bdiv 7 = -2* (-12 : Int).bdiv 8 = -1* (-12 : Int).bdiv 9 = -1\n\nBalanced modulus.This version of integer modulus uses the balanced rounding convention, which guarantees that\n-m / 2 ≤ Int.bmod x m < m/2 for m ≠ 0 and Int.bmod x m is congruent to x modulo m.If m = 0, then Int.bmod x m = x.Examples:* (7 : Int).bmod 0 = 7* (0 : Int).bmod 7 = 0* (12 : Int).bmod 6 = 0* (12 : Int).bmod 7 = -2* (12 : Int).bmod 8 = -4* (12 : Int).bmod 9 = 3* (-12 : Int).bmod 6 = 0* (-12 : Int).bmod 7 = 2* (-12 : Int).bmod 8 = -4* (-12 : Int).bmod 9 = -3\n\nInteger division using the F-rounding convention.In the F-rounding convention (flooring division), Int.fdiv x y satisfies Int.fdiv x y = ⌊x / y⌋\nand Int.fmod is the unique function satisfying Int.fmod x y + (Int.fdiv x y) * y = x.Examples:* (7 : Int).fdiv (0 : Int) = 0* (0 : Int).fdiv (7 : Int) = 0* (12 : Int).fdiv (6 : Int) = 2* (12 : Int).fdiv (-6 : Int) = -2* (-12 : Int).fdiv (6 : Int) = -2* (-12 : Int).fdiv (-6 : Int) = 2* (12 : Int).fdiv (7 : Int) = 1* (12 : Int).fdiv (-7 : Int) = -2* (-12 : Int).fdiv (7 : Int) = -2* (-12 : Int).fdiv (-7 : Int) = 1\n\nInteger modulus using the F-rounding convention.In the F-rounding convention (flooring division), Int.fdiv x y satisfies Int.fdiv x y = ⌊x / y⌋\nand Int.fmod is the unique function satisfying Int.fmod x y + (Int.fdiv x y) * y = x.Examples:* (7 : Int).fmod (0 : Int) = 7* (0 : Int).fmod (7 : Int) = 0* (12 : Int).fmod (6 : Int) = 0* (12 : Int).fmod (-6 : Int) = 0* (-12 : Int).fmod (6 : Int) = 0* (-12 : Int).fmod (-6 : Int) = 0* (12 : Int).fmod (7 : Int) = 5* (12 : Int).fmod (-7 : Int) = -2* (-12 : Int).fmod (7 : Int) = 2* (-12 : Int).fmod (-7 : Int) = -5\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference\u0009Arithmetic","header":"19.2.4.3.1. Division","id":"/Basic-Types/Integers/#int-div"},"/Basic-Types/Strings/#string-api-compare":{"contents":"The LT String instance is defined by the lexicographic ordering on strings based on the LT Char instance.\nLogically, this is modeled by the lexicographic ordering on the lists that model strings, so List.Lex defines the order.\nIt is decidable, and the decision procedure is overridden at runtime with efficient code that takes advantage of the run-time representation of strings.\n\nNon-strict inequality on strings, typically used via the ≤ operator.a ≤ b is defined to mean ¬ b < a.\n\nReturns the first position where the two strings differ.If one string is a prefix of the other, then the returned position is the end position of the\nshorter string. If the strings are identical, then their end position is returned.Examples:* \"tea\".firstDiffPos \"ten\" = ⟨2⟩* \"tea\".firstDiffPos \"tea\" = ⟨3⟩* \"tea\".firstDiffPos \"teas\" = ⟨3⟩* \"teas\".firstDiffPos \"tea\" = ⟨3⟩\n\nChecks whether the first string (p) is a prefix of the second (s).String.startsWith is a version that takes the potential prefix after the string.Examples:* \"red\".isPrefixOf \"red green blue\" = true* \"green\".isPrefixOf \"red green blue\" = false* \"\".isPrefixOf \"red green blue\" = true\n\nChecks whether the first string (s) begins with the second (pre).String.isPrefix is a version that takes the potential prefix before the string.Examples:* \"red green blue\".startsWith \"red\" = true* \"red green blue\".startsWith \"green\" = false* \"red green blue\".startsWith \"\" = true* \"red\".startsWith \"red\" = true\n\nChecks whether the first string (s) ends with the second (post).Examples:* \"red green blue\".endsWith \"blue\" = true* \"red green blue\".endsWith \"green\" = false* \"red green blue\".endsWith \"\" = true* \"red\".endsWith \"red\" = true\n\nDecides whether two strings are equal. Normally used via the DecidableEq String instance and the\n= operator.At runtime, this function is overridden with an efficient native implementation.\n\nComputes a hash for strings.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.8. Comparisons","id":"/Basic-Types/Strings/#string-api-compare"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-in-Continuation-Passing-Style":{"contents":"Continuation-passing-style state monads represent stateful computations as functions that, for any type whatsoever, take an initial state and a continuation (modeled as a function) that accepts a value and an updated state.\nAn example of such a type is (δ : Type u) → σ → (α → σ → δ) → δ, though StateCpsT is a transformer that can be applied to any monad.\nState monads in continuation passing style have different performance characteristics than tuple-based state monads; for some applications, it may be worth benchmarking them.\n\n\n\nAn alternative implementation of a state monad transformer that internally uses continuation passing\nstyle instead of tuples.\n\nRuns an action from the underlying monad in the monad with state. The state is not modified.This function is typically implicitly accessed via a MonadLiftT instance as part of automatic\nlifting.\n\nRuns a stateful computation that's represented using continuation passing style by providing it with\nan initial state and a continuation.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value, discarding the final state.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value paired with the final state.While the state is internally represented in continuation passing style, the resulting value is the\nsame as for a non-CPS state monad.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009State","header":"14.5.4.3. State Monads in Continuation Passing Style","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-in-Continuation-Passing-Style"}});