window.docContents[146].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Modification":{"contents":"Inserts the given element into the set. If the hash set already contains an element that is\nequal (with regard to ==) to the given element, then the hash set is returned unchanged.Note: this non-replacement behavior is true for ExtHashSet and ExtHashSet.Raw.\nThe insert function on ExtHashMap, DExtHashMap, ExtHashMap.Raw and DExtHashMap.Raw behaves\ndifferently: it will overwrite an existing mapping.\n\nInserts multiple mappings into the hash set by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the first occurrence takes precedence.Note: this precedence behavior is true for ExtHashSet and ExtHashSet.Raw. The insertMany function on\nExtHashMap, DExtHashMap, ExtHashMap.Raw and DExtHashMap.Raw behaves differently: it will prefer the last\nappearance.\n\nRemoves the element if it exists.\n\nRemoves all elements from the hash set for which the given function returns false.\n\nChecks whether an element is present in a set and inserts the element if it was not found.\nIf the hash set already contains an element that is equal (with regard to ==) to the given\nelement, then the hash set is returned unchanged.Equivalent to (but potentially faster than) calling contains followed by insert.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Sets","header":"19.18.7.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Modification"},"/Notations-and-Macros/Macros/#quote-patterns":{"contents":"Quasiquotations can be used in pattern matching to recognize syntax that matches a template.\nJust as antiquotations in a quotation that's used as a term are regions that are treated as ordinary non-quoted expressions, antiquotations in patterns are regions that are treated as ordinary Lean patterns.\nQuote patterns are compiled differently from other patterns, so they can't be intermixed with non-quote patterns in a single match expression.\nLike ordinary quotations, quote patterns are first processed by Lean's parser.\nThe parser's output is then compiled into code that determines whether there is a match.\nSyntax matching assumes that the syntax being matched was produced by Lean's parser, either via quotation or directly in user code, and uses this to omit some checks.\nFor example, if nothing but a particular keyword can be present in a given position, the check may be omitted.\n\nSyntax matches a quote pattern in the following cases:\n\n Atoms\n\nKeyword atoms (such as if or match) result in singleton nodes whose kind is token. followed by the atom.\n  In many cases, it is not necessary to check for specific atom values because the grammar allows only a single keyword, and no checking will be performed.\n  If the syntax of the term being matched requires the check, then the node kind is compared.Literals, such as string or numeric literals, are compared via their underlying string representation.\n  The pattern `(0x15) and the quotation `(21) do not match.\n\n Nodes\n\nIf both the pattern and the value being matched represent Syntax.node, there is a match when both have the same syntax kind, the same number of children, and each child pattern matches the corresponding child value.\n\n Identifiers\n\nIf both the pattern and the value being matched are identifiers, then their literal Name values are compared for equality modulo macro scopes.\n  Identifiers that “look” the same match, and it does not matter if they refer to the same binding.\n  This design choice allows quote pattern matching to be used in contexts that don't have access to a compile-time environment in which names can be compared by reference.\n\n\n\nBecause quotation pattern matching is based on the node kinds emitted by the parser, quotations that look identical may not match if they come from different syntax categories.\nIf in doubt, including the syntax category in the quotation can help.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros","header":"20.5.4. Matching Syntax","id":"/Notations-and-Macros/Macros/#quote-patterns"},"/Type-Classes/Instance-Synthesis/#instance-synth-parameters":{"contents":"The search process for instances is largely governed by class parameters.\nType classes take a certain number of parameters, and instances are tried during the search when their choice of parameters is compatible with those in the class type for which the instance is being synthesized.\n\nInstances themselves may also take parameters, but the role of instances' parameters in instance synthesis is very different.\nInstances' parameters represent either variables that may be instantiated by instance synthesis or further synthesis work to be done before the instance can be used.\nIn particular, parameters to instances may be explicit, implicit, or instance-implicit.\nIf they are instance implicit, then they induce further recursive instance searching, while explicit or implicit parameters must be solved by unification.\n\nImplicit and Explicit Parameters to InstancesWhile instances typically take parameters either implicitly or instance-implicitly, explicit parameters may be filled out as if they were implicit during instance synthesis.\nIn this example, aNonemptySumInstance is found by synthesis, applied explicitly to Nat, which is needed to make it type-correct.instance aNonemptySumInstance\n    (α : Type) {β : Type} [inst : Nonempty α] :\n    Nonempty (α ⊕ β) :=\n  let ⟨x⟩ := inst\n  ⟨.inl x⟩\nset_option pp.explicit true in\n#synth Nonempty (Nat ⊕ Empty)\nIn the output, both the explicit argument Nat and the implicit argument Empty were found by unification with the search goal, while the Nonempty Nat instance was found via recursive instance synthesis.@aNonemptySumInstance Nat Empty (@instNonemptyOfInhabited Nat instInhabitedNat)\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.4. Instance Parameters and Synthesis","id":"/Type-Classes/Instance-Synthesis/#instance-synth-parameters"}});