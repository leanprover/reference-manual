window.docContents[72].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map, and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.If the returned Bool is true, then the returned map is unaltered. If the Bool is false, then\nthe returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the hash map for which the given function returns false.\n\nUpdates the values of the hash map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.Note: this replacement behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insert function on HashSet and HashSet.Raw behaves differently: it will return the set\nunchanged if a matching key is already present.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nInserts multiple mappings into the hash map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insertMany function on HashSet and HashSet.Raw behaves differently: it will prefer the first\nappearance.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Dependent Hash Maps","header":"19.18.5.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Modification"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets":{"contents":"Targets are typically added to the set of default targets by applying the default_target attribute, rather than by explicitly listing them.\n\n\n\nSpecifying Default TargetsMarks a target as a default, to be built when no other target is specified.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"22.1.3.2.4. Targets","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets"},"/Interacting-with-Lean/#repr":{"contents":"A Repr instance describes how to represent a value as a Std.Format.\nBecause they should emit valid Lean syntax, these instances need to take precedence into account.\nInserting the maximal number of parentheses would work, but it makes it more difficult for humans to read the resulting output.\n\nThe standard way of turning values of some type into Format.When rendered this Format should be as close as possible to something that can be parsed as the\ninput value.Turn a value of type α into a Format at a given precedence. The precedence value can be used\nto avoid parentheses if they are not necessary.\n\nTurns a into a Format using its Repr instance. The precedence level is initially set to 0.\n\nTurns a into a String using its Repr instance, rendering the Format at the default width of\n120 columns.The precedence level is initially set to 0.\n\nMaximal ParenthesesThe type NatOrInt can contain a Nat or an Int:inductive NatOrInt where\n  | nat : Nat → NatOrInt\n  | int : Int → NatOrInt\nThis Repr NatOrInt instance ensures that the output is valid Lean syntax by inserting many parentheses:instance : Repr NatOrInt where\n  reprPrec x _ :=\n    .nestD <| .group <|\n      match x with\n      | .nat n =>\n          .text \"(\" ++ \"NatOrInt.nat\" ++ .line ++ \"(\" ++ repr n ++ \"))\"\n      | .int i =>\n          .text \"(\" ++ \"NatOrInt.int\" ++ .line ++ \"(\" ++ repr i ++ \"))\"\nWhether it contains a Nat, a non-negative Int, or a negative Int, the result can be parsed:open NatOrInt in\n#eval do\n  IO.println <| repr <| nat 3\n  IO.println <| repr <| int 5\n  IO.println <| repr <| int (-5)\n(NatOrInt.nat (3))\n(NatOrInt.int (5))\n(NatOrInt.int (-5))\nHowever, (NatOrInt.nat (3)) is not particularly idiomatic Lean, and redundant parentheses can make it difficult to read large expressions.\n\nThe method Repr.reprPrec has the following signature:\n\nRepr.reprPrec.{u} {α : Type u} [Repr α] : α → Nat → Std.Format\n\n\nThe first explicit parameter is the value to be represented, while the second is the precedence of the context in which it occurs.\nThis precedence can be used to decide whether to insert parentheses: if the precedence of the syntax being produced by the instance is greater than that of its context, parentheses are necessary.\n\n\n\n\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output","header":"3.7.2. Repr","id":"/Interacting-with-Lean/#repr"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Language":{"contents":"* #6973 stops dsimp from visiting proof terms, which should make\nsimp and dsimp more efficient.* #7428 adds a dsimp cache to simp. Previously each dsimp call from simp started with a fresh cache. As a result, time spent in simp while compiling Mathlib is reduced by over 45%, giving an overall 8% speedup to Mathlib compilation.* #7631 fixes Lean.Level.mkIMaxAux (mk_imax in the kernel) such that\nimax 1 u reduces to u.* #7977 adds basic support for eta-reduction to grind.* #8002 fixes an issue where \"go to definition\" for variables\ngeneralized by the induction and cases tactic did not work. Closes\n#2873.* #8024 adds the --setup option to the lean CLI. It takes a path to\na JSON file containing information about a module's imports and\nconfiguration, superseding that in the module's own file header. This\nwill be used by Lake to specify paths to module artifacts (e.g., oleans\nand ileans) separate from the LEAN_PATH schema.* #8037 introduces a noConfusionType construction that’s sub-quadratic\nin size, and reduces faster.* #8104 makes fun_induction and fun_cases (try to) unfold the\nfunction application of interest in the goal. The old behavior can be\nenabled with set_option tactic.fun_induction.unfolding false. For\nfun_cases this does not work yet when the function’s result type\ndepends on one of the arguments, see issue #8296.* #8106 adds a register_linter_set command for declaring linter sets.\nThe getLinterValue function now checks if the present linter is\ncontained in a set that has been enabled (using the set_option command\nor on the command line).* #8169 makes the whitespace handling in the syntax of omit and\ninclude consistent with variable.* #8171 omits cases from functional induction/cases principles that are\nimplemented by contradiction (or, more generally, False.elim,\nabsurd or `noConfusion). Breaking change in the sense that there are\nfewer goals to prove after using functional induction.* #8196 improves the E-matching pattern inference procedure in grind.\nConsider the following theorem:@[grind →]\ntheorem eq_empty_of_append_eq_empty {xs ys : Array α} (h : xs ++ ys = #[]) : xs = #[] ∧ ys = #[] :=\n  append_eq_empty_iff.mp h\nBefore this PR, grind inferred the following pattern:@HAppend.hAppend _ _ _ _ #2 #1\nNote that this pattern would match any ++ application, even if it had\nnothing to do with arrays. With this PR, the inferred pattern becomes:@HAppend.hAppend (Array #3) (Array _) (Array _) _ #2 #1\nWith the new pattern, the theorem will not be considered by grind for\ngoals that do not involve Arrays.* #8198 fixes an issue in the theory propagation used in grind. When\ntwo equivalence classes are merged, the core may need to push additional\nequalities or disequalities down to the satellite theory solvers (e.g.,\ncutsat, comm ring, etc). Some solvers (e.g. cutsat) assume that\nall of the core’s invariants hold before they receive those facts.\nPropagating immediately therefore risks violating a solver’s\npre-conditions midway through the merge. To decouple the merge operation\nfrom propagation and to keep the core solver-agnostic, this PR adds the\nhelper type PendingTheoryPropagation.* #8208 reduces the need for defeq in frequently used bv_decide rewrite\nby turning them into simprocs that work on structural equality instead.\nAs the intended meaning of these rewrites is to simply work with\nstructural equality anyways this should not change the proving power of\nbv_decide's rewriter but just make it faster on certain very large\nproblems.* #8209 fixes a nondeterminism issue in the grind tactic. It was a bug\nin the model-based theory combination module.* #8221 adjusts the experimental module system to not export the bodies\nof defs unless opted out by the new attribute @[expose] on the def\nor on a surrounding section.* #8224 adds diagnostic information for the commutative ring procedure\nin grind.* #8226 fixes the simplifyBasis procedure in the commutative ring\nprocedure in grind.* #8231 changes the behaviour of apply? so that the sorry it uses to\nclose the goal is non-synthetic. (Recall that correct use of synthetic\nsorries requires that the tactic also generates an error message, which\nwe don't want to do in this situation.) This change defends against the problem reported in #8212.* #8232 fixes elaboration of constants in the rewrite tactic.\npreviously, rw [eq_self] would elaborate eq_self twice, and add it\nto the infotree twice. This would lead to the \"Expected type\" being\ndelaborated with an unknown universe metavariable.* #8241 changes the behavior of the rename tactic to skip over\nimplementation detail hypotheses when finding a hypothesis to rename.* #8254 fixes unintended inlining of ToJson, FromJson, and Repr\ninstances, which was causing exponential compilation times in deriving\nclauses for large structures.* #8259 clarifies the invalid field notation error when projected value\ntype is a metavariable.* #8260 clarifies the invalid dotted identifier notation error when the\ntype is a sort.* #8261 adjusts the error message when apply fails to unify. It is\nclearer about distinguishing the term being applied and the goal, as\nwell as distinguishing the \"conclusion\" of the given term and the term\nitself.* #8262 improves the type-as-hole error message. Type-as-hole error for\ntheorem declarations should not admit the possibility of omitting the\ntype entirely.* #8264 rewords the application type mismatch error message by more\nspecifically mentioning that the problem is with the final argument.\nThis is useful when the same argument is passed to the function multiple\ntimes.* #8267 makes #guard_msgs to treat trace messages separate from\ninfo, warning and error. It also introduce the ability to say\n#guard_msgs (pass info, like (drop info) so far, and also adds\n(check info) as the explicit form of (info), for completeness.* #8270 makes the enum pass of bv_decide handle enum types that are\nuniverse polymorphic.* #8271 changes addPPExplicitToExposeDiff to show universe differences\nand to visit into projections, e.g.:error: tactic 'rfl' failed, the left-hand side\n  (Test.mk (∀ (x : PUnit.{1}), True)).1\nis not definitionally equal to the right-hand side\n  (Test.mk (∀ (x : PUnit.{2}), True)).1\nforinductive Test where\n  | mk (x : Prop)\n\n* #8275 ensures the congruence closure in grind and find non-dependent\narrow congruences. That is, it can apply the implies_congr theorem.* #8276 adds the instances Grind.CommRing (Fin n) and Grind.IsCharP (Fin n) n. New tests:example (x y z : Fin 13) :\n    (x + y + z) ^ 2 = x ^ 2 + y ^ 2 + z ^ 2 + 2 * (x * y + y * z + z * x) := by\n  grind +ring\n\n* #8277 improves the generation of .induct_unfolding by rewriting\nmatch statements more reliably, using the new “congruence equations”\nintroduced in #8284. Fixes #8195.* #8280 the support for arrows in the congruence closure procedure used\nin grind.* #8281 improves the module used to prove auxiliary type cast equalities\nin grind.* #8284 adds a new variant of equations for matchers, namely “congruence\nequations” that generalize the normal matcher equations. They have\nunrestricted left-hand-sides, extra equality assumptions relating the\ndiscriminiants with the patterns and thus prove heterogenous equalities.\nIn that sense they combine congruence with rewriting. They can be used\nto rewrite matcher applications where, due to dependencies, simp would\nfail to rewrite the discriminants, and will be used when producing the\nunfolding induction theorems.* #8285 fixes “declaration has free variables” errors when generating a\nsplitter for a match statement with named patterns. Fixes #8274.* #8299 implements a missing preprocessing step in grind: abstract\nmetavariables in the goal* #8301 unfolds functions in the unfolding induction principle properly\nwhen they use bif (a.k.a. Bool.cond).* #8302 lets cases fail gracefully when the motive has an complex\nargument whose type is dependent type on the targets. While the\ninduction tactic can handle this well, cases does not. This change\nat least gracefully degrades to not instantiating that motive parameter.\nSee issue #8296 for more details on this issue.* #8303 fixes missing occurrences of foldProjs in grind.* #8306 makes it possible for bv_decide to tackle situations for its\nenum type preprocessing where the enums themselves are use in a\ndependently type context (for example inside of a GetElem body) and\nthus not trivially accessible to simp for rewriting. To do this we\ndropGetElem on BitVec as well as dite as early as possible in the\npipeline.* #8321 lets the termination argument inference consider negations of\nNat comparisons. Fixes #8257.* #8323 adds support for bv_decide to understand BitVec.reverse in\nbitblasting.* #8330 improves support for structure extensionality in grind. It now\nuses eta expansion for structures instead of the extensionality theorems\ngenerated by [ext]. Examples:opaque f (a : Nat) : Nat × Bool\n\n* #8338 improves the error messages displayed in inductive\ndeclarations when type parameters are invalid or absent.* #8341 fixes the propagateCtor constraint propagator used in grind.* #8343 splits Lean.Grind.CommRing into 4 typeclasses, for semirings\nand noncommutative rings. This does not yet change the behaviour of\ngrind, which expects to find all 4 typeclasses. Later we will make\nsome generalizations.* #8344 fixes term normalization issues in grind, and the new option\ngrind +etaStruct.* #8347 adds draft typeclasses for grind to process facts about\nordered modules. These interfaces will evolve as the implementation\ndevelops.* #8354 makes sure that when generating the unfolding functional\ninduction theorem, mdata does not get in the way.* #8356 tries harder to clean internals of the argument packing of n-ary\nfunctions from the functional induction theorem, in particular the\nunfolding variant* #8359 improves the functional cases principles, by making a more\neducated guess which function parameters should be targets and which\nshould remain parameters (or be dropped). This simplifies the\nprinciples, and increases the chance that fun_cases can unfold the\nfunction call.* #8361 fixes a bug in the cases tacic introduced in #3188 that arises\nwhen cases (not induction) is used with a non-atomic expression in using\nand the argument indexing gets confused.* #8363 unifies various ways of naming auxiliary declarations in a\nconflict-free way and ensures the method is compatible with diverging\nbranches of elaboration such as parallelism or Aesop-like\nbacktracking+replaying search.* #8365 fixes the transparency mode for ground patterns. This is\nimportant for implicit instances. Here is a mwe for an issue detected\nwhile testing grind in Mathlib.example (a : Nat) : max a a = a := by\n  grind\n\n* #8368 improves the error messages produced by invalid pattern-match\nalternatives and improves parity in error placement between\npattern-matching tactics and elaborators.* #8369 fixes a type error at instantiateTheorem function used in\ngrind. It was failing to instantiate theorems such astheorem getElem_reverse {xs : Array α} {i : Nat} (hi : i < xs.reverse.size)\n    : (xs.reverse)[i] = xs[xs.size - 1 - i]'(by simp at hi; omega)\nin examples such asexample (xs : Array Nat) (w : xs.reverse = xs) (j : Nat) (hj : 0 ≤ j) (hj' : j < xs.size / 2)\n    : xs[j] = xs[xs.size - 1 - j]\ngenerating the issue  [issue] type error constructing proof for Array.getElem_reverse\n      when assigning metavariable ?hi with\n        ‹j < xs.toList.length›\n      has type\n        j < xs.toList.length : Prop\n      but is expected to have type\n        j < xs.reverse.size : Prop\n* #8375 ensures that using mapError to expand an error message uses\naddMessageContext to include the current context, so that expressions\nare rendered correctly. Also adds a preprendError variant with a more\nconvenient argument order for the common cases of\nprepending-and-indenting.* #8403 adds missing monotonicity lemmas for universal quantifiers, that\nare used in defining (co)inductive predicates.* #8410 fixes a case-splitting heuristic in grind and simplifies the\nproof for test grind_palindrome2.lean.* #8412 fixes the markNestedProofs preprocessor used in grind. There\nwas a missing case (e.g., Expr.mdata)* #8413 implements normalization rules that pull universal quantifiers\nacross disjunctions. This is a common normalization step performed by\nfirst-order theorem provers.* #8417 introduces Lean.Grind.Field, proves that a IsCharP 0 field\nsatisfies NoNatZeroDivisors, and sets up some basic (currently\nfailing) tests for grind.* #8426 adds the attribute [grind?]. It is like [grind] but displays\ninferred E-matching patterns. It is a more convinient than writing.\nThanks @kim-em for suggesting this feature.set_option trace.grind.ematch.pattern true\nalso improves some tests, and adds helper function\nENode.isRoot.* #8429 adds Lean.Grind.Ring.IsOrdered, and cleans up the ring/module\ngrind API. These typeclasses are at present unused, but will support\nfuture algorithmic improvements in grind.* #8437 fixes split in the presence of metavariables in the target.* #8438 ensures that grind diagnostics are obtained even when\nmaxHeartbeats is reached.\nalso removes some dead code.* #8440 implements non-chronological backtracking for the grind\ntactic. This feature ensures that grind does not need to process\nirrelevant branches after performing a case-split that is not relevant.\nIt is not just about performance, but also the size of the final proof\nterm. The new test demonstrates this feature in practice.-- In the following test, the first 8 case-splits are irrelevant,\n-- and non-choronological backtracking is used to avoid searching\n-- (2^8 - 1) irrelevant branches\n/--\ntrace:\n[grind.split] p8 ∨ q8, generation: 0\n[grind.split] p7 ∨ q7, generation: 0\n[grind.split] p6 ∨ q6, generation: 0\n[grind.split] p5 ∨ q5, generation: 0\n[grind.split] p4 ∨ q4, generation: 0\n[grind.split] p3 ∨ q3, generation: 0\n[grind.split] p2 ∨ q2, generation: 0\n[grind.split] p1 ∨ q1, generation: 0\n[grind.split] ¬p ∨ ¬q, generation: 0\n-/\n#guard_msgs (trace) in\nset_option trace.grind.split true in\ntheorem ex\n    : p ∨ q →\n      ¬ p ∨ q →\n      p ∨ ¬ q →\n      ¬ p ∨ ¬ q →\n      p1 ∨ q1 →\n      p2 ∨ q2 →\n      p3 ∨ q3 →\n      p4 ∨ q4 →\n      p5 ∨ q5 →\n      p6 ∨ q6 →\n      p7 ∨ q7 →\n      p8 ∨ q8 →\n      False := by\n  grind (splits := 10)\n* #8443 adds the lemmas about ordered rings and ordered fields which\nwill be needed by the new algebraic normalization components of grind.* #8449 upstreams and extends the Mathlib clear_value tactic. Given a\nlocal definition x : T := v, the tactic clear_value x replaces it\nwith a hypothesis x : T, or throws an error if the goal does not\ndepend on the value v. The syntax clear_value x with h creates a\nhypothesis h : x = v before clearing the value of x. Furthermore,\nclear_value * clears all values that can be cleared, or throws an\nerror if none can be cleared.* #8450 adds a feature to the subst tactic so that when x : X := v\nis a local definition, subst x substitutes v for x in the goal and\nremoves x. Previously the tactic would throw an error.* #8466 fixes another instance of the grind issue \"unexpected kernel\nprojection term during internalization\".* #8472 avoids name resolution blocking on the elaboration of a\ntheorem's proof when looking up the theorem name.* #8479 implements hash-consing for grind that takes alpha equivalence\ninto account.* #8483 ensures grind reuses the simp cache between different calls.\nRecall that grind uses simp to normalize terms during\ninternalization.* #8491 fixes the behavior of simp_all? and simp_all?!, aligning\nthem with simp_all and simp_all! respectively.* #8506 implements match-expressions in grind using match\ncongruence equations. The goal is to minimize the number of cast\noperations that need to be inserted, and avoid cast over functions.\nThe new approach support match-expressions of the form match h : ... with ....* #8512 adds a value_of% ident term that elaborates to the value of\nthe local or global constant ident. This is useful for creating\ndefinition hypotheses:let x := ... complicated expression ...\nhave hx : x = value_of% x := rfl\n* #8516 is a followup to #8449 to refine the syntax of clear_value.\nThe syntax for adding equality hypotheses before clearing values is now\nclear_value (h : x = _). Any expression definitionally equal to x\ncan be used in place of the underscore.* #8536 fixes the support for LawfulBEq and BEq in grind.* #8541 ensures that for any nested proof h : p in a goal, we\npropagate that p is true in the grind tactic.* #8542 fixes two inappropriate uses of whnfD in grind. They were\npotential performance foot guns, and were producing unexpected errors\nsince whnfD is not consistently used (and it should not be) in all\nmodules.* #8544 implements support for over-applied ite and dite\napplications in the grind tactic. It adds support for propagation and\ncase-split.* #8549 fixes the hash function used to implement congruence closure in\ngrind. The hash of an Expr must not depend on whether the expression\nhas been internalized or not.* #8564 simplifies the interface between the grind core and the cutsat\nprocedure. Before this PR, core would try to minimize the number of\nnumeric literals that have to be internalized in cutsat. This\noptimization was buggy (see grind_cutsat_zero.lean test), and produced\ncounterintuitive counterexamples.* #8569 adds support for generalized E-match patterns to arbitrary\ntheorems.* #8570 fixes some issues in the E-matching generalized pattern support\nafter the update stage0.* #8572 adds some generalized Option theorems for grind . The avoid\ncasts operations during E-matching.* #8576 sets ring := true by default in grind. It also fixes a bug\nin the reification procedure, and improves the term internalization in\nthe ring and cutsat modules.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Language","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Language"}});