window.docContents[62].resolve({"/Basic-Types/Floating-Point-Numbers/#Float":{"contents":"Floating-point numbers are a an approximation of the real numbers that are efficiently implemented in computer hardware.\nComputations that use floating-point numbers are very efficient; however, the nature of the way that they approximate the real numbers is complex, with many corner cases.\nThe IEEE 754 standard, which defines the floating-point format that is used on modern computers, allows hardware designers to make certain choices, and real systems differ in these small details.\nFor example, there are many distinct bit representations of NaN, the indicator that a result is undefined, and some platforms differ with respect to which NaN is returned from adding two NaNs.\n\nLean exposes the underlying platform's floating-point values for use in programming, but they are not encoded in Lean's logic.\nThey are represented by an opaque type.\nThis means that the kernel is not capable of computing with or reasoning about floating-point values without additional axioms.\nA consequence of this is that equality of floating-point numbers is not decidable.\nFurthermore, comparisons between floating-point values are decidable, but the code that does so is opaque; in practice, the decision procedure can only be used in compiled code.\n\nLean provides two floating-point types: Float represents 64-bit floating point values, while Float32 represents 32-bit floating point values.\nThe precision of Float does not vary based on the platform that Lean is running on.\n\n64-bit floating-point numbers.Float corresponds to the IEEE 754 binary64 format (double in C or f64 in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.Floating-point numbers include subnormal numbers.\nTheir special values are:* NaN, which denotes a class of “not a number” values that result from operations such as\ndividing zero by zero, and* Inf and -Inf, which represent positive and infinities that result from dividing non-zero\nvalues by zero.\n\n32-bit floating-point numbers.Float32 corresponds to the IEEE 754 binary32 format (float in C or f32 in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.Floating-point numbers include subnormal numbers.\nTheir special values are:* NaN, which denotes a class of “not a number” values that result from operations such as\ndividing zero by zero, and* Inf and -Inf, which represent positive and infinities that result from dividing non-zero\nvalues by zero.\n\nNo Kernel Reasoning About Floating-Point NumbersThe Lean kernel can compare expressions of type Float for syntactic equality, so 0.0 is definitionally equal to itself.example : (0.0 : Float) = (0.0 : Float) := by rfl\nTerms that require reduction to become syntactically equal cannot be checked by the kernel:example : (0.0 : Float) = (0.0 + 0.0 : Float) := by rfl\nTactic `rfl` failed: The left-hand side\n  0.0\nis not definitionally equal to the right-hand side\n  0.0 + 0.0\n\n⊢ 0.0 = 0.0 + 0.0\nSimilarly, the kernel cannot evaluate Bool-valued comparisons of floating-point numbers while checking definitional equality:theorem Float.zero_eq_zero_plus_zero :\n    ((0.0 : Float) == (0.0 + 0.0 : Float)) = true :=\n  by rfl\nTactic `rfl` failed: The left-hand side\n  0.0 == 0.0 + 0.0\nis not definitionally equal to the right-hand side\n  true\n\n⊢ (0.0 == 0.0 + 0.0) = true\nHowever, the native_decide tactic can invoke the underlying platform's floating-point primitives that are used by Lean for run-time programs:theorem Float.zero_eq_zero_plus_zero :\n    ((0.0 : Float) == (0.0 + 0.0 : Float)) = true := by\n  native_decide\nThis tactic uses the axiom Lean.trustCompiler, which states that the Lean compiler, interpreter and the low-level implementations of built-in operators are trusted in addition to the kernel.#print axioms Float.zero_eq_zero_plus_zero\n'Float.zero_eq_zero_plus_zero' depends on axioms: [Classical.choice, Lean.ofReduceBool, Lean.trustCompiler]\n\n\nFloating-Point Equality Is Not ReflexiveFloating-point operations may produce NaN values that indicate an undefined result.\nThese values are not comparable with each other; in particular, all comparisons involving NaN will return false, including equality.#eval ((0.0 : Float) / 0.0) == ((0.0 : Float) / 0.0)\n\n\nFloating-Point Equality Is Not a CongruenceApplying a function to two equal floating-point numbers may not result in equal numbers.\nIn particular, positive and negative zero are distinct values that are equated by floating-point equality, but division by positive or negative zero yields positive or negative infinite values.def neg0 : Float := -0.0\n\ndef pos0 : Float := 0.0\n\n#eval (neg0 == pos0, 1.0 / neg0 == 1.0 / pos0)\n(true, false)\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.6. Floating-Point Numbers","id":"/Basic-Types/Floating-Point-Numbers/#Float"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Language-server___-widgets___-and-IDE-extensions":{"contents":"* #4821 resolves two language server bugs that especially affect Windows users. (1) Editing the header could result in the watchdog not correctly restarting the file worker, which would lead to the file seemingly being processed forever. (2) On an especially slow Windows machine, we found that starting the language server would sometimes not succeed at all. This PR also resolves an issue where we would not correctly emit messages that we received while the file worker is being restarted to the corresponding file worker after the restart.* #5006 updates the user widget manual.* #5193 updates the quickstart guide with the new display name for the Lean 4 extension (\"Lean 4\").* #5185 fixes a bug where over time \"import out of date\" messages would accumulate.* #4900 improves ilean loading performance by about a factor of two. Optimizes the JSON parser and the conversion from JSON to Lean data structures; see PR description for details.* Other fixes or improvements* #5031 localizes an instance in Lsp.Diagnostics.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Language server, widgets, and IDE extensions","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Language-server___-widgets___-and-IDE-extensions"}});