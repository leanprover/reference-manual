window.docContents[22].resolve({"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Bitwise-Operators":{"contents":"Bitwise operators on Int can be understood as bitwise operators on an infinite stream of bits that are the twos-complement representation of integers.\n\nBitwise not, usually accessed via the ~~~ prefix operator.Interprets the integer as an infinite sequence of bits in two's complement and complements each bit.Examples:* ~~~(0 : Int) = -1* ~~~(1 : Int) = -2* ~~~(-1 : Int) = 0\n\nBitwise right shift, usually accessed via the >>> operator.Interprets the integer as an infinite sequence of bits in two's complement and shifts the value to\nthe right.Examples:* ( 0b0111 : Int) >>> 1 =  0b0011* ( 0b1000 : Int) >>> 1 =  0b0100* (-0b1000 : Int) >>> 1 = -0b0100* (-0b0111 : Int) >>> 1 = -0b0100\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","header":"19.2.4.4. Bitwise Operators","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Bitwise-Operators"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-default":{"contents":"Elan's configuration file specifies a default toolchain to be used when there is no lean-toolchain file or toolchain override for the current directory.\nRather than manually editing the file, this value is typically changed using the default command.\n\n\n\nSets the default toolchain to toolchain, which should be a valid toolchain identifier such as stable, nightly, or 4.17.0.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Command-Line Interface","header":"22.2.3.2. Setting the Default Toolchain","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-default"},"/The-Type-System/Inductive-Types/#recursor-types":{"contents":"The recursor takes the following parameters: The inductive type's parameters\n\nBecause parameters are consistent, they can be abstracted over the entire recursor.\n\n The motive\n\nThe motive determines the type of an application of the recursor. The motive is a function whose arguments are the type's indices and an instance of the type with these indices instantiated. The specific universe for the type that the motive determines depends on the inductive type's universe and the specific constructors—see the section on subsingleton elimination for details.\n\n A minor premise for each constructor\n\nFor each constructor, the recursor expects a function that satisfies the motive for an arbitrary application of the constructor.\n  Each minor premise abstracts over all of the constructor's parameters.\n  If the constructor's parameter's type is the inductive type itself, then the minor premise additionally takes a parameter whose type is the motive applied to that parameter's value—this will receive the result of recursively processing the recursive parameter.\n\n The major premise, or target\n\nFinally, the recursor takes an instance of the type as an argument, along with any index values.\n\nThe result type of the recursor is the motive applied to these indices and the major premise.\n\nThe recursor for BoolBool's recursor Bool.rec has the following parameters:* The motive computes a type in any universe, given a Bool.* There are minor premises for both constructors, in which the motive is satisfied for both false and true.* The major premise is some Bool.The return type is the motive applied to the major premise.Bool.rec.{u} {motive : Bool → Sort u}\n  (false : motive false)\n  (true : motive true)\n  (t : Bool) : motive t\n\n\nThe recursor for ListList's recursor List.rec has the following parameters:* The parameter α comes first, because the motive, minor premises, and major premise need to refer to it.* The motive computes a type in any universe, given a List α. There is no connection between the universe levels u and v.* There are minor premises for both constructors:* The motive is satisfied for List.nil* The motive should be satisfiable for any application of List.cons, given that it is satisfiable for the tail. The extra parameter motive tail is because tail's type is a recursive occurrence of List.* The major premise is some List α.Once again, the return type is the motive applied to the major premise.List.rec.{u, v} {α : Type v} {motive : List α → Sort u}\n  (nil : motive [])\n  (cons : (head : α) → (tail : List α) → motive tail →\n    motive (head :: tail))\n  (t : List α) : motive t\n\n\nRecursor with parameters and indicesGiven the definition of EvenOddList:inductive EvenOddList (α : Type u) : Bool → Type u where\n  | nil : EvenOddList α true\n  | cons : α → EvenOddList α isEven → EvenOddList α (not isEven)\nThe recursor EvenOddList.rec is very similar to that for List.\nThe difference comes from the presence of the index:* The motive now abstracts over any arbitrary choice of index.* The minor premise for nil applies the motive to nil's index value true.* The minor premise cons abstracts over the index value used in its recursive occurrence, and instantiates the motive with its negation.* The major premise additionally abstracts over an arbitrary choice of index.EvenOddList.rec.{u, v} {α : Type v}\n  {motive : (isEven : Bool) → EvenOddList α isEven → Sort u}\n  (nil : motive true EvenOddList.nil)\n  (cons : {isEven : Bool} →\n    (head : α) →\n    (tail : EvenOddList α isEven) → motive isEven tail →\n    motive (!isEven) (EvenOddList.cons head tail)) :\n  {isEven : Bool} → (t : EvenOddList α isEven) → motive isEven t\n\n\nWhen using a predicate (that is, a function that returns a Prop) for the motive, recursors express induction.\nThe minor premises for non-recursive constructors are the base cases, and the additional arguments supplied to minor premises for constructors with recursive arguments are the induction hypotheses.\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Recursors","header":"4.4.3.1.1. Recursor Types","id":"/The-Type-System/Inductive-Types/#recursor-types"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--DevOps___CI":{"contents":"* #4914 and #4937 improve the release checklist.* #4925 ignores stale leanpkg tests.* #5003 upgrades actions/cache in CI.* #5010 sets save-always in cache actions in CI.* #5008 adds more libuv search patterns for the speedcenter.* #5009 reduce number of runs in the speedcenter for \"fast\" benchmarks from 10 to 3.* #5014 adjusts lakefile editing to use new git syntax in pr-release workflow.* #5025 has pr-release workflow pass --retry to curl.* #5022 builds MacOS Aarch64 release for PRs by default.* #5045 adds libuv to the required packages heading in macos docs.* #5034 fixes the install name of libleanshared_1 on macOS.* #5051 fixes Windows stage 0.* #5052 fixes 32bit stage 0 builds in CI.* #5057 avoids rebuilding leanmanifest in each build.* #5099 makes restart-on-label workflow also filter by commit SHA.* #4325 adds CaDiCaL.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"DevOps/CI","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--DevOps___CI"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Language-Features":{"contents":"* #6432 implements tactics called extract_lets and lift_lets that\nmanipulate let/let_fun expressions. The extract_lets tactic\ncreates new local declarations extracted from any let and let_fun\nexpressions in the main goal. For top-level lets in the target, it is\nlike the intros tactic, but in general it can extract lets from deeper\nsubexpressions as well. The lift_lets tactic moves let and let_fun\nexpressions as far out of an expression as possible, but it does not\nextract any new local declarations. The option extract_lets +lift\ncombines these behaviors.* #7806 modifies the syntaxes of the ext, intro and enter conv\ntactics to accept _. The introduced binder is an inaccessible name.* #7830 modifies the syntax of induction, cases, and other tactics\nthat use Lean.Parser.Tactic.inductionAlts. If a case omits => ...\nthen it is assumed to be => ?_. Example:example (p : Nat × Nat) : p.1 = p.1 := by\n  cases p with | _ p1 p2\n  /-\n  case mk\n  p1 p2 : Nat\n  ⊢ (p1, p2).fst = (p1, p2).fst\n  -/\nThis works with multiple cases as well. Example:example (n : Nat) : n + 1 = 1 + n := by\n  induction n with | zero | succ n ih\n  /-\n  case zero\n  ⊢ 0 + 1 = 1 + 0\n\n  case succ\n  n : Nat\n  ih : n + 1 = 1 + n\n  ⊢ n + 1 + 1 = 1 + (n + 1)\n  -/\nThe induction n with | zero | succ n ih is short for induction n with | zero | succ n ih => ?_, which is short for induction n with | zero => ?_ | succ n ih => ?_. Note that a consequence of parsing is that\nonly the last alternative can omit =>. Any =>-free alternatives\nbefore an alternative with => will be a part of that alternative.* #7831 adds extensibility to the evalAndSuggest procedure used to\nimplement try?. Users can now implement their own handlers for any\ntactic.-- Install a `TryTactic` handler for `assumption`\n@[try_tactic assumption]\ndef evalTryApply : TryTactic := fun tac => do\n  -- We just use the default implementation, but return a different tactic.\n  evalAssumption tac\n  `(tactic| (trace \"worked\"; assumption))\n\n/-- info: Try this: · trace \"worked\"; assumption -/\n#guard_msgs (info) in\nexample (h : False) : False := by\n  try? (max := 1) -- at most one solution\n\n-- `try?` uses `evalAndSuggest` the attribute `[try_tactic]` is used to extend `evalAndSuggest`.\n-- Let's define our own `try?` that uses `evalAndSuggest`\nelab stx:\"my_try?\" : tactic => do\n  -- Things to try\n  let toTry ← `(tactic| attempt_all | assumption | apply True | rfl)\n  evalAndSuggest stx toTry\n\n/--\ninfo: Try these:\n• · trace \"worked\"; assumption\n• rfl\n-/\n#guard_msgs (info) in\nexample (a : Nat) (h : a = a) : a = a := by\n  my_try?\n* #8055 adds an implementation of an async IO multiplexing framework as\nwell as an implementation of it for the Timer API in order to\ndemonstrate it.* #8088 adds the “unfolding” variant of the functional induction and\nfunctional cases principles, under the name foo.induct_unfolding resp.\nfoo.fun_cases_unfolding. These theorems combine induction over the\nstructure of a recursive function with the unfolding of that function,\nand should be more reliable, easier to use and more efficient than just\ncase-splitting and then rewriting with equational theorems.For example instead ofackermann.induct\n  (motive : Nat → Nat → Prop)\n  (case1 : ∀ (m : Nat), motive 0 m)\n  (case2 : ∀ (n : Nat), motive n 1 → motive (Nat.succ n) 0)\n  (case3 : ∀ (n m : Nat), motive (n + 1) m → motive n (ackermann (n + 1) m) → motive (Nat.succ n) (Nat.succ m))\n  (x x : Nat) : motive x x\none getsackermann.fun_cases_unfolding\n  (motive : Nat → Nat → Nat → Prop)\n  (case1 : ∀ (m : Nat), motive 0 m (m + 1))\n  (case2 : ∀ (n : Nat), motive n.succ 0 (ackermann n 1))\n  (case3 : ∀ (n m : Nat), motive n.succ m.succ (ackermann n (ackermann (n + 1) m)))\n  (x✝ x✝¹ : Nat) : motive x✝ x✝¹ (ackermann x✝ x✝¹)\n* #8097 adds support for inductive and coinductive predicates defined\nusing lattice theoretic structures on Prop. These are syntactically\ndefined using greatest_fixpoint or least_fixpoint termination\nclauses for recursive Prop-valued functions. The functionality relies\non partial_fixpoint machinery and requires function definitions to be\nmonotone. For non-mutually recursive predicates, an appropriate\n(co)induction proof principle (given by Park induction) is generated.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)\u0009Highlights","header":"Language Features","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Language-Features"}});