window.docContents[230].resolve({"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Iteration":{"contents":"A left fold on ByteArray that iterates over an array from low to high indices, computing a\nrunning value.Each element of the array is combined with the value from the prior elements using a function\nf. The initial value init is the starting value before any elements have been\nprocessed.ByteArray.foldlM is a monadic variant of this function.\n\nA monadic left fold on ByteArray that iterates over an array from low to high indices,\ncomputing a running value.Each element of the array is combined with the value from the prior elements using a monadic\nfunction f. The initial value init is the starting value before any elements have\nbeen processed.\n\nThe reference implementation of ForIn.forIn for ByteArray.In compiled code, this is replaced by the more efficient ByteArray.forInUnsafe.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.6. Iteration","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Iteration"},"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Properties":{"contents":"Floating-point numbers fall into one of three categories:\n\n* Finite numbers are ordinary floating-point values.* Infinities, which may be positive or negative, result from division by zero.* NaNs, which are not numbers, result from other undefined operations, such as the square root of a negative number.\n\nChecks whether a floating-point number is a positive or negative infinite number, but not a finite\nnumber or NaN.This function does not reduce in the kernel. It is compiled to the C operator isinf.\n\nChecks whether a floating-point number is a positive or negative infinite number, but not a finite\nnumber or NaN.This function does not reduce in the kernel. It is compiled to the C operator isinf.\n\nChecks whether a floating point number is NaN (“not a number”) value.NaN values result from operations that might otherwise be errors, such as dividing zero by zero.This function does not reduce in the kernel. It is compiled to the C operator isnan.\n\nChecks whether a floating point number is NaN (\"not a number\") value.NaN values result from operations that might otherwise be errors, such as dividing zero by zero.This function does not reduce in the kernel. It is compiled to the C operator isnan.\n\nChecks whether a floating-point number is finite, that is, whether it is normal, subnormal, or zero,\nbut not infinite or NaN.This function does not reduce in the kernel. It is compiled to the C operator isfinite.\n\nChecks whether a floating-point number is finite, that is, whether it is normal, subnormal, or zero,\nbut not infinite or NaN.This function does not reduce in the kernel. It is compiled to the C operator isfinite.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"19.6.2.1. Properties","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Properties"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Adjustment":{"contents":"Returns the previous valid position before the given position, given a proof that the position\nis not the start position, which guarantees that such a position exists.\n\nReturns the previous valid position before the given position, or panics if the position is\nthe start position.\n\nReturns the previous valid position before the given position, or none if the position is\nthe start position.\n\nAdvances a valid position on a string to the next valid position, given a proof that the\nposition is not the past-the-end position, which guarantees that such a position exists.\n\nAdvances a valid position on a string to the next valid position, or panics if the given\nposition is the past-the-end position.\n\nAdvances a valid position on a string to the next valid position, or returns none if the\ngiven position is the past-the-end position.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Positions","header":"19.8.4.4.4. Adjustment","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Adjustment"},"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--Integrating--grind-___s-Features":{"contents":"This example demonstrates how the various submodules of grind are seamlessly integrated.\nIn particular we can:* instantiate theorems from the library, using custom patterns,* perform case splitting,* do linear integer arithmetic reasoning, including modularity conditions, and* do Gröbner basis reasoning\nall without providing explicit instructions to drive the interactions between these modes of reasoning.\n\nFor this example we'll begin with a “mocked up” version of the real numbers, and the sin and cos functions.\nOf course, this example works without any changes using Mathlib's versions of these!\n\n\n\naxiom R : Type\n\n\n@[instance] axiom instCommRingR : Lean.Grind.CommRing R\n\n\naxiom sin : R → R\naxiom cos : R → R\naxiom trig_identity : ∀ x, (cos x)^2 + (sin x)^2 = 1\n\n\nOur first step is to tell grind to “put the trig identity on the whiteboard” whenever it sees a goal involving sin or cos:grind_pattern trig_identity => cos x\ngrind_pattern trig_identity => sin x\nNote here we use two different patterns for the same theorem, so the theorem is instantiated even if grind sees just one of these functions.\nIf we preferred to more conservatively instantiate the theorem only when both sin and cos are present, we could have used a multi-pattern:grind_pattern trig_identity => cos x, sin x\nFor this example, either approach will work.\n\nBecause grind immediately notices the trig identity, we can prove goals like this:example : (cos x + sin x)^2 = 2 * cos x * sin x + 1 := by\n  grind\nHere grind does the following:1. It notices cos x and sin x, so instantiates the trig identity.2. It notices that this is a polynomial in CommRing R, and sends it to the Gröbner basis module.\n   No calculation happens at this point: it's the first polynomial relation in this ring, so the Gröbner basis is updated to [(cos x)^2 + (sin x)^2 - 1].3. It notices that the left and right hand sides of the goal are polynomials in CommRing R, and sends them to the Gröbner basis module for normalization.Since their normal forms modulo (cos x)^2 + (sin x)^2 = 1 are equal, their equivalence classes are merged, and the goal is solved.We can also do this sort of argument when congruence closure is needed:example (f : R → Nat) :\n    f ((cos x + sin x)^2) = f (2 * cos x * sin x + 1) := by\n  grind\nAs before, grind instantiates the trig identity, notices that (cos x + sin x)^2 and 2 * cos x * sin x + 1 are equal modulo (cos x)^2 + (sin x)^2 = 1,\nputs those algebraic expressions in the same equivalence class, and then puts the function applications f ((cos x + sin x)^2) and f (2 * cos x * sin x + 1) in the same equivalence class,\nand closes the goal.Notice that we've used an arbitrary function f : R → Nat here; let's check that grind can use some linear integer arithmetic reasoning after the Gröbner basis steps:example (f : R → Nat) :\n    4 * f ((cos x + sin x)^2) ≠ 2 + f (2 * cos x * sin x + 1) := by\n  grind\nHere grind first works out that this goal reduces to 4 * n ≠ 2 + n for some n : Nat (i.e. by identifying the two function applications as described above), and then uses modularity to derive a contradiction.Finally, we can also mix in some case splitting:example (f : R → Nat) :\n    max 3 (4 * f ((cos x + sin x)^2)) ≠\n      2 + f (2 * cos x * sin x + 1) := by\n  grind\nAs before, grind first does the instantiation and Gröbner basis calculations required to identify the two function applications.\nHowever the cutsat algorithm by itself can't do anything with max 3 (4 * n) ≠ 2 + n.\nNext, after instantiating Nat.max_def (automatically, because of an annotation in the standard library) which states ∀ {n m : Nat}, max n m = if n ≤ m then m else n, grind can then case split on the inequality.\nIn the branch 3 ≤ 4 * n, cutsat again uses modularity to prove 4 * n ≠ 2 + n.\nIn the branch 4 * n < 3, cutsat quickly determines n = 0, and then notices that 4 * 0 ≠ 2 + 0.This has been, of course, a quite artificial example!\nIn practice, this sort of automatic integration of different reasoning modes is very powerful: the central “whiteboard” which tracks instantiated theorems and equivalence classes can hand off relevant terms and equalities to the appropriate modules (here, cutsat and Gröbner bases), which can then return new facts to the whiteboard.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples","header":"17.10.1. Integrating  grind 's Features","id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--Integrating--grind-___s-Features"},"/The-Type-System/Inductive-Types/#iota-reduction":{"contents":"In addition to adding new constants to the logic, inductive type declarations also add new reduction rules.\nThese rules govern the interaction between recursors and constructors; specifically recursors that have constructors as their major premise.\nThis form of reduction is called ι-reduction (iota reduction).\n\nWhen the recursor's major premise is a constructor with no recursive parameters, the recursor application reduces to an application of the constructor's minor premise to the constructor's arguments.\nIf there are recursive parameters, then these arguments to the minor premise are found by applying the recursor to the recursive occurrence.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Recursors","header":"4.4.3.1.2. Reduction","id":"/The-Type-System/Inductive-Types/#iota-reduction"}});