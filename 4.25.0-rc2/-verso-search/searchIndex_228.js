window.docContents[228].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Negation-and-Absolute-Value":{"contents":"Computes the absolute value of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nfabs.\n\nComputes the absolute value of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nfabsf.\n\nNegates 64-bit floating-point numbers according to IEEE 754. Typically used via the - prefix\noperator.This function does not reduce in the kernel. It is compiled to the C negation operator.\n\nNegates 32-bit floating-point numbers according to IEEE 754. Typically used via the - prefix\noperator.This function does not reduce in the kernel. It is compiled to the C negation operator.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"19.6.2.10. Negation and Absolute Value","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Negation-and-Absolute-Value"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Lookups":{"contents":"Returns the element at the provided index, counting from 0.In other words, for i : Fin as.length, as.get i returns the i'th element of the list as.\nBecause the index is a Fin bounded by the list's length, the index will never be out of bounds.Examples:* [\"spring\", \"summer\", \"fall\", \"winter\"].get (2 : Fin 4) = \"fall\"* [\"spring\", \"summer\", \"fall\", \"winter\"].get (0 : Fin 4) = \"spring\"\n\nReturns the element at the provided index, counting from 0. Returns fallback if the index is out\nof bounds.To return an Option depending on whether the index is in bounds, use as[i]?. To panic if the\nindex is out of bounds, use as[i]!.Examples:* [\"spring\", \"summer\", \"fall\", \"winter\"].getD 2 \"never\" = \"fall\"* [\"spring\", \"summer\", \"fall\", \"winter\"].getD 0 \"never\" = \"spring\"* [\"spring\", \"summer\", \"fall\", \"winter\"].getD 4 \"never\" = \"never\"\n\nReturns the last element of a non-empty list.Examples:* [\"circle\", \"rectangle\"].getLast (by decide) = \"rectangle\"* [\"circle\"].getLast (by decide) = \"circle\"\n\nReturns the last element in the list, or none if the list is empty.Alternatives include List.getLastD, which takes a fallback value for empty lists, and\nList.getLast!, which panics on empty lists.Examples:* [\"circle\", \"rectangle\"].getLast? = some \"rectangle\"* [\"circle\"].getLast? = some \"circle\"* ([] : List String).getLast? = none\n\nReturns the last element in the list, or fallback if the list is empty.Alternatives include List.getLast?, which returns an Option, and List.getLast!, which panics\non empty lists.Examples:* [\"circle\", \"rectangle\"].getLastD \"oval\" = \"rectangle\"* [\"circle\"].getLastD \"oval\" = \"circle\"* ([] : List String).getLastD \"oval\" = \"oval\"\n\nReturns the last element in the list. Panics and returns default if the list is empty.Safer alternatives include:* getLast?, which returns an Option,* getLastD, which takes a fallback value for empty lists, and* getLast, which requires a proof that the list is non-empty.Examples:* [\"circle\", \"rectangle\"].getLast! = \"rectangle\"* [\"circle\"].getLast! = \"circle\"\n\nTreats the list as an association list that maps keys to values, returning the first value whose key\nis equal to the specified key.O(|l|).Examples:* [(1, \"one\"), (3, \"three\"), (3, \"other\")].lookup 3 = some \"three\"* [(1, \"one\"), (3, \"three\"), (3, \"other\")].lookup 2 = none\n\nReturns the largest element of the list if it is not empty, or none if it is empty.Examples:* [].max? = none* [4].max? = some 4* [1, 4, 2, 10, 6].max? = some 10\n\nReturns the smallest element of the list if it is not empty, or none if it is empty.Examples:* [].min? = none* [4].min? = some 4* [1, 4, 2, 10, 6].min? = some 1\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.5. Lookups","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Lookups"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks--Impure-Tasks":{"contents":"When spawning a task with side effects using one of the asTask functions, it's important to actually execute the resulting IO action.\nA task is spawned each time the resulting action is executed, not when asTask is called.\nImpure tasks continue running even when there are no references to them, though this does result in cancellation being requested.\nCancellation may also be explicitly requested using IO.cancel.\nThe impure task must check for cancellation using IO.checkCanceled.\n\nRuns act in a separate Task, with priority prio.Running the resulting BaseIO action causes the task to be started eagerly. Pure accesses to the\nTask do not influence the impure act.Unlike pure tasks created by Task.spawn, tasks created by this function will run even if the last\nreference to the task is dropped. The act should explicitly check for cancellation via\nIO.checkCanceled if it should be terminated or otherwise react to the last reference being\ndropped.\n\nRuns act in a separate Task, with priority prio. Because EIO ε actions may throw an exception\nof type ε, the result of the task is an Except ε α.Running the resulting IO action causes the task to be started eagerly. Pure accesses to the Task\ndo not influence the impure act.Unlike pure tasks created by Task.spawn, tasks created by this function will run even if the last\nreference to the task is dropped. The act should explicitly check for cancellation via\nIO.checkCanceled if it should be terminated or otherwise react to the last reference being\ndropped.\n\nRuns act in a separate Task, with priority prio. Because IO actions may throw an exception\nof type IO.Error, the result of the task is an Except IO.Error α.Running the resulting BaseIO action causes the task to be started eagerly. Pure accesses to the\nTask do not influence the impure act. Because IO actions may throw an exception of type\nIO.Error, the result of the task is an Except IO.Error α.Unlike pure tasks created by Task.spawn, tasks created by this function will run even if the last\nreference to the task is dropped. The act should explicitly check for cancellation via\nIO.checkCanceled if it should be terminated or otherwise react to the last reference being\ndropped.\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads\u0009Creating Tasks","header":"15.11.1.2. Impure Tasks","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks--Impure-Tasks"},"/Notations-and-Macros/Macros/#macro-command":{"contents":"\n\nThe macro command simultaneously defines a new syntax rule and associates it with a macro.\nUnlike notation, which can define only new term syntax and in which the expansion is a term into which the parameters are to be substituted, the macro command may define syntax in any syntax category and it may use arbitrary code in the MacroM monad to generate the expansion.\nBecause macros are so much more flexible than notations, Lean cannot automatically generate an unexpander; this means that new syntax implemented via the macro command is available for use in input to Lean, but Lean's output does not use it without further work.\n\nMacro Declarations\n\nMacro ArgumentsA macro's arguments are either syntax items (as used in the syntax command) or syntax items with attached names.\n\nIn the expansion, the names that are attached to syntax items are bound; they have type TSyntax for the appropriate syntax kinds.\nIf the syntax matched by the parser does not have a defined kind (e.g. because the name is applied to a complex specification), then the type is TSyntax Name.anonymous.\n\n\n\nThe documentation comment is associated with the new syntax, and the attribute kind (none, local, or scoped) governs the visibility of the macro just as it does for notations: scoped macros are available in the namespace in which they are defined or in any section scope that opens that namespace, while local macros are available only in the local section scope.\n\nBehind the scenes, the macro command is itself implemented by a macro that expands it to a syntax command and a macro_rules command.\nAny attributes applied to the macro command are applied to the syntax definition, but not to the macro_rules command.\n\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009Defining Macros","header":"20.5.5.2. The  macro  Command","id":"/Notations-and-Macros/Macros/#macro-command"},"/The-Type-System/Functions/#functions":{"contents":"Function types are a built-in feature of Lean.\nFunctions map the values of one type (the domain) into those of another type (the codomain), and function types specify the domain and codomain of functions.\n\nThere are two kinds of function type:\n\n Dependent\n\nDependent function types explicitly name the parameter, and the function's codomain may refer explicitly to this name.\n   Because types can be computed from values, a dependent function may return values from any number of different types, depending on its argument.Dependent functions are sometimes referred to as dependent products, because they correspond to an indexed product of sets.\n\n Non-Dependent\n\nNon-dependent function types do not include a name for the parameter, and the codomain does not vary based on the specific argument provided.\n\n\n\nDependent Function TypesThe function two returns values in different types, depending on which argument it is called with:def two : (b : Bool) → if b then Unit × Unit else String :=\n  fun b =>\n    match b with\n    | true => ((), ())\n    | false => \"two\"\nThe body of the function cannot be written with if...then...else... because it does not refine types the same way that match does.\n\nIn Lean's core language, all function types are dependent: non-dependent function types are dependent function types in which the parameter name does not occur in the codomain.\nAdditionally, two dependent function types that have different parameter names may be definitionally equal if renaming the parameter makes them equal.\nHowever, the Lean elaborator does not introduce a local binding for non-dependent functions' parameters.\n\nDefinitional Equality of Dependent and Non-Dependent FunctionsThe types (x : Nat) → String and Nat → String are definitionally equal:example : ((x : Nat) → String) = (Nat → String) :=\n  rfl\nSimilarly, the types (n : Nat) → n + 1 = 1 + n and (k : Nat) → k + 1 = 1 + k are definitionally equal:example : ((n : Nat) → n + 1 = 1 + n) = ((k : Nat) → k + 1 = 1 + k) :=\n  rfl\n\n\nNon-Dependent Functions Don't Bind VariablesA dependent function is required in the following statement that all elements of an array are non-zero:def AllNonZero (xs : Array Nat) : Prop :=\n  (i : Nat) → (lt : i < xs.size) → xs[i] ≠ 0\nThis is because the elaborator for array access requires a proof that the index is in bounds.\nThe non-dependent version of the statement does not introduce this assumption:def AllNonZero (xs : Array Nat) : Prop :=\n  (i : Nat) → (i < xs.size) → xs[i] ≠ 0\nfailed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nxs : Array Nat\ni : Nat\n⊢ i < xs.size\n\n\nWhile the core type theory does not feature implicit parameters, function types do include an indication of whether the parameter is implicit.\nThis information is used by the Lean elaborator, but it does not affect type checking or definitional equality in the core theory and can be ignored when thinking only about the core type theory.\n\nDefinitional Equality of Implicit and Explicit Function TypesThe types {α : Type} → (x : α) → α and (α : Type) → (x : α) → α are definitionally equal, even though the first parameter is implicit in one and explicit in the other.example :\n    ({α : Type} → (x : α) → α)\n    =\n    ((α : Type) → (x : α) → α)\n  := rfl\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System","header":"4.1. Functions","id":"/The-Type-System/Functions/#functions"}});