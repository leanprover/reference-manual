window.docContents[206].resolve({"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Syntax":{"contents":"Boolean Infix OperatorsThe infix operators &&, ||, and ^^ are notations for Bool.and, Bool.or, and Bool.xor, respectively.\n\nBoolean NegationThe prefix operator ! is notation for Bool.not.\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans","header":"19.11.3. Syntax","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Syntax"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Transformation":{"contents":"Applies a function to each element of the list, returning the resulting list of values.O(|l|).Examples:* [a, b, c].map f = [f a, f b, f c]* [].map Nat.succ = []* [\"one\", \"two\", \"three\"].map (·.length) = [3, 3, 5]* [\"one\", \"two\", \"three\"].map (·.reverse) = [\"eno\", \"owt\", \"eerht\"]\n\nApplies a function to each element of the list, returning the resulting list of values.O(|l|). This is the tail-recursive variant of List.map, used in runtime code.Examples:* [a, b, c].mapTR f = [f a, f b, f c]* [].mapTR Nat.succ = []* [\"one\", \"two\", \"three\"].mapTR (·.length) = [3, 3, 5]* [\"one\", \"two\", \"three\"].mapTR (·.reverse) = [\"eno\", \"owt\", \"eerht\"]\n\nApplies the monadic action f to every element in the list, left-to-right, and returns the list of\nresults.This implementation is tail recursive. List.mapM' is a a non-tail-recursive variant that may be\nmore convenient to reason about. List.forM is the variant that discards the results and\nList.mapA is the variant that works with Applicative.\n\nApplies the monadic action f on every element in the list, left-to-right, and returns the list of\nresults.This is a non-tail-recursive variant of List.mapM that's easier to reason about. It cannot be used\nas the main definition and replaced by the tail-recursive version because they can only be proved\nequal when m is a LawfulMonad.\n\nApplies the applicative action f on every element in the list, left-to-right, and returns the list\nof results.If m is also a Monad, then using mapM can be more efficient.See List.forA for the variant that discards the results. See List.mapM for the variant that\nworks with Monad.This function is not tail-recursive, so it may fail with a stack overflow on long lists.\n\nApplies a function to each element of the list along with the index at which that element is found,\nreturning the list of results. In addition to the index, the function is also provided with a proof\nthat the index is valid.List.mapIdx is a variant that does not provide the function with evidence that the index is valid.\n\nApplies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results. In addition to the index, the function is also provided with a\nproof that the index is valid.List.mapIdxM is a variant that does not provide the function with evidence that the index is\nvalid.\n\nApplies a function to each element of the list along with the index at which that element is found,\nreturning the list of results.List.mapFinIdx is a variant that additionally provides the function with a proof that the index\nis valid.\n\nApplies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results.List.mapFinIdxM is a variant that additionally provides the function with a proof that the index\nis valid.\n\nApplies a function to each element of a list, returning the list of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new list if the result of each function call is\npointer-equal to its argument.For verification purposes, List.mapMono = List.map.\n\nApplies a monadic function to each element of a list, returning the list of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new list if the result of each function call is\npointer-equal to its argument.\n\nApplies a function that returns a list to each element of a list, and concatenates the resulting\nlists.Examples:* [2, 3, 2].flatMap List.range = [0, 1, 0, 1, 2, 0, 1]* [\"red\", \"blue\"].flatMap String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']\n\nApplies a function that returns a list to each element of a list, and concatenates the resulting\nlists.This is the tail-recursive version of List.flatMap that's used at runtime.Examples:* [2, 3, 2].flatMapTR List.range = [0, 1, 0, 1, 2, 0, 1]* [\"red\", \"blue\"].flatMapTR String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']\n\nApplies a monadic function that returns a list to each element of a list, from left to right, and\nconcatenates the resulting lists.\n\nCombines two lists into a list of pairs in which the first and second components are the\ncorresponding elements of each list. The resulting list is the length of the shorter of the input\nlists.O(min |xs| |ys|).Examples:* [\"Mon\", \"Tue\", \"Wed\"].zip [1, 2, 3] = [(\"Mon\", 1), (\"Tue\", 2), (\"Wed\", 3)]* [\"Mon\", \"Tue\", \"Wed\"].zip [1, 2] = [(\"Mon\", 1), (\"Tue\", 2)]* [x₁, x₂, x₃].zip [y₁, y₂, y₃, y₄] = [(x₁, y₁), (x₂, y₂), (x₃, y₃)]\n\nPairs each element of a list with its index, optionally starting from an index other than 0.O(|l|).Examples:* [a, b, c].zipIdx = [(a, 0), (b, 1), (c, 2)]* [a, b, c].zipIdx 5 = [(a, 5), (b, 6), (c, 7)]\n\nPairs each element of a list with its index, optionally starting from an index other than 0.O(|l|). This is a tail-recursive version of List.zipIdx that's used at runtime.Examples:* [a, b, c].zipIdxTR = [(a, 0), (b, 1), (c, 2)]* [a, b, c].zipIdxTR 5 = [(a, 5), (b, 6), (c, 7)]\n\nApplies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.O(min |xs| |ys|).Examples:* [1, 2].zipWith (· + ·) [5, 6] = [6, 8]* [1, 2, 3].zipWith (· + ·) [5, 6, 10] = [6, 8, 13]* [].zipWith (· + ·) [5, 6] = []* [x₁, x₂, x₃].zipWith f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]\n\nApplies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.O(min |xs| |ys|). This is a tail-recursive version of List.zipWith that's used at runtime.Examples:* [1, 2].zipWithTR (· + ·) [5, 6] = [6, 8]* [1, 2, 3].zipWithTR (· + ·) [5, 6, 10] = [6, 8, 13]* [].zipWithTR (· + ·) [5, 6] = []* [x₁, x₂, x₃].zipWithTR f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]\n\nApplies a function to the corresponding elements of both lists, stopping when there are no more\nelements in either list. If one list is shorter than the other, the function is passed none for\nthe missing elements.Examples:* [1, 6].zipWithAll min [5, 2] = [some 1, some 2]* [1, 2, 3].zipWithAll Prod.mk [5, 6] = [(some 1, some 5), (some 2, some 6), (some 3, none)]* [x₁, x₂].zipWithAll f [y] = [f (some x₁) (some y), f (some x₂) none]\n\nSeparates a list of pairs into two lists that contain the respective first and second components.O(|l|).Examples:* [(\"Monday\", 1), (\"Tuesday\", 2)].unzip = ([\"Monday\", \"Tuesday\"], [1, 2])* [(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzip = ([x₁, x₂, x₃], [y₁, y₂, y₃])* ([] : List (Nat × String)).unzip = (([], []) : List Nat × List String)\n\nSeparates a list of pairs into two lists that contain the respective first and second components.O(|l|). This is a tail-recursive version of List.unzip that's used at runtime.Examples:* [(\"Monday\", 1), (\"Tuesday\", 2)].unzipTR = ([\"Monday\", \"Tuesday\"], [1, 2])* [(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzipTR = ([x₁, x₂, x₃], [y₁, y₂, y₃])* ([] : List (Nat × String)).unzipTR = (([], []) : List Nat × List String)\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.11. Transformation","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Transformation"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Positions":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices","header":"19.8.4.12.3. Positions","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Positions"},"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Modifying-Reducibility":{"contents":"The reducibility of a definition can be globally modified in the module in which it is defined by applying the appropriate attribute with the attribute command.\nIn other modules, the reducibility of imported definitions can be modified by applying the attribute with the local modifier.\nThe seal and  unseal commands are a shorthand for this process.\n\nLocal IrreducibilityThe seal foo command ensures that the definition of foo is sealed, meaning it is marked as [irreducible].\nThis command is particularly useful in contexts where you want to prevent the reduction of foo in proofs.In terms of functionality, seal foo is equivalent to attribute [local irreducible] foo.\nThis attribute specifies that foo should be treated as irreducible only within the local scope,\nwhich helps in maintaining the desired abstraction level without affecting global settings.\n\nLocal ReducibilityThe unseal foo command ensures that the definition of foo is unsealed, meaning it is marked as [semireducible], the\ndefault reducibility setting. This command is useful when you need to allow some level of reduction of foo in proofs.Functionally, unseal foo is equivalent to attribute [local semireducible] foo.\nApplying this attribute makes foo semireducible only within the local scope.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Controlling Reduction","header":"7.6.6.2. Modifying Reducibility","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Modifying-Reducibility"},"/The-Type-System/Inductive-Types/#inductive-types-ffi":{"contents":"From the perspective of C, these other inductive types are represented by lean_object *.\nEach constructor is stored as a lean_ctor_object, and lean_is_ctor will return true.\nA lean_ctor_object stores the constructor index in its header, and the fields are stored in the m_objs portion of the object.\nLean assumes that sizeof(size_t) == sizeof(void*)—while this is not guaranteed by C, the Lean run-time system contains an assertion that fails if this is not the case.\n\nThe memory order of the fields is derived from the types and order of the fields in the declaration. They are ordered as follows:\n\n* Non-scalar fields stored as lean_object ** Fields of type USize* Other scalar fields, in decreasing order by size\n\nWithin each group the fields are ordered in declaration order. Warning: Trivial wrapper types still count toward a field being treated as non-scalar for this purpose.\n\n* To access fields of the first kind, use lean_ctor_get(val, i) to get the ith non-scalar field.* To access USize fields, use lean_ctor_get_usize(val, n+i) to get the ith USize field and n is the total number of fields of the first kind.* To access other scalar fields, use lean_ctor_get_uintN(val, off) or lean_ctor_get_usize(val, off) as appropriate. Here off is the byte offset of the field in the structure, starting at n*sizeof(void*) where n is the number of fields of the first two kinds.\n\nFor example, a structure such asstructure S where\n  ptr_1 : Array Nat\n  usize_1 : USize\n  sc64_1 : UInt64\n  -- wrappers don't count as scalars:\n  ptr_2 : { x : UInt64 // x > 0 }\n  sc64_2 : Float -- `Float` is 64 bit\n  sc8_1 : Bool\n  sc16_1 : UInt16\n  sc8_2 : UInt8\n  sc64_3 : UInt64\n  usize_2 : USize\n  -- trivial wrapper around `UInt32`\n  ptr_3 : Char\n  sc32_1 : UInt32\n  sc16_2 : UInt16\nwould get re-sorted into the following memory order:* S.ptr_1 - lean_ctor_get(val, 0)* S.ptr_2 - lean_ctor_get(val, 1)* S.ptr_3 - lean_ctor_get(val, 2)* S.usize_1 - lean_ctor_get_usize(val, 3)* S.usize_2 - lean_ctor_get_usize(val, 4)* S.sc64_1 - lean_ctor_get_uint64(val, sizeof(void*)*5)* S.sc64_2 - lean_ctor_get_float(val, sizeof(void*)*5 + 8)* S.sc64_3 - lean_ctor_get_uint64(val, sizeof(void*)*5 + 16)* S.sc32_1 - lean_ctor_get_uint32(val, sizeof(void*)*5 + 24)* S.sc16_1 - lean_ctor_get_uint16(val, sizeof(void*)*5 + 28)* S.sc16_2 - lean_ctor_get_uint16(val, sizeof(void*)*5 + 30)* S.sc8_1 - lean_ctor_get_uint8(val, sizeof(void*)*5 + 32)* S.sc8_2 - lean_ctor_get_uint8(val, sizeof(void*)*5 + 33)\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation\u0009Other Inductive Types","header":"4.4.4.4.1. FFI","id":"/The-Type-System/Inductive-Types/#inductive-types-ffi"},"/Type-Classes/Instance-Synthesis/#class-output-parameters":{"contents":"By default, the parameters of a type class are considered to be inputs to the search process.\nIf the parameters are not known, then the search process gets stuck, because choosing an instance would require the parameters to have values that match those in the instance, which cannot be determined on the basis of incomplete information.\nIn most cases, guessing instances would make instance synthesis unpredictable.\n\nIn some cases, however, the choice of one parameter should cause an automatic choice of another.\nFor example, the overloaded membership predicate type class Membership treats the type of elements of a data structure as an output, so that the type of element can be determined by the type of data structure at a use site, instead of requiring that there be sufficient type annotations to determine both types prior to starting instance synthesis.\nAn element of a List Nat can be concluded to be a Nat simply on the basis of its membership in the list.\n\n\n\nType class parameters can be declared as outputs by wrapping their types in the outParam gadget.\nWhen a class parameter is an output parameter, instance synthesis will not require that it be known; in fact, any existing value is ignored completely.\nThe first instance that matches the input parameters is selected, and that instance's assignment of the output parameter becomes its value.\nIf there was a pre-existing value, then it is compared with the assignment after synthesis is complete, and it is an error if they do not match.\n\nGadget for marking output parameters in type classes.For example, the Membership class is defined as:class Membership (α : outParam (Type u)) (γ : Type v)\nThis means that whenever a typeclass goal of the form Membership ?α ?γ comes\nup, Lean will wait to solve it until ?γ is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of ?α,\nwhich thereby determines what ?α should be.This expresses that in a term like a ∈ s, s might be a Set α or\nList α or some other type with a membership operation, and in each case\nthe \"member\" type α is determined by looking at the container type.\n\nOutput Parameters and Stuck SearchThis serialization framework provides a way to convert values to some underlying storage type:class Serialize (input output : Type) where\n  ser : input → output\nexport Serialize (ser)\n\ninstance : Serialize Nat String where\n  ser n := toString n\n\ninstance [Serialize α γ] [Serialize β γ] [Append γ] :\n    Serialize (α × β) γ where\n  ser\n    | (x, y) => ser x ++ ser y\nIn this example, the output type is unknown.example := ser (2, 3)\nInstance synthesis can't select the Serialize Nat String instance, and thus the Append String instance, because that would require instantiating the output type as String, so the search gets stuck:typeclass instance problem is stuck, it is often due to metavariables\n  Serialize (Nat × Nat) ?m.16\nOne way to fix the problem is to supply an expected type:example : String := ser (2, 3)\nThe other is to make the output type into an output parameter:class Serialize (input : Type) (output : outParam Type) where\n  ser : input → output\nexport Serialize (ser)\n\ninstance : Serialize Nat String where\n  ser n := toString n\n\ninstance [Serialize α γ] [Serialize β γ] [Append γ] :\n    Serialize (α × β) γ where\n  ser\n    | (x, y) => ser x ++ ser y\nNow, instance synthesis is free to select the Serialize Nat String instance, which solves the unknown implicit output parameter of ser:example := ser (2, 3)\n\n\nOutput Parameters with Pre-Existing ValuesThe class OneSmaller represents a way to transform non-maximal elements of a type into elements of a type that has one fewer elements.\nThere are two separate instances that can match an input type Option Bool, with different outputs:class OneSmaller (α : Type) (β : outParam Type) where\n  biggest : α\n  shrink : (x : α) → x ≠ biggest → β\n\ninstance : OneSmaller (Option α) α where\n  biggest := none\n  shrink\n    | some x, _ => x\n\ninstance : OneSmaller (Option Bool) (Option Unit) where\n  biggest := some true\n  shrink\n    | none, _ => none\n    | some false, _ => some ()\n\ninstance : OneSmaller Bool Unit where\n  biggest := true\n  shrink\n    | false, _ => ()\nBecause instance synthesis selects the most recently defined instance, the following code is an error:#check OneSmaller.shrink (β := Bool) (some false) sorry\nfailed to synthesize\n  OneSmaller (Option Bool) Bool\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nThe OneSmaller (Option Bool) (Option Unit) instance was selected during instance synthesis, without regard to the supplied value of β.\n\nSemi-output parameters are like output parameters in that they are not required to be known prior to synthesis commencing; unlike output parameters, their values are taken into account when selecting instances.\n\nGadget for marking semi output parameters in type classes.Semi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as [Mul β] : Add α (because β could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.For example, the Coe class is defined as:class Coe (α : semiOutParam (Sort u)) (β : Sort v)\nThis means that all Coe instances should provide a concrete value for α\n(i.e., not an assignable metavariable). An instance like Coe Nat Int or Coe α (Option α) is fine, but Coe α Nat is not since it does not provide a value\nfor α.\n\nSemi-output parameters impose a requirement on instances: each instance of a class with semi-output parameters should determine the values of its semi-output parameters.\n\n\n\nSemi-Output Parameters with Pre-Existing ValuesThe class OneSmaller represents a way to transform non-maximal elements of a type into elements of a type that one fewer elements.\nIt has two separate instances that can match an input type Option Bool, with different outputs:class OneSmaller (α : Type) (β : semiOutParam Type) where\n  biggest : α\n  shrink : (x : α) → x ≠ biggest → β\n\ninstance : OneSmaller (Option α) α where\n  biggest := none\n  shrink\n    | some x, _ => x\n\ninstance : OneSmaller (Option Bool) (Option Unit) where\n  biggest := some true\n  shrink\n    | none, _ => none\n    | some false, _ => some ()\n\ninstance : OneSmaller Bool Unit where\n  biggest := true\n  shrink\n    | false, _ => ()\nBecause instance synthesis takes semi-output parameters into account when selecting instances, the OneSmaller (Option Bool) (Option Unit) instance is passed over due to the supplied value for β:#check OneSmaller.shrink (β := Bool) (some false) sorry\nOneSmaller.shrink (some false) ⋯ : Bool\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.5. Output Parameters","id":"/Type-Classes/Instance-Synthesis/#class-output-parameters"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Other-Highlights":{"contents":"* Documentation has been significantly expanded. See the Documentation section below for details.* #7185 refactors Lake's build internals to enable the introduction of\ntargets and facets beyond packages, modules, and libraries. Facets,\nbuild keys, build info, and CLI commands have been generalized to\narbitrary target types.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Highlights","header":"Other Highlights","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Other-Highlights"},"/releases/v4.9.0/#release-v4___9___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.9.0 (2024-07-01)","id":"/releases/v4.9.0/#release-v4___9___0"}});