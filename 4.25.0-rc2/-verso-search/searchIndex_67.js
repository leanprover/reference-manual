window.docContents[67].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Comparisons":{"contents":"Return true if as is a prefix of bs, or false otherwise.Examples:* #[0, 1, 2].isPrefixOf #[0, 1, 2, 3] = true* #[0, 1, 2].isPrefixOf #[0, 1, 2] = true* #[0, 1, 2].isPrefixOf #[0, 1] = false* #[].isPrefixOf #[0, 1] = true\n\nCompares arrays lexicographically with respect to a comparison lt on their elements.Specifically, Array.lex as bs lt is true if* bs is larger than as and as is pairwise equivalent via == to the initial segment of bs,\nor* there is an index i such that lt as[i] bs[i], and for all j < i, as[j] == bs[j].\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.13. Comparisons","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Comparisons"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Logical-Operations":{"contents":"\n\nThe functions cond, and, and or are short-circuiting.\nIn other words, false && BIG_EXPENSIVE_COMPUTATION does not need to execute BIG_EXPENSIVE_COMPUTATION before returning false.\nThese functions are defined using the macro_inline attribute, which causes the compiler to replace calls to them with their definitions while generating code, and the definitions use nested pattern matching to achieve the short-circuiting behavior.\n\n\n\nThe conditional function.cond c x y is the same as if c then x else y, but optimized for a Boolean condition rather than\na decidable proposition. It can also be written using the notation bif c then x else y.Just like ite, cond is declared @[macro_inline], which causes applications of cond to be\nunfolded. As a result, x and y are not evaluated at runtime until one of them is selected, and\nonly the selected branch is evaluated.\n\nThe dependent conditional function, in which each branch is provided with a local assumption about\nthe condition's value. This allows the value to be used in proofs as well as for control flow.dcond c (fun h => x) (fun h => y) is the same as if h : c then x else y, but optimized for a\nBoolean condition rather than a decidable proposition. Unlike the non-dependent version cond,\nthere is no special notation for dcond.Just like ite, dite, and cond, dcond is declared @[macro_inline], which causes\napplications of dcond to be unfolded. As a result, x and y are not evaluated at runtime until\none of them is selected, and only the selected branch is evaluated. dcond is intended for\nmetaprogramming use, rather than for use in verified programs, so behavioral lemmas are not\nprovided.\n\nBoolean negation, also known as Boolean complement. not x can be written !x.This is a function that maps the value true to false and the value false to true. The\npropositional connective is Not : Prop → Prop.Conventions for notations in identifiers:* The recommended spelling of ! in identifiers is not.\n\nBoolean “and”, also known as conjunction. and x y can be written x && y.The corresponding propositional connective is And : Prop → Prop → Prop, written with the ∧\noperator.The Boolean and is a @[macro_inline] function in order to give it short-circuiting evaluation:\nif x is false then y is not evaluated at runtime.Conventions for notations in identifiers:* The recommended spelling of && in identifiers is and.* The recommended spelling of || in identifiers is or.\n\nBoolean “or”, also known as disjunction. or x y can be written x || y.The corresponding propositional connective is Or : Prop → Prop → Prop, written with the ∨\noperator.The Boolean or is a @[macro_inline] function in order to give it short-circuiting evaluation:\nif x is true then y is not evaluated at runtime.\n\nBoolean “exclusive or”. xor x y can be written x ^^ y.x ^^ y is true when precisely one of x or y is true. Unlike and and or, it does not\nhave short-circuiting behavior, because one argument's value never determines the final value. Also\nunlike and and or, there is no commonly-used corresponding propositional connective.Examples:* false ^^ false = false* true ^^ false = true* false ^^ true = true* true ^^ true = falseConventions for notations in identifiers:* The recommended spelling of ^^ in identifiers is xor.\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans\u0009API Reference","header":"19.11.4.1. Logical Operations","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Logical-Operations"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion":{"contents":"Transforms the tree set into a list of elements in ascending order.\n\nTransforms a list into a tree set.\n\nTransforms the tree set into an array of elements in ascending order.\n\nTransforms an array into a tree set.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","header":"19.18.10.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion"},"/Definitions/Modifiers/#declaration-modifiers":{"contents":"Declarations accept a consistent set of modifiers, all of which are optional.\nModifiers change some aspect of the declaration's interpretation; for example, they can add documentation or change its scope.\nThe order of modifiers is fixed, but not every kind of declaration accepts every kind of modifier.\n\nDeclaration ModifiersModifiers consist of the following, in order, all of which are optional:1. a documentation comment,2. a list of attributes,3. namespace control, specifying whether the resulting name is private or protected,4. the noncomputable keyword, which exempts a definition from compilation,5. the unsafe keyword, and6. a recursion modifier partial or nonrec, which disable termination proofs or disallow recursion entirely.\n\nDocumentation comments are used to provide in-source API documentation for the declaration that they modify.\nDocumentation comments are not, in fact comments: it is a syntax error to put a documentation comment in a position where it is not processed as documentation.\nThey also occur in positions where some kind of text is required, but string escaping would be onerous, such as the desired messages on the #guard_msgs command.\n\nDocumentation CommentsDocumentation comments are like ordinary block comments, but they begin with the sequence /-- rather than /-; just like ordinary comments, they are terminated with -/.\n\nAttributes are an extensible collection of modifiers that associate additional information with declarations.\nThey are described in a dedicated section.\n\nIf a declaration is marked private, then it is not accessible outside the module in which it is defined.\nIf it is protected, then opening its namespace does not bring it into scope.\n\nFunctions marked noncomputable are not compiled and cannot be executed.\nFunctions must be noncomputable if they use noncomputable reasoning principles such as the axiom of choice or excluded middle to produce data that is relevant to the answer that they return, or if they use features of Lean that are exempted from code generation for efficiency reasons, such as recursors.\nNoncomputable functions are very useful for specification and reasoning, even if they cannot be compiled and executed.\n\nThe unsafe marker exempts a definition from kernel checking and enables it to access features that may undermine Lean's guarantees.\nIt should be used with great care, and only with a thorough understanding of Lean's internals.\n\n","context":"Lean Reference\u0009Definitions","header":"7.1. Modifiers","id":"/Definitions/Modifiers/#declaration-modifiers"},"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers":{"contents":"Seeds the random number generator state used by IO.rand.\n\nReturns a pseudorandom number between lo and hi, using and updating a saved random generator\nstate.This state can be seeded using IO.setRandSeed.\n\nGenerates a random Boolean.\n\nGenerates a random natural number in the interval [lo, hi].\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.10. Random Numbers","id":"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers"},"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Manipulating-Stateful-Hypotheses":{"contents":"mclear is like clear, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : P ⊢ₛ Q → Q := by\n  mintro HP\n  mintro HQ\n  mclear HP\n  mexact HQ\n\n\nDuplicate a stateful Std.Do.SPred hypothesis.\n\nmhave is like have, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HQ\n\n\nmreplace is like replace, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HPQ\n\n\nmspecialize is like specialize, but operating on a stateful Std.Do.SPred goal.\nIt specializes a hypothesis from the stateful context with hypotheses from either the pure\nor stateful context or pure terms.example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mspecialize HPQ HP\n  mexact HPQ\n\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by\n  mintro HQ HΨ\n  mspecialize HΨ (y + 1) hP HQ\n  mexact HΨ\n\n\nmspecialize_pure is like mspecialize, but it specializes a hypothesis from the\npure context with hypotheses from either the pure or stateful context or pure terms.example (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by\n  mintro HQ\n  mspecialize_pure (hΨ (y + 1)) hP HQ => HΨ\n  mexact HΨ\n\n\nLike rcases, but operating on stateful Std.Do.SPred goals.\nExample: Given a goal h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R,\nmcases h with ⟨-, ⟨hq | hr⟩, hqr⟩ will yield two goals:\n(hq : Q, hqr : Q → R) ⊢ₛ R and (hr : R) ⊢ₛ R.That is, mcases h with pat has the following semantics, based on pat:* pat=□h' renames h to h' in the stateful context, regardless of whether h is pure* pat=⌜h'⌝ introduces h' : φ  to the pure local context if h : ⌜φ⌝\n(c.f. Lean.Elab.Tactic.Do.ProofMode.IsPure)* pat=h' is like pat=⌜h'⌝ if h is pure\n(c.f. Lean.Elab.Tactic.Do.ProofMode.IsPure), otherwise it is like pat=□h'.* pat=_ renames h to an inaccessible name* pat=- discards h* ⟨pat₁, pat₂⟩ matches on conjunctions and existential quantifiers and recurses via\npat₁ and pat₂.* ⟨pat₁ | pat₂⟩ matches on disjunctions, matching the left alternative via pat₁ and the right\nalternative via pat₂.\n\nmrename_i is like rename_i, but names inaccessible stateful hypotheses in a Std.Do.SPred goal.\n\nmpure moves a pure hypothesis from the stateful context into the pure context.example (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by\n  mintro Hφ\n  mpure Hφ\n  mexact (ψ Hφ)\n\n\nmframe infers which hypotheses from the stateful context can be moved into the pure context.\nThis is useful because pure hypotheses \"survive\" the next application of modus ponens\n(Std.Do.SPred.mp) and transitivity (Std.Do.SPred.entails.trans).It is used as part of the mspec tactic.example (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by\n  mintro _\n  mframe\n  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/\n  mcases h with hP\n  mexact h\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Verification Condition Generation\u0009Tactics for Stateful Goals in  Std.Do.SPred","header":"13.5.23.1.3. Manipulating Stateful Hypotheses","id":"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Manipulating-Stateful-Hypotheses"},"/Type-Classes/Instance-Synthesis/#default-instance-synth":{"contents":"When instance synthesis would otherwise fail, having not selected an instance, the default instances specified using the default_instance attribute are attempted in order of priority.\nWhen priorities are equal, more recently-defined default instances are chosen before earlier ones.\nThe first default instance that causes the search to succeed is chosen.\n\nDefault instances may induce further recursive instance search if the default instances themselves have instance-implicit parameters.\nIf the recursive search fails, the search process backtracks and the next default instance is tried.\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.6. Default Instances","id":"/Type-Classes/Instance-Synthesis/#default-instance-synth"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Language-server___-widgets___-and-IDE-extensions":{"contents":"* #4443 makes the watchdog be more resilient against badly behaving clients.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"Language server, widgets, and IDE extensions","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Language-server___-widgets___-and-IDE-extensions"},"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Pretty-printing":{"contents":"* #4558 fixes the pp.instantiateMVars setting and changes the default value to true.* #4631 makes sure syntax nodes always run their formatters. Fixes an issue where if ppSpace appears in a macro or elab command then it does not format with a space.* #4665 fixes a bug where pretty printed signatures (for example in #check) were overly hoverable due to pp.tagAppFns being set.* #4724 makes match pretty printer be sensitive to pp.explicit, which makes hovering over a match in the Infoview show the underlying term.* #4764 documents why anonymous constructor notation isn't pretty printed with flattening.* #4786 adjusts the parenthesizer so that only the parentheses are hoverable, implemented by having the parentheses \"steal\" the term info from the parenthesized expression.* #4854 allows arbitrarily long sequences of optional arguments to be omitted from the end of applications, versus the previous conservative behavior of omitting up to one optional argument.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.11.0 (2024-09-02)","header":"Pretty printing","id":"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Pretty-printing"},"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Pretty-printing":{"contents":"* #5640 fixes a bug where goal states in messages might print newlines as spaces.* #5643 adds option pp.mvars.delayed (default false), which when false causes delayed assignment metavariables to pretty print with what they are assigned to. Now fun x : Nat => ?a pretty prints as fun x : Nat => ?a rather than fun x ↦ ?m.7 x.* #5711 adds options pp.mvars.anonymous and pp.mvars.levels, which when false respectively cause expression metavariables and level metavariables to pretty print as ?_.* #5710 adjusts the ⋯ elaboration warning to mention pp.maxSteps.* #5759 fixes the app unexpander for sorryAx.* #5827 improves accuracy of binder names in the signature pretty printer (like in output of #check). Also fixes the issue where consecutive hygienic names pretty print without a space separating them, so we now have (x✝ y✝ : Nat) rather than (x✝y✝ : Nat).* #5830 makes sure all the core delaborators respond to pp.explicit when appropriate.* #5639 makes sure name literals use escaping when pretty printing.* #5854 adds delaborators for <|>, <*>, >>, <*, and *>.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.14.0 (2024-12-02)","header":"Pretty printing","id":"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Pretty-printing"}});