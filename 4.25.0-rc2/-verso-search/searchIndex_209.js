window.docContents[209].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Bitwise-Operations":{"contents":"Bitwise left shift of bounded numbers, with wraparound on overflow.Examples:* (1 : Fin 10) <<< (1 : Fin 10) = (2 : Fin 10)* (1 : Fin 10) <<< (3 : Fin 10) = (8 : Fin 10)* (1 : Fin 10) <<< (4 : Fin 10) = (6 : Fin 10)\n\nBitwise right shift of bounded numbers.This operator corresponds to logical rather than arithmetic bit shifting. The new bits are always\n0.Examples:* (15 : Fin 16) >>> (1 : Fin 16) = (7 : Fin 16)* (15 : Fin 16) >>> (2 : Fin 16) = (3 : Fin 16)* (15 : Fin 17) >>> (2 : Fin 17) = (3 : Fin 17)\n\nBitwise and.\n\nBitwise or.\n\nBitwise xor (“exclusive or”).\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"19.3.3.3. Bitwise Operations","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Bitwise-Operations"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Unbundled-Variants":{"contents":"Unbundled maps separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the modules Std.DHashMap.Raw and Std.DHashMap.RawLemmas.\n\nDependent hash maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer DHashMap\nover DHashMap.Raw. Lemmas about the operations on Std.Data.DHashMap.Raw are available in the\nmodule Std.Data.DHashMap.RawLemmas.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.The number of mappings present in the hash mapInternal implementation detail of the hash map\n\nWell-formedness predicate for hash maps. Users of DHashMap will not need to interact with\nthis. Users of DHashMap.Raw will need to provide proofs of WF to lemmas and should use lemmas\nlike WF.empty and WF.insert (which are always named exactly like the operations they are about)\nto show that map operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.Internal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash mapInternal implementation detail of the hash map\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","header":"19.18.3.7. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Unbundled-Variants"},"/Basic-Types/Natural-Numbers/#nat-api-conversion":{"contents":"Converts a natural number to an 8-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* Nat.toUInt8 5 = 5* Nat.toUInt8 255 = 255* Nat.toUInt8 256 = 0* Nat.toUInt8 259 = 3* Nat.toUInt8 32770 = 2\n\nConverts a natural number to a 16-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* Nat.toUInt16 5 = 5* Nat.toUInt16 255 = 255* Nat.toUInt16 32770 = 32770* Nat.toUInt16 65537 = 1\n\nConverts a natural number to a 32-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* Nat.toUInt32 5 = 5* Nat.toUInt32 65_539 = 65_539* Nat.toUInt32 4_294_967_299 = 3\n\nConverts a natural number to a 64-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.Examples:* Nat.toUInt64 5 = 5* Nat.toUInt64 65539 = 65539* Nat.toUInt64 4_294_967_299 = 4_294_967_299* Nat.toUInt64 18_446_744_073_709_551_620 = 4\n\nConverts an arbitrary-precision natural number to an unsigned word-sized integer, wrapping around on\noverflow.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number to an 8-bit signed integer, wrapping around to negative numbers on\noverflow.Examples:* Nat.toInt8 53 = 53* Nat.toInt8 127 = 127* Nat.toInt8 128 = -128* Nat.toInt8 255 = -1\n\nConverts a natural number to a 16-bit signed integer, wrapping around to negative numbers on\noverflow.Examples:* Nat.toInt16 127 = 127* Nat.toInt16 32767 = 32767* Nat.toInt16 32768 = -32768* Nat.toInt16 32770 = -32766\n\nConverts a natural number to a 32-bit signed integer, wrapping around to negative numbers on\noverflow.Examples:* Nat.toInt32 127 = 127* Nat.toInt32 32770 = 32770* Nat.toInt32 2_147_483_647 = 2_147_483_647* Nat.toInt32 2_147_483_648 = -2_147_483_648\n\nConverts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.Examples:* Nat.toInt64 127 = 127* Nat.toInt64 2_147_483_648 = 2_147_483_648* Nat.toInt64 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807* Nat.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808* Nat.toInt64 18_446_744_073_709_551_618 = 0\n\nConverts an arbitrary-precision natural number to a word-sized signed integer, wrapping around on\noverflow.This function is overridden at runtime with an efficient implementation.\n\nConverts a natural number into the closest-possible 64-bit floating-point number, or an infinite\nfloating-point value if the range of Float is exceeded.\n\nConverts a natural number into the closest-possible 32-bit floating-point number, or an infinite\nfloating-point value if the range of Float32 is exceeded.\n\nA Nat denotes a valid Unicode code point if it is less than 0x110000 and it is also not a\nsurrogate code point (the range 0xd800 to 0xdfff inclusive).\n\nConverts a natural number to its decimal string representation.\n\nReturns the decimal representation of a natural number as a list of digit characters in the given\nbase. If the base is greater than 16 then '*' is returned for digits greater than 0xf.Examples:* Nat.toDigits 10 0xff = ['2', '5', '5']* Nat.toDigits 8 0xc = ['1', '4']* Nat.toDigits 16 0xcafe = ['c', 'a', 'f', 'e']* Nat.toDigits 80 200 = ['2', '*']\n\nReturns a single digit representation of n, which is assumed to be in a base less than or equal to\n16. Returns '*' if n > 15.Examples:* Nat.digitChar 5 = '5'* Nat.digitChar 12 = 'c'* Nat.digitChar 15 = 'f'* Nat.digitChar 16 = '*'* Nat.digitChar 85 = '*'\n\nConverts a natural number to a string that contains the its decimal representation as Unicode\nsubscript digit characters.Examples:* Nat.toSubscriptString 0 = \"₀\"* Nat.toSubscriptString 35 = \"₃₅\"\n\nConverts a natural number to a string that contains the its decimal representation as Unicode\nsuperscript digit characters.Examples:* Nat.toSuperscriptString 0 = \"⁰\"* Nat.toSuperscriptString 35 = \"³⁵\"\n\nConverts a natural number to the list of Unicode superscript digit characters that corresponds to\nits decimal representation.Examples:* Nat.toSuperDigits 0 = ['⁰']* Nat.toSuperDigits 35 = ['³', '⁵']\n\nConverts a natural number to the list of Unicode subscript digit characters that corresponds to\nits decimal representation.Examples:* Nat.toSubDigits 0 = ['₀']* Nat.toSubDigits 35 = ['₃', '₅']\n\nConverts a natural number less than 10 to the corresponding Unicode subscript digit character.\nReturns '*' for other numbers.Examples:* Nat.subDigitChar 3 = '₃'* Nat.subDigitChar 7 = '₇'* Nat.subDigitChar 10 = '*'\n\nConverts a natural number less than 10 to the corresponding Unicode superscript digit character.\nReturns '*' for other numbers.Examples:* Nat.superDigitChar 3 = '³'* Nat.superDigitChar 7 = '⁷'* Nat.superDigitChar 10 = '*'\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"19.1.4.7. Conversion","id":"/Basic-Types/Natural-Numbers/#nat-api-conversion"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference":{"contents":"In addition to the general functions described here, there are some functions that are conventionally defined as part of the API of in the namespace of each collection type:\n\n* mapM maps a monadic function.* forM maps a monadic function, throwing away the result.* filterM filters using a monadic predicate, returning the values that satisfy it.\n\nMonadic Collection OperationsArray.filterM can be used to write a filter that depends on a side effect.def values := #[1, 2, 3, 5, 8]\ndef main : IO Unit := do\n  let filtered ← values.filterM fun v => do\n    repeat\n      IO.println s!\"Keep {v}? [y/n]\"\n      let answer := (← (← IO.getStdin).getLine).trim\n      if answer == \"y\" then return true\n      if answer == \"n\" then return false\n    return false\n  IO.println \"These values were kept:\"\n  for v in filtered do\n    IO.println s!\" * {v}\"\ny\nn\noops\ny\nn\ny\nKeep 1? [y/n]\nKeep 2? [y/n]\nKeep 3? [y/n]\nKeep 3? [y/n]\nKeep 5? [y/n]\nKeep 8? [y/n]\nThese values were kept:\n * 1\n * 3\n * 8\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation","header":"14.4. API Reference","id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Control-Flow":{"contents":"If the proposition p is true, does nothing, else fails (using failure).\n\nReturns some x if f succeeds with value x, else returns none.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009API Reference","header":"14.4.2. Control Flow","id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Control-Flow"},"/The-Simplifier/Configuring-Simplification/#simp-config":{"contents":"simp is primarily configured via a configuration parameter, passed as a named argument called config.\n\nThe configuration for simp.\nPassed to simp using, for example, the simp +contextual or simp (maxSteps := 100000) syntax.See also Lean.Meta.Simp.neutralConfig and Lean.Meta.DSimp.Config.The maximum number of subexpressions to visit when performing simplification.\nThe default is 100000.When simp discharges side conditions for conditional lemmas, it can recursively apply simplification.\nThe maxDischargeDepth (default: 2) is the maximum recursion depth when recursively applying simplification to side conditions.When contextual is true (default: false) and simplification encounters an implication p → q\nit includes p as an additional simp lemma when simplifying q.When true (default: true) then the simplifier caches the result of simplifying each sub-expression, if possible.When singlePass is true (default: false), the simplifier runs through a single round of simplification,\nwhich consists of running pre-methods, recursing using congruence lemmas, and then running post-methods.\nOtherwise, when it is false, it iteratively applies this simplification procedure.When true (default: true), performs zeta reduction of let and have expressions.\nThat is, let x := v; e[x] reduces to e[v].\nIf zetaHave is false then have expressions are not zeta reduced.\nSee also zetaDelta.When true (default: true), performs beta reduction of applications of fun expressions.\nThat is, (fun x => e[x]) v reduces to e[v].TODO (currently unimplemented). When true (default: true), performs eta reduction for fun expressions.\nThat is, (fun x => f x) reduces to f.Configures how to determine definitional equality between two structure instances.\nSee documentation for Lean.Meta.EtaStructMode.When true (default: true), reduces match expressions applied to constructors.When true (default: true), reduces projections of structure constructors.When true (default: false), rewrites a proposition p to True or False by inferring\na Decidable p instance and reducing it.When true (default: false), simplifies simple arithmetic expressions.When true (default: false), unfolds applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be enabled using the simp! syntax.When true (default: true) then switches to dsimp on dependent arguments\nif there is no congruence theorem that would allow simp to visit them.\nWhen dsimp is false, then the argument is not visited.If failIfUnchanged is true (default: true), then calls to simp, dsimp, or simp_all\nwill fail if they do not make progress.If ground is true (default: false), then ground terms are reduced.\nA term is ground when it does not contain free or meta variables.\nReduction is interrupted at a function application f ... if f is marked to not be unfolded.\nGround term reduction applies @[seval] lemmas.If unfoldPartialApp is true (default: false), then calls to simp, dsimp, or simp_all\nwill unfold even partial applications of f when we request f to be unfolded.When true (default: false), local definitions are unfolded.\nThat is, given a local context containing x : t := e, then the free variable x reduces to e.\nOtherwise, x must be provided as a simp argument.When index (default : true) is false, simp will only use the root symbol\nto find candidate simp theorems. It approximates Lean 3 simp behavior.If implicitDefEqProofs := true, simp does not create proof terms when the\ninput and output terms are definitionally equal.When true (default : true), then simp removes unused let and have expressions:\nlet x := v; e simplifies to e when x does not occur in e.\nThis option takes precedence over zeta and zetaHave.When true (default : true), then simp catches runtime exceptions and\nconverts them into simp exceptions.When false (default: true), then disables zeta reduction of have expressions.\nIf zeta is false, then this option has no effect.\nUnused haves are still removed if zeta or zetaUnused are true.When true (default : true), then simp will attempt to transform lets into haves\nif they are non-dependent. This only applies when zeta := false.When true (default: true), simp tries to realize constant f.congr_simp\nwhen constructing an auxiliary congruence proof for f.\nThis option exists because the termination prover uses simp and withoutModifyingEnv\nwhile constructing the termination proof. Thus, any constant realized by simp\nis deleted.When true (default: true), the bitvector simprocs use BitVec.ofNat for representing\nbitvector literals.When true (default: true), the ^ simprocs generate an warning it the exponents are too big.\n\nA neutral configuration for simp, turning off all reductions and other built-in simplifications.\n\nThe configuration for dsimp.\nPassed to dsimp using, for example, the dsimp (config := {zeta := false}) syntax.Implementation note: this structure is only used for processing the (config := ...) syntax, and it is not used internally.\nIt is immediately converted to Lean.Meta.Simp.Config by Lean.Elab.Tactic.elabSimpConfig.When true (default: true), performs zeta reduction of let and have expressions.\nThat is, let x := v; e[x] reduces to e[v].\nIf zetaHave is false then have expressions are not zeta reduced.\nSee also zetaDelta.When true (default: true), performs beta reduction of applications of fun expressions.\nThat is, (fun x => e[x]) v reduces to e[v].TODO (currently unimplemented). When true (default: true), performs eta reduction for fun expressions.\nThat is, (fun x => f x) reduces to f.Configures how to determine definitional equality between two structure instances.\nSee documentation for Lean.Meta.EtaStructMode.When true (default: true), reduces match expressions applied to constructors.When true (default: true), reduces projections of structure constructors.When true (default: false), rewrites a proposition p to True or False by inferring\na Decidable p instance and reducing it.When true (default: false), unfolds applications of functions defined by pattern matching, when one of the patterns applies.\nThis can be enabled using the simp! syntax.If failIfUnchanged is true (default: true), then calls to simp, dsimp, or simp_all\nwill fail if they do not make progress.If unfoldPartialApp is true (default: false), then calls to simp, dsimp, or simp_all\nwill unfold even partial applications of f when we request f to be unfolded.When true (default: false), local definitions are unfolded.\nThat is, given a local context containing x : t := e, then the free variable x reduces to e.\nOtherwise, x must be provided as a simp argument.When index (default : true) is false, simp will only use the root symbol\nto find candidate simp theorems. It approximates Lean 3 simp behavior.When true (default : true), then simp will remove unused let and have expressions:\nlet x := v; e simplifies to e when x does not occur in e.When false (default: true), then disables zeta reduction of have expressions.\nIf zeta is false, then this option has no effect.\nUnused haves are still removed if zeta or zetaUnused are true.\n\n\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.6. Configuring Simplification","id":"/The-Simplifier/Configuring-Simplification/#simp-config"},"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Variable-Bindings":{"contents":"Universe-polymorphic definitions bind universe variables.\nThese bindings may be either explicit or implicit.\nExplicit universe variable binding and instantiation occurs as a suffix to the definition's name.\nUniverse parameters are defined or provided by suffixing the name of a constant with a period (.) followed by a comma-separated sequence of universe variables between curly braces.\n\nUniverse-polymorphic mapThe following declaration of map declares two universe parameters (u and v) and instantiates the polymorphic List with each in turn:def map.{u, v} {α : Type u} {β : Type v}\n    (f : α → β) :\n    List.{u} α → List.{v} β\n  | [] => []\n  | x :: xs => f x :: map f xs\n\n\nJust as Lean automatically instantiates implicit parameters, it also automatically instantiates universe parameters.\nWhen automatic implicit parameter insertion is enabled (i.e. the autoImplicit option is set to true, which is the default), it is not necessary to explicitly bind universe variables; they are inserted automatically.\nWhen it is set to false, then they must be added explicitly or declared using the universe command. \n\nAutomatic Implicit Parameters and Universe PolymorphismWhen autoImplicit is true (which is the default setting), this definition is accepted even though it does not bind its universe parameters:set_option autoImplicit true\ndef map {α : Type u} {β : Type v} (f : α → β) : List α → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nWhen autoImplicit is false, the definition is rejected because u and v are not in scope:set_option autoImplicit false\ndef map {α : Type u} {β : Type v} (f : α → β) : List α → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nunknown universe level `u`\nunknown universe level `v`\n\n\nIn addition to using autoImplicit, particular identifiers can be declared as universe variables in a particular section scope using the universe command.\n\nUniverse Parameter DeclarationsDeclares one or more universe variables for the extent of the current scope.Just as the variable command causes a particular identifier to be treated as a parameter with a particular type, the universe command causes the subsequent identifiers to be implicitly quantified as universe parameters in declarations that mention them, even if the option autoImplicit is false.\n\nThe universe command when autoImplicit is falseset_option autoImplicit false\nuniverse u\ndef id₃ (α : Type u) (a : α) := a\n\n\nBecause the automatic implicit parameter feature only inserts parameters that are used in the declaration's header, universe variables that occur only on the right-hand side of a definition are not inserted as arguments unless they have been declared with universe even when autoImplicit is true.\n\nAutomatic universe parameters and the universe commandThis definition with an explicit universe parameter is accepted:def L.{u} := List (Type u)\nEven with automatic implicit parameters, this definition is rejected, because u is not mentioned in the header, which precedes the :=:set_option autoImplicit true\ndef L := List (Type u)\nunknown universe level `u`\nWith a universe declaration, u is accepted as a parameter even on the right-hand side:universe u\ndef L := List (Type u)\nThe resulting definition of L is universe-polymorphic, with u inserted as a universe parameter.Declarations in the scope of a universe command are not made polymorphic if the universe variables do not occur in them or in other automatically-inserted arguments.universe u\ndef L := List (Type 0)\n#check L\n\n\n","context":"Lean Reference\u0009Type System\u0009Universes\u0009Polymorphism","header":"4.3.2.2. Universe Variable Bindings","id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Variable-Bindings"}});