window.docContents[153].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key. There is also a Prop-valued version\nof this: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for comparisons, while for hash maps, both use ==.\n\nRetrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof\nof a ∈ m.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, panicking if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning none if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\nReturns a list of all keys present in the hash map in some order.\n\nReturns an array of all keys present in the hash map in some order.\n\nReturns a list of all values present in the hash map in some order.\n\nReturns an array of all values present in the hash map in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","header":"19.18.3.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Queries"},"/Definitions/#definitions":{"contents":"The following commands in Lean are definition-like: \n\n* def* abbrev* example* theorem* opaque\n\nAll of these commands cause Lean to elaborate a term based on a signature.\nWith the exception of example, which discards the result, the resulting expression in Lean's core language is saved for future use in the environment.\nThe instance command is described in the section on instance declarations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"7. Definitions","id":"/Definitions/#definitions"},"/Introduction/#The-Lean-Language-Reference--Introduction--How-to-Cite-This-Work":{"contents":"In formal citations, please cite this work as The Lean Language Reference by The Lean Developers.\nAdditionally, please include the corresponding version of Lean in the citation, which is 4.25.0-rc2.\n\n","context":"Lean Reference\u0009Introduction","header":"1.3. How to Cite This Work","id":"/Introduction/#The-Lean-Language-Reference--Introduction--How-to-Cite-This-Work"},"/Source-Files-and-Modules/#module-contents":{"contents":"When Lean elaborates a module, the result is an  environment.\nThe environment includes the constants, inductive types, theorems, type classes, instances, and everything else declared in the module, along with side tables that track data as diverse as simp sets, namespace aliases, and documentation comments.\n\nAs the module is processed by Lean, commands add content to the environment.\nA module's environment can be serialized to a .olean file, which contains both the environment and a compacted heap region with the run-time objects needed by the environment.\nThis means that an imported module can be loaded without re-executing all of its commands.\n\n","context":"Lean Reference\u0009Source Files and Modules","header":"5.4. Elaborated Modules","id":"/Source-Files-and-Modules/#module-contents"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Lake":{"contents":"* #5030 removes dead code.* #4770 adds additional fields to the package configuration which will be used by Reservoir. See the PR description for details.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Lake","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Lake"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Lean-internals":{"contents":"* Performance* Some core algorithms have been rewritten in C++ for performance.* #4910 and #4912 reimplement instantiateLevelMVars.* #4915, #4922, and #4931 reimplement instantiateExprMVars, 30% faster on a benchmark.* #4934 has optimizations for the kernel's Expr equality test.* #4990 fixes bug in hashing for the kernel's Expr equality test.* #4935 and #4936 skip some PreDefinition transformations if they are not needed.* #5225 adds caching for visited exprs at CheckAssignmentQuick in ExprDefEq.* #5226 maximizes term sharing at instantiateMVarDeclMVars, used by runTactic.* Diagnostics and profiling* #4923 adds profiling for instantiateMVars in Lean.Elab.MutualDef, which can be a bottleneck there.* #4924 adds diagnostics for large theorems, controlled by the diagnostics.threshold.proofSize option.* #4897 improves display of diagnostic results.* Other fixes or improvements* #4921 cleans up Expr.betaRev.* #4940 fixes tests by not writing directly to stdout, which is unreliable now that elaboration and reporting are executed in separate threads.* #4955 documents that stderrAsMessages is now the default on the command line as well.* #4647 adjusts documentation for building on macOS.* #4987 makes regular mvar assignments take precedence over delayed ones in instantiateMVars. Normally delayed assignment metavariables are never directly assigned, but on errors Lean assigns sorry to unassigned metavariables.* #4967 adds linter name to errors when a linter crashes.* #5043 cleans up command line snapshots logic.* #5067 minimizes some imports.* #5068 generalizes the monad for addMatcherInfo.* f71a1f adds missing test for #5126.* #5201 restores a test.* #3698 fixes a bug where label attributes did not pass on the attribute kind.* Typos: #5080, #5150, #5202\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Lean internals","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Lean-internals"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Highlights--Breaking-Changes":{"contents":"* #6602 allows the dot ident notation to resolve to the current\ndefinition, or to any of the other definitions in the same mutual block.\nExisting code that uses dot ident notation may need to have nonrec\nadded if the ident has the same name as the definition.* Introduction of the zetaUnused simp and reduction option (#6755)\nis a breaking change in rare cases: the split tactic no longer removes unused let and have expressions as a side-effect.\ndsimp only can be used to remove unused have and let expressions.\n\nThis highlights section was contributed by Violetta Sim.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)\u0009Highlights","header":"Breaking Changes","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Highlights--Breaking-Changes"}});