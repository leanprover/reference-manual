window.docContents[188].resolve({"/Basic-Types/Strings/#string-api":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings","header":"19.8.4. API Reference","id":"/Basic-Types/Strings/#string-api"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Internal-Kinds":{"contents":"The `group kind is used for nodes that result from Lean.Parser.group. This avoids confusion\nwith the null kind when used inside optional.\n\n`null is the “fallback” kind, used when no other kind applies. Null nodes result from\nrepetition operators, and empty null nodes represent the failure of an optional parse.The null kind is used for raw list parsers like many.\n\nThe `choice kind is used to represent ambiguous parse results.The parser prioritizes longer matches over shorter ones, but there is not always a unique longest\nmatch. All the parse results are saved, and the determination of which to use is deferred\nuntil typing information is available.\n\n`hygieneInfo is the node kind of the Lean.Parser.hygieneInfo parser, which produces an\n“invisible token” that captures the hygiene information at the current point without parsing\nanything.They can be used to generate identifiers (with Lean.HygieneInfo.mkIdent) as if they were\nintroduced in a macro's input, rather than by its implementation.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.4. Internal Kinds","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Internal-Kinds"},"/Notations-and-Macros/Macros/#defining-macros":{"contents":"There are two primary ways to define macros: the macro_rules command and the macro command.\nThe macro_rules command associates a macro with existing syntax, while the macro command simultaneously defines new syntax and a macro that translates it to existing syntax.\nThe macro command can be seen as a generalization of notation that allows the expansion to be generated programmatically, rather than simply by substitution.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros","header":"20.5.5. Defining Macros","id":"/Notations-and-Macros/Macros/#defining-macros"},"/Tactic-Proofs/Options/#tactic-language-options":{"contents":"These options affect the meaning of tactics.\n\nenable using custom eliminators in the 'induction' and 'cases' tactics defined using the '@[induction_eliminator]' and '@[cases_eliminator]' attributes\n\nin the rw and simp tactics, if an instance implicit argument is assigned, do not try to synthesize instance.\n\nWhen tracing is enabled, calls to simp or dsimp will print an equivalent simp only call.\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.4. Options","id":"/Tactic-Proofs/Options/#tactic-language-options"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-control":{"contents":"Strictly speaking, there is no fundamental distinction between control structures and other tactics.\nAny tactic is free to take others as arguments and arrange for their execution in any context that it sees fit.\nEven if a distinction is arbitrary, however, it can still be useful.\nThe tactics in this section are those that resemble traditional control structures from programming, or those that only recombine other tactics rather than making progress themselves.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","header":"13.3.1. Control Structures","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-control"},"/releases/v4.0.0/#release-v4___0___0":{"contents":"* Lean.Meta.getConst? has been renamed.\nWe have renamed getConst? to getUnfoldableConst? (and getConstNoEx? to getUnfoldableConstNoEx?).\nThese were not intended to be part of the public API, but downstream projects had been using them\n(sometimes expecting different behaviour) incorrectly instead of Lean.getConstInfo.* dsimp / simp / simp_all now fail by default if they make no progress.This can be overridden with the (config := { failIfUnchanged := false }) option.\nThis change was made to ease manual use of simp (with complicated goals it can be hard to tell if it was effective)\nand to allow easier flow control in tactics internally using simp.\nSee the summary discussion\non zulip for more details.* simp_all now preserves order of hypotheses.In order to support the failIfUnchanged configuration option for dsimp / simp / simp_all\nthe way simp_all replaces hypotheses has changed.\nIn particular it is now more likely to preserve the order of hypotheses.\nSee simp_all reorders hypotheses unnecessarily.\n(Previously all non-dependent propositional hypotheses were reverted and reintroduced.\nNow only such hypotheses which were changed, or which come after a changed hypothesis,\nare reverted and reintroduced.\nThis has the effect of preserving the ordering amongst the non-dependent propositional hypotheses,\nbut now any dependent or non-propositional hypotheses retain their position amongst the unchanged\nnon-dependent propositional hypotheses.)\nThis may affect proofs that use rename_i, case ... =>, or next ... =>.* New have this implementation.this is now a regular identifier again that is implicitly introduced by anonymous have := for the remainder of the tactic block. It used to be a keyword that was visible in all scopes and led to unexpected behavior when explicitly used as a binder name.* Show typeclass and tactic names in profile output.* Make calc require the sequence of relation/proof-s to have the same indentation,\nand add calc alternative syntax allowing underscores _ in the first relation.The flexible indentation in calc was often used to align the relation symbols:example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=\n  calc\n      (x + y) * (x + y) = (x + y) * x + (x + y) * y       := by rw [Nat.mul_add]\n                      -- improper indentation\n                      _ = x * x + y * x + (x + y) * y     := by rw [Nat.add_mul]\n                      _ = x * x + y * x + (x * y + y * y) := by rw [Nat.add_mul]\n                      _ = x * x + y * x + x * y + y * y   := by rw [←Nat.add_assoc]\nThis is no longer legal.  The new syntax puts the first term right after the calc and each step has the same indentation:example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=\n  calc (x + y) * (x + y)\n    _ = (x + y) * x + (x + y) * y       := by rw [Nat.mul_add]\n    _ = x * x + y * x + (x + y) * y     := by rw [Nat.add_mul]\n    _ = x * x + y * x + (x * y + y * y) := by rw [Nat.add_mul]\n    _ = x * x + y * x + x * y + y * y   := by rw [←Nat.add_assoc]\n* Update Lake to latest prerelease.* Make go-to-definition on a typeclass projection application go to the instance(s).* Include timings in trace messages when profiler is true.* Pretty-print signatures in hover and #check <ident>.* Introduce parser memoization to avoid exponential behavior.* feat: allow doSeq in let x <- e | seq.* Add hover/go-to-def/refs for options.* Add empty type ascription syntax (e :).* Make tokens in <|> relevant to syntax match.* Add linter.deprecated option to silence deprecation warnings.* Improve fuzzy-matching heuristics.* Implementation-detail hypotheses.* Hover information for cases/induction case names.* Prefer longer parse even if unsuccessful.* Show declaration module in hover.* New conv mode structuring tactics.* simp can track information and can print an equivalent simp only. PR #1626.* Enforce uniform indentation in tactic blocks / do blocks. See issue #1606.* Moved AssocList, HashMap, HashSet, RBMap, RBSet, PersistentArray, PersistentHashMap, PersistentHashSet to the Lean package. The standard library contains versions that will evolve independently to simplify bootstrapping process.* Standard library moved to the std4 GitHub repository.* InteractiveGoals now has information that a client infoview can use to show what parts of the goal have changed after applying a tactic. PR #1610.* Add [inheritDoc] attribute. PR #1480.* Expose that panic = default. PR #1614.* New code generator project has started.* Remove description argument from register_simp_attr. PR #1566.* Additional concurrency primitives.* Collapsible traces with messages.* Hygienic resolution of namespaces.* New Float functions.* Many new doc strings have been added to declarations at Init.\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.0.0 (2023-09-08)","id":"/releases/v4.0.0/#release-v4___0___0"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Library-highlights":{"contents":"Notable additions to the standard library are:\n\n* Iterators (#8420, #8545, #8615, #8629, #8768),* monadic interface for Async operations (#8003),* DNS functions (#8072),* system information functions (#8109).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Library highlights","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Library-highlights"}});