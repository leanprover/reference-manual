window.docContents[215].resolve({"/Basic-Types/Natural-Numbers/#Nat":{"contents":"The natural numbers are nonnegative integers.\nLogically, they are the numbers 0, 1, 2, 3, …, generated from the constructors Nat.zero and Nat.succ.\nLean imposes no upper bound on the representation of natural numbers other than physical constraints imposed by the available memory of the computer.\n\nBecause the natural numbers are fundamental to both mathematical reasoning and programming, they are specially supported by Lean's implementation. The logical model of the natural numbers is as an inductive type, and arithmetic operations are specified using this model. In Lean's kernel, the interpreter, and compiled code, closed natural numbers are represented as efficient arbitrary-precision integers. Sufficiently small numbers are values that don't require indirection through a pointer. Arithmetic operations are implemented by primitives that take advantage of the efficient representations.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.1. Natural Numbers","id":"/Basic-Types/Natural-Numbers/#Nat"},"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References--State-Transformers--Comparisons":{"contents":"Checks whether two reference cells are in fact aliases for the same cell.Even if they contain the same value, two references allocated by different executions of IO.mkRef\nor ST.mkRef are distinct. Modifying one has no effect on the other. Likewise, a single reference\ncell may be aliased, and modifications to one alias also modify the other.\n\n","context":"Lean Reference\u0009IO\u0009Mutable References\u0009State Transformers","header":"15.4.1.2. Comparisons","id":"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References--State-Transformers--Comparisons"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Promises":{"contents":"Promises represent a value that will be supplied in the future.\nSupplying the value is called resolving the promise.\nOnce created, a promise can be stored in a data structure or passed around like any other value, and attempts to read from it will block until it is resolved.\n\nPromise α allows you to create a Task α whose value is provided later by calling resolve.Typical usage is as follows:1. let promise ← Promise.new creates a promise2. promise.result? : Task (Option α) can now be passed around3. promise.result?.get blocks until the promise is resolved4. promise.resolve a resolves the promise5. promise.result?.get now returns some aIf the promise is dropped without ever being resolved, promise.result?.get will return none.\nSee Promise.result!/resultD for other ways to handle this case.\n\nCreates a new Promise.\n\nChecks whether the promise has already been resolved, i.e. whether access to result* will return\nimmediately.\n\nLike Promise.result, but resolves to none if the promise is dropped without ever being resolved.\n\nThe result task of a Promise.The task blocks until Promise.resolve is called. If the promise is dropped without ever being\nresolved, evaluating the task will panic and, when not using fatal panics, block forever. As\nPromise.result! is a pure value and thus the point of evaluation may not be known precisely, this\nmeans that any promise on which Promise.result! may be evaluated must be resolved eventually.\nWhen in doubt, always prefer Promise.result? to handle dropped promises explicitly.\n\nLike Promise.result, but resolves to dflt if the promise is dropped without ever being resolved.\n\nResolves a Promise.Only the first call to this function has an effect.\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads","header":"15.11.5. Promises","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Promises"},"/Terms/Quotation-and-Antiquotation/#The-Lean-Language-Reference--Terms--Quotation-and-Antiquotation":{"contents":"Quotation terms are described in the section on quotation.\n\n","context":"Lean Reference\u0009Terms","header":"10.11. Quotation and Antiquotation","id":"/Terms/Quotation-and-Antiquotation/#The-Lean-Language-Reference--Terms--Quotation-and-Antiquotation"},"/releases/v4.0.0-m1/#The-Lean-Language-Reference--Release-Notes--Lean-4___0___0-m1-_LPAR_2021-01-04_RPAR_--Acknowledgements":{"contents":"* Daniel Selsam - type class resolution, feedback, design discussions* Marc Huisinga and Wojciech Nawrocki - Lean Server* Joe Hendrix, Andrew Kent, Rob Dockins, Simon Winwood (Galois Inc) - early adopters, suggestions, feedback* Daan Leijen, Simon Peyton Jones, Nikhil Swamy, Sebastian Graf, Max Wagner - design discussions, feedback, suggestions\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.0.0-m1 (2021-01-04)","header":"Acknowledgements","id":"/releases/v4.0.0-m1/#The-Lean-Language-Reference--Release-Notes--Lean-4___0___0-m1-_LPAR_2021-01-04_RPAR_--Acknowledgements"},"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Compiler___-runtime___-and-FFI":{"contents":"* #3632 makes it possible to allocate and free thread-local runtime resources for threads not started by Lean itself.* #3627 improves error message about compacting closures.* #3692 fixes deadlock in IO.Promise.resolve.* #3753 catches error code from MoveFileEx on Windows.* #4028 fixes a double reset bug in ResetReuse transformation.* 6e731b\nremoves interpreter copy constructor to avoid potential memory safety issues.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.8.0 (2024-06-05)","header":"Compiler, runtime, and FFI","id":"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Compiler___-runtime___-and-FFI"}});