window.docContents[212].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Conversion":{"contents":"Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence.\n\nCreates a hash map from an array of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofArray, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\nCreates a hash map from a list of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofList, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Maps","header":"19.18.4.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Conversion"},"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Compiler-IR":{"contents":"The compiler option trace.compiler.ir.result can be used to inspect the compiler's intermediate representation (IR) for a function.\nIn this intermediate representation, reference counting, allocation, and reuse are explicit:\n\n* The isShared operator checks whether a reference count is 1.* ctor_n allocates the nth constructor of a type.* proj_n retrieves the nth field from a constructor value.* set x﻿[n﻿] mutates the nth field of the constructor in x.* ret x returns the value in x.\n\nThe specifics of reference count manipulations can depend on the results of optimization passes such as inlining.\nWhile the vast majority of Lean code doesn't require this kind of attention to achieve good performance, knowing how to diagnose unique reference issues can be very important when writing performance-critical code.\n\nenable/disable tracing for the given module and submodules\n\nReference Counts in IRCompiler IR can be used to observe when reference counts are incremented, which can help diagnose situations when a value is expected to have a unique incoming reference, but is in fact shared.\nHere, process and process' each take a string as a parameter and modify it with String.set, returning a pair of strings.\nWhile process returns a constant string as the second element of the pair, process' returns the original string.set_option trace.compiler.ir.result true\ndef process (str : String) : String × String :=\n  (str.set 0 ' ', \"\")\ndef process' (str : String) : String × String:=\n  (str.set 0 ' ', str)\nThe IR for process includes no inc or dec instructions.\nIf the incoming string x_1 is a unique reference, then it is still a unique reference when passed to String.set, which can then use in-place modification:[Compiler.IR] [result]\n    def process._closed_0 : obj :=\n      let x_1 : obj := \"\";\n      ret x_1\n    def process (x_1 : obj) : obj :=\n      let x_2 : tagged := 0;\n      let x_3 : u32 := 32;\n      let x_4 : obj := String.set x_1 x_2 x_3;\n      let x_5 : obj := process._closed_0;\n      let x_6 : obj := ctor_0[Prod.mk] x_4 x_5;\n      ret x_6\nThe IR for process', on the other hand, increments the reference count of the string just before calling String.set.\nThus, the modified string x_4 is a copy, regardless of whether the original reference to x_1 is unique:[Compiler.IR] [result]\n    def process' (x_1 : obj) : obj :=\n      let x_2 : tagged := 0;\n      let x_3 : u32 := 32;\n      inc x_1;\n      let x_4 : obj := String.set x_1 x_2 x_3;\n      let x_5 : obj := ctor_0[Prod.mk] x_4 x_1;\n      ret x_5\n\n\nMemory Re-Use in IRThe function discardElems is a simplified version of List.map that replaces every element in a list with ().\nInspecting its intermediate representation demonstrates that it will re-use the list's memory when its reference is unique.set_option trace.compiler.ir.result true\n\ndef discardElems : List α → List Unit\n  | [] => []\n  | x :: xs => () :: discardElems xs\nThis emits the following IR:[Compiler.IR] [result]\n    def discardElems._redArg (x_1 : tobj) : tobj :=\n      case x_1 : tobj of\n      List.nil →\n        let x_2 : tagged := ctor_0[List.nil];\n        ret x_2\n      List.cons →\n        let x_3 : u8 := isShared x_1;\n        case x_3 : u8 of\n        Bool.false →\n          let x_4 : tobj := proj[1] x_1;\n          let x_5 : tobj := proj[0] x_1;\n          dec x_5;\n          let x_6 : tagged := ctor_0[PUnit.unit];\n          let x_7 : tobj := discardElems._redArg x_4;\n          set x_1[1] := x_7;\n          set x_1[0] := x_6;\n          ret x_1\n        Bool.true →\n          let x_8 : tobj := proj[1] x_1;\n          inc x_8;\n          dec x_1;\n          let x_9 : tagged := ctor_0[PUnit.unit];\n          let x_10 : tobj := discardElems._redArg x_8;\n          let x_11 : obj := ctor_1[List.cons] x_9 x_10;\n          ret x_11\n    def discardElems (x_1 : ◾) (x_2 : tobj) : tobj :=\n      let x_3 : tobj := discardElems._redArg x_2;\n      ret x_3\nIn the IR, the List.cons case explicitly checks whether the argument value is shared (i.e. whether it's reference count is greater than one).\nIf the reference is unique, the reference count of the discarded list element x_5 is decremented and the constructor value is reused.\nIf it is shared, a new List.cons is allocated in x_11 for the result.\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Reference Counting","header":"21.2.2. Compiler IR","id":"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Compiler-IR"},"/Tactic-Proofs/Custom-Tactics/#custom-tactics":{"contents":"\n\nTactics are productions in the syntax category tactic. \nGiven the syntax of a tactic, the tactic interpreter is responsible for carrying out actions in the tactic monad TacticM, which is a wrapper around Lean's term elaborator that keeps track of the additional state needed to execute tactics.\nA custom tactic consists of an extension to the tactic category along with either:\n\n* a macro that translates the new syntax into existing syntax, or* an elaborator that carries out TacticM actions to implement the tactic.\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.8. Custom Tactics","id":"/Tactic-Proofs/Custom-Tactics/#custom-tactics"},"/The-Type-System/Inductive-Types/#structure-fields":{"contents":"Each field of a structure declaration corresponds to a parameter of the constructor.\nAuto-implicit arguments are inserted in each field separately, even if their names coincide, and the fields become constructor parameters that quantify over types.\n\nAuto-implicit parameters in structure fieldsThe structure MyStructure contains a field whose type is an auto-implicit parameter:structure MyStructure where\n  field1 : α\n  field2 : α\nThe type constructor MyStructure takes two universe parameters:MyStructure.{u, v} : Type (max u v)\nThe resulting type is in Type rather than Sort because the constructor fields quantify over types in Sort. In particular, both fields in its constructor MyStructure.mk take an implicit type parameter:MyStructure.mk.{u, v}\n  (field1 : {α : Sort u} → α)\n  (field2 : {α : Sort v} → α)\n  : MyStructure.{u,v}\n\n\nFor each field, a projection function is generated that extracts the field's value from the underlying type's constructor.\nThis function is in the structure's name's namespace.\nStructure field projections are handled specially by the elaborator (as described in the section on structure inheritance), which performs extra steps beyond looking up a namespace.\nWhen field types depend on prior fields, the types of the dependent projection functions are written in terms of earlier projections, rather than explicit pattern matching.\n\nDependent projection typesThe structure ArraySized contains a field whose type depends on both a structure parameter and an earlier field:structure ArraySized (α : Type u) (length : Nat)  where\n  array : Array α\n  size_eq_length : array.size = length\nThe signature of the projection function size_eq_length takes the structure type's parameter as an implicit parameter and refers to the earlier field using the corresponding projection:ArraySized.size_eq_length.{u}\n  {α : Type u} {length : Nat}\n  (self : ArraySized α length)\n  : self.array.size = length\n\n\nStructure fields may have default values, specified with :=.\nThese values are used if no explicit value is provided.\n\nDefault valuesAn adjacency list representation of a graph can be represented as an array of lists of Nat.\nThe size of the array indicates the number of vertices, and the outgoing edges from each vertex are stored in the array at the vertex's index.\nBecause the default value #[] is provided for the field adjacency, the empty graph Graph.empty can be constructed without providing any field values.structure Graph where\n  adjacency : Array (List Nat) := #[]\n\ndef Graph.empty : Graph := {}\n\n\nStructure fields may additionally be accessed via their index, using dot notation.\nFields are numbered beginning with 1.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Structure Declarations","header":"4.4.2.2. Fields","id":"/The-Type-System/Inductive-Types/#structure-fields"}});