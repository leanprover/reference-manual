window.docContents[10].resolve({"/Axioms/#axiom-reduction":{"contents":"Even consistent axioms can cause difficulties.\nDefinitional equality identifies terms modulo reduction rules.\nThe ι-reduction rule specifies the interaction of recursors and constructors; because axioms are not constructors, it does not apply to them.\nOrdinarily, terms without free variables reduce to applications of constructors, but axioms can cause them to get “stuck,” resulting in large terms.\n\nAxioms and Stuck ReductionAdding an additional 0 to Nat with an axiom results in some definitional reductions getting stuck.\nIn this example, two Nat.succ constructors are successfully moved to the outside of the term by reduction, but Nat.rec is unable to make further progress after encountering Nat.otherZero.axiom Nat.otherZero : Nat\n\n#reduce 4 + (Nat.otherZero + 2)\n((Nat.rec ⟨fun x => x, PUnit.unit⟩ (fun n n_ih => ⟨fun x => (n_ih.1 x).succ, n_ih⟩) Nat.otherZero).1 4).succ.succ\n\n\nFurthermore, the Lean compiler is not able to generate code for axioms.\nAt runtime, Lean values must be represented by concrete data in memory, but axioms do not have a concrete representation.\nDefinitions that contain non-proof code that relies on axioms must be marked noncomputable and can't be compiled.\n\nAxioms and CompilationAdding an additional 0 to Nat with an axiom makes it so functions that use it can't be compiled.\nIn particular, List.length' returns the axiom Nat.otherZero instead of Nat.zero as the length of the empty list.axiom Nat.otherZero : Nat\n\ndef List.length' : List α → Nat\n  | [] => Nat.otherZero\n  | _ :: _ => xs.length\n`Nat.otherZero` not supported by code generator; consider marking definition as `noncomputable`\nAxioms used in proofs rather than programs do not prevent a function from being compiled.\nThe compiler does not generate code for proofs, so axioms in proofs are no problem.\nnextOdd computes the next odd number from a Nat, which may be the number itself or one greater:def nextOdd (k : Nat) :\n    { n : Nat // n % 2 = 1 ∧ (n = k ∨ n = k + 1) } where\n  val := if k % 2 = 1 then k else k + 1\n  property := by\n    by_cases k % 2 = 1 <;>\n    simp [*] <;> omega\nThe tactic proof generates a term that transitively relies on three axioms:#print axioms nextOdd\n'nextOdd' depends on axioms: [propext, Classical.choice, Quot.sound]\nBecause they occur only in a proof, the compiler has no problem generating code:#eval (nextOdd 4, nextOdd 5)\n(5, 5)\n\n\n","context":"Lean Reference\u0009Axioms","header":"8.3. Reduction","id":"/Axioms/#axiom-reduction"},"/Basic-Types/Strings/#string-interpolation":{"contents":"Preceding a string literal with s! causes it to be processed as an interpolated string, in which regions of the string surrounded by { and } characters are parsed and interpreted as Lean expressions.\nInterpolated strings are interpreted by appending the string that precedes the interpolation, the expression (with an added call to toString surrounding it), and the string that follows the interpolation.\n\nFor example:\n\nexample :\n    s!\"1 + 1 = {1 + 1}\\n\" =\n    \"1 + 1 = \" ++ toString (1 + 1) ++ \"\\n\" :=\n  rfl\n\n\nPreceding a literal with m! causes the interpolation to result in an instance of MessageData, the compiler's internal data structure for messages to be shown to users.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009Syntax","header":"19.8.3.2. Interpolated Strings","id":"/Basic-Types/Strings/#string-interpolation"},"/The--grind--tactic/Bigger-Examples/#grind-bigger-examples":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.10. Bigger Examples","id":"/The--grind--tactic/Bigger-Examples/#grind-bigger-examples"},"/The-Type-System/Inductive-Types/#inductive-types-standard-representation":{"contents":"If an inductive type doesn't fall into one of the categories above, then its representation is determined by its constructors.\nConstructors without relevant parameters are represented by their index into the list of constructors, as unboxed unsigned machine integers (scalars).\nConstructors with relevant parameters are represented as an object with a header, the constructor's index, an array of pointers to other objects, and then arrays of scalar fields sorted by their types.\nThe header tracks the object's reference count and other necessary bookkeeping.\n\nRecursive functions are compiled as they are in most programming languages, rather than by using the inductive type's recursor.\nElaborating recursive functions to recursors serves to provide reliable termination evidence, not executable code.\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation","header":"4.4.4.4. Other Inductive Types","id":"/The-Type-System/Inductive-Types/#inductive-types-standard-representation"},"/The-Type-System/Quotients/#quotients":{"contents":"Quotient types allow a new type to be formed by decreasing the granularity of an existing type's propositional equality.\nIn particular, given a type A and an equivalence relation \\sim, the quotient A / \\sim contains the same elements as A, but every pair of elements that are related by \\sim are considered equal.\nEquality is respected universally; nothing in Lean's logic can observe any difference between two equal terms.\nThus, quotient types provide a way to build an impenetrable abstraction barrier.\nIn particular, all functions from a quotient type must prove that they respect the equivalence relation.\n\nQuotient types coarsen the propositional equality for a type so that terms related by some\nequivalence relation are considered equal. The equivalence relation is given by an instance of\nSetoid.Set-theoretically, Quotient s can seen as the set of equivalence classes of α modulo the\nSetoid instance's relation s.r. Functions from Quotient s must prove that they respect s.r:\nto define a function f : Quotient s → β, it is necessary to provide f' : α → β and prove that\nfor all x : α and y : α, s.r x y → f' x = f' y. Quotient.lift implements this operation.The key quotient operators are:* Quotient.mk places elements of the underlying type α into the quotient.* Quotient.lift allows the definition of functions from the quotient to some other type.* Quotient.sound asserts the equality of elements related by r* Quotient.ind is used to write proofs about quotients by assuming that all elements are\nconstructed with Quotient.mk.Quotient is built on top of the primitive quotient type Quot, which does not require a proof\nthat the relation is an equivalence relation. Quotient should be used instead of Quot for\nrelations that actually are equivalence relations.\n\nA proof that two elements of the underlying type are related by the equivalence relation is sufficient to prove that they are equal in the Quotient.\nHowever, definitional equality is unaffected by the use of Quotient: two elements in the quotient are definitionally equal if and only if they are definitionally equal in the underlying type.\n\nQuotient types are not widely used in programming.\nHowever, they occur regularly in mathematics: Integers\n\nThe integers are traditionally defined as a pair of natural numbers (n, k) that encodes the integer n - k.\n  In this encoding, two integers (n_1, k_1) and (n_2, k_2) are equal if n_1 + k_2 = n_2 + k_1.\n\n Rational Numbers\n\nThe number \\frac{n}{d} can be encoded as the pair (n, d), where d \\neq 0.\n  Two rational numbers \\frac{n_1}{d_1} and \\frac{n_2}{d_2} are equal if n_1 d_2 = n_2 d_1.\n\n Real Numbers\n\nThe real numbers can be represented as a Cauchy sequence, but this encoding is not unique.\n  Using a quotient type, two Cauchy sequences can be made equal when their difference converges to zero.\n\n Finite Sets\n\nFinite sets can be represented as lists of elements.\n  With a quotient types, two finite sets can be made equal if they contain the same elements; this definition does not impose any requirements (such as decidable equality or an ordering relation) on the type of elements.\n\n\n\nOne alternative to quotient types would be to reason directly about the equivalence classes introduced by the relation.\nThe downside of this approach is that it does not allow computation: in addition to knowing that there is an integer that is the sum of 5 and 8, it is useful for 5 + 8 = 13 to not be a theorem that requires proof.\nDefining functions out of sets of equivalence classes relies on non-computational classical reasoning principles, while functions from quotient types are ordinary computational functions that additionally respect an equivalence relation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System","header":"4.5. Quotients","id":"/The-Type-System/Quotients/#quotients"}});