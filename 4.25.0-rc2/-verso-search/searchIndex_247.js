window.docContents[247].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Tangent":{"contents":"Computes the tangent of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntan.\n\nComputes the tangent of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanf.\n\nComputes the hyperbolic tangent of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanh.\n\nComputes the hyperbolic tangent of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanhf.\n\nComputes the arc tangent (inverse tangent) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan.\n\nComputes the arc tangent (inverse tangent) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanf.\n\nComputes the hyperbolic arc tangent (inverse tangent) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanh.\n\nComputes the hyperbolic arc tangent (inverse tangent) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanhf.\n\nComputes the arc tangent (inverse tangent) of y / x in radians, in the range -π–π. The signs\nof the arguments determine the quadrant of the result.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan2.\n\nComputes the arc tangent (inverse tangent) of y / x in radians, in the range -π–π. The signs\nof the arguments determine the quadrant of the result.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan2f.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Trigonometry","header":"19.6.2.9.3. Tangent","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Tangent"},"/Basic-Types/Linked-Lists/#list-syntax":{"contents":"List literals are written in square brackets, with the elements of the list separated by commas.\nThe constructor List.cons that adds an element to the front of a list is represented by the infix operator ::.\nThe syntax for lists can be used both in ordinary terms and in patterns.\n\nList LiteralsThe syntax [a, b, c] is shorthand for a :: b :: c :: [], or\nList.cons a (List.cons b (List.cons c List.nil)). It allows conveniently constructing\nlist literals.For lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\nlet left := [d, e, f]; a :: b :: c :: left to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like dbg_trace.Conventions for notations in identifiers:* The recommended spelling of [] in identifiers is nil.* The recommended spelling of [a] in identifiers is singleton.\n\nList ConstructionThe list whose first element is head, where tail is the rest of the list.\nUsually written head :: tail.Conventions for notations in identifiers:* The recommended spelling of :: in identifiers is cons.\n\nConstructing ListsAll of these examples are equivalent:example : List Nat := [1, 2, 3]\nexample : List Nat := 1 :: [2, 3]\nexample : List Nat := 1 :: 2 :: [3]\nexample : List Nat := 1 :: 2 :: 3 :: []\nexample : List Nat := 1 :: 2 :: 3 :: .nil\nexample : List Nat := 1 :: 2 :: .cons 3 .nil\nexample : List Nat := .cons 1 (.cons 2 (.cons 3 .nil))\n\n\nPattern Matching and ListsAll of these functions are equivalent:def split : List α → List α × List α\n  | [] => ([], [])\n  | [x] => ([x], [])\n  | x :: x' :: xs =>\n    let (ys, zs) := split xs\n    (x :: ys, x' :: zs)\ndef split' : List α → List α × List α\n  | .nil => (.nil, .nil)\n  | x :: [] => (.singleton x, .nil)\n  | x :: x' :: xs =>\n    let (ys, zs) := split xs\n    (x :: ys, x' :: zs)\ndef split'' : List α → List α × List α\n  | .nil => (.nil, .nil)\n  | .cons x .nil=> (.singleton x, .nil)\n  | .cons x (.cons x' xs) =>\n    let (ys, zs) := split xs\n    (.cons x ys, .cons x' zs)\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists","header":"19.15.1. Syntax","id":"/Basic-Types/Linked-Lists/#list-syntax"},"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch":{"contents":"\n\nThis error occurs when a parameter of an inductive type is not uniform in an inductive\ndeclaration. The parameters of an inductive type (i.e., those that appear before the colon following\nthe inductive keyword) must be identical in all occurrences of the type being defined in its\nconstructors' types. If a parameter of an inductive type must vary between constructors, make the\nparameter an index by moving it to the right of the colon. See the manual section on\nInductive Types for additional details.\n\nNote that auto-implicit inlay hints always appear left of the colon in an inductive declaration\n(i.e., as parameters), even when they are actually indices. This means that double-clicking on an\ninlay hint to insert such parameters may result in this error. If it does, change the inserted\nparameters to indices.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.inductiveParamMismatch","id":"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators":{"contents":"Infix operators are primarily useful in smaller expressions, or when there is no Monad instance.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax","header":"14.3.1. Infix Operators","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Bitwuzla-Rewrite-Rules":{"contents":"* #7424 proves Bitwuzla's rule\nBV_ZERO_EXTEND_ELIM:theorem setWidth_eq_append {v : Nat} {x : BitVec v} {w : Nat} (h : v ≤ w) :\n    x.setWidth w = ((0#(w - v)) ++ x).cast (by omega) := by\n* #7426 adds the Bitwuzla rewrite rule\nBV_EXTRACT_FULL,\nwhich is useful for the bitblaster to simplify extractLsb' based\nexpressions.* #7427 implements the bitwuzla rule\nBV_CONCAT_EXTRACT.\nThis will be used by the bitblaster to simplify adjacent extracts\ninto a single extract.* #7454 implements the bitwuzla rule\nBV_SIGN_EXTEND_ELIM,\nwhich rewrites a signExtend x as an append of the appropriate sign\nbits, followed by the bits of x.* #7461 introduces a bitvector associativity/commutativity normalization\non bitvector terms of the form (a * b) = (c * d) for a, b, c, d\nbitvectors. This mirrors Bitwuzla's PassNormalize::process's\nPassNormalize::normalize_eq_add_mul.* #7481 implements the Bitwuzla rewrites BV_ADD_NEG_MUL, and\nassociated lemmas to make the proof streamlined. bvneg (bvadd a (bvmul a b)) = (bvmul a (bvnot b)), or spelled as lean:theorem neg_add_mul_eq_mul_not {x y : BitVec w} :\n    - (x + x * y) = (x * ~~~ y)\n* #7482 implements the\nBV_EXTRACT_CONCAT\nrule from Bitwuzla, which explains how to extract bits from an append.\nWe first prove a 'master theorem' which has the full case analysis, from\nwhich we rapidly derive the necessary BV_EXTRACT_CONCAT theorems:theorem extractLsb'_append_eq_ite {v w} {xhi : BitVec v} {xlo : BitVec w} {start len : Nat} :\n    extractLsb' start len (xhi ++ xlo) =\n    if hstart : start < w\n    then\n      if hlen : start + len < w\n      then extractLsb' start len xlo\n      else\n        (((extractLsb' (start - w) (len - (w - start)) xhi) ++\n            extractLsb' start (w - start) xlo)).cast (by omega)\n    else\n      extractLsb' (start - w) len xhi\n\n* #7493 implements the Bitwuzla rewrite rule\nNORM_BV_ADD_MUL,\nand the associated lemmas to allow for expedient rewriting:theorem neg_add_mul_eq_mul_not {x y : BitVec w} : - (x + x * y) = x * ~~~ y\n* #7508 shows that negation commutes with left shift, which is the\nBitwuzla rewrite\nNORM_BV_SHL_NEG.* #7594 implements the Bitwuzla rewrites\nBV_EXTRACT_ADD_MUL,\nwhich witness that the high bits at i >= len do not affect the bits of\nthe product upto len.* #7595 implements the addition rewrite from the Bitwuzla rewrite\nBV_EXTRACT_ADD_MUL,\nwhich witness that the high bits at i >= len do not affect the bits of\nthe sum upto len:theorem extractLsb'_add {w len} {x y : BitVec w} (hlen : len ≤ w) :\n    (x + y).extractLsb' 0 len = x.extractLsb' 0 len + y.extractLsb' 0 len\n* #7757 adds the Bitwuzla rewrite NORM_BV_ADD_CONCAT for symbolic\nsimplification of add-of-append.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Library","header":"Bitwuzla Rewrite Rules","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Bitwuzla-Rewrite-Rules"},"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Breaking-changes":{"contents":"While most changes could be considered to be a breaking change, this section makes special note of API changes.\n\n* Nat.zero_or and Nat.or_zero have been swapped (#4094).* IsLawfulSingleton is now LawfulSingleton (#4350).* The BitVec literal notation is now <num>#<term> rather than <term>#<term>, and it is global rather than scoped. Use BitVec.ofNat w x rather than x#w when x is a not a numeric literal (0d3051).* BitVec.rotateLeft and BitVec.rotateRight now take the shift modulo the bitwidth (#4229).* These are no longer simp lemmas:\nList.length_pos (#4172),\nOption.bind_eq_some (#4314).* Types in let and have (both the expressions and tactics) may fail to elaborate due to new restrictions on what sorts of elaboration problems may be postponed (#4096).\nIn particular, tactics embedded in the type will no longer make use of the type of value in expressions such as let x : type := value; body.* Now functions defined by well-founded recursion are marked with @[irreducible] by default (#4061).\nExisting proofs that hold by definitional equality (e.g. rfl) can be\nrewritten to explicitly unfold the function definition (using simp,\nunfold, rw), or the recursive function can be temporarily made\nsemireducible (using unseal f in before the command), or the function\ndefinition itself can be marked as @[semireducible] to get the previous\nbehavior.* Due to #3929:* The MessageData.ofPPFormat constructor has been removed.\nIts functionality has been split into two:* for lazy structured messages, please use MessageData.lazy;* for embedding Format or FormatWithInfos, use MessageData.ofFormatWithInfos.An example migration can be found in #3929.* The MessageData.ofFormat constructor has been turned into a function.\nIf you need to inspect MessageData, you can pattern-match on MessageData.ofFormatWithInfos.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.9.0 (2024-07-01)","header":"Breaking changes","id":"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Breaking-changes"}});