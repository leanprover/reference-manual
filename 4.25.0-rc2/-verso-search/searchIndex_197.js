window.docContents[197].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Sorted-Arrays":{"contents":"In-place quicksort.qsort as lt lo hi sorts the subarray as[lo...=hi] in-place using lt to compare elements.\n\nSort an array using compare to compare elements.\n\nSorts an array using insertion sort.The optional parameter lt specifies an ordering predicate. It defaults to LT.lt, which must be\ndecidable to be used for sorting.\n\nInserts an element into a sorted array such that the resulting array is sorted. If the element is\nalready present in the array, it is not inserted.The ordering predicate lt should be a total order on elements, and the array as should be sorted\nwith respect to lt.Array.binInsertM is a more general operator that provides greater control over the handling of\nduplicate elements in addition to running in a monad.Examples:* #[0, 1, 3, 5].binInsert (· < ·) 2 = #[0, 1, 2, 3, 5]* #[0, 1, 3, 5].binInsert (· < ·) 1 = #[0, 1, 3, 5]* #[].binInsert (· < ·) 1 = #[1]\n\nInserts an element k into a sorted array as such that the resulting array is sorted.The ordering predicate lt should be a total order on elements, and the array as should be sorted\nwith respect to lt.If an element that lt equates to k is already present in as, then merge is applied to the\nexisting element to determine the value of that position in the resulting array. If no element equal\nto k is present, then add is used to determine the value to be inserted.\n\nBinary search for an element equivalent to k in the sorted array as. Returns the element from\nthe array, if it is found, or none otherwise.The array as must be sorted according to the comparison operator lt, which should be a total\norder.The optional parameters lo and hi determine the region of the array indices to be searched. Both\nare inclusive, and default to searching the entire array.\n\nBinary search for an element equivalent to k in the sorted array as. Returns true if the\nelement is found, or false otherwise.The array as must be sorted according to the comparison operator lt, which should be a total\norder.The optional parameters lo and hi determine the region of the array indices to be searched. Both\nare inclusive, and default to searching the entire array.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.7. Sorted Arrays","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Sorted-Arrays"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Comparisons":{"contents":"Most comparisons on Booleans should be performed using the DecidableEq Bool, LT Bool, LE Bool instances.\n\nDecides whether two Booleans are equal.This function should normally be called via the DecidableEq Bool instance that it exists to\nsupport.\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans\u0009API Reference","header":"19.11.4.2. Comparisons","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Comparisons"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Search-Path-Helpers":{"contents":"Get the detected LEAN_PATH value of the Lake environment.\n\nGet the detected LEAN_SRC_PATH value of the Lake environment.\n\nGet the detected sharedLibPathEnvVar value of the Lake environment.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference\u0009Accessing the Environment","header":"22.1.4.1.1. Search Path Helpers","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Search-Path-Helpers"},"/Definitions/Theorems/#The-Lean-Language-Reference--Definitions--Theorems":{"contents":"Because propositions are types whose inhabitants count as proofs, theorems and definitions are technically very similar.\nHowever, because their use cases are quite different, they differ in many details:* The theorem statement must be a proposition.\n  The types of definitions may inhabit any universe.* A theorem's header (that is, the theorem statement) is completely elaborated before the body is elaborated.\n  Section variables only become parameters to the theorem if they (or their dependents) are mentioned in the header.\n  This prevents changes to a proof from unintentionally changing the theorem statement.* Theorems are irreducible by default.\n  Because all proofs of the same proposition are definitionally equal, there few reasons to unfold a theorem.\n\nTheorems may be recursive, subject to the same conditions as recursive function definitions.\nHowever, it is more common to use tactics such as induction or fun_induction instead.\n\nTheoremsThe syntax of theorems is like that of definitions, except the codomain (that is, the theorem statement) in the signature is mandatory.\n\n","context":"Lean Reference\u0009Definitions","header":"7.4. Theorems","id":"/Definitions/Theorems/#The-Lean-Language-Reference--Definitions--Theorems"},"/Interacting-with-Lean/#format-render":{"contents":"The ToString Std.Format instance invokes Std.Format.pretty with its default arguments.\n\nThere are two ways to render a document:\n\n* Use pretty to construct a String.\n  The entire string must be constructed up front before any can be sent to a user.* Use prettyM to incrementally emit the String, using effects in some Monad.\n  As soon as each line is rendered, it is emitted.\n  This is suitable for streaming output.\n\nRenders a Format to a string.* width: the total width* indent: the initial indentation to use for wrapped lines\n(subsequent wrapping may increase the indentation)* column: begin the first line wrap column characters earlier than usual\n(this is useful when the output String will be printed starting at column)\n\nThe default width of the targeted output, which is 120 columns.\n\nRenders a Format using effects in the monad m, using the methods of MonadPrettyFormat.Each line is emitted as soon as it is rendered, rather than waiting for the entire document to be\nrendered.* w: the total width* indent: the initial indentation to use for wrapped lines (subsequent wrapping may increase the\nindentation)\n\nA monad that can be used to incrementally render Format objects.Emits the string s.Emits a newline followed by indent columns of indentation.Gets the current column at which the next string will be emitted.Starts a region tagged with tag.Exits the scope of count opened tags.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.6. Rendering","id":"/Interacting-with-Lean/#format-render"},"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Documentation-fixes":{"contents":"* #3918 @[builtin_doc] attribute (@digama0)* #4305 explains the borrow syntax (@eric-wieser)* #5349 adds documentation for groupBy.loop (@vihdzp)* #5473 fixes typo in BitVec.mul docstring (@llllvvuu)* #5476 fixes typos in Lean.MetavarContext* #5481 removes mention of Lean.withSeconds (@alexkeizer)* #5497 updates documentation and tests for toUIntX functions (@TomasPuverle)* #5087 mentions that inferType does not ensure type correctness* Many fixes to spelling across the doc-strings, (@euprunin): #5425 #5426 #5427 #5430  #5431 #5434 #5435 #5436 #5438 #5439 #5440 #5599\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.13.0 (2024-11-01)","header":"Documentation fixes","id":"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Documentation-fixes"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--bv_decide-Tactic":{"contents":"* #6741 implements two rules for bv_decide's preprocessor, lowering\n||| to &&& in order to enable more term sharing + application of\nrules about &&& as well as rewrites of the form (a &&& b == -1#w) = (a == -1#w && b == -1#w) in order to preserve rewriting behavior that\nalready existed before this lowering.* #6924 adds the EQUAL_ITE rules from Bitwuzla to the preprocessor of\nbv_decide.* #6926 adds the BV_EQUAL_CONST_NOT rules from Bitwuzla to the\npreprocessor of bv_decide.* #6946 implements basic support for handling of enum inductives in\nbv_decide. It now supports equality on enum inductive variables (or\nother uninterpreted atoms) and constants.* #7009 ensures users get an error message saying which module to import\nwhen they try to use bv_decide.* #7019 properly spells out the trace nodes in bv_decide so they are\nvisible with just trace.Meta.Tactic.bv and trace.Meta.Tactic.sat\ninstead of always having to enable the profiler.* #7021 adds theorems for interactions of extractLsb with &&&, ^^^,\n~~~ and bif to bv_decide's preprocessor.* #7029 adds simprocs to bv_decide's preprocessor that rewrite\nmultiplication with powers of two to constant shifts.* #7033 improves presentation of counter examples for UIntX and enum\ninductives in bv_decide.* #7242 makes sure bv_decide can work with projections applied to ite\nand cond in its structures pass.* #7257 improves performance of LRAT trimming in bv_decide.* #7269 implements support for IntX and ISize in bv_decide.* #7275 adds all level 1 rewrites from Bitwuzla to the preprocessor of\nbv_decide.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"bv_decide Tactic","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--bv_decide-Tactic"}});