window.docContents[205].resolve({"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Modification":{"contents":"Replaces the value at (zero-based) index n in l with a. If the index is out of bounds, then\nthe list is returned unmodified.Examples:* [\"water\", \"coffee\", \"soda\", \"juice\"].set 1 \"tea\" = [\"water\", \"tea\", \"soda\", \"juice\"]* [\"water\", \"coffee\", \"soda\", \"juice\"].set 4 \"tea\" = [\"water\", \"coffee\", \"soda\", \"juice\"]\n\nReplaces the value at (zero-based) index n in l with a. If the index is out of bounds, then\nthe list is returned unmodified.This is a tail-recursive version of List.set that's used at runtime.Examples:* [\"water\", \"coffee\", \"soda\", \"juice\"].set 1 \"tea\" = [\"water\", \"tea\", \"soda\", \"juice\"]* [\"water\", \"coffee\", \"soda\", \"juice\"].set 4 \"tea\" = [\"water\", \"coffee\", \"soda\", \"juice\"]\n\nReplaces the element at the given index, if it exists, with the result of applying f to it. If the\nindex is invalid, the list is returned unmodified.Examples:* [1, 2, 3].modify 0 (· * 10) = [10, 2, 3]* [1, 2, 3].modify 2 (· * 10) = [1, 2, 30]* [1, 2, 3].modify 3 (· * 10) = [1, 2, 3]\n\nReplaces the element at the given index, if it exists, with the result of applying f to it.This is a tail-recursive version of List.modify.Examples:* [1, 2, 3].modifyTR 0 (· * 10) = [10, 2, 3]* [1, 2, 3].modifyTR 2 (· * 10) = [1, 2, 30]* [1, 2, 3].modifyTR 3 (· * 10) = [1, 2, 3]\n\nReplace the head of the list with the result of applying f to it. Returns the empty list if the\nlist is empty.Examples:* [1, 2, 3].modifyHead (· * 10) = [10, 2, 3]* [].modifyHead (· * 10) = []\n\nReplaces the nth tail of l with the result of applying f to it. Returns the input without\nusing f if the index is larger than the length of the List.Examples:[\"circle\", \"square\", \"triangle\"].modifyTailIdx 1 List.reverse\n[\"circle\", \"triangle\", \"square\"]\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 1 (fun xs => xs ++ xs)\n[\"circle\", \"square\", \"triangle\", \"square\", \"triangle\"]\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 2 (fun xs => xs ++ xs)\n[\"circle\", \"square\", \"triangle\", \"triangle\"]\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 5 (fun xs => xs ++ xs)\n[\"circle\", \"square\", \"triangle\"]\n\n\nRemoves the first occurrence of a from l. If a does not occur in l, the list is returned\nunmodified.O(|l|).Examples:* [1, 5, 3, 2, 5].erase 5 = [1, 3, 2, 5]* [1, 5, 3, 2, 5].erase 6 = [1, 5, 3, 2, 5]\n\nRemoves the first occurrence of a from l. If a does not occur in l, the list is returned\nunmodified.O(|l|).This is a tail-recursive version of List.erase, used in runtime code.Examples:* [1, 5, 3, 2, 5].eraseTR 5 = [1, 3, 2, 5]* [1, 5, 3, 2, 5].eraseTR 6 = [1, 5, 3, 2, 5]\n\nErases duplicated elements in the list, keeping the first occurrence of duplicated elements.O(|l|^2).Examples:* [1, 3, 2, 2, 3, 5].eraseDups = [1, 3, 2, 5]* [\"red\", \"green\", \"green\", \"blue\"].eraseDups = [\"red\", \"green\", \"blue\"]\n\nRemoves the element at the specified index. If the index is out of bounds, the list is returned\nunmodified.O(i).Examples:* [0, 1, 2, 3, 4].eraseIdx 0 = [1, 2, 3, 4]* [0, 1, 2, 3, 4].eraseIdx 1 = [0, 2, 3, 4]* [0, 1, 2, 3, 4].eraseIdx 5 = [0, 1, 2, 3, 4]\n\nRemoves the element at the specified index. If the index is out of bounds, the list is returned\nunmodified.O(i).This is a tail-recursive version of List.eraseIdx, used at runtime.Examples:* [0, 1, 2, 3, 4].eraseIdxTR 0 = [1, 2, 3, 4]* [0, 1, 2, 3, 4].eraseIdxTR 1 = [0, 2, 3, 4]* [0, 1, 2, 3, 4].eraseIdxTR 5 = [0, 1, 2, 3, 4]\n\nRemoves the first element of a list for which p returns true. If no element satisfies p, then\nthe list is returned unchanged.Examples:* [2, 1, 2, 1, 3, 4].eraseP (· < 2) = [2, 2, 1, 3, 4]* [2, 1, 2, 1, 3, 4].eraseP (· > 2) = [2, 1, 2, 1, 4]* [2, 1, 2, 1, 3, 4].eraseP (· > 8) = [2, 1, 2, 1, 3, 4]\n\nRemoves the first element of a list for which p returns true. If no element satisfies p, then\nthe list is returned unchanged.This is a tail-recursive version of eraseP, used at runtime.Examples:* [2, 1, 2, 1, 3, 4].erasePTR (· < 2) = [2, 2, 1, 3, 4]* [2, 1, 2, 1, 3, 4].erasePTR (· > 2) = [2, 1, 2, 1, 4]* [2, 1, 2, 1, 3, 4].erasePTR (· > 8) = [2, 1, 2, 1, 3, 4]\n\nErases repeated elements, keeping the first element of each run.O(|l|).Example:* [1, 3, 2, 2, 2, 3, 3, 5].eraseReps = [1, 3, 2, 3, 5]\n\nReturns the slice of l from indices start (inclusive) to stop (exclusive).Examples:* [0, 1, 2, 3, 4, 5].extract 1 2 = [1]* [0, 1, 2, 3, 4, 5].extract 2 2 = []* [0, 1, 2, 3, 4, 5].extract 2 4 = [2, 3]* [0, 1, 2, 3, 4, 5].extract 2 = [2, 3, 4, 5]* [0, 1, 2, 3, 4, 5].extract (stop := 2) = [0, 1]\n\nRemoves all elements of xs that are present in ys.O(|xs| * |ys|).Examples:* [1, 1, 5, 1, 2, 4, 5].removeAll [1, 2, 2] = [5, 4, 5]* [1, 2, 3, 2].removeAll [] = [1, 2, 3, 2]* [1, 2, 3, 2].removeAll [3] = [1, 2, 2]\n\nReplaces the first element of the list l that is equal to a with b. If no element is equal to\na, then the list is returned unchanged.O(|l|).Examples:* [1, 4, 2, 3, 3, 7].replace 3 6 = [1, 4, 2, 6, 3, 7]* [1, 4, 2, 3, 3, 7].replace 5 6 = [1, 4, 2, 3, 3, 7]\n\nReplaces the first element of the list l that is equal to a with b. If no element is equal to\na, then the list is returned unchanged.O(|l|). This is a tail-recursive version of List.replace that's used in runtime code.Examples:* [1, 4, 2, 3, 3, 7].replaceTR 3 6 = [1, 4, 2, 6, 3, 7]* [1, 4, 2, 3, 3, 7].replaceTR 5 6 = [1, 4, 2, 3, 3, 7]\n\nReverses a list.O(|as|).Because of the “functional but in place” optimization implemented by Lean's compiler, this function\ndoes not allocate a new list when its reference to the input list is unshared: it simply walks the\nlinked list and reverses all the node pointers.Examples:* [1, 2, 3, 4].reverse = [4, 3, 2, 1]* [].reverse = []\n\nConcatenates a list of lists into a single list, preserving the order of the elements.O(|flatten L|).Examples:* [[\"a\"], [\"b\", \"c\"]].flatten = [\"a\", \"b\", \"c\"]* [[\"a\"], [], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]].flatten = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n\nConcatenates a list of lists into a single list, preserving the order of the elements.O(|flatten L|). This is a tail-recursive version of List.flatten, used in runtime code.Examples:* [[\"a\"], [\"b\", \"c\"]].flattenTR = [\"a\", \"b\", \"c\"]* [[\"a\"], [], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]].flattenTR = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n\nRotates the elements of xs to the left, moving i % xs.length elements from the start of the list\nto the end.O(|xs|).Examples:* [1, 2, 3, 4, 5].rotateLeft 3 = [4, 5, 1, 2, 3]* [1, 2, 3, 4, 5].rotateLeft 5 = [1, 2, 3, 4, 5]* [1, 2, 3, 4, 5].rotateLeft 1 = [2, 3, 4, 5, 1]\n\nRotates the elements of xs to the right, moving i % xs.length elements from the end of the list\nto the start.After rotation, the element at xs[n] is at index (i + n) % l.length. O(|xs|).Examples:* [1, 2, 3, 4, 5].rotateRight 3 = [3, 4, 5, 1, 2]* [1, 2, 3, 4, 5].rotateRight 5 = [1, 2, 3, 4, 5]* [1, 2, 3, 4, 5].rotateRight 1 = [5, 1, 2, 3, 4]\n\nPads l : List α on the left with repeated occurrences of a : α until it is of length n. If l\nalready has at least n elements, it is returned unmodified.Examples:* [1, 2, 3].leftpad 5 0 = [0, 0, 1, 2, 3]* [\"red\", \"green\", \"blue\"].leftpad 4 \"blank\" = [\"blank\", \"red\", \"green\", \"blue\"]* [\"red\", \"green\", \"blue\"].leftpad 3 \"blank\" = [\"red\", \"green\", \"blue\"]* [\"red\", \"green\", \"blue\"].leftpad 1 \"blank\" = [\"red\", \"green\", \"blue\"]\n\nPads l : List α on the left with repeated occurrences of a : α until it is of length n. If l\nalready has at least n elements, it is returned unmodified.This is a tail-recursive version of List.leftpad, used at runtime.Examples:* [1, 2, 3].leftPadTR 5 0 = [0, 0, 1, 2, 3]* [\"red\", \"green\", \"blue\"].leftPadTR 4 \"blank\" = [\"blank\", \"red\", \"green\", \"blue\"]* [\"red\", \"green\", \"blue\"].leftPadTR 3 \"blank\" = [\"red\", \"green\", \"blue\"]* [\"red\", \"green\", \"blue\"].leftPadTR 1 \"blank\" = [\"red\", \"green\", \"blue\"]\n\nPads l : List α on the right with repeated occurrences of a : α until it is of length n. If\nl already has at least n elements, it is returned unmodified.Examples:* [1, 2, 3].rightpad 5 0 = [1, 2, 3, 0, 0]* [\"red\", \"green\", \"blue\"].rightpad 4 \"blank\" = [\"red\", \"green\", \"blue\", \"blank\"]* [\"red\", \"green\", \"blue\"].rightpad 3 \"blank\" = [\"red\", \"green\", \"blue\"]* [\"red\", \"green\", \"blue\"].rightpad 1 \"blank\" = [\"red\", \"green\", \"blue\"]\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.8. Modification","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Modification"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map, and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.If the returned Bool is true, then the returned map is unaltered. If the Bool is false, then\nthe returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the hash map for which the given function returns false.\n\nUpdates the values of the hash map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.Note: this replacement behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insert function on HashSet and HashSet.Raw behaves differently: it will return the set\nunchanged if a matching key is already present.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associate value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.\n\nInserts multiple mappings into the hash map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insertMany function on HashSet and HashSet.Raw behaves differently: it will prefer the first\nappearance.\n\nInserts multiple keys with the value () into the hash map by iterating over the given collection\nand calling insertIfNew. If the same key appears multiple times, the first occurrence takes\nprecedence.This is mainly useful to implement HashSet.insertMany, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\nPartition a hash map into two hash map based on a predicate.\n\nComputes the union of the given hash maps. If a key appears in both maps, the entry contains in\nthe second argument will appear in the result.This function always merges the smaller map into the larger map, so the expected runtime is\nO(min(m₁.size, m₂.size)).\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","header":"19.18.2.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Modification"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Type-Classes-for-Iteration":{"contents":"To be used with for loops without membership proofs, collections must implement the ForIn type class.\nImplementing ForIn' additionally allows the use of for loops with membership proofs.\n\nMonadic iteration in do-blocks, using the for x in xs notation.The parameter m is the monad of the do-block in which iteration is performed, ρ is the type of\nthe collection being iterated over, and α is the type of elements.Monadically iterates over the contents of a collection xs, with a local state b and the\npossibility of early termination.Because a do block supports local mutable bindings along with return, and break, the monadic\naction passed to ForIn.forIn takes a starting state in addition to the current element of the\ncollection and returns an updated state together with an indication of whether iteration should\ncontinue or terminate. If the action returns ForInStep.done, then ForIn.forIn should stop\niteration and return the updated state. If the action returns ForInStep.yield, then\nForIn.forIn should continue iterating if there are further elements, passing the updated state\nto the action.More information about the translation of for loops into ForIn.forIn is available in the Lean\nreference manual.\n\nMonadic iteration in do-blocks with a membership proof, using the for h : x in xs notation.The parameter m is the monad of the do-block in which iteration is performed, ρ is the type of\nthe collection being iterated over, α is the type of elements, and d is the specific membership\npredicate to provide.Monadically iterates over the contents of a collection xs, with a local state b and the\npossibility of early termination. At each iteration, the body of the loop is provided with a proof\nthat the current element is in the collection.Because a do block supports local mutable bindings along with return, and break, the monadic\naction passed to ForIn'.forIn' takes a starting state in addition to the current element of the\ncollection with its membership proof. The action returns an updated state together with an\nindication of whether iteration should continue or terminate. If the action returns\nForInStep.done, then ForIn'.forIn' should stop iteration and return the updated state. If the\naction returns ForInStep.yield, then ForIn'.forIn' should continue iterating if there are\nfurther elements, passing the updated state to the action.More information about the translation of for loops into ForIn'.forIn' is available in the\nLean reference manual.\n\nAn indication of whether a loop's body terminated early that's used to compile the for x in xs\nnotation.A collection's ForIn or ForIn' instance describe's how to iterate over its elements. The monadic\naction that represents the body of the loop returns a ForInStep α, where α is the local state\nused to implement features such as let mut.The loop should terminate early.ForInStep.done is produced by uses of break or return in the loop body.The loop should continue with the next iteration, using the returned state.ForInStep.yield is produced by continue and by reaching the bottom of the loop body.\n\nExtracts the value from a ForInStep, ignoring whether it is ForInStep.done or ForInStep.yield.\n\nOverloaded monadic iteration over some container type.An instance of ForM m γ α describes how to iterate a monadic operator over a container of type γ\nwith elements of type α in the monad m. The element type should be uniquely determined by the\nmonad and the container.Use ForM.forIn to construct a ForIn instance from a ForM instance, thus enabling the use of\nthe for operator in do-notation.Runs the monadic action f on each element of the collection coll.\n\nCreates a suitable implementation of ForIn.forIn from a ForM instance.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.7. Type Classes for Iteration","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Type-Classes-for-Iteration"},"/Notations-and-Macros/Macros/#quasiquotation":{"contents":"Quasiquotation is a form of quotation that may contain antiquotations, which are regions of the quotation that are not quoted, but instead are expressions that are evaluated to yield syntax.\nA quasiquotation is essentially a template; the outer quoted region provides a fixed framework that always yields the same outer syntax, while the antiquotations yield the parts of the final syntax that vary.\nAll quotations in Lean are quasiquotations, so no special syntax is needed to distinguish quasiquotations from other quotations.\nThe quotation process does not add macro scopes to identifiers that are inserted via antiquotations, because these identifiers either come from another quotation (in which case they already have macro scopes) or from the macro's input (in which case they should not have macro scopes, because they are not introduced by the macro).\n\nBasic antiquotations consist of a dollar sign ($) immediately followed by an identifier.\nThis means that the value of the corresponding variable, which should be a syntax tree, is to be substituted into this position of the quoted syntax.\nEntire expressions may be used as antiquotations by wrapping them in parentheses.\n\n\n\n\n\nLean's parser assigns every antiquotation a syntax category based on what the parser expects at the given position.\nIf the parser expects syntax category c, then the antiquotation's type is TSyntax c.\n\nSome syntax categories can be matched by elements of other categories.\nFor example, numeric and string literals are valid terms in addition to being their own syntax categories.\nAntiquotations may be annotated with the expected category by suffixing them with a colon and the category name, which causes the parser to validate that the annotated category is acceptable in the given position and construct any intermediate layers that are required in the parse tree.\n\nAntiquotationsWhitespace is not permitted between the dollar sign ('$') that initiates an antiquotation and the identifier or parenthesized term that follows.\nSimilarly, no whitespace is permitted around the colon that annotates the syntax category of the antiquotation.\n\nQuasiquotationBoth forms of antiquotation are used in this example.\nBecause natural numbers are not syntax, quote is used to transform a number into syntax that represents it.open Lean in\nexample [Monad m] [MonadQuotation m] (x : Term) (n : Nat) : m Syntax :=\n  `($x + $(quote (n + 2)))\n\n\nAntiquotation AnnotationsThis example requires that m is a monad that can perform quotation.variable {m : Type → Type} [Monad m] [MonadQuotation m]\nBy default, the antiquotation $e is expected to be a term, because that's the syntactic category that's immediately expected as the second argument to addition.def ex1 (e) := show m _ from `(2 + $e)\n#check ex1\nex1 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `term) : m (TSyntax `term)\nAnnotating $e as a numeric literal succeeds, because numeric literals are also valid terms.\nThe expected type of the parameter e changes to TSyntax `num.def ex2 (e) := show m _ from `(2 + $e:num)\n#check ex2\nex2 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `num) : m (TSyntax `term)\nSpaces are not allowed between the dollar sign and the identifier.def ex2 (e) := show m _ from `(2 + $ e:num)\n<example>:1:34-1:36: unexpected token '$'; expected '`(tactic|' or no space before spliced term\nSpaces are also not allowed before the colon:def ex2 (e) := show m _ from `(2 + $e :num)\n<example>:1:37-1:39: unexpected token ':'; expected ')'\n\n\n\n\nExpanding QuasiquotationPrinting the definition of f demonstrates the expansion of a quasiquotation.open Lean in\ndef f [Monad m] [MonadQuotation m]\n    (x : Term) (n : Nat) : m Syntax :=\n  `(fun k => $x + $(quote (n + 2)) + k)\n#print f\ndef f : {m : Type → Type} → [Monad m] → [Lean.MonadQuotation m] → Lean.Term → Nat → m Syntax :=\nfun {m} [Monad m] [Lean.MonadQuotation m] x n => do\n  let info ← Lean.MonadRef.mkInfoFromRefPos\n  let scp ← Lean.getCurrMacroScope\n  let quotCtx ← Lean.MonadQuotation.getContext\n  pure\n      {\n          raw :=\n            Syntax.node2 info `Lean.Parser.Term.fun (Syntax.atom info \"fun\")\n              (Syntax.node4 info `Lean.Parser.Term.basicFun\n                (Syntax.node1 info `null (Syntax.ident info \"k\".toSubstring' (Lean.addMacroScope quotCtx `k scp) []))\n                (Syntax.node info `null #[]) (Syntax.atom info \"=>\")\n                (Syntax.node3 info `«term_+_»\n                  (Syntax.node3 info `«term_+_» x.raw (Syntax.atom info \"+\") (Lean.quote `term (n + 2)).raw)\n                  (Syntax.atom info \"+\")\n                  (Syntax.ident info \"k\".toSubstring' (Lean.addMacroScope quotCtx `k scp) []))) }.raw\nIn this output, the quotation is a do block.\nIt begins by constructing the source information for the resulting syntax, obtained by querying the compiler about the current user syntax being processed.\nIt then obtains the current macro scope and the name of the module being processed, because macro scopes are added with respect to a module to enable independent compilation and avoid the need for a global counter.\nIt then constructs a node using helpers such as Syntax.node1 and Syntax.node2, which create a Syntax.node with the indicated number of children.\nThe macro scope is added to each identifier, and TSyntax.raw is used to extract the contents of typed syntax wrappers.\nThe antiquotations of x and quote (n + 2) occur directly in the expansion, as parameters to Syntax.node3.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009Quotation","header":"20.5.3.1. Quasiquotation","id":"/Notations-and-Macros/Macros/#quasiquotation"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Experimental___-monadic-verification-framework":{"contents":"#8995 introduces a Hoare logic for monadic programs in\nStd.Do.Triple, and assorted tactics:\n\n* mspec for applying Hoare triple specifications,* mvcgen to turn a Hoare triple proof obligation ⦃P⦄ prog ⦃Q⦄ into\npure verification conditions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Experimental: monadic verification framework","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Experimental___-monadic-verification-framework"}});