window.docContents[166].resolve({"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Iteration":{"contents":"Applies the applicative action f to every element in the list, in order.If m is also a Monad, then using List.forM can be more efficient.List.mapA is a variant that collects results.\n\nApplies the monadic action f to every element in the list, in order.List.mapM is a variant that collects results. List.forA is a variant that works on any\nApplicative.\n\nMaps f over the list and collects the results with <|>. The result for the end of the list is\nfailure.Examples:* [[], [1, 2], [], [2]].firstM List.head? = some 1* [[], [], []].firstM List.head? = none* [].firstM List.head? = none\n\nComputes the sum of the elements of a list.Examples:* [a, b, c].sum = a + (b + (c + 0))* [1, 2, 5].sum = 8\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.10. Iteration","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Iteration"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Iteration":{"contents":"Updates the values of the hash map by applying the given function to all mappings.\n\nFolds the given function over the mappings in the hash map in some order.\n\nMonadically computes a value by folding the given function over the mappings in the hash\nmap in some order.\n\nSupport for the for loop construct in do blocks.\n\nCarries out a monadic action on each mapping in the hash map in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","header":"19.18.2.5. Iteration","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Iteration"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries--Ordering-Based-Queries":{"contents":"Returns the n-th smallest element.\n\nReturns the n-th smallest element, or panics if n is at least t.size.\n\nReturns the n-th smallest element, or none if n is at least t.size.\n\nReturns the n-th smallest element, or fallback if n is at least t.size.\n\nGiven a proof that such an element exists, retrieves the smallest element that is\ngreater than or equal to the given element.\n\nTries to retrieve the smallest element that is greater than or equal to the\ngiven element, panicking if no such element exists.\n\nTries to retrieve the smallest element that is greater than or equal to the\ngiven element, returning none if no such element exists.\n\nTries to retrieve the smallest element that is greater than or equal to the\ngiven element, returning fallback if no such element exists.\n\nGiven a proof that such an element exists, retrieves the smallest element that is\ngreater than the given element.\n\nTries to retrieve the smallest element that is greater than the given element,\npanicking if no such element exists.\n\nTries to retrieve the smallest element that is greater than the given element,\nreturning none if no such element exists.\n\nTries to retrieve the smallest element that is greater than the given element,\nreturning fallback if no such element exists.\n\nGiven a proof that such an element exists, retrieves the largest element that is\nless than or equal to the given element.\n\nTries to retrieve the largest element that is less than or equal to the\ngiven element, panicking if no such element exists.\n\nTries to retrieve the largest element that is less than or equal to the\ngiven element, returning none if no such element exists.\n\nTries to retrieve the largest element that is less than or equal to the\ngiven element, returning fallback if no such element exists.\n\nGiven a proof that such an element exists, retrieves the smallest element that is\nless than the given element.\n\nTries to retrieve the smallest element that is less than the given element,\npanicking if no such element exists.\n\nTries to retrieve the smallest element that is less than the given element,\nreturning none if no such element exists.\n\nTries to retrieve the smallest element that is less than the given element,\nreturning fallback if no such element exists.\n\nGiven a proof that the tree set is not empty, retrieves the smallest element.\n\nTries to retrieve the smallest element of the tree set, panicking if the set is empty.\n\nTries to retrieve the smallest element of the tree set, returning none if the set is empty.\n\nTries to retrieve the smallest element of the tree set, returning fallback if the tree set is empty.\n\nGiven a proof that the tree set is not empty, retrieves the largest element.\n\nTries to retrieve the largest element of the tree set, panicking if the set is empty.\n\nTries to retrieve the largest element of the tree set, returning none if the set is empty.\n\nTries to retrieve the largest element of the tree set, returning fallback if the tree set is empty.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets\u0009Queries","header":"19.18.10.3.1. Ordering-Based Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries--Ordering-Based-Queries"},"/Build-Tools-and-Distribution/Lake/#lake-cache":{"contents":"This is an experimental feature that is still undergoing development.\n\nLake supports a local artifact cache that stores individual build products, tracking the complete set of inputs that gave rise to them.\nEach toolchain has its own cache because intermediate build products are not compatible between toolchain versions.\nHowever, a toolchain's cache is shared between all local workspaces that use it, so common dependencies don't need to be rebuilt.\nIf two separate workspaces with the same toolchain depend on the same package, then they can share each others' build products.\n\nBecause it is an experimental feature, the local cache is disabled by default.\nIt is only enabled when the LAKE_ARTIFACT_CACHE environment variable is set to true or when the  enableArtifactCache field is set to true in the configuration file.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","header":"22.1.1.6. Artifact Caches","id":"/Build-Tools-and-Distribution/Lake/#lake-cache"},"/platforms/Tier-1/#The-Lean-Language-Reference--Supported-Platforms--Tier-1":{"contents":"Tier 1 platforms are those for which Lean is built and tested by our CI infrastructure.\nBinary releases of Lean are available for these platforms via elan.\nThe Tier 1 platforms are:* x86-64 Linux with glibc 2.26+* aarch64 Linux with glibc 2.27+* aarch64 (Apple Silicon) macOS 10.15+* x86-64 Windows 11 (any version), Windows 10 (version 1903 or higher), Windows Server 2022, Windows Server 2025\n\n","context":"Lean Reference\u0009Supported Platforms","header":"Tier 1","id":"/platforms/Tier-1/#The-Lean-Language-Reference--Supported-Platforms--Tier-1"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Server":{"contents":"* #7178 fixes a race condition in the language server that would\nsometimes cause it to drop requests and never respond to them when\nediting the header of a file. This in turn could cause semantic\nhighlighting to stop functioning in VS Code, as VS Code would stop\nemitting requests when a prior request was dropped, and also cause the\nInfoView to become defective. It would also cause import auto-completion\nto feel a bit wonky, since these requests were sometimes dropped. This\nrace condition has been present in the language server since its first\nversion in 2020.* #7223 implements parallel watchdog request processing so that requests\nthat are processed by the watchdog cannot block the main thread of the\nwatchdog anymore.* #7240 adds a canonical syntax for linking to sections in the language\nreference along with formatting of examples in docstrings according to\nthe docstring style guide.* #7343 mitigates an issue where inserting an inlay hint in VS Code by\ndouble-clicking would insert the inlay hint at the wrong position right\nafter an edit.* #7344 combines the auto-implicit inlay hint tooltips into a single\ntooltip. This works around an issue in VS Code where VS Code fails to\nupdate hovers for tooltips in adjacent inlay hint parts when moving the\nmouse.* #7346 fixes an issue where the language server would run into an inlay\nhint assertion violation when deleting a file that is still open in the\nlanguage server.* #7366 adds server-side support for dedicated 'unsolved goals' and\n'goals accomplished' diagnostics that will have special support in the\nLean 4 VS Code extension. The special 'unsolved goals' diagnostic is\nadapted from the 'unsolved goals' error diagnostic, while the 'goals\naccomplished' diagnostic is issued when a theorem or Prop-typed\nexample has no errors or sorrys. The Lean 4 VS Code extension\ncompanion PR is at leanprover/vscode-lean4#585.* #7376 ensures weak options do not have to be repeated in both Lake\nleanOptions and moreServerOptions.* #7882 fixes a regression where elaboration of a previous document\nversion is not cancelled on changes to the document.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)","header":"Server","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Server"}});