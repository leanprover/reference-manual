window.docContents[90].resolve({"/Basic-Types/Natural-Numbers/#nat-api-iteration":{"contents":"Many iteration operators come in two versions: a structurally recursive version and a tail-recursive version.\nThe structurally recursive version is typically easier to use in contexts where definitional equality is important, as it will compute when only some prefix of a natural number is known.\n\nApplies a function to a starting value the specified number of times.In other words, f is iterated n times on a.Examples:* Nat.repeat f 3 a = f <| f <| f <| a* Nat.repeat (· ++ \"!\") 4 \"Hello\" = \"Hello!!!!\"\n\nApplies a function to a starting value the specified number of times.In other words, f is iterated n times on a.This is a tail-recursive version of Nat.repeat that's used at runtime.Examples:* Nat.repeatTR f 3 a = f <| f <| f <| a* Nat.repeatTR (· ++ \"!\") 4 \"Hello\" = \"Hello!!!!\"\n\nIterates the application of a function f to a starting value init, n times. At each step, f\nis applied to the current value and to the next natural number less than n, in increasing order.Examples:* Nat.fold 3 f init = (init |> f 0 (by simp) |> f 1 (by simp) |> f 2 (by simp))* Nat.fold 4 (fun i _ xs => xs.push i) #[] = #[0, 1, 2, 3]* Nat.fold 0 (fun i _ xs => xs.push i) #[] = #[]\n\nIterates the application of a function f to a starting value init, n times. At each step, f\nis applied to the current value and to the next natural number less than n, in increasing order.This is a tail-recursive version of Nat.fold that's used at runtime.Examples:* Nat.foldTR 3 f init = (init |> f 0 (by simp) |> f 1 (by simp) |> f 2 (by simp))* Nat.foldTR 4 (fun i _ xs => xs.push i) #[] = #[0, 1, 2, 3]* Nat.foldTR 0 (fun i _ xs => xs.push i) #[] = #[]\n\nIterates the application of a monadic function f to a starting value init, n times. At each\nstep, f is applied to the current value and to the next natural number less than n, in\nincreasing order.\n\nIterates the application of a function f to a starting value init, n times. At each step, f\nis applied to the current value and to the next natural number less than n, in decreasing order.Examples:* Nat.foldRev 3 f init = (f 0 (by simp) <| f 1 (by simp) <| f 2 (by simp) init)* Nat.foldRev 4 (fun i _ xs => xs.push i) #[] = #[3, 2, 1, 0]* Nat.foldRev 0 (fun i _ xs => xs.push i) #[] = #[]\n\nIterates the application of a monadic function f to a starting value init, n times. At each\nstep, f is applied to the current value and to the next natural number less than n, in\ndecreasing order.\n\nExecutes a monadic action on all the numbers less than some bound, in increasing order.Example:#eval Nat.forM 5 fun i _ => IO.println i\n0\n1\n2\n3\n4\n\n\nExecutes a monadic action on all the numbers less than some bound, in decreasing order.Example:#eval Nat.forRevM 5 fun i _ => IO.println i\n4\n3\n2\n1\n0\n\n\nChecks whether f returns true for every number strictly less than a bound.Examples:* Nat.all 4 (fun i _ => i < 5) = true* Nat.all 7 (fun i _ => i < 5) = false* Nat.all 7 (fun i _ => i % 2 = 0) = false* Nat.all 1 (fun i _ => i % 2 = 0) = true\n\nChecks whether f returns true for every number strictly less than a bound.This is a tail-recursive equivalent of Nat.all that's used at runtime.Examples:* Nat.allTR 4 (fun i _ => i < 5) = true* Nat.allTR 7 (fun i _ => i < 5) = false* Nat.allTR 7 (fun i _ => i % 2 = 0) = false* Nat.allTR 1 (fun i _ => i % 2 = 0) = true\n\nChecks whether there is some number less that the given bound for which f returns true.Examples:* Nat.any 4 (fun i _ => i < 5) = true* Nat.any 7 (fun i _ => i < 5) = true* Nat.any 7 (fun i _ => i % 2 = 0) = true* Nat.any 1 (fun i _ => i % 2 = 1) = false\n\nChecks whether there is some number less that the given bound for which f returns true.This is a tail-recursive equivalent of Nat.any that's used at runtime.Examples:* Nat.anyTR 4 (fun i _ => i < 5) = true* Nat.anyTR 7 (fun i _ => i < 5) = true* Nat.anyTR 7 (fun i _ => i % 2 = 0) = true* Nat.anyTR 1 (fun i _ => i % 2 = 1) = false\n\nChecks whether the monadic predicate p returns true for all numbers less that the given bound.\nNumbers are checked in increasing order until p returns false, after which no further are checked.\n\nChecks whether there is some number less that the given bound for which the monadic predicate p\nreturns true. Numbers are checked in increasing order until p returns true, after which\nno further are checked.\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"19.1.4.6. Iteration","id":"/Basic-Types/Natural-Numbers/#nat-api-iteration"},"/Definitions/Recursive-Definitions/#well-founded-recursion":{"contents":"Functions defined by well-founded recursion are those in which each recursive call has arguments that are smaller (in a suitable sense) than the functions' parameters.\nIn contrast to structural recursion, in which recursive definitions must satisfy particular syntactic requirements, definitions that use well-founded recursion employ semantic arguments.\nThis allows a larger class of recursive definitions to be accepted.\nFurthermore, when Lean's automation fails to construct a termination proof, it is possible to specify one manually.\n\nAll definitions are treated identically by the Lean compiler.\nIn Lean's logic, definitions that use well-founded recursion typically do not reduce definitionally.\nThe reductions do hold as propositional equalities, however, and Lean automatically proves them.\nThis does not typically make it more difficult to prove properties of definitions that use well-founded recursion, because the propositional reductions can be used to reason about the behavior of the function.\nIt does mean, however, that using these functions in types typically does not work well.\nEven when the reduction behavior happens to hold definitionally, it is often much slower than structurally recursive definitions in the kernel, which must unfold the termination proof along with the definition.\nWhen possible, recursive function that are intended for use in types or in other situations where definitional equality is important should be defined with structural recursion.\n\nTo explicitly use well-founded recursion, a function or theorem definition can be annotated with a termination_by clause that specifies the measure by which the function terminates.\nThe measure should be a term that decreases at each recursive call; it may be one of the function's parameters or a tuple of the parameters, but it may also be any other term.\nThe measure's type must be equipped with a well-founded relation, which determines what it means for the measure to decrease.\n\nExplicit Well-Founded RecursionThe termination_by clause introduces the termination argument.The identifiers before the optional => can bring function parameters into scope that are not\nalready bound in the declaration header, and the mandatory term must indicate one of the function's parameters, whether introduced in the header or locally in the clause.\n\nDivision by Iterated SubtractionDivision can be specified as the number of times the divisor can be subtracted from the dividend.\nThis operation cannot be elaborated using structural recursion because subtraction is not pattern matching.\nThe value of n does decrease with each recursive call, so well-founded recursion can be used to justify the definition of division by iterated subtraction.def div (n k : Nat) : Nat :=\n  if k = 0 then 0\n  else if k > n then 0\n  else 1 + div (n - k) k\ntermination_by n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.3. Well-Founded Recursion","id":"/Definitions/Recursive-Definitions/#well-founded-recursion"},"/releases/v4.0.0-m5/#release-v4___0___0-m5":{"contents":"This is the fifth milestone release of Lean 4. It contains many improvements and many new features.\nWe had  1495 commits since the last milestone.\n\nContributors:\n\n   885  Leonardo de Moura\n   310  Sebastian Ullrich\n    69  E.W.Ayers\n    66  Wojciech Nawrocki\n    49  Gabriel Ebner\n    38  Mario Carneiro\n    22  larsk21\n    10  tydeu\n     6  Ed Ayers\n     6  Mariana Alanis\n     4  Chris Lovett\n     3  Jannis Limperg\n     2  François G. Dorais\n     2  Henrik Böving\n     2  Jakob von Raumer\n     2  Scott Morrison\n     2  Siddharth\n     1  Andrés Goens\n     1  Arthur Paulino\n     1  Connor Baker\n     1  Joscha\n     1  KaseQuark\n     1  Lars\n     1  Mac\n     1  Marcus Rossel\n     1  Patrick Massot\n     1  Siddharth Bhat\n     1  Timo\n     1  Vincent de Haan\n     1  William Blake\n     1  Yuri de Wit\n     1  ammkrn\n     1  asdasd1dsadsa\n     1  kzvi\n\n\n* Update Lake to v4.0.0. See the v4.0.0 release notes for detailed changes.* Mutual declarations in different namespaces are now supported. Example:mutual\n  def Foo.boo (x : Nat) :=\n    match x with\n    | 0 => 1\n    | x + 1 => 2*Boo.bla x\n\n  def Boo.bla (x : Nat) :=\n    match x with\n    | 0 => 2\n    | x+1 => 3*Foo.boo x\nend\nA namespace is automatically created for the common prefix. Example:mutual\n  def Tst.Foo.boo (x : Nat) := ...\n  def Tst.Boo.bla (x : Nat) := ...\nend\nexpands tonamespace Tst\nmutual\n  def Foo.boo (x : Nat) := ...\n  def Boo.bla (x : Nat) := ...\nend\nend Tst\n* Allow users to install their own deriving handlers for existing type classes.\nSee example at Simple.lean.* Add tactic congr (num)?. See doc string for additional details.* Missing doc linter* match-syntax notation now checks for unused alternatives. See issue #1371.* Auto-completion for structure instance fields. Example:example : Nat × Nat := {\n  f -- HERE\n}\nfst now appears in the list of auto-completion suggestions.* Auto-completion for dotted identifier notation. Example:example : Nat :=\n  .su -- HERE\nsucc now appears in the list of auto-completion suggestions.* nat_lit is not needed anymore when declaring OfNat instances. See issues #1389 and #875. Example:inductive Bit where\n  | zero\n  | one\n\ninstance inst0 : OfNat Bit 0 where\n  ofNat := Bit.zero\n\ninstance : OfNat Bit 1 where\n  ofNat := Bit.one\n\nexample : Bit := 0\nexample : Bit := 1\n* Add [elabAsElim] attribute (it is called elab_as_eliminator in Lean 3). Motivation: simplify the Mathlib port to Lean 4.* Trans type class now accepts relations in Type u. See this Zulip issue.* Accept unescaped keywords as inductive constructor names. Escaping can often be avoided at use sites via dot notation.inductive MyExpr\n  | let : ...\n\ndef f : MyExpr → MyExpr\n  | .let ... => .let ...\n* Throw an error message at parametric local instances such as [Nat -> Decidable p]. The type class resolution procedure\ncannot use this kind of local instance because the parameter does not have a forward dependency.\nThis check can be disabled using set_option checkBinderAnnotations false.* Add option pp.showLetValues. When set to false, the info view hides the value of let-variables in a goal.\nBy default, it is true when visualizing tactic goals, and false otherwise.\nSee issue #1345 for additional details.* Add option warningAsError. When set to true, warning messages are treated as errors.* Support dotted notation and named arguments in patterns. Example:def getForallBinderType (e : Expr) : Expr :=\n  match e with\n  | .forallE (binderType := type) .. => type\n  | _ => panic! \"forall expected\"\n* \"jump-to-definition\" now works for function names embedded in the following attributes\n@[implementedBy funName], @[tactic parserName], @[termElab parserName], @[commandElab parserName],\n@[builtinTactic parserName], @[builtinTermElab parserName], and @[builtinCommandElab parserName].\nSee issue #1350.* Improve MVarId methods discoverability. See issue #1346.\nWe still have to add similar methods for FVarId, LVarId, Expr, and other objects.\nMany existing methods have been marked as deprecated.* Add attribute [deprecated] for marking deprecated declarations. Examples:def g (x : Nat) := x + 1\n\n-- Whenever `f` is used, a warning message is generated suggesting to use `g` instead.\n@[deprecated g]\ndef f (x : Nat) := x + 1\n\n#check f 0 -- warning: `f` has been deprecated, use `g` instead\n\n-- Whenever `h` is used, a warning message is generated.\n@[deprecated]\ndef h (x : Nat) := x + 1\n\n#check h 0 -- warning: `h` has been deprecated\n* Add type LevelMVarId (and abbreviation LMVarId) for universe level metavariable ids.\nMotivation: prevent meta-programmers from mixing up universe and expression metavariable ids.* Improve calc term and tactic. See issue #1342.* Relaxed antiquotation parsing further reduces the need for explicit $x:p antiquotation kind annotations.* Add support for computed fields in inductives. Example:inductive Exp\n  | var (i : Nat)\n  | app (a b : Exp)\nwith\n  @[computedField] hash : Exp → Nat\n    | .var i => i\n    | .app a b => a.hash * b.hash + 1\nThe result of the Exp.hash function is then stored as an extra \"computed\" field in the .var and .app constructors;\nExp.hash accesses this field and thus runs in constant time (even on dag-like values).* Update a[i] notation. It is now based on the typeclassclass GetElem (cont : Type u) (idx : Type v) (elem : outParam (Type w)) (dom : outParam (cont → idx → Prop)) where\n  getElem (xs : cont) (i : idx) (h : dom xs i) : Elem\nThe notation a[i] is now defined as followsmacro:max x:term noWs \"[\" i:term \"]\" : term => `(getElem $x $i (by get_elem_tactic))\nThe proof that i is a valid index is synthesized using the tactic get_elem_tactic.\nFor example, the type Array α has the following instancesinstance : GetElem (Array α) Nat α fun xs i => LT.lt i xs.size where ...\ninstance : GetElem (Array α) USize α fun xs i => LT.lt i.toNat xs.size where ...\nYou can use the notation a[i]'h to provide the proof manually.\nTwo other notations were introduced: a[i]! and a[i]?, For a[i]!, a panic error message is produced at\nruntime if i is not a valid index. a[i]? has type Option α, and a[i]? evaluates to none if the\nindex i is not valid.\nThe three new notations are defined as follows:@[inline] def getElem' [GetElem cont idx elem dom] (xs : cont) (i : idx) (h : dom xs i) : elem :=\ngetElem xs i h\n\n@[inline] def getElem! [GetElem cont idx elem dom] [Inhabited elem] (xs : cont) (i : idx) [Decidable (dom xs i)] : elem :=\n  if h : _ then getElem xs i h else panic! \"index out of bounds\"\n\n@[inline] def getElem? [GetElem cont idx elem dom] (xs : cont) (i : idx) [Decidable (dom xs i)] : Option elem :=\n  if h : _ then some (getElem xs i h) else none\n\nmacro:max x:term noWs \"[\" i:term \"]\" noWs \"?\" : term => `(getElem? $x $i)\nmacro:max x:term noWs \"[\" i:term \"]\" noWs \"!\" : term => `(getElem! $x $i)\nmacro x:term noWs \"[\" i:term \"]'\" h:term:max : term => `(getElem' $x $i $h)\nSee discussion on Zulip.\nExamples:example (a : Array Int) (i : Nat) : Int :=\n  a[i] -- Error: failed to prove index is valid ...\n\nexample (a : Array Int) (i : Nat) (h : i < a.size) : Int :=\n  a[i] -- Ok\n\nexample (a : Array Int) (i : Nat) : Int :=\n  a[i]! -- Ok\n\nexample (a : Array Int) (i : Nat) : Option Int :=\n  a[i]? -- Ok\n\nexample (a : Array Int) (h : a.size = 2) : Int :=\n  a[0]'(by rw [h]; decide) -- Ok\n\nexample (a : Array Int) (h : a.size = 2) : Int :=\n  have : 0 < a.size := by rw [h]; decide\n  have : 1 < a.size := by rw [h]; decide\n  a[0] + a[1] -- Ok\n\nexample (a : Array Int) (i : USize) (h : i.toNat < a.size) : Int :=\n  a[i] -- Ok\nThe get_elem_tactic is defined asmacro \"get_elem_tactic\" : tactic =>\n  `(first\n    | get_elem_tactic_trivial\n    | fail \"failed to prove index is valid, ...\"\n   )\nThe get_elem_tactic_trivial auxiliary tactic can be extended using macro_rules. By default, it tries trivial, simp_arith, and a special case for Fin. In the future, it will also try linarith.\nYou can extend get_elem_tactic_trivial using my_tactic as followsmacro_rules\n| `(tactic| get_elem_tactic_trivial) => `(tactic| my_tactic)\nNote that Idx's type in GetElem does not depend on Cont. So, you cannot write the instance instance : GetElem (Array α) (Fin ??) α fun xs i => ..., but the Lean library comes equipped with the following auxiliary instance:instance [GetElem cont Nat elem dom] : GetElem cont (Fin n) elem fun xs i => dom xs i where\n  getElem xs i h := getElem xs i.1 h\nand helper tacticmacro_rules\n| `(tactic| get_elem_tactic_trivial) => `(tactic| apply Fin.val_lt_of_le; get_elem_tactic_trivial; done)\nExample:example (a : Array Nat) (i : Fin a.size) :=\n  a[i] -- Ok\n\nexample (a : Array Nat) (h : n ≤ a.size) (i : Fin n) :=\n  a[i] -- Ok\n* Better support for qualified names in recursive declarations. The following is now supported:namespace Nat\n  def fact : Nat → Nat\n  | 0 => 1\n  | n+1 => (n+1) * Nat.fact n\nend Nat\n* Add support for CommandElabM monad at #eval. Example:import Lean\n\nopen Lean Elab Command\n\n#eval do\n  let id := mkIdent `foo\n  elabCommand (← `(def $id := 10))\n\n#eval foo -- 10\n* Try to elaborate do notation even if the expected type is not available. We still delay elaboration when the expected type\nis not available. This change is particularly useful when writing examples such as#eval do\n  IO.println \"hello\"\n  IO.println \"world\"\nThat is, we don't have to use the idiom #eval show IO _ from do ... anymore.\nNote that auto monadic lifting is less effective when the expected type is not available.\nMonadic polymorphic functions (e.g., ST.Ref.get) also require the expected type.* On Linux, panics now print a backtrace by default, which can be disabled by setting the environment variable LEAN_BACKTRACE to 0.\nOther platforms are TBD.* The group(·) syntax combinator is now introduced automatically where necessary, such as when using multiple parsers inside (...)+.* Add \"Typed Macros\": syntax trees produced and accepted by syntax antiquotations now remember their syntax kinds, preventing accidental production of ill-formed syntax trees and reducing the need for explicit :kind antiquotation annotations. See PR for details.* Aliases of protected definitions are protected too. Example:protected def Nat.double (x : Nat) := 2*x\n\nnamespace Ex\nexport Nat (double) -- Add alias Ex.double for Nat.double\nend Ex\n\nopen Ex\n#check Ex.double -- Ok\n#check double -- Error, `Ex.double` is alias for `Nat.double` which is protected\n* Use IO.getRandomBytes to initialize random seed for IO.rand. See discussion at this PR.* Improve dot notation and aliases interaction. See discussion on Zulip for additional details.\nExample:def Set (α : Type) := α → Prop\ndef Set.union (s₁ s₂ : Set α) : Set α := fun a => s₁ a ∨ s₂ a\ndef FinSet (n : Nat) := Fin n → Prop\n\nnamespace FinSet\n  export Set (union) -- FinSet.union is now an alias for `Set.union`\nend FinSet\n\nexample (x y : FinSet 10) : FinSet 10 :=\n  x.union y -- Works\n* ext and enter conv tactics can now go inside let-declarations. Example:example (g : Nat → Nat) (y : Nat) (h : let x := y + 1; g (0+x) = x) : g (y + 1) = y + 1 := by\n  conv at h => enter [x, 1, 1]; rw [Nat.zero_add]\n  /-\n    g : Nat → Nat\n    y : Nat\n    h : let x := y + 1;\n        g x = x\n    ⊢ g (y + 1) = y + 1\n  -/\n  exact h\n* Add zeta conv tactic to expand let-declarations. Example:example (h : let x := y + 1; 0 + x = y) : False := by\n  conv at h => zeta; rw [Nat.zero_add]\n  /-\n    y : Nat\n    h : y + 1 = y\n    ⊢ False\n  -/\n  simp_arith at h\n* Improve namespace resolution. See issue #1224. Example:import Lean\nopen Lean Parser Elab\nopen Tactic -- now opens both `Lean.Parser.Tactic` and `Lean.Elab.Tactic`\n* Rename constant command to opaque. See discussion at Zulip.* Extend induction and cases syntax: multiple left-hand-sides in a single alternative. This extension is very similar to the one implemented for match expressions. Examples:inductive Foo where\n  | mk1 (x : Nat) | mk2 (x : Nat) | mk3\n\ndef f (v : Foo) :=\n  match v with\n  | .mk1 x => x + 1\n  | .mk2 x => 2*x + 1\n  | .mk3   => 1\n\ntheorem f_gt_zero : f v > 0 := by\n  cases v with\n  | mk1 x | mk2 x => simp_arith!  -- New feature used here!\n  | mk3 => decide\n* let/if indentation in do blocks in now supported.* Add unnamed antiquotation $_ for use in syntax quotation patterns.* Add unused variables linter. Feedback welcome!* Lean now generates an error if the body of a declaration body contains a universe parameter that does not occur in the declaration type, nor is an explicit parameter.\nExamples:/-\nThe following declaration now produces an error because `PUnit` is universe polymorphic,\nbut the universe parameter does not occur in the function type `Nat → Nat`\n-/\ndef f (n : Nat) : Nat :=\n  let aux (_ : PUnit) : Nat := n + 1\n  aux ⟨⟩\n\n/-\nThe following declaration is accepted because the universe parameter was explicitly provided in the\nfunction signature.\n-/\ndef g.{u} (n : Nat) : Nat :=\n  let aux (_ : PUnit.{u}) : Nat := n + 1\n  aux ⟨⟩\n* Add subst_vars tactic.* Fix autoParam in structure fields lost in multiple inheritance..* Add [eliminator] attribute. It allows users to specify default recursor/eliminators for the induction and cases tactics.\nIt is an alternative for the using notation. Example:@[eliminator] protected def recDiag {motive : Nat → Nat → Sort u}\n    (zero_zero : motive 0 0)\n    (succ_zero : (x : Nat) → motive x 0 → motive (x + 1) 0)\n    (zero_succ : (y : Nat) → motive 0 y → motive 0 (y + 1))\n    (succ_succ : (x y : Nat) → motive x y → motive (x + 1) (y + 1))\n    (x y : Nat) :  motive x y :=\n  let rec go : (x y : Nat) → motive x y\n    | 0,     0 => zero_zero\n    | x+1, 0   => succ_zero x (go x 0)\n    | 0,   y+1 => zero_succ y (go 0 y)\n    | x+1, y+1 => succ_succ x y (go x y)\n  go x y\ntermination_by go x y => (x, y)\n\ndef f (x y : Nat) :=\n  match x, y with\n  | 0,   0   => 1\n  | x+1, 0   => f x 0\n  | 0,   y+1 => f 0 y\n  | x+1, y+1 => f x y\ntermination_by f x y => (x, y)\n\nexample (x y : Nat) : f x y > 0 := by\n  induction x, y <;> simp [f, *]\n* Add support for casesOn applications to structural and well-founded recursion modules.\nThis feature is useful when writing definitions using tactics. Example:inductive Foo where\n  | a | b | c\n  | pair: Foo × Foo → Foo\n\ndef Foo.deq (a b : Foo) : Decidable (a = b) := by\n  cases a <;> cases b\n  any_goals apply isFalse Foo.noConfusion\n  any_goals apply isTrue rfl\n  case pair a b =>\n    let (a₁, a₂) := a\n    let (b₁, b₂) := b\n    exact match deq a₁ b₁, deq a₂ b₂ with\n    | isTrue h₁, isTrue h₂ => isTrue (by rw [h₁,h₂])\n    | isFalse h₁, _ => isFalse (fun h => by cases h; cases (h₁ rfl))\n    | _, isFalse h₂ => isFalse (fun h => by cases h; cases (h₂ rfl))\n* Option is again a monad. The auxiliary type OptionM has been removed. See Zulip thread.* Improve split tactic. It used to fail on match expressions of the form match h : e with ... where e is not a free variable.\nThe failure used to occur during generalization.* New encoding for match-expressions that use the h : notation for discriminants. The information is not lost during delaboration,\nand it is the foundation for a better split tactic. at delaboration time. Example:#print Nat.decEq\n/-\nprotected def Nat.decEq : (n m : Nat) → Decidable (n = m) :=\nfun n m =>\n  match h : Nat.beq n m with\n  | true => isTrue (_ : n = m)\n  | false => isFalse (_ : ¬n = m)\n-/\n* exists tactic is now takes a comma separated list of terms.* Add dsimp and dsimp! tactics. They guarantee the result term is definitionally equal, and only apply\nrfl-theorems.* Fix binder information for match patterns that use definitions tagged with [matchPattern] (e.g., Nat.add).\nWe now have proper binder information for the variable y in the following example.def f (x : Nat) : Nat :=\n  match x with\n  | 0 => 1\n  | y + 1 => y\n* (Fix) the default value for structure fields may now depend on the structure parameters. Example:structure Something (i: Nat) where\nn1: Nat := 1\nn2: Nat := 1 + i\n\ndef s : Something 10 := {}\nexample : s.n2 = 11 := rfl\n* Apply rfl theorems at the dsimp auxiliary method used by simp. dsimp can be used anywhere in an expression\nbecause it preserves definitional equality.* Refine auto bound implicit feature. It does not consider anymore unbound variables that have the same\nname of a declaration being defined. Example:def f : f → Bool := -- Error at second `f`\n  fun _ => true\n\ninductive Foo : List Foo → Type -- Error at second `Foo`\n  | x : Foo []\nBefore this refinement, the declarations above would be accepted and the\nsecond f and Foo would be treated as auto implicit variables. That is,\nf : {f : Sort u} → f → Bool, and\nFoo : {Foo : Type u} → List Foo → Type.* Fix syntax highlighting for recursive declarations. Exampleinductive List (α : Type u) where\n  | nil : List α  -- `List` is not highlighted as a variable anymore\n  | cons (head : α) (tail : List α) : List α\n\ndef List.map (f : α → β) : List α → List β\n  | []    => []\n  | a::as => f a :: map f as -- `map` is not highlighted as a variable anymore\n* Add autoUnfold option to Lean.Meta.Simp.Config, and the following macros* simp! for simp (config := { autoUnfold := true })* simp_arith! for simp (config := { autoUnfold := true, arith := true })* simp_all! for simp_all (config := { autoUnfold := true })* simp_all_arith! for simp_all (config := { autoUnfold := true, arith := true })When the autoUnfold is set to true, simp tries to unfold the following kinds of definition* Recursive definitions defined by structural recursion.* Non-recursive definitions where the body is a match-expression. This\nkind of definition is only unfolded if the match can be reduced.\nExample:def append (as bs : List α) : List α :=\n  match as with\n  | [] => bs\n  | a :: as => a :: append as bs\n\ntheorem append_nil (as : List α) : append as [] = as := by\n  induction as <;> simp_all!\n\ntheorem append_assoc (as bs cs : List α) : append (append as bs) cs = append as (append bs cs) := by\n  induction as <;> simp_all!\n* Add save tactic for creating checkpoints more conveniently. Example:example : <some-proposition> := by\n  tac_1\n  tac_2\n  save\n  tac_3\n  ...\nis equivalent toexample : <some-proposition> := by\n  checkpoint\n    tac_1\n    tac_2\n  tac_3\n  ...\n* Remove support for {} annotation from inductive datatype constructors. This annotation was barely used, and we can control the binder information for parameter bindings using the new inductive family indices to parameter promotion. Example: the following declaration using {}inductive LE' (n : Nat) : Nat → Prop where\n  | refl {} : LE' n n -- Want `n` to be explicit\n  | succ  : LE' n m → LE' n (m+1)\ncan now be written asinductive LE' : Nat → Nat → Prop where\n  | refl (n : Nat) : LE' n n\n  | succ : LE' n m → LE' n (m+1)\nIn both cases, the inductive family has one parameter and one index.\nRecall that the actual number of parameters can be retrieved using the command #print.* Remove support for {} annotation in the structure command.* Several improvements to LSP server. Examples: \"jump to definition\" in mutually recursive sections, fixed incorrect hover information in \"match\"-expression patterns, \"jump to definition\" for pattern variables, fixed auto-completion in function headers, etc.* In macro ... xs:p* ... and similar macro bindings of combinators, xs now has the correct type Array Syntax* Identifiers in syntax patterns now ignore macro scopes during matching.* Improve binder names for constructor auto implicit parameters. Example, given the inductive datatypeinductive Member : α → List α → Type u\n  | head : Member a (a::as)\n  | tail : Member a bs → Member a (b::bs)\nbefore:#check @Member.head\n-- @Member.head : {x : Type u_1} → {a : x} → {as : List x} → Member a (a :: as)\nnow:#check @Member.head\n-- @Member.head : {α : Type u_1} → {a : α} → {as : List α} → Member a (a :: as)\n* Improve error message when constructor parameter universe level is too big.* Add support for for h : i in [start:stop] do ..  where h : i ∈ [start:stop]. This feature is useful for proving\ntermination of functions such as:inductive Expr where\n  | app (f : String) (args : Array Expr)\n\ndef Expr.size (e : Expr) : Nat := Id.run do\n  match e with\n  | app f args =>\n    let mut sz := 1\n    for h : i in [: args.size] do\n      -- h.upper : i < args.size\n      sz := sz + size (args.get ⟨i, h.upper⟩)\n    return sz\n* Add tactic case'. It is similar to case, but does not admit the goal on failure.\nFor example, the new tactic is useful when writing tactic scripts where we need to use case'\nat first | ... | ..., and we want to take the next alternative when case' fails.* Add tactic macromacro \"stop\" s:tacticSeq : tactic => `(repeat sorry)\nSee discussion on Zulip.* When displaying goals, we do not display inaccessible proposition names\nif they do not have forward dependencies. We still display their types.\nFor example, the goalcase node.inl.node\nβ : Type u_1\nb : BinTree β\nk : Nat\nv : β\nleft : Tree β\nkey : Nat\nvalue : β\nright : Tree β\nihl : BST left → Tree.find? (Tree.insert left k v) k = some v\nihr : BST right → Tree.find? (Tree.insert right k v) k = some v\nh✝ : k < key\na✝³ : BST left\na✝² : ForallTree (fun k v => k < key) left\na✝¹ : BST right\na✝ : ForallTree (fun k v => key < k) right\n⊢ BST left\nis now displayed ascase node.inl.node\nβ : Type u_1\nb : BinTree β\nk : Nat\nv : β\nleft : Tree β\nkey : Nat\nvalue : β\nright : Tree β\nihl : BST left → Tree.find? (Tree.insert left k v) k = some v\nihr : BST right → Tree.find? (Tree.insert right k v) k = some v\n : k < key\n : BST left\n : ForallTree (fun k v => k < key) left\n : BST right\n : ForallTree (fun k v => key < k) right\n⊢ BST left\n* The hypothesis name is now optional in the by_cases tactic.* Fix inconsistency between syntax and kind names.\nThe node kinds numLit, charLit, nameLit, strLit, and scientificLit are now called\nnum, char, name, str, and scientific respectively. Example: we now writemacro_rules | `($n:num) => `(\"hello\")\ninstead ofmacro_rules | `($n:numLit) => `(\"hello\")\n* (Experimental) New checkpoint <tactic-seq> tactic for big interactive proofs.* Rename tactic nativeDecide => native_decide.* Antiquotations are now accepted in any syntax. The incQuotDepth syntax parser is therefore obsolete and has been removed.* Renamed tactic nativeDecide => native_decide.* \"Cleanup\" local context before elaborating a match alternative right-hand-side. Examples:example (x : Nat) : Nat :=\n  match g x with\n  | (a, b) => _ -- Local context does not contain the auxiliary `_discr := g x` anymore\n\nexample (x : Nat × Nat) (h : x.1 > 0) : f x > 0 := by\n  match x with\n  | (a, b) => _ -- Local context does not contain the `h✝ : x.fst > 0` anymore\n* Improve let-pattern (and have-pattern) macro expansion. In the following example,example (x : Nat × Nat) : f x > 0 := by\n  let (a, b) := x\n  done\nThe resulting goal is now ... |- f (a, b) > 0 instead of ... |- f x > 0.* Add cross-compiled aarch64 Linux and aarch64 macOS releases.* Add tutorial-like examples to our documentation, rendered using LeanInk+Alectryon.\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.0.0-m5 (2022-08-22)","id":"/releases/v4.0.0-m5/#release-v4___0___0-m5"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--invariants-and-with-sections-in-mvcgen":{"contents":"* #9927 implements extended induction-inspired syntax for mvcgen,\nallowing optional invariants and with sections.The example below gives the proof that nodup correctly checks for duplicates in a list.import Std.Tactic.Do\nimport Std\n\nopen Std Do\n\ndef nodup (l : List Int) : Bool := Id.run do\n  let mut seen : HashSet Int := ∅\n  for x in l do\n    if x ∈ seen then\n      return false\n    seen := seen.insert x\n  return true\n\ntheorem nodup_correct (h : nodup l = r) : r = true ↔ l.Nodup := by\n  unfold nodup at h\n  apply Id.of_wp_run_eq h; clear h\n  mvcgen\n  invariants\n  · Invariant.withEarlyReturn\n      (onReturn := fun ret seen => ⌜ret = false ∧ ¬l.Nodup⌝)\n      (onContinue := fun xs seen =>\n        ⌜(∀ x, x ∈ seen ↔ x ∈ xs.prefix) ∧ xs.prefix.Nodup⌝)\n  with grind\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)\u0009Highlights","header":"invariants and with sections in mvcgen","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--invariants-and-with-sections-in-mvcgen"}});