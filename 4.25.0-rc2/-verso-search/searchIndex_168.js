window.docContents[168].resolve({"/Basic-Types/Maps-and-Sets/#ExtDHashMap":{"contents":"The declarations in this section should be imported using import Std.ExtDHashMap.\n\nExtensional dependent hash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nmust be an equivalence relation and a == b must imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.In contrast to regular dependent hash maps, Std.ExtDHashMap offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over the hash map.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.DHashMap.Raw and\nStd.DHashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nDHashMap over DHashMap.Raw.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.18.5. Extensional Dependent Hash Maps","id":"/Basic-Types/Maps-and-Sets/#ExtDHashMap"},"/Terms/Identifiers/#identifiers-and-resolution":{"contents":"Identifiers$x:ident\n\n\nAn identifier term is a reference to a name.The specific lexical syntax of identifiers is described in the section on Lean's concrete syntax.\nIdentifiers also occur in contexts where they bind names, such as let and fun; however, these binding occurrences are not complete terms in and of themselves.\nThe mapping from identifiers to names is not trivial: at any point in a module, some number of namespaces will be open, there may be section variables, and there may be local bindings.\nFurthermore, identifiers may contain multiple dot-separated atomic identifiers; the dot both separates namespaces from their contents and variables from fields or functions that use field notation.\nThis creates ambiguity, because an identifier A.B.C.D.e.f could refer to any of the following:\n\n* A name f in the namespace A.B.C.D.e (for instance, a function defined in e's where block).* An application of T.f to A.B.C.D.e if A.B.C.D.e has type T* A projection of field f from a structure named A.B.C.D.e* A series of field projections B.C.D.e from structure value A, followed by an application of f using field notation* If namespace Q is opened, it could be a reference to any of the above with a Q prefix, such as a name f in the namespace Q.A.B.C.D.e\n\nThis list is not exhaustive.\nGiven an identifier, the elaborator must discover which name or names an identifier refers to, and whether any of the trailing components are fields or functions applied via field notation.\nThis is called resolving the name.\n\nSome declarations in the global environment are lazily created the first time they are referenced.\nResolving an identifier in a way that both creates one of these declarations and results in a reference to it is called realizing the name.\nThe rules for resolving and realizing a name are the same, so even though this section refers only to resolving names, it applies to both.\n\nName resolution is affected by the following:\n\n* Pre-resolved names attached to the identifier* The macro scopes attached to the identifier* The local bindings in scope, including auxiliary definitions created as part of the elaboration of let rec.* Aliases created with export in modules transitively imported by the current module* The current section scope, in particular the current namespace, opened namespaces, and section variables\n\nAny prefix of an identifier can resolve to a set of names.\nThe suffix that was not included in the resolution process is then treated as field projections or field notation.\nResolutions of longer prefixes take precedence over resolutions of shorter prefixes; in other words, as few components as of the identifier as possible are treated as field notation.\nAn identifier prefix may refer to any of the following, with earlier items taking precedence over later ones:\n\n1. A locally-bound variable whose name is identical to the identifier prefix, including macro scopes, with closer local bindings taking precedence over outer local bindings.2. A local auxiliary definition whose name is identical to the identifier prefix3. A section variable whose name is identical to the identifier prefix4. A global name that is identical to a prefix of the current namespace appended to the identifier prefix, or for which an alias exists in a prefix of the current namespace, with longer prefixes of the current namespace taking precedence over shorter ones5. A global name that has been brought into scope via open commands that is identical to the identifier prefix\n\nIf an identifier resolves to multiple names, then the elaborator attempts to use all of them.\nIf exactly one of them succeeds, then it is used as the meaning of the identifier.\nIt is an error if more than one succeed or if all fail.\n\nLocal Names Take PrecedenceLocal bindings take precedence over global bindings:def x := \"global\"\n\n#eval\n  let x := \"local\"\n  x\n\"local\"\nThe innermost local binding of a name takes precedence over others:#eval\n  let x := \"outer\"\n  let x := \"inner\"\n  x\n\"inner\"\n\n\nLonger Prefixes of Current Namespace Take PrecedenceThe  namespaces A, B, and C are nested.\nBoth A and C contain a definition of x.namespace A\ndef x := \"A.x\"\nnamespace B\nnamespace C\ndef x := \"A.B.C.x\"\nWhen the current namespace is A.B.C, x resolves to A.B.C.x.#eval x\n\"A.B.C.x\"\nWhen the current namespace is A.B, x resolves to A.x.end C\n#eval x\n\"A.x\"\n\n\nLonger Identifier Prefixes Take PrecedenceWhen an identifier could refer to different projections from names, the one with the longest name takes precedence:structure A where\n  y : String\nderiving Repr\n\nstructure B where\n  y : A\nderiving Repr\n\ndef y : B := ⟨⟨\"shorter\"⟩⟩\ndef y.y : A := ⟨\"longer\"⟩\nGiven the above declarations, y.y.y could in principle refer either to the y field of the y field of y, or to the y field of y.y.\nIt refers to the y field of y.y, because the name y.y is a longer prefix of y.y.y than the name y:#eval y.y.y\n\"longer\"\n\n\nCurrent Namespace Contents Take Precedence Over Opened NamespacesWhen an identifier could refer either to a name defined in a prefix of the current namespace or to an opened namespace, the former takes precedence.namespace A\ndef x := \"A.x\"\nend A\n\nnamespace B\ndef x := \"B.x\"\nnamespace C\nopen A\n#eval x\nEven though A was opened more recently than the declaration of B.x, the identifier x resolves to B.x rather than A.x because B is a prefix of the current namespace B.C.#eval x\n\"B.x\"\n\n\nAmbiguous IdentifiersIn this example, x could refer either to A.x or B.x, and neither takes precedence.\nBecause both have the same type, it is an error.def A.x := \"A.x\"\ndef B.x := \"B.x\"\nopen A\nopen B\n#eval x\nAmbiguous term\n  x\nPossible interpretations:\n  B.x : String\n\n  A.x : String\n\n\nDisambiguation via TypingWhen otherwise-ambiguous names have different types, the types are used to disambiguate:def C.x := \"C.x\"\ndef D.x := 3\nopen C\nopen D\n#eval (x : String)\n\"C.x\"\n\n\n\n\n","context":"Lean Reference\u0009Terms","header":"10.1. Identifiers","id":"/Terms/Identifiers/#identifiers-and-resolution"},"/platforms/Tier-2/#The-Lean-Language-Reference--Supported-Platforms--Tier-2":{"contents":"Tier 2 platforms are those for which Lean is cross-compiled but not tested by our CI.\nBinary releases are available for these platforms.\n\nReleases may be silently broken due to the lack of automated testing.\nIssue reports and fixes are welcome.\n\nThe Tier 2 platforms are:* x86-64 macOS 10.15+* Emscripten WebAssembly\n\n","context":"Lean Reference\u0009Supported Platforms","header":"Tier 2","id":"/platforms/Tier-2/#The-Lean-Language-Reference--Supported-Platforms--Tier-2"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Lake":{"contents":"* #6290 uses StateRefT instead of StateT to equip the Lake build\nmonad with a build store.* #6323 adds a new Lake CLI command, lake query, that both builds\ntargets and outputs their results. It can produce raw text or JSON\n-formatted output (with --json / -J).* #6418 alters all builtin Lake facets to produce Job objects.* #6627 aims to fix the trace issues reported by Mathlib that are\nbreaking lake exe cache in downstream projects.* #6631 sets MACOSX_DEPLOYMENT_TARGET for shared libraries (it was\npreviously only set for executables).* #6771 enables FetchM to be run from JobM / SpawnM and\nvice-versa. This allows calls of fetch to asynchronously depend on the\noutputs of other jobs.* #6780 makes all targets and all fetch calls produce a Job of some\nvalue. As part of this change, facet definitions (e.g., library_data,\nmodule_data, package_data) and Lake type families (e.g.,\nFamilyOut) should no longer include Job in their types (as this is\nnow implicit).* #6798 deprecates the -U shorthand for the --update option.* #7209 fixes broken Lake tests on Windows' new MSYS2. As of MSYS2\n0.0.20250221, OSTYPE is now reported as cygwin instead of msys, which must be accounted for in a few Lake tests.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Lake","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Lake"}});