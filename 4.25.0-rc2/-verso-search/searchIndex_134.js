window.docContents[134].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Bounds":{"contents":"The bitvector of width w that has the largest value when interpreted as an integer.\n\nThe bitvector of width w that has the smallest value when interpreted as an integer.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"19.5.5.1. Bounds","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Bounds"},"/Basic-Types/Strings/#string-runtime":{"contents":"Memory layout of strings \n\nStrings are represented as dynamic arrays of bytes, encoded in UTF-8.\nAfter the object header, a string contains:\n\n byte count\n\nThe number of bytes that currently contain valid string data\n\n capacity\n\nThe number of bytes presently allocated for the string\n\n length\n\nThe length of the encoded string, which may be shorter than the byte count due to UTF-8 multi-byte characters\n\n data\n\nThe actual character data in the string, null-terminated\n\n\n\nMany string functions in the Lean runtime check whether they have exclusive access to their argument by consulting the reference count in the object header.\nIf they do, and the string's capacity is sufficient, then the existing string can be mutated rather than allocating fresh memory.\nOtherwise, a new string must be allocated.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings","header":"19.8.2. Run-Time Representation","id":"/Basic-Types/Strings/#string-runtime"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Concepts-and-Terminology--GitHub-Release-Builds--Uploading":{"contents":"To upload a built package as an artifact to a GitHub release, Lake provides the upload command as a convenient shorthand.\nThis command uses tar to pack the package's build directory into an archive and uses gh release upload to attach it to a pre-existing GitHub release for the specified tag.\nThus, in order to use it, the package uploader (but not the downloader) needs to have gh, the GitHub CLI, installed and in PATH.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology\u0009GitHub Release Builds","header":"22.1.1.5.2. Uploading","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Concepts-and-Terminology--GitHub-Release-Builds--Uploading"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-run":{"contents":"The commands in this section provide the ability to run a command in a specific toolchain and to locate a tool from a particular toolchain on disk.\nThis can be useful when experimenting with different Lean versions, for cross-version testing, and for integrating Elan with other tools.\n\n\n\nConfigures an environment to use the given toolchain and then runs the specified program.\nThe toolchain will be installed if the --install flag is provided.\nThe command may be any program; it does not need to be a command that's part of a toolchain such as lean or lake.\nThis can be used for testing arbitrary toolchains without setting an override.\n\n\n\nDisplays the full path to the toolchain-specific binary for command.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Command-Line Interface","header":"22.2.3.5. Running Tools and Commands","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-run"},"/Introduction/#technical-terms":{"contents":"Technical terminology refers to terms used in a very specific sense when writing technical material, such as this reference.\nUses of technical terminology are frequently hyperlinked to their definition sites, using links like this one.\n\n","context":"Lean Reference\u0009Introduction\u0009Typographical Conventions","header":"1.2.3. Technical Terminology","id":"/Introduction/#technical-terms"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Updates-to-structures-and-classes":{"contents":"* #7302 changes how fields are elaborated in the structure/class\ncommands and also makes default values respect the structure resolution\norder when there is diamond inheritance. Before, the details of\nsubobjects were exposed during elaboration, and in the local context any\nfields that came from a subobject were defined to be projections of the\nsubobject field. Now, every field is represented as a local variable.\nAll parents (not just subobject parents) are now represented in the\nlocal context, and they are now local variables defined to be parent\nconstructors applied to field variables (inverting the previous\nrelationship). See the PR description for further details.* #7640 implements the main logic for inheriting and overriding\nautoParam fields in the structure/class commands, pending being\nenabled in the structure instance notation elaborator. Adds term info to\noverridden fields, so they now can be hovered over, and \"go to\ndefinition\" goes to the structure the field is originally defined in.* #7717 changes how {...}/where notation (\"structure instance\nnotation\") elaborates. The notation now tries to simulate a flat\nrepresentation as much as possible, without exposing the details of\nsubobjects.\nThis is a breaking change, see the PR description for further details and mitigation strategies.* #7742 adds a feature to structure/class where binders without\ntypes on a field definition are interpreted as overriding the type's\nparameters binder kinds in that field's projection function. See the PR description for further details.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Highlights","header":"Updates to structures and classes","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Updates-to-structures-and-classes"}});