window.docContents[214].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Syntax":{"contents":"All the fixed-width integer types have OfNat instances, which allow numerals to be used as literals, both in expression and in pattern contexts.\nThe signed types additionally have Neg instances, allowing negation to be applied.\n\nFixed-Width LiteralsLean allows both decimal and hexadecimal literals to be used for types with OfNat instances.\nIn this example, literal notation is used to define masks.structure Permissions where\n  readable : Bool\n  writable : Bool\n  executable : Bool\n\ndef Permissions.encode (p : Permissions) : UInt8 :=\n  let r := if p.readable then 0x01 else 0\n  let w := if p.writable then 0x02 else 0\n  let x := if p.executable then 0x04 else 0\n  r ||| w ||| x\n\ndef Permissions.decode (i : UInt8) : Permissions :=\n  ⟨i &&& 0x01 ≠ 0, i &&& 0x02 ≠ 0, i &&& 0x04 ≠ 0⟩\n\n\nLiterals that overflow their types' precision are interpreted modulus the precision.\nSigned types, are interpreted according to the underlying twos-complement representation.\n\nOverflowing Fixed-Width LiteralsThe following statements are all true:example : (255 : UInt8) = 255 := by rfl\nexample : (256 : UInt8) = 0   := by rfl\nexample : (257 : UInt8) = 1   := by rfl\n\nexample : (0x7f : Int8) = 127  := by rfl\nexample : (0x8f : Int8) = -113 := by rfl\nexample : (0xff : Int8) = -1   := by rfl\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","header":"19.4.3. Syntax","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Syntax"},"/Functors___-Monads-and--do--Notation/Syntax/#do-notation":{"contents":"Monads are primarily used via do-notation, which is an embedded language for programming in an imperative style.\nIt provides familiar syntax for sequencing effectful operations, early return, local mutable variables, loops, and exception handling.\nAll of these features are translated to the operations of the Monad type class, with a few of them requiring addition instances of classes such as ForIn that specify iteration over containers.\nFor more details about the design of do-notation, please consult .\nA do term consists of the keyword do followed by a sequence of do items.\n\ndo-NotationThe items in a do may be separated by semicolons; otherwise, each should be on its own line and they should have equal indentation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax","header":"14.3.2. do -Notation","id":"/Functors___-Monads-and--do--Notation/Syntax/#do-notation"},"/The-Type-System/Quotients/#quotient-alternatives":{"contents":"While Quotient is a convenient way to form quotients with reasonable computational properties, it is often possible to define quotients in other ways.\n\nIn general, a type Q is said to be the quotient of A by an equivalence relation \\sim if it respects the universal property of quotients: there is a function q:A\\to Q with the property that q(a)=q(b) if and only if a\\sim b for all a and b in A.\n\nQuotients formed with Quotient have this property up to propositional equality: elements of A that are related by \\sim are equal, so they cannot be distinguished.\nHowever, members of the same equivalence class are not necessarily definitionally equal in the quotient.\n\nQuotients may also be implemented by designating a single representative of each equivalence class in A itself, and then defining Q as pair of elements in A with proofs that they are such a canonical representative.\nTogether with a function that maps each a in A to its canonical representative, Q is a quotient of A.\nDue to proof irrelevance, representatives in Q of the same equivalence class are definitionally equal.\n\nSuch a manually implemented quotient Q can be easier to work with than Quotient.\nIn particular, because each equivalence class is represented by its single canonical representative, there's no need to prove that functions from the quotient respect the equivalence relation.\nIt can also have better computational properties due to the fact that the computations give normalized values (in contrast, elements of Quotient can be represented in multiple ways).\nFinally, because the manually implemented quotient is an inductive type, it can be used in contexts where other kinds of types cannot, such as when defining a nested inductive type.\nHowever, not all quotients can be manually implemented.\n\nManually Quotiented IntegersWhen implemented as pairs of Nats, each equivalence class according to the desired equality for integers has a canonical representative in which at least one of the Nats is zero.\nThis can be represented as a Lean structure:structure Z where\n  a : Nat\n  b : Nat\n  canonical : a = 0 ∨ b = 0\nDue to proof irrelevance, every value of this structure type that represents the same integer is already equal.\nConstructing a Z can be made more convenient with a wrapper that uses the fact that subtraction of natural numbers truncates at zero to automate the construction of the proof:def Z.mk' (n k : Nat) : Z where\n  a := n - k\n  b := k - n\n  canonical := by omega\nThis construction respects the equality demanded of integers:theorem Z_mk'_respects_eq :\n    (Z.mk' n k = Z.mk' n' k') ↔ (n + k' = n' + k) := by\n  simp [Z.mk']\n  omega\nTo use this type in examples, it's convenient to have Neg, OfNat, and ToString instances.\nThese instances make it easier to read or write examples.instance : Neg Z where\n  neg n := Z.mk' n.b n.a\n\ninstance : OfNat Z n where\n  ofNat := Z.mk' n 0\n\ninstance : ToString Z where\n  toString n :=\n    if n.a = 0 then\n      if n.b = 0 then \"0\"\n      else s!\"-{n.b}\"\n    else toString n.a\n#eval (5 : Z)\n5\n#eval (-5 : Z)\n-5\nAddition is addition of the underlying Nats:instance : Add Z where\n  add n k := Z.mk' (n.a + k.a) (n.b + k.b)\n#eval (-5 + 22: Z)\n17\nBecause each equivalence class is uniquely represented, there's no need to write a proof that these functions from Z respect the equivalence relation.\nHowever, in practice, the API for quotients should be implemented for manually-constructed quotients and proved to respect the universal property.\n\nBuilt-In Integers as QuotientsLean's built-in integer type Int satisfies the universal property of quotients, and can thus be thought of as a quotient of pairs of Nats.\nThe canonical representative of each equivalence class can be computed via comparison and subtraction:This toInt function is called Int.subNatNat in the standard library.def toInt (n k : Nat) : Int :=\n  if n < k then - (k - n : Nat)\n  else if n = k then 0\n  else (n - k : Nat)\nIt satisfies the universal property.\nTwo pairs of Nats represent the same integer if and only if toInt computes the same Int for both pairs:theorem toInt_sound :\n    n + k' = k + n' ↔\n    toInt n k = toInt n' k' := by\n  simp only [toInt]\n  split <;> split <;> omega\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.1. Alternatives to Quotient Types","id":"/The-Type-System/Quotients/#quotient-alternatives"},"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Compiler___-runtime___-and-FFI":{"contents":"* #4100 improves reset/reuse algorithm; it now runs a second pass relaxing the constraint that reused memory cells must only be for the exact same constructor.* #2903 fixes segfault in old compiler from mishandling noConfusion applications.* #4311 fixes bug in constant folding.* #3915 documents the runtime memory layout for inductive types.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.9.0 (2024-07-01)","header":"Compiler, runtime, and FFI","id":"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Compiler___-runtime___-and-FFI"}});