window.docContents[124].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Modifications":{"contents":"Removes the specified number of characters (Unicode code points) from the beginning of a substring\nby advancing its start position.If the substring's end position is reached, the start position is not advanced past it.\n\nRemoves the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position. The start position is moved to the position of\nthe first character for which the predicate returns false, or to the substring's end position if\nthe predicate always returns true.\n\nRemoves the specified number of characters (Unicode code points) from the end of a substring\nby moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRemoves the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position. The end position is moved just after the position\nof the last character for which the predicate returns false, or to the substring's start position\nif the predicate always returns true.\n\nRetains only the specified number of characters (Unicode code points) at the beginning of a\nsubstring, by moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRetains only the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position towards its start position.\n\nRetains only the specified number of characters (Unicode code points) at the end of a substring, by\nmoving its start position towards its end position.If the substring's end position is reached, the start position is not advanced past it.\n\nRetains only the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position towards its end position.\n\nReturns the region of the substring delimited by the provided start and stop positions, as a\nsubstring. The positions are interpreted with respect to the substring's start position, rather than\nthe underlying string.If the resulting substring is empty, then the resulting substring is a substring of the empty string\n\"\". Otherwise, the underlying string is that of the input substring with the beginning and end\npositions adjusted.\n\nRemoves leading and trailing whitespace from a substring by first moving its start position to the\nfirst non-whitespace character, and then moving its end position to the last non-whitespace\ncharacter.If the substring consists only of whitespace, then the resulting substring's start position is moved\nto its end position.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \" red green blue \".toSubstring.trim.toString = \"red green blue\"* \" red green blue \".toSubstring.trim.startPos = ⟨1⟩* \" red green blue \".toSubstring.trim.stopPos = ⟨15⟩* \"     \".toSubstring.trim.startPos = ⟨5⟩\n\nRemoves leading whitespace from a substring by moving its start position to the first non-whitespace\ncharacter, or to its end position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nRemoves trailing whitespace from a substring by moving its end position to the last non-whitespace\ncharacter, or to its start position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nSplits a substring s on occurrences of the separator string sep. The default separator is \" \".When sep is empty, the result is [s]. When sep occurs in overlapping patterns, the first match\nis taken. There will always be exactly n+1 elements in the returned list if there were n\nnon-overlapping matches of sep in the string. The separators are not included in the returned\nsubstrings, which are all substrings of s's string.\n\nGiven a Substring, returns another one which has valid endpoints\nand represents the same substring according to Substring.toString.\n(Note, the substring may still be inverted, i.e. beginning greater than end.)\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Substrings","header":"19.8.4.11.7. Modifications","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Modifications"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers":{"contents":"exists e₁, e₂, ... is shorthand for refine ⟨e₁, e₂, ...⟩; try trivial.\nIt is useful for existential goals.\n\nIntroduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a let or function type.* intro by itself introduces one anonymous hypothesis, which can be accessed\nby e.g. assumption. It is equivalent to intro _.* intro x y introduces two hypotheses and names them. Individual hypotheses\ncan be anonymized via _, given a type ascription, or matched against a pattern:-- ... ⊢ α × β → ...\nintro (a, b)\n-- ..., a : α, b : β ⊢ ...\n* intro rfl is short for intro h; subst h, if h is an equality where the left-hand or right-hand side\nis a variable.* Alternatively, intro can be combined with pattern matching much like fun:intro\n| n + 1, 0 => tac\n| ...\n\n\nintros repeatedly applies intro to introduce zero or more hypotheses\nuntil the goal is no longer a binding expression\n(i.e., a universal quantifier, function type, implication, or have/let),\nwithout performing any definitional reductions (no unfolding, beta, eta, etc.).\nThe introduced hypotheses receive inaccessible (hygienic) names.intros x y z is equivalent to intro x y z and exists only for historical reasons.\nThe intro tactic should be preferred in this case.Properties and relations* intros succeeds even when it introduces no hypotheses.* repeat intro is like intros, but it performs definitional reductions\nto expose binders, and as such it may introduce more hypotheses than intros.* intros is equivalent to intro _ _ … _,\nwith the fewest trailing _ placeholders needed so that the goal is no longer a binding expression.\nThe trailing introductions do not perform any definitional reductions.ExamplesImplications:example (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\nLet-bindings:example : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\nDoes not unfold definitions:def AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n\nThe tacticintro\n| pat1 => tac1\n| pat2 => tac2\nis the same as:intro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\nThat is, intro can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to fun with match arms in term mode.\n\nThe rintro tactic is a combination of the intros tactic with rcases to\nallow for destructuring patterns while introducing variables. See rcases for\na description of supported patterns. For example, rintro (a | ⟨b, c⟩) ⟨d, e⟩\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables a d e and the other with b c d e.rintro, unlike rcases, also supports the form (x y : ty) for introducing\nand type-ascripting multiple variables at once, similar to binders.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.3. Quantifiers","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers"}});