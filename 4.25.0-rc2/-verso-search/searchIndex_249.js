window.docContents[249].resolve({"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers","header":"19.2.4. API Reference","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Conversion":{"contents":"Transforms a list of mappings into a tree map.\n\nTransforms the tree map into a list of mappings in ascending order.\n\nTransforms the tree map into a list of mappings in ascending order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"19.18.9.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Conversion"},"/Basic-Types/Strings/#string-api-build":{"contents":"Returns a new string that contains only the character c.Because strings are encoded in UTF-8, the resulting string may take multiple bytes.Examples:* String.singleton 'L' = \"L\"* String.singleton ' ' = \" \"* String.singleton '\"' = \"\\\"\"* String.singleton 'ùí´' = \"ùí´\"\n\nAppends two strings. Usually accessed via the ++ operator.The internal implementation will perform destructive updates if the string is not shared.Examples:* \"abc\".append \"def\" = \"abcdef\"* \"abc\" ++ \"def\" = \"abcdef\"* \"\" ++ \"\" = \"\"\n\nAppends all the strings in a list of strings, in order.Use String.intercalate to place a separator string between the strings in a list.Examples:* String.join [\"gr\", \"ee\", \"n\"] = \"green\"* String.join [\"b\", \"\", \"l\", \"\", \"ue\"] = \"blue\"* String.join [] = \"\"\n\nAppends the strings in a list of strings, placing the separator s between each pair.Examples:* \", \".intercalate [\"red\", \"green\", \"blue\"] = \"red, green, blue\"* \" and \".intercalate [\"tea\", \"coffee\"] = \"tea and coffee\"* \" | \".intercalate [\"M\", \"\", \"N\"] = \"M |  | N\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.1. Constructing","id":"/Basic-Types/Strings/#string-api-build"},"/Basic-Types/Strings/#string-api-slice":{"contents":"A region or slice of some underlying string.A slice consists of a string together with the start and end byte positions of a region of\ninterest. Actually extracting a substring requires copying and memory allocation, while many\nslices of the same underlying string may exist with very little overhead. While this could be achieved by tracking the bounds by hand, the slice API is much more convenient.String.Slice bundles proofs to ensure that the start and end positions always delineate a valid\nstring. For this reason, it should be preferred over Substring.The underlying strings.The byte position of the start of the string slice.The byte position of the end of the string slice.The slice is not degenerate (but it may be empty).\n\nReturns a slice that contains the entire string.\n\nThe slice from p (inclusive) up to the end of s.\n\nThe slice from the beginning of s up to p (exclusive).\n\nA Slice.Pos s is a byte offset in s together with a proof that this position is at a UTF-8\ncharacter boundary.The underlying byte offset of the Slice.Pos.The proof that offset is valid for the string slice s.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.12. String Slices","id":"/Basic-Types/Strings/#string-api-slice"},"/Definitions/Recursive-Definitions/#mutual-syntax":{"contents":"Just as a recursive definition is one that mentions the name being defined in the body of the definition, mutually recursive definitions are definitions that may be recursive or mention one another.\nTo use mutual recursion between multiple declarations, they must be placed in a mutual block.\n\nMutual Declaration BlocksThe general syntax for mutual recursion is:where the declarations must be definitions or theorems.\n\nThe declarations in a mutual block are not in scope in each others' signatures, but they are in scope in each others' bodies.\nEven though the names are not in scope in signatures, they will not be inserted as auto-bound implicit parameters.\n\nMutual Block ScopeNames defined in a mutual block are not in scope in each others' signatures.mutual\n  abbrev NaturalNum : Type := Nat\n  def n : NaturalNum := 5\nend\nUnknown identifier `NaturalNum`\nWithout the mutual block, the definition succeeds:abbrev NaturalNum : Type := Nat\ndef n : NaturalNum := 5\n\n\nMutual Block Scope and Automatic Implicit ParametersNames defined in a mutual block are not in scope in each others' signatures.\nNonetheless, they cannot be used as automatic implicit parameters:mutual\n  abbrev Œ± : Type := Nat\n  def identity (x : Œ±) : Œ± := x\nend\nUnknown identifier `Œ±`\nWith a different name, the implicit parameter is automatically added:mutual\n  abbrev Œ± : Type := Nat\n  def identity (x : Œ≤) : Œ≤ := x\nend\n\n\nElaborating recursive definitions always occurs at the granularity of mutual blocks, as if there were a singleton mutual block around every declaration that is not itself part of such a block.\nLocal definitions introduced via let rec and\n where are lifted out of their context, introducing parameters for captured free variables as necessary, and treated as if they were separate definitions within the mutual block as well. \nThus, helpers defined in a where block may use mutual recursion both with one another and with the definition in which they occur, but they may not mention each other in their type signatures.\n\nAfter the first step of elaboration, in which definitions are still recursive, and before translating recursion using the techniques above, Lean identifies the actually (mutually) recursive cliques  among the definitions in the mutual block and processes them separately and in dependency order.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.1. Mutual Recursion","id":"/Definitions/Recursive-Definitions/#mutual-syntax"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Library":{"contents":"* #7352 reworks the simp set around the Id monad, to not elide or\nunfold pure and Id.run* #7995 adds a verification of Array.qsort properties, trying to use\ngrind and fun_induction where possible.\nCurrently this is in the tests/ folder, but once grind is ready for\nproduction use we will move it out into the library.* #8182 adds ofList_eq_insertMany_empty lemmas for all the hash/tree\nmap types, with the exception of\nStd.HashSet.Raw.ofList_eq_insertMany_empty.* #8188 takes the existing getElem_map statements for HashMap\nvariants (also getElem?, getElem!, and getD statements), adds a\nprime to their name and an explanatory comment, and replaces the\nunprimed statement with a simpler statement that is only true with\nLawfulBEq present. The original statements which were simp lemmas are\nnow low priority simp lemmas, so the nicer statements should fire when\nLawfulBEq is available.* #8202 adds an inference that was repeatedly needed when proving\nBitVec.msb_sdiv, and is the symmetric version of\nBitVec.one_eq_zero_iff* #8206 shows that negating a bitvector created from a natural number\nequals creating a bitvector from the the negative of that number (as an\ninteger).* #8216 completes adding @[grind] annotations for Option lemmas, and\nincidentally fills in some Option API gaps/defects.* #8218 continues adding @[grind] attributes for List/Array/Vector,\nparticularly to the lemmas involving the toList/toArray functions.* #8246 add @[grind] annotations for HashMap and variants.* #8272 adds lemmas about the length and use of []? on results of\nList.intersperse.* #8291 changes the statements of Fin lemmas to use [NeZero n] (i : Fin n) rather than (i : Fin (n+1)) where possible.* #8298 adds various Option lemmas and defines Option.filterM for\napplicative functors.* #8313 changes the definition of Vector so it no longer extends\nArray. This prevents Array API from \"leaking through\".* #8315 splits Std.Classes.Ord into Std.Classes.Ord.Basic (with few\nimports) and Std.Classes.Ord.SInt and Std.Classes.Ord.Vector. These\nchanges avoid importing Init.Data.BitVec.Lemmas unnecessarily into\nvarious basic files.\nAs the new import-only file Std.Classes.Ord imports all three of\nthese, end-users are not affected.* #8318 is follow-up to #8272, combining the conditional lemmas for\ngetElem_intersperse into a single lemma with an if on the RHS.* #8327 adds @[grind] annotations to the generic\ngetElem?_eq_none_iff, isSome_getElem?, and get_getElem?.* #8328 adds the @[grind =] attribute to all contains_iff_mem\nlemmas.* #8331 improves the docstring for PlainDateTime.now and its variants.* #8346 adds some missing lemmas about consequences of\npositivity/non-negativity of a * b : Int.* #8349 fixes the signature of the intended Inhabited instance for\nExtDHashMap.* #8357 adds variants of dite_eq_left_iff that will be useful in a\nfuture PR.* #8358 introduces a very minimal version of the new iterator library.\nIt comes with list iterators and various consumers, namely toArray,\ntoList, toListRev, ForIn, fold, foldM and drain. All\nconsumers also come in a partial variant that can be used without any\nproofs. This limited version of the iterator library generates decent\ncode, even with the old code generator.* #8378 improves and extends the api around Ord and Ordering.* #8379 adds missing Option lemmas.* #8380 provides simple lemmas about toArray, toList and toListRev\nfor the iterator library.* #8384 provides lemmas about the behavior of step, toArray,\ntoList and toListRev on list iterators created with List.iter and\nList.iterM.* #8389 adds the List/Array/Vector.ofFnM, the monadic analogues of\nofFn, along with basic theory.* #8392 corrects some Array lemmas to be about Array not List.* #8397 cleans up many duplicate instances (or, in some cases,\nneedlessly duplicated def X := ...; instance Y := X).* #8399 adds variants of HashMap.getElem?_filter that assume\nLawfulBEq and have a simpler right-hand-side. simp can already\nachieve these, via rewriting with getKey_eq under the lambda. However\ngrind can not, and these lemmas help grind work with HashMap\ngoals. There are variants for all variants of HashMap,\ngetElem?/getElem/getElem!/getD, and for filter and filterMap.* #8405 provides lemmas about the loop constructs ForIn, fold,\nfoldM and drain and their relation to each other in the context of\niterators.* #8418 provides the take iterator combinator that transforms any\niterator into an iterator that stops after a given number of steps. The\nchange contains the implementation and lemmas.* #8422 adds LT and Decidable LT instances for\nStd.Time.Timestamp and Std.Time.Duration.* #8434 adds the equivalent of List.take_cons about List.drop.* #8435 upstreams the LawfulMonadLift(T) classes, lemmas and instances\nfrom Batteries into Core because the iterator library needs them in\norder to prove lemmas about the mapM operator, which relies on\nMonadLiftT.* #8445 adds a @[simp] lemma, and comments explaining that there is\nintentionally no verification API for Vector.take, Vector.drop, or\nVector.tail, which should all be rewritten in terms of\nVector.extract.* #8446 adds basic @[grind] annotations for TreeMap and its\nvariants. Likely more annotations will be added after we've explored\nsome examples.* #8451 provides the iterator combinator filterMap in a pure and\nmonadic version and specializations map and filter. This new\ncombinator allows to apply a function to the emitted values of a stream\nwhile filtering out certain elements.* #8460 adds further @[grind] annotations for Option, as follow-up\nto the recent additions to the Option API in #8379 and #8298.* #8465 adds further lemmas about LawfulGetElem, including marking\nsome with @[grind].* #8470 adds @[simp] to getElem_pos/neg (similarly for getElem!).\nThese are often already simp lemmas for concrete types.* #8482 adds preliminary @[grind] annotations for List.Pairwise and\nList.Nodup.* #8484 provides the iterator combinator zip in a pure and monadic\nversion.* #8492 adds simp lemmas for toInt_* and toNat_* with arithmetic\noperation given the hypothesis of no-overflow\n(toNat_add_of_not_uaddOverflow, toInt_add_of_not_saddOverflow,\ntoNat_sub_of_not_usubOverflow, toInt_sub_of_not_ssubOverflow,\ntoInt_neg_of_not_negOverflow, toNat_mul_of_not_umulOverflow,\ntoInt_mul_of_not_smulOverflow). In particular, these are simp since\n(1) the rhs is strictly simpler than the lhs and (2) this version is\nalso simpler than the standard operation when the hypothesis is\navailable.* #8493 provides the iterator combinators takeWhile (forwarding all\nemitted values of another iterator until a predicate becomes false)\ndropWhile (dropping values until some predicate on these values\nbecomes false, then forwarding all the others).* #8497 adds preliminary grind annotations for\nList.Sublist/IsInfix/IsPrefix/IsSuffix, along with test cases.* #8499 changes the definition of Array.ofFn.go to use recursion on\nNat (rather than well-founded recursion). This resolves a problem\nreported on zulip).* #8513 removes the @[reducible] annotation on Array.size. This is\nprobably best gone anyway in order to keep separation between the List\nand Array APIs, but it also helps avoid uselessly instantiating\nArray theorems when grind is working on List problems.* #8515 removes the prime from Fin.ofNat': the old Fin.ofNat has\ncompleted its 6 month deprecation cycle and is being removed.* #8527 adds grind annotations for theorems about List.countP and\nList.count.* #8552 provides array iterators (Array.iter(M),\nArray.iterFromIdx(M)), infinite iterators produced by a step function\n(Iter.repeat), and a ForM instance for finite iterators that is\nimplemented in terms of ForIn.* #8620 removes the NatCast (Fin n) global instance (both the direct\ninstance, and the indirect one via Lean.Grind.Semiring), as that\ninstance causes causes x < n (for x : Fin k, n : Nat) to be\nelaborated as x < ‚Üën rather than ‚Üëx < n, which is undesirable. Note\nhowever that in Mathlib this happens anyway!\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Library","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Library"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Grind-AC-solver":{"contents":"grind can reason about associative, commutative, idempotent, and/or unital operations\n(#10105, #10146, etc..):\n\nexample (a b c : Nat) : max a (max b c) = max (max b 0) (max a c) := by\n  grind only\n\nexample {Œ±} (as bs cs : List Œ±) : as ++ (bs ++ cs) = ((as ++ []) ++ bs) ++ (cs ++ []) := by\n  grind only\n\nexample {Œ± : Sort u} (op : Œ± ‚Üí Œ± ‚Üí Œ±) (u : Œ±) [Std.Associative op] [Std.Commutative op] [Std.IdempotentOp op] [Std.LawfulIdentity op u] (a b c : Œ±)\n    : op (op a a) (op b c) = op (op (op b a) (op (op u b) b)) c := by\n  grind only\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)\u0009Highlights","header":"Grind AC solver","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Grind-AC-solver"}});