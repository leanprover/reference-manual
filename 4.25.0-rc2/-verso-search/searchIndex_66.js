window.docContents[66].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Conversions":{"contents":"Extracts the underlying Nat value.This function is a synonym for Fin.val, which is the simp normal form. Fin.val is also a\ncoercion, so values of type Fin n are automatically converted to Nats as needed.\n\nReturns a modulo n as a Fin n.The assumption NeZero n ensures that Fin n is nonempty.\n\nUses a proof that two bounds are equal to allow a value bounded by one to be used with the other.In other words, when eq : n = m, Fin.cast eq i converts i : Fin n into a Fin m.\n\nReplaces the bound with another that is suitable for the value.The proof embedded in i can be used to cast to a larger bound even if the concrete value is not\nknown.Examples:example : Fin 12 := (7 : Fin 10).castLT (by decide : 7 < 12)\nexample (i : Fin 10) : Fin 12 :=\n  i.castLT <| by\n    cases i; simp; omega\n\n\nCoarsens a bound to one at least as large.See also Fin.castAdd for a version that represents the larger bound with addition rather than an\nexplicit inequality proof.\n\nCoarsens a bound to one at least as large.See also Fin.natAdd and Fin.addNat for addition functions that increase the bound, and\nFin.castLE for a version that uses an explicit inequality proof.\n\nCoarsens a bound by one.\n\nReplaces a value with its difference from the largest value in the type.Considering the values of Fin n as a sequence 0, 1, â€¦, n-2, n-1, Fin.rev finds the\ncorresponding element of the reversed sequence. In other words, it maps 0 to n-1, 1 to n-2,\n..., and n-1 to 0.Examples:* (5 : Fin 6).rev = (0 : Fin 6)* (0 : Fin 6).rev = (5 : Fin 6)* (2 : Fin 5).rev = (2 : Fin 5)\n\nThe type Fin 0 is uninhabited, so it can be used to derive any result whatsoever.This is similar to Empty.elim. It can be thought of as a compiler-checked assertion that a code\npath is unreachable, or a logical contradiction from which False and thus anything else could be\nderived.\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"19.3.3.4. Conversions","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Conversions"},"/Basic-Types/Maps-and-Sets/#maps":{"contents":"A map is a data structure that associates keys with values.\nThey are also referred to as dictionaries, associative arrays, or simply as hash tables.\n\nIn Lean, maps may have the following properties: Representation\n\nThe in-memory representation of a map may be either a tree or a hash table.\n  Tree-based representations are better when the reference to the data structure is shared, because hash tables are based on arrays.\n  Arrays are copied in full on modification when the reference is not unique, while only the path from the root of the tree to the modified nodes must be copied on modification of a tree.\n  Hash tables, on the other hand, can be more efficient when references are not shared, because non-shared arrays can be modified in constant time.\n  Furthermore, tree-based maps store data in order and thus support ordered traversals of the data.\n\n Extensionality\n\nMaps can be viewed as partial functions from keys to values.\n  Extensional maps are maps for which propositional equality matches this interpretation.\n  This can be convenient for reasoning, but it also rules out some useful operations that would be able to distinguish between them.\n  In general, extensional maps should be used only when needed for verification.\n\n Dependent or Not\n\nA dependent map is one in which the type of each value is determined by its corresponding key, rather than being constant.\n  Dependent maps have more expressive power, but are also more difficult to use.\n  They impose more requirements on their users.\n  For example, many operations on DHashMap require LawfulBEq instances rather than BEq.\n\n\n\n* Map* Representation* Extensional?* Dependent?* TreeMap* Tree* No* No* DTreeMap* Tree* No* Yes* HashMap* Hash Table* No* No* DHashMap* Hash Table* No* Yes* ExtHashMap* Hash Table* Yes* No* ExtDHashMap* Hash Table* Yes* Yes\n\nA map can always be used as a set by setting its type of values to Unit.\nThe following set types are provided:\n\n* Std.HashSet is a set based on hash tables. Its performance characteristics are like those of Std.HashMap: it is based on arrays and can be efficiently updated, but only when not shared.* Std.TreeSet is a set based on balanced trees. Its performance characteristics are like those of Std.TreeMap.* Std.ExtHashSet is an extensional hash set type that matches the mathematical notion of finite sets: two sets are equal if they contain the same elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.18. Maps and Sets","id":"/Basic-Types/Maps-and-Sets/#maps"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Discarding-Results":{"contents":"The discard function is especially useful when using an action that returns a value only for its side effects.\n\nDiscards the value in a functor, retaining the functor's structure.Discarding values is especially useful when using Applicative functors or Monads to implement\neffects, and some operation should be carried out only for its effects. In do-notation, statements\nwhose values are discarded must return Unit, and discard can be used to explicitly discard their\nvalues.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009API Reference","header":"14.4.1. Discarding Results","id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Discarding-Results"},"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--Other-solutions":{"contents":"At this point, it's worth pausing and doing at least one of the following:\n\n* Try to prove this yourself! It's quite challenging for a beginner!\n  You can have a go\n  in the Live Lean editor without any installation.* Read Chris Hughes's solution,\n  which is included in the Mathlib Archive.\n  This solution makes good use of Aesop, but is not ideal because1. It defines the solution using a subtype, simultaneously giving the construction and proving properties about it.\n     We think it's better stylistically to keep these separate.2. Even with Aesop automation, there's still about 15 lines of manual proof work before we can hand off to Aesop.* Read Wojciech Nawrocki's solution.\n  This one uses less automation, at about 300 lines of proof work.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if - then - else  Normalization","header":"17.10.2.3. Other solutions","id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--Other-solutions"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--bv_decide":{"contents":"* #7298 adds rewrites to bv_decide's preprocessing that concern\ncombinations of if-then-else and operation such as multiplication or\nnegation.* #7309 fixes a bug where bv_decide's new structure support would\nsometimes not case split on all available structure fvars as their type\nwas an mvar.* #7329 adds support to bv_decide for simple pattern matching on enum\ninductives. By simple we mean non dependent match statements with all\narms written out.* #7347 upgrades the CaDiCal we ship and use for bv_decide to version\n2.1.2. Additionally it enables binary LRAT proofs on windows by default\nas https://github.com/arminbiere/cadical/issues/112 has been fixed.* #7381 refactors the AIG datastructures that underly bv_decide in order\nto allow a better tracking of negations in the circuit. This refactor\nhas two effects, for one adding full constant folding to the AIG\nframework and secondly enabling us to add further simplifications from\nthe Brummayer Biere paper in the future which was previously\narchitecturally impossible.* #7390 makes bv_decide's preprocessing handle casts, as we are in the\nconstant BitVec fragment we should be able to always remove them using\nBitVec.cast_eq.* #7407 adds rules for -1#w * a = -a and a * -1#w = -a to\nbv_normalize as seen in Bitwuzla's BV_MUL_SPECIAL_CONST.* #7417 adds support for enum inductive matches with default branches to\nbv_decide.* #7429 adds the BV_EXTRACT_FULL preprocessing rule from Bitwuzla to\nbv_decide.* #7436 adds simprocs that turn left and right shifts by constants into\nextracts to bv_decide.* #7438 adds the EQUAL_CONST_BV_ADD and BV_AND_CONST rules to\nbv_decide's preprocessor.* #7441 adds the BV_CONCAT_CONST, BV_CONCAT_EXTRACT and ELIM_ZERO_EXTEND\nrule from Bitwuzla to bv_decide.* #7477 ensures that bv_decide doesn't accidentally operate on terms\nunderneath binders. As there is currently no binder construct that is in\nthe supported fragment of bv_decide this changes nothing about the proof\npower.* #7480 adds the necessary rewrites for the Bitwuzla rules\nBV_ULT_SPECIAL_CONST, BV_SIGN_EXTEND_ELIM, TODO.* #7486 adds the BitVec.add_neg_mul rule introduced in #7481 to\nbv_decide's preprocessor.* #7491 achieves a speed up in bv_decide's LRAT checker by improving its\ninput validation.* #7521 adds the equivalent of Array.emptyWithCapacity to the AIG\nframework and applies it to bv_decide. This is particularly useful as\nwe are only working with capacities that are always known at run time so\nwe should never have to reallocate a RefVec.* #7527 adds the BV_EXTRACT_CONCAT_LHS_RHS, NORM_BV_ADD_MUL and\nNORM_BV_SHL_NEG rewrite from Bitwuzla as well as a reduction from\ngetLsbD to extractLsb' to bv_decide.* #7615 adds the ADD part of bitwuzlas BV_EXTRACT_ADD_MUL rule to\nbv_decide's preprocessor.* #7617 adds the known bits optimization from the multiplication circuit\nto the add one, allowing us to discover potentially even more symmetries\nbefore going to the SAT solver.* #7636 makes sure that the expression level cache in bv_decide is\nmaintained across the entire bitblaster instead of just locally per\nBitVec expression.* #7644 adds a cache to the reflection procedure of bv_decide.* #7649 changes the AIG representation of constants from const (b : Bool) to a single constructor false. Since #7381 Ref contains an\ninvert flag meaning the constant true can be represented as a Ref\nto false with invert set, so no expressivity is lost.* #7655 adds the preprocessing rule for extraction over multiplication\nto bv_decide.* #7663 uses computed fields to store the hash code and pointer equality\nto increase performance of comparison and hashmap lookups on the core\ndata structure used by the bitblaster.* #7670 improves the caching computation of the atoms assignment in\nbv_decide's reflection procedure.* #7698 adds more sharing and caching procedures to bv_decide's\nreflection step.* #7720 compresses the AIG representation by storing the inverter bit in\nthe lowest bit of the gate descriptor instead of as a separate Bool.* #7727 avoids some unnecessary allocations in the CNF to dimacs\nconversion* #7733 ensures that in the AIG the constant circuit node is always\nstored at the first spot. This allows us to skip performing a cache\nlookup when we require a constant node.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Language","header":"bv_decide","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--bv_decide"}});