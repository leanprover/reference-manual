window.docContents[186].resolve({"/Build-Tools-and-Distribution/Lake/#lake-scripts":{"contents":"Lake package configuration files may include Lake scripts, which are embedded programs that can be executed from the command line.\nScripts are intended to be used for project-specific tasks that are not already well-served by Lake's other features.\nWhile ordinary executable programs are run in the IO monad, scripts are run in ScriptM, which extends IO with information about the workspace.\nBecause they are Lean definitions, Lake scripts can only be defined in the Lean configuration format.\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","header":"22.1.1.3. Scripts","id":"/Build-Tools-and-Distribution/Lake/#lake-scripts"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Type-Class":{"contents":"Exception monads provide the ability to throw errors and handle errors.In this class, ε is an outParam, which means that it is inferred from m. MonadExceptOf ε\nprovides the same operations, but allows ε to influence instance synthesis.MonadExcept.tryCatch is used to desugar try ... catch ... steps inside do-blocks when the\nhandlers do not have exception type annotations.Throws an exception of type ε to the nearest enclosing handler.Catches errors thrown in body, passing them to handler. Errors in handler are not caught.\n\nRe-interprets an Except ε action in an exception monad m, succeeding if it succeeds and throwing\nan exception if it throws an exception.\n\nUnconditional error recovery that ignores which exception was thrown. Usually used via the <|>\noperator.If both computations throw exceptions, then the result is the second exception.\n\nAn alternative unconditional error recovery operator that allows callers to specify which exception\nto throw in cases where both operations throw exceptions.By default, the first is thrown, because the <|> operator throws the second.\n\nException monads provide the ability to throw errors and handle errors.In this class, ε is a semiOutParam, which means that it can influence the choice of instance.\nMonadExcept ε provides the same operations, but requires that ε be inferable from m.tryCatchThe, which takes an explicit exception type, is used to desugar try ... catch ... steps\ninside do-blocks when the handlers have type annotations.Throws an exception of type ε to the nearest enclosing catch.Catches errors thrown in body, passing them to handler. Errors in handler are not caught.\n\nThrows an exception, with the exception type specified explicitly. This is useful when a monad\nsupports throwing more than one type of exception.Use throw for a version that expects the exception type to be inferred from m.\n\nCatches errors, recovering using handle. The exception type is specified explicitly. This is useful when a monad\nsupports throwing or handling more than one type of exception.Use tryCatch, for a version that expects the exception type to be inferred from m.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Exceptions","header":"14.5.7.2. Type Class","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Type-Class"},"/Notations-and-Macros/Macros/#macro-environment":{"contents":"Macros have only limited support for querying the environment.\nThey can check whether a constant exists and resolve names, but further introspection is unavailable.\n\nReturns true if the environment contains a declaration with name declName\n\nGets the current namespace given the position in the file.\n\nResolves the given name to an overload list of namespaces.\n\nResolves the given name to an overload list of global definitions.\nThe List String in each alternative is the deduced list of projections\n(which are ambiguous with name components).Remark: it will not trigger actions associated with reserved names. Recall that Lean\nhas reserved names. For example, a definition foo has a reserved name foo.def for theorem\ncontaining stating that foo is equal to its definition. The action associated with foo.def\nautomatically proves the theorem. At the macro level, the name is resolved, but the action is not\nexecuted. The actions are executed by the elaborator when converting Syntax into Expr.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009The Macro Monad","header":"20.5.2.3. Querying the Environment","id":"/Notations-and-Macros/Macros/#macro-environment"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-rw":{"contents":"rw is like rewrite, but also tries to close the goal by \"cheap\" (reducible) rfl afterwards.\n\nrewrite [e] applies identity e as a rewrite rule to the target of the main goal.\nIf e is preceded by left arrow (← or <-), the rewrite is applied in the reverse direction.\nIf e is a defined constant, then the equational theorems associated with e are used.\nThis provides a convenient way to unfold e.* rewrite [e₁, ..., eₙ] applies the given rules sequentially.* rewrite [e] at l rewrites e at location(s) l, where l is either * or a\nlist of hypotheses in the local context. In the latter case, a turnstile ⊢ or |-\ncan also be used, to signify the target of the goal.Using rw (occs := .pos L) [e],\nwhere L : List Nat, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from 1.\nAt each allowed occurrence, arguments of the rewrite rule e may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n(occs := .neg L) allows skipping specified occurrences.\n\nerw [rules] is a shorthand for rw (transparency := .default) [rules].\nThis does rewriting up to unfolding of regular definitions (by comparison to regular rw\nwhich only unfolds @[reducible] definitions).\n\nrwa is short-hand for rw; assumption.\n\nConfigures the behavior of the rewrite and rw tactics.The transparency mode to use for unfoldingWhether to support offset constraints such as ?x + 1 =?= eWhich occurrences to rewriteHow to convert the resulting metavariables into  new goals\n\nConfiguration for which occurrences that match an expression should be rewritten.All occurrences should be rewritten.A list of indices for which occurrences should be rewritten.A list of indices for which occurrences should not be rewritten.\n\nWhich constants should be unfolded?Unfolds all constants, even those tagged as @[irreducible].Unfolds all constants except those tagged as @[irreducible].Unfolds only constants tagged with the @[reducible] attribute.Unfolds reducible constants and constants tagged with the @[instance] attribute.\n\nControls which new mvars are turned in to goals by the apply tactic.* nonDependentFirst  mvars that don't depend on other goals appear first in the goal list.* nonDependentOnly only mvars that don't depend on other goals are added to goal list.* all all unassigned mvars are added to the goal list.\n\n* unfold id unfolds all occurrences of definition id in the target.* unfold id1 id2 ... is equivalent to unfold id1; unfold id2; ....* unfold id at h unfolds at the hypothesis h.Definitions can be either global or local definitions.For non-recursive global definitions, this tactic is identical to delta.\nFor recursive global definitions, it uses the \"unfolding lemma\" id.eq_def,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to simp only [id], which unfolds definition id recursively.Implemented by Lean.Elab.Tactic.evalUnfold.\n\nActs like have, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:f : α → β\nh : α\n⊢ goal\nThen after replace h := f h the state will be:f : α → β\nh : β\n⊢ goal\nwhereas have h := f h would result in:f : α → β\nh† : α\nh : β\n⊢ goal\nThis can be used to simulate the specialize and apply at tactics of Coq.\n\ndelta id1 id2 ... delta-expands the definitions id1, id2, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.13. Rewriting","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-rw"}});