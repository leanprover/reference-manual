window.docContents[54].resolve({"/Axioms/#axiom-declarations":{"contents":"Axioms declarations include a name and a type:\n\nAxiom Declarations\n\nAxioms declarations may be modified with all possible declaration modifiers.\nDocumentation comments, attributes, private, and protected have the same meaning as for other declarations.\nThe modifiers partial, nonrec, noncomputable and unsafe have no effect.\n\n","context":"Lean Reference\u0009Axioms","header":"8.1. Axiom Declarations","id":"/Axioms/#axiom-declarations"},"/Basic-Types/Bitvectors/#BitVec":{"contents":"Bitvectors are fixed-width sequences of binary digits.\nThey are frequently used in software verification, because they closely model efficient data structures and operations that are similar to hardware.\nA bitvector can be understood from two perspectives: as a sequence of bits, or as a number encoded by a sequence of bits.\nWhen a bitvector represents a number, it can do so as either a signed or an unsigned number.\nSigned numbers are represented in two's complement form.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.5. Bitvectors","id":"/Basic-Types/Bitvectors/#BitVec"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Constructing-Lists":{"contents":"Constructs a single-element list.Examples:* List.singleton 5 = [5].* List.singleton \"green\" = [\"green\"].* List.singleton [1, 2, 3] = [[1, 2, 3]]\n\nAdds an element to the end of a list.The added element is the last element of the resulting list.Examples:* List.concat [\"red\", \"yellow\"] \"green\" = [\"red\", \"yellow\", \"green\"]* List.concat [1, 2, 3] 4 = [1, 2, 3, 4]* List.concat [] () = [()]\n\nCreates a list that contains n copies of a.* List.replicate 5 \"five\" = [\"five\", \"five\", \"five\", \"five\", \"five\"]* List.replicate 0 \"zero\" = []* List.replicate 2 ' ' = [' ', ' ']\n\nCreates a list that contains n copies of a.This is a tail-recursive version of List.replicate.* List.replicateTR 5 \"five\" = [\"five\", \"five\", \"five\", \"five\", \"five\"]* List.replicateTR 0 \"zero\" = []* List.replicateTR 2 ' ' = [' ', ' ']\n\nCreates a list by applying f to each potential index in order, starting at 0.Examples:* List.ofFn (n := 3) toString = [\"0\", \"1\", \"2\"]* List.ofFn (fun i => #[\"red\", \"green\", \"blue\"].get i.val i.isLt) = [\"red\", \"green\", \"blue\"]\n\nAppends two lists. Normally used via the ++ operator.Appending lists takes time proportional to the length of the first list: O(|xs|).Examples:* [1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5].* [] ++ [4, 5] = [4, 5].* [1, 2, 3] ++ [] = [1, 2, 3].\n\nAppends two lists. Normally used via the ++ operator.Appending lists takes time proportional to the length of the first list: O(|xs|).This is a tail-recursive version of List.append.Examples:* [1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5].* [] ++ [4, 5] = [4, 5].* [1, 2, 3] ++ [] = [1, 2, 3].\n\nReturns a list of the numbers from 0 to n exclusive, in increasing order.O(n).Examples:* range 5 = [0, 1, 2, 3, 4]* range 0 = []* range 2 = [0, 1]\n\nReturns a list of the numbers with the given length len, starting at start and increasing by\nstep at each element.In other words, List.range' start len step is [start, start+step, ..., start+(len-1)*step].Examples:* List.range' 0 3 (step := 1) = [0, 1, 2]* List.range' 0 3 (step := 2) = [0, 2, 4]* List.range' 0 4 (step := 2) = [0, 2, 4, 6]* List.range' 3 4 (step := 2) = [3, 5, 7, 9]\n\nReturns a list of the numbers with the given length len, starting at start and increasing by\nstep at each element.In other words, List.range'TR start len step is [start, start+step, ..., start+(len-1)*step].This is a tail-recursive version of List.range'.Examples:* List.range'TR 0 3 (step := 1) = [0, 1, 2]* List.range'TR 0 3 (step := 2) = [0, 2, 4]* List.range'TR 0 4 (step := 2) = [0, 2, 4, 6]* List.range'TR 3 4 (step := 2) = [3, 5, 7, 9]\n\nLists all elements of Fin n in order, starting at 0.Examples:* List.finRange 0 = ([] : List (Fin 0))* List.finRange 2 = ([0, 1] : List (Fin 2))\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.2. Constructing Lists","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Constructing-Lists"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Lake-Install-Helpers":{"contents":"Get the detected Lake installation.\n\nGet the root directory of the detected Lake installation (e.g., LAKE_HOME).\n\nGet the source directory of the detected Lake installation.\n\nGet the Lean library directory of the detected Lake installation.\n\nGet the path of the lake binary in the detected Lake installation.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference\u0009Accessing the Environment","header":"22.1.4.1.4. Lake Install Helpers","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Lake-Install-Helpers"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Lifting-Boolean-Operations":{"contents":"Converts the result of the monadic action x to a Bool. If it is true, returns y; otherwise,\nreturns the original result of x.This a monadic counterpart to the short-circuiting && operator, usually accessed via the <&&>\noperator.Conventions for notations in identifiers:* The recommended spelling of <&&> in identifiers is andM.\n\nConverts the result of the monadic action x to a Bool. If it is true, returns it and ignores\ny; otherwise, runs y and returns its result.This a monadic counterpart to the short-circuiting || operator, usually accessed via the <||>\noperator.Conventions for notations in identifiers:* The recommended spelling of <||> in identifiers is orM.\n\nRuns a monadic action and returns the negation of its result.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009API Reference","header":"14.4.3. Lifting Boolean Operations","id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Lifting-Boolean-Operations"},"/Run-Time-Code/Foreign-Function-Interface/#The-Lean-Language-Reference--Run-Time-Code--Foreign-Function-Interface--____LSQ_extern_RSQ_--in-the-Interpreter":{"contents":"The Lean interpreter can run Lean declarations for which symbols are available in loaded shared libraries, which includes declarations that are marked extern.\nTo run this code (e.g. with #eval), the following steps are necessary:\n\n1. The module containing the declaration and its dependencies must be compiled into a shared library2. This shared library should be provided to lean --load-dynlib= to run code that imports the module.\n\nIt is not sufficient to load the foreign library containing the external symbol because the interpreter depends on code that is emitted for each extern declaration.\nThus it is not possible to interpret an extern declaration in the same file.\nThe Lean source repository contains an example of this usage in tests/compiler/foreign.\n\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Foreign Function Interface","header":"21.4.3. @[extern]  in the Interpreter","id":"/Run-Time-Code/Foreign-Function-Interface/#The-Lean-Language-Reference--Run-Time-Code--Foreign-Function-Interface--____LSQ_extern_RSQ_--in-the-Interpreter"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Highlights":{"contents":"The Lean v4.17 release brings a range of new features, performance improvements,\nand bug fixes. Notable user-visible updates include:\n\n* #6368 implements executing kernel checking in parallel to elaboration,\nwhich is a prerequisite for parallelizing elaboration itself.* #6711 adds support for UIntX and USize in bv_decide by adding a\npreprocessor that turns them into BitVec of their corresponding size.* #6505 implements a basic async framework as well as asynchronously\nrunning timers using libuv.* improvements to documentation with docgen, which now links\ndot notations (#6703),\ncoerced functions (#6729),\nand tokens (#6730).* extensive library development, in particular, expanding verification APIs of BitVec,\nmaking APIs of List / Array / Vector consistent, and adding lemmas describing the behavior of UInt.* #6597 fixes the indentation of nested traces nodes in the info view.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Highlights","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Highlights"}});