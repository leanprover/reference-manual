window.docContents[93].resolve({"/Basic-Types/Finite-Natural-Numbers/#Fin":{"contents":"\n\nFor any natural number n, the Fin n is a type that contains all the natural numbers that are strictly less than n.\nIn other words, Fin n has exactly n elements.\nIt can be used to represent the valid indices into a list or array, or it can serve as a canonical n-element type.\n\nNatural numbers less than some upper bound.In particular, a Fin n is a natural number i with the constraint that i < n. It is the\ncanonical type with n elements.Creates a Fin n from i : Nat and a proof that i < n.The number that is strictly less than n.Fin.val is a coercion, so any Fin n can be used in a position where a Nat is expected.The number val is strictly less than the bound n.\n\nFin is closely related to UInt8, UInt16, UInt32, UInt64, and USize, which also represent finite non-negative integral types.\nHowever, these types are backed by bitvectors rather than by natural numbers, and they have fixed bounds.\nFin is comparatively more flexible, but also less convenient for low-level reasoning.\nIn particular, using bitvectors rather than proofs that a number is less than some power of two avoids needing to take care to avoid evaluating the concrete bound.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.3. Finite Natural Numbers","id":"/Basic-Types/Finite-Natural-Numbers/#Fin"},"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Arithmetic":{"contents":"Typically, arithmetic operations on integers are accessed using Lean's overloaded arithmetic notation.\nIn particular, the instances of Add Int, Neg Int, Sub Int, and Mul Int allow ordinary infix operators to be used.\nDivision is somewhat more intricate, because there are multiple sensible notions of division on integers.\n\nAddition of integers, usually accessed via the + operator.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* (7 : Int) + (6 : Int) = 13* (6 : Int) + (-6 : Int) = 0\n\nSubtraction of integers, usually accessed via the - operator.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* (63 : Int) - (6 : Int) = 57* (7 : Int) - (0 : Int) = 7* (0 : Int) - (7 : Int) = -7\n\nNon-truncating subtraction of two natural numbers.Examples:* Int.subNatNat 5 2 = 3* Int.subNatNat 2 5 = -3* Int.subNatNat 0 13 = -13\n\nNegation of integers, usually accessed via the - prefix operator.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* -(6 : Int) = -6* -(-6 : Int) = 6* (12 : Int).neg = -12\n\nNegation of natural numbers.Examples:* Int.negOfNat 6 = -6* Int.negOfNat 0 = 0\n\nMultiplication of integers, usually accessed via the * operator.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* (63 : Int) * (6 : Int) = 378* (6 : Int) * (-6 : Int) = -36* (7 : Int) * (0 : Int) = 0\n\nPower of an integer to a natural number, usually accessed via the ^ operator.Examples:* (2 : Int) ^ 4 = 16* (10 : Int) ^ 0 = 1* (0 : Int) ^ 10 = 0* (-7 : Int) ^ 3 = -343\n\nComputes the greatest common divisor of two integers as a natural number. The GCD of two integers is\nthe largest natural number that evenly divides both. However, the GCD of a number and 0 is the\nnumber's absolute value.This implementation uses Nat.gcd, which is overridden in both the kernel and the compiler to\nefficiently evaluate using arbitrary-precision arithmetic.Examples:* Int.gcd 10 15 = 5* Int.gcd 10 (-15) = 5* Int.gcd (-6) (-9) = 3* Int.gcd 0 5 = 5* Int.gcd (-7) 0 = 7\n\nComputes the least common multiple of two integers as a natural number. The LCM of two integers is\nthe smallest natural number that's evenly divisible by the absolute values of both.Examples:* Int.lcm 9 6 = 18* Int.lcm 9 (-6) = 18* Int.lcm 9 3 = 9* Int.lcm 9 (-3) = 9* Int.lcm 0 3 = 0* Int.lcm (-3) 0 = 0\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","header":"19.2.4.3. Arithmetic","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Arithmetic"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Iteration":{"contents":"Updates the values of the hash map by applying the given function to all mappings.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Maps","header":"19.18.4.5. Iteration","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Iteration"},"/Notations-and-Macros/Precedence/#precedence":{"contents":"Infix operators, notations, and other syntactic extensions to Lean make use of explicit precedence annotations.\nWhile precedences in Lean can technically be any natural number, by convention they range from 10 to 1024, respectively denoted min and max.\nFunction application has the highest precedence.\n\nParser PrecedencesMost operator precedences consist of explicit numbers.\nThe named precedence levels denote the outer edges of the range, close to the minimum or maximum, and are typically used by more involved syntax extensions.Precedences may also be denoted as sums or differences of precedences; these are typically used to assign precedences that are relative to one of the named precedences.The maximum precedence is used to parse terms that occur in a function position.\nOperators should typically not use use this level, because it can interfere with users' expectation that function application binds more tightly than any other operator, but it is useful in more involved syntax extensions to indicate how other constructs interact with function application.Argument precedence is one less than the maximum precedence.\nThis level is useful for defining syntax that should be treated as an argument to a function, such as fun or do.Lead precedence is less that argument precedence, and should be used for custom syntax that should not occur as a function argument, such as let.The minimum precedence can be used to ensure that an operator binds less tightly than all other operators.\n\n","context":"Lean Reference\u0009Notations and Macros","header":"20.2. Precedence","id":"/Notations-and-Macros/Precedence/#precedence"},"/The-Type-System/Quotients/#quotient-proofs":{"contents":"The fundamental tools for proving properties of elements of quotient types are the soundness axiom and the induction principle.\nThe soundness axiom states that if two elements of the underlying type are related by the quotient's equivalence relation, then they are equal in the quotient type.\nThe induction principle follows the structure of recursors for inductive types: in order to prove that a predicate holds all elements of a quotient type, it suffices to prove that it holds for an application of Quotient.mk to each element of the underlying type.\nBecause Quotient is not an inductive type, tactics such as cases and induction require that Quotient.ind be specified explicitly with the using modifier.\n\nThe quotient axiom, which asserts the equality of elements related in the setoid.Because Quotient is built on a lower-level type Quot, Quotient.sound is implemented as a\ntheorem. It is derived from Quot.sound, the soundness axiom for the lower-level quotient type\nQuot.\n\nA reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with Quotient.mk.\n\nProofs About QuotientsGiven the definition of integers as a quotient type from the prior examples, Quotient.ind and Quotient.sound can be used to prove that negation is an additive inverse.\nFirst, Quotient.ind is used to replace instances of n with applications of Quotient.mk.\nHaving done so, the left side of the equality becomes definitionally equal to a single application of Quotient.mk, via unfolding definitions and the computation rule for Quotient.lift.\nThis makes Quotient.sound applicable, which yields a new goal: to show that both sides are related by the equivalence relation.\nThis is provable using simp_arith.theorem Z.add_neg_inverse (n : Z) : n  + (-n) = 0 := by\n  cases n using Quotient.ind\n  apply Quotient.sound\n  simp +arith [· ≈ ·, Setoid.r, eq]\n\n\nFor more specialized use cases, Quotient.rec, Quotient.recOn, and Quotient.hrecOn can be used to define dependent functions from a quotient type to a type in any other universe.\nStating that a dependent function respects the quotient's equivalence relation requires a means of dealing with the fact that the dependent result type is instantiated with different values from the quotient on each side of the equality.\nQuotient.rec and Quotient.recOn use the Quotient.sound to equate the related elements, inserting the appropriate cast into the statement of equality, while Quotient.hrecOn uses heterogeneous equality.\n\nA dependent recursion principle for Quotient. It is analogous to the\nrecursor for a structure, and can be used when the resulting type\nis not necessarily a proposition.While it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:* Quotient.lift is useful for defining non-dependent functions.* Quotient.ind is useful for proving theorems about quotients.* Quotient.recOnSubsingleton can be used whenever the target type is a Subsingleton.* Quotient.hrecOn uses heterogeneous equality instead of rewriting with Quotient.sound.Quotient.recOn is a version of this recursor that takes the quotient parameter first.\n\nA dependent recursion principle for Quotient. It is analogous to the\nrecursor for a structure, and can be used when the resulting type\nis not necessarily a proposition.While it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:* Quotient.lift is useful for defining non-dependent functions.* Quotient.ind is useful for proving theorems about quotients.* Quotient.recOnSubsingleton can be used whenever the target type is a Subsingleton.* Quotient.hrecOn uses heterogeneous equality instead of rewriting with Quotient.sound.Quotient.rec is a version of this recursor that takes the quotient parameter last.\n\nA dependent recursion principle for Quotient that uses heterogeneous\nequality, analogous to a recursor for\na structure.Quotient.recOn is a version of this recursor that uses Eq instead of HEq.\n\nIf two elements of a type are equal in a quotient, then they are related by the setoid's equivalence relation.\nThis property is called Quotient.exact.\n\nIf two values are equal in a quotient, then they are related by its equivalence relation.\n\n","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Quotient API","header":"4.5.4.3. Proofs About Quotients","id":"/The-Type-System/Quotients/#quotient-proofs"}});