window.docContents[151].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Iteration":{"contents":"Folds an operation from left to right over the elements in a subarray.\nAn accumulator of type β is constructed by starting with init and combining each\nelement of the subarray with the current accumulator value in turn.\nExamples:* #[\"red\", \"green\", \"blue\"].toSubarray.foldl (· + ·.length) 0 = 12* #[\"red\", \"green\", \"blue\"].toSubarray.popFront.foldl (· + ·.length) 0 = 9\n\nFolds a monadic operation from left to right over the elements in a subarray.\nAn accumulator of type β is constructed by starting with init and monadically combining each\nelement of the subarray with the current accumulator value in turn. The monad in question may permit\nearly termination or repetition.\nExamples:#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldlM (init := \"\") fun acc x => do\n  let l ← Option.guard (· ≠ 0) x.length\n  return s!\"{acc}({l}){x} \"\nsome \"(3)red (5)green (4)blue \"\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldlM (init := 0) fun acc x => do\n  let l ← Option.guard (· ≠ 5) x.length\n  return s!\"{acc}({l}){x} \"\nnone\n\n\nFolds an operation from right to left over the elements in a subarray.An accumulator of type β is constructed by starting with init and combining each element of the\nsubarray with the current accumulator value in turn, moving from the end to the start.Examples:* #[\"red\", \"green\", \"blue\"].toSubarray.foldr (·.length + ·) 0 = 12* #[\"red\", \"green\", \"blue\"].toSubarray.popFront.foldr (·.length + ·) 0 = 9\n\nFolds a monadic operation from right to left over the elements in a subarray.An accumulator of type β is constructed by starting with init and monadically combining each\nelement of the subarray with the current accumulator value in turn, moving from the end to the\nstart. The monad in question may permit early termination or repetition.Examples:#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldrM (init := \"\") fun x acc => do\n  let l ← Option.guard (· ≠ 0) x.length\n  return s!\"{acc}({l}){x} \"\nsome \"(4)blue (5)green (3)red \"\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldrM (init := 0) fun x acc => do\n  let l ← Option.guard (· ≠ 5) x.length\n  return s!\"{acc}({l}){x} \"\nnone\n\n\nRuns a monadic action on each element of a subarray.The elements are processed starting at the lowest index and moving up.\n\nRuns a monadic action on each element of a subarray, in reverse order.The elements are processed starting at the highest index and moving down.\n\nThe implementation of ForIn.forIn for Subarray, which allows it to be used with for loops in\ndo-notation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","header":"19.16.5.5. Iteration","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Iteration"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Library-Targets":{"contents":"Library targets are expected in the lean_lib array of tables.\n\nA Lean library's declarative configuration.The library's name, which is typically the same as its single module root.The subdirectory of the package's source directory containing the library's\nLean source files. Defaults simply to said srcDir.(This will be passed to lean as the -R option.)The root module(s) of the library.\nSubmodules of these roots (e.g., Lib.Foo of Lib) are considered\npart of the library.\nDefaults to a single root of the target's name.The name of the library artifact.\nUsed as a base for the file names of its static and dynamic binaries.\nDefaults to the mangled name of the target.Whether static and shared binaries of this library should be prefixed with lib on Windows.Unlike Unix, Windows does not require native libraries to start with lib and,\nby convention, they usually do not. However, for consistent naming across all platforms,\nusers may wish to enable this.Defaults to false.An Array of targets to build before the executable's modules.Deprecated. Use needs instead.\nAn Array of target names to build before the library's modules.Whether to compile each of the library's modules into a native shared library\nthat is loaded whenever the module is imported. This speeds up evaluation of\nmetaprograms and enables the interpreter to run functions marked @[extern].Defaults to false.An Array of library facets to build on a bare lake build of the library.\nFor example, #[LeanLib.sharedLib] will build the shared library facet.Whether downstream packages can import all modules of this library.If enabled, downstream users will be able to access the private internals of modules,\nincluding definition bodies not marked as @[expose].\nThis may also, in the future, prevent compiler optimization which rely on private\ndefinitions being inaccessible outside their own package.Defaults to false.The mode in which the modules should be built (e.g., debug, release).\nDefaults to release.An Array of additional options to pass to both the Lean language server\n(i.e., lean --server) launched by lake serve and to lean when compiling\na module's Lean source files.Additional arguments to pass to lean\nwhen compiling a module's Lean source files.Additional arguments to pass to lean\nwhen compiling a module's Lean source files.Unlike moreLeanArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLeanArgs.Additional arguments to pass to leanc\nwhen compiling a module's C source files generated by lean.Lake already passes some flags based on the buildType,\nbut you can change this by, for example, adding -O0 and -UNDEBUG.Additional options to pass to the Lean language server\n(i.e., lean --server) launched by lake serve.Additional arguments to pass to leanc\nwhen compiling a module's C source files generated by lean.Unlike moreLeancArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLeancArgs.Additional target objects to use when linking (both static and shared).\nThese will come after the paths of native facets.Additional target libraries to pass to leanc when linking\n(e.g., for shared libraries or binary executables).\nThese will come after the paths of other link objects.Additional arguments to pass to leanc when linking (e.g., for shared\nlibraries or binary executables). These will come after the paths of\nthe linked objects.Additional arguments to pass to leanc when linking (e.g., for shared\nlibraries or binary executables). These will come after the paths of\nthe linked objects.Unlike moreLinkArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLinkArgs.Asserts whether Lake should assume Lean modules are platform-independent.* If false, Lake will add System.Platform.target to the module traces\nwithin the code unit (e.g., package or library). This will force Lean code\nto be re-elaborated on different platforms.* If true, Lake will exclude platform-dependent elements\n(e.g., precompiled modules, external libraries) from a module's trace,\npreventing re-elaboration on different platforms. Note that this will not\neffect  modules outside the code unit in question. For example, a\nplatform-independent package which depends on a platform-dependent library\nwill still be platform-dependent.* If none, Lake will construct traces as natural. That is, it will include\nplatform-dependent artifacts in the trace if they module depends on them,\nbut otherwise not force modules to be platform-dependent.There is no check  for correctness here, so a configuration can lie\nand Lake will not catch it. Defaults to none.\n\nMinimal Library TargetThis library declaration supplies only a name:[[lean_lib]]\nname = \"TacticTools\"\nThe library's source is located in the package's default source directory, in the module hierarchy rooted at TacticTools.\n\nConfigured Library TargetThis library declaration supplies more options:[[lean_lib]]\nname = \"TacticTools\"\nsrcDir = \"src\"\nprecompileModules = true\nThe library's source is located in the directory src, in the module hierarchy rooted at TacticTools.\nIf its modules are accessed at elaboration time, they will be compiled to native code and linked in, rather than run in the interpreter.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Declarative TOML Format","header":"22.1.3.1.3. Library Targets","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Library-Targets"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-assumptions":{"contents":"assumption tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the ‹t› term notation, which is a shorthand for show t by assumption.\n\napply_assumption looks for an assumption of the form ... → ∀ _, ... → head\nwhere head matches the current goal.You can specify additional rules to apply using apply_assumption [...].\nBy default apply_assumption will also try rfl, trivial, congrFun, and congrArg.\nIf you don't want these, or don't want to use all hypotheses, use apply_assumption only [...].\nYou can use apply_assumption [-h] to omit a local hypothesis.\nYou can use apply_assumption using [a₁, ...] to use all lemmas which have been labelled\nwith the attributes aᵢ (these attributes must be created using register_label_attr).apply_assumption will use consequences of local hypotheses obtained via symm.If apply_assumption fails, it will call exfalso and try again.\nThus if there is an assumption of the form P → ¬ Q, the new tactic state\nwill have two goals, P and Q.You can pass a further configuration via the syntax apply_rules (config := {...}) lemmas.\nThe options supported are the same as for solve_by_elim (and include all the options for apply).\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.2. Assumptions","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-assumptions"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--___Try-this___-suggestions-are-rendered-under-___Messages___":{"contents":"* #9966 adjusts the \"try this\" widget to be rendered as a widget message\nunder 'Messages', not a separate widget under a 'Suggestions' section.\nThe main benefit of this is that the message of the widget is not\nduplicated between 'Messages' and 'Suggestions'.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)\u0009Highlights","header":"\"Try this\" suggestions are rendered under 'Messages'","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--___Try-this___-suggestions-are-rendered-under-___Messages___"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Compiler":{"contents":"* #10429 fixes and overeager reuse of specialisation in the code\ngenerator.* #10444 fixes an overeager insertion of inc operations for large uint\nconstants.* #10488 changes the way that scientific numerals are parsed in order to\ngive better error messages for (invalid) syntax like 32.succ.* #10495 fixes constant folding for UIntX in the code generator. This\noptimization was previously simply dead code due to the way that uint\nliterals are encoded.* #10610 ensures that even if a type is marked as irreducible the\ncompiler can see through it in\norder to discover functions hidden behind type aliases.* #10626 reduces the aggressiveness of the dead let eliminator from\nlambda RC.* #10689 fixes an oversight in the RC insertion phase in the code\ngenerator.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc2 (2025-10-22)","header":"Compiler","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc2-_LPAR_2025-10-22_RPAR_--Compiler"}});