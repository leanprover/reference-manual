window.docContents[241].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Creation":{"contents":"Creates a new empty hash set. The optional parameter capacity can be supplied to presize the\nset so that it can hold the given number of elements without reallocating. It is also possible to\nuse the empty collection notations ∅ and {} to create an empty hash set with the default\ncapacity.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Sets","header":"19.18.7.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Creation"},"/IO/#io":{"contents":"Lean is a pure functional programming language.\nWhile Lean code is strictly evaluated at run time, the order of evaluation that is used during type checking, especially while checking definitional equality, is formally unspecified and makes use of a number of heuristics that improve performance but are subject to change.\nThis means that simply adding operations that perform side effects (such as file I/O, exceptions, or mutable references) would lead to programs in which the order of effects is unspecified.\nDuring type checking, even terms with free variables are reduced; this would make side effects even more difficult to predict.\nFinally, a basic principle of Lean's logic is that functions are functions that map each element of the domain to a unique element of the range.\nIncluding side effects such as console I/O, arbitrary mutable state, or random number generation would violate this principle.\n\nPrograms that may have side effects have a type (typically IO α) that distinguishes them from pure functions.\nLogically speaking, IO describes the sequencing and data dependencies of side effects.\nMany of the basic side effects, such as reading from files, are opaque constants from the perspective of Lean's logic.\nOthers are specified by code that is logically equivalent to the run-time version.\nAt run time, the compiler produces ordinary code.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"15. IO","id":"/IO/#io"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Library":{"contents":"* #5020 swaps the parameters to Membership.mem. A purpose of this change is to make set-like CoeSort coercions to refer to the eta-expanded function fun x => Membership.mem s x, which can reduce in many computations. Another is that having the s argument first leads to better discrimination tree keys. (See breaking changes.)* Array* #4970 adds @[ext] attribute to Array.ext.* #4957 deprecates Array.get_modify.* List* #4995 upstreams List.findIdx lemmas.* #5029, #5048 and #5132 add List.Sublist lemmas, some upstreamed. #5077 fixes implicitness in refl/rfl lemma binders.  add List.Sublist theorems.* #5047 upstreams List.Pairwise lemmas.* #5053, #5124, and #5161 add List.find?/findSome?/findIdx? theorems.* #5039 adds List.foldlRecOn and List.foldrRecOn recursion principles to prove things about List.foldl and List.foldr.* #5069 upstreams List.Perm.* #5092 and #5107 add List.mergeSort and a fast @[csimp] implementation.* #5103 makes the simp lemmas for List.subset more aggressive.* #5106 changes the statement of List.getLast?_cons.* #5123 and #5158 add List.range and List.iota lemmas.* #5130 adds List.join lemmas.* #5131 adds List.append lemmas.* #5152 adds List.erase(|P|Idx) lemmas.* #5127 makes miscellaneous lemma updates.* #5153 and #5160 add lemmas about List.attach and List.pmap.* #5164, #5177, and #5215 add List.find? and List.range'/range/iota lemmas.* #5196 adds List.Pairwise_erase and related lemmas.* #5151 and #5163 improve confluence of List simp lemmas. #5105 and #5102 adjust List simp lemmas.* #5178 removes List.getLast_eq_iff_getLast_eq_some as a simp lemma.* #5210 reverses the meaning of List.getElem_drop and List.getElem_drop'.* #5214 moves @[csimp] lemmas earlier where possible.* Nat and Int* #5104 adds Nat.add_left_eq_self and relatives.* #5146 adds missing Nat.and_xor_distrib_(left|right).* #5148 and #5190 improve Nat and Int simp lemma confluence.* #5165 adjusts Int simp lemmas.* #5166 adds Int lemmas relating neg and emod/mod.* #5208 reverses the direction of the Int.toNat_sub simp lemma.* #5209 adds Nat.bitwise lemmas.* #5230 corrects the docstrings for integer division and modulus.* Option* #5128 and #5154 add Option lemmas.* BitVec* #4889 adds sshiftRight bitblasting.* #4981 adds Std.Associative and Std.Commutative instances for BitVec.[and|or|xor].* #4913 enables missingDocs error for BitVec modules.* #4930 makes parameter names for BitVec more consistent.* #5098 adds BitVec.intMin. Introduces boolToPropSimps simp set for converting from boolean to propositional expressions.* #5200 and #5217 rename BitVec.getLsb to BitVec.getLsbD, etc., to bring naming in line with List/Array/etc.* Theorems: #4977, #4951, #4667, #5007, #4997, #5083, #5081, #4392* UInt* #4514 fixes naming convention for UInt lemmas.* Std.HashMap and Std.HashSet* #4943 deprecates variants of hash map query methods. (See breaking changes.)* #4917 switches the library and Lean to Std.HashMap and Std.HashSet almost everywhere.* #4954 deprecates Lean.HashMap and Lean.HashSet.* #5023 cleans up lemma parameters.* Std.Sat (for bv_decide)* #4933 adds definitions of SAT and CNF.* #4953 defines \"and-inverter graphs\" (AIGs) as described in section 3 of Davis-Swords 2013.* Parsec* #4774 generalizes the Parsec library, allowing parsing of iterable data beyond String such as ByteArray. (See breaking changes.)* #5115 moves Lean.Data.Parsec to Std.Internal.Parsec for bootstrappng reasons.* Thunk* #4969 upstreams Thunk.ext.* IO* #4973 modifies IO.FS.lines to handle \\r\\n on all operating systems instead of just on Windows.* #5125 adds createTempFile and withTempFile for creating temporary files that can only be read and written by the current user.* Other fixes or improvements* #4945 adds Array, Bool and Prod utilities from LeanSAT.* #4960 adds Relation.TransGen.trans.* #5012 states WellFoundedRelation Nat using <, not Nat.lt.* #5011 uses ≠ instead of Not (Eq ...) in Fin.ne_of_val_ne.* #5197 upstreams Fin.le_antisymm.* #5042 reduces usage of refine'.* #5101 adds about if-then-else and Option.* #5112 adds basic instances for ULift and PLift.* #5133 and #5168 make fixes from running the simpNF linter over Lean.* #5156 removes a bad simp lemma in omega theory.* #5155 improves confluence of Bool simp lemmas.* #5162 improves confluence of Function.comp simp lemmas.* #5191 improves confluence of if-then-else simp lemmas.* #5147 adds @[elab_as_elim] to Quot.rec, Nat.strongInductionOn and Nat.casesStrongInductionOn, and also renames the latter two to Nat.strongRecOn and Nat.casesStrongRecOn (deprecated in #5179).* #5180 disables some simp lemmas with bad discrimination tree keys.* #5189 cleans up internal simp lemmas that had leaked.* #5198 cleans up allowUnsafeReducibility.* #5229 removes unused lemmas from some simp tactics.* #5199 removes >6 month deprecations.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Library","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Library"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--Structures":{"contents":"* #7302 changes how fields are elaborated in the structure/class\ncommands and also makes default values respect the structure resolution\norder when there is diamond inheritance. Before, the details of\nsubobjects were exposed during elaboration, and in the local context any\nfields that came from a subobject were defined to be projections of the\nsubobject field. Now, every field is represented as a local variable.\nAll parents (not just subobject parents) are now represented in the\nlocal context, and they are now local variables defined to be parent\nconstructors applied to field variables (inverting the previous\nrelationship). Other notes:* The entire collection of parents is processed, and all parent\nprojection names are checked for consistency. Every parent appears in\nthe local context now.* For classes, every parent now contributes an instance, not just the\nparents represented as subobjects.* Default values are now processed according to the parent resolution\norder. Default value definition/override auxiliary definitions are\nstored at StructName.fieldName._default, and inherited values are\nstored at StructName.fieldName._inherited_default. Metaprograms no\nlonger need to look at parents when doing calculations on default\nvalues.* Default value omission for structure instance notation pretty printing\nhas been updated in consideration of this.* Now the elaborator generates a _flat_ctor constructor that will be\nused for structure instance elaboration. All types in this constructor\nare put in \"field normal form\" (projections of parent constructors are\nreduced, and parent constructors are eta reduced), and all fields with\nautoParams are annotated as such. This is not meant for users, but it\nmay be useful for metaprogramming.* While elaborating fields, any metavariables whose type is one of the\nparents is assigned to that parent. The hypothesis is that, for the\npurpose of elaborating structure fields, parents are fixed: there is\nonly one instance of any given parent under consideration. See the\nMagma test for an example of this being necessary. The hypothesis may\nnot be true when there are recursive structures, since different values\nof the structure might not agree on parent fields.* #7314 changes elaboration of structure parents so that each must be\nfully elaborated before the next one is processed.* #7640 implements the main logic for inheriting and overriding\nautoParam fields in the structure/class commands, pending being\nenabled in the structure instance notation elaborator. Adds term info to\noverridden fields, so they now can be hovered over, and \"go to\ndefinition\" goes to the structure the field is originally defined in.* #7652 gives #print for structures the ability to show the default\nvalues and auto-param tactics for fields.* #7717 changes how {...}/where notation (\"structure instance\nnotation\") elaborates. The notation now tries to simulate a flat\nrepresentation as much as possible, without exposing the details of\nsubobjects. Features:* When fields are elaborated, their expected types now have a couple\nreductions applied. For all projections and constructors associated to\nthe structure and its parents, projections of constructors are reduced\nand constructors of projections are eta reduced, and also implementation\ndetail local variables are zeta reduced in propositions (so tactic\nproofs should never see them anymore). Furthermore, field values are\nbeta reduced automatically in successive field types. The example in\nmathlib4#12129\nnow shows a goal of 0 = 0 rather than { toFun := fun x => x }.toFun 0 = 0.* All parents can now be used as field names, not just the subobject\nparents. These are like additional sources but with three constraints:\nevery field of the value must be used, the fields must not overlap with\nother provided fields, and every field of the specified parent must be\nprovided for. Similar to sources, the values are hoisted to lets if\nthey are not already variables, to avoid multiple evaluation. They are\nimplementation detail local variables, so they get unfolded for\nsuccessive fields.* All class parents are now used to fill in missing fields, not just the\nsubobject parents. Closes #6046. Rules: (1) only those parents whose\nfields are a subset of the remaining fields are considered, (2) parents\nare considered only before any fields are elaborated, and (3) only those\nparents whose type can be computed are considered (this can happen if a\nparent depends on another parent, which is possible since #7302).* Default values and autoparams now respect the resolution order\ncompletely: each field has at most one default value definition that can\nprovide for it. The algorithm that tries to unstick default values by\nwalking up the subobject hierarchy has been removed. If there are\napplications of default value priorities, we might consider it in a\nfuture release.* The resulting constructors are now fully packed. This is implemented\nby doing structure eta reduction of the elaborated expressions.* \"Magic field definitions\" (as reported on\nZulip)\nhave been eliminated. This was where fields were being solved for by\nunification, tricking the default value system into thinking they had\nactually been provided. Now the default value system keeps track of\nwhich fields it has actually solved for, and which fields the user did\nnot provide. Explicit structure fields (the default kind) without any\nexplicit value definition will result in an error. If it was solved for\nby unification, the error message will include the inferred value, like\n\"field 'f' must be explicitly provided, its synthesized value is v\"* When the notation is used in patterns, it now no longer inserts fields\nusing class parents, and it no longer applies autoparams or default\nvalues. The motivation is that one expects patterns to match only the\ngiven fields. This is still imperfect, since fields might be solved for\nindirectly.* Elaboration now attempts error recovery. Extraneous fields log errors\nand are ignored, missing fields are filled with sorry.* #7742 adds a feature to structure/class where binders without\ntypes on a field definition are interpreted as overriding the type's\nparameters binder kinds in that field's projection function. The rules\nare (1) only a prefix of the binders are interpreted this way, (2)\nmulti-identifier binders are allowed but they must all be for\nparameters, (3) only parameters that appear in the declaration itself\n(not from variables) can be overridden and (4) the updates will be\napplied after parameter binder kind inference is done. Binder updates\nare not allowed in default value redefinitions. Example application: In\nthe following, (R p) causes the R and p parameters to be explicit,\nwhere normally they would be implicit.class CharP (R : Type u) [AddMonoidWithOne R] (p : Nat) : Prop where\n  cast_eq_zero_iff (R p) : ∀ x : Nat, (x : R) = 0 ↔ p ∣ x\n\n#guard_msgs in #check CharP.cast_eq_zero_iff\n/-\ninfo: CharP.cast_eq_zero_iff.{u} (R : Type u) {inst✝ : AddMonoidWithOne R} (p : Nat) [self : CharP R p] (x : Nat) :\n  ↑x = 0 ↔ p ∣ x\n-/\n* #7746 adds declaration ranges to structure fields that were copied\nfrom parents that aren't represented as subobjects, supporting \"go to\ndefinition\". The declaration range is the parent in the extends\nclause.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Language","header":"Structures","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--Structures"}});