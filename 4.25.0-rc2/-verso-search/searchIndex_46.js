window.docContents[46].resolve({"/Definitions/Recursive-Definitions/#recursive-definitions":{"contents":"Allowing arbitrary recursive function definitions would make Lean's logic inconsistent.\nGeneral recursion makes it possible to write circular proofs: \"proposition P is true because proposition P is true\".\nOutside of proofs, an infinite loop could be assigned the type Empty, which can be used with nomatch or Empty.rec to prove any theorem.\n\nBanning recursive function definitions outright would render Lean far less useful: inductive types are key to defining both predicates and data, and they have a recursive structure.\nFurthermore, most useful recursive functions do not threaten soundness, and infinite loops usually indicate mistakes in definitions rather than intentional behavior.\nInstead of banning recursive functions, Lean requires that each recursive function is defined safely.\nWhile elaborating recursive definitions, the Lean elaborator also produces a justification that the function being defined is safe.The section on the elaborator's output in the overview of elaboration contextualizes the elaboration of recursive definitions in the overall context of the elaborator.\n\nThere are five main kinds of recursive functions that can be defined:\n\n Structurally recursive functions\n\nStructurally recursive functions take an argument such that the function makes recursive calls only on strict sub-components of said argument.Strictly speaking, arguments whose types are indexed families are grouped together with their indices, with the whole collection considered as a unit.\n  The elaborator translates the recursion into uses of the argument's recursor.\n  Because every type-correct use of a recursor is guaranteed to avoid infinite regress, this translation is evidence that the function terminates.\n  Applications of functions defined via recursors are definitionally equal to the result of the recursion, and are typically relatively efficient inside the kernel.\n\n Recursion over well-founded relations\n\nMany functions are also difficult to convert to structural recursion; for instance, a function may terminate because the difference between an array index and the size of the array decreases as the index increases, but Nat.rec isn't applicable because the index that increases is the function's argument.\n  Here, there is a measure of termination that decreases at each recursive call, but the measure is not itself an argument to the function.\n  In these cases, well-founded recursion can be used to define the function.\n  Well-founded recursion is a technique for systematically transforming recursive functions with a decreasing measure into recursive functions over proofs that every sequence of reductions to the measure eventually terminates at a minimum.\n  Applications of functions defined via well-founded recursion are not necessarily definitionally equal to their return values, but this equality can be proved as a proposition.\n  Even when definitional equalities exist, these functions are frequently slow to compute with because they require reducing proof terms that are often very large.\n\n Recursive functions as partial fixpoints\n\nThe definition of a function can be understood as an equation that specifies its behavior.\n  In certain cases, the existence of a function that satisfies this specification can be proven even when the recursive function does not necessarily terminate for all inputs.\n  This strategy is even applicable in some cases where the function definition does not necessarily terminate for all inputs.\n  These partial functions emerge as fixed points of these equations are called partial fixpoints.In particular, any function whose return type is in certain monads (e.g. Option) can be defined using this strategy.\n  Lean generates additional partial correctness theorems for these monadic functions.\n  As with well-founded recursion, applications of functions defined as partial fixpoints are not definitionally equal to their return values, but Lean generates theorems that propositionally equate the function to its unfolding and to the reduction behavior specified in its definition.\n\n Partial functions with nonempty codomains\n\nFor many applications, it's not important to reason about the implementation of certain functions.\n  A recursive function might be used only as part of the implementation of proof automation steps, or it might be an ordinary program that will never be formally proved correct.\n  In these cases, the Lean kernel does not need either definitional or propositional equalities to hold for the definition; it suffices that soundness is maintained.\n  Functions marked partial are treated as opaque constants by the kernel and are neither unfolded nor reduced.\n  All that is required for soundness is that their return type is inhabited.\n  Partial functions may still be used in compiled code as usual, and they may appear in propositions and proofs; their equational theory in Lean's logic is simply very weak.\n\n Unsafe recursive definitions\n\nUnsafe definitions have none of the restrictions of partial definitions.\n  They may freely make use of general recursion, and they may use features of Lean that break assumptions about its equational theory, such as primitives for casting (unsafeCast), checking pointer equality (ptrAddrUnsafe), and observing reference counts (isExclusiveUnsafe).\n  However, any declaration that refers to an unsafe definition must itself be marked unsafe, making it clear when logical soundness is not guaranteed.\n  Unsafe operations can be used to replace the implementations of other functions with more efficient variants in compiled code, while the kernel still uses the original definition.\n  The replaced function may be opaque, which results in the function name having a trivial equational theory in the logic, or it may be an ordinary function, in which case the function is used in the logic.\n  Use this feature with care: logical soundness is not at risk, but the behavior of programs written in Lean may diverge from their verified logical models if the unsafe implementation is incorrect.\n\n\n\n\n\nAs described in the overview of the elaborator's output, elaboration of recursive functions proceeds in two phases:\n\n1. The definition is elaborated as if Lean's core type theory had recursive definitions.\n    Aside from using recursion, this provisional definition is fully elaborated.\n    The compiler generates code from these provisional definitions.2. A termination analysis attempts to use the four techniques to justify the function to Lean's kernel.\n    If the definition is marked unsafe or partial, then that technique is used.\n    If an explicit termination_by clause is present, then the indicated technique is the only one attempted.\n    If there is no such clause, then the elaborator performs a search, testing each parameter to the function as a candidate for structural recursion, and attempting to find a measure with a well-founded relation that decreases at each recursive call.\n\nThis section describes the rules that govern recursive functions.\nAfter a description of mutual recursion, each of the five kinds of recursive definitions is specified, along with the tradeoffs between reasoning power and flexibility that go along with each.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions","header":"7.6. Recursive Definitions","id":"/Definitions/Recursive-Definitions/#recursive-definitions"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations":{"contents":"One form of do item is a term.\n\nTerms in do-Notation\n\nA term followed by a sequence of items is translated to a use of bind; in particular, do e1; es is translated to e1 >>= fun () => do es.\n\n* do Item* Desugaring\n* do\ne1\nes\n* e1 >>= fun () => do es\n\n\n\n\nThe result of the term's computation may also be named, allowing it to be used in subsequent steps.\nThis is done using let.\n\n\n\nData Dependence in do-NotationThere are two forms of monadic let-binding in a do block.\nThe first binds an identifier to the result, with an optional type annotation:The second binds a pattern to the result.\nThe fallback clause, beginning with |, specifies the behavior when the pattern does not match the result.\n\nThis syntax is also translated to a use of bind.\ndo let x ← e1; es is translated to e1 >>= fun x => do es, and fallback clauses are translated to default pattern matches.\nlet may also be used with the standard definition syntax := instead of ←.\nThis indicates a pure, rather than monadic, definition:\n\nLocal Definitions in do-Notation\n\ndo let x := e; es is translated to let x := e; do es.\n\n* do Item* Desugaring\n* do\nlet x ← e1\nes\n* e1 >>= fun x =>\n  do es\n* do\nlet some x ← e1?\n  | fallback\nes\n* e1? >>= fun\n  | some x => do\n    es\n  | _ => fallback\n* do\nlet x := e\nes\n* let x := e\ndo es\n\n\n\n\nWithin a do block, ← may be used as a prefix operator.\nThe expression to which it is applied is replaced with a fresh variable, which is bound using bind just before the current step.\nThis allows monadic effects to be used in positions that otherwise might expect a pure value, while still maintaining the distinction between describing an effectful computation and actually executing its effects.\nMultiple occurrences of ← are processed from left to right, inside to outside.\n\nExample Nested Action Desugarings* Example do Item* Desugaring\n* do\nf (← e1) (← e2)\nes\n* do\nlet x ← e1\nlet y ← e2\nf x y\nes\n* do\nlet x := g (← h (← e1))\nes\n* do\nlet y ← e1\nlet z ← h y\nlet x := g z\nes\n\n\n\n\nIn addition to convenient support for sequential computations with data dependencies, do-notation also supports the local addition of a variety of effects, including early return, local mutable state, and loops with early termination.\nThese effects are implemented via transformations of the entire do block in a manner akin to monad transformers, rather than via a local desugaring.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.1. Sequential Computations","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations"},"/releases/v4.18.0/#release-v4___18___0":{"contents":"For this release, 344 changes landed. In addition to the 166 feature additions and 38 fixes listed below there were 13 refactoring changes, 10 documentation improvements, 3 performance improvements, 4 improvements to the test suite and 109 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.18.0 (2025-04-02)","id":"/releases/v4.18.0/#release-v4___18___0"},"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Pretty-Printing":{"contents":"* #8391 adds an unexpander for Vector.mk that unexpands Vector.mk #[...] _ to #v[...].-- previously:\n#check #v[1, 2, 3] -- { toArray := #[1, 2, 3], size_toArray := ⋯ } : Vector Nat 3\n-- now:\n#check #v[1, 2, 3] -- #v[1, 2, 3] : Vector Nat 3\n* #9475 fixes the way some syntaxes are pretty printed due to missing\nwhitespace advice.* #9494 fixes an issue that caused some error messages to attempt to\ndisplay hovers for nonexistent identifiers.* #9555 allows hints in message data to specify custom preview spans\nthat extend beyond the edit region specified by the code action.* #9778 modifies the pretty printing of anonymous metavariables to use\nthe index rather than the internal name. This leads to smaller numerical\nsuffixes in ?m.123 since the indices are numbered within a given\nmetavariable context rather than across an entire file, hence each\ncommand gets its own numbering. This does not yet affect pretty printing\nof universe level metavariables.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.23.0 (2025-09-15)","header":"Pretty Printing","id":"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Pretty-Printing"}});