window.docContents[71].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Comparisons":{"contents":"Checks whether two floating-point numbers are equal according to IEEE 754.Floating-point equality does not correspond with propositional equality. In particular, it is not\nreflexive since NaN != NaN, and it is not a congruence because 0.0 == -0.0, but\n1.0 / 0.0 != 1.0 / -0.0.This function does not reduce in the kernel. It is compiled to the C equality operator.\n\nChecks whether two floating-point numbers are equal according to IEEE 754.Floating-point equality does not correspond with propositional equality. In particular, it is not\nreflexive since NaN != NaN, and it is not a congruence because 0.0 == -0.0, but\n1.0 / 0.0 != 1.0 / -0.0.This function does not reduce in the kernel. It is compiled to the C equality operator.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"19.6.2.4. Comparisons","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Comparisons"},"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Inhabited":{"contents":"The Inhabited definitions for Sum and PSum are not registered as instances.\nThis is because there are two separate ways to construct a default value (via inl or inr), and instance synthesis might result in either choice.\nThe result could be situations where two identically-written terms elaborate differently and are not definitionally equal.\n\nBoth types have Nonempty instances, for which proof irrelevance makes the choice of inl or inr not matter.\nThis is enough to enable partial functions.\nFor situations that require an Inhabited instance, such as programs that use panic!, the instance can be explicitly used by adding it to the local context with have or let.\n\nInhabited Sum TypesIn Lean's logic, panic! is equivalent to the default value specified in its type's Inhabited instance.\nThis means that the type must have such an instance—a Nonempty instance combined with the axiom of choice would render the program non-computable.Products have the right instance:example : Nat × String := panic! \"Cant' find it\"\nSums do not, by default:example : Nat ⊕ String := panic! \"Cant' find it\"\nfailed to synthesize\n  Inhabited (Nat ⊕ String)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nThe desired instance can be made available to instance synthesis using have:example : Nat ⊕ String :=\n  have : Inhabited (Nat ⊕ String) := Sum.inhabitedLeft\n  panic! \"Cant' find it\"\n\n\nIf the left type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\nIf the right type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\nIf the left type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\nIf the right type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\n","context":"Lean Reference\u0009Basic Types\u0009Sum Types\u0009API Reference","header":"19.14.2.4. Inhabited","id":"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Inhabited"},"/Notations-and-Macros/Macros/#macro-exceptions":{"contents":"The unsupportedSyntax exception is used for control flow during macro expansion.\nIt indicates that the current macro is incapable of expanding the received syntax, but that an error has not occurred.\nThe exceptions thrown by throwError and throwErrorAt terminate macro expansion, reporting the error to the user.\n\nThrow an unsupportedSyntax exception.\n\nAn unsupported syntax exception. We keep this separate because it is\nused for control flow: if one macro does not support a syntax then we try\nthe next one.\n\nThrow an error with the given message,\nusing the ref for the location information.\n\nThrow an error with the given message and location information.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009The Macro Monad","header":"20.5.2.1. Exceptions and Errors","id":"/Notations-and-Macros/Macros/#macro-exceptions"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-search":{"contents":"The library search tactics are intended for interactive use.\nWhen run, they search the Lean library for lemmas or rewrite rules that could be applicable in the current situation, and suggests a new tactic.\nThese tactics should not be left in a proof; rather, their suggestions should be incorporated.\n\nSearches environment for definitions or theorems that can solve the goal using exact\nwith conditions resolved by solve_by_elim.The optional using clause provides identifiers in the local context that must be\nused by exact? when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n\nSearches environment for definitions or theorems that can refine the goal using apply\nwith conditions resolved when possible with solve_by_elim.The optional using clause provides identifiers in the local context that must be\nused when closing the goal.\n\nIn this proof state:i j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ i < k\ninvoking apply? suggests:Try this:\n  [apply] exact Nat.lt_trans h1 h2\n\n\nrw? tries to find a lemma which can rewrite the goal.rw? should not be left in proofs; it is a search tool, like apply?.Suggestions are printed as rw [h] or rw [← h].You can use rw? [-my_lemma, -my_theorem] to prevent rw? using the named lemmas.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.15. Library Search","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-search"},"/Terms/Proofs/#The-Lean-Language-Reference--Terms--Proofs":{"contents":"The syntax for invoking tactics (by) is described in the section on proofs.\n\n\n","context":"Lean Reference\u0009Terms","header":"10.13. Proofs","id":"/Terms/Proofs/#The-Lean-Language-Reference--Terms--Proofs"},"/Terms/do--Notation/#The-Lean-Language-Reference--Terms--do--Notation":{"contents":"do-notation is described in the chapter on monads.\n\n","context":"Lean Reference\u0009Terms","header":"10.12. do -Notation","id":"/Terms/do--Notation/#The-Lean-Language-Reference--Terms--do--Notation"},"/The--grind--tactic/E___matching/#The-Lean-Language-Reference--The--grind--tactic--E___matching--Inspecting-Patterns":{"contents":"The grind? attribute is a version of the grind attribute that additionally displays the generated pattern or multi-pattern.\nPatterns and multi-patterns are displayed as lists of subexpressions, each of which is a pattern; ordinary patters are displayed as singleton lists.\nIn these displayed patterns, the names of defined constants are printed as-is.\nWhen the theorem's parameters occur in the pattern, they are displayed using numbers rather than names.\nIn particular, they are numbered from right to left, starting at 0; this representation is referred as de Bruijn indices.\n\nInspecting PatternsIn order to use this proof that divisibility is transitive with grind, it requires E-matching patterns:theorem div_trans {n k j : Nat} : n ∣ k → k ∣ j → n ∣ j := by\n  intro ⟨d₁, p₁⟩ ⟨d₂, p₂⟩\n  exact ⟨d₁ * d₂, by rw [p₂, p₁, Nat.mul_assoc]⟩\nThe right attribute to use is @[grind →], because there should be a pattern for each premise.\nUsing @[grind? →], it is possible to see which patterns are generated:attribute [grind? →] div_trans\nThere are two:div_trans: [@Dvd.dvd `[Nat] `[Nat.instDvd] #4 #3, @Dvd.dvd `[Nat] `[Nat.instDvd] #3 #2]\nArguments are numbered from right to left, so #0 is the assumption that k ∣ j, while #4 is n.\nThus, these two patterns correspond to the terms n ∣ k and k ∣ j.\n\nThe rules for selecting patterns from subexpressions of the hypotheses and conclusion are subtle.\n\n\n\nForward Pattern Generationaxiom p : Nat → Nat\naxiom q : Nat → Nat\n@[grind!? →] theorem h₁ (w : 7 = p (q x)) : p (x + 1) = q x := sorry\nh₁: [q #1]\nThe pattern is q x.\nCounting from the right, parameter #0 is the premise w and parameter #1 is the implicit parameter x.Why did @[grind →]? select q #1?\nThe attribute @[grind →] finds patterns by traversing the hypotheses (that is, parameters whose types are propositions) from left to right.\nIn this case, there's only a single hypothesis: 7 = p (q x).\nThe heuristic described above says that grind will search for a minimal indexable subexpression which covers a previously uncovered parameter.\nThere's just one uncovered parameter, namely x.\nThe whole hypothesis p (q x) = 7 can't be used because grind will not index on equality.\nThe right-hand side 7 is not helpful, because it doesn't determine the value of x.\np (q x) is not suitable because it is not minimal: it has q x inside of it, which is indexable (its head is the constant q), and it determines the value of x.\nThe expression q x itself is minimal, because x is not indexable.\nThus, q x is selected as the pattern.\n\nBackward Pattern GenerationIn this example, the ← modifier indicates that the pattern should be found in the conclusion:set_option trace.grind.debug.ematch.pattern true in\n@[grind? ←] theorem h₂ (w : 7 = p (q x)) : p (x + 1) = q x := sorry\nThe left side of the equality is used because Eq is not indexable and HAdd.hAdd has lower priority than p.h₂: [p (#1 + 1)]\n\n\nBidirectional Equality Pattern GenerationIn this example, two separate E-matching patterns are generated from the equality conclusion.\nOne matches the left-hand side, and the other matches the right-hand side.@[grind? _=_] theorem h₃ (w : 7 = p (q x)) : p (x + 1) = q x := sorry\nh₃: [q #1]\nThe entire left side of the equality is used instead of just x + 1 because HAdd.hAdd has lower priority than p.h₃: [p (#1 + 1)]\n\n\nPatterns from Conclusion and HypothesesWithout any modifiers, @[grind] produces a multipattern by first checking the conclusion and then the premises:@[grind? .] theorem h₄ (w : p x = q y) : p (x + 2) = 7 := sorry\nHere, argument x is #2, y is #1, and w is #0.\nThe resulting multipattern contains the left-hand side of the equality, which is the only minimal indexable subexpression of the conclusion that covers an argument (namely x).\nIt also contains q y, which is the only minimal indexable subexpression of the hypothesis w that covers an additional argument (namely y).h₄: [p (#2 + 2), q #1]\n\n\nFailing Backward Pattern GenerationIn this example, pattern generation fails because the theorem's conclusion doesn't mention the the argument y.@[grind? ←] theorem h₅ (w : p x = q y) : p (x + 2) = 7 := sorry\n`@[grind ←] theorem h₅` failed to find patterns in the theorem's conclusion, consider using different options or the `grind_pattern` command\n\n\nLeft-to-Right GenerationIn this example, the pattern is generated by traversing the premises from left to right, followed by the conclusion:@[grind? =>] theorem h₆\n    (_ : q (y + 2) = q y)\n    (_ : q (y + 1) = q y) :\n    p (x + 2) = 7 :=\n  sorry\nIn the patterns, y is argument #3 and x is argument #2, because automatic implicit parameters are inserted from left to right and y occurs before x in the theorem statement.\nThe premises are arguments #1 and #0.\nIn the resulting multipattern, y is covered by a subexpression of the first premise, and z is covered by a subexpression of the conclusion:h₆: [q (#3 + 2), p (#2 + 2)]\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009E‑matching","header":"17.6.2. Inspecting Patterns","id":"/The--grind--tactic/E___matching/#The-Lean-Language-Reference--The--grind--tactic--E___matching--Inspecting-Patterns"},"/Type-Classes/Basic-Classes/#basic-classes":{"contents":"Many Lean type classes exist in order to allow built-in notations such as addition or array indexing to be overloaded.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"11.5. Basic Classes","id":"/Type-Classes/Basic-Classes/#basic-classes"}});