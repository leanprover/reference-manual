window.docContents[179].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Arithmetic":{"contents":"Typically, arithmetic operations on Fin should be accessed using Lean's overloaded arithmetic notation, particularly via the instances Add (Fin n), Sub (Fin n), Mul (Fin n), Div (Fin n),  and Mod (Fin n).\nHeterogeneous operators such as Fin.natAdd do not have corresponding heterogeneous instances (e.g. HAdd) to avoid confusing type inference behavior.\n\nAddition modulo n, usually invoked via the + operator.Examples:* (2 : Fin 8) + (2 : Fin 8) = (4 : Fin 8)* (2 : Fin 3) + (2 : Fin 3) = (1 : Fin 3)\n\nAdds a natural number to a Fin, increasing the bound.This is a generalization of Fin.succ.Fin.addNat is a version of this function that takes its Nat parameter second.Examples:* Fin.natAdd 3 (5 : Fin 8) = (8 : Fin 11)* Fin.natAdd 1 (0 : Fin 8) = (1 : Fin 9)* Fin.natAdd 1 (2 : Fin 8) = (3 : Fin 9)\n\nAdds a natural number to a Fin, increasing the bound.This is a generalization of Fin.succ.Fin.natAdd is a version of this function that takes its Nat parameter first.Examples:* Fin.addNat (5 : Fin 8) 3 = (8 : Fin 11)* Fin.addNat (0 : Fin 8) 1 = (1 : Fin 9)* Fin.addNat (1 : Fin 8) 2 = (3 : Fin 10)\n\nMultiplication modulo n, usually invoked via the * operator.Examples:* (2 : Fin 10) * (2 : Fin 10) = (4 : Fin 10)* (2 : Fin 10) * (7 : Fin 10) = (4 : Fin 10)* (3 : Fin 10) * (7 : Fin 10) = (1 : Fin 10)\n\nSubtraction modulo n, usually invoked via the - operator.Examples:* (5 : Fin 11) - (3 : Fin 11) = (2 : Fin 11)* (3 : Fin 11) - (5 : Fin 11) = (9 : Fin 11)\n\nSubtraction of a natural number from a Fin, with the bound narrowed.This is a generalization of Fin.pred. It is guaranteed to not underflow or wrap around.Examples:* (5 : Fin 9).subNat 2 (by decide) = (3 : Fin 7)* (5 : Fin 9).subNat 0 (by decide) = (5 : Fin 9)* (3 : Fin 9).subNat 3 (by decide) = (0 : Fin 6)\n\nDivision of bounded numbers, usually invoked via the / operator.The resulting value is that computed by the / operator on Nat. In particular, the result of\ndivision by 0 is 0.Examples:* (5 : Fin 10) / (2 : Fin 10) = (2 : Fin 10)* (5 : Fin 10) / (0 : Fin 10) = (0 : Fin 10)* (5 : Fin 10) / (7 : Fin 10) = (0 : Fin 10)\n\nModulus of bounded numbers, usually invoked via the % operator.The resulting value is that computed by the % operator on Nat.\n\nModulus of bounded numbers with respect to a Nat.The resulting value is that computed by the % operator on Nat.\n\nLogarithm base 2 for bounded numbers.The resulting value is the same as that computed by Nat.log2. In particular, the result for 0 is\n0.Examples:* (8 : Fin 10).log2 = (3 : Fin 10)* (7 : Fin 10).log2 = (2 : Fin 10)* (4 : Fin 10).log2 = (2 : Fin 10)* (3 : Fin 10).log2 = (1 : Fin 10)* (1 : Fin 10).log2 = (0 : Fin 10)* (0 : Fin 10).log2 = (0 : Fin 10)\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"19.3.3.2. Arithmetic","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Arithmetic"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion--Unbundled-Variants":{"contents":"Unbundled sets separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the module Std.TreeSet.Raw.\n\nTree sets without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer TreeSet\nover TreeSet.Raw. Lemmas about the operations on Std.TreeSet.Raw are available in the\nmodule Std.Data.TreeSet.Raw.Lemmas.A tree set stores elements of a certain type in a certain order. It depends on a comparator function\nthat defines an ordering on the keys and provides efficient order-dependent queries, such as\nretrieval of the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e only one of them\ncan be contained in a single tree set at the same time.To avoid expensive copies, users should make sure that the tree set is used linearly.Internally, the tree sets are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.Internal implementation detail of the tree set.\n\nWell-formedness predicate for tree sets. Users of TreeSet will not need to interact with\nthis. Users of TreeSet.Raw will need to provide proofs of WF to lemmas and should use lemmas\nlike WF.empty and WF.insert (which are always named exactly like the operations they are about)\nto show that set operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.Internal implementation detail of the tree map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets\u0009Conversion","header":"19.18.10.6.1. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion--Unbundled-Variants"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax":{"contents":"Lean supports programming with functors, applicative functors, and monads via special syntax:\n\n* Infix operators are provided for the most common operations.* An embedded language called do-notation allows the use of imperative syntax when writing programs in a monad.\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation","header":"14.3. Syntax","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads":{"contents":"Monads are primarily used via do-notation.\nHowever, it can sometimes be convenient to describe monadic computations via operators.\n\n\n\nMonad Operatorsact >>= f is syntax for Bind.bind act f.Similarly, the reversed operator f =<< act is syntax for Bind.bind act f.The Kleisli composition operators Bind.kleisliRight and Bind.kleisliLeft also have infix operators.\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009Infix Operators","header":"14.3.1.3. Monads","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads"}});