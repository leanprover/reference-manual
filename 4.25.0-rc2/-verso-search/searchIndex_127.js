window.docContents[127].resolve({"/Interacting-with-Lean/#format-api":{"contents":"A representation of a set of strings, in which the placement of newlines and indentation differ.Given a specific line width, specified in columns, the string that uses the fewest lines can be\nselected.The pretty-printing algorithm is based on Wadler's paper\nA Prettier Printer.The empty format.A position where a newline may be inserted if the current group does not fit within the allotted\ncolumn width.align tells the formatter to pad with spaces to the current indentation level, or else add a\nnewline if we are already at or past the indent.If force is true, then it will pad to the indent even if it is in a flattened group.Example:open Std Format in\n#eval IO.println (nest 2 <| \".\" ++ align ++ \"a\" ++ line ++ \"b\")\n. a\n  b\nA node containing a plain string.If the string contains newlines, the formatter emits them and then indents to the current level.nest indent f increases the current indentation level by indent while rendering f.Example:open Std Format in\ndef fmtList (l : List Format) : Format :=\n  let f := joinSep l  (\", \" ++ Format.line)\n  group (nest 1 <| \"[\" ++ f ++ \"]\")\nThis will be written all on one line, but if the text is too large, the formatter will put in\nlinebreaks after the commas and indent later lines by 1.Concatenation of two Formats.Creates a new flattening group for the given inner Format.Used for associating auxiliary information (e.g. Exprs) with Format objects.\n\nDetermines how groups should have linebreaks inserted when the text would overfill its remaining\nspace.* allOrNone will make a linebreak on every Format.line in the group or none of them.[1,\n 2,\n 3]\n* fill will only make linebreaks on as few Format.lines as possible:[1, 2,\n 3]\nEither all Format.lines in the group will be newlines, or all of them will be spaces.As few Format.lines in the group as possible will be newlines.\n\nCreates a group in which as few Format.lines as possible are rendered as newlines.This is an alias for Format.group, with FlattenBehavior set to fill.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.1. Documents","id":"/Interacting-with-Lean/#format-api"},"/Run-Time-Code/Foreign-Function-Interface/#ffi-borrowing":{"contents":"By default, all lean_object * parameters of an extern function are considered owned.\nThe external code is passed a “virtual RC token” and is responsible for passing this token along to another consuming function (exactly once) or freeing it via lean_dec.\nTo reduce reference counting overhead, parameters can be marked as borrowed by prefixing their type with @&.\nBorrowed objects must only be passed to other non-consuming functions (arbitrarily often) or converted to owned values using lean_inc.\nIn lean.h, the lean_object * aliases lean_obj_arg and b_lean_obj_arg are used to mark this difference on the C side.\nReturn values and @[export] parameters are always owned at the moment.\n\nBorrowed ParametersParameters may be marked as borrowed by prefixing their types with @&.\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Foreign Function Interface\u0009The Lean ABI","header":"21.4.1.2. Borrowing","id":"/Run-Time-Code/Foreign-Function-Interface/#ffi-borrowing"},"/The-Type-System/Inductive-Types/#inductive-types-runtime-relevance":{"contents":"Types and proofs have no run-time representation.\nThat is, if an inductive type is a Prop, then its values are erased prior to compilation.\nSimilarly, all theorem statements and types are erased.\nTypes with run-time representations are called relevant, while types without run-time representations are called irrelevant.\n\nTypes are irrelevantEven though List.cons has the following signature, which indicates three parameters:List.cons.{u} {α : Type u} : α → List α → List α\nits run-time representation has only two, because the type argument is run-time irrelevant.\n\nProofs are irrelevantEven though Fin.mk has the following signature, which indicates three parameters:Fin.mk {n : Nat} (val : Nat) : val < n → Fin n\nits run-time representation has only two, because the proof is erased.\n\nIn most cases, irrelevant values simply disappear from compiled code.\nHowever, in cases where some representation is required (such as when they are arguments to polymorphic constructors), they are represented by a trivial value.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation","header":"4.4.4.2. Relevance","id":"/The-Type-System/Inductive-Types/#inductive-types-runtime-relevance"}});