window.docContents[5].resolve({"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks":{"contents":"In addition to the types and operations described in this section, IO.Ref can be used as a lock.\nTaking the reference (using take) causes other threads to block when reading until the reference is set again.\nThis pattern is described in the section on reference cells.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads","header":"15.11.6. Communication Between Tasks","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks"},"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-mbtc":{"contents":"The solver also implements model-based theory combination, which is a mechanism for propagating equalities back to the metaphorical shared whiteboard.\nThese additional equalities may in turn trigger new congruences.\nModel-based theory combination increases the size of the search space; it can be disabled using the option grind -mbtc.\n\nPropagating EqualitiesIn the example above, the linear inequalities and disequalities imply y = 0:example (f : Int → Int) (x y : Int) :\n    f x = 0 →\n    0 ≤ y → y ≤ 1 → y ≠ 1 →\n    f (x + y) = 0 := by\n  grind\nConsequently x = x + y, so f x = f (x + y) by congruence.\nWithout model-based theory combination, the proof gets stuck:example (f : Int → Int) (x y : Int) :\n    f x = 0 →\n    0 ≤ y → y ≤ 1 → y ≠ 1 →\n    f (x + y) = 0 := by\n  grind -mbtc\n`grind` failed\ncase grind\nf : Int → Int\nx y : Int\nh : f x = 0\nh_1 : -1 * y ≤ 0\nh_2 : y + -1 ≤ 0\nh_3 : ¬y = 1\nh_4 : ¬f (x + y) = 0\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n  [eqc] False propositions\n  [eqc] Equivalence classes\n  [cutsat] Assignment satisfying linear constraints\n  [ring] Ring `Int`\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.5. Propagating Information","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-mbtc"},"/The-Type-System/Inductive-Types/#prop-vs-type":{"contents":"Lean rejects universe-polymorphic types that could not, in practice, be used polymorphically.\nThis could arise if certain instantiations of the universe parameters would cause the type itself to be a Prop.\nIf this type is not a subsingleton, then its recursor can only target propositions (that is, the motive must return a Prop).\nThese types only really make sense as Props themselves, so the universe polymorphism is probably a mistake.\nBecause they are largely useless, Lean's inductive type elaborator has not been designed to support these types.\n\nWhen such universe-polymorphic inductive types are indeed subsingletons, it can make sense to define them.\nLean's standard library defines PUnit and PEmpty.\nTo define a subsingleton that can inhabit Prop or a Type, set the option bootstrap.inductiveCheckResultingUniverse to false.\n\nby default the inductive/structure commands report an error if the resulting universe is not zero, but may be zero for some universe parameters. Reason: unless this type is a subsingleton, it is hardly what the user wants since it can only eliminate into Prop. In the Init package, we define subsingletons, and we use this option to disable the check. This option may be deleted in the future after we improve the validator\n\nOverly-universe-polymorphic BoolDefining a version of Bool that can be in any universe is not allowed:inductive PBool : Sort u where\n  | true\n  | false\nInvalid universe polymorphic resulting type: The resulting universe is not `Prop`, but it may be `Prop` for some parameter values:\n  Sort u\n\nHint: A possible solution is to use levels of the form `max 1 _` or `_ + 1` to ensure the universe is of the form `Type _`\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Well-Formedness Requirements","header":"4.4.3.2.3. Prop vs Type","id":"/The-Type-System/Inductive-Types/#prop-vs-type"}});