window.docContents[220].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-Other-Fixed-Width-Integers":{"contents":"Converts word-sized unsigned integers to 8-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts word-sized unsigned integers to 16-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts word-sized unsigned integers to 32-bit unsigned integers. Wraps around on overflow, which\nmight occur on 64-bit architectures.This function is overridden at runtime with an efficient implementation.\n\nConverts word-sized unsigned integers to 32-bit unsigned integers. This cannot overflow because\nUSize.size is either 2^32 or 2^64.This function is overridden at runtime with an efficient implementation.\n\nObtains the ISize that is 2's complement equivalent to the USize.\n\nObtains the Int8 that is 2's complement equivalent to the UInt8.\n\nConverts 8-bit unsigned integers to 16-bit unsigned integers.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit unsigned integers to 32-bit unsigned integers.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit unsigned integers to 64-bit unsigned integers.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit unsigned integers to word-sized unsigned integers.This function is overridden at runtime with an efficient implementation.\n\nConverts 16-bit unsigned integers to 8-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nObtains the Int16 that is 2's complement equivalent to the UInt16.\n\nConverts 16-bit unsigned integers to 32-bit unsigned integers.This function is overridden at runtime with an efficient implementation.\n\nConverts 16-bit unsigned integers to 64-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts 16-bit unsigned integers to word-sized unsigned integers.This function is overridden at runtime with an efficient implementation.\n\nConverts a 32-bit unsigned integer to an 8-bit unsigned integer, wrapping on overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts 32-bit unsigned integers to 16-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nObtains the Int32 that is 2's complement equivalent to the UInt32.\n\nConverts 32-bit unsigned integers to 64-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts 32-bit unsigned integers to word-sized unsigned integers.This function is overridden at runtime with an efficient implementation.\n\nConverts 64-bit unsigned integers to 8-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts 64-bit unsigned integers to 16-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nConverts 64-bit unsigned integers to 32-bit unsigned integers. Wraps around on overflow.This function is overridden at runtime with an efficient implementation.\n\nObtains the Int64 that is 2's complement equivalent to the UInt64.\n\nConverts 64-bit unsigned integers to word-sized unsigned integers. On 32-bit machines, this may\noverflow, which results in the value wrapping around (that is, it is reduced modulo USize.size).This function is overridden at runtime with an efficient implementation.\n\nConverts a word-sized signed integer to an 8-bit signed integer by truncating its bitvector representation.This function is overridden at runtime with an efficient implementation.\n\nConverts a word-sized integer to a 16-bit integer by truncating its bitvector representation.This function is overridden at runtime with an efficient implementation.\n\nConverts a word-sized signed integer to a 32-bit signed integer.On 32-bit platforms, this conversion is lossless. On 64-bit platforms, the integer's bitvector\nrepresentation is truncated to 32 bits. This function is overridden at runtime with an efficient\nimplementation.This function is overridden at runtime with an efficient implementation.\n\nConverts word-sized signed integers to 64-bit signed integers that denote the same number. This\nconversion is lossless, because ISize is either Int32 or Int64.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit signed integers to 16-bit signed integers that denote the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit signed integers to 32-bit signed integers that denote the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit signed integers to 64-bit signed integers that denote the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit signed integers to word-sized signed integers that denote the same number. This\nconversion is lossless, because ISize is either Int32 or Int64.This function is overridden at runtime with an efficient implementation.\n\nConverts 16-bit signed integers to 8-bit signed integers by truncating their bitvector\nrepresentation.This function is overridden at runtime with an efficient implementation.\n\nConverts 8-bit signed integers to 32-bit signed integers that denote the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts 16-bit signed integers to 64-bit signed integers that denote the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts 16-bit signed integers to word-sized signed integers that denote the same number. This conversion is lossless, because\nISize is either Int32 or Int64.This function is overridden at runtime with an efficient implementation.\n\nConverts a 32-bit signed integer to an 8-bit signed integer by truncating its bitvector\nrepresentation.This function is overridden at runtime with an efficient implementation.\n\nConverts a 32-bit signed integer to an 16-bit signed integer by truncating its bitvector\nrepresentation.This function is overridden at runtime with an efficient implementation.\n\nConverts 32-bit signed integers to 64-bit signed integers that denote the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts 32-bit signed integers to word-sized signed integers that denote the same number. This\nconversion is lossless, because ISize is either Int32 or Int64.This function is overridden at runtime with an efficient implementation.\n\nConverts a 64-bit signed integer to an 8-bit signed integer by truncating its bitvector\nrepresentation.This function is overridden at runtime with an efficient implementation.\n\nConverts a 64-bit signed integer to a 16-bit signed integer by truncating its bitvector\nrepresentation.This function is overridden at runtime with an efficient implementation.\n\nConverts a 64-bit signed integer to a 32-bit signed integer by truncating its bitvector\nrepresentation.This function is overridden at runtime with an efficient implementation.\n\nConverts 64-bit signed integers to word-sized signed integers, truncating the bitvector\nrepresentation on 32-bit platforms. This conversion is lossless on 64-bit platforms.This function is overridden at runtime with an efficient implementation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","header":"19.4.4.3.3. To Other Fixed-Width Integers","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-Other-Fixed-Width-Integers"},"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model--Signed":{"contents":"Signed integers that are the size of a word on the platform's architecture.On a 32-bit architecture, ISize is equivalent to Int32. On a 64-bit machine, it is equivalent to\nInt64. This type has special support in the compiler so it can be represented by an unboxed value.Converts a word-sized signed integer into the word-sized unsigned integer that is its two's\ncomplement encoding.\n\nSigned 8-bit integers.This type has special support in the compiler so it can be represented by an unboxed 8-bit value.Converts an 8-bit signed integer into the 8-bit unsigned integer that is its two's complement\nencoding.\n\nSigned 16-bit integers.This type has special support in the compiler so it can be represented by an unboxed 16-bit value.Converts an 16-bit signed integer into the 16-bit unsigned integer that is its two's complement\nencoding.\n\nSigned 32-bit integers.This type has special support in the compiler so it can be represented by an unboxed 32-bit value.Converts an 32-bit signed integer into the 32-bit unsigned integer that is its two's complement\nencoding.\n\nSigned 64-bit integers.This type has special support in the compiler so it can be represented by an unboxed 64-bit value.Converts an 64-bit signed integer into the 64-bit unsigned integer that is its two's complement\nencoding.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009Logical Model","header":"19.4.1.2. Signed","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model--Signed"},"/IO/Control-Structures/#io-monad-control":{"contents":"Normally, programs written in IO use the same control structures as those written in other monads.\nThere is one specific IO helper.\n\nIterates an IO action. Starting with an initial state, the action is applied repeatedly until it\nreturns a final value in Sum.inr. Each time it returns Sum.inl, the returned value is treated as\na new state.\n\n","context":"Lean Reference\u0009IO","header":"15.2. Control Structures","id":"/IO/Control-Structures/#io-monad-control"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-false":{"contents":"exfalso converts a goal ⊢ tgt into ⊢ False by applying False.elim.\n\ncontradiction closes the main goal if its hypotheses are \"trivially contradictory\".* Inductive type/family with no applicable constructorsexample (h : False) : p := by contradiction\n* Injectivity of constructorsexample (h : none = some true) : p := by contradiction  --\n* Decidable false propositionexample (h : 2 + 2 = 3) : p := by contradiction\n* Contradictory hypothesesexample (h : p) (h' : ¬ p) : q := by contradiction\n* Other simple contradictions such asexample (x : Nat) (h : x ≠ x) : p := by contradiction\n\n\nChanges the goal to False, retaining as much information as possible:* If the goal is False, do nothing.* If the goal is an implication or a function type, introduce the argument and restart.\n(In particular, if the goal is x ≠ y, introduce x = y.)* Otherwise, for a propositional goal P, replace it with ¬ ¬ P\n(attempting to find a Decidable instance, but otherwise falling back to working classically)\nand introduce ¬ P.* For a non-propositional goal use False.elim.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.7. Falsehood","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-false"}});