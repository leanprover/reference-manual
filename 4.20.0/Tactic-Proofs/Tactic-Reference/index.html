<!DOCTYPE html>
<html>
  <head>
<meta name="robots" content="noindex">
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Tactic Reference</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "âŽ";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    <script defer="defer" data-domain="lean-lang.org/doc/reference/latest" src="https://plausible.io/js/script.outbound-links.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="current numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-tactics" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-tactics" checked="checked"></label><span class="number">13.</span>Â <span class=""><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></span></div>
              <table><tr class="numbered"><td class="num">13.1.</td><td><a href="Tactic-Proofs/Running-Tactics/#by">Running Tactics</a></td></tr><tr class="numbered"><td class="num">13.2.</td><td><a href="Tactic-Proofs/Reading-Proof-States/#proof-states">Reading Proof States</a></td></tr><tr class="numbered"><td class="num">13.3.</td><td><a href="Tactic-Proofs/The-Tactic-Language/#tactic-language">The Tactic Language</a></td></tr><tr class="numbered"><td class="num">13.4.</td><td><a href="Tactic-Proofs/Options/#tactic-language-options">Options</a></td></tr><tr class="current numbered"><td class="num">13.5.</td><td><a href="Tactic-Proofs/Tactic-Reference/#tactic-ref">Tactic Reference</a></td></tr><tr class="numbered"><td class="num">13.6.</td><td><a href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv">Targeted Rewriting with <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-next"><span class="keyword token" data-binding="" data-verso-hover="0">conv</span></a></code></a></td></tr><tr class="numbered"><td class="num">13.7.</td><td><a href="Tactic-Proofs/Naming-Bound-Variables/#bound-variable-name-hints">Naming Bound Variables</a></td></tr><tr class="numbered"><td class="num">13.8.</td><td><a href="Tactic-Proofs/Custom-Tactics/#custom-tactics">Custom Tactics</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-tactic-ref" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-tactic-ref" checked="checked"></label><span class="number">13.5.</span>Â <span class="current"><a href="Tactic-Proofs/Tactic-Reference/#tactic-ref">Tactic Reference</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-classical">Classical Logic</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#classical"><code class="tactic-name">classical</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-assumptions">Assumptions</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#assumption"><code class="tactic-name">assumption</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><code class="tactic-name">apply_assumption</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers">Quantifiers</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exists"><code class="tactic-name">exists</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#intro"><code class="tactic-name">intro</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#intros"><code class="tactic-name">intros</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#intro-___-_________-____GT_-_________-___-_________-____GT_-_________"><code class="tactic-name">intro | ... =&gt; ... | ... =&gt; ...</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rintro"><code class="tactic-name">rintro</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-relations">Relations</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rfl"><code class="tactic-name">rfl</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rfl___"><code class="tactic-name">rfl'</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_rfl"><code class="tactic-name">apply_rfl</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next"><span class="syntax"><span class="keyword">refl</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#symm"><code class="tactic-name">symm</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#symm_saturate"><code class="tactic-name">symm_saturate</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">symm</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#calc"><code class="tactic-name">calc</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Trans___mk"><code>Trans</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-equality">Equality</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#subst"><code class="tactic-name">subst</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#subst_eqs"><code class="tactic-name">subst_eqs</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#subst_vars"><code class="tactic-name">subst_vars</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#congr"><code class="tactic-name">congr</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#eq_refl"><code class="tactic-name">eq_refl</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ac_rfl"><code class="tactic-name">ac_rfl</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-associativity-commutativity">Associativity and Commutativity</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><code class="tactic-name">ac_nf</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ac_nf0"><code class="tactic-name">ac_nf0</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">6.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-lemmas">Lemmas</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exact"><code class="tactic-name">exact</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply"><code class="tactic-name">apply</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#refine"><code class="tactic-name">refine</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#refine___"><code class="tactic-name">refine'</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><code class="tactic-name">solve_by_elim</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><code class="tactic-name">apply_rules</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#as_aux_lemma"><code class="tactic-name">as_aux_lemma</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">7.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-false">Falsehood</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exfalso"><code class="tactic-name">exfalso</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#contradiction"><code class="tactic-name">contradiction</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#false_or_by_contra"><code class="tactic-name">false_or_by_contra</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">8.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-goals">Goal Management</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#suffices"><code class="tactic-name">suffices</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#change"><code class="tactic-name">change</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________"><code class="tactic-name">change ... with ...</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#generalize"><code class="tactic-name">generalize</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#specialize"><code class="tactic-name">specialize</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#obtain"><code class="tactic-name">obtain</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#show"><code class="tactic-name">show</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#show_term"><code class="tactic-name">show_term</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">9.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-casts">Cast Management</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><code class="tactic-name">norm_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#push_cast"><code class="tactic-name">push_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast"><code class="tactic-name">exact_mod_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast"><code class="tactic-name">apply_mod_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rw_mod_cast"><code class="tactic-name">rw_mod_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast"><code class="tactic-name">assumption_mod_cast</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">10.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-ext">Extensionality</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ext"><code class="tactic-name">ext</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ext1"><code class="tactic-name">ext1</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_ext_theorem"><code class="tactic-name">apply_ext_theorem</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#funext-next"><code class="tactic-name">funext</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">11.</span> <a href="Tactic-Proofs/Tactic-Reference/#simp-tactics">Simplification</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp"><code class="tactic-name">simp</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp___"><code class="tactic-name">simp!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><code class="tactic-name">simp?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp______"><code class="tactic-name">simp?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_arith"><code class="tactic-name">simp_arith</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_arith___"><code class="tactic-name">simp_arith!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp"><code class="tactic-name">dsimp</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp___"><code class="tactic-name">dsimp!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp___-next"><code class="tactic-name">dsimp?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp______"><code class="tactic-name">dsimp?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all"><code class="tactic-name">simp_all</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all___"><code class="tactic-name">simp_all!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all___-next"><code class="tactic-name">simp_all?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all______"><code class="tactic-name">simp_all?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith"><code class="tactic-name">simp_all_arith</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith___"><code class="tactic-name">simp_all_arith!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa"><code class="tactic-name">simpa</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa___"><code class="tactic-name">simpa!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa___-next"><code class="tactic-name">simpa?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa______"><code class="tactic-name">simpa?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_wf"><code class="tactic-name">simp_wf</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">12.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-rw">Rewriting</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rw"><code class="tactic-name">rw</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rewrite"><code class="tactic-name">rewrite</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#erw"><code class="tactic-name">erw</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rwa"><code class="tactic-name">rwa</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___Config___mk"><code>Config</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all"><code>Occurrences</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all"><code>TransparencyMode</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___NewGoals"><code>NewGoals</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#unfold"><code class="tactic-name">unfold</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#replace"><code class="tactic-name">replace</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#delta"><code class="tactic-name">delta</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">13.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive">Inductive Types</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">13.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-intro">Introduction</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#constructor"><code class="tactic-name">constructor</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#injection"><code class="tactic-name">injection</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#injections"><code class="tactic-name">injections</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#left"><code class="tactic-name">left</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#right"><code class="tactic-name">right</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">13.2.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-elim">Elimination</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">induction_eliminator</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">cases_eliminator</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#cases"><code class="tactic-name">cases</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rcases"><code class="tactic-name">rcases</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#fun_cases"><code class="tactic-name">fun_cases</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#induction"><code class="tactic-name">induction</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#fun_induction"><code class="tactic-name">fun_induction</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#nofun"><code class="tactic-name">nofun</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#nomatch"><code class="tactic-name">nomatch</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">14.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-search">Library Search</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exact___"><code class="tactic-name">exact?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply___"><code class="tactic-name">apply?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rw___"><code class="tactic-name">rw?</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">15.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-cases">Case Analysis</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#split"><code class="tactic-name">split</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#by_cases"><code class="tactic-name">by_cases</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">16.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-decision">Decision Procedures</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#decide"><code class="tactic-name">decide</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#native_decide"><code class="tactic-name">native_decide</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#omega"><code class="tactic-name">omega</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_omega"><code class="tactic-name">bv_omega</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">16.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-sat">SAT Solver Integration</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><code class="tactic-name">bv_decide</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_normalize"><code class="tactic-name">bv_normalize</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_check"><code class="tactic-name">bv_check</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_decide___"><code class="tactic-name">bv_decide?</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">17.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-reducibility">Controlling Reduction</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#with_reducible-next"><code class="tactic-name">with_reducible</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#with_reducible_and_instances-next"><code class="tactic-name">with_reducible_and_instances</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#with_unfolding_all-next"><code class="tactic-name">with_unfolding_all</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">18.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-control">Control Flow</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#skip"><code class="tactic-name">skip</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><code class="tactic-name">guard_hyp</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#guard_target"><code class="tactic-name">guard_target</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#guard_expr"><code class="tactic-name">guard_expr</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#done"><code class="tactic-name">done</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#sleep"><code class="tactic-name">sleep</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#stop"><code class="tactic-name">stop</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">19.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-term-helpers">Term Elaboration Backends</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#decreasing_with"><code class="tactic-name">decreasing_with</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic"><code class="tactic-name">get_elem_tactic</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial"><code class="tactic-name">get_elem_tactic_trivial</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">20.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-debug">Debugging Utilities</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#sorry"><code class="tactic-name">sorry</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#admit"><code class="tactic-name">admit</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dbg_trace"><code class="tactic-name">dbg_trace</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#trace_state"><code class="tactic-name">trace_state</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#trace"><code class="tactic-name">trace</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">21.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-other">Other</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#trivial"><code class="tactic-name">trivial</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#solve"><code class="tactic-name">solve</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#and_intros"><code class="tactic-name">and_intros</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#infer_instance"><code class="tactic-name">infer_instance</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#expose_names"><code class="tactic-name">expose_names</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#unhygienic"><code class="tactic-name">unhygienic</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#run_tac"><code class="tactic-name">run_tac</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Tactic-Proofs/Options/#tactic-language-options" rel="prev" title="13.4. Options"><span class="arrow">â†</span><span class="where">13.4. Options</span></a><a class="local-button active" href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv" rel="next" title="13.6. Targeted Rewriting with conv"><span class="where">13.6. Targeted Rewriting with conv</span><span class="arrow">â†’</span></a></nav>
          <section>
            <h1>
              13.5.Â Tactic Reference<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref" title="Permalink">ðŸ”—</a></span></h1>
            <section>
              <h2 id="tactic-ref-classical">
                13.5.1.Â Classical Logic<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-classical" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="classical">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.classical" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#classical"><span class="keyword token" data-binding="" data-verso-hover="2316">classical</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">classical</span> <span class="unknown token" data-binding="">tacs</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> in a scope where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Classical.propDecidable" data-verso-hover="2317">Classical.propDecidable</span></code> is a low priority
local instance.</p>
                  <p>
                    Note that <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#classical"><span class="keyword token" data-binding="" data-verso-hover="2316">classical</span></a></code> is a scoping tactic: it adds the instance only within the
scope of the tactic.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-assumptions">
                13.5.2.Â Assumptions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-assumptions" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="assumption">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.assumption" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="" data-verso-hover="1029">assumption</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">â€¹</span><span class="unknown token" data-binding="">t</span><span class="unknown token" data-binding="">â€º</span></code> term notation, which is a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-0">show</span> <span class="var token" data-binding="var-_uniq.69" data-verso-hover="296">t</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic'-7">by</span> <a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-10" data-verso-hover="1029">assumption</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_assumption">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.applyAssumption" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><span class="keyword token" data-binding="" data-verso-hover="2318">apply_assumption</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2318">apply_assumption</span></a></code> looks for an assumption of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">head</span></code>
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">head</span></code> matches the current goal.</p>
                  <p>
                    You can specify additional rules to apply using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_assumption</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code>.
By default <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2318">apply_assumption</span></a></code> will also try <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2319">trivial</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1393">congrFun</span></a></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="775">congrArg</span></a></code>.
If you don't want these, or don't want to use all hypotheses, use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_assumption</span> <span class="unknown token" data-binding="">only</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code>.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2318">apply_assumption</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code> to omit a local hypothesis.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_assumption</span> <span class="keyword token" data-binding="kw-occ-null-0">using</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">aâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> to use all lemmas which have been labelled
with the attributes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aáµ¢</span></code> (these attributes must be created using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">register_label_attr</span></code>).</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2318">apply_assumption</span></a></code> will use consequences of local hypotheses obtained via <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2320">symm</span></a></code>.</p>
                  <p>
                    If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2318">apply_assumption</span></a></code> fails, it will call <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2321">exfalso</span></a></code> and try again.
Thus if there is an assumption of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.156" data-verso-hover="2322">P</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">Â¬</span> <span class="var token" data-binding="var-_uniq.169" data-verso-hover="204">Q</span></code>, the new tactic state
will have two goals, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.156" data-verso-hover="2322">P</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.169" data-verso-hover="204">Q</span></code>.</p>
                  <p>
                    You can pass a further configuration via the syntax <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">lemmas</span></code>.
The options supported are the same as for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code> (and include all the options for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code>).</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-quantifiers">
                13.5.3.Â Quantifiers<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-quantifiers" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="exists">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.Â«tacticExists_,,Â»" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exists"><span class="keyword token" data-binding="" data-verso-hover="2324">exists</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">exists</span> <span class="unknown token" data-binding="">eâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">eâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">refine</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">eâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">eâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">âŸ©</span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-null-0">try</span> <span class="keyword token" data-binding="kw-occ-null-0">trivial</span></code>.
It is useful for existential goals.</p>
                  </div>
                </div>
              <div class="namedocs" id="intro">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.intro" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="" data-verso-hover="662">intro</span></a></pre><div class="text">
                  <p>
                    Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let-rec"><span class="keyword token" data-binding="" data-verso-hover="2299">let</span></a></code> or function type.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.201" data-verso-hover="2325">intro</span></code> by itself introduces one anonymous hypothesis, which can be accessed
by e.g. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="662">intro</span></a> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span></code> introduces two hypotheses and names them. Individual hypotheses
can be anonymized via <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>, or matched against a pattern:</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">intro</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span>
-- ..., a : Î±, b : Î² âŠ¢ ...</code></li>
                    <li>
                      <p>
                        Alternatively, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.201" data-verso-hover="2325">intro</span></code> can be combined with pattern matching much like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun</span></code>:</p>
                      <pre>intro
| n + 1, 0 =&gt; tac
| ...
</pre></li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="intros">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.intros" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="" data-verso-hover="379">intros</span></a></pre><div class="text">
                  <p>
                    Introduces zero or more hypotheses, optionally naming them.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="379">intros</span></a></code> is equivalent to repeatedly applying <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="662">intro</span></a></code>
until the goal is not an obvious candidate for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="662">intro</span></a></code>, which is to say
that so long as the goal is a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let-rec"><span class="keyword token" data-binding="" data-verso-hover="2299">let</span></a></code> or a pi type (e.g. an implication, function, or universal quantifier),
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="379">intros</span></a></code> tactic will introduce an anonymous hypothesis.
This tactic does not unfold definitions.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">intros</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">...</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">intro</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">...</span></code>,
introducing hypotheses for each supplied argument and unfolding definitions as necessary.
Each argument can be either an identifier or a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>.
An identifier indicates a name to use for the corresponding introduced hypothesis,
and a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code> indicates that the hypotheses should be introduced anonymously.</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Examples</strong></p>
                  <p>
                    Basic properties:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span> <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="897">f</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">%</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>

-- Introduces the two obvious hypotheses automatically
<span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-108">example</span></span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-164">fun</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-8032504918879244459-187-189"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-187" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8032504918879244459-187-189"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.196" data-verso-hover="897">f</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="897">f</span> â†’ <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.198" data-verso-hover="7">k</span> =&gt; <span class="var token" data-binding="var-_uniq.196" data-verso-hover="897">f</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.198" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-1817849126808732708-192-198"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-192" data-verso-hover="379">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1817849126808732708-192-198"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.190" data-verso-hover="897">fâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.191" data-verso-hover="2327">aâœ</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.190" data-verso-hover="897">fâœ</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">k</span> =&gt; <span class="var token" data-binding="var-_uniq.190" data-verso-hover="897">fâœ</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span>
  /- Tactic state
     fâœ : Nat â†’ Nat
     aâœ : AllEven fâœ
     âŠ¢ AllEven fun k =&gt; fâœ (k + 1) -/
  <span class="tactic"><label for="tactic-state-7-310-315"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-310" data-verso-hover="11">sorry</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-310-315"><span class="tactic-state">All goals completed! ðŸ™</span></span>

-- Introduces exactly two hypotheses, naming only the first
<span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-377">example</span></span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.199" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-433">fun</span> <span class="var token" data-binding="var-_uniq.206" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.206" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14809632191207359732-456-458"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-456" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14809632191207359732-456-458"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.287" data-verso-hover="897">f</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.287" data-verso-hover="897">f</span> â†’ <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.289" data-verso-hover="7">k</span> =&gt; <span class="var token" data-binding="var-_uniq.287" data-verso-hover="897">f</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.289" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-4002303998941722555-461-471"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-461" data-verso-hover="379">intros</span></a> <span class="var token" data-binding="var-_uniq.281" data-verso-hover="897">g</span> <span class="unknown token" data-binding="">_</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4002303998941722555-461-471"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.281" data-verso-hover="897">g</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.282" data-verso-hover="2328">aâœ</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.281" data-verso-hover="897">g</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.286" data-verso-hover="7">k</span> =&gt; <span class="var token" data-binding="var-_uniq.281" data-verso-hover="897">g</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.286" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span>
  /- Tactic state
     g : Nat â†’ Nat
     aâœ : AllEven g
     âŠ¢ AllEven fun k =&gt; g (k + 1) -/
  <span class="tactic"><label for="tactic-state-7-574-579"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-574" data-verso-hover="11">sorry</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-574-579"><span class="tactic-state">All goals completed! ðŸ™</span></span>

-- Introduces exactly three hypotheses, which requires unfolding `AllEven`
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-656">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.290" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.290" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">â†’</span> <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-712">fun</span> <span class="var token" data-binding="var-_uniq.297" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.290" data-verso-hover="897">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.297" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-2811588411521364105-735-737"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-735" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2811588411521364105-735-737"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.390" data-verso-hover="897">f</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.390" data-verso-hover="897">f</span> â†’ <span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.392" data-verso-hover="7">k</span> =&gt; <span class="var token" data-binding="var-_uniq.390" data-verso-hover="897">f</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.392" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-6097473226663759826-740-752"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-740" data-verso-hover="379">intros</span></a> <span class="var token" data-binding="var-_uniq.372" data-verso-hover="897">f</span> <span class="var token" data-binding="var-_uniq.373" data-verso-hover="2329">h</span> <span class="var token" data-binding="var-_uniq.374" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6097473226663759826-740-752"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.372" data-verso-hover="897">f</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.373" data-verso-hover="2329">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-AllEven" data-verso-hover="2326">AllEven</span> <span class="var token" data-binding="var-_uniq.372" data-verso-hover="897">f</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.374" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.402" data-verso-hover="7">k</span> =&gt; <span class="var token" data-binding="var-_uniq.372" data-verso-hover="897">f</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.402" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a>) <span class="var token" data-binding="var-_uniq.374" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HMod___mk"><span class="const token" data-binding="const-HMod.hMod" data-verso-hover="1401"> % </span></a>2<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  /- Tactic state
     f : Nat â†’ Nat
     h : AllEven f
     n : Nat
     âŠ¢ (fun k =&gt; f (k + 1)) n % 2 = 0 -/
  <span class="tactic"><label for="tactic-state-7-869-876"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-869" data-verso-hover="692">apply</span></a> <span class="var token" data-binding="var-_uniq.373" data-verso-hover="2329">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-869-876"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                    Implications:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3003612779711439782-40-42"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-40" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3003612779711439782-40-42"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span> â†’ <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span> â†’ <span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-16532137758905053158-45-51"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-45" data-verso-hover="379">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16532137758905053158-45-51"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1813">aâœÂ¹</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="2301">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span></span></span></span></span></span>
  /- Tactic state
     aâœÂ¹ : p
     aâœ : q
     âŠ¢ p      -/
  <span class="tactic"><label for="tactic-state-7-121-131"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-121" data-verso-hover="1029">assumption</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-121-131"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                    Let bindings:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-10" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-22" data-verso-hover="108">let</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">;</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3684336675399343821-47-49"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-47" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3684336675399343821-47-49"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">n</span> := 1;
<span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">k</span> := 2;
<span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>3</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-6719238456830077458-52-58"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-52" data-verso-hover="379">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6719238456830077458-52-58"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.180" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> := 1</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.181" data-verso-hover="7">kâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> := 2</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.180" data-verso-hover="7">nâœ</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.181" data-verso-hover="7">kâœ</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>3</span></span></span></span></span>
  /- nâœ : Nat := 1
     kâœ : Nat := 2
     âŠ¢ nâœ + kâœ = 3 -/
  <span class="tactic"><label for="tactic-state-7-131-134"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-131" data-verso-hover="14">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-131-134"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="intro-___-_________-____GT_-_________-___-_________-____GT_-_________">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.introMatch" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#intro-___-_________-____GT_-_________-___-_________-____GT_-_________"><span class="keyword token" data-binding="" data-verso-hover="2330">intro | ... =&gt; ... | ... =&gt; ...</span></a></pre><div class="text">
                  <p>
                    The tactic</p>
                  <pre>intro
| pat1 =&gt; tac1
| pat2 =&gt; tac2
</pre><p>
                    is the same as:</p>
                  <pre>intro x
match x with
| pat1 =&gt; tac1
| pat2 =&gt; tac2
</pre><p>
                    That is, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="662">intro</span></a></code> can be followed by match arms and it introduces the values while
doing a pattern match. This is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun</span></code> with match arms in term mode.</p>
                  </div>
                </div>
              <div class="namedocs" id="rintro">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.rintro" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rintro"><span class="keyword token" data-binding="" data-verso-hover="2295">rintro</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro"><span class="keyword token" data-binding="" data-verso-hover="2295">rintro</span></a></code> tactic is a combination of the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="379">intros</span></a></code> tactic with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> to
allow for destructuring patterns while introducing variables. See <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> for
a description of supported patterns. For example, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rintro-0" data-verso-hover="2295">rintro</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">âŸ©</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">d</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">âŸ©</span></code>
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">d</span> <span class="unknown token" data-binding="">e</span></code> and the other with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span> <span class="unknown token" data-binding="">c</span> <span class="unknown token" data-binding="">d</span> <span class="unknown token" data-binding="">e</span></code>.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro"><span class="keyword token" data-binding="" data-verso-hover="2295">rintro</span></a></code>, unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code>, also supports the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ty</span><span class="unknown token" data-binding="">)</span></code> for introducing
and type-ascripting multiple variables at once, similar to binders.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-relations">
                13.5.4.Â Relations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-relations" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="rfl">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticRfl" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="" data-verso-hover="14">rfl</span></a></pre><div class="text">
                  <p>
                    This tactic applies to a goal whose target has the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">~</span> <span class="unknown token" data-binding="">x</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">~</span></code> is equality, heterogeneous equality or any relation that
has a reflexivity lemma tagged with the attribute @[refl].</p>
                  </div>
                </div>
              <div class="namedocs" id="rfl___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticRfl'" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rfl___"><span class="keyword token" data-binding="" data-verso-hover="2332">rfl'</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rfl___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl'-0" data-verso-hover="2332">rfl'</span></a></code> is similar to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_rfl">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.applyRfl" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_rfl"><span class="keyword token" data-binding="" data-verso-hover="2333">apply_rfl</span></a></pre><div class="text">
                  <p>
                    The same as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, but without trying <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#eq_refl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.eqRefl-0" data-verso-hover="2334">eq_refl</span></a></code> at the end.</p>
                  </div>
                </div>
              <div class="namedocs" id="attr-next-next-next-next-next-next-next-next">
                <span class="label">attribute</span><span class="title">Reflexive Relations</span><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2335">refl</span></code> attribute marks a lemma as a proof of reflexivity for some relation.
These lemmas are used by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="" data-verso-hover="14">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#rfl___"><span class="keyword token" data-binding="" data-verso-hover="2332">rfl'</span></a></code>, and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rfl"><span class="keyword token" data-binding="" data-verso-hover="2333">apply_rfl</span></a></code> tactics.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">refl</span><span class="from-nonterminal" data-kind="null"></span></pre></div>
                </div>
              <div class="namedocs" id="symm">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.symm" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="" data-verso-hover="2320">symm</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2320">symm</span></a></code> applies to a goal whose target has the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span> <span class="unknown token" data-binding="">~</span> <span class="unknown token" data-binding="">u</span></code> where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">~</span></code> is a symmetric relation,
that is, a relation which has a symmetry lemma tagged with the attribute [symm].
It replaces the target with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">~</span> <span class="unknown token" data-binding="">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2320">symm</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-5" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> will rewrite a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">t</span> <span class="unknown token" data-binding="">~</span> <span class="unknown token" data-binding="">u</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">~</span> <span class="unknown token" data-binding="">t</span></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="symm_saturate">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.symmSaturate" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#symm_saturate"><span class="keyword token" data-binding="" data-verso-hover="2336">symm_saturate</span></a></pre><div class="text">
                  <p>
                    For every hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">~</span> <span class="unknown token" data-binding="">b</span></code> where a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">symm</span><span class="unknown token" data-binding="">]</span></code> lemma is available,
add a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h_symm</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">b</span> <span class="unknown token" data-binding="">~</span> <span class="unknown token" data-binding="">a</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="attr-next-next-next-next-next-next-next-next-next">
                <span class="label">attribute</span><span class="title">Symmetric Relations</span><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2337">symm</span></code> attribute marks a lemma as a proof that a relation is symmetric.
These lemmas are used by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="" data-verso-hover="2320">symm</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#symm_saturate"><span class="keyword token" data-binding="" data-verso-hover="2336">symm_saturate</span></a></code> tactics.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">symm</span><span class="from-nonterminal" data-kind="null"></span></pre></div>
                </div>
              <div class="namedocs" id="calc">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.calcTactic" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#calc"><span class="keyword token" data-binding="" data-verso-hover="2338">calc</span></a></pre><div class="text">
                  <p>
                    Step-wise reasoning over transitive relations.</p>
                  <pre>calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
</pre><p>
                    proves <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.514" data-verso-hover="2339">a</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.524" data-verso-hover="2339">z</span></code> from the given step-wise proofs. <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> can be replaced with any
relation implementing the typeclass <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#Trans___mk"><span class="const token" data-binding="const-Trans" data-verso-hover="2340">Trans</span></a></code>. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>.</p>
                  <pre>calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
</pre><p>
                    It is also possible to write the <em>first</em> relation as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">lhs</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">\</span><span class="unknown token" data-binding="">n</span>  <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">rhs</span><span class="unknown token" data-binding="">&gt;</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">proof</span><span class="unknown token" data-binding="">&gt;</span></code>. This is useful for aligning relation symbols, especially on longer:
identifiers:</p>
                  <pre>calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
</pre><p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#calc"><span class="keyword token" data-binding="" data-verso-hover="2338">calc</span></a></code> works as a term, as a tactic or as a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.conv" data-verso-hover="2341">conv</span></code> tactic.</p>
                  <p>
                    See <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs">Theorem Proving in Lean 4</a> for more information.</p>
                  </div>
                </div>
              <div class="namedocs" id="Trans___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Trans.mk" title="Permalink">ðŸ”—</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only">Trans.{u, v, w, u_1, u_2, u_3} {<span class="var token" data-binding="var-_uniq.3441" data-verso-hover="127">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_1</span>} {<span class="var token" data-binding="var-_uniq.3442" data-verso-hover="296">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_2</span>}
  {<span class="var token" data-binding="var-_uniq.3443" data-verso-hover="188">Î³</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_3</span>} (<span class="var token" data-binding="var-_uniq.3447" data-verso-hover="2342">r</span> : <span class="var token" data-binding="var-_uniq.3441" data-verso-hover="127">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3442" data-verso-hover="296">Î²</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>) (<span class="var token" data-binding="var-_uniq.3451" data-verso-hover="2343">s</span> : <span class="var token" data-binding="var-_uniq.3442" data-verso-hover="296">Î²</span> â†’ <span class="var token" data-binding="var-_uniq.3443" data-verso-hover="188">Î³</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>)
  (<span class="var token" data-binding="var-_uniq.3455" data-verso-hover="2344">t</span> : <a href="Type-Classes/Instance-Synthesis/#outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1550">outParam</span></a> (<span class="var token" data-binding="var-_uniq.3441" data-verso-hover="127">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3443" data-verso-hover="188">Î³</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort w</span>)) :
  <span class="sort token" data-binding="" data-verso-hover="169">Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)</span></div><div class="narrow-only">Trans.{u, v, w, u_1, u_2, u_3}
  {<span class="var token" data-binding="var-_uniq.3441" data-verso-hover="127">Î±</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_1</span>} {<span class="var token" data-binding="var-_uniq.3442" data-verso-hover="296">Î²</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_2</span>}
  {<span class="var token" data-binding="var-_uniq.3443" data-verso-hover="188">Î³</span> : <span class="sort token" data-binding="" data-verso-hover="169">Sort u_3</span>} (<span class="var token" data-binding="var-_uniq.3447" data-verso-hover="2342">r</span> : <span class="var token" data-binding="var-_uniq.3441" data-verso-hover="127">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3442" data-verso-hover="296">Î²</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort u</span>)
  (<span class="var token" data-binding="var-_uniq.3451" data-verso-hover="2343">s</span> : <span class="var token" data-binding="var-_uniq.3442" data-verso-hover="296">Î²</span> â†’ <span class="var token" data-binding="var-_uniq.3443" data-verso-hover="188">Î³</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort v</span>)
  (<span class="var token" data-binding="var-_uniq.3455" data-verso-hover="2344">t</span> : <a href="Type-Classes/Instance-Synthesis/#outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1550">outParam</span></a> (<span class="var token" data-binding="var-_uniq.3441" data-verso-hover="127">Î±</span> â†’ <span class="var token" data-binding="var-_uniq.3443" data-verso-hover="188">Î³</span> â†’ <span class="sort token" data-binding="" data-verso-hover="169">Sort w</span>)) :
  <span class="sort token" data-binding="" data-verso-hover="169">Sort
    (max
        (max
            (max
                (max (max (max 1 u) u_1)
                    u_2)
                u_3)
            v)
        w)</span></div></pre><div class="text">
                  <p>
                    Transitive chaining of proofs, used e.g. by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#calc"><span class="keyword token" data-binding="" data-verso-hover="2338">calc</span></a></code>.</p>
                  <p>
                    It takes two relations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.559" data-verso-hover="2342">r</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="2343">s</span></code> as "input", and produces an "output"
relation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="2344">t</span></code>, with the property that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.559" data-verso-hover="2342">r</span> <span class="var token" data-binding="var-_uniq.574" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.583" data-verso-hover="185">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.560" data-verso-hover="2343">s</span> <span class="var token" data-binding="var-_uniq.583" data-verso-hover="185">b</span> <span class="var token" data-binding="var-_uniq.593" data-verso-hover="993">c</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.561" data-verso-hover="2344">t</span> <span class="var token" data-binding="var-_uniq.574" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.593" data-verso-hover="993">c</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#calc"><span class="keyword token" data-binding="" data-verso-hover="2338">calc</span></a></code> tactic uses this so that when it sees a chain with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.574" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="var token" data-binding="var-_uniq.583" data-verso-hover="185">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.583" data-verso-hover="185">b</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.593" data-verso-hover="993">c</span></code>
it knows that this should be a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.574" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.593" data-verso-hover="993">c</span></code> because there is an instance
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Trans</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">â‰¤</span><span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  <h1>
                    Instance Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Tactic-Proofs/Tactic-Reference/#Trans___mk"><span class="const token" data-binding="const-Trans.mk" data-verso-hover="2345">Trans.mk</span></a>.{u, v, w, u_1, u_2, u_3}</pre><div class="docs"></div>
                    </section>
                  <h1>
                    Methods</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Trans.trans" data-verso-hover="2346">trans</span> : {<span class="var token" data-binding="var-_uniq.3381" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.3366" data-verso-hover="127">Î±</span>} â†’ {<span class="var token" data-binding="var-_uniq.3387" data-verso-hover="185">b</span> : <span class="var token" data-binding="var-_uniq.3367" data-verso-hover="296">Î²</span>} â†’ {<span class="var token" data-binding="var-_uniq.3392" data-verso-hover="993">c</span> : <span class="var token" data-binding="var-_uniq.3368" data-verso-hover="188">Î³</span>} â†’ <span class="var token" data-binding="var-_uniq.3369" data-verso-hover="2342">r</span> <span class="var token" data-binding="var-_uniq.3381" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.3387" data-verso-hover="185">b</span> â†’ <span class="var token" data-binding="var-_uniq.3370" data-verso-hover="2343">s</span> <span class="var token" data-binding="var-_uniq.3387" data-verso-hover="185">b</span> <span class="var token" data-binding="var-_uniq.3392" data-verso-hover="993">c</span> â†’ <span class="var token" data-binding="var-_uniq.3371" data-verso-hover="2344">t</span> <span class="var token" data-binding="var-_uniq.3381" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.3392" data-verso-hover="993">c</span></pre><div class="docs">
                      <p>
                        Compose two proofs by transitivity, generalized over the relations involved.</p>
                      </div>
                    </section>
                  </div>
                </div>
              <section>
                <h3 id="tactic-ref-equality">
                  13.5.4.1.Â Equality<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-equality" title="Permalink">ðŸ”—</a></span></h3>
                <div class="namedocs" id="subst">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.subst" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#subst"><span class="keyword token" data-binding="" data-verso-hover="2347">subst</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">subst</span> <span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">...</span></code> substitutes each <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3504" data-verso-hover="2348">x</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3523" data-verso-hover="2349">e</span></code> in the goal if there is a hypothesis
of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3504" data-verso-hover="2350">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.3523" data-verso-hover="2350">e</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3523" data-verso-hover="2351">e</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.3504" data-verso-hover="2351">x</span></code>.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3504" data-verso-hover="2351">x</span></code> is itself a hypothesis of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3540" data-verso-hover="2352">y</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.3523" data-verso-hover="2352">e</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3523" data-verso-hover="2353">e</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.3540" data-verso-hover="2353">y</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3540" data-verso-hover="2353">y</span></code> is substituted instead.</p>
                    </div>
                  </div>
                <div class="namedocs" id="subst_eqs">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.substEqs" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#subst_eqs"><span class="keyword token" data-binding="" data-verso-hover="2354">subst_eqs</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">subst_eq</span></code> repeatedly substitutes according to the equality proof hypotheses in the context,
replacing the left side of the equality with the right, until no more progress can be made.</p>
                    </div>
                  </div>
                <div class="namedocs" id="subst_vars">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.substVars" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#subst_vars"><span class="keyword token" data-binding="" data-verso-hover="2355">subst_vars</span></a></pre><div class="text">
                    <p>
                      Applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#subst"><span class="keyword token" data-binding="" data-verso-hover="2347">subst</span></a></code> to all hypotheses of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3597" data-verso-hover="2356">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3573" data-verso-hover="2357">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.3584" data-verso-hover="2357">t</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">t</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">x</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="congr">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.congr" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#congr"><span class="keyword token" data-binding="" data-verso-hover="2358">congr</span></a></pre><div class="text">
                    <p>
                      Apply congruence (recursively) to goals of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">as</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">bs</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">HEq</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">as</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">bs</span><span class="unknown token" data-binding="">)</span></code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congr-next"><span class="const token" data-binding="const-congr" data-verso-hover="2359">congr</span></a></code> is too aggressive in breaking down the goal.
For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">g</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">g</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congr-next"><span class="const token" data-binding="const-congr" data-verso-hover="2359">congr</span></a></code> produces the goals <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">y</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">x</span></code>,
while <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#congr"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.congr-0" data-verso-hover="2358">congr</span></a> <span class="unknown token" data-binding="">2</span></code> produces the intended <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">x</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="eq_refl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.eqRefl" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#eq_refl"><span class="keyword token" data-binding="" data-verso-hover="2334">eq_refl</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#eq_refl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.eqRefl-0" data-verso-hover="2334">eq_refl</span></a></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <span class="unknown token" data-binding="">rfl</span></code>, but has a few optimizations.</p>
                    </div>
                  </div>
                <div class="namedocs" id="ac_rfl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.acRfl" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ac_rfl"><span class="keyword token" data-binding="" data-verso-hover="2360">ac_rfl</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.acRfl-0" data-verso-hover="2360">ac_rfl</span></a></code> proves equalities up to application of an associative and commutative operator.</p>
                    <pre>instance : Associative (Î± := Nat) (.+.) := âŸ¨Nat.add_assocâŸ©
instance : Commutative (Î± := Nat) (.+.) := âŸ¨Nat.add_commâŸ©

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl
</pre></div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-ref-associativity-commutativity">
                13.5.5.Â Associativity and Commutativity<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-associativity-commutativity" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="ac_nf">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticAc_nf_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><span class="keyword token" data-binding="" data-verso-hover="2361">ac_nf</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2361">ac_nf</span></a></code> normalizes equalities up to application of an associative and commutative operator.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2361">ac_nf</span></a></code> normalizes all hypotheses and the goal target of the goal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2361">ac_nf</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-6" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">l</span></code> normalizes at location(s) <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code> is either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">*</span></code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">|</span><span class="unknown token" data-binding="">-</span></code>
can also be used, to signify the target of the goal.</p>
                      </li>
                    </ul>
                  <pre>instance : Associative (Î± := Nat) (.+.) := âŸ¨Nat.add_assocâŸ©
instance : Commutative (Î± := Nat) (.+.) := âŸ¨Nat.add_commâŸ©

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by
 ac_nf
 -- goal: a + (b + (c + d)) = a + (b + (c + d))
</pre></div>
                </div>
              <div class="namedocs" id="ac_nf0">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.acNf0" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf0"><span class="keyword token" data-binding="" data-verso-hover="2362">ac_nf0</span></a></pre><div class="text">
                  <p>
                    Implementation of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2361">ac_nf</span></a></code> (the full <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2361">ac_nf</span></a></code> calls <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2319">trivial</span></code> afterwards).</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-lemmas">
                13.5.6.Â Lemmas<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-lemmas" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="exact">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.exact" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="" data-verso-hover="765">exact</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <span class="unknown token" data-binding="">e</span></code> closes the main goal if its target type matches that of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.apply" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-0" data-verso-hover="692">apply</span></a> <span class="unknown token" data-binding="">e</span></code> tries to match the current goal against the conclusion of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p>
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code> tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.</p>
                  </div>
                </div>
              <div class="namedocs" id="refine">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.refine" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#refine"><span class="keyword token" data-binding="" data-verso-hover="2272">refine</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.refine-0" data-verso-hover="2272">refine</span></a> <span class="unknown token" data-binding="">e</span></code> behaves like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <span class="unknown token" data-binding="">e</span></code>, except that named (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">x</span></code>) or unnamed (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">_</span></code>)
holes in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> that are not solved by unification with the main goal's target type
are converted into new goals, using the hole's name, if any, as the goal case name.</p>
                  </div>
                </div>
              <div class="namedocs" id="refine___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.refine'" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#refine___"><span class="keyword token" data-binding="" data-verso-hover="2305">refine'</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.refine'-0" data-verso-hover="2305">refine'</span></a> <span class="unknown token" data-binding="">e</span></code> behaves like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.refine-0" data-verso-hover="2272">refine</span></a> <span class="unknown token" data-binding="">e</span></code>, except that unsolved placeholders (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>)
and implicit parameters are also converted into new goals.</p>
                  </div>
                </div>
              <div class="namedocs" id="solve_by_elim">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.solveByElim" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="" data-verso-hover="2323">solve_by_elim</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code> calls <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code> on the main goal to find an assumption whose head matches
and then repeatedly calls <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code> on the generated subgoals until no subgoals remain,
performing at most <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">maxDepth</span></code> (defaults to 6) recursive steps.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code> discharges the current goal or fails.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code> performs backtracking if subgoals can not be solved.</p>
                  <p>
                    By default, the assumptions passed to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code> are the local context, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2319">trivial</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1393">congrFun</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="775">congrArg</span></a></code>.</p>
                  <p>
                    The assumptions can be modified with similar syntax as for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">háµ£</span><span class="unknown token" data-binding="">]</span></code> also applies the given expressions.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span> <span class="unknown token" data-binding="">only</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">háµ£</span><span class="unknown token" data-binding="">]</span></code> does not include the local context,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2319">trivial</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1393">congrFun</span></a></code>, or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="775">congrArg</span></a></code> unless they are explicitly included.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">hâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">hâ‚™</span><span class="unknown token" data-binding="">]</span></code> removes the given local hypotheses.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span> <span class="keyword token" data-binding="kw-occ-null-0">using</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">aâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> uses all lemmas which have been labelled
with the attributes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aáµ¢</span></code> (these attributes must be created using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">register_label_attr</span></code>).</p>
                      </li>
                    </ul>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a><span class="unknown token" data-binding="">*</span></code> tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.
(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)</p>
                  <p>
                    Optional arguments passed via a configuration argument as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code></p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">maxDepth</span></code>: number of attempts at discharging generated subgoals</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2320">symm</span></a></code>: adds all hypotheses derived by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2320">symm</span></a></code> (defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>).</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2321">exfalso</span></a></code>: allow calling <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2321">exfalso</span></a></code> and trying again if <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code> fails
(defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>).</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">transparency</span></code>: change the transparency mode when calling <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code>. Defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.default</span></code>,
but it is often useful to change to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.reducible</span></code>,
so semireducible definitions will not be unfolded when trying to apply a lemma.</p>
                      </li>
                    </ul>
                  <p>
                    See also the doc-comment for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Meta.Tactic.Backtrack.BacktrackConfig" data-verso-hover="2363">Lean.Meta.Tactic.Backtrack.BacktrackConfig</span></code> for the options
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">proc</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">suspend</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">discharge</span></code> which allow further customization of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code>.
Both <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2318">apply_assumption</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a></code> are implemented via these hooks.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_rules">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.applyRules" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="" data-verso-hover="2364">apply_rules</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">lâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">lâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> tries to solve the main goal by iteratively
applying the list of lemmas <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">lâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">lâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> or by applying a local hypothesis.
If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code> generates new goals, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a></code> iteratively tries to solve those goals.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code> to omit a local hypothesis.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a></code> will also use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2319">trivial</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1393">congrFun</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="775">congrArg</span></a></code>.
These can be disabled, as can local hypotheses, by using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span> <span class="unknown token" data-binding="">only</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code>.</p>
                  <p>
                    You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span> <span class="keyword token" data-binding="kw-occ-null-0">using</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">aâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> to use all lemmas which have been labelled
with the attributes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aáµ¢</span></code> (these attributes must be created using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">register_label_attr</span></code>).</p>
                  <p>
                    You can pass a further configuration via the syntax <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code>.
The options supported are the same as for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code> (and include all the options for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code>).</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a></code> will try calling <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2320">symm</span></a></code> on hypotheses and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2321">exfalso</span></a></code> on the goal as needed.
This can be disabled with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">symm</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">false</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">exfalso</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">false</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  <p>
                    You can bound the iteration depth using the syntax <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">maxDepth</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  <p>
                    Unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2364">apply_rules</span></a></code> does not perform backtracking, and greedily applies
a lemma from the list until it gets stuck.</p>
                  </div>
                </div>
              <div class="namedocs" id="as_aux_lemma">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.as_aux_lemma" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#as_aux_lemma"><span class="keyword token" data-binding="" data-verso-hover="2365">as_aux_lemma</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">as_aux_lemma</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tac</span></code> does the same as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code>, except that it wraps the resulting expression
into an auxiliary lemma. In some cases, this significantly reduces the size of expressions
because the proof term is not duplicated.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-false">
                13.5.7.Â Falsehood<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-false" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="exfalso">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticExfalso" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exfalso"><span class="keyword token" data-binding="" data-verso-hover="2321">exfalso</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2321">exfalso</span></a></code> converts a goal <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">tgt</span></code> into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">False</span></code> by applying <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False___elim"><span class="const token" data-binding="const-False.elim" data-verso-hover="1379">False.elim</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="contradiction">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.contradiction" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="" data-verso-hover="1181">contradiction</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-0" data-verso-hover="1181">contradiction</span></a></code> closes the main goal if its hypotheses are "trivially contradictory".</p>
                  <ul>
                    <li>
                      <p>
                        Inductive type/family with no applicable constructors</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="421">h</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="127">p</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14137034110488466993-27-29"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14137034110488466993-27-29"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="2366">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="169">Sort ?u.9</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="421">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="2366">p</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-30-43"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-30" data-verso-hover="1181">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-30-43"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Injectivity of constructors</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.74" data-verso-hover="2367">h</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.40" data-verso-hover="127">p</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-17901862782927326286-38-40"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-38" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17901862782927326286-38-40"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.79" data-verso-hover="2368">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="169">Sort ?u.75</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.74" data-verso-hover="2367">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.79" data-verso-hover="2368">p</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-41-54"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-41" data-verso-hover="1181">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-41-54"><span class="tactic-state">All goals completed! ðŸ™</span></span>  --
<span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Decidable false proposition</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.180" data-verso-hover="2369">h</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.92" data-verso-hover="127">p</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-16010087280529596762-31-33"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-31" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16010087280529596762-31-33"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.275" data-verso-hover="2370">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="169">Sort ?u.181</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.180" data-verso-hover="2369">h</span></span><span class="colon">:</span><span class="type">2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>3</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.275" data-verso-hover="2370">p</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-34-47"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-34" data-verso-hover="1181">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-34-47"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Contradictory hypotheses</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="1813">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">p</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1812">h'</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">Â¬</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">p</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="127">q</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11218138560346200192-35-37"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11218138560346200192-35-37"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.23" data-verso-hover="204">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.24" data-verso-hover="2371">q</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="169">Sort ?u.17</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14" data-verso-hover="1813">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.23" data-verso-hover="204">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1812">h'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="635">Â¬</span></a><span class="var token" data-binding="var-_uniq.23" data-verso-hover="204">p</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.24" data-verso-hover="2371">q</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-38-51"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-38" data-verso-hover="1181">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-38-51"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Other simple contradictions such as</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="2372">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">â‰ </span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="127">p</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-4506727907446180416-39-41"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-39" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4506727907446180416-39-41"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.22" data-verso-hover="2371">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="169">Sort ?u.17</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="2372">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">x</span><span class="const token" data-binding="const-Ne" data-verso-hover="512"> â‰  </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">x</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.22" data-verso-hover="2371">p</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-42-55"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-42" data-verso-hover="1181">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-42-55"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="false_or_by_contra">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.falseOrByContra" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#false_or_by_contra"><span class="keyword token" data-binding="" data-verso-hover="2373">false_or_by_contra</span></a></pre><div class="text">
                  <p>
                    Changes the goal to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>, retaining as much information as possible:</p>
                  <ul>
                    <li>
                      <p>
                        If the goal is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>, do nothing.</p>
                      </li>
                    <li>
                      <p>
                        If the goal is an implication or a function type, introduce the argument and restart.
(In particular, if the goal is <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4109" data-verso-hover="2374">x</span> <span class="unknown token" data-binding="">â‰ </span> <span class="var token" data-binding="var-_uniq.4117" data-verso-hover="2374">y</span></code>, introduce <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4109" data-verso-hover="2375">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.4117" data-verso-hover="2375">y</span></code>.)</p>
                      </li>
                    <li>
                      <p>
                        Otherwise, for a propositional goal <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4136" data-verso-hover="2376">P</span></code>, replace it with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Â¬</span> <span class="unknown token" data-binding="">Â¬</span> <span class="var token" data-binding="var-_uniq.4136" data-verso-hover="204">P</span></code>
(attempting to find a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a></code> instance, but otherwise falling back to working classically)
and introduce <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Â¬</span> <span class="var token" data-binding="var-_uniq.4136" data-verso-hover="204">P</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        For a non-propositional goal use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False___elim"><span class="const token" data-binding="const-False.elim" data-verso-hover="1379">False.elim</span></a></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-goals">
                13.5.8.Â Goal Management<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-goals" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="suffices">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticSuffices_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#suffices"><span class="keyword token" data-binding="" data-verso-hover="768">suffices</span></a></pre><div class="text">
                  <p>
                    Given a main goal <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ctx</span> <span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">t</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#suffices"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSuffices_-0" data-verso-hover="768">suffices</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">t'</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-16">from</span> <span class="unknown token" data-binding="">e</span></code> replaces the main goal with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ctx</span> <span class="unknown token" data-binding="">âŠ¢</span> <span class="unknown token" data-binding="">t'</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> must have type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code> in the context <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ctx</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">t'</span></code>.</p>
                  <p>
                    The variant <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">suffices</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">t'</span> <span class="keyword token" data-binding="kw-occ-null-0">by</span> <span class="unknown token" data-binding="">tac</span></code> is a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">suffices</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">t'</span> <span class="keyword token" data-binding="kw-occ-null-0">from</span> <span class="keyword token" data-binding="kw-occ-null-0">by</span> <span class="unknown token" data-binding="">tac</span></code>.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span></code> is omitted, the name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> is used.</p>
                  </div>
                </div>
              <div class="namedocs" id="change">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.change" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#change"><span class="keyword token" data-binding="" data-verso-hover="2377">change</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.change-0" data-verso-hover="2377">change</span></a> <span class="unknown token" data-binding="">tgt'</span></code> will change the goal from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tgt</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tgt'</span></code>,
assuming these are definitionally equal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.change-0" data-verso-hover="2377">change</span></a> <span class="unknown token" data-binding="">t'</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> will change hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4216" data-verso-hover="2273">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4194" data-verso-hover="2378">t</span></code> to have type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t'</span></code>, assuming
assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4194" data-verso-hover="2378">t</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t'</span></code> are definitionally equal.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="change-_________-with-_________">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.changeWith" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________"><span class="keyword token" data-binding="" data-verso-hover="2379">change ... with ...</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2379">change</span></a> <span class="unknown token" data-binding="">a</span> <a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2379">with</span></a> <span class="unknown token" data-binding="">b</span></code> will change occurrences of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> in the goal,
assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> are definitionally equal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2379">change</span></a> <span class="unknown token" data-binding="">a</span> <a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2379">with</span></a> <span class="unknown token" data-binding="">b</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-16" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> similarly changes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> in the type of hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="generalize">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.generalize" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#generalize"><span class="keyword token" data-binding="" data-verso-hover="2380">generalize</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">generalize</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,+</span></code> replaces all occurrences <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4348" data-verso-hover="2381">e</span></code>s in the main goal
with a fresh hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4371" data-verso-hover="2382">x</span></code>s. If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4387" data-verso-hover="2383">h</span></code> is given, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4387" data-verso-hover="2384">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4348" data-verso-hover="2385">e</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.4371" data-verso-hover="2385">x</span></code> is introduced as well.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">generalize</span> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">x</span> <span class="keyword token" data-binding="kw-occ-null-0">at</span> <span class="unknown token" data-binding="">hâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">hâ‚™</span></code> also generalizes occurrences of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4348" data-verso-hover="2385">e</span></code>
inside <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hâ‚</span></code>, ..., <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hâ‚™</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#generalize"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.generalize-0" data-verso-hover="2380">generalize</span></a> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">x</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-17" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">*</span></code> will generalize occurrences of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4348" data-verso-hover="2385">e</span></code> everywhere.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="specialize">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.specialize" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#specialize"><span class="keyword token" data-binding="" data-verso-hover="1193">specialize</span></a></pre><div class="text">
                  <p>
                    The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">specialize</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">aâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">aâ‚™</span></code> works on local hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.
The premises of this hypothesis, either universal quantifications or
non-dependent implications, are instantiated by concrete terms coming
from arguments <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aâ‚</span></code> ... <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aâ‚™</span></code>.
The tactic adds a new hypothesis with the same name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">aâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">aâ‚™</span></code>
and tries to clear the previous one.</p>
                  </div>
                </div>
              <div class="namedocs" id="obtain">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.obtain" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#obtain"><span class="keyword token" data-binding="" data-verso-hover="1190">obtain</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#obtain"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-0" data-verso-hover="1190">obtain</span></a></code> tactic is a combination of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="" data-verso-hover="1102">have</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code>. See <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> for
a description of supported patterns.</p>
                  <pre>obtain âŸ¨pattâŸ© : type := proof
</pre><p>
                    is equivalent to</p>
                  <pre>have h : type := proof
rcases h with âŸ¨pattâŸ©
</pre><p>
                    If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">patt</span><span class="unknown token" data-binding="">âŸ©</span></code> is omitted, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> will try to infer the pattern.</p>
                  <p>
                    If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">type</span></code> is omitted, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">proof</span></code> is required.</p>
                  </div>
                </div>
              <div class="namedocs" id="show">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticShow_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#show"><span class="keyword token" data-binding="" data-verso-hover="1134">show</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#show"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticShow_-0" data-verso-hover="1134">show</span></a> <span class="unknown token" data-binding="">t</span></code> finds the first goal whose target unifies with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="show_term">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.showTerm" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#show_term"><span class="keyword token" data-binding="" data-verso-hover="2386">show_term</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.showTermElab-0" data-verso-hover="2387">show_term</span> <span class="var token" data-binding="var-_uniq.4496" data-verso-hover="2388">tac</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4496" data-verso-hover="2388">tac</span></code>, then prints the generated term in the form
"exact X Y Z" or "refine X ?_ Z" (prefixed by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#expose_names"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exposeNames-0" data-verso-hover="2389">expose_names</span></a></code> if necessary)
if there are remaining subgoals.</p>
                  <p>
                    (For some tactics, the printed term will not be human readable.)</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-casts">
                13.5.9.Â Cast Management<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-casts" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                The tactics in this section make it easier avoid getting stuck on <span id="--tech-term-casts" class="def-technical-term"><em>casts</em></span>, which are functions that coerce data from one type to another, such as converting a natural number to the corresponding integer.
They are described in more detail by Lewis and MadelaineÂ (2020)<span class="marginalia"><span class="note"><span class="citation">Robert Y. Lewis and Paul-Nicolas Madelaine,Â 2020. <a href="https://arxiv.org/abs/2001.10594">â€œSimplifying Casts and Coercionsâ€</a>. arXiv:2001.10594</span></span></span>.</p>
              <div class="namedocs" id="norm_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticNorm_cast__" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="" data-verso-hover="2088">norm_cast</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> family of tactics is used to normalize certain coercions (<em>casts</em>) in expressions.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> normalizes casts in the target.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> normalizes casts in hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    The tactic is basically a version of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code> with a specific set of lemmas to move casts
upwards in the expression.
Therefore even in situations where non-terminal <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code> calls are discouraged (because of fragility),
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> is considered to be safe.
It also has special handling of numerals.</p>
                  <p>
                    For instance, given an assumption</p>
                  <pre>a b : â„¤
h : â†‘a + â†‘b &lt; (10 : â„š)
</pre><p>
                    writing <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> will turn <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> into</p>
                  <pre>h : a + b &lt; 10
</pre><p>
                    There are also variants of basic tactics that use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> to normalize expressions during
their operation, to make them more flexible about the expressions they accept
(we say that it is a tactic <em>modulo</em> the effects of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code>):</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast"><span class="keyword token" data-binding="" data-verso-hover="2390">exact_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="" data-verso-hover="765">exact</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast"><span class="keyword token" data-binding="" data-verso-hover="2391">apply_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code>.
Writing <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExact_mod_cast_-0" data-verso-hover="2390">exact_mod_cast</span></a> <span class="unknown token" data-binding="">h</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticApply_mod_cast_-0" data-verso-hover="2391">apply_mod_cast</span></a> <span class="unknown token" data-binding="">h</span></code> will normalize casts
in the goal and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> before using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <span class="unknown token" data-binding="">h</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-0" data-verso-hover="692">apply</span></a> <span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw_mod_cast"><span class="keyword token" data-binding="" data-verso-hover="2392">rw_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="" data-verso-hover="1138">rw</span></a></code>. It applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> between rewrites.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAssumption_mod_cast_-0" data-verso-hover="2393">assumption_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code>.
This is effectively <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">norm_cast</span> <span class="keyword token" data-binding="kw-occ-null-0">at</span> <span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-null-0">assumption</span></code>, but more efficient.
It normalizes casts in the goal and, for every hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> in the context,
it will try to normalize casts in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> and use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    See also <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2394">push_cast</span></a></code>, which moves casts inwards rather than lifting them outwards.</p>
                  </div>
                </div>
              <div class="namedocs" id="push_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.pushCast" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="" data-verso-hover="2394">push_cast</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2394">push_cast</span></a></code> rewrites the goal to move certain coercions (<em>casts</em>) inward, toward the leaf nodes.
This uses <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> lemmas in the forward direction.
For example, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">â†‘</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span></code> will be written to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">â†‘</span><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">â†‘</span><span class="unknown token" data-binding="">b</span></code>.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2394">push_cast</span></a></code> moves casts inward in the goal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2394">push_cast</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> moves casts inward in the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.
It can be used with extra simp lemmas with, for example, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2394">push_cast</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Int.add_zero</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Example:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.105" data-verso-hover="2395">h1</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="337">10</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.217" data-verso-hover="2396">h2</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="337">10</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="337">10</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-10421042161102796544-136-138"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-136" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10421042161102796544-136-138"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.105" data-verso-hover="2395">h1</span></span><span class="colon">:</span><span class="type">â†‘<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.217" data-verso-hover="2396">h2</span></span><span class="colon">:</span><span class="type">â†‘<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">â†‘<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span></span></span>
  /-
  h1 : â†‘(a + b) = 10
  h2 : â†‘(a + b + 0) = 10
  âŠ¢ â†‘(a + b) = 10
  -/
  <span class="tactic"><label for="tactic-state-2327087266105131378-223-232"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-223" data-verso-hover="2394">push_cast</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2327087266105131378-223-232"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.105" data-verso-hover="2395">h1</span></span><span class="colon">:</span><span class="type">â†‘<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.217" data-verso-hover="2396">h2</span></span><span class="colon">:</span><span class="type">â†‘<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">â†‘<span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>â†‘<span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span></span></span>
  /- Now
  âŠ¢ â†‘a + â†‘b = 10
  -/
  <span class="tactic"><label for="tactic-state-2995026816086673321-272-287"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-272" data-verso-hover="2394">push_cast</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-282" data-verso-hover="695">at</span> <span class="var token" data-binding="var-_uniq.105" data-verso-hover="2395">h1</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2995026816086673321-272-287"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.105" data-verso-hover="2397">h1</span></span><span class="colon">:</span><span class="type">â†‘<span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>â†‘<span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.217" data-verso-hover="2396">h2</span></span><span class="colon">:</span><span class="type">â†‘<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">â†‘<span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>â†‘<span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-17994435084395157885-290-320"><a href="Tactic-Proofs/Tactic-Reference/#push_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-290" data-verso-hover="2394">push_cast</span></a> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Int.add_zero" data-verso-hover="2398">Int.add_zero</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-315" data-verso-hover="695">at</span> <span class="var token" data-binding="var-_uniq.217" data-verso-hover="2396">h2</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17994435084395157885-290-320"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.105" data-verso-hover="2397">h1</span></span><span class="colon">:</span><span class="type">â†‘<span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>â†‘<span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.498" data-verso-hover="2397">h2</span></span><span class="colon">:</span><span class="type">â†‘<span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>â†‘<span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">â†‘<span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>â†‘<span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">b</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>10</span></span></span></span></span>
  /- Now
  h1 h2 : â†‘a + â†‘b = 10
  -/
  <span class="tactic"><label for="tactic-state-7-364-372"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-364" data-verso-hover="765">exact</span></a> <span class="var token" data-binding="var-_uniq.105" data-verso-hover="2397">h1</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-364-372"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                    See also <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="exact_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticExact_mod_cast_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast"><span class="keyword token" data-binding="" data-verso-hover="2390">exact_mod_cast</span></a></pre><div class="text">
                  <p>
                    Normalize casts in the goal and the given expression, then close the goal with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="" data-verso-hover="765">exact</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticApply_mod_cast_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast"><span class="keyword token" data-binding="" data-verso-hover="2391">apply_mod_cast</span></a></pre><div class="text">
                  <p>
                    Normalize casts in the goal and the given expression, then <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code> the expression to the goal.</p>
                  </div>
                </div>
              <div class="namedocs" id="rw_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticRw_mod_cast___" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rw_mod_cast"><span class="keyword token" data-binding="" data-verso-hover="2392">rw_mod_cast</span></a></pre><div class="text">
                  <p>
                    Rewrites with the given rules, normalizing casts prior to each step.</p>
                  </div>
                </div>
              <div class="namedocs" id="assumption_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticAssumption_mod_cast_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast"><span class="keyword token" data-binding="" data-verso-hover="2393">assumption_mod_cast</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAssumption_mod_cast_-0" data-verso-hover="2393">assumption_mod_cast</span></a></code> is a variant of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code> that solves the goal
using a hypothesis. Unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code>, it first pre-processes the goal and
each hypothesis to move casts as far outwards as possible, so it can be used
in more situations.</p>
                  <p>
                    Concretely, it runs <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> on the goal. For each local hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>, it also
normalizes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2088">norm_cast</span></a></code> and tries to use that to close the goal.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-ext">
                13.5.10.Â Extensionality<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-ext" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="ext">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Elab.Tactic.Ext.ext" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ext"><span class="keyword token" data-binding="" data-verso-hover="167">ext</span></a></pre><div class="text">
                  <p>
                    Applies extensionality lemmas that are registered with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.ext-2" data-verso-hover="2399">ext</span><span class="unknown token" data-binding="">]</span></code> attribute.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span> <span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> applies extensionality theorems as much as possible,
using the patterns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> to introduce the variables in extensionality theorems using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro"><span class="keyword token" data-binding="" data-verso-hover="2295">rintro</span></a></code>.
For example, the patterns are used to name the variables introduced by lemmas such as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext"><span class="const token" data-binding="const-funext" data-verso-hover="166">funext</span></a></code>.</p>
                      </li>
                    <li>
                      <p>
                        Without patterns,<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ext"><span class="keyword token" data-binding="kw-occ-Lean.Elab.Tactic.Ext.ext-0" data-verso-hover="167">ext</span></a></code> applies extensionality lemmas as much
as possible but introduces anonymous hypotheses whenever needed.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span> <span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">n</span></code> applies ext theorems only up to depth <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext1</span> <span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> tactic is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span> <span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> except that it only applies a single extensionality theorem.</p>
                  <p>
                    Unused patterns will generate warning.
Patterns that don't match the variables will typically result in the introduction of anonymous hypotheses.</p>
                  </div>
                </div>
              <div class="namedocs" id="ext1">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Elab.Tactic.Ext.tacticExt1___" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ext1"><span class="keyword token" data-binding="" data-verso-hover="2400">ext1</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext1</span> <span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span> <span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> except that it only applies a single extensionality theorem rather
than recursively applying as many extensionality theorems as possible.</p>
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> patterns are processed using the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro"><span class="keyword token" data-binding="" data-verso-hover="2295">rintro</span></a></code> tactic.
If no patterns are supplied, then variables are introduced anonymously using the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="379">intros</span></a></code> tactic.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_ext_theorem">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Elab.Tactic.Ext.applyExtTheorem" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_ext_theorem"><span class="keyword token" data-binding="" data-verso-hover="2401">apply_ext_theorem</span></a></pre><div class="text">
                  <p>
                    Apply a single extensionality theorem to the current goal.</p>
                  </div>
                </div>
              <div class="namedocs" id="funext-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticFunext___" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#funext-next"><span class="keyword token" data-binding="" data-verso-hover="111">funext</span></a></pre><div class="text">
                  <p>
                    Apply function extensionality and introduce new hypotheses.
The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#funext-next"><span class="keyword token" data-binding="kw-occ-tacticFunext___-0" data-verso-hover="111">funext</span></a></code> will keep applying the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext"><span class="const token" data-binding="const-funext" data-verso-hover="166">funext</span></a></code> lemma until the goal target is not reducible to</p>
                  <pre>  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))
</pre><p>
                    The variant <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">funext</span> <span class="unknown token" data-binding="">hâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">hâ‚™</span></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext"><span class="const token" data-binding="const-funext" data-verso-hover="166">funext</span></a></code> <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> times, and uses the given identifiers to name the new hypotheses.
Patterns can be used like in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="662">intro</span></a></code> tactic. Example, given a goal</p>
                  <pre>  |-  ((fun x : Nat Ã— Bool =&gt; ...) = (fun x =&gt; ...))
</pre><p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#funext-next"><span class="keyword token" data-binding="kw-occ-tacticFunext___-0" data-verso-hover="111">funext</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext"><span class="const token" data-binding="const-funext" data-verso-hover="166">funext</span></a></code> once and performs pattern matching on the newly introduced pair.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="simp-tactics">
                13.5.11.Â Simplification<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=simp-tactics" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                The simplifier is described in greater detail in <a href="The-Simplifier/#the-simplifier">its dedicated chapter</a>.</p>
              <div class="namedocs" id="simp">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simp" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="" data-verso-hover="36">simp</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code> tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code> simplifies the main goal target using lemmas tagged with the attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1811">simp</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚™</span><span class="unknown token" data-binding="">]</span></code> simplifies the main goal target using the lemmas tagged
with the attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1811">simp</span><span class="unknown token" data-binding="">]</span></code> and the given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">háµ¢</span></code>'s, where the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">háµ¢</span></code>'s are expressions.-</p>
                      </li>
                    <li>
                      <p>
                        If an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">háµ¢</span></code> is a defined constant <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is unfolded. If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> has equational lemmas associated
with it (and is not a projection or a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">reducible</span></code> definition), these are used to rewrite with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></code> simplifies the main goal target using the lemmas tagged with the
attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1811">simp</span><span class="unknown token" data-binding="">]</span></code> and all hypotheses.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span> <span class="unknown token" data-binding="">only</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚™</span><span class="unknown token" data-binding="">]</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hâ‚™</span><span class="unknown token" data-binding="">]</span></code> but does not use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1811">simp</span><span class="unknown token" data-binding="">]</span></code> lemmas.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">idâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">idâ‚™</span><span class="unknown token" data-binding="">]</span></code> simplifies the main goal target using the lemmas tagged
with the attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1811">simp</span><span class="unknown token" data-binding="">]</span></code>, but removes the ones named <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">idáµ¢</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span> <span class="keyword token" data-binding="kw-occ-null-0">at</span> <span class="unknown token" data-binding="">hâ‚</span> <span class="unknown token" data-binding="">hâ‚‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">hâ‚™</span></code> simplifies the hypotheses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.167" data-verso-hover="2402">hâ‚</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.85" data-verso-hover="2403">Tâ‚</span></code> ... <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.333" data-verso-hover="2404">hâ‚™</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="2405">Tâ‚™</span></code>. If
the target or another hypothesis depends on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">háµ¢</span></code>, a new simplified hypothesis
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">háµ¢</span></code> is introduced, but the old one remains in the local context.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-5" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">*</span></code> simplifies all the hypotheses and the target.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-9" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">*</span></code> simplifies target and all (propositional) hypotheses using the
other hypotheses.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simp___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpAutoUnfold" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp___"><span class="keyword token" data-binding="" data-verso-hover="2406">simp!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAutoUnfold-0" data-verso-hover="2406">simp!</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">autoUnfold</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">true</span></code>.
This will rewrite with all equation lemmas, which can be used to
partially evaluate many definitions.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpTrace" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="" data-verso-hover="2407">simp?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2407">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">if</span></a> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14893532502544598044-59-61"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14893532502544598044-59-61"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>3<span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-64-69"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: simp only [â†“reduceIte, Nat.add_left_cancel_iff]</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2407">simp?</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69"><span class="tactic-state">All goals completed! ðŸ™</span></span> -- prints "Try this: simp only [ite_true]"
<span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticSimp?!_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp______"><span class="keyword token" data-binding="" data-verso-hover="2407">simp?!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2407">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">if</span></a> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14893532502544598044-59-61"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14893532502544598044-59-61"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>3<span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-64-69"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: simp only [â†“reduceIte, Nat.add_left_cancel_iff]</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2407">simp?</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69"><span class="tactic-state">All goals completed! ðŸ™</span></span> -- prints "Try this: simp only [ite_true]"
<span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_arith">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpArith" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith"><span class="keyword token" data-binding="" data-verso-hover="723">simp_arith</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpArith-0" data-verso-hover="723">simp_arith</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_arith___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpArithBang" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith___"><span class="keyword token" data-binding="" data-verso-hover="2408">simp_arith!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpArithBang-0" data-verso-hover="2408">simp_arith!</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAutoUnfold-0" data-verso-hover="2406">simp!</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.dsimp" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="" data-verso-hover="772">dsimp</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code> tactic is the definitional simplifier. It is similar to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code> but only
applies theorems that hold by reflexivity. Thus, the result is guaranteed to be
definitionally equal to the input.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.dsimpAutoUnfold" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp___"><span class="keyword token" data-binding="" data-verso-hover="2409">dsimp!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimpAutoUnfold-0" data-verso-hover="2409">dsimp!</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">autoUnfold</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">true</span></code>.
This will rewrite with all equation lemmas, which can be used to
partially evaluate many definitions.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.dsimpTrace" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp___-next"><span class="keyword token" data-binding="" data-verso-hover="2407">dsimp?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2407">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">if</span></a> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14893532502544598044-59-61"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14893532502544598044-59-61"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>3<span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-64-69"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: simp only [â†“reduceIte, Nat.add_left_cancel_iff]</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2407">simp?</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69"><span class="tactic-state">All goals completed! ðŸ™</span></span> -- prints "Try this: simp only [ite_true]"
<span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticDsimp?!_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp______"><span class="keyword token" data-binding="" data-verso-hover="2407">dsimp?!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2407">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">if</span></a> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14893532502544598044-59-61"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14893532502544598044-59-61"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>3<span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-64-69"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: simp only [â†“reduceIte, Nat.add_left_cancel_iff]</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2407">simp?</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69"><span class="tactic-state">All goals completed! ðŸ™</span></span> -- prints "Try this: simp only [ite_true]"
<span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpAll" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="" data-verso-hover="666">simp_all</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> is a stronger version of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-9" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">*</span></code> where the hypotheses and target
are simplified multiple times until no simplification is applicable.
Only non-dependent propositional hypotheses are considered.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpAllAutoUnfold" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___"><span class="keyword token" data-binding="" data-verso-hover="2410">simp_all!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllAutoUnfold-0" data-verso-hover="2410">simp_all!</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">autoUnfold</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">true</span></code>.
This will rewrite with all equation lemmas, which can be used to
partially evaluate many definitions.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpAllTrace" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___-next"><span class="keyword token" data-binding="" data-verso-hover="2407">simp_all?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2407">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">if</span></a> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14893532502544598044-59-61"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14893532502544598044-59-61"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>3<span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-64-69"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: simp only [â†“reduceIte, Nat.add_left_cancel_iff]</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2407">simp?</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69"><span class="tactic-state">All goals completed! ðŸ™</span></span> -- prints "Try this: simp only [ite_true]"
<span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticSimp_all?!_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all______"><span class="keyword token" data-binding="" data-verso-hover="2407">simp_all?!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2407">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">if</span></a> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="137">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14893532502544598044-59-61"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14893532502544598044-59-61"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="629">(</span><span class="const token" data-binding="const-ite" data-verso-hover="629">if </span><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a><span class="const token" data-binding="const-ite" data-verso-hover="629"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<span class="const token" data-binding="const-ite" data-verso-hover="629"> </span><span class="const token" data-binding="const-ite" data-verso-hover="629">else </span>3<span class="const token" data-binding="const-ite" data-verso-hover="629">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-64-69"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: simp only [â†“reduceIte, Nat.add_left_cancel_iff]</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2407">simp?</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69"><span class="tactic-state">All goals completed! ðŸ™</span></span> -- prints "Try this: simp only [ite_true]"
<span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="772">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all_arith">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpAllArith" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith"><span class="keyword token" data-binding="" data-verso-hover="2411">simp_all_arith</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllArith-0" data-verso-hover="2411">simp_all_arith</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="666">simp_all</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all_arith___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpAllArithBang" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith___"><span class="keyword token" data-binding="" data-verso-hover="2412">simp_all_arith!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllArithBang-0" data-verso-hover="2412">simp_all_arith!</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllAutoUnfold-0" data-verso-hover="2410">simp_all!</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="simpa">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.simpa" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="" data-verso-hover="1195">simpa</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-null-19">using</span> <span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simpa___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticSimpa!_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa___"><span class="keyword token" data-binding="" data-verso-hover="1195">simpa!</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-null-19">using</span> <span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simpa___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticSimpa?_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa___-next"><span class="keyword token" data-binding="" data-verso-hover="1195">simpa?</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-null-19">using</span> <span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simpa______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticSimpa?!_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa______"><span class="keyword token" data-binding="" data-verso-hover="1195">simpa?!</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-null-19">using</span> <span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1195">simpa</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">â‹¯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1029">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simp_wf">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticSimp_wf" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_wf"><span class="keyword token" data-binding="" data-verso-hover="2413">simp_wf</span></a></pre><div class="text">
                  <p>
                    Unfold definitions commonly used in well founded relation definitions.</p>
                  <p>
                    Since Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the
user, and this tactic should no longer be necessary. Calls to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_wf"><span class="keyword token" data-binding="kw-occ-tacticSimp_wf-0" data-verso-hover="2413">simp_wf</span></a></code> can be removed or replaced
by plain calls to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-rw">
                13.5.12.Â Rewriting<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-rw" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="rw">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.rwSeq" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="" data-verso-hover="1138">rw</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="" data-verso-hover="1138">rw</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite"><span class="keyword token" data-binding="" data-verso-hover="1542">rewrite</span></a></code>, but also tries to close the goal by "cheap" (reducible) <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code> afterwards.</p>
                  </div>
                </div>
              <div class="namedocs" id="rewrite">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.rewriteSeq" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rewrite"><span class="keyword token" data-binding="" data-verso-hover="1542">rewrite</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewriteSeq-0" data-verso-hover="1542">rewrite</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">]</span></code> applies identity <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> as a rewrite rule to the target of the main goal.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is preceded by left arrow (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">â†</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;-</span></code>), the rewrite is applied in the reverse direction.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is a defined constant, then the equational theorems associated with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> are used.
This provides a convenient way to unfold <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">rewrite</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">eâ‚</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">eâ‚™</span><span class="unknown token" data-binding="">]</span></code> applies the given rules sequentially.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewriteSeq-0" data-verso-hover="1542">rewrite</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-12" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">l</span></code> rewrites <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> at location(s) <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code> is either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">*</span></code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŠ¢</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">|</span><span class="unknown token" data-binding="">-</span></code>
can also be used, to signify the target of the goal.</p>
                      </li>
                    </ul>
                  <p>
                    Using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1138">rw</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">occs</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">.pos</span> <span class="unknown token" data-binding="">L</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">]</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5229" data-verso-hover="1021">L</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, you can control which "occurrences" are rewritten.
(This option applies to each rule, so usually this will only be used with a single rule.)
Occurrences count from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="7">1</span></code>.
At each allowed occurrence, arguments of the rewrite rule <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> may be instantiated,
restricting which later rewrites can be found.
(Disallowed occurrences do not result in instantiation.)
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">occs</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">neg</span> <span class="unknown token" data-binding="">L</span><span class="unknown token" data-binding="">)</span></code> allows skipping specified occurrences.</p>
                  </div>
                </div>
              <div class="namedocs" id="erw">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticErw___" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#erw"><span class="keyword token" data-binding="" data-verso-hover="2414">erw</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#erw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticErw___-0" data-verso-hover="2414">erw</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">]</span></code> is a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1138">rw</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">transparency</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">.default</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">]</span></code>.
This does rewriting up to unfolding of regular definitions (by comparison to regular <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="" data-verso-hover="1138">rw</span></a></code>
which only unfolds <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> definitions).</p>
                  </div>
                </div>
              <div class="namedocs" id="rwa">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticRwa__" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rwa"><span class="keyword token" data-binding="" data-verso-hover="2415">rwa</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rwa"><span class="keyword token" data-binding="" data-verso-hover="2415">rwa</span></a></code> is short-hand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">rw</span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-null-0">assumption</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___Rewrite___Config___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Meta.Rewrite.Config" title="Permalink">ðŸ”—</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only">Lean.Meta.Rewrite.Config : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Meta.Rewrite.Config : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Configures the behavior of the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite"><span class="keyword token" data-binding="" data-verso-hover="1542">rewrite</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="" data-verso-hover="1138">rw</span></a></code> tactics.</p>
                  <h1>
                    Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___Config___mk"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.mk" data-verso-hover="2416">Lean.Meta.Rewrite.Config.mk</span></a></pre><div class="docs"></div>
                    </section>
                  <h1>
                    Fields</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.transparency" data-verso-hover="2417">transparency</span> : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2418">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        The transparency mode to use for unfolding</p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.offsetCnstrs" data-verso-hover="2419">offsetCnstrs</span> : <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></pre><div class="docs">
                      <p>
                        Whether to support offset constraints such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=?=</span> <span class="unknown token" data-binding="">e</span></code></p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.occs" data-verso-hover="2420">occs</span> : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2421">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        Which occurrences to rewrite</p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.newGoals" data-verso-hover="2422">newGoals</span> : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___NewGoals"><span class="const token" data-binding="const-Lean.Meta.Rewrite.NewGoals" data-verso-hover="2423">Lean.Meta.Rewrite.NewGoals</span></a></pre><div class="docs">
                      <p>
                        How to convert the resulting metavariables into  new goals</p>
                      </div>
                    </section>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___Occurrences___all">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Meta.Occurrences" title="Permalink">ðŸ”—</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only">Lean.Meta.Occurrences : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Meta.Occurrences : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Configuration for which occurrences that match an expression should be rewritten.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">all : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2421">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        All occurrences should be rewritten.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">pos (<span class="var token" data-binding="var-_uniq.5312" data-verso-hover="1021">idxs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2421">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        A list of indices for which occurrences should be rewritten.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">neg (<span class="var token" data-binding="var-_uniq.5313" data-verso-hover="1021">idxs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2421">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        A list of indices for which occurrences should not be rewritten.</p>
                      </div>
                    </div>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___TransparencyMode___all">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Meta.TransparencyMode" title="Permalink">ðŸ”—</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only">Lean.Meta.TransparencyMode : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Meta.TransparencyMode : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Which constants should be unfolded?</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">all : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2418">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds all constants, even those tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">default : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2418">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds all constants except those tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">reducible : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2418">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds only constants tagged with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> attribute.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">instances : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2418">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds reducible constants and constants tagged with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><a href="Type-Classes/Instance-Declarations/#Lean___Parser___Attr___instance"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.instance-2">instance</span></a><span class="unknown token" data-binding="">]</span></code> attribute.</p>
                      </div>
                    </div>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___Rewrite___NewGoals">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Meta.Rewrite.NewGoals" title="Permalink">ðŸ”—</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only">Lean.Meta.Rewrite.NewGoals : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div><div class="narrow-only">Lean.Meta.Rewrite.NewGoals : <span class="sort token" data-binding="" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    Controls which new mvars are turned in to goals by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code> tactic.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">nonDependentFirst</span></code>  mvars that don't depend on other goals appear first in the goal list.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">nonDependentOnly</span></code> only mvars that don't depend on other goals are added to goal list.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">all</span></code> all unassigned mvars are added to the goal list.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="unfold">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.unfold" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="" data-verso-hover="770">unfold</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-0" data-verso-hover="770">unfold</span></a> <span class="unknown token" data-binding="">id</span></code> unfolds all occurrences of definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-id" data-verso-hover="213">id</span></code> in the target.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">unfold</span> <span class="unknown token" data-binding="">id1</span> <span class="unknown token" data-binding="">id2</span> <span class="unknown token" data-binding="">...</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">unfold</span> <span class="unknown token" data-binding="">id1</span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-null-0">unfold</span> <span class="unknown token" data-binding="">id2</span><span class="unknown token" data-binding="">;</span> <span class="unknown token" data-binding="">...</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-0" data-verso-hover="770">unfold</span></a> <span class="unknown token" data-binding="">id</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> unfolds at the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Definitions can be either global or local definitions.</p>
                  <p>
                    For non-recursive global definitions, this tactic is identical to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#delta"><span class="keyword token" data-binding="" data-verso-hover="2424">delta</span></a></code>.
For recursive global definitions, it uses the "unfolding lemma" <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-id.eq_def" data-verso-hover="2425">id.eq_def</span></code>,
which is generated for each recursive definition, to unfold according to the recursive definition given by the user.
Only one level of unfolding is performed, in contrast to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-5">only</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">id</span><span class="unknown token" data-binding="">]</span></code>, which unfolds definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-id" data-verso-hover="213">id</span></code> recursively.</p>
                  <p>
                    Implemented by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Tactic.evalUnfold" data-verso-hover="2426">Lean.Elab.Tactic.evalUnfold</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="replace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.replace" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#replace"><span class="keyword token" data-binding="" data-verso-hover="2427">replace</span></a></pre><div class="text">
                  <p>
                    Acts like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="" data-verso-hover="1102">have</span></a></code>, but removes a hypothesis with the same name as
this one if possible. For example, if the state is:</p>
                  <pre>f : Î± â†’ Î²
h : Î±
âŠ¢ goal
</pre><p>
                    Then after <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#replace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.replace-0" data-verso-hover="2427">replace</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">h</span></code> the state will be:</p>
                  <pre>f : Î± â†’ Î²
h : Î²
âŠ¢ goal
</pre><p>
                    whereas <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-0" data-verso-hover="1102">have</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">h</span></code> would result in:</p>
                  <pre>f : Î± â†’ Î²
hâ€  : Î±
h : Î²
âŠ¢ goal
</pre><p>
                    This can be used to simulate the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.specialize-0">specialize</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply</span> <span class="keyword token" data-binding="kw-occ-null-0">at</span></code> tactics of Coq.</p>
                  </div>
                </div>
              <div class="namedocs" id="delta">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.delta" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#delta"><span class="keyword token" data-binding="" data-verso-hover="2424">delta</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">delta</span> <span class="unknown token" data-binding="">id1</span> <span class="unknown token" data-binding="">id2</span> <span class="unknown token" data-binding="">...</span></code> delta-expands the definitions <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">id1</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">id2</span></code>, ....
This is a low-level tactic, it will expose how recursive definitions have been
compiled by Lean.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-inductive">
                13.5.13.Â Inductive Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-inductive" title="Permalink">ðŸ”—</a></span></h2>
              <section>
                <h3 id="tactic-ref-inductive-intro">
                  13.5.13.1.Â Introduction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-inductive-intro" title="Permalink">ðŸ”—</a></span></h3>
                <div class="namedocs" id="constructor">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.constructor" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#constructor"><span class="keyword token" data-binding="" data-verso-hover="2428">constructor</span></a></pre><div class="text">
                    <p>
                      If the main goal's target type is an inductive type, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#constructor"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.constructor-0" data-verso-hover="2428">constructor</span></a></code> solves it with
the first matching constructor, or else fails.</p>
                    </div>
                  </div>
                <div class="namedocs" id="injection">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.injection" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#injection"><span class="keyword token" data-binding="" data-verso-hover="2429">injection</span></a></pre><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection"><span class="keyword token" data-binding="" data-verso-hover="2429">injection</span></a></code> tactic is based on the fact that constructors of inductive data
types are injections.
That means that if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5416" data-verso-hover="2430">c</span></code> is a constructor of an inductive datatype, and if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">c</span> <span class="unknown token" data-binding="">tâ‚</span><span class="unknown token" data-binding="">)</span></code>
and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">c</span> <span class="unknown token" data-binding="">tâ‚‚</span><span class="unknown token" data-binding="">)</span></code> are two terms that are equal then  <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5533" data-verso-hover="2431">tâ‚</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5639" data-verso-hover="2432">tâ‚‚</span></code> are equal too.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">q</span></code> is a proof of a statement of conclusion <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5533" data-verso-hover="2433">tâ‚</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5639" data-verso-hover="2433">tâ‚‚</span></code>, then injection applies
injectivity to derive the equality of all arguments of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5533" data-verso-hover="2433">tâ‚</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5639" data-verso-hover="2433">tâ‚‚</span></code> placed in
the same positions. For example, from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5774" data-verso-hover="2434">a</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.5908" data-verso-hover="2435">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5416" data-verso-hover="2434">c</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.6044" data-verso-hover="2435">d</span><span class="unknown token" data-binding="">)</span></code> we derive <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5774" data-verso-hover="2436">a</span><span class="unknown token" data-binding="">=</span><span class="var token" data-binding="var-_uniq.5416" data-verso-hover="2436">c</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5908" data-verso-hover="2437">b</span><span class="unknown token" data-binding="">=</span><span class="var token" data-binding="var-_uniq.6044" data-verso-hover="2437">d</span></code>.
To use this tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5533" data-verso-hover="2433">tâ‚</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5639" data-verso-hover="2433">tâ‚‚</span></code> should be constructor applications of the same constructor.
Given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.6185" data-verso-hover="2438">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5774" data-verso-hover="2436">a</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.5908" data-verso-hover="2437">b</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5416" data-verso-hover="2436">c</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.6044" data-verso-hover="2437">d</span></code>, the tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.injection-0" data-verso-hover="2429">injection</span></a> <span class="unknown token" data-binding="">h</span></code> adds two new hypothesis with types
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5774" data-verso-hover="2439">a</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5416" data-verso-hover="2439">c</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5908" data-verso-hover="2440">b</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.6044" data-verso-hover="2440">d</span></code> to the main goal.
The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.injection-0" data-verso-hover="2429">injection</span></a> <span class="unknown token" data-binding="">h</span> <span class="keyword token" data-binding="kw-occ-null-12">with</span> <span class="unknown token" data-binding="">hâ‚</span> <span class="unknown token" data-binding="">hâ‚‚</span></code> uses the names <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hâ‚</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hâ‚‚</span></code> to name the new hypotheses.</p>
                    </div>
                  </div>
                <div class="namedocs" id="injections">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.injections" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#injections"><span class="keyword token" data-binding="" data-verso-hover="2441">injections</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injections"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.injections-0" data-verso-hover="2441">injections</span></a></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection"><span class="keyword token" data-binding="" data-verso-hover="2429">injection</span></a></code> to all hypotheses recursively
(since <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection"><span class="keyword token" data-binding="" data-verso-hover="2429">injection</span></a></code> can produce new hypotheses). Useful for destructing nested
constructor equalities like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6417" data-verso-hover="2442">a</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.6489" data-verso-hover="2442">b</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.6560" data-verso-hover="2443">c</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6632" data-verso-hover="2442">d</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.6707" data-verso-hover="2442">e</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.6782" data-verso-hover="2443">f</span><span class="unknown token" data-binding="">)</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="left">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.left" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#left"><span class="keyword token" data-binding="" data-verso-hover="2444">left</span></a></pre><div class="text">
                    <p>
                      Applies the first constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <span class="unknown token" data-binding="">âˆ¨</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5453225103602410079-28-30"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-28" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5453225103602410079-28-30"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a><a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="378"> âˆ¨ </span></a><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-17180778638691059420-33-37"><a href="Tactic-Proofs/Tactic-Reference/#left"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.left-33" data-verso-hover="2444">left</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17180778638691059420-33-37"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-340" checked="checked"><span for="--verso-unique-340" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-40-47"><a href="Tactic-Proofs/Tactic-Reference/#trivial"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-40" data-verso-hover="258">trivial</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-40-47"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                <div class="namedocs" id="right">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.right" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#right"><span class="keyword token" data-binding="" data-verso-hover="2445">right</span></a></pre><div class="text">
                    <p>
                      Applies the second constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2301">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span> <span class="unknown token" data-binding="">âˆ¨</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3665232260059931967-42-44"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-42" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3665232260059931967-42-44"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2301">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span><a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="378"> âˆ¨ </span></a><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5617083846312722428-47-52"><a href="Tactic-Proofs/Tactic-Reference/#right"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.right-47" data-verso-hover="2445">right</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5617083846312722428-47-52"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-342" checked="checked"><span for="--verso-unique-342" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="204">p</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2301">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="204">q</span></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-55-62"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-55" data-verso-hover="765">exact</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="2301">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-55-62"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                </section>
              <section>
                <h3 id="tactic-ref-inductive-elim">
                  13.5.13.2.Â Elimination<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-inductive-elim" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  Elimination tactics use <a href="The-Type-System/Inductive-Types/#recursors">recursors</a> and the automatically-derived <a href="The-Type-System/Inductive-Types/#recursor-elaboration-helpers"><code>casesOn</code> helper</a> to implement induction and case splitting.
The <a class="technical-term" href="Tactic-Proofs/#--tech-term-subgoals">subgoals</a> that result from these tactics are determined by the types of the minor premises of the eliminators, and using different eliminators with the <code class="plain-keyword">using</code> option results in different subgoals.</p>
                <details class="example"><summary class="description">Choosing Eliminators</summary><div class="example-content">
                    <p>
                    <p>
                      When attempting to prove that <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">âˆ€</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7090" data-verso-hover="2446">i</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7027" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="2446">0</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.7090" data-verso-hover="2446">i</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.7090" data-verso-hover="2446">i</span></code>, after introducing the hypotheses the tactic <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-12048814197792265543-5210-5221"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-5210" data-verso-hover="720">induction</span></a> <span class="var token" data-binding="var-_uniq.7219" data-verso-hover="2446">i</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12048814197792265543-5210-5221"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-343" checked="checked"><span for="--verso-unique-343" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7216" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7239" data-verso-hover="2447">isLtâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.7216" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">, </span></a><span class="var token" data-binding="var-_uniq.7239" data-verso-hover="2447">isLtâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ©</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">, </span></a><span class="var token" data-binding="var-_uniq.7239" data-verso-hover="2447">isLtâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ©</span></a></span></span></span></span></span></span></code> results in:</p>
                    <div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-344" checked="checked"><span for="--verso-unique-344" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7216" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7239" data-verso-hover="2447">isLtâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.7216" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">, </span></a><span class="var token" data-binding="var-_uniq.7239" data-verso-hover="2447">isLtâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ©</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ¨</span></a><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="7">valâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">, </span></a><span class="var token" data-binding="var-_uniq.7239" data-verso-hover="2447">isLtâœ</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ©</span></a></span></span></span></span></div>
                      </div>
                    <p>
                      This is because <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a></code> is a <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Structures">structure</a> with a single non-recursive constructor.
Its recursor has a single minor premise for this constructor:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Fin.rec" data-verso-hover="2448">Fin.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2449">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-5560" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="2450">mk</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">val</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="2451">isLt</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">val</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="var token" data-binding="var-_uniq.6" data-verso-hover="2449">motive</span> <span class="unknown token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ¨</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">val</span><span class="unknown token" data-binding="const-Fin.mk" data-verso-hover="467">,</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="2451">isLt</span><span class="unknown token" data-binding="const-Fin.mk" data-verso-hover="467">âŸ©</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="851">t</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="2449">motive</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="851">t</span></code><p>
                    <p>
                      Using the tactic <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-10895778734358796932-5878-5909"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-5878" data-verso-hover="720">induction</span></a> <span class="var token" data-binding="var-_uniq.7471" data-verso-hover="2446">i</span> <span class="keyword token" data-binding="kw-occ-null-5890">using</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___induction"><span class="const token" data-binding="const-Fin.induction" data-verso-hover="2452">Fin.induction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10895778734358796932-5878-5909"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-345" checked="checked"><span for="--verso-unique-345" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7468" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-346"><span for="--verso-unique-346" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7468" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.7468" data-verso-hover="7">n</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7495" data-verso-hover="2453">aâœ</span></span><span class="colon">:</span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2454">castSucc</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2454">castSucc</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2455">succ</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2455">succ</span></a></span></span></span></span></span></span></code> instead results in:</p>
                    <div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-347" checked="checked"><span for="--verso-unique-347" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7468" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-348" checked="checked"><span for="--verso-unique-348" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7468" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.7468" data-verso-hover="7">n</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7495" data-verso-hover="2453">aâœ</span></span><span class="colon">:</span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2454">castSucc</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2454">castSucc</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2455">succ</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.7494" data-verso-hover="851">iâœ</span>.<a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2455">succ</span></a></span></span></span></span></div>
                      </div>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___induction"><span class="const token" data-binding="const-Fin.induction" data-verso-hover="2452">Fin.induction</span></a></code> is an alternative eliminator that implements induction on the underlying <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___induction"><span class="const token" data-binding="const-Fin.induction" data-verso-hover="2452">Fin.induction</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.61" data-verso-hover="2456">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-6257" data-verso-hover="169">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.132" data-verso-hover="2457">zero</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="2456">motive</span> <span class="typed token" data-binding="" data-verso-hover="2446">0</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.145" data-verso-hover="2458">succ</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.135" data-verso-hover="851">i</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">â†’</span>
    <span class="var token" data-binding="var-_uniq.61" data-verso-hover="2456">motive</span> <span class="var token" data-binding="var-_uniq.135" data-verso-hover="851">i</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2454">castSucc</span></a> <span class="unknown token" data-binding="">â†’</span>
    <span class="var token" data-binding="var-_uniq.61" data-verso-hover="2456">motive</span> <span class="var token" data-binding="var-_uniq.135" data-verso-hover="851">i</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2455">succ</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.194" data-verso-hover="2446">i</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="468">Fin</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="2456">motive</span> <span class="var token" data-binding="var-_uniq.194" data-verso-hover="2446">i</span></code></div>
                  </details><p>
                  <span id="--tech-term-Custom-eliminators" class="def-technical-term">Custom eliminators</span> can be registered using the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2459">induction_eliminator</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2460">cases_eliminator</span></code> attributes.
The eliminator is registered for its explicit targets (i.e. those that are explicit, rather than implicit, parameters to the eliminator function) and will be applied when <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="" data-verso-hover="720">induction</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></code> is used on targets of those types.
When present, custom eliminators take precedence over recursors.
Setting <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Options/#tactic___customEliminators"><span class="option token" data-binding="option-tactic.customEliminators" data-verso-hover="2461">tactic.customEliminators</span></a></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code> disables the use of custom eliminators.</p>
                <div class="namedocs" id="attr-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">attribute</span><span class="title">Custom Eliminators</span><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2459">induction_eliminator</span></code> attribute registers an eliminator for use by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="" data-verso-hover="720">induction</span></a></code> tactic.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">induction_eliminator</span><span class="from-nonterminal" data-kind="null"></span></pre><p>
                      The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2459">induction_eliminator</span></code> attribute registers an eliminator for use by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></code> tactic.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">cases_eliminator</span><span class="from-nonterminal" data-kind="null"></span></pre></div>
                  </div>
                <div class="namedocs" id="cases">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.cases" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></pre><div class="text">
                    <p>
                      Assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> is a variable in the local context with an inductive type,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="383">cases</span></a> <span class="unknown token" data-binding="">x</span></code> splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></code> detects unreachable cases and closes them automatically.</p>
                    <p>
                      For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7526" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> and a goal with a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">P</span> <span class="unknown token" data-binding="">n</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span> <span class="unknown token" data-binding="">n</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="383">cases</span></a> <span class="unknown token" data-binding="">n</span></code> produces one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">P</span> <span class="unknown token" data-binding="">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span> <span class="unknown token" data-binding="">0</span></code>,
and one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">P</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span> <span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span> <span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code>.
Here the name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is chosen automatically and is not accessible.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">with</span></code> to provide the variables names for each constructor.</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="383">cases</span></a> <span class="unknown token" data-binding="">e</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is an expression instead of a variable, generalizes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> in the goal,
and then cases on the resulting variable.</p>
                        </li>
                      <li>
                        <p>
                          Given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="51">as</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.7847" data-verso-hover="2462">Î±</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">cases</span> <span class="unknown token" data-binding="">as</span> <span class="keyword token" data-binding="kw-occ-null-0">with</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">nil</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">cons</span> <span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">as'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚‚</span></code>,
uses tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacâ‚</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">nil</span></code> case, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacâ‚‚</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">cons</span></code> case,
and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">as'</span></code> are used as names for the new variables introduced.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="383">cases</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">e</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is a variable or an expression,
performs cases on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> as above, but also adds a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">...</span></code> to each hypothesis,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">...</span></code> is the constructor instance for that particular case.</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="rcases">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.rcases" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="" data-verso-hover="2331">rcases</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> is a tactic that will perform <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></code> recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8027" data-verso-hover="2463">h1</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.7975" data-verso-hover="204">a</span> <span class="unknown token" data-binding="">âˆ§</span> <span class="var token" data-binding="var-_uniq.7988" data-verso-hover="204">b</span> <span class="unknown token" data-binding="">âˆ§</span> <span class="var token" data-binding="var-_uniq.8001" data-verso-hover="204">c</span> <span class="unknown token" data-binding="">âˆ¨</span> <span class="var token" data-binding="var-_uniq.8014" data-verso-hover="204">d</span></code> or
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h2</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆƒ</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">trans_rel</span> <span class="unknown token" data-binding="">R</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span></code>. Usual usage might be <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a> <span class="unknown token" data-binding="">h1</span> <span class="keyword token" data-binding="kw-occ-null-10">with</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">ha</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hb</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hc</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">hd</span></code> or
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a> <span class="unknown token" data-binding="">h2</span> <span class="keyword token" data-binding="kw-occ-null-10">with</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">z</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hxz</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">hzy</span><span class="unknown token" data-binding="">âŸ©</span><span class="unknown token" data-binding="">âŸ©</span></code> for these examples.</p>
                    <p>
                      Each element of an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> pattern is matched against a particular local hypothesis (most of which
are generated during the execution of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> and represent individual elements destructured from
the input expression). An <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> pattern has the following grammar:</p>
                    <ul>
                      <li>
                        <p>
                          A name like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>, which names the active hypothesis as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>.</p>
                        </li>
                      <li>
                        <p>
                          A blank <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>, which does nothing (letting the automatic naming system used by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></code> name the
hypothesis).</p>
                        </li>
                      <li>
                        <p>
                          A hyphen <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">-</span></code>, which clears the active hypothesis and any dependents.</p>
                        </li>
                      <li>
                        <p>
                          The keyword <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, which expects the hypothesis to be <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8268" data-verso-hover="2464">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.8198" data-verso-hover="2465">a</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.8232" data-verso-hover="2465">b</span></code>, and calls <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#subst"><span class="keyword token" data-binding="" data-verso-hover="2347">subst</span></a></code> on the
hypothesis (which has the effect of replacing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8232" data-verso-hover="2465">b</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8198" data-verso-hover="2465">a</span></code> everywhere or vice versa).</p>
                        </li>
                      <li>
                        <p>
                          A type ascription <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8360" data-verso-hover="2466">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.8314" data-verso-hover="2467">ty</span></code>, which sets the type of the hypothesis to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8314" data-verso-hover="2467">ty</span></code> and then matches it
against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8360" data-verso-hover="2466">p</span></code>. (Of course, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8314" data-verso-hover="2467">ty</span></code> must unify with the actual type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8268" data-verso-hover="2464">h</span></code> for this to work.)</p>
                        </li>
                      <li>
                        <p>
                          A tuple pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">p1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">p2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">p3</span><span class="unknown token" data-binding="">âŸ©</span></code>, which matches a constructor with many arguments, or a series
of nested conjunctions or existentials. For example if the active hypothesis is <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8198" data-verso-hover="204">a</span> <span class="unknown token" data-binding="">âˆ§</span> <span class="var token" data-binding="var-_uniq.8232" data-verso-hover="204">b</span> <span class="unknown token" data-binding="">âˆ§</span> <span class="var token" data-binding="var-_uniq.8418" data-verso-hover="204">c</span></code>,
then the conjunction will be destructured, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">p1</span></code> will be matched against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8198" data-verso-hover="204">a</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">p2</span></code> against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8232" data-verso-hover="204">b</span></code>
and so on.</p>
                        </li>
                      <li>
                        <p>
                          A <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@</span></code> before a tuple pattern as in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@</span><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">p1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">p2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">p3</span><span class="unknown token" data-binding="">âŸ©</span></code> will bind all arguments in the constructor,
while leaving the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@</span></code> off will only use the patterns on the explicit arguments.</p>
                        </li>
                      <li>
                        <p>
                          An alternation pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">p1</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">p2</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">p3</span></code>, which matches an inductive type with multiple constructors,
or a nested disjunction like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8198" data-verso-hover="204">a</span> <span class="unknown token" data-binding="">âˆ¨</span> <span class="var token" data-binding="var-_uniq.8232" data-verso-hover="204">b</span> <span class="unknown token" data-binding="">âˆ¨</span> <span class="var token" data-binding="var-_uniq.8418" data-verso-hover="204">c</span></code>.</p>
                        </li>
                      </ul>
                    <p>
                      A pattern like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">d</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">âŸ©</span></code> will do a split over the inductive datatype,
naming the first three parameters of the first constructor as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">c</span></code> and the
first two of the second constructor <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">d</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">e</span></code>. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">âŸ©</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">b</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">âŸ©</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">d</span></code> then these will cause more case splits as necessary.
If there are too many arguments, such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">âŸ©</span></code> for splitting on
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âˆƒ</span> <span class="var token" data-binding="var-_uniq.8606" data-verso-hover="2468">x</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">âˆƒ</span> <span class="var token" data-binding="var-_uniq.8611" data-verso-hover="2469">y</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">p</span> <span class="unknown token" data-binding="">x</span></code>, then it will be treated as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">âŸ¨</span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">âŸ©</span><span class="unknown token" data-binding="">âŸ©</span></code>, splitting the last
parameter as necessary.</p>
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a></code> also has special support for quotient types: quotient induction into Prop works like
matching on the constructor <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">quot.mk</span></code>.</p>
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">e</span> <span class="keyword token" data-binding="kw-occ-null-13">with</span> <span class="unknown token" data-binding="">PAT</span></code> will do the same as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2331">rcases</span></a> <span class="unknown token" data-binding="">e</span> <span class="keyword token" data-binding="kw-occ-null-9">with</span> <span class="unknown token" data-binding="">PAT</span></code> with the exception that an
assumption <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8666" data-verso-hover="2470">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.8654" data-verso-hover="2471">e</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.8659" data-verso-hover="2471">PAT</span></code> will be added to the context.</p>
                    </div>
                  </div>
                <div class="namedocs" id="fun_cases">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.funCases" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#fun_cases"><span class="keyword token" data-binding="" data-verso-hover="2472">fun_cases</span></a></pre><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.fun_cases" data-verso-hover="2473">fun_cases</span></code> tactic is a convenience wrapper of the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></code> tactic when using a functional
cases principle.</p>
                    <p>
                      The tactic invocation</p>
                    <pre>fun_cases f x ... y ...`
</pre><p>
                      is equivalent to</p>
                    <pre>cases y, ... using f.fun_cases x ...
</pre><p>
                      where the arguments of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> are used as arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.fun_cases</span></code> or targets of the case analysis, as
appropriate.</p>
                    <p>
                      The form</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.fun_cases" data-verso-hover="2473">fun_cases</span> <span class="var token" data-binding="var-_uniq.8703" data-verso-hover="204">f</span></code><p>
                      (with no arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>) searches the goal for an unique eligible application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>, and uses
these arguments. An application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p>
                    <p>
                      The form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun_cases</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span> <span class="keyword token" data-binding="kw-occ-null-0">with</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">case1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">case2</span> <span class="unknown token" data-binding="">x'</span> <span class="unknown token" data-binding="">ih</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚‚</span></code> works like with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="" data-verso-hover="383">cases</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="induction">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.induction" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="" data-verso-hover="720">induction</span></a></pre><div class="text">
                    <p>
                      Assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> is a variable in the local context with an inductive type,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="720">induction</span></a> <span class="unknown token" data-binding="">x</span></code> applies induction on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.</p>
                    <p>
                      For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8768" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> and a goal with a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">P</span> <span class="unknown token" data-binding="">n</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span> <span class="unknown token" data-binding="">n</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="720">induction</span></a> <span class="unknown token" data-binding="">n</span></code> produces one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">P</span> <span class="unknown token" data-binding="">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span> <span class="unknown token" data-binding="">0</span></code>,
and one goal with hypotheses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">P</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span> <span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ihâ‚</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">P</span> <span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">â†’</span> <span class="unknown token" data-binding="">Q</span> <span class="unknown token" data-binding="">a</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span> <span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code>.
Here the names <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9029" data-verso-hover="848">ihâ‚</span></code> are chosen automatically and are not accessible.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">with</span></code> to provide the variables names for each constructor.</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="720">induction</span></a> <span class="unknown token" data-binding="">e</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is an expression instead of a variable,
generalizes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> in the goal, and then performs induction on the resulting variable.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="720">induction</span></a> <span class="unknown token" data-binding="">e</span> <span class="keyword token" data-binding="kw-occ-null-12">using</span> <span class="unknown token" data-binding="">r</span></code> allows the user to specify the principle of induction that should be used.
Here <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">r</span></code> should be a term whose result type must be of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">C</span> <span class="unknown token" data-binding="">t</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9371" data-verso-hover="2474">C</span></code> is a bound variable and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code> is a (possibly empty) sequence of bound variables</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">induction</span> <span class="unknown token" data-binding="">e</span> <span class="keyword token" data-binding="kw-occ-null-0">generalizing</span> <span class="unknown token" data-binding="">zâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">zâ‚™</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">zâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">zâ‚™</span></code> are variables in the local context,
generalizes over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">zâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">zâ‚™</span></code> before applying the induction but then introduces them in each goal.
In other words, the net effect is that each inductive hypothesis is generalized.</p>
                        </li>
                      <li>
                        <p>
                          Given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9447" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">induction</span> <span class="unknown token" data-binding="">x</span> <span class="keyword token" data-binding="kw-occ-null-0">with</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">zero</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">succ</span> <span class="unknown token" data-binding="">x'</span> <span class="unknown token" data-binding="">ih</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚‚</span></code>
uses tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacâ‚</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">zero</span></code> case, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacâ‚‚</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">succ</span></code> case.</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="fun_induction">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.funInduction" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#fun_induction"><span class="keyword token" data-binding="" data-verso-hover="877">fun_induction</span></a></pre><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#fun_induction"><span class="keyword token" data-binding="" data-verso-hover="877">fun_induction</span></a></code> tactic is a convenience wrapper of the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="" data-verso-hover="720">induction</span></a></code> tactic when using a functional
induction principle.</p>
                    <p>
                      The tactic invocation</p>
                    <pre>fun_induction f xâ‚ ... xâ‚™ yâ‚ ... yâ‚˜
</pre><p>
                      where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is a function defined by non-mutual structural or well-founded recursion, is equivalent to</p>
                    <pre>induction yâ‚, ... yâ‚˜ using f.induct xâ‚ ... xâ‚™
</pre><p>
                      where the arguments of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> are used as arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.induct</span></code> or targets of the induction, as
appropriate.</p>
                    <p>
                      The form</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">fun_induction</span> <span class="unknown token" data-binding="">f</span></code><p>
                      (with no arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>) searches the goal for an unique eligible application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>, and uses
these arguments. An application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p>
                    <p>
                      The forms <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun_induction</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span> <span class="keyword token" data-binding="kw-occ-null-0">generalizing</span> <span class="unknown token" data-binding="">zâ‚</span> <span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">zâ‚™</span></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun_induction</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span> <span class="keyword token" data-binding="kw-occ-null-0">with</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">case1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">case2</span> <span class="unknown token" data-binding="">x'</span> <span class="unknown token" data-binding="">ih</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">tacâ‚‚</span></code> work like with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="720">induction</span></a><span class="unknown token" data-binding="">.</span></code></p>
                    </div>
                  </div>
                <div class="namedocs" id="nofun">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticNofun" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#nofun"><span class="keyword token" data-binding="" data-verso-hover="2475">nofun</span></a></pre><div class="text">
                    <p>
                      The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#nofun"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNofun-0" data-verso-hover="2475">nofun</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___nofun"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.nofun-6">nofun</span></a></code>: it introduces the assumptions, then performs an
empty pattern match, closing the goal if the introduced pattern is impossible.</p>
                    </div>
                  </div>
                <div class="namedocs" id="nomatch">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.Â«tacticNomatch_,,Â»" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#nomatch"><span class="keyword token" data-binding="" data-verso-hover="2476">nomatch</span></a></pre><div class="text">
                    <p>
                      The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#nomatch"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Â«tacticNomatch_,,Â»-0" data-verso-hover="2476">nomatch</span></a> <span class="unknown token" data-binding="">h</span></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.nomatch-6" data-verso-hover="1538">nomatch</span></a> <span class="unknown token" data-binding="">h</span></code>.</p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-ref-search">
                13.5.14.Â Library Search<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-search" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                The library search tactics are intended for interactive use.
When run, they search the Lean library for lemmas or rewrite rules that could be applicable in the current situation, and suggests a new tactic.
These tactics should not be left in a proof; rather, their suggestions should be incorporated.</p>
              <div class="namedocs" id="exact___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.exact?" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exact___"><span class="keyword token" data-binding="" data-verso-hover="2477">exact?</span></a></pre><div class="text">
                  <p>
                    Searches environment for definitions or theorems that can solve the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="" data-verso-hover="765">exact</span></a></code>
with conditions resolved by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code>.</p>
                  <p>
                    The optional <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">using</span></code> clause provides identifiers in the local context that must be
used by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact?-0" data-verso-hover="2477">exact?</span></a></code> when closing the goal.  This is most useful if there are multiple
ways to resolve the goal, and one wants to guide which lemma is used.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.apply?" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply___"><span class="keyword token" data-binding="" data-verso-hover="2478">apply?</span></a></pre><div class="text">
                  <p>
                    Searches environment for definitions or theorems that can refine the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="" data-verso-hover="692">apply</span></a></code>
with conditions resolved when possible with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2323">solve_by_elim</span></a></code>.</p>
                  <p>
                    The optional <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">using</span></code> clause provides identifiers in the local context that must be
used when closing the goal.</p>
                  </div>
                </div>
              <p>
              <p>
                In this proof state:</p>
              <div class="hl lean tactic-view">
                <div class="tactic-state">
                  <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9697" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9700" data-verso-hover="7">j</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9703" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9706" data-verso-hover="1060">h1</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.9697" data-verso-hover="7">i</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.9700" data-verso-hover="7">j</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9709" data-verso-hover="2264">h2</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.9700" data-verso-hover="7">j</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.9703" data-verso-hover="7">k</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.9697" data-verso-hover="7">i</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="630"> &lt; </span></a><span class="var token" data-binding="var-_uniq.9703" data-verso-hover="7">k</span></span></span></span></div>
                </div>
              <p>
                invoking <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-7-8084-8090"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: exact Nat.lt_trans h1 h2</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#apply___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply?-8084" data-verso-hover="2478">apply?</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-8084-8090"><span class="tactic-state">All goals completed! ðŸ™</span></span></code> suggests:</p>
              <div class="information">
                <pre>Try this: exact Nat.lt_trans h1 h2
</pre></div>
              <div class="namedocs" id="rw___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.rewrites?" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rw___"><span class="keyword token" data-binding="" data-verso-hover="2479">rw?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2479">rw?</span></a></code> tries to find a lemma which can rewrite the goal.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2479">rw?</span></a></code> should not be left in proofs; it is a search tool, like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply?-0" data-verso-hover="2478">apply?</span></a></code>.</p>
                  <p>
                    Suggestions are printed as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1138">rw</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1138">rw</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">â†</span> <span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code>.</p>
                  <p>
                    You can use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2479">rw?</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">my_lemma</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">my_theorem</span><span class="unknown token" data-binding="">]</span></code> to prevent <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2479">rw?</span></a></code> using the named lemmas.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-cases">
                13.5.15.Â Case Analysis<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-cases" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="split">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.split" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="" data-verso-hover="632">split</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="632">split</span></a></code> tactic is useful for breaking nested if-then-else and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code> expressions into separate cases.
For a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code> expression with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> cases, the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="632">split</span></a></code> tactic generates at most <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> subgoals.</p>
                  <p>
                    For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15449" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, and a target <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="137">if</span></a> <span class="var token" data-binding="var-_uniq.15449" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="137">then</span></a> <span class="var token" data-binding="var-_uniq.15515" data-verso-hover="2480">Q</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="137">else</span></a> <span class="var token" data-binding="var-_uniq.15564" data-verso-hover="2480">R</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="632">split</span></a></code> will generate
one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15449" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15515" data-verso-hover="2480">Q</span></code>, and a second goal with hypothesis
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Â¬</span><span class="var token" data-binding="var-_uniq.15449" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15564" data-verso-hover="2480">R</span></code>.  Note that the introduced hypothesis is unnamed, and is commonly
renamed used the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#case"><span class="keyword token" data-binding="" data-verso-hover="2231">case</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="" data-verso-hover="1180">next</span></a></code> tactics.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="632">split</span></a></code> will split the goal (target).</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="632">split</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-6" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">h</span></code> will split the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="by_cases">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Â«tacticBy_cases_:_Â»" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#by_cases"><span class="keyword token" data-binding="" data-verso-hover="1402">by_cases</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">by_cases</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">?</span> <span class="unknown token" data-binding="">p</span></code> splits the main goal into two cases, assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15659" data-verso-hover="1813">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.15655" data-verso-hover="2481">p</span></code> in the first branch, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">Â¬</span> <span class="unknown token" data-binding="">p</span></code> in the second branch.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-decision">
                13.5.16.Â Decision Procedures<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-decision" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="decide">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.decide" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="" data-verso-hover="259">decide</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1817">decide</span></a></code> attempts to prove the main goal (with target type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15806" data-verso-hover="2482">p</span></code>) by synthesizing an instance of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a> <span class="var token" data-binding="var-_uniq.15806" data-verso-hover="204">p</span></code>
and then reducing that instance to evaluate the truth value of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15806" data-verso-hover="204">p</span></code>.
If it reduces to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable.isTrue" data-verso-hover="1637">isTrue</span></a> <span class="var token" data-binding="var-_uniq.15814" data-verso-hover="2483">h</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15814" data-verso-hover="2483">h</span></code> is a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15806" data-verso-hover="204">p</span></code> that closes the goal.</p>
                  <p>
                    The target is not allowed to contain local variables or metavariables.
If there are local variables, you can first try using the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#revert"><span class="keyword token" data-binding="" data-verso-hover="2297">revert</span></a></code> tactic with these local variables to move them into the target,
or you can use the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">revert</span></code> option, described below.</p>
                  <p>
                    Options:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="259">decide</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">revert</span></code> begins by reverting local variables that the target depends on,
after cleaning up the local context of irrelevant variables.
A variable is <em>relevant</em> if it appears in the target, if it appears in a relevant variable,
or if it is a proposition that refers to a relevant variable.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="259">decide</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">kernel</span></code> uses kernel for reduction instead of the elaborator.
It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,
and (2) it reduces the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a></code> instance only once instead of twice.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="259">decide</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">native</span></code> uses the native code compiler (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#eval</span></code>) to evaluate the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a></code> instance,
admitting the result via the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.ofReduceBool" data-verso-hover="1410">Lean.ofReduceBool</span></code> axiom.
This can be significantly more efficient than using reduction, but it is at the cost of increasing the size
of the trusted code base.
Namely, it depends on the correctness of the Lean compiler and all definitions with an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">implemented_by</span><span class="unknown token" data-binding="">]</span></code> attribute.
Like with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">kernel</span></code>, the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a></code> instance is evaluated only once.</p>
                      </li>
                    </ul>
                  <p>
                    Limitation: In the default mode or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">kernel</span></code> mode, since <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1817">decide</span></a></code> uses reduction to evaluate the term,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a></code> instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.
Reduction can also get stuck on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a></code> instances with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Eq.rec" data-verso-hover="437">Eq.rec</span></code> terms.
These can appear in instances defined using tactics (such as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="" data-verso-hover="1138">rw</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a></code>).
To avoid this, create such instances using definitions such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-decidable_of_iff" data-verso-hover="2484">decidable_of_iff</span></code> instead.</p>
                  <p>
                    <strong>Examples</strong></p>
                  <p>
                    Proving inequalities:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">â‰ </span> <span class="typed token" data-binding="" data-verso-hover="7">5</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5354802996925771522-25-27"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-25" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5354802996925771522-25-27"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>2<span class="const token" data-binding="const-Ne" data-verso-hover="512"> â‰  </span>5</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-28-34"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-28" data-verso-hover="259">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-28-34"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                    Trying to prove a false proposition:</p>
                  <pre>example : 1 â‰  1 := by decide
/-
tactic 'decide' proved that the proposition
  1 â‰  1
is false
-/
</pre><p>
                    Trying to prove a proposition whose <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a></code> instance fails to reduce</p>
                  <pre>opaque unknownProp : Prop

open scoped Classical in
example : unknownProp := by decide
/-
tactic 'decide' failed for proposition
  unknownProp
since its 'Decidable' instance reduced to
  Classical.choice â‹¯
rather than to the 'isTrue' constructor.
-/
</pre><p>
                    <strong>Properties and relations</strong></p>
                  <p>
                    For equality goals for types with decidable equality, usually <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code> can be used in place of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1817">decide</span></a></code>.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-7604198462819786412-23-25"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-23" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7604198462819786412-23-25"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>2</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-26-32"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-26" data-verso-hover="259">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-26-32"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-33">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-7604198462819786412-56-58"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-56" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7604198462819786412-56-58"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>2</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-59-62"><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-59" data-verso-hover="14">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-59-62"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="native_decide">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.nativeDecide" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#native_decide"><span class="keyword token" data-binding="" data-verso-hover="1406">native_decide</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#native_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.nativeDecide-0" data-verso-hover="1406">native_decide</span></a></code> is a synonym for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="259">decide</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">native</span></code>.
It will attempt to prove a goal of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15876" data-verso-hover="2485">p</span></code> by synthesizing an instance
of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="465">Decidable</span></a> <span class="var token" data-binding="var-_uniq.15876" data-verso-hover="204">p</span></code> and then evaluating it to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable.isTrue" data-verso-hover="1637">isTrue</span></a> <span class="unknown token" data-binding="">..</span></code>. Unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1817">decide</span></a></code>, this
uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#eval</span></code> to evaluate the decidability instance.</p>
                  <p>
                    This should be used with care because it adds the entire lean compiler to the trusted
part, and the axiom <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.ofReduceBool" data-verso-hover="1410">Lean.ofReduceBool</span></code> will show up in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#print</span> <span class="unknown token" data-binding="">axioms</span></code> for theorems using
this method or anything that transitively depends on them. Nevertheless, because it is
compiled, this can be significantly more efficient than using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1817">decide</span></a></code>, and for very
large computations this is one way to run external programs and trust the result.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___range"><span class="const token" data-binding="const-List.range" data-verso-hover="2486">List.range</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1000</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1354">length</span></a> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">1000</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-8220669306711705989-45-47"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-45" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8220669306711705989-45-47"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">(<a href="Basic-Types/Linked-Lists/#List___range"><span class="const token" data-binding="const-List.range" data-verso-hover="2486">List.range</span></a> 1000).<a href="Basic-Types/Linked-Lists/#List___length"><span class="const token" data-binding="const-List.length" data-verso-hover="1354">length</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1000</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-48-61"><a href="Tactic-Proofs/Tactic-Reference/#native_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.nativeDecide-48" data-verso-hover="1406">native_decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-48-61"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="omega">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.omega" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="" data-verso-hover="386">omega</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-0" data-verso-hover="386">omega</span></a></code> tactic, for resolving integer and natural linear arithmetic problems.</p>
                  <p>
                    It is not yet a full decision procedure (no "dark" or "grey" shadows),
but should be effective on many problems.</p>
                  <p>
                    We handle hypotheses of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15904" data-verso-hover="2487">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.15914" data-verso-hover="2487">y</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">y</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="unknown token" data-binding="">y</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">k</span> <span class="unknown token" data-binding="">âˆ£</span> <span class="unknown token" data-binding="">x</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span></code> in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a></code>
(and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16865" data-verso-hover="2488">k</span></code> a literal), along with negations of these statements.</p>
                  <p>
                    We decompose the sides of the inequalities as linear combinations of atoms.</p>
                  <p>
                    If we encounter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">/</span> <span class="unknown token" data-binding="">k</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">%</span> <span class="unknown token" data-binding="">k</span></code> for literal integers <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.18044" data-verso-hover="2489">k</span></code> we introduce new auxiliary variables
and the relevant inequalities.</p>
                  <p>
                    On the first pass, we do not perform case splits on natural subtraction.
If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-0" data-verso-hover="386">omega</span></a></code> fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.</p>
                  <p>
                    The options</p>
                  <pre>omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
</pre><p>
                    can be used to:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitDisjunctions</span></code>: split any disjunctions found in the context,
if the problem is not otherwise solvable.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitNatSub</span></code>: for each appearance of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.19625" data-verso-hover="7">b</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="146">Int</span></a><span class="unknown token" data-binding="">)</span></code>, split on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="var token" data-binding="var-_uniq.19625" data-verso-hover="7">b</span></code> if necessary.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitNatAbs</span></code>: for each appearance of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Integers/#Int___natAbs"><span class="const token" data-binding="const-Int.natAbs" data-verso-hover="2490">Int.natAbs</span></a> <span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span></code>, split on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">â‰¤</span> <span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span></code> if necessary.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitMinMax</span></code>: for each occurrence of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Min___mk"><span class="const token" data-binding="const-Min.min" data-verso-hover="2491">min</span></a> <span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.19625" data-verso-hover="7">b</span></code>, split on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Min___mk"><span class="const token" data-binding="const-Min.min" data-verso-hover="2491">min</span></a> <span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.19625" data-verso-hover="7">b</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">âˆ¨</span> <a href="Type-Classes/Basic-Classes/#Min___mk"><span class="const token" data-binding="const-Min.min" data-verso-hover="2491">min</span></a> <span class="var token" data-binding="var-_uniq.19544" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.19625" data-verso-hover="7">b</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.19625" data-verso-hover="7">b</span></code>
Currently, all of these are on by default.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="bv_omega">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticBv_omega" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_omega"><span class="keyword token" data-binding="" data-verso-hover="2492">bv_omega</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticBv_omega-0" data-verso-hover="2492">bv_omega</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-0" data-verso-hover="386">omega</span></a></code> with an additional preprocessor that turns statements about <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a></code> into statements about <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.
Currently the preprocessor is implemented as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#try"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTry_-0" data-verso-hover="2270">try</span></a> <a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-4" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-9">only</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">bitvec_to_nat</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-30" data-verso-hover="695">at</span> <span class="unknown token" data-binding="">*</span></code>.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">bitvec_to_nat</span></code> is a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-2" data-verso-hover="1811">simp</span><span class="unknown token" data-binding="">]</span></code> attribute that you can (cautiously) add to more theorems.</p>
                  </div>
                </div>
              <section>
                <h3 id="tactic-ref-sat">
                  13.5.16.1.Â SAT Solver Integration<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-sat" title="Permalink">ðŸ”—</a></span></h3>
                <div class="namedocs" id="bv_decide">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.bvDecide" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="" data-verso-hover="109">bv_decide</span></a></pre><div class="text">
                    <p>
                      Close fixed-width <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> goals by obtaining a proof from an external SAT solver and
verifying it inside Lean. The solvable goals are currently limited to</p>
                    <ul>
                      <li>
                        <p>
                          the Lean equivalent of <a href="https://smt-lib.org/logics-all.shtml#QF_BV"><code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">QF_BV</span></code></a></p>
                        </li>
                      <li>
                        <p>
                          automatically splitting up <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">structure</span></code>s that contain information about <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code></p>
                        </li>
                      </ul>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="2493">a</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="2493">b</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a> <span class="typed token" data-binding="" data-verso-hover="7">64</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="2493">a</span> <span class="unknown token" data-binding="">&&&</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="2493">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="2493">a</span> <span class="unknown token" data-binding="">^^^</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="2493">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="2493">a</span> <span class="unknown token" data-binding="">|||</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="2493">b</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-6933519964024914269-68-70"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-68" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6933519964024914269-68-70"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.929" data-verso-hover="2493">a </span><span class="var token" data-binding="var-_uniq.930" data-verso-hover="2493">b</span> : <a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a> 64), <a href="Type-Classes/Basic-Classes/#HAnd___mk"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2494">(</span></a><span class="var token" data-binding="var-_uniq.929" data-verso-hover="2493">a</span><a href="Type-Classes/Basic-Classes/#HAnd___mk"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2494"> &&& </span></a><span class="var token" data-binding="var-_uniq.930" data-verso-hover="2493">b</span><a href="Type-Classes/Basic-Classes/#HAnd___mk"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2494">)</span></a><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="Type-Classes/Basic-Classes/#HXor___mk"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="113">(</span></a><span class="var token" data-binding="var-_uniq.929" data-verso-hover="2493">a</span><a href="Type-Classes/Basic-Classes/#HXor___mk"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="113"> ^^^ </span></a><span class="var token" data-binding="var-_uniq.930" data-verso-hover="2493">b</span><a href="Type-Classes/Basic-Classes/#HXor___mk"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="113">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.929" data-verso-hover="2493">a</span><a href="Type-Classes/Basic-Classes/#HOr___mk"><span class="const token" data-binding="const-HOr.hOr" data-verso-hover="2495"> ||| </span></a><span class="var token" data-binding="var-_uniq.930" data-verso-hover="2493">b</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-9345841105949238504-73-79"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-73" data-verso-hover="379">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9345841105949238504-73-79"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.183" data-verso-hover="2493">aâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a> 64</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.184" data-verso-hover="2493">bâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a> 64</span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Type-Classes/Basic-Classes/#HAnd___mk"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2494">(</span></a><span class="var token" data-binding="var-_uniq.183" data-verso-hover="2493">aâœ</span><a href="Type-Classes/Basic-Classes/#HAnd___mk"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2494"> &&& </span></a><span class="var token" data-binding="var-_uniq.184" data-verso-hover="2493">bâœ</span><a href="Type-Classes/Basic-Classes/#HAnd___mk"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2494">)</span></a><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="Type-Classes/Basic-Classes/#HXor___mk"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="113">(</span></a><span class="var token" data-binding="var-_uniq.183" data-verso-hover="2493">aâœ</span><a href="Type-Classes/Basic-Classes/#HXor___mk"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="113"> ^^^ </span></a><span class="var token" data-binding="var-_uniq.184" data-verso-hover="2493">bâœ</span><a href="Type-Classes/Basic-Classes/#HXor___mk"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="113">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.183" data-verso-hover="2493">aâœ</span><a href="Type-Classes/Basic-Classes/#HOr___mk"><span class="const token" data-binding="const-HOr.hOr" data-verso-hover="2495"> ||| </span></a><span class="var token" data-binding="var-_uniq.184" data-verso-hover="2493">bâœ</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-82-91"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-82" data-verso-hover="109">bv_decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-82-91"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="109">bv_decide</span></a></code> encounters an unknown definition it will be treated like an unconstrained <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a></code>
variable. Sometimes this enables solving goals despite not understanding the definition because
the precise properties of the definition do not matter in the specific proof.</p>
                    <p>
                      If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="109">bv_decide</span></a></code> fails to close a goal it provides a counter-example, containing assignments for all
terms that were considered as variables.</p>
                    <p>
                      In order to avoid calling a SAT solver every time, the proof can be cached with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvTrace-0" data-verso-hover="2496">bv_decide?</span></a></code>.</p>
                    <p>
                      If solving your problem relies inherently on using associativity or commutativity, consider enabling
the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">bv.ac_nf</span></code> option.</p>
                    <p>
                      Note: <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="109">bv_decide</span></a></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ofReduceBool</span></code> and thus trusts the correctness of the code generator.</p>
                    <p>
                      Note: include <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">import</span> <span class="unknown token" data-binding="">Std.Tactic.BVDecide</span></code></p>
                    </div>
                  </div>
                <div class="namedocs" id="bv_normalize">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.bvNormalize" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_normalize"><span class="keyword token" data-binding="" data-verso-hover="2497">bv_normalize</span></a></pre><div class="text">
                    <p>
                      Run the normalization procedure of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="109">bv_decide</span></a></code> only. Sometimes this is enough to solve basic
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin"><span class="const token" data-binding="const-BitVec" data-verso-hover="106">BitVec</span></a></code> goals already.</p>
                    <p>
                      Note: include <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">import</span> <span class="unknown token" data-binding="">Std.Tactic.BVDecide</span></code></p>
                    </div>
                  </div>
                <div class="namedocs" id="bv_check">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.bvCheck" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_check"><span class="keyword token" data-binding="" data-verso-hover="2498">bv_check</span></a></pre><div class="text">
                    <p>
                      This tactic works just like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="109">bv_decide</span></a></code> but skips calling a SAT solver by using a proof that is
already stored on disk. It is called with the name of an LRAT file in the same directory as the
current Lean file:</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">bv_check</span> <span class="literal string token" data-binding="" data-verso-hover="2499">"proof.lrat"</span></code></div>
                  </div>
                <div class="namedocs" id="bv_decide___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.bvTrace" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide___"><span class="keyword token" data-binding="" data-verso-hover="2496">bv_decide?</span></a></pre><div class="text">
                    <p>
                      Suggest a proof script for a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="109">bv_decide</span></a></code> tactic call. Useful for caching LRAT proofs.</p>
                    <p>
                      Note: include <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">import</span> <span class="unknown token" data-binding="">Std.Tactic.BVDecide</span></code></p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-reducibility">
                13.5.17.Â Controlling Reduction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-reducibility" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="with_reducible-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.withReducible" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1112">with_reducible</span></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_reducible</span> <span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the reducible transparency setting.
In this setting only definitions tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> are unfolded.</p>
                  </div>
                </div>
              <div class="namedocs" id="with_reducible_and_instances-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.withReducibleAndInstances" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1367">with_reducible_and_instances</span></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_reducible_and_instances</span> <span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.instances</span></code> transparency setting.
In this setting only definitions tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> or type class instances are unfolded.</p>
                  </div>
                </div>
              <div class="namedocs" id="with_unfolding_all-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.withUnfoldingAll" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1368">with_unfolding_all</span></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_unfolding_all</span> <span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.all</span></code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-control">
                13.5.18.Â Control Flow<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-control" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="skip">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.skip" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="" data-verso-hover="1007">skip</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-0" data-verso-hover="1007">skip</span></a></code> does nothing.</p>
                  </div>
                </div>
              <div class="namedocs" id="guard_hyp">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.guardHyp" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="" data-verso-hover="2500">guard_hyp</span></a></pre><div class="text">
                  <p>
                    Tactic to check that a named hypothesis has a given type and/or value.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">t</span></code> checks the type up to reducible defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:~</span> <span class="unknown token" data-binding="">t</span></code> checks the type up to default defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:â‚›</span> <span class="unknown token" data-binding="">t</span></code> checks the type up to syntactic equality,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:â‚</span> <span class="unknown token" data-binding="">t</span></code> checks the type up to alpha equality.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">v</span></code> checks value up to reducible defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:=~</span> <span class="unknown token" data-binding="">v</span></code> checks value up to default defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:=â‚›</span> <span class="unknown token" data-binding="">v</span></code> checks value up to syntactic equality,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2500">guard_hyp</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:=â‚</span> <span class="unknown token" data-binding="">v</span></code> checks the value up to alpha equality.</p>
                      </li>
                    </ul>
                  <p>
                    The value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">v</span></code> is elaborated using the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> as the expected type.</p>
                  </div>
                </div>
              <div class="namedocs" id="guard_target">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.guardTarget" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="" data-verso-hover="997">guard_target</span></a></pre><div class="text">
                  <p>
                    Tactic to check that the target agrees with a given expression.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="997">guard_target</span></a> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">e</span></code> checks that the target is defeq at reducible transparency to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="997">guard_target</span></a> <span class="unknown token" data-binding="">=~</span> <span class="unknown token" data-binding="">e</span></code> checks that the target is defeq at default transparency to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="997">guard_target</span></a> <span class="unknown token" data-binding="">=â‚›</span> <span class="unknown token" data-binding="">e</span></code> checks that the target is syntactically equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="997">guard_target</span></a> <span class="unknown token" data-binding="">=â‚</span> <span class="unknown token" data-binding="">e</span></code> checks that the target is alpha-equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    The term <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is elaborated with the type of the goal as the expected type, which is mostly
useful within <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.conv" data-verso-hover="2341">conv</span></code> mode.</p>
                  </div>
                </div>
              <div class="namedocs" id="guard_expr">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.guardExpr" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr"><span class="keyword token" data-binding="" data-verso-hover="2501">guard_expr</span></a></pre><div class="text">
                  <p>
                    Tactic to check equality of two expressions.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2501">guard_expr</span></a> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are defeq at reducible transparency.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2501">guard_expr</span></a> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=~</span> <span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are defeq at default transparency.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2501">guard_expr</span></a> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=â‚›</span> <span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are syntactically equal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2501">guard_expr</span></a> <span class="unknown token" data-binding="">e</span> <span class="unknown token" data-binding="">=â‚</span> <span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are alpha-equivalent.</p>
                      </li>
                    </ul>
                  <p>
                    Both <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are elaborated then have their metavariables instantiated before the equality
check. Their types are unified (using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">isDefEqGuarded</span></code>) before synthetic metavariables are
processed, which helps with default instance handling.</p>
                  </div>
                </div>
              <div class="namedocs" id="done">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.done" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="" data-verso-hover="1113">done</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-0" data-verso-hover="1113">done</span></a></code> succeeds iff there are no remaining goals.</p>
                  </div>
                </div>
              <div class="namedocs" id="sleep">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.sleep" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#sleep"><span class="keyword token" data-binding="" data-verso-hover="2502">sleep</span></a></pre><div class="text">
                  <p>
                    The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">sleep</span> <span class="unknown token" data-binding="">ms</span></code> sleeps for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ms</span></code> milliseconds and does nothing.
It is used for debugging purposes only.</p>
                  </div>
                </div>
              <div class="namedocs" id="stop">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticStop_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#stop"><span class="keyword token" data-binding="" data-verso-hover="2503">stop</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#stop"><span class="keyword token" data-binding="" data-verso-hover="2503">stop</span></a></code> is a helper tactic for "discarding" the rest of a proof:
it is defined as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#repeat"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRepeat_-0" data-verso-hover="2292">repeat</span></a> <a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-7" data-verso-hover="11">sorry</span></a></code>.
It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-term-helpers">
                13.5.19.Â Term Elaboration Backends<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-term-helpers" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                These tactics are used during elaboration of terms to satisfy obligations that arise.</p>
              <div class="namedocs" id="decreasing_with">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticDecreasing_with_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#decreasing_with"><span class="keyword token" data-binding="" data-verso-hover="2504">decreasing_with</span></a></pre><div class="text">
                  <p>
                    Constructs a proof of decreasing along a well founded relation, by simplifying, then applying
lexicographic order lemmas and finally using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ts</span></code> to solve the base case. If it fails,
it prints a message to help the user diagnose an ill-founded recursive definition.</p>
                  </div>
                </div>
              <div class="namedocs" id="get_elem_tactic">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticGet_elem_tactic" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic"><span class="keyword token" data-binding="" data-verso-hover="1951">get_elem_tactic</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic-0" data-verso-hover="1951">get_elem_tactic</span></a></code> is the tactic automatically called by the notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">arr</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">i</span><span class="unknown token" data-binding="">]</span></code>
to prove any side conditions that arise when constructing the term
(e.g. the index is in bounds of the array). It just delegates to
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic_trivial-0" data-verso-hover="1953">get_elem_tactic_trivial</span></a></code> and gives a diagnostic error message otherwise;
users are encouraged to extend <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic_trivial-0" data-verso-hover="1953">get_elem_tactic_trivial</span></a></code> instead of this tactic.</p>
                  </div>
                </div>
              <div class="namedocs" id="get_elem_tactic_trivial">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticGet_elem_tactic_trivial" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial"><span class="keyword token" data-binding="" data-verso-hover="1953">get_elem_tactic_trivial</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic_trivial-0" data-verso-hover="1953">get_elem_tactic_trivial</span></a></code> is an extensible tactic automatically called
by the notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">arr</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">i</span><span class="unknown token" data-binding="">]</span></code> to prove any side conditions that arise when
constructing the term (e.g. the index is in bounds of the array).
The default behavior is to just try <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2319">trivial</span></code> (which handles the case
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27434" data-verso-hover="2505">i</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">arr.size</span></code> is in the context) and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-0" data-verso-hover="386">omega</span></a></code>
(for doing linear arithmetic in the index).</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-debug">
                13.5.20.Â Debugging Utilities<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-debug" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="sorry">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticSorry" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="" data-verso-hover="11">sorry</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="11">sorry</span></a></code> tactic is a temporary placeholder for an incomplete tactic proof,
closing the main goal using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-6" data-verso-hover="73">sorry</span></code>.</p>
                  <p>
                    This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.
Lean will give a warning whenever a proof uses <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="11">sorry</span></a></code>, so you aren't likely to miss it,
but you can double check if a theorem depends on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="11">sorry</span></a></code> by looking for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-sorryAx" data-verso-hover="1412">sorryAx</span></code> in the output
of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#print</span> <span class="unknown token" data-binding="">axioms</span> <span class="unknown token" data-binding="">my_thm</span></code> command, the axiom used by the implementation of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="11">sorry</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="admit">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticAdmit" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#admit"><span class="keyword token" data-binding="" data-verso-hover="2506">admit</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#admit"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAdmit-0" data-verso-hover="2506">admit</span></a></code> is a synonym for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="11">sorry</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="dbg_trace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.dbgTrace" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dbg_trace"><span class="keyword token" data-binding="" data-verso-hover="2507">dbg_trace</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dbg_trace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dbgTrace-0" data-verso-hover="2507">dbg_trace</span></a> <span class="literal string token" data-binding="" data-verso-hover="2508">"foo"</span></code> prints <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> when elaborated.
Useful for debugging tactic control flow:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a> <span class="unknown token" data-binding="">âˆ¨</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-8041903926592228059-28-30"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-28" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8041903926592228059-28-30"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="378"> âˆ¨ </span></a><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a></span></span></span></span></span>
  <a href="Tactic-Proofs/The-Tactic-Language/#first"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.first-33" data-verso-hover="2267">first</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="tactic"><label for="tactic-state-5686274142821041165-43-55"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-43" data-verso-hover="692">apply</span></a> <a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or.inl" data-verso-hover="432">Or.inl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5686274142821041165-43-55"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-357" checked="checked"><span for="--verso-unique-357" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-5686274142821041165-57-64"><a href="Tactic-Proofs/Tactic-Reference/#trivial"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-57" data-verso-hover="258">trivial</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5686274142821041165-57-64"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-358" checked="checked"><span for="--verso-unique-358" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span> <a href="Tactic-Proofs/Tactic-Reference/#dbg_trace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dbgTrace-66" data-verso-hover="2507">dbg_trace</span></a> <span class="literal string token" data-binding="" data-verso-hover="2509">"left"</span>
  <span class="unknown token" data-binding="">|</span> <span class="tactic"><label for="tactic-state-17180778638691059420-87-99"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-87" data-verso-hover="692">apply</span></a> <a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or.inr" data-verso-hover="434">Or.inr</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17180778638691059420-87-99"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-359" checked="checked"><span for="--verso-unique-359" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="260">True</span></a></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-101-108"><a href="Tactic-Proofs/Tactic-Reference/#trivial"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-101" data-verso-hover="258">trivial</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-101-108"><span class="tactic-state">All goals completed! ðŸ™</span></span><span class="unknown token" data-binding="">;</span> <a href="Tactic-Proofs/Tactic-Reference/#dbg_trace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dbgTrace-110" data-verso-hover="2507">dbg_trace</span></a> <span class="literal string token" data-binding="" data-verso-hover="2510">"right"</span>
<span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="trace_state">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.traceState" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#trace_state"><span class="keyword token" data-binding="" data-verso-hover="2511">trace_state</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#trace_state"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.traceState-0" data-verso-hover="2511">trace_state</span></a></code> displays the current state in the info view.</p>
                  </div>
                </div>
              <div class="namedocs" id="trace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.traceMessage" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#trace"><span class="keyword token" data-binding="" data-verso-hover="2512">trace</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">trace</span> <span class="unknown token" data-binding="">msg</span></code> displays <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">msg</span></code> in the info view.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-other">
                13.5.21.Â Other<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=tactic-ref-other" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="trivial">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticTrivial" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#trivial"><span class="keyword token" data-binding="" data-verso-hover="258">trivial</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2319">trivial</span></code> tries different simple tactics (e.g., <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-0" data-verso-hover="1181">contradiction</span></a></code>, ...)
to close the current goal.
You can use the command <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">macro_rules</span></code> to extend the set of tactics used. Example:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-0">macro_rules</span></a> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">`(tactic|</span> <a href="Tactic-Proofs/Tactic-Reference/#trivial"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-24" data-verso-hover="258">trivial</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">`(tactic|</span> <a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-46" data-verso-hover="36">simp</span></a><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="solve">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.solveTactic" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#solve"><span class="keyword token" data-binding="" data-verso-hover="2513">solve</span></a></pre><div class="text">
                  <p>
                    Similar to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#first"><span class="keyword token" data-binding="" data-verso-hover="2267">first</span></a></code>, but succeeds only if one the given tactics solves the current goal.</p>
                  </div>
                </div>
              <div class="namedocs" id="and_intros">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticAnd_intros" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#and_intros"><span class="keyword token" data-binding="" data-verso-hover="2514">and_intros</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#and_intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAnd_intros-0" data-verso-hover="2514">and_intros</span></a></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And.intro" data-verso-hover="427">And.intro</span></a></code> until it does not make progress.</p>
                  </div>
                </div>
              <div class="namedocs" id="infer_instance">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticInfer_instance" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#infer_instance"><span class="keyword token" data-binding="" data-verso-hover="2515">infer_instance</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#infer_instance"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticInfer_instance-0" data-verso-hover="2515">infer_instance</span></a></code> is an abbreviation for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="765">exact</span></a> <span class="unknown token" data-binding="">inferInstance</span></code>.
It synthesizes a value of any target type by typeclass inference.</p>
                  </div>
                </div>
              <div class="namedocs" id="expose_names">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.exposeNames" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#expose_names"><span class="keyword token" data-binding="" data-verso-hover="2389">expose_names</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#expose_names"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exposeNames-0" data-verso-hover="2389">expose_names</span></a></code> renames all inaccessible variables with accessible names, making them available
for reference in generated tactics. However, this renaming introduces machine-generated names
that are not fully under user control. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#expose_names"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exposeNames-0" data-verso-hover="2389">expose_names</span></a></code> is primarily intended as a preamble for
auto-generated end-game tactic scripts. It is also useful as an alternative to
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span> <span class="unknown token" data-binding="">tactic.hygienic</span> <span class="unknown token" data-binding="">false</span></code>. If explicit control over renaming is needed in the
middle of a tactic script, consider using structured tactic scripts with
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span> <span class="unknown token" data-binding="">..</span> <span class="keyword token" data-binding="kw-occ-null-0">with</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">induction</span> <span class="unknown token" data-binding="">..</span> <span class="keyword token" data-binding="kw-occ-null-0">with</span></code>, or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="662">intro</span></a></code> with explicit user-defined names,
as well as tactics such as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="" data-verso-hover="1180">next</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#case"><span class="keyword token" data-binding="" data-verso-hover="2231">case</span></a></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#rename_i"><span class="keyword token" data-binding="" data-verso-hover="2249">rename_i</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="unhygienic">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.tacticUnhygienic_" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#unhygienic"><span class="keyword token" data-binding="" data-verso-hover="2516">unhygienic</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">unhygienic</span> <span class="unknown token" data-binding="">tacs</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> with name hygiene disabled.
This means that tactics that would normally create inaccessible names will instead
make regular variables. <strong>Warning</strong>: Tactics may change their variable naming
strategies at any time, so code that depends on autogenerated names is brittle.
Users should try not to use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.28537" data-verso-hover="2517">unhygienic</span></code> if possible.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-13547114583190736551-32-34"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-32" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13547114583190736551-32-34"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.17" data-verso-hover="7">x</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.17" data-verso-hover="7">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.17" data-verso-hover="7">x</span></span></span></span></span></span> <a href="Tactic-Proofs/Tactic-Reference/#unhygienic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticUnhygienic_-35" data-verso-hover="2516">unhygienic</span></a>
  <span class="tactic"><label for="tactic-state-15095693903456198986-48-53"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-48" data-verso-hover="662">intro</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15095693903456198986-48-53"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">x</span></span></span></span></span></span>            -- x would normally be intro'd as inaccessible
  <span class="tactic"><label for="tactic-state-7-114-129"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-114" data-verso-hover="765">exact</span></a> <a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="436">Eq.refl</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">x</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-114-129"><span class="tactic-state">All goals completed! ðŸ™</span></span>  -- refer to x
<span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="run_tac">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=Lean.Parser.Tactic.runTac" title="Permalink">ðŸ”—</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#run_tac"><span class="keyword token" data-binding="" data-verso-hover="2518">run_tac</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#run_tac"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.runTac-0" data-verso-hover="2518">run_tac</span></a> <span class="unknown token" data-binding="">doSeq</span></code> tactic executes code in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TacticM</span> <span class="unknown token" data-binding="">Unit</span></code>.</p>
                  </div>
                </div>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Tactic-Proofs/Options/#tactic-language-options" rel="prev" title="13.4. Options"><span class="arrow">â†</span><span class="where">13.4. Options</span></a><a class="local-button active" href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv" rel="next" title="13.6. Targeted Rewriting with conv"><span class="where">13.6. Targeted Rewriting with conv</span><span class="arrow">â†’</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

