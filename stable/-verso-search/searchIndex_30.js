window.docContents[30].resolve({"/Coercions/Coercing-to-Sorts/#sort-coercion":{"contents":"The Lean elaborator expects types in certain positions without necessarily being able to determine the type's universe ahead of time.\nFor example, the term following the colon in a definition header might be a proposition or a type.\nThe ordinary coercion mechanism is not applicable because it requires a specific expected type, and there's no way to express that the expected type could be any universe in the Coe class.\n\nWhen a term is elaborated in a position where a proposition or type is expected, but the inferred type of the elaborated term is not a proposition or type, Lean  attempts to recover from the error by synthesizing an instance of CoeSort.\nIf the instance is found, and the resulting type is itself a type, then it the coercion is inserted and unfolded.\n\nNot every situation in which the elaborator expects a universe requires CoeSort.\nIn some cases, a particular universe is available as an expected type.\nIn these situations, ordinary coercion insertion using CoeT is used.\nInstances of CoeSort can be used to synthesize instances of CoeOut, so no separate instance is needed to support this use case.\nIn general, coercions to types should be implemented as CoeSort.\n\nCoeSort α β is a coercion to a sort. β must be a universe, and this is\ntriggered when a : α appears in a place where a type is expected, like\n(x : a) or a → a.\nCoeSort instances apply to CoeOut as well.Coerces a value of type α to β, which must be a universe.\n\nExplicit Coercion to SortsCoercions to sorts can be explicitly triggered using the ↥ prefix operator.\n\nSort CoercionsA monoid is a type equipped with an associative binary operation and an identity element.\nWhile monoid structure can be defined as a type class, it can also be defined as a structure that “bundles up” the structure with the type:structure Monoid where\n  Carrier : Type u\n  op : Carrier → Carrier → Carrier\n  id : Carrier\n  op_assoc :\n    ∀ (x y z : Carrier), op x (op y z) = op (op x y) z\n  id_op_identity : ∀ (x : Carrier), op id x = x\n  op_id_identity : ∀ (x : Carrier), op x id = x\nThe type Monoid does not indicate the carrier:def StringMonoid : Monoid where\n  Carrier := String\n  op := (· ++ ·)\n  id := \"\"\n  op_assoc := by intros; simp [String.append_assoc]\n  id_op_identity := by intros; simp\n  op_id_identity := by intros; simp\nHowever, a CoeSort instance can be implemented that applies the Monoid.Carrier projection when a monoid is used in a position where Lean would expect a type:instance : CoeSort Monoid (Type u) where\n  coe m := m.Carrier\n\nexample : StringMonoid := \"hello\"\n\n\nSort Coercions as Ordinary CoercionsThe inductive type NatOrBool represents the types Nat and Bool.\nThey can be coerced to the actual types Nat and Bool:inductive NatOrBool where\n  | nat | bool\n\n@[coe]\nabbrev NatOrBool.asType : NatOrBool → Type\n  | .nat => Nat\n  | .bool => Bool\n\ninstance : CoeSort NatOrBool Type where\n  coe := NatOrBool.asType\n\nopen NatOrBool\nThe CoeSort instance is used when nat occurs to the right of a colon:def x : nat := 5\nWhen an expected type is available, ordinary coercion insertion is used.\nIn this case, the CoeSort instance is used to synthesize a CoeOut NatOrBool Type instance, which chains with the Coe Type (Option Type) instance to recover from the type error.def y : Option Type := bool\n\n\n","context":"Lean Reference\u0009Coercions","header":"12.3. Coercing to Sorts","id":"/Coercions/Coercing-to-Sorts/#sort-coercion"},"/Run-Time-Code/#runtime":{"contents":"Compiled Lean code uses services provided by the Lean runtime.\nThe runtime contains efficient, low-level primitives that bridge the gap between the Lean language and the supported platforms.\nThese services include:\n\n Memory management\n\nLean does not require programmers to manually manage memory.\n    Space is allocated when needed to store a value, and values that can no longer be reached (and are thus irrelevant) are deallocated.\n    In particular, Lean uses reference counting, where each allocated object maintains a count of incoming references.\n    The compiler emits calls to memory management routines that allocate memory and modify reference counts, and these routines are provided by the runtime, along with the data structures that represent Lean values in compiled code.\n\n Multiple Threads\n\nThe Task API provides the ability to write parallel and concurrent code.\n    The runtime is responsible for scheduling Lean tasks across operating-system threads.\n\n Primitive operators\n\nMany built-in types, including Nat, Array, String, and fixed-width integers, have special representations for reasons of efficiency.\n    The runtime provides implementations of these types' primitive operators that take advantage of these optimized representations.\n\n\n\nThere are many primitive operators.\nThey are described in their respective sections under Basic Types.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"23. Run-Time Code","id":"/Run-Time-Code/#runtime"},"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Loops-and-Invariants":{"contents":"As a first example of mvcgen, the function mySum computes the sum of an array using local mutable state and a for loop:def mySum (l : Array Nat) : Nat := Id.run do\n  let mut out := 0\n  for i in l do\n    out := out + i\n  return out\n\n\nIf mySum is correct, then it is equal to Array.sum.\nIn mySum, the use of do is an internal implementation detail—the function's signature makes no mention of any monad.\nThus, the proof first manipulates the goal into a form that is amenable to the use of mvcgen, using the lemma Id.of_wp_run_eq.\nThis lemma states that facts about the result of running a computation in the Id monad that terminates normally (Id computations never throw exceptions) can be proved by showing that the weakest precondition that ensures the desired result is true.\nNext, the proof uses mvcgen to replace the formulation in terms of weakest preconditions with a set of verification conditions.\n\nWhile mvcgen is mostly automatic, it does require an invariant for the loop.\nA loop invariant is a statement that is both assumed and guaranteed by the body of the loop; if it is true when the loop begins, then it will be true when the loop terminates.\n\ntheorem mySum_correct (l : Array Nat) : mySum l = l.sum := by\n  -- Focus on the part of the program with the `do` block (`Id.run ...`)\n  generalize h : mySum l = x\n  apply Id.of_wp_run_eq h\n  -- Break down into verification conditions\n  mvcgen\n  -- Specify the invariant which should hold throughout the loop\n  -- * `out` refers to the current value of the `let mut` variable\n  -- * `xs` is a `List.Cursor`, which is a data structure representing\n  --   a list that is split into `xs.prefix` and `xs.suffix`.\n  --   It tracks how far into the loop we have gotten.\n  -- Our invariant is that `out` holds the sum of the prefix.\n  -- The notation ⌜p⌝ embeds a `p : Prop` into the assertion language.\n  case inv1 => exact ⇓⟨xs, out⟩ => ⌜xs.prefix.sum = out⌝\n  -- After specifying the invariant, we can further simplify our goals\n  -- by \"leaving the proof mode\". `mleave` is just\n  -- `simp only [...] at *` with a stable simp subset.\n  all_goals mleave\n  -- Prove that our invariant is preserved at each step of the loop\n  case vc1 ih =>\n    -- The goal here mentions `pref`, which binds the `prefix` field of\n    -- the cursor passed to the invariant. Unpacking the\n    -- (dependently-typed) cursor makes it easier for `grind`.\n    grind\n  -- Prove that the invariant is true at the start\n  case vc2 =>\n    grind\n  -- Prove that the invariant at the end of the loop implies the\n  -- property we wanted\n  case vc3 h =>\n    grind\n\n\nNote that the case labels are actually unique prefixes of the full case labels.\nWhenever referring to cases, only this prefix should be used; the suffix is merely a hint to the user of where that particular VC came from.\nFor example:* vc1.step conveys that this VC proves the inductive step for the loop* vc2.a.pre is meant to prove that the hypotheses of a goal imply the precondition of a specification (of forIn).* vc3.a.post.success is meant to prove that the postcondition of a specification (of forIn) implies the desired property.\n\nAfter specifying the loop invariant, the proof can be shortened to just all_goals mleave; grind (where mleave leaves the stateful proof mode, cleaning up the proof state).theorem mySum_correct_short (l : Array Nat) : mySum l = l.sum := by\n  generalize h : mySum l = x\n  apply Id.of_wp_run_eq h\n  mvcgen\n  case inv1 => exact ⇓⟨xs, out⟩ => ⌜xs.prefix.sum = out⌝\n  all_goals mleave; grind\nThis pattern is so common that mvcgen comes with special syntax for it:theorem mySum_correct_shorter (l : Array Nat) : mySum l = l.sum := by\n  generalize h : mySum l = x\n  apply Id.of_wp_run_eq h\n  mvcgen\n  invariants\n  · ⇓⟨xs, out⟩ => ⌜xs.prefix.sum = out⌝\n  with grind\nThe mvcgen invariants ...with... is an abbreviation for the\ntactic sequence mvcgen; case inv1 => ...; all_goals mleave; grind\nabove. It is the form that we will be using from now on.\n\nIt is helpful to compare the proof of mySum_correct_shorter to a traditional correctness proof:theorem mySum_correct_vanilla (l : Array Nat) : mySum l = l.sum := by\n  -- Turn the array into a list\n  cases l with | mk l =>\n  -- Unfold `mySum` and rewrite `forIn` to `foldl`\n  simp [mySum]\n  -- Generalize the inductive hypothesis\n  suffices h : ∀ out, List.foldl (· + ·) out l = out + l.sum by simp [h]\n  -- Grind away\n  induction l with grind\n\n\nThis proof is similarly succinct as the proof in mySum_correct_shorter that uses mvcgen.\nHowever, the traditional approach relies on important properties of the program:* The for loop does not break or return early. Otherwise, the forIn could not be rewritten to a foldl.* The loop body (· + ·) is small enough to be repeated in the proof.* The loop body does not carry out any effects in the underlying monad (that is, the only effects are those introduced by do-notation).\n  The Id monad has no effects, so all of its comptutations are pure.\n  While forIn could still be rewritten to a foldlM, reasoning about the monadic loop body can be tough for grind.In the following sections, we will go through several examples to learn about mvcgen and its support library, and also see where traditional proofs become difficult.\nThis is usually caused by:* do blocks using control flow constructs such as for loops, breaks and early return.* The use of effects in non-Id monads, which affects the implicit monadic context (state, exceptions) in ways that need to be reflected in loop invariants.mvcgen scales to these challenges with reasonable effort.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Tutorial: Verifying Imperative Programs Using  mvcgen","header":"18.6.2. Loops and Invariants","id":"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Loops-and-Invariants"},"/The-Type-System/Universes/#level-expressions":{"contents":"Levels that occur in a definition are not restricted to just variables and addition of constants.\nMore complex relationships between universes can be defined using level expressions.\n\nLevel ::= 0 | 1 | 2 | ...  -- Concrete levels\n        | u, v             -- Variables\n        | Level + n        -- Addition of constants\n        | max Level Level  -- Least upper bound\n        | imax Level Level -- Impredicative LUB\n\n\nGiven an assignment of level variables to concrete numbers, evaluating these expressions follows the usual rules of arithmetic.\nThe imax operation is defined as follows:\n\n\\mathtt{imax}\\ u\\ v = \\begin{cases}0 & \\mathrm{when\\ }v = 0\\\\\\mathtt{max}\\ u\\ v&\\mathrm{otherwise}\\end{cases}\n\nimax is used to implement impredicative quantification for Prop.\nIn particular, if A : Sort u and B : Sort v, then (x : A) → B : Sort (imax u v).\nIf B : Prop, then the function type is itself a Prop; otherwise, the function type's level is the maximum of u and v.\n\n","context":"Lean Reference\u0009Type System\u0009Universes\u0009Polymorphism","header":"4.3.2.1. Level Expressions","id":"/The-Type-System/Universes/#level-expressions"},"/releases/v4.10.0/#release-v4___10___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.10.0 (2024-07-31)","id":"/releases/v4.10.0/#release-v4___10___0"}});