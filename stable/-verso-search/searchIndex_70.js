window.docContents[70].resolve({"/Basic-Types/Characters/#char-syntax":{"contents":"Character literals consist of a single character or an escape sequence enclosed in single quotes (', Unicode 'APOSTROPHE' (U+0027)).\nBetween these single quotes, the character literal may contain character other that ', including newlines, which are included literally (with the caveat that all newlines in a Lean source file are interpreted as '\\n', regardless of file encoding and platform).\nSpecial characters may be escaped with a backslash, so '\\'' is a character literal that contains a single quote.\nThe following forms of escape sequences are accepted:\n\n \\r, \\n, \\t, \\\\, \\\", \\'\n\nThese escape sequences have the usual meaning, mapping to CR, LF, tab, backslash, double quote, and single quote, respectively.\n\n \\xNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the two-digit hexadecimal code.\n\n \\uNNNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the four-digit hexadecimal code.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters","header":"20.7.3. Syntax","id":"/Basic-Types/Characters/#char-syntax"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration":{"contents":"Option can be thought of as a collection that contains at most one value.\nFrom this perspective, iteration operators can be understood as performing some operation on the contained value, if present, or doing nothing if not.\n\nChecks whether an optional value either satisfies a Boolean predicate or is none.Examples:* `(some 33).all (· % 2 == 0) = false* `(some 22).all (· % 2 == 0) = true* `none.all (fun x : Nat => x % 2 == 0) = true\n\nChecks whether an optional value is not none and satisfies a Boolean predicate.Examples:* `(some 33).any (· % 2 == 0) = false* `(some 22).any (· % 2 == 0) = true* `none.any (fun x : Nat => true) = false\n\nKeeps an optional value only if it satisfies a Boolean predicate.If Option is thought of as a collection that contains at most one element, then Option.filter is\nanalogous to List.filter or Array.filter.Examples:* (some 5).filter (· % 2 == 0) = none* (some 4).filter (· % 2 == 0) = some 4* none.filter (fun x : Nat => x % 2 == 0) = none* none.filter (fun x : Nat => true) = none\n\nKeeps an optional value only if it satisfies a monadic Boolean predicate.If Option is thought of as a collection that contains at most one element, then Option.filterM\nis analogous to List.filterM.\n\nExecutes a monadic action on an optional value if it is present, or does nothing if there is no\nvalue.Examples:#eval ((some 5).forM set : StateM Nat Unit).run 0\n((), 5)\n#eval (none.forM (fun x : Nat => set x) : StateM Nat Unit).run 0\n((), 0)\n\n\nApply a function to an optional value, if present.From the perspective of Option as a container with at most one value, this is analogous to\nList.map. It can also be accessed via the Functor Option instance.Examples:* (none : Option Nat).map (· + 1) = none* (some 3).map (· + 1) = some 4\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.This is an alias for Option.mapM, which already works for applicative functors.\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.Runs a monadic function f on an optional value, returning the result. If the optional value is\nnone, the function is not called and the result is also none.From the perspective of Option as a container with at most one element, this is analogous to\nList.mapM, returning the result of running the monadic function on all elements of the container.This function only requires m to be an applicative functor. An alias Option.mapA is provided.\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"20.12.2.5. Iteration","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration"},"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Range-Related-Type-Classes":{"contents":"This typeclass provides the function succ? : α → Option α that computes the successor of\nelements of α, or none if no successor exists.\nIt also provides the function succMany?, which computes n-th successors.succ? is expected to be acyclic: No element is its own transitive successor.\nIf α is ordered, then every element larger than a : α should be a transitive successor of a.\nThese properties and the compatibility of succ? with succMany? are encoded in the typeclasses\nLawfulUpwardEnumerable, LawfulUpwardEnumerableLE and LawfulUpwardEnumerableLT.Maps elements of α to their successor, or none if no successor exists.Maps elements of α to their n-th successor, or none if no successor exists.\nThis should semantically behave like repeatedly applying succ?, but it might be more efficient.LawfulUpwardEnumerable ensures the compatibility with succ?.If no other implementation is provided in UpwardEnumerable instance, succMany? repeatedly\napplies succ?.\n\nAccording to UpwardEnumerable.LE, a is less than or equal to b if b is a or a transitive\nsuccessor of a.\n\nAccording to UpwardEnumerable.LT, a is less than b if b is a proper transitive successor of\na. 'Proper' means that b is the n-th successor of a, where n > 0.Given LawfulUpwardEnumerable α, no element of α is less than itself.\n\nThis typeclass ensures that an UpwardEnumerable α instance is well-behaved.There is no cyclic chain of successors.The 0-th successor of a is a itself.The n + 1-th successor of a is the successor of the n-th successor, given that said\nsuccessors actually exist.\n\nThe typeclass Least? α optionally provides a smallest element of α, least? : Option α.The main use case of this typeclass is to use it in combination with UpwardEnumerable to\nobtain a (possibly infinite) ascending enumeration of all elements of α.Returns the smallest element of α, or none if α is empty.Only empty types are allowed to define least? := none. If α is ordered and nonempty, then\nthe value of least? should be the smallest element according to the order on α.\n\nThis propositional typeclass ensures that UpwardEnumerable.succ? will never return none.\nIn other words, it ensures that there will always be a successor.\n\nThis propositional typeclass ensures that UpwardEnumerable.succ? is injective.\n\nThis type class ensures that right-unbounded ranges (i.e., for a bound a,\na...*, a<...* and *...*) are always finite.\nThis is a prerequisite for many functions and instances, such as\nRci.toList or ForIn'.\n\nThis typeclass provides support for the size function for ranges with closed lower bound\n(Ric.size,\nRio.size and\nRii.size).The returned size should be equal to the number of elements returned by toList. This\ncondition is captured by the typeclass\nLawfulHasSize.Returns the number of elements starting from lo that satisfy the given upper bound.\n\nThis type class ensures that right-closed ranges (i.e., for bounds a and b,\na...=b, a<...=b and *...=b) are always finite.\nThis is a prerequisite for many functions and instances, such as\nRcc.toList or ForIn'.\n\nThis typeclass provides support for the size function for ranges with closed lower bound\n(Rcc.size,\nRco.size and\nRci.size).The returned size should be equal to the number of elements returned by toList. This\ncondition is captured by the typeclass\nLawfulHasSize.Returns the number of elements starting from lo that satisfy the given upper bound.\n\n","context":"Lean Reference\u0009Basic Types\u0009Ranges","header":"20.18.2. Range-Related Type Classes","id":"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Range-Related-Type-Classes"},"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch--Examples":{"contents":"Typo in resulting typeinductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Treee α\ninductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Tree α\n\n\nMissing resulting type after constructor parameterinductive Credential where\n  | pin      : Nat\n  | password : String\ninductive Credential where\n  | pin      : Nat → Credential\n  | password : String → Credential\ninductive Credential where\n  | pin (num : Nat)\n  | password (str : String)\nIf the type of a constructor is annotated, the full type—including the resulting type—must be\nprovided. Alternatively, constructor parameters can be written using named binders; this allows the\nomission of the constructor's resulting type because it contains no indices.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.ctorResultingTypeMismatch","header":"Examples","id":"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch--Examples"},"/Error-Explanations/lean___propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--lean___propRecLargeElim--Examples":{"contents":"Defining an intermediate data value within a proofexample {α : Type} [inst : Nonempty α] (p : α → Prop) :\n    ∃ x, p x ∨ ¬ p x :=\n  let val :=\n    match inst with\n    | .intro x => x\n  ⟨val, Classical.em (p val)⟩\nexample {α : Type} [inst : Nonempty α] (p : α → Prop) :\n    ∃ x, p x ∨ ¬ p x :=\n  match inst with\n  | .intro x => ⟨x, Classical.em (p x)⟩\nEven though the example being defined has a propositional type, the body of val does not; it has\ntype α : Type. Thus, pattern-matching on the proof of Nonempty α (a proposition) to produce\nval requires eliminating that proof into a non-propositional type and is disallowed. Instead, the\nmatch expression must be moved to the top level of the example, where the result is a\nProp-valued proof of the existential claim stated in the example's header. This restructuring\ncould also be done using a pattern-matching let binding.\n\nExtracting the witness from an existential proofdef getWitness {α : Type u} {p : α → Prop} (h : ∃ x, p x) : α :=\n  match h with\n  | .intro x _ => x\n-- This is `Exists.elim`\ntheorem useWitness {α : Type u} {p : α → Prop} {q : Prop}\n    (h : ∃ x, p x) (hq : (x : α) → p x → q) : q :=\n  match h with\n  | .intro x hx => hq x hx\ndef getWitness {α : Type u} {p : α → Prop}\n    (h : (x : α) ×' p x) : α :=\n  match h with\n  | .mk x _ => x\nIn this example, simply relocating the pattern-match is insufficient; the attempted definition\ngetWitness is fundamentally unsound. (Consider the case where p is fun (n : Nat) => n > 0: if\nh and h' are proofs of ∃ x, x > 0, with h using witness 1 and h' witness 2, then since\nh = h' by proof irrelevance, it follows that getWitness h = getWitness h'—i.e., 1 = 2.)Instead, getWitness must be rewritten: either the resulting type of the function must be a\nproposition (the first fixed example above), or h must not be a proposition (the second).In the first corrected example, the resulting type of useWitness is now a proposition q. This\nallows us to pattern-match on h—since we are eliminating into a propositional type—and pass the\nunpacked values to hq. From a programmatic perspective, one can view useWitness as rewriting\ngetWitness in continuation-passing style, restricting subsequent computations to use its result\nonly to construct values in Prop, as required by the prohibition on propositional large\nelimination. Note that useWitness is the existential elimination principle Exists.elim.The second corrected example changes the type of h from an existential proposition to a\nType-valued dependent pair (corresponding to the PSigma type constructor). Since this type is\nnot propositional, eliminating into α : Type u is no longer invalid, and the previously attempted\npattern match now type-checks.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.propRecLargeElim","header":"Examples","id":"/Error-Explanations/lean___propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--lean___propRecLargeElim--Examples"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors":{"contents":"Mutual inductive types are provided with primitive recursors, just like non-mutually-defined inductive types.\nThese recursors take into account that they must process the other types in the group, and thus will have a motive for each inductive type.\nBecause all inductive types in the mutual group are required to have identical parameters, the recursors still take the parameters first, abstracting them over the motives and the rest of the recursor.\nAdditionally, because the recursor must process the group's other types, it will require cases for each constructor of each of the types in the group.\nThe actual dependency structure between the types is not taken into account; even if an additional motive or constructor case is not really required due to there being fewer mutual dependencies than there could be, the generated recursor still requires them.\n\nEven and oddmutual\n  inductive Even : Nat → Prop where\n    | zero : Even 0\n    | succ : Odd n → Even (n + 1)\n  inductive Odd : Nat → Prop where\n    | succ : Even n → Odd (n + 1)\nend\nEven.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : {n : Nat} → (a : Odd n) → motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) →\n  ∀ {a : Nat} (t : Even a), motive_1 a t\nOdd.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) → ∀ {a : Nat} (t : Odd a), motive_2 a t\n\n\nSpuriously mutual typesThe types Two and Three are defined in a mutual block, even though they do not refer to each other:mutual\n  inductive Two (α : Type) where\n    | mk : α → α → Two α\n  inductive Three (α : Type) where\n    | mk : α → α → α → Three α\nend\nTwo's recursor, Two.rec, nonetheless requires a motive and a case for Three:Two.rec.{u} {α : Type}\n  {motive_1 : Two α → Sort u}\n  {motive_2 : Three α → Sort u}\n  (mk : (a a_1 : α) → motive_1 (Two.mk a a_1)) :\n  ((a a_1 a_2 : α) → motive_2 (Three.mk a a_1 a_2)) → (t : Two α) → motive_1 t\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","header":"4.4.5.2. Recursors","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors"}});