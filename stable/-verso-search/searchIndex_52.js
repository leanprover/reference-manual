window.docContents[52].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Arithmetic--Roots":{"contents":"Computing the square root of a negative number yields NaN.\n\nComputes the square root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsqrt.\n\nComputes the square root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsqrtf.\n\nComputes the cube root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncbrt.\n\nComputes the cube root of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncbrtf.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Arithmetic","header":"20.6.2.5.1. Roots","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Arithmetic--Roots"},"/Basic-Types/Integers/#int-syntax":{"contents":"\n\nThe OfNat Int instance allows numerals to be used as literals, both in expression and in pattern contexts.\n(OfNat.ofNat n : Int) reduces to the constructor application Int.ofNat n.\nThe Neg Int instance allows negation to be used as well.\n\n\n\nOn top of these instances, there is special syntax for the constructor Int.negSucc that is available when the Int namespace is opened.\nThe notation -[ n +1] is suggestive of -(n + 1), which is the meaning of Int.negSucc n.\n\nNegative Successor-[ n +1] is notation for Int.negSucc n.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers","header":"20.2.3. Syntax","id":"/Basic-Types/Integers/#int-syntax"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates":{"contents":"The predicate transformer semantics of monadic programs is based on a logic in which propositions may mention the program's state.\nHere, “state” refers not only to mutable state, but also to read-only values such as those that are provided via ReaderT.\nDifferent monads have different state types available, but each individual state always has a type.\nGiven a list of state types, SPred is a type of predicates over these states.\n\nSPred is not inherently tied to the monadic verification framework.\nThe related Assertion computes a suitable SPred for a monad's state as expressed via its WP instance's PostShape output parameter.\n\nA predicate indexed by a list of states.example : SPred [Nat, Bool] = (Nat → Bool → ULift Prop) := rfl\n\n\nOrdinary propositions that do not mention the state can be used as stateful predicates by adding a trivial universal quantification.\nThis is written with the syntax ⌜P⌝, which is syntactic sugar for SPred.pure.Notation for SPredEmbedding of pure Lean values into SVal. An alias for SPred.pure.\n\nA pure proposition P : Prop embedded into SPred.\nPrefer to use idiom bracket notation `⌜P⌝.\n\nStateful PredicatesThe predicate ItIsSecret expresses that a state of type String is \"secret\":def ItIsSecret : SPred [String] := fun s => ⌜s = \"secret\"⌝\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers","header":"18.2.1. Stateful Predicates","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates"},"/the-index/#The-Lean-Language-Reference--Index":{"contents":"\n\n","context":"Lean Reference","header":"Index","id":"/the-index/#The-Lean-Language-Reference--Index"}});