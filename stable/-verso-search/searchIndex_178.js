window.docContents[178].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Syntax":{"contents":"There is an OfNat (BitVec w) n instance for all widths w and natural numbers n.\nNatural number literals, including those that use hexadecimal or binary notation, may be used to represent bitvectors in contexts where the expected type is known.\nWhen the expected type is not known, a dedicated syntax allows the width of the bitvector to be specified along with its value.\n\nNumeric Literals for BitvectorsThe following literals are all equivalent:example : BitVec 8 := 0xff\nexample : BitVec 8 := 255\nexample : BitVec 8 := 0b1111_1111\n\n\nFixed-Width Bitvector LiteralsThis notation pairs a numeric literal with a term that denotes its width.\nSpaces are forbidden around the #.\nLiterals that overflow the width of the bitvector are truncated.\n\nFixed-Width Bitvector LiteralsBitvectors may be represented by natural number literals, so (5 : BitVec 8) is a valid bitvector.\nAdditionally, a width may be specified directly in the literal:5#8\nSpaces are not allowed on either side of the #:5 #8\n<example>:1:2-1:3: expected end of input\n5# 8\n<example>:1:3-1:4: expected no space before\nA numeric literal is required to the left of the #:(3 + 2)#8\n<example>:1:7-1:8: expected end of input\nHowever, a term is allowed to the right of the #:5#(4 + 4)\nIf the literal is too large to fit in the specified number of bits, then it is truncated:#eval 7#2\n3#2\n\n\nBounded Bitvector LiteralsThis notation is available only when the BitVec namespace has been opened.\nRather than an explicit width, it expects a proof that the literal value is representable by a bitvector of the corresponding width.\n\nBounded Bitvector LiteralsThe bounded bitvector literal notation ensures that literals do not overflow the specified number of bits.\nThe notation is only available when the BitVec namespace has been opened.open BitVec\nLiterals that are in bounds require a proof to that effect:example : BitVec 8 := 1#'(by decide)\nLiterals that are not in bounds are not allowed:example : BitVec 8 := 256#'(by decide)\nTactic `decide` proved that the proposition\n  256 < 2 ^ 8\nis false\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors","header":"20.5.3. Syntax","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Syntax"},"/Definitions/Recursive-Definitions/#mutual-structural-recursion":{"contents":"Lean supports the definition of mutually recursive functions using structural recursion.\nMutual recursion may be introduced using a mutual block, but it also results from let rec expressions and where blocks.\nThe rules for mutual structural recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the elaboration steps for mutual groups.\nIf every function in the mutual group has a termination_by structural annotation indicating that function’s decreasing argument, then structural recursion is used to translate the definitions.\n\nThe requirements on the decreasing argument above are extended:\n\n* All the types of all the decreasing arguments must be from the same inductive type, or more generally from the same mutual group of inductive types.* The parameters of the decreasing parameter's types must be the same for all functions, and may depend only on the common fixed prefix of function arguments.\n\nThe functions do not have to be in a one-to-one correspondence to the mutual inductive types.\nMultiple functions can have a decreasing argument of the same type, and not all types that are mutually recursive with the decreasing argument need have a corresponding function.\n\nMutual Structural Recursion Over Non-Mutual TypesThe following example demonstrates mutual recursion over a non-mutual inductive data type:mutual\n  def even : Nat → Prop\n    | 0 => True\n    | n+1 => odd n\n  termination_by structural n => n\n\n  def odd : Nat → Prop\n    | 0 => False\n    | n+1 => even n\n  termination_by structural n => n\nend\n\n\nMutual Structural Recursion Over Mutual TypesThe following example demonstrates recursion over mutually inductive types.\nThe functions Exp.size and App.size are mutually recursive.mutual\n  inductive Exp where\n    | var : String → Exp\n    | app : App → Exp\n\n  inductive App where\n    | fn : String → App\n    | app : App → Exp → App\nend\n\nmutual\n  def Exp.size : Exp → Nat\n    | .var _ => 1\n    | .app a => a.size\n  termination_by structural e => e\n\n  def App.size : App → Nat\n    | .fn _ => 1\n    | .app a e => a.size + e.size + 1\n  termination_by structural a => a\nend\nThe definition of App.numArgs is structurally recursive over type App.\nIt demonstrates that not all inductive types in the mutual group need to be handled.def App.numArgs : App → Nat\n  | .fn _ => 0\n  | .app a _ => a.numArgs + 1\ntermination_by structural a => a\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Structural Recursion","header":"7.6.2.2. Mutual Structural Recursion","id":"/Definitions/Recursive-Definitions/#mutual-structural-recursion"},"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Compositional-Reasoning-About-Effectful-Programs-Using-Hoare-Triples--Hoare-Triples":{"contents":"A Hoare triple consists of a precondition, a statement, and a postcondition; it asserts that if the precondition holds, then the postcondition holds after running the statement.\nIn Lean syntax, this is written ⦃ P ⦄ prog ⦃ Q ⦄, where P is the precondition, prog : m α is the statement, and Q is the postcondition.\nP and Q are written in an assertion language that is determined by the specific monad m.In particular, monad's instance of the type class WP specifies the ways in which assertions may refer to the monad's state or the exceptions it may throw.Specifications as Hoare triples are compositional because they allow statements to be sequenced.\nGiven ⦃P⦄ stmt1 ⦃Q⦄ and ⦃P'⦄ stmt2 ⦃Q'⦄, if Q implies P' then ⦃P⦄ (do stmt1; stmt2) ⦃Q'⦄.\nJust as proofs about ordinary functions can rely on lemmas about the functions that they call, proofs about monadic programs can use lemmas that are specified in terms of Hoare triples.One suitable specification for mkFresh as a Hoare triple is this translation of mkFreshN_correct:⦃⌜True⌝⦄ mkFreshN n ⦃⇓ r => ⌜r.Nodup⌝⦄\nCorner brackets embed propositions into the monadic assertion language, so ⌜p⌝ is the assertion of the proposition p.\nThe precondition ⌜True⌝ asserts that True is true; this trivial precondition is used to state that the specification imposes no requirements on the state in which it is called.\nThe postcondition states that the result value is a list with no duplicate elements.A specification for the single-step mkFresh describes its effects on the monad's state:∀ (c : Nat),\n⦃fun state => ⌜state.counter = c⌝⦄\nmkFresh\n⦃⇓ r state => ⌜r = c ∧ c < state.counter⌝⦄\nWhen working in a state monad, preconditions may be parameterized over the value of the state prior to running the code.\nHere, the universally quantified Nat is used to relate the initial state to the final state; the precondition is used to connect it to the initial state.\nSimilarly, the postcondition may also accept the final state as a parameter.\nThis Hoare triple states:If c refers to the Supply.counter field of the Supply prestate, then running mkFresh returns c and modifies the Supply.counter of the poststate to be larger than c.Note that this specification is lossy: mkFresh could increment its state by an arbitrary non-negative amount and still satisfy the specification.\nThis is good, because specifications may abstract over uninteresting implementation details, ensuring resilient and small proofs.Hoare triples are defined in terms of a logic of stateful predicates plus a weakest precondition semantics wp⟦prog⟧ that translates monadic programs into this logic.\nA weakest precondition semantics is an interpretation of programs as mappings from postconditions to the weakest precondition that the program would require to ensure the postcondition; in this interpretation, programs are understood as predicate transformers.\nThe Hoare triple syntax is notation for Std.Do.Triple:-- This is the definition of Std.Do.Triple:\ndef Triple [WP m ps] {α : Type u} (prog : m α)\n    (P : Assertion ps) (Q : PostCond α ps) : Prop :=\n  P ⊢ₛ wp⟦prog⟧ Q\nThe WP type class maps a monad m to its PostShape ps, and this PostShape governs the exact shape of the Std.Do.Triple.\nMany of the standard monad transformers such as StateT, ReaderT and ExceptT come with a canonical WP instance.\nFor example, StateT σ comes with a WP instance that adds a σ argument to every Assertion.\nStateful entailment ⊢ₛ eta-expands through these additional σ arguments.\nFor StateM programs, the following type is definitionally equivalent to Std.Do.Triple:def StateMTriple {α σ : Type u} (prog : StateM σ α)\n    (P : σ → ULift Prop) (Q : (α → σ → ULift Prop) × PUnit) : Prop :=\n  ∀ s, (P s).down → let (a, s') := prog.run s; (Q.1 a s').down\nThe common postcondition notation ⇓ r => ... injects an assertion of type α → Assertion ps into\nPostCond α ps (the ⇓ is meant to be parsed like fun); in case of StateM by adjoining it with an empty tuple PUnit.unit.\nThe shape of postconditions becomes more interesting once exceptions enter the picture.\nThe notation ⌜p⌝ embeds a pure hypotheses p into a stateful assertion.\nVice versa, any stateful hypothesis P is called pure if it is equivalent to ⌜p⌝\nfor some p.\nPure, stateful hypotheses may be freely moved into the regular Lean context and back.\n(This can be done manually with the mpure tactic.)\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Tutorial: Verifying Imperative Programs Using  mvcgen\u0009Compositional Reasoning About Effectful Programs Using Hoare Triples","header":"18.6.4.1. Hoare Triples","id":"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Compositional-Reasoning-About-Effectful-Programs-Using-Hoare-Triples--Hoare-Triples"},"/The-Type-System/Inductive-Types/#inductive-types-logical-model":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.3. Logical Model","id":"/The-Type-System/Inductive-Types/#inductive-types-logical-model"}});