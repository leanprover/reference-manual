window.docContents[115].resolve({"/Definitions/Recursive-Definitions/#partial-correctness-theorem":{"contents":"For every function defined as a partial fixpoint, Lean proves that the defining equation is satisfied.\nThis enables proofs by rewriting.\nHowever, these equational theorems are not sufficient for reasoning about the behavior of the function on arguments for which the function specification does not terminate.\nCode paths that lead to infinite recursion at runtime would end up as infinite chains of rewrites in a potential proof.\n\nPartial fixpoints in suitable monads, on the other hand, provide additional theorems that map the undefined values from non-termination to suitable values in the monad.\nIn the Option monad, then partial fixpoint equals Option.none on all function inputs for which the defining equation specifies non-termination.\nFrom this fact, Lean proves a partial correctness theorem for the function which allows facts to be concluded when the function's result is Option.some.\n\nPartial Correctness TheoremRecall List.findIndex from an earlier example:def List.findIndex (xs : List α) (p : α → Bool) : Option Nat :=\n  match xs with\n  | [] => none\n  | x::ys =>\n    if p x then\n      some 0\n    else\n      (· + 1) <$> List.findIndex ys p\npartial_fixpoint\nWith this function definition, Lean automatically proves the following partial correctness theorem:List.findIndex.partial_correctness.{u_1} {α : Type u_1}\n  (p : α → Bool)\n  (motive : List α → Nat → Prop)\n  (h :\n    ∀ (findIndex : List α → Option Nat),\n      (∀ (xs : List α) (r : Nat), findIndex xs = some r → motive xs r) →\n        ∀ (xs : List α) (r : Nat),\n          (match xs with\n              | [] => none\n              | x :: ys =>\n                if p x = true then some 0\n                else (fun x => x + 1) <$> findIndex ys) = some r →\n            motive xs r)\n  (xs : List α) (r : Nat) :\n  xs.findIndex p = some r →\n    motive xs r\nHere, the motive is a relation between the parameter and return types of List.findIndex, with the Option removed from the return type.\nIf, when given an arbitrary partial function with a signature that's compatible with List.findIndex, the following hold:* the motive is satisfied for all inputs for which the arbitrary function returns a value (rather than none),* taking one rewriting step with the defining equation, in which the recursive calls are replaced by the arbitrary function, also implies the satisfaction of the motivethen the motive is satsified for all inputs for which the List.findIndex returns some.The partial correctness theorem is a reasoning principle.\nIt can be used to prove that the resulting number is a valid index in the list and that the predicate holds for that index:theorem List.findIndex_implies_pred\n    (xs : List α) (p : α → Bool) :\n    xs.findIndex p = some i →\n    ∃x, xs[i]? = some x ∧ p x := by\n  apply List.findIndex.partial_correctness\n          (motive := fun xs i => ∃ x, xs[i]? = some x ∧ p x)\n  intro findIndex ih xs r hsome\n  split at hsome\n  next => contradiction\n  next x ys =>\n    split at hsome\n    next =>\n      have : r = 0 := by simp_all\n      simp_all\n    next =>\n      simp only [Option.map_eq_map, Option.map_eq_some'] at hsome\n      obtain ⟨r', hr, rfl⟩ := hsome\n      specialize ih _ _ hr\n      simpa\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.3. Partial Correctness Theorems","id":"/Definitions/Recursive-Definitions/#partial-correctness-theorem"},"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen--Compositional-Reasoning-About-Effectful-Programs-Using-Hoare-Triples":{"contents":"The previous examples reasoned about functions defined using Id.run do <prog> to make use of local mutability and early return in <prog>.\nHowever, real-world programs often use do notation and monads M to hide away state and failure conditions as implicit “effects”.\nIn this use case, functions usually omit the M.run.\nInstead they have a monadic return type M α and compose well with other functions of that return type.\nIn other words, the monad is part of the function's interface, not merely its implementation.\n\nHere is an example involving a stateful function mkFresh that returns auto-incremented counter values:structure Supply where\n  counter : Nat\n\ndef mkFresh : StateM Supply Nat := do\n  let n ← (·.counter) <$> get\n  modify fun s => { s with counter := s.counter + 1 }\n  pure n\n\ndef mkFreshN (n : Nat) : StateM Supply (List Nat) := do\n  let mut acc := #[]\n  for _ in [:n] do\n    acc := acc.push (← mkFresh)\n  pure acc.toList\n\n\nmkFreshN n returns n “fresh” numbers, modifying the internal Supply state through mkFresh.\nHere, “fresh” refers to all previously generated numbers being distinct from the next generated number.\nWe can formulate and prove a correctness property mkFreshN_correct in terms of List.Nodup: the returned list of numbers should contain no duplicates.\nIn this proof, StateM.of_wp_run'_eq serves the same role that Id.of_wp_run_eq did in the preceding examples.theorem mkFreshN_correct (n : Nat) : ((mkFreshN n).run' s).Nodup := by\n  -- Focus on `(mkFreshN n).run' s`.\n  generalize h : (mkFreshN n).run' s = x\n  apply StateM.of_wp_run'_eq h\n  -- Show something about monadic program `mkFresh n`.\n  -- The `mkFreshN` and `mkFresh` arguments to `mvcgen` add to an\n  -- internal `simp` set and makes `mvcgen` unfold these definitions.\n  mvcgen [mkFreshN, mkFresh]\n  invariants\n  -- Invariant: The counter is larger than any accumulated number,\n  --            and all accumulated numbers are distinct.\n  -- Note that the invariant may refer to the state through function\n  -- argument `state : Supply`. Since the next number to accumulate is\n  -- the counter, it is distinct to all accumulated numbers.\n  · ⇓⟨xs, acc⟩ state =>\n      ⌜(∀ x ∈ acc, x < state.counter) ∧ acc.toList.Nodup⌝\n  with grind\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Verifying Imperative Programs Using  mvcgen","header":"18.1.4. Compositional Reasoning About Effectful Programs Using Hoare Triples","id":"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen--Compositional-Reasoning-About-Effectful-Programs-Using-Hoare-Triples"},"/The--mvcgen--tactic/#mvcgen-tactic":{"contents":"The mvcgen tactic implements a monadic verification condition generator:\nIt breaks down a goal involving a program written using Lean's imperative do notation into a number of pure verification conditions (VCs) that discharge said goal.\nA verification condition is a sub-goal that does not mention the monad underlying the do block.\n\nIn order to use the mvcgen tactic, Std.Tactic.Do must be imported and the namespace Std.Do must be opened.\n\n\n\n","context":"Lean Reference","header":"18. The  mvcgen  tactic","id":"/The--mvcgen--tactic/#mvcgen-tactic"}});