window.docContents[247].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Tangent":{"contents":"Computes the tangent of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntan.\n\nComputes the tangent of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanf.\n\nComputes the hyperbolic tangent of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanh.\n\nComputes the hyperbolic tangent of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanhf.\n\nComputes the arc tangent (inverse tangent) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan.\n\nComputes the arc tangent (inverse tangent) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanf.\n\nComputes the hyperbolic arc tangent (inverse tangent) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanh.\n\nComputes the hyperbolic arc tangent (inverse tangent) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanhf.\n\nComputes the arc tangent (inverse tangent) of y / x in radians, in the range -π–π. The signs\nof the arguments determine the quadrant of the result.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan2.\n\nComputes the arc tangent (inverse tangent) of y / x in radians, in the range -π–π. The signs\nof the arguments determine the quadrant of the result.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan2f.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Trigonometry","header":"20.6.2.9.3. Tangent","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Tangent"},"/Basic-Types/Linked-Lists/#list-syntax":{"contents":"List literals are written in square brackets, with the elements of the list separated by commas.\nThe constructor List.cons that adds an element to the front of a list is represented by the infix operator ::.\nThe syntax for lists can be used both in ordinary terms and in patterns.\n\nList LiteralsThe syntax [a, b, c] is shorthand for a :: b :: c :: [], or\nList.cons a (List.cons b (List.cons c List.nil)). It allows conveniently constructing\nlist literals.For lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\nlet left := [d, e, f]; a :: b :: c :: left to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like dbg_trace.Conventions for notations in identifiers:* The recommended spelling of [] in identifiers is nil.* The recommended spelling of [a] in identifiers is singleton.\n\nList ConstructionThe list whose first element is head, where tail is the rest of the list.\nUsually written head :: tail.Conventions for notations in identifiers:* The recommended spelling of :: in identifiers is cons.\n\nConstructing ListsAll of these examples are equivalent:example : List Nat := [1, 2, 3]\nexample : List Nat := 1 :: [2, 3]\nexample : List Nat := 1 :: 2 :: [3]\nexample : List Nat := 1 :: 2 :: 3 :: []\nexample : List Nat := 1 :: 2 :: 3 :: .nil\nexample : List Nat := 1 :: 2 :: .cons 3 .nil\nexample : List Nat := .cons 1 (.cons 2 (.cons 3 .nil))\n\n\nPattern Matching and ListsAll of these functions are equivalent:def split : List α → List α × List α\n  | [] => ([], [])\n  | [x] => ([x], [])\n  | x :: x' :: xs =>\n    let (ys, zs) := split xs\n    (x :: ys, x' :: zs)\ndef split' : List α → List α × List α\n  | .nil => (.nil, .nil)\n  | x :: [] => (.singleton x, .nil)\n  | x :: x' :: xs =>\n    let (ys, zs) := split xs\n    (x :: ys, x' :: zs)\ndef split'' : List α → List α × List α\n  | .nil => (.nil, .nil)\n  | .cons x .nil=> (.singleton x, .nil)\n  | .cons x (.cons x' xs) =>\n    let (ys, zs) := split xs\n    (.cons x ys, .cons x' zs)\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists","header":"20.15.1. Syntax","id":"/Basic-Types/Linked-Lists/#list-syntax"},"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch":{"contents":"\n\nThis error occurs when a parameter of an inductive type is not uniform in an inductive\ndeclaration. The parameters of an inductive type (i.e., those that appear before the colon following\nthe inductive keyword) must be identical in all occurrences of the type being defined in its\nconstructors' types. If a parameter of an inductive type must vary between constructors, make the\nparameter an index by moving it to the right of the colon. See the manual section on\nInductive Types for additional details.\n\nNote that auto-implicit inlay hints always appear left of the colon in an inductive declaration\n(i.e., as parameters), even when they are actually indices. This means that double-clicking on an\ninlay hint to insert such parameters may result in this error. If it does, change the inserted\nparameters to indices.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.inductiveParamMismatch","id":"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators":{"contents":"Infix operators are primarily useful in smaller expressions, or when there is no Monad instance.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax","header":"14.3.1. Infix Operators","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Bitwuzla-Rewrite-Rules":{"contents":"* #7424 proves Bitwuzla's rule\nBV_ZERO_EXTEND_ELIM:theorem setWidth_eq_append {v : Nat} {x : BitVec v} {w : Nat} (h : v ≤ w) :\n    x.setWidth w = ((0#(w - v)) ++ x).cast (by omega) := by\n* #7426 adds the Bitwuzla rewrite rule\nBV_EXTRACT_FULL,\nwhich is useful for the bitblaster to simplify extractLsb' based\nexpressions.* #7427 implements the bitwuzla rule\nBV_CONCAT_EXTRACT.\nThis will be used by the bitblaster to simplify adjacent extracts\ninto a single extract.* #7454 implements the bitwuzla rule\nBV_SIGN_EXTEND_ELIM,\nwhich rewrites a signExtend x as an append of the appropriate sign\nbits, followed by the bits of x.* #7461 introduces a bitvector associativity/commutativity normalization\non bitvector terms of the form (a * b) = (c * d) for a, b, c, d\nbitvectors. This mirrors Bitwuzla's PassNormalize::process's\nPassNormalize::normalize_eq_add_mul.* #7481 implements the Bitwuzla rewrites BV_ADD_NEG_MUL, and\nassociated lemmas to make the proof streamlined. bvneg (bvadd a (bvmul a b)) = (bvmul a (bvnot b)), or spelled as lean:theorem neg_add_mul_eq_mul_not {x y : BitVec w} :\n    - (x + x * y) = (x * ~~~ y)\n* #7482 implements the\nBV_EXTRACT_CONCAT\nrule from Bitwuzla, which explains how to extract bits from an append.\nWe first prove a 'master theorem' which has the full case analysis, from\nwhich we rapidly derive the necessary BV_EXTRACT_CONCAT theorems:theorem extractLsb'_append_eq_ite {v w} {xhi : BitVec v} {xlo : BitVec w} {start len : Nat} :\n    extractLsb' start len (xhi ++ xlo) =\n    if hstart : start < w\n    then\n      if hlen : start + len < w\n      then extractLsb' start len xlo\n      else\n        (((extractLsb' (start - w) (len - (w - start)) xhi) ++\n            extractLsb' start (w - start) xlo)).cast (by omega)\n    else\n      extractLsb' (start - w) len xhi\n\n* #7493 implements the Bitwuzla rewrite rule\nNORM_BV_ADD_MUL,\nand the associated lemmas to allow for expedient rewriting:theorem neg_add_mul_eq_mul_not {x y : BitVec w} : - (x + x * y) = x * ~~~ y\n* #7508 shows that negation commutes with left shift, which is the\nBitwuzla rewrite\nNORM_BV_SHL_NEG.* #7594 implements the Bitwuzla rewrites\nBV_EXTRACT_ADD_MUL,\nwhich witness that the high bits at i >= len do not affect the bits of\nthe product upto len.* #7595 implements the addition rewrite from the Bitwuzla rewrite\nBV_EXTRACT_ADD_MUL,\nwhich witness that the high bits at i >= len do not affect the bits of\nthe sum upto len:theorem extractLsb'_add {w len} {x y : BitVec w} (hlen : len ≤ w) :\n    (x + y).extractLsb' 0 len = x.extractLsb' 0 len + y.extractLsb' 0 len\n* #7757 adds the Bitwuzla rewrite NORM_BV_ADD_CONCAT for symbolic\nsimplification of add-of-append.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Library","header":"Bitwuzla Rewrite Rules","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Bitwuzla-Rewrite-Rules"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Tactics":{"contents":"* #10848 fixes an issue where adding a missing case name after the pipe\nin induction would not remove the now-obsolete error message.* #10858 improves the done tactic in grind interactive mode. It now\ndisplays the grind state diagnostics for all unsolved subgoals.* #10859 fixes auto-completion for set_option in grind interactive\nmode.* #10862 implements the show_term combinator in grind interactive\nmode.* #10874 uses the correct context for elaborating the grind state\nfilter.* #10877 fixes theory propagation issue in grind order.* #10881 fixes a proof instability source in grind.* #10887 uses the new TermInfo.isDisplayableTerm when hovering over\ncases tactic anchors in the grind interactive mode.* #10890 adds a +lax configuration option for grind, causing it to\nignore parameters referring to non-existent theorems, or to theorems for\nwhich we can't generate a pattern. This allows throwing large sets of\ntheorems (e.g. from a premise selection enginre) into grind to see\nwhat happens.* #10899 ensures the generated instantiate tactic instantiates the\ntheorems using the same order used by finish?* #10916 implements parameter optimization for the generated\ninstantiate tactics produced by finish?.\nWe use a simple parameter optimizer that takes two sets as input: the\nlower and upper bounds.\nThe lower bound consists of the theorems actually used in the proof\nterm, while the upper bound includes all the theorems instantiated in a\nparticular theorem instantiation step.\nThe lower bound is often sufficient to replay the proof, but in some\ncases, additional theorems must be included because a theorem\ninstantiation may contribute to the proof by providing terms and many\nnot be present in the final proof term.* #10919 implements the have <ident>? : <prop> tactic for the grind\ninteractive mode. The proposition is proved using the default grind\nsearch strategy. This tactic is also useful for inspecting or querying\nthe current grind state.* #10920 adds support for grind +premises, calling the currently\nconfigured premise selection algorithm and including the results as\nparameters to grind. (Recall that there is not currently a default\npremise selector provided by Lean4: you need a downstream premise\nselector to make use of this.)* #10936 fixes issues in grind => finish? that were preventing\ngenerated grind tactic scripts from being successfully replayed.* #10937 fixes a missing counter reset at the cases tactic in grind\ninteractive mode.* #10938 ensures solver grind tactics (e.g., ac, ring, lia, etc)\nprocess pending facts after making progress.* #10939 fixes another instance of the “default parameter value in\nconstructor” footgun, which was affecting the cases tactic in the\ngrind interactive mode.* #10948 ensures that finish? produces partial tactic scripts\ncontaining sorrys.\nWe may add an option to disable this feature in the future.\nIt is enabled by default because it provides a useful way to debug\ngrind failures.* #10949 ensures that solver propagation steps are necessary in the\ngenerated tactic script to close the goal.* #10950 adds the mbtc tactic to the grind interactive mode. It\nimplements model-based theory combination. It also ensures finish? is\ncapable of generating it.* #10951 fixes a bug in the cutsat incremental model construction. The\nmodel was not being reset when new (unsatisfied) equalities were\nasserted.* #10955 fixes a regression in the grind order module introduced by* #10956 fixes a bug in the equality propagation procedure in\ngrind.order. Specifically, it affects the procedure that asserts\nequalities in the grind core state that are implied by (ring)\ninequalities in the grind.order module.* #10960 fixes a bug in the grind linarith model/counterexample\nconstruction.* #10961 adds support for scientific literals for Rat in grind.\ngrind does not yet add support for this kind of literal in arbitrary\nfields.* #10962 fixes a spurious warning message in grind.* #10964 adds a propagator for a^(n+m) and removes its normalizer. This\nchange was motivated by issue #10661* #10965 ensures that model-based theory combination in grind cutsat\nconsiders nonlinear terms. Nonlinear multiplications such as x * y are\ntreated as uninterpreted symbols in cutsat.* #10971 adds a LawfulOfScientific class, providing compatibility with\na Lean.Grind.Field structure.* #10975 adds the combinator  · t_1 ... t_n to the grind interactive\nmode. The finish? tactic now generates scripts using this combinator\nto conform to Mathlib coding standards. The new format is also more\ncompact. Example:/--\ninfo: Try this:\n  [apply] ⏎\n    instantiate only [= mem_indices_of_mem, insert, = getElem_def]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #f590\n    · cases #ffdf\n      · instantiate only\n        instantiate only [= Array.getElem_set]\n      · instantiate only\n        instantiate only [size, = HashMap.mem_insert, = HashMap.getElem_insert, = Array.getElem_push]\n    · instantiate only [= mem_indices_of_mem, = getElem_def]\n      instantiate only [usr getElem_indices_lt]\n      instantiate only [size]\n      cases #ffdf\n      · instantiate only [=_ WF]\n        instantiate only [= getElem?_neg, = getElem?_pos, = Array.getElem_set]\n        instantiate only [WF']\n      · instantiate only\n        instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert, = Array.getElem_push]\n-/\n#guard_msgs in\nexample (m : IndexMap α β) (a a' : α) (b : β) (h : a' ∈ m.insert a b) :\n    (m.insert a b)[a'] = if h' : a' == a then b else m[a'] := by\n  grind => finish?\n* #10978 implements the following grind improvements:1. set_option can now be used to set grind configuration options in\nthe interactive mode.2. Fixes a bug in the repeated theorem instantiation detection.3. Adds the macro use [...] as a shorthand for instantiate only [...].* #10990 adds the set_config tactic for setting grind configuration\noptions. It uses the same syntax used for setting configuration options\nin the grind main tactic.* #10991 renames cutsat in configuration options and trace messages to\nlia.* #10992 ensures that grind +premises silently drops warnings and\nerrors about bad suggestions.* #10997 adds support for configuration options at finish and\nfinish?.* #11003 adds support for specifying anchors to restrict the search space\nin grind when using grind only. Anchors can limit which case splits\nare performed and which local lemmas are instantiated.* #11012 ensures the grind tactics finish and finish? can take\nparameters.* #11026 fixes a nontermination and missing propagation bug in grind order. It also register relevant case-splits for arithmetic.* #11028 ensures that grind? +premises removes +premises from the\n\"Try this\" suggestion.* #11029 changes the terminology used from \"premise selection\" to\n\"library suggestions\". This will be more understandable to users (we\ndon't assume anyone is familiar with the premise selection literature),\nand avoids a conflict with the existing use of \"premise\" in Lean\nterminology (e.g. \"major premise\" in induction, as well as generally the\nsynonym for \"hypothesis\"/\"argument\").* #11030 adds a library suggestion engine for local theorems. To be\nuseful, I still need to write more combinators to re-rank and combine\nsuggestions from multiple engines.* #11032 implements simp? +suggestions, which uses the configured\nlibrary suggestion engine to add relevant theorems to the simp call.\nsimp +suggestions without the ? prints a message requiring adding\nthe ?.* #11034 adds a new suggestion to finish?. It now generates the grind\ntactic script as before, and a finish only tactic. Example:/--\ninfo: Try these:\n  [apply] ⏎\n    instantiate only [findIdx, insert, = mem_indices_of_mem]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #1bba\n    · instantiate only [findIdx]\n    · instantiate only\n      instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert]\n  [apply] finish only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert, #1bba]\n-/\nexample (m : IndexMap α β) (a : α) (b : β) :\n    (m.insert a b).findIdx a = if h : a ∈ m then m.findIdx a else m.size := by\n  grind => finish?\n* #11039 fixes the grind invalid universe level regression reported in\n#11036* #11040 fixes a panic that occurred during the processing of generalized\nE-matching patterns in grind.* #11047 implements (nested term) equality propagation in grind order.\nThat is, it propagates implied equalities from grind order back to the\ngrind core. Examples:open Lean Grind Std\n\n* #11049 implements equality propagation for Nat in grind order.\ngrind order supports offset equalities for rings, but it has an\nadapter for Nat. Example:example (a b : Nat) (f : Nat → Int) : a ≤ b + 1 → b + 1 ≤ a → f (1 + a) = f (1 + b + 1) := by\n  grind -offset -mbtc -lia -linarith (splits := 0)\n* #11050 fixes equality propagation for Nat in grind order.* #11051 removes the grind offset module because it is (now) subsumed\nby grind order.* #11057 implements grind? using the new grind => finish?\ninfrastructure.* #11061 fixes a deep recursion issue in the kernel when type-checking a\nproof term produced by grind.* #11071 ensures that the denote functions used to implement\nproof-by-reflection terms in grind are abbreviations. This change\neliminates the need for the withAbstractAtoms gadget.* #11075 updates simp? +suggestions so that if a name is ambiguous\n(because of namespaces) all alternatives are used, rather than erroring.* #11077 fixes the anchor values produced by grind?* #11080 fixes a panic during equality propagation in the grind ring\nmodule. If the maximum number of steps has been reached, the polynomials\nmay not be fully simplified.* #11084 fixes a stack overflow that occurs when constructing a proof\nterm in grind.* #11087 enables grind to case bash on Sum and PSum.* #11092 ensures that grind ac denotation functions used in proof by\nreflection are marked as abbrev.* #11098 updates the suggestions tactic so the printed message includes\nhoverable type information (and displays scores and flags when\nrelevant).* #11099 improves the support for universe-metavariables in grind.* #11101 fixes an initialization issue for local Function.Injective f\nhypotheses.* #11126 ensures grind does not fail when applying injection to a\nhypothesis that cannot be cleared because of forward dependencies.* #11133 fixes disequality propagation for constructor applications in\ngrind. The equivalence class representatives may be distinct\nconstructor applications, but we must ensure they have the same type.\nExamples that were panic'ing before this PR:example (a b : List Nat)\n    : a ≍ ([] : List Int) → b ≍ ([1] : List Int) → a = b ∨ p → p := by\n  grind\n\n* #11135 ensures that checkExp is used in grind lia (formerly known\nas grind cutsat) and grind ring to prevent stack overflows.* #11136 adds support for try? to use induction; it will only perform\ninduction on inductive types defined in the current namespace and/or\nmodule; so in particular for now it will not induct on built-in\ninductives such as Nat or List.* #11137 fixes a stackoverflow during proof construction in grind.* #11145 fixes a bug in isMatchCondCandidate used in grind. The\nmissing condition was causing a \"not internalized term\" grind internal\nerror.* #11147 refactors the implementation of the symmetric equality\ncongruence rule used in grind.* #11148 addst the cases_next tactic to the grind interactive mode.* #11149 adds a user-extension mechanism for the try? tactic. You can\neither use the @[try_suggestion] attribute on a declaration with\nsignature MVarId -> Try.Info -> MetaM (Array (TSyntax `tactic)) to\nproduce suggestions, or the register_try?_tactic <stx> command with a\nfixed piece of syntax. User-extensions are only tried after the\nbuilt-in try strategies have been tried and failed.* #11157 implements the #grind_lint command, a diagnostic tool for\nanalyzing the behavior of theorems annotated for theorem instantiation.\nThe command helps identify problematic theorems that produce excessive\nor unbounded instance generation during E-matching, which can lead to\nperformance issues.\nThe main entry point is:#grind_lint check\nwhich analyzes all theorems marked with the @[grind] attribute.\nFor each theorem, it creates an artificial goal and runs grind,\ncollecting statistics about the number of instances produced.\nResults are summarized using info messages, and detailed breakdowns are\nshown for lemmas exceeding a configurable threshold.\nAdditional subcommands are provided for targeted inspection and control:* #grind_lint inspect thm: analyzes one or more specific theorems in\ndetail* #grind_lint mute thm: excludes a theorem from instantiation during\nanalysis* #grind_lint skip thm: omits a theorem from being analyzed by\n#grind_lint check* #11166 implements the following improvements to the #grind_lint\ncommand:1. More informative messages when the number of instances exceeds the\nminimum threshold.2. A code action for #grind_lint inspect that inserts\nset_option trace.grind.ematch.instance true whenever the number of\ninstances exceeds\nthe minimum threshold.3. Displaying doc strings for grind configuration options in\n#grind_lint.4. Improve doc strings for #grind_lint inspect and #grind_lint check.* #11167 implements support for #grind_lint check in module <module>.\nMathlib does not use namespaces, so we need to restrict the\n#grind_lint search space using module (prefix) names. Example:/--\ninfo: instantiating `Array.filterMap_some` triggers more than 100 additional `grind` theorem instantiations\n---\ninfo: Array.filterMap_some\n[thm] instances\n  [thm] Array.filterMap_filterMap ↦ 94\n  [thm] Array.size_filterMap_le ↦ 5\n  [thm] Array.filterMap_some ↦ 1\n---\ninfo: instantiating `Array.range_succ` triggers 22 additional `grind` theorem instantiations\n-/\n#guard_msgs in\n#grind_lint check (min := 20) in module Init.Data.Array\n* #11168 changes the default library suggestions (e.g. for grind +suggestions or `simp_all? +suggestions) to include the theorems from\nthe current file in addition to the output of Sine Qua Non.* #11170 adds tactic and term mode macros for ∎ (typed \\qed) which\nexpand to try?. The term mode version captures any produced\nsuggestions and prepends by.* #11171 ensures that tactics using library suggestions set the caller\nfield, so the premise selection engine has access to this. We'll later\nuse this to filter out some modules for grind, which we know have\nalready been fully annotated.* #11172 removes simp_all? +suggestions from try? for now. It's\nreally slow out in Mathlib; too often the suggestions cause simp to\nloop. Until we have the ability for try? to move past a timeing-out\ntactic (or maybe even until we have parallelism), it needs to be\nremoved.* #11174 modifies the try? framework, so each subsidiary tactic runs\nwith a separate maxHeartbeats budget.* #11187 adds syntax for specifying grind_pattern constraints and\nextends the EMatchTheorem object.* #11189 implements grind_pattern constraints. They are useful for\ncontrolling theorem instantiation in grind. As an example, consider\nthe following two theorems:theorem extract_empty {start stop : Nat} :\n    (#[] : Array α).extract start stop = #[] := …\n\n* #11193 uses the new grind_pattern constraints to fix cases where an\nunbounded number of theorem instantiations would be generated for\ncertain theorems in the standard library.* #11194 the redundant grind parameter warning message. It now checks\nthe grind theorem instantiation constraints too.* #11197 implements try? using the new finish? infrastructure. It\nalso removes the old tracing infrastructure, which is now obsolete.\nExample:/--\ninfo: Try these:\n  [apply] grind\n  [apply] grind only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert, #1bba]\n  [apply] grind only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert]\n  [apply] grind =>\n    instantiate only [findIdx, insert, = mem_indices_of_mem]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #1bba\n    · instantiate only [findIdx]\n    · instantiate only\n      instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert]\n-/\n#guard_msgs in\nexample (m : IndexMap α β) (a : α) (b : β) :\n    (m.insert a b).findIdx a = if h : a ∈ m then m.findIdx a else m.size := by\n  try?\n* #11203 fixes a few minor issues in the new Action framework used in\ngrind. The goal is to eventually delete the old SearchM\ninfrastructure. The main solve function used by grind is now based\non the Action framework. The PR also deletes dead code in SearchM.* #11204 has #grind_list check produce a \"Try this:\" suggestion with\n#grind_list inspect commands, as this is usually the next step in\ndealing with problematic cases. We also fix the grind pattern for one\ntheorem, as part of testing the workflow. More to follow.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0 (2025-12-13)","header":"Tactics","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Tactics"},"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Breaking-changes":{"contents":"While most changes could be considered to be a breaking change, this section makes special note of API changes.\n\n* Nat.zero_or and Nat.or_zero have been swapped (#4094).* IsLawfulSingleton is now LawfulSingleton (#4350).* The BitVec literal notation is now <num>#<term> rather than <term>#<term>, and it is global rather than scoped. Use BitVec.ofNat w x rather than x#w when x is a not a numeric literal (0d3051).* BitVec.rotateLeft and BitVec.rotateRight now take the shift modulo the bitwidth (#4229).* These are no longer simp lemmas:\nList.length_pos (#4172),\nOption.bind_eq_some (#4314).* Types in let and have (both the expressions and tactics) may fail to elaborate due to new restrictions on what sorts of elaboration problems may be postponed (#4096).\nIn particular, tactics embedded in the type will no longer make use of the type of value in expressions such as let x : type := value; body.* Now functions defined by well-founded recursion are marked with @[irreducible] by default (#4061).\nExisting proofs that hold by definitional equality (e.g. rfl) can be\nrewritten to explicitly unfold the function definition (using simp,\nunfold, rw), or the recursive function can be temporarily made\nsemireducible (using unseal f in before the command), or the function\ndefinition itself can be marked as @[semireducible] to get the previous\nbehavior.* Due to #3929:* The MessageData.ofPPFormat constructor has been removed.\nIts functionality has been split into two:* for lazy structured messages, please use MessageData.lazy;* for embedding Format or FormatWithInfos, use MessageData.ofFormatWithInfos.An example migration can be found in #3929.* The MessageData.ofFormat constructor has been turned into a function.\nIf you need to inspect MessageData, you can pattern-match on MessageData.ofFormatWithInfos.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.9.0 (2024-07-01)","header":"Breaking changes","id":"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Breaking-changes"}});