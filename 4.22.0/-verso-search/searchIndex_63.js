window.docContents[63].resolve({"/Tactic-Proofs/Tactic-Reference/#tactic-ref-equality":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-equality","header":"13.5.4.1. Equality","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Relations","contents":"subst x... substitutes each hypothesis x with a definition found in the local context,\nthen eliminates the hypothesis.* If x is a local definition, then its definition is used.* Otherwise, if there is a hypothesis of the form x = e or e = x,\nthen e is used for the definition of x.If h : a = b, then subst h may be used if either a or b unfolds to a local hypothesis.\nThis is similar to the cases h tactic.See also: subst_vars for substituting all local hypotheses that have a defining equation.\n\nsubst_eq repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n\nApplies subst to all hypotheses of the form h : x = t or h : t = x.\n\nApply congruence (recursively) to goals of the form ⊢ f as = f bs and ⊢ f as ≍ f bs.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when congr is too aggressive in breaking down the goal.\nFor example, given ⊢ f (g (x + y)) = f (g (y + x)),\ncongr produces the goals ⊢ x = y and ⊢ y = x,\nwhile congr 2 produces the intended ⊢ x + y = y + x.\n\neq_refl is equivalent to exact rfl, but has a few optimizations.\n\nac_rfl proves equalities up to application of an associative and commutative operator.instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n\n\n"},"/Error-Explanations/lean___inductiveParamMissing/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMissing":{"id":"/Error-Explanations/lean___inductiveParamMissing/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMissing","header":"lean.inductiveParamMissing","context":"Lean Reference\u0009Error Explanations","contents":"\n\nThis error occurs when an inductive type constructor is partially applied in the type of one of its\nconstructors such that one or more parameters of the type are omitted. The elaborator requires that\nall parameters of an inductive type be specified everywhere that type is referenced in its\ndefinition, including in the types of its constructors.\n\nIf it is necessary to allow the type constructor to be partially applied, without specifying a given\ntype parameter, that parameter must be converted to an index. See the manual section on\nInductive Types for further explanation of the difference\nbetween indices and parameters.\n\n\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Libraries":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Libraries","header":"22.1.3.2.4.1. Libraries","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format\u0009Targets","contents":"Library TargetsTo define a library in which all configurable fields have their default values, use lean_lib with no further fields.The default configuration can be modified by providing the new values.\n\nThe fields of lean_lib are those of the LeanLibConfig structure.\n\nA Lean library's declarative configuration.The subdirectory of the package's source directory containing the library's\nLean source files. Defaults simply to said srcDir.(This will be passed to lean as the -R option.)The root module(s) of the library.\nSubmodules of these roots (e.g., Lib.Foo of Lib) are considered\npart of the library.\nDefaults to a single root of the target's name.An Array of module Globs to build for the library.\nDefaults to a Glob.one of each of the library's  roots.Submodule globs build every source file within their directory.\nLocal imports of glob'ed files (i.e., fellow modules of the workspace) are\nalso recursively built.The name of the library artifact.\nUsed as a base for the file names of its static and dynamic binaries.\nDefaults to the mangled name of the target.An Array of targets to build before the executable's modules.Deprecated. Use needs instead.\nAn Array of target names to build before the library's modules.Whether to compile each of the library's modules into a native shared library\nthat is loaded whenever the module is imported. This speeds up evaluation of\nmetaprograms and enables the interpreter to run functions marked @[extern].Defaults to false.An Array of library facets to build on a bare lake build of the library.\nFor example, #[LeanLib.sharedLib] will build the shared library facet.The module facets to build and combine into the library's static\nand shared libraries. If shouldExport is true, the module facets should\nexport any symbols a user may expect to lookup in the library. For example,\nthe Lean interpreter will use exported symbols in linked libraries.Defaults to a singleton of Module.oExportFacet (if shouldExport) or\nModule.oFacet. That is, the  object files compiled from the Lean sources,\npotentially with exported Lean symbols.\n\n"},"/Basic-Types/Maps-and-Sets/#TreeMap":{"id":"/Basic-Types/Maps-and-Sets/#TreeMap","header":"19.17.8. Tree-Based Maps","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","contents":"The declarations in this section should be imported using import Std.TreeMap.\n\nTree maps.A tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one entry\nwith key either a or b in a tree map. Looking up either a or b always yields the same entry,\nif any is present.To avoid expensive copies, users should make sure that the tree map is used linearly.Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.For use in proofs, the type Std.ExtTreeMap of extensional tree maps should be preferred. This\ntype comes with several extensionality lemmas and provides the same functions but requires a\nTransCmp instance to work with.These tree maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.TreeMap.Raw and\nStd.TreeMap.Raw.WF unbundle the invariant from the tree map. When in doubt, prefer\nTreeMap over TreeMap.Raw.\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Termination-Helpers":{"id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Termination-Helpers","header":"19.16.4.14. Termination Helpers","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","contents":"“Attaches” the proof that the elements of xs are in fact elements of xs, producing a new array with\nthe same elements but in the subtype { x // x ∈ xs }.O(1).This function is primarily used to allow definitions by well-founded\nrecursion that use higher-order functions (such as\nArray.map) to prove that an value taken from a list is smaller than the list. This allows the\nwell-founded recursion mechanism to prove that the function terminates.\n\n“Attaches” individual proofs to an array of values that satisfy a predicate P, returning an array\nof elements in the corresponding subtype { x // P x }.O(1).\n\nMaps an array of terms in a subtype to the corresponding terms in the type by forgetting that they\nsatisfy the predicate.This is the inverse of Array.attachWith and a synonym for xs.map (·.val).Mostly this should not be needed by users. It is introduced as an intermediate step by lemmas such\nas map_subtype, and is ideally subsequently simplified away by unattach_attach.This function is usually inserted automatically by Lean as an intermediate step while proving\ntermination. It is rarely used explicitly in code. It is introduced as an intermediate step during\nthe elaboration of definitions by well-founded\nrecursion. If this function is encountered in a proof\nstate, the right approach is usually the tactic simp [Array.unattach, -Array.map_subtype].\n\nMaps a partially defined function (defined on those terms of α that satisfy a predicate P) over\nan array xs : Array α, given a proof that every element of xs in fact satisfies P.Array.pmap, named for “partial map,” is the equivalent of Array.map for such partial functions.\n\n"},"/#lean-language-reference":{"id":"/#lean-language-reference","header":"The Lean Language Reference","context":"","contents":"This is the Lean Language Reference.\nIt is intended to be a comprehensive, precise description of Lean: a reference work in which Lean users can look up detailed information, rather than a tutorial intended for new users.\nFor other documentation, please refer to the Lean documentation overview.\nThis manual covers Lean version 4.22.0.\n\nLean is an interactive theorem prover based on dependent type theory, designed for use both in cutting-edge mathematics and in software verification.\nLean's core type theory is expressive enough to capture very complicated mathematical objects, but simple enough to admit independent implementations, reducing the risk of bugs that affect soundness.\nThe core type theory is implemented in a minimal kernel that does nothing other than check proof terms.\nThis core theory and kernel are supported by advanced automation, realized in an expressive tactic language.\nEach tactic produces a term in the core type theory that is checked by the kernel, so bugs in tactics do not threaten the soundness of Lean as a whole.\nAlong with many other parts of Lean, the tactic language is user-extensible, so it can be built up to meet the needs of a given formalization project.\nTactics are written in Lean itself, and can be used immediately upon definition; rebuilding the prover or loading external modules is not required.\n\nLean is also a pure functional programming language, with features such as a run-time system based on reference counting that can efficiently work with packed array structures, multi-threading, and monadic IO.\nAs befits a programming language, Lean is primarily implemented in itself, including the language server, build tool, elaborator, and tactic system.\nThis very book is written in Verso, a documentation authoring tool written in Lean.\n\nFamiliarity with Lean's programming features is valuable even for users whose primary interest is in writing proofs, because Lean programs are used to implement new tactics and proof automation.\nThus, this reference manual does not draw a barrier between the two aspects, but rather describes them together so they can shed light on one another.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}});