/-
Copyright (c) 2025 Lean FRO LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: David Thrane Christiansen
-/

import VersoManual

import Lean.Parser.Command
import Lake

import Manual.Meta

open Manual
open Verso.Genre
open Verso.Genre.Manual


open Lean.Elab.Tactic.GuardMsgs.WhitespaceMode


#doc (Manual) "Lake and Reservoir" =>
%%%
tag := "build-tools-and-distribution"
%%%

# Lake
%%%
tag := "lake"
%%%

::: planned 75
 * Port and organize the information in the Lake README
 * Describe the underlying Lake-specific concepts of traces, artifacts, workspaces, and facets
:::


Lake is the standard Lean build tool.
It is responsible for:
 * Configuring builds and building Lean code
 * Fetching and building external dependencies
 * Integrating with Reservoir, the Lean package server
 * Running tests, linters, and other development workflows

Lake is extensible.
It provides a rich API that can be used to {TODO}[examples]

This section describes Lake's {ref "lake-cli"}[command-line interface], {ref "lake-config"}[configuration files], and {ref "lake-api"}[internal API].
All three share a set of concepts and terminology, which is described in {ref "lake-vocab"}[a dedicated subsection].

## Concepts and Terminology
%%%
tag := "lake-vocab"
%%%

A {deftech}_package_ is the basic unit of Lean code distribution.
Packages contain {tech}[targets], which are the basic unit of code to be built.
They consist of a directory that contains a {tech}[package configuration] file together with source code.
Packages may {deftech}_require_ other packages, in which case those packages' code (more specifically, their {tech}[targets]) are made available.
The {deftech}_direct dependencies_ of a package are those that it requires, and the {deftech}_transitive dependencies_ are the direct dependencies of a package together with their transitive dependencies.

A {deftech}_workspace_ is a directory on disk that contains a package's source code and the source code of its {tech}[transitive dependencies].
The workspace also contains any built {tech}[artifacts] for the package, enabling incremental builds.{TODO}[xref and def]
Dependencies and artifacts do not need to be present for a directory to be considered a workspace; commands such as `lake update` and `lake build` produce them.
With the exception of commands such as `lake init`, Lake is typically used in a workspace.


A {deftech}_package configuration_ file specifies the dependencies, settings, and targets of a package.
Packages can specify configuration options that apply to all their contained targets.
They can be written in two formats:
 * The TOML format (`lakefile.toml`) is used for fully declarative package configurations.
 * The Lean format (`lakefile.lean`) additionally supports the use of Lean code to configure the package in ways not supported by the declarative options.

A {deftech}_manifest_ tracks the specific versions of other packages that are used in a package.
Together, a manifest and a {tech}[package configuration] file specify a unique set of transitive dependencies for the package.

A {deftech}_target_ represents a build product that can be requested by a user:

 * {deftech}_Libraries_ are collections of Lean {tech}[module]s, organized hierarchically under one or more {tech}_module roots_.
 * {deftech}_Executables_ consist of a _single_ module that defines `main`
 * {deftech}_External libraries_ {TODO}[add as a TODO due to upcoming refactor]
 * {deftech}_Static libraries_ {TODO}[add as a TODO due to upcoming refactor]
 * {deftech}_Custom targets_ contain arbitrary code to run a build, written using {name Lake.FetchM}`FetchM` in {TODO}[xref]Lake's API.

An {deftech}_artifact_ is the persistent result of a build, such as object code, an executable binary, or an {tech}[`.olean` file].
Artifacts can result from builds at three levels of granularity: modules, targets, and packages.
There is a one-to-many relationship between each of these inputs and the resulting artifacts; for example, a building a module produces an `.olean` file and an `.ilean` file, along with a C source file that contains the code generated by Lean's compiler and an object file generated by the C compiler.




The {deftech}_log_ contains information produced during a build.
Logs are saved so they can be replayed during incremental builds.
Messages in the log have four levels, ordered by severity:

 1. Trace messages contain internal build details that are often specific to the machine on which the build is running, including the specific invocations of Lean and other tools that are passed to the shell.
 2. Informational messages contain general informational output that is not expected to indicate a problem with the code, such as the results of a {keywordOf Lean.Parser.Command.eval}`#eval` command.
 3. Warnings indicate potential problems, such as unused variable bindings.
 4. Errors explain why parsing and elaboration could not complete.

### Facets
%%%
tag := "lake-facets"
%%%

A {deftech}_facet_ describes the production of an artifact from a module, target, or package.
Each kind of target has a default facet (e.g. producing an executable binary from an executable target); other facets may be specified explicitly in the {tech}[package configuration] or via Lake's {ref "lake-cli"}[command-line interface].
Lake's API may be used to write custom facets. {TODO}[xref]



```lakeHelp "build"
Build targets

USAGE:
  lake build [<targets>...]

A target is specified with a string of the form:

  [[@]<package>/][<target>|[+]<module>][:<facet>]

The optional `@` and `+` markers can be used to disambiguate packages
and modules from other kinds of targets (i.e., executables and libraries).

LIBRARY FACETS:         build the library's ...
  leanArts (default)    Lean artifacts (*.olean, *.ilean, *.c files)
  static                static artifact (*.a file)
  shared                shared artifact (*.so, *.dll, or *.dylib file)

MODULE FACETS:          build the module's ...
  deps                  dependencies (e.g., imports, shared libraries, etc.)
  leanArts (default)    Lean artifacts (*.olean, *.ilean, *.c files)
  olean                 OLean (binary blob of Lean data for importers)
  ilean                 ILean (binary blob of metadata for the Lean LSP server)
  c                     compiled C file
  bc                    compiled LLVM bitcode file
  c.o                   compiled object file (of its C file)
  bc.o                  compiled object file (of its LLVM bitcode file)
  o                     compiled object file (of its configured backend)
  dynlib                shared library (e.g., for `--load-dynlib`)

TARGET EXAMPLES:        build the ...
  a                     default facet of target `a`
  @a                    default target(s) of package `a`
  +A                    Lean artifacts of module `A`
  a/b                   default facet of target `b` of package `a`
  a/+A:c                C file of module `A` of package `a`
  :foo                  facet `foo` of the root package

A bare `lake build` command will build the default facet of the root package.
Package dependencies are not updated during a build.
```

The facets available for packages are:

::: TODO

Confirm these with Mac

:::

 * `optCache` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `cache` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `optBarrel` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `barrel` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `optRelease` A package's _optional_ build archive from a GitHub release. Will *not* cause the whole build to fail if the release cannot be fetched.

 * `release` A package's _optional_ build archive from a GitHub release. Will cause the whole build to fail if the archive cannot be fetched.

The facets available for targets (including libraries and executables) are:

 * `leanArts` contains the artifacts that the Lean compiler produces for the library ({tech key:="olean files"}`*.olean`, `*.ilean`, and `*.c` files).
 * `static` contains the static library produced by the C compiler from the `leanArts` (that is, a `*.a` file).
 * `static.export` contains the static library produced by the C compiler from the `leanArts` (that is, a `*.a` file), with exported symbols.
 * `shared` contains the shared library (that is, a `*.so`, `*.dll`, or `*.dylib` file, depending on the platform).
 * `extraDep` contains a Lean library's `extraDepTargets` {TODO}[xref] and those of its package.
 * `leanExe` contains the executable binary produced from a Lean executable target.

The facets available for modules are:
 * `deps`                  dependencies (e.g., imports, shared libraries, etc.)
 * `leanArts` (default)    Lean artifacts (`*.olean`, `*.ilean`, `*.c` files)
 * `olean`                 OLean (binary blob of Lean data for importers)
 * `ilean`                 ILean (binary blob of metadata for the Lean LSP server)
 * `c`                     compiled C file
 * `bc`                    compiled LLVM bitcode file
 * `c.o`                   compiled object file (of its C file)
 * `bc.o`                  compiled object file (of its LLVM bitcode file)
 * `o`                     compiled object file (of its configured backend)
 * `dynlib`                shared library (e.g., for `--load-dynlib`)



UI Concepts

When I build a target, the packages' dependencies are built before the target.

Two notions of dependencies:
 * Packages depend on packages
 * Targets may depend on targets from other package
 * "ExtraDepTargets" imposes dependencies on all targets in a package

A target is something I wish to ask for - the user requests it. Front-facing name of the thing I want to ask for.
A build product on disk is named by a target and a facet. Each target has a default facet.

A build product is an _artifact_ - any persistent result.

The "workspace" is also part of the UI

A workspace is the full set of all required packages.
The "known universe" to lake.
Relevant when setting up the server - the server needs to know all the code to point at.
The workspace is composed of multiple packages - incl. the root package.
The root package is the one whose config file is read.

Package is unit of distribution, workspace is the name of the local files.

What is query? It's a way to get output from Lake from a target that doesn't go through a target.
Mostly machine-readable, and not interleaved with all the log stuff.

Pack/unpack: related to cloud releases/cloud build archives.
They give a "crate"/"uncrate".
They "zip up the build dir" essentially - unless platform independent option is set (no platform traces)
These are beta features

Upload: perhaps use from GH action?

It's an error if there's an incomplete manifest

Configuring a package is to parse the configuration, apply the options.
This is a one-time thing, and you must use `-R`.
Configuration happens again if the file changes, but changes to -K options require -R

Log levels: "trace" is hidden unless verbose

Modules in Lake are Lean modules + potentially generated ones not existing as code in the users's source directory
Module is the unit of code visible to the build system (smallest code unit visible to the build system)

Targets are:


Test driver: exe, script, library

Linters: exe or script

The check- versions are used to tell whether the problem is failing tests/lints vs misconfigured builds

:::TODO

What does Lake do and what does it not do?

Manifests

:::

### Test and Linter Drivers
%%%
tag := "test-lint-drivers"
%%%

:::TODO
Take text from README and lake help test/lake help lint
:::

A {deftech}_test driver_ is ... {TODO}[write]

A {deftech}_lint driver_ is ... {TODO}[write]

A test driver can be configured by either setting the 'testDriver'
package configuration option or by tagging a script, executable, or library
`@[test_driver]`. A definition in a dependency can be used as a test driver
by using the `<pkg>/<name>` syntax for the 'testDriver' configuration option.


## Command-Line Interface
%%%
tag := "lake-cli"
%%%


```lakeHelp
USAGE:
  lake [OPTIONS] <COMMAND>

COMMANDS:
  new <name> <temp>     create a Lean package in a new directory
  init <name> <temp>    create a Lean package in the current directory
  build <targets>...    build targets
  exe <exe> <args>...   build an exe and run it in Lake's environment
  check-build           check if any default build targets are configured
  test                  test the package using the configured test driver
  check-test            check if there is a properly configured test driver
  lint                  lint the package using the configured lint driver
  check-lint            check if there is a properly configured lint driver
  clean                 remove build outputs
  env <cmd> <args>...   execute a command in Lake's environment
  lean <file>           elaborate a Lean file in Lake's context
  update                update dependencies and save them to the manifest
  pack                  pack build artifacts into an archive for distribution
  unpack                unpack build artifacts from an distributed archive
  upload <tag>          upload build artifacts to a GitHub release
  script                manage and run workspace scripts
  scripts               shorthand for `lake script list`
  run <script>          shorthand for `lake script run`
  translate-config      change language of the package configuration
  serve                 start the Lean language server

BASIC OPTIONS:
  --version             print version and exit
  --help, -h            print help of the program or a command and exit
  --dir, -d=file        use the package configuration in a specific directory
  --file, -f=file       use a specific file for the package configuration
  -K key[=value]        set the configuration file option named key
  --old                 only rebuild modified modules (ignore transitive deps)
  --rehash, -H          hash all files for traces (do not trust `.hash` files)
  --update, -U          update dependencies on load (e.g., before a build)
  --packages=file       JSON file of package entries that override the manifest
  --reconfigure, -R     elaborate configuration files instead of using OLeans
  --keep-toolchain      do not update toolchain on workspace update
  --no-build            exit immediately if a build target is not up-to-date
  --no-cache            build packages locally; do not download build caches
  --try-cache           attempt to download build caches for supported packages

OUTPUT OPTIONS:
  --quiet, -q           hide informational logs and the progress indicator
  --verbose, -v         show trace logs (command invocations) and built targets
  --ansi, --no-ansi     toggle the use of ANSI escape codes to prettify output
  --log-level=lv        minimum log level to output on success
                        (levels: trace, info, warning, error)
  --fail-level=lv       minimum log level to fail a build (default: error)
  --iofail              fail build if any I/O or other info is logged
                        (same as --fail-level=info)
  --wfail               fail build if warnings are logged
                        (same as --fail-level=warning)


See `lake help <command>` for more information on a specific command.
```

Lake's command-line interface provides ... {TODO}[finish]

### Environment Variables
%%%
tag := "lake-environment"
%%%

```lakeHelp "env"
Execute a command in Lake's environment

USAGE:
  lake env [<cmd>] [<args>...]

Spawns a new process executing `cmd` with the given `args` and with
the environment set based on the detected Lean/Lake installations and
the workspace configuration (if it exists).

Specifically, this command sets the following environment variables:

  LAKE                  set to the detected Lake executable
  LAKE_HOME             set to the detected Lake home
  LEAN_SYSROOT          set to the detected Lean toolchain directory
  LEAN_AR               set to the detected Lean `ar` binary
  LEAN_CC               set to the detected `cc` (if not using the bundled one)
  LEAN_PATH             adds Lake's and the workspace's Lean library dirs
  LEAN_SRC_PATH         adds Lake's and the workspace's source dirs
  PATH                  adds Lean's, Lake's, and the workspace's binary dirs
  PATH                  adds Lean's and the workspace's library dirs (Windows)
  DYLD_LIBRARY_PATH     adds Lean's and the workspace's library dirs (MacOS)
  LD_LIBRARY_PATH       adds Lean's and the workspace's library dirs (other)

A bare `lake env` will print out the variables set and their values,
using the form NAME=VALUE like the POSIX `env` command.
```


When invoking the Lean compiler or other tools, Lake sets or modifies a number of environment variables.{index}[environment variables]
These values are system-dependent.
Invoking {lake}`env` without any arguments displays the environment variables and their values.
Otherwise, {lakeMeta}`cmd` is invoked in Lake's environment with arguments {lakeMeta}`args`.

The following variables are set, overriding previous values:
:::table
* row
  * `LAKE`
  * The detected Lake executable
* row
  * `LAKE_HOME`
  * The detected {tech}[Lake home]
* row
  * `LEAN_SYSROOT`
  * The detected Lean {tech}[toolchain] directory
* row
 * `LEAN_AR`
 * The detected Lean `ar` binary
* row
  * `LEAN_CC`
  * The detected C compiler (if not using the bundled one)
:::

The following variables are augmented with additional information:
:::table
* row
  * `LEAN_PATH`
  * Lake's and the {tech}[workspace]'s Lean {tech}[library directories] are added.
* row
  * `LEAN_SRC_PATH`
  * Lake's and the {tech}[workspace]'s {tech}[source directories] are added.
* row
  * `PATH`
  * Lean's, Lake's, and the {tech}[workspace]'s {tech}[binary directories] are added.
    On Windows, Lean's and the {tech}[workspace]'s {tech}[library directories] are also added.
* row
  * `DYLD_LIBRARY_PATH`
  * On macOS, Lean's and the {tech}[workspace]'s {tech}[library directories] are added.
* row
  * `LD_LIBRARY_PATH`
  * On platforms other than Windows and macOS, Lean's and the {tech}[workspace]'s {tech}[library directories] are added.
:::

Lake itself can be configured with the following environment variables:
:::table
* row
  * {envVar def:=true}`ELAN_HOME`
  * The location of the {ref "elan"}[Elan] installation, which is used for {ref "automatic-toolchain-updates"}[automatic toolchain updates].
    The {envVar def:=true}`ELAN` variable, pointing at the `elan` binary, is used as a fallback, followed by an occurrence of `elan` found on the {envVar}`PATH`.
* row
  * {envVar def:=true}`LAKE_HOME`
  * The location of the Lake installation.
    This environment variable is only consulted when Lake is unable to determine its installation path from the location of the `lake` executable that's currently running.
* row
  * {envVar def:=true}`LEAN_SYSROOT`
  * The location of the Lean installation, used to find the Lean compiler, the standard library, and other bundled tools.
    Lake first checks whether its binary is colocated with a Lean install, using that installation if so.
    If not, or if {envVar def:=true}`LAKE_OVERRIDE_LEAN` is true, then Lake consults {envVar}`LEAN_SYSROOT`.
    If this is not set, Lake consults the {envVar def:=true}`LEAN` environment variable to find the Lean compiler, and attempts to find the Lean installation relative to the compiler.
    If {envVar}`LEAN` is set but empty, Lake considers Lean to be disabled.
    If {envVar}`LEAN_SYSROOT` and {envVar}`LEAN` are unset, the first occurrence of `lean` on the {envVar}`PATH` is used to find the installation.
* row
  * {envVar def:=true}`LEAN_CC` and {envVar def:=true}`LEAN_AR`
  * If {envVar}`LEAN_CC` and/or {envVar}`LEAN_AR` is set, its value is used as the C compiler or `ar` command when building libraries.
    If not, Lake will fall back to the bundled tool in the Lean installation.
    If the bundled tool is not found, the value of {envVar def:=true}`CC` or {envVar def:=true}`AR`, followed by a `cc` or `ar` on the {envVar}`PATH`, are used.


* row
  * {envVar def:=true}`LAKE_NO_CACHE`
  * If true, Lake does not use cached builds. {TODO}[xref]
    This environment variable can be overridden using the `--try-cache` command-line option.

:::

Lake considers an environment variable to be true when its value is `y`, `yes`, `t`, `true`, `on`, or `1`, compared case-insensitively.
It considers a variable to be false when its value is `n`, `no`, `f`, `false`, `off`, or `0`, compared case-insensitively.
If the variable is unset, or its value is neither true nor false, a default value is used.

```lean (show := false)
-- Test the claim above
/--
info: def Lake.envToBool? : String → Option Bool :=
fun o =>
  if ["y", "yes", "t", "true", "on", "1"].contains o.toLower = true then some true
  else if ["n", "no", "f", "false", "off", "0"].contains o.toLower = true then some false else none
-/
#guard_msgs in
#print Lake.envToBool?
```

### Options

Lake's command-line interface provides a number of global options as well as subcommands that perform important tasks.
Single-character flags cannot be combined; `-HU` is not equivalent to `-H -U`.

: `--version`

  Lake outputs its version and exits without doing anything else.

: `--help` or `-h`

  Lake outputs its version and exits without doing anything else.

: `--dir DIR` or `-d=DIR`

  Use the provided directory as location of the package instead of the current working directory.
  This is not always equivalent to changing to the directory first, because the version of `lake` indicated by the current directory's {tech}[toolchain file] will be used, rather than that of `DIR`.

: `--file FILE` or `-f=FILE`

  Use the specified {tech}[package configuration file] instead of the default.

: `--old`

  Only rebuild modified modules, ignoring transitive dependencies.{TODO}[Clarify]

: `--rehash` or `-H`

  Ignored cached file hashes, recomputing them. {TODO}[Q for Mac: does this use modification times by default?]

: `--update` or `-U`

  Update dependencies after the {tech}[package configuration] is loaded but prior to performing other tasks, such as a build.
  This is equivalent to running `lake update` before the selected command.{TODO}[is it?]

: `--packages=FILE`

  Use the contents of `FILE` to specify the versions of each dependency instead of the manifest.
  `FILE` should be a valid manifest.

:  `--reconfigure` or `-R`

  Normally, the {tech}[package configuration] file is {tech}[elaborated] when a package is first configured, with the result cached to a {tech}[`.olean` file] that is used for future invocations until the package configuration
  Providing this flag causes the configuration file to be re-elaborated.

: `--keep-toolchain`

  By default, Lake attempts to update the local {tech}[workspace]'s {tech}[toolchain file].
  Providing this flag disables {ref "automatic-toolchain-updates"}[automatic toolchain updates].

: `--no-build`

  Lake exits immediately if a build target is not up-to-date, returning a non-zero exit code.

: `--no-cache`

  Instead of using available cloud build caches, build all packages locally.
  Build caches are not downloaded.

: `--try-cache`

  attempt to download build caches for supported packages

### Controlling Output

These options provide allow control over the {tech}[log] that is produced while building.
In addition to showing or hiding messages, a build can be made to fail when warnings or even information is emitted; this can be used to enforce a style guide that disallows output during builds.

: `--quiet`, `-q`

  Hides informational logs and the progress indicator.

: `--verbose`, `-v`

  Shows trace logs (typically command invocations) and built {tech}[targets].

:  `--ansi`, `--no-ansi`

  Enables or disables the use of [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) that add colors and animations to Lake's output.

:  `--log-level=LV`

  Sets the minimum level of {tech}[logs] to be shown when builds succeed.
  `LV` may be `trace`, `info`, `warning`, or `error`, compared case-insensitively.
  When a build fails, all levels are shown.
  The default log level is `info`.

:  `--fail-level=LV`

  Sets the threshold at which a message in the {tech}[log] causes a build to be considered a failure.
  If a message is emitted to the log with a level that is greater than or equal to the threshold, the build fails.
  `LV` may be `trace`, `info`, `warning`, or `error`, compared case-insensitively; it is `error` by default.


: `--iofail`

  Causes builds to fail if any I/O or other info is logged.
  This is equivalent to `--fail-level=info`

: `--wfail`

  Causes builds to fail if any warnings are logged.
  This is equivalent to `--fail-level=warning`.

### Automatic Toolchain Updates
%%%
tag := "automatic-toolchain-updates"
%%%

:::TODO

To determine "newest compatible" toolchain, Lake parses the toolchain listed in the packages' lean-toolchain files into four categories: release , nightly, PR, and other. For newness, release toolchains are compared by semantic version (e.g., "v4.4.0" < "v4.8.0" and "v4.6.0-rc1" < "v4.6.0") and nightlies are compared by date (e.g., "nightly-2024-01-10" < "nightly-2014-10-01"). All other toolchain types and mixtures are incompatible. If there is not a single newest toolchain, Lake will print a warning and continue updating without changing the toolchain.

If Lake does find a new toolchain, Lake updates the workspace's lean-toolchain file accordingly and restarts the update process on the new Lake. If Elan is detected, it will spawn the new Lake process via elan run with the same arguments Lake was initially run with. If Elan is missing, it will prompt the user to restart Lake manually and exit with a special error code (4).

The Elan executable used by Lake is now configurable by the ELAN environment variable.

Also `LEAN` env var for Lean.

:::

### Creating Packages

```lakeHelp "new"
Create a Lean package in a new directory

USAGE:
  lake new <name> [<template>][.<language>]

The initial configuration and starter files are based on the template:

  std                   library and executable; default
  exe                   executable only
  lib                   library only
  math                  library only with a mathlib dependency

Templates can be suffixed with `.lean` or `.toml` to produce a Lean or TOML
version of the configuration file, respectively. The default is Lean.
```

:::lake new "name [template][\".\"language]"

Running {lake}`new` creates an initial Lean package in a new directory.
This command is equivalent to creating a directory named {lakeMeta}`name` and then running {lake}`init`

:::

:::lake init "name [template][\".\"language]"

Running {lake}`init` creates an initial Lean package in the current directory.
The package's contents are based on a template, with the names of the {tech}[package], its {tech}[targets], and their {tech}[module roots] derived from the name of the current directory.

The {lakeMeta}`template` may be:

: `std` (default)

  Creates a package that contains a library and an executable.

: `exe`

  Creates a package that contains only an executable.

: `lib`

  Creates a package that contains only a library.

: `math`

  Creates a package that contains a library that depends on [Mathlib](https://github.com/leanprover-community/mathlib4).

The {lakeMeta}`language` selects the file format used for the {tech}[package configuration file] and may be `lean` (the default) or `toml`.
:::

:::TODO
Example of `lake init` or `lake new`
:::

### Building and Running

```lakeHelp "build"
Build targets

USAGE:
  lake build [<targets>...]

A target is specified with a string of the form:

  [[@]<package>/][<target>|[+]<module>][:<facet>]

The optional `@` and `+` markers can be used to disambiguate packages
and modules from other kinds of targets (i.e., executables and libraries).

LIBRARY FACETS:         build the library's ...
  leanArts (default)    Lean artifacts (*.olean, *.ilean, *.c files)
  static                static artifact (*.a file)
  shared                shared artifact (*.so, *.dll, or *.dylib file)

MODULE FACETS:          build the module's ...
  deps                  dependencies (e.g., imports, shared libraries, etc.)
  leanArts (default)    Lean artifacts (*.olean, *.ilean, *.c files)
  olean                 OLean (binary blob of Lean data for importers)
  ilean                 ILean (binary blob of metadata for the Lean LSP server)
  c                     compiled C file
  bc                    compiled LLVM bitcode file
  c.o                   compiled object file (of its C file)
  bc.o                  compiled object file (of its LLVM bitcode file)
  o                     compiled object file (of its configured backend)
  dynlib                shared library (e.g., for `--load-dynlib`)

TARGET EXAMPLES:        build the ...
  a                     default facet of target `a`
  @a                    default target(s) of package `a`
  +A                    Lean artifacts of module `A`
  a/b                   default facet of target `b` of package `a`
  a/+A:c                C file of module `A` of package `a`
  :foo                  facet `foo` of the root package

A bare `lake build` command will build the default facet of the root package.
Package dependencies are not updated during a build.
```

:::lake build "[targets...]"

Builds the specified targets.

Each of the {lakeMeta}`targets` is specified by a string of the form:

{lakeArgs}`[["@"]package"/"][target|["+"]module][":"facet]`

The optional {keyword}`@` and {keyword}`+` markers can be used to disambiguate packages and modules from executables and libraries.
If not provided, {lakeMeta}`package` defaults to the {tech}[workspace]'s {tech}[root package].

The available {tech}[facets] depend on whether a package, target, or module is to be built.
They are listed in {ref "lake-facets"}[the section on facets].

:::

:::TODO

Rules for picking a target (current package first, then dependencies in some order?)

Talk to Mac about alternative terminology for picking a fact of something - "target" seems overloaded here

:::

::::example "Example target specifications"

:::table
* ignored
  - `a`
  - default facet of target `a`
* ignored
  - `@a`
  - default target(s) of package `a`
* ignored
  - `+A`
  -  Lean artifacts of module `A`
* ignored
  - `a/b`
  - default facet of target `b` of package `a`
* ignored
  - `a/+A:c`
  - C file of module `A` of package `a`
* ignored
  - `:foo`
  - facet `foo` of the root package
:::
::::

```lakeHelp "exe"
Build an executable target and run it in Lake's environment

USAGE:
  lake exe <exe-target> [<args>...]

ALIAS: lake exec

Looks for the executable target in the workspace (see `lake help build` to
learn how to specify targets), builds it if it is out of date, and then runs
it with the given `args` in Lake's environment (see `lake help env` for how
the environment is set up).
```

:::lake exe "«exe-target» [args...]" (alias := exec)

Looks for the executable target {lakeMeta}`exe-target` in the workspace, builds it if it is out of date, and then runs
it with the given {lakeMeta}`args` in Lake's environment.

See {lake}`build` for the syntax of target specifications and {lake}`env` for a description of how the environment is set up.

:::

```lakeHelp "clean"
Remove build outputs

USAGE:
  lake clean [<package>...]

If no package is specified, deletes the build directories of every package in
the workspace. Otherwise, just deletes those of the specified packages.
```

:::lake clean "[packages...]"

If no package is specified, deletes the {tech}[build directories] of every package in the workspace.
Otherwise, it just deletes those of the specified {lakeMeta}`packages`.

:::

```lakeHelp "env"
Execute a command in Lake's environment

USAGE:
  lake env [<cmd>] [<args>...]

Spawns a new process executing `cmd` with the given `args` and with
the environment set based on the detected Lean/Lake installations and
the workspace configuration (if it exists).

Specifically, this command sets the following environment variables:

  LAKE                  set to the detected Lake executable
  LAKE_HOME             set to the detected Lake home
  LEAN_SYSROOT          set to the detected Lean toolchain directory
  LEAN_AR               set to the detected Lean `ar` binary
  LEAN_CC               set to the detected `cc` (if not using the bundled one)
  LEAN_PATH             adds Lake's and the workspace's Lean library dirs
  LEAN_SRC_PATH         adds Lake's and the workspace's source dirs
  PATH                  adds Lean's, Lake's, and the workspace's binary dirs
  PATH                  adds Lean's and the workspace's library dirs (Windows)
  DYLD_LIBRARY_PATH     adds Lean's and the workspace's library dirs (MacOS)
  LD_LIBRARY_PATH       adds Lean's and the workspace's library dirs (other)

A bare `lake env` will print out the variables set and their values,
using the form NAME=VALUE like the POSIX `env` command.
```

::::lake env "[cmd [args...]]"

When {lakeMeta}`cmd` is provided, it is executed in {ref "lake-environment"}[the Lake environment] with arguments {lakeMeta}`args`.

If {lakeMeta}`cmd` is not provided, Lake prints the environment in which it runs tools.
This environment is system-specific.
::::

```lakeHelp "lean"
Elaborate a Lean file in the context of the Lake workspace

USAGE:
  lake lean <file> [-- <args>...]

Build the imports of the given file and then runs `lean` on it using
the workspace's root package's additional Lean arguments and the given args
(in that order). The `lean` process is executed in Lake's environment like
`lake env lean` (see `lake help env` for how the environment is set up).
```

:::lake lean "file [\"--\" args...]"

Builds the imports of the given {lakeMeta}`file` and then runs `lean` on it using the {tech}[workspace]'s {tech}[root package]'s additional Lean arguments and the given {lakeMeta}`args`, in that order.
The `lean` process is executed in {ref "lake-environment"}[Lake's environment].
:::


### Development Tools

#### Tests and Linters

```lakeHelp test
Test the workspace's root package using its configured test driver

USAGE:
  lake test [-- <args>...]

A test driver can be configured by either setting the 'testDriver'
package configuration option or by tagging a script, executable, or library
`@[test_driver]`. A definition in a dependency can be used as a test driver
by using the `<pkg>/<name>` syntax for the 'testDriver' configuration option.

A script test driver will be run with the  package configuration's
`testDriverArgs` plus the CLI `args`. An executable test driver will be
built and then run like a script. A library test driver will just be built.

```

:::lake test " [\"--\" args...]"
Test the workspace's root package using its configured {tech}[test driver].

A script test driver will be run with the package configuration's `testDriverArgs` plus the CLI {lakeMeta}`args`.
An executable test driver will be built and then run like a script.
A library test driver will just be built.
:::

```lakeHelp lint
Lint the workspace's root package using its configured lint driver

USAGE:
  lake lint [-- <args>...]

A lint driver can be configured by either setting the `lintDriver` package
configuration option by tagging a script or executable `@[lint_driver]`.
A definition in dependency can be used as a test driver by using the
`<pkg>/<name>` syntax for the 'testDriver' configuration option.

A script lint driver will be run with the  package configuration's
`lintDriverArgs` plus the CLI `args`. An executable lint driver will be
built and then run like a script.

```

:::lake lint " [\"--\" args...]"

Lint the workspace's root package using its configured lint driver

A script lint driver will be run with the  package configuration's
`lintDriverArgs` plus the CLI `args`. An executable lint driver will be
built and then run like a script.
:::

```lakeHelp "check-test"
Check if there is a properly configured test driver

USAGE:
  lake check-test

Exits with code 0 if the workspace's root package has a properly
configured lint driver. Errors (with code 1) otherwise.

Does NOT verify that the configured test driver actually exists in the
package or its dependencies. It merely verifies that one is specified.

```

:::lake «check-test»

Check if there is a properly configured test driver

Exits with code 0 if the workspace's root package has a properly
configured lint driver. Errors (with code 1) otherwise.

Does NOT verify that the configured test driver actually exists in the
package or its dependencies. It merely verifies that one is specified.

:::

```lakeHelp "check-lint"
Check if there is a properly configured lint driver

USAGE:
  lake check-lint

Exits with code 0 if the workspace's root package has a properly
configured lint driver. Errors (with code 1) otherwise.

Does NOT verify that the configured lint driver actually exists in the
package or its dependencies. It merely verifies that one is specified.

```

:::lake «check-lint»
Check if there is a properly configured lint driver

Exits with code 0 if the workspace's root package has a properly
configured lint driver. Errors (with code 1) otherwise.

Does NOT verify that the configured lint driver actually exists in the
package or its dependencies. It merely verifies that one is specified.
:::


#### Scripts

```lakeHelp script
Manage Lake scripts

USAGE:
  lake script <COMMAND>

COMMANDS:
  list                  list available scripts
  run <script>          run a script
  doc <script>          print the docstring of a given script

See `lake help <command>` for more information on a specific command.
```
:::lake script list
:::

:::lake script run "script"
:::

:::lake script run "script"
:::


```lakeHelp scripts
List available scripts

USAGE:
  lake script list

ALIAS: lake scripts

This command prints the list of all available scripts in the workspace.
```

:::lake scripts
:::

```lakeHelp run
Run a script

USAGE:
  lake script run [[<package>/]<script>] [<args>...]

ALIAS: lake run

This command runs the `script` of the workspace (or the specific `package`),
passing `args` to it.

A bare `lake run` command will run the default script(s) of the root package
(with no arguments).
```

:::lake script run
:::

:::lake run
:::


#### Language Server

```lakeHelp serve
Start the Lean language server

USAGE:
  lake serve [-- <args>...]

Run the language server of the Lean installation (i.e., via `lean --server`)
with the package configuration's `moreServerArgs` field and `args`.

```

:::lake serve "[\"--\" args...]"
Runs the Lean language server in the workspace's root project with the {tech}[package configuration]'s `moreServerArgs` field and {lakeMeta}`args`.

This command is typically invoked by editors or other tooling, rather than manually.
:::

### Dependency Management

```lakeHelp update
Update dependencies and save them to the manifest

USAGE:
  lake update [<package>...]

ALIAS: lake upgrade

Updates the Lake package manifest (i.e., `lake-manifest.json`),
downloading and upgrading packages as needed. For each new (transitive) git
dependency, the appropriate commit is cloned into a subdirectory of
`packagesDir`. No copy is made of local dependencies.

If a set of packages are specified, said dependencies are upgraded to
the latest version compatible with the package's configuration (or removed if
removed from the configuration). If there are dependencies on multiple versions
of the same package, the version materialized is undefined.

A bare `lake update` will upgrade all dependencies.
```

:::lake update
:::



### Configuration Files


```lakeHelp "translate-config"
Translate a Lake configuration file into a different language

USAGE:
  lake translate-config <lang> [<out-file>]

Translates the loaded package's configuration into another of
Lake's supported configuration languages (i.e., either `lean` or `toml`).
The produced file is written to `out-file` or, if not provided, the path of
the configuration file with the new language's extension. If the output file
already exists, Lake will error.

Translation is lossy. It does not preserve comments or formatting and
non-declarative configuration will be discarded.
```

:::lake «translate-config» "lang [«out-file»]"
:::


## Configuration File Format

### Declarative TOML Format

### Lean Format

## API Reference
%%%
tag := "lake-api"
%%%

{docstring Lake.FetchM}

{docstring Lake.FetchM.run}

{docstring Lake.RecBuildM}

{docstring Lake.RecBuildM.runJobM}

{docstring Lake.RecBuildM.run}

{docstring Lake.RecBuildM.run'}

{docstring Lake.ScriptM}

{docstring Lake.buildCycleError}

{docstring Lake.addLeanTrace}

{docstring Lake.addPlatformTrace}

{docstring Lake.addPureTrace}

{docstring Lake.addTrace}

{docstring Lake.binder}

{docstring Lake.binder.formatter}

{docstring Lake.binder.parenthesizer}

{docstring Lake.buildFileAfterDep}

{docstring Lake.buildFileUnlessUpToDate'}

{docstring Lake.buildImportsAndDeps}

{docstring Lake.buildLeanExe}

{docstring Lake.buildLeanO}

{docstring Lake.buildLeanSharedLib}

{docstring Lake.buildLeanSharedLibOfStatic}

{docstring Lake.buildO}

{docstring Lake.buildSpecs}

{docstring Lake.buildStaticLib}

{docstring Lake.buildUnlessUpToDate}

{docstring Lake.buildUnlessUpToDate?}

{docstring Lake.buildUnlessUpToDate?.go}

{docstring Lake.busyAcquireLockFile}

{docstring Lake.busyAcquireLockFile.busyLoop}

{docstring Lake.cacheFileHash}

{docstring Lake.captureProc}

{docstring Lake.captureProc?}

{docstring Lake.checkHashUpToDate}

{docstring Lake.clearFileHash}

{docstring Lake.collectImportsAux}

{docstring Lake.compileExe}

{docstring Lake.compileLeanModule}

{docstring Lake.compileO}

{docstring Lake.compileSharedLib}

{docstring Lake.compileStaticLib}

{docstring Lake.computeArrayHash}

{docstring Lake.computeArrayTrace}

{docstring Lake.computeBinFileHash}

{docstring Lake.computeDynlibOfShared}

{docstring Lake.computeFileHash}

{docstring Lake.computeHash}

{docstring Lake.computeListTrace}

{docstring Lake.computePrecompileImportsAux}

{docstring Lake.computeTextFileHash}

{docstring Lake.computeTrace}

{docstring Lake.createParentDirs}

{docstring Lake.customDataDecl}

{docstring Lake.declareOpaqueType}

{docstring Lake.defaultBinDir}

{docstring Lake.defaultBuildArchive}

{docstring Lake.defaultBuildDir}

{docstring Lake.defaultConfigFile}

{docstring Lake.defaultIrDir}

{docstring Lake.defaultLakeDir}

{docstring Lake.defaultLeanConfigFile}

{docstring Lake.defaultLeanLibDir}

{docstring Lake.defaultManifestFile}

{docstring Lake.defaultNativeLibDir}

{docstring Lake.defaultPackagesDir}

{docstring Lake.defaultScriptAttr}

{docstring Lake.defaultTargetAttr}

{docstring Lake.defaultTomlConfigFile}

{docstring Lake.defaultVersionTags}

{docstring Lake.dirExt}

{docstring Lake.doElemTry_Else_}

{docstring Lake.download}

{docstring Lake.drbmapOf}

{docstring Lake.dropLogFrom}

{docstring Lake.elabVerLit}

{docstring Lake.elabVerLit.unsafe_1}

{docstring Lake.elabVerLit.unsafe_impl_1}

{docstring Lake.ensureJob}

{docstring Lake.env}

{docstring Lake.envToBool?}

{docstring Lake.errorWithLog}

{docstring Lake.exe}

{docstring Lake.exitIfErrorCode}

{docstring Lake.expandBinderIdent}

{docstring Lake.expandBinderModifier}

{docstring Lake.expandBinderType}

{docstring Lake.expandBinders}

{docstring Lake.expandOptIdent}

{docstring Lake.expandOptType}

{docstring Lake.externLibAttr}

{docstring Lake.extractLog}

{docstring Lake.familyDef}

{docstring Lake.fetchFileHash}

{docstring Lake.fetchFileTrace}

{docstring Lake.fetchOrCreate}

{docstring Lake.findElanInstall?}

{docstring Lake.findExternLib?}

{docstring Lake.findInstall?}

{docstring Lake.findLakeInstall?}

{docstring Lake.findLakeLeanJointHome?}

{docstring Lake.findLeanCmdInstall?}

{docstring Lake.findLeanExe?}

{docstring Lake.findLeanInstall?}

{docstring Lake.findLeanLib?}

{docstring Lake.findLeanSysroot?}

{docstring Lake.findModule?}

{docstring Lake.findPackage?}

{docstring Lake.flush}

{docstring Lake.foldlUtf8}

{docstring Lake.foldlUtf8M}

{docstring Lake.getAugmentedEnv}

{docstring Lake.getAugmentedLeanPath}

{docstring Lake.getAugmentedLeanSrcPath}

{docstring Lake.getAugmentedSharedLibPath}

{docstring Lake.getBinderIds}

{docstring Lake.getBuildConfig}

{docstring Lake.getBuildContext}

{docstring Lake.getElan?}

{docstring Lake.getElanHome?}

{docstring Lake.getElanInstall?}

{docstring Lake.getElanToolchain}

{docstring Lake.getEnvLeanPath}

{docstring Lake.getEnvLeanSrcPath}

{docstring Lake.getEnvSharedLibPath}

{docstring Lake.getFileMTime}

{docstring Lake.getIsOldMode}

{docstring Lake.getIsQuiet}

{docstring Lake.getIsVerbose}

{docstring Lake.getLake}

{docstring Lake.getLakeEnv}

{docstring Lake.getLakeHome}

{docstring Lake.getLakeInstall}

{docstring Lake.getLakeInstall?}

{docstring Lake.getLakeLibDir}

{docstring Lake.getLakeSrcDir}

{docstring Lake.getLean}

{docstring Lake.getLeanAr}

{docstring Lake.getLeanCc}

{docstring Lake.getLeanCc?}

{docstring Lake.getLeanIncludeDir}

{docstring Lake.getLeanInstall}

{docstring Lake.getLeanLibDir}

{docstring Lake.getLeanPath}

{docstring Lake.getLeanSharedLib}

{docstring Lake.getLeanSrcDir}

{docstring Lake.getLeanSrcPath}

{docstring Lake.getLeanSysroot}

{docstring Lake.getLeanSystemLibDir}

{docstring Lake.getLeanTrace}

{docstring Lake.getLeanc}

{docstring Lake.getLog}

{docstring Lake.getLogPos}

{docstring Lake.getNoBuild}

{docstring Lake.getNoCache}

{docstring Lake.getPkgUrlMap}

{docstring Lake.getRootPackage}

{docstring Lake.getSearchPath}

{docstring Lake.getSharedLibPath}

{docstring Lake.getTrace}

{docstring Lake.getTrustHash}

{docstring Lake.getTryCache}

{docstring Lake.getUrl}

{docstring Lake.getVerbosity}

{docstring Lake.guardCycle}

{docstring Lake.hexEncodeByte}

{docstring Lake.hydrateOpaqueType}

{docstring Lake.initLibraryFacetConfigs}

{docstring Lake.initModuleFacetConfigs}

{docstring Lake.initPackageFacetConfigs}

{docstring Lake.initSharedLib}

{docstring Lake.inputBinFile}

{docstring Lake.inputFile}

{docstring Lake.inputTextFile}

{docstring Lake.instToJsonFilePath_lake}

{docstring Lake.isUriUnreservedMark}

{docstring Lake.isVerLike}

{docstring Lake.lakeBuildHome?}

{docstring Lake.lakeExe}

{docstring Lake.leanArExe}

{docstring Lake.leanCcExe}

{docstring Lake.leanExe}

{docstring Lake.leanExeAttr}

{docstring Lake.leanLibAttr}

{docstring Lake.leanSharedLib}

{docstring Lake.leanSharedLibDir}

{docstring Lake.leancExe}

{docstring Lake.libraryDataDecl}

{docstring Lake.libraryFacetAttr}

{docstring Lake.lintDriverAttr}

{docstring Lake.logError}

{docstring Lake.logInfo}

{docstring Lake.logOutput}

{docstring Lake.logSerialMessage}

{docstring Lake.logToStream}

{docstring Lake.logVerbose}

{docstring Lake.logWarning}

{docstring Lake.lpad}

{docstring Lake.matchBinder}

{docstring Lake.maybeRegisterJob}

{docstring Lake.mixTraceArray}

{docstring Lake.mixTraceList}

{docstring Lake.mkBuildContext}

{docstring Lake.mkBuildSpec}

{docstring Lake.mkCmdLog}

{docstring Lake.mkConfigBuildSpec}

{docstring Lake.mkDRBMap}

{docstring Lake.mkExceptionMessage}

{docstring Lake.mkFacetConfig}

{docstring Lake.mkFacetJobConfig}

{docstring Lake.mkHoleFrom}

{docstring Lake.mkLakeContext}

{docstring Lake.mkMessageLogString}

{docstring Lake.mkMessageNoPos}

{docstring Lake.mkMessageString}

{docstring Lake.mkMessageStringCore}

{docstring Lake.mkOrdNameMap}

{docstring Lake.mkParserErrorMessage}

{docstring Lake.mkRBArray}

{docstring Lake.mkRelPathString}

{docstring Lake.mkTargetFacetBuild}

{docstring Lake.mkTargetJobConfig}

{docstring Lake.moduleDataDecl}

{docstring Lake.moduleFacetAttr}

{docstring Lake.monitorJobs}

{docstring Lake.nameToSharedLib}

{docstring Lake.nameToStaticLib}

{docstring Lake.noBuildCode}

{docstring Lake.ofFamily}

{docstring Lake.optsExt}

{docstring Lake.packageAttr}

{docstring Lake.packageDataDecl}

{docstring Lake.packageDepAttr}

{docstring Lake.packageFacetAttr}

{docstring Lake.parseExeTargetSpec}

{docstring Lake.parsePackageSpec}

{docstring Lake.parseTargetSpec}

{docstring Lake.parseTargetSpecs}

{docstring Lake.platformTrace}

{docstring Lake.postUpdateAttr}

{docstring Lake.print!}

{docstring Lake.proc}

{docstring Lake.pureHash}

{docstring Lake.pushLogEntry}

{docstring Lake.rawProc}

{docstring Lake.readTraceFile?}

{docstring Lake.recBuildExternDynlibs}

{docstring Lake.recBuildWithIndex}

{docstring Lake.recFetch}

{docstring Lake.recFetchAcyclic}

{docstring Lake.recFetchMemoize}

{docstring Lake.registerJob}

{docstring Lake.registerOrderedTagAttribute}

{docstring Lake.resolveCustomTarget}

{docstring Lake.resolveDefaultPackageTarget}

{docstring Lake.resolveExeTarget}

{docstring Lake.resolveExternLibTarget}

{docstring Lake.resolveLibTarget}

{docstring Lake.resolveLibTarget.resolveFacet}

{docstring Lake.resolveModuleTarget}

{docstring Lake.resolvePackageTarget}

{docstring Lake.resolveTargetBaseSpec}

{docstring Lake.resolveTargetInPackage}

{docstring Lake.resolveTargetInWorkspace}

{docstring Lake.rpad}

{docstring Lake.runBuild}

{docstring Lake.scriptAttr}

{docstring Lake.setTrace}

{docstring Lake.sharedLibExt}

{docstring Lake.sharedLibPathEnvVar}

{docstring Lake.stringToLegalOrSimpleName}

{docstring Lake.takeLog}

{docstring Lake.takeLogFrom}

{docstring Lake.takeTrace}

{docstring Lake.tar}

{docstring Lake.targetAttr}

{docstring Lake.targetDataDecl}

{docstring Lake.termTry_Else_}

{docstring Lake.testDriverAttr}

{docstring Lake.testProc}

{docstring Lake.toFamily}

{docstring Lake.toUpperCamelCase}

{docstring Lake.toUpperCamelCaseString}

{docstring Lake.toolchainFileName}

{docstring Lake.uiVersionString}

{docstring Lake.untar}

{docstring Lake.updateAction}

{docstring Lake.uriEncode}

{docstring Lake.uriEncodeChar}

{docstring Lake.uriEscapeByte}

{docstring Lake.uriEscapeChar}

{docstring Lake.verLit}

{docstring Lake.version.isRelease}

{docstring Lake.version.major}

{docstring Lake.version.minor}

{docstring Lake.version.patch}

{docstring Lake.version.specialDesc}

{docstring Lake.versionString}

{docstring Lake.versionStringCore}

{docstring Lake.versionTagPresets}

{docstring Lake.withExtractLog}

{docstring Lake.withLockFile}

{docstring Lake.withLogErrorPos}

{docstring Lake.withLoggedIO}

{docstring Lake.withRegisterJob}

{docstring Lake.writeTraceFile}

{docstring Lake.zpad}


# Reservoir
%%%
tag := "reservoir"
%%%


::: planned 76
 * Concepts
 * Package and toolchain versions
 * Tags and builds
:::
