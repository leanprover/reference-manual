/-
Copyright (c) 2025 Lean FRO LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: David Thrane Christiansen
-/

import VersoManual

import Lean.Parser.Command
import Lake

import Manual.Meta
import Manual.BuildTools.Lake.CLI
import Manual.BuildTools.Lake.Config

open Manual
open Verso.Genre
open Verso.Genre.Manual


open Lean.Elab.Tactic.GuardMsgs.WhitespaceMode

#doc (Manual) "Lake" =>
%%%
tag := "lake"
%%%

::: planned 75
 * Port and organize the information in the Lake README
 * Describe the underlying Lake-specific concepts of traces, artifacts, workspaces, and facets
:::


Lake is the standard Lean build tool.
It is responsible for:
 * Configuring builds and building Lean code
 * Fetching and building external dependencies
 * Integrating with Reservoir, the Lean package server
 * Running tests, linters, and other development workflows

Lake is extensible.
It provides a rich API that can be used to {TODO}[examples]

This section describes Lake's {ref "lake-cli"}[command-line interface], {ref "lake-config"}[configuration files], and {ref "lake-api"}[internal API].
All three share a set of concepts and terminology, which is described in {ref "lake-vocab"}[a dedicated subsection].

# Concepts and Terminology
%%%
tag := "lake-vocab"
%%%

A {deftech}_package_ is the basic unit of Lean code distribution.
Packages contain {tech}[targets], which are the basic unit of code to be built.
They consist of a directory that contains a {tech}[package configuration] file together with source code.
Packages may {deftech}_require_ other packages, in which case those packages' code (more specifically, their {tech}[targets]) are made available.
The {deftech}_direct dependencies_ of a package are those that it requires, and the {deftech}_transitive dependencies_ are the direct dependencies of a package together with their transitive dependencies.

A {deftech}_workspace_ is a directory on disk that contains a package's source code and the source code of its {tech}[transitive dependencies].
The workspace also contains any built {tech}[artifacts] for the package, enabling incremental builds.{TODO}[xref and def]
Dependencies and artifacts do not need to be present for a directory to be considered a workspace; commands such as `lake update` and `lake build` produce them.
With the exception of commands such as `lake init`, Lake is typically used in a workspace.


A {deftech}_package configuration_ file specifies the dependencies, settings, and targets of a package.
Packages can specify configuration options that apply to all their contained targets.
They can be written in two formats:
 * The TOML format (`lakefile.toml`) is used for fully declarative package configurations.
 * The Lean format (`lakefile.lean`) additionally supports the use of Lean code to configure the package in ways not supported by the declarative options.

A {deftech}_manifest_ tracks the specific versions of other packages that are used in a package.
Together, a manifest and a {tech}[package configuration] file specify a unique set of transitive dependencies for the package.

A {deftech}_target_ represents a build product that can be requested by a user:

 * {deftech}_Libraries_ are collections of Lean {tech}[module]s, organized hierarchically under one or more {tech}_module roots_.
 * {deftech}_Executables_ consist of a _single_ module that defines `main`
 * {deftech}_External libraries_ {TODO}[add as a TODO due to upcoming refactor]
 * {deftech}_Static libraries_ {TODO}[add as a TODO due to upcoming refactor]
 * {deftech}_Custom targets_ contain arbitrary code to run a build, written using {name Lake.FetchM}`FetchM` in {TODO}[xref]Lake's API.

An {deftech}_artifact_ is the persistent result of a build, such as object code, an executable binary, or an {tech}[`.olean` file].
Artifacts can result from builds at three levels of granularity: modules, targets, and packages.
There is a one-to-many relationship between each of these inputs and the resulting artifacts; for example, a building a module produces an `.olean` file and an `.ilean` file, along with a C source file that contains the code generated by Lean's compiler and an object file generated by the C compiler.




The {deftech}_log_ contains information produced during a build.
Logs are saved so they can be replayed during incremental builds.
Messages in the log have four levels, ordered by severity:

 1. Trace messages contain internal build details that are often specific to the machine on which the build is running, including the specific invocations of Lean and other tools that are passed to the shell.
 2. Informational messages contain general informational output that is not expected to indicate a problem with the code, such as the results of a {keywordOf Lean.Parser.Command.eval}`#eval` command.
 3. Warnings indicate potential problems, such as unused variable bindings.
 4. Errors explain why parsing and elaboration could not complete.

## Facets
%%%
tag := "lake-facets"
%%%

A {deftech}_facet_ describes the production of an artifact from a module, target, or package.
Each kind of target has a default facet (e.g. producing an executable binary from an executable target); other facets may be specified explicitly in the {tech}[package configuration] or via Lake's {ref "lake-cli"}[command-line interface].
Lake's API may be used to write custom facets. {TODO}[xref]



```lakeHelp "build"
Build targets

USAGE:
  lake build [<targets>...]

A target is specified with a string of the form:

  [[@]<package>/][<target>|[+]<module>][:<facet>]

The optional `@` and `+` markers can be used to disambiguate packages
and modules from other kinds of targets (i.e., executables and libraries).

LIBRARY FACETS:         build the library's ...
  leanArts (default)    Lean artifacts (*.olean, *.ilean, *.c files)
  static                static artifact (*.a file)
  shared                shared artifact (*.so, *.dll, or *.dylib file)

MODULE FACETS:          build the module's ...
  deps                  dependencies (e.g., imports, shared libraries, etc.)
  leanArts (default)    Lean artifacts (*.olean, *.ilean, *.c files)
  olean                 OLean (binary blob of Lean data for importers)
  ilean                 ILean (binary blob of metadata for the Lean LSP server)
  c                     compiled C file
  bc                    compiled LLVM bitcode file
  c.o                   compiled object file (of its C file)
  bc.o                  compiled object file (of its LLVM bitcode file)
  o                     compiled object file (of its configured backend)
  dynlib                shared library (e.g., for `--load-dynlib`)

TARGET EXAMPLES:        build the ...
  a                     default facet of target `a`
  @a                    default target(s) of package `a`
  +A                    Lean artifacts of module `A`
  a/b                   default facet of target `b` of package `a`
  a/+A:c                C file of module `A` of package `a`
  :foo                  facet `foo` of the root package

A bare `lake build` command will build the default facet of the root package.
Package dependencies are not updated during a build.
```

The facets available for packages are:

::: TODO

Confirm these with Mac

:::

 * `optCache` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `cache` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `optBarrel` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `barrel` A package's optional cached build archive (e.g., from Reservoir or GitHub). Will NOT cause the whole build to fail if the archive cannot be fetched.

 * `optRelease` A package's _optional_ build archive from a GitHub release. Will *not* cause the whole build to fail if the release cannot be fetched.

 * `release` A package's _optional_ build archive from a GitHub release. Will cause the whole build to fail if the archive cannot be fetched.

The facets available for targets (including libraries and executables) are:

 * `leanArts` contains the artifacts that the Lean compiler produces for the library ({tech key:="olean files"}`*.olean`, `*.ilean`, and `*.c` files).
 * `static` contains the static library produced by the C compiler from the `leanArts` (that is, a `*.a` file).
 * `static.export` contains the static library produced by the C compiler from the `leanArts` (that is, a `*.a` file), with exported symbols.
 * `shared` contains the shared library (that is, a `*.so`, `*.dll`, or `*.dylib` file, depending on the platform).
 * `extraDep` contains a Lean library's `extraDepTargets` {TODO}[xref] and those of its package.
 * `leanExe` contains the executable binary produced from a Lean executable target.

The facets available for modules are:
 * `deps`                  dependencies (e.g., imports, shared libraries, etc.)
 * `leanArts` (default)    Lean artifacts (`*.olean`, `*.ilean`, `*.c` files)
 * `olean`                 OLean (binary blob of Lean data for importers)
 * `ilean`                 ILean (binary blob of metadata for the Lean LSP server)
 * `c`                     compiled C file
 * `bc`                    compiled LLVM bitcode file
 * `c.o`                   compiled object file (of its C file)
 * `bc.o`                  compiled object file (of its LLVM bitcode file)
 * `o`                     compiled object file (of its configured backend)
 * `dynlib`                shared library (e.g., for `--load-dynlib`)



UI Concepts

When I build a target, the packages' dependencies are built before the target.

Two notions of dependencies:
 * Packages depend on packages
 * Targets may depend on targets from other package
 * "ExtraDepTargets" imposes dependencies on all targets in a package

A target is something I wish to ask for - the user requests it. Front-facing name of the thing I want to ask for.
A build product on disk is named by a target and a facet. Each target has a default facet.

A build product is an _artifact_ - any persistent result.

The "workspace" is also part of the UI

A workspace is the full set of all required packages.
The "known universe" to lake.
Relevant when setting up the server - the server needs to know all the code to point at.
The workspace is composed of multiple packages - incl. the root package.
The root package is the one whose config file is read.

Package is unit of distribution, workspace is the name of the local files.

What is query? It's a way to get output from Lake from a target that doesn't go through a target.
Mostly machine-readable, and not interleaved with all the log stuff.

Pack/unpack: related to cloud releases/cloud build archives.
They give a "crate"/"uncrate".
They "zip up the build dir" essentially - unless platform independent option is set (no platform traces)
These are beta features

Upload: perhaps use from GH action?

It's an error if there's an incomplete manifest

Configuring a package is to parse the configuration, apply the options.
This is a one-time thing, and you must use `-R`.
Configuration happens again if the file changes, but changes to -K options require -R

Log levels: "trace" is hidden unless verbose

Modules in Lake are Lean modules + potentially generated ones not existing as code in the users's source directory
Module is the unit of code visible to the build system (smallest code unit visible to the build system)

Targets are:


Test driver: exe, script, library

Linters: exe or script

The check- versions are used to tell whether the problem is failing tests/lints vs misconfigured builds

:::TODO

What does Lake do and what does it not do?

Manifests

:::

## Test and Linter Drivers
%%%
tag := "test-lint-drivers"
%%%

:::TODO
Take text from README and lake help test/lake help lint
:::

A {deftech}_test driver_ is ... {TODO}[write]

A {deftech}_lint driver_ is ... {TODO}[write]

A test driver can be configured by either setting the 'testDriver'
package configuration option or by tagging a script, executable, or library
`@[test_driver]`. A definition in a dependency can be used as a test driver
by using the `<pkg>/<name>` syntax for the 'testDriver' configuration option.


{include 0 Manual.BuildTools.Lake.CLI}

{include 0 Manual.BuildTools.Lake.Config}

# API Reference
%%%
tag := "lake-api"
%%%

{docstring Lake.FetchM}

{docstring Lake.FetchM.run}

{docstring Lake.RecBuildM}

{docstring Lake.RecBuildM.runJobM}

{docstring Lake.RecBuildM.run}

{docstring Lake.RecBuildM.run'}

{docstring Lake.ScriptM}

{docstring Lake.buildCycleError}

{docstring Lake.addLeanTrace}

{docstring Lake.addPlatformTrace}

{docstring Lake.addPureTrace}

{docstring Lake.addTrace}

{docstring Lake.binder}

{docstring Lake.binder.formatter}

{docstring Lake.binder.parenthesizer}

{docstring Lake.buildFileAfterDep}

{docstring Lake.buildFileUnlessUpToDate'}

{docstring Lake.buildImportsAndDeps}

{docstring Lake.buildLeanExe}

{docstring Lake.buildLeanO}

{docstring Lake.buildLeanSharedLib}

{docstring Lake.buildLeanSharedLibOfStatic}

{docstring Lake.buildO}

{docstring Lake.buildSpecs}

{docstring Lake.buildStaticLib}

{docstring Lake.buildUnlessUpToDate}

{docstring Lake.buildUnlessUpToDate?}

{docstring Lake.buildUnlessUpToDate?.go}

{docstring Lake.busyAcquireLockFile}

{docstring Lake.busyAcquireLockFile.busyLoop}

{docstring Lake.cacheFileHash}

{docstring Lake.captureProc}

{docstring Lake.captureProc?}

{docstring Lake.checkHashUpToDate}

{docstring Lake.clearFileHash}

{docstring Lake.collectImportsAux}

{docstring Lake.compileExe}

{docstring Lake.compileLeanModule}

{docstring Lake.compileO}

{docstring Lake.compileSharedLib}

{docstring Lake.compileStaticLib}

{docstring Lake.computeArrayHash}

{docstring Lake.computeArrayTrace}

{docstring Lake.computeBinFileHash}

{docstring Lake.computeDynlibOfShared}

{docstring Lake.computeFileHash}

{docstring Lake.computeHash}

{docstring Lake.computeListTrace}

{docstring Lake.computePrecompileImportsAux}

{docstring Lake.computeTextFileHash}

{docstring Lake.computeTrace}

{docstring Lake.createParentDirs}

{docstring Lake.customDataDecl}

{docstring Lake.declareOpaqueType}

{docstring Lake.defaultBinDir}

{docstring Lake.defaultBuildArchive}

{docstring Lake.defaultBuildDir}

{docstring Lake.defaultConfigFile}

{docstring Lake.defaultIrDir}

{docstring Lake.defaultLakeDir}

{docstring Lake.defaultLeanConfigFile}

{docstring Lake.defaultLeanLibDir}

{docstring Lake.defaultManifestFile}

{docstring Lake.defaultNativeLibDir}

{docstring Lake.defaultPackagesDir}

{docstring Lake.defaultScriptAttr}

{docstring Lake.defaultTargetAttr}

{docstring Lake.defaultTomlConfigFile}

{docstring Lake.defaultVersionTags}

{docstring Lake.dirExt}

{docstring Lake.doElemTry_Else_}

{docstring Lake.download}

{docstring Lake.drbmapOf}

{docstring Lake.dropLogFrom}

{docstring Lake.elabVerLit}

{docstring Lake.elabVerLit.unsafe_1}

{docstring Lake.elabVerLit.unsafe_impl_1}

{docstring Lake.ensureJob}

{docstring Lake.env}

{docstring Lake.envToBool?}

{docstring Lake.errorWithLog}

{docstring Lake.exe}

{docstring Lake.exitIfErrorCode}

{docstring Lake.expandBinderIdent}

{docstring Lake.expandBinderModifier}

{docstring Lake.expandBinderType}

{docstring Lake.expandBinders}

{docstring Lake.expandOptIdent}

{docstring Lake.expandOptType}

{docstring Lake.externLibAttr}

{docstring Lake.extractLog}

{docstring Lake.familyDef}

{docstring Lake.fetchFileHash}

{docstring Lake.fetchFileTrace}

{docstring Lake.fetchOrCreate}

{docstring Lake.findElanInstall?}

{docstring Lake.findExternLib?}

{docstring Lake.findInstall?}

{docstring Lake.findLakeInstall?}

{docstring Lake.findLakeLeanJointHome?}

{docstring Lake.findLeanCmdInstall?}

{docstring Lake.findLeanExe?}

{docstring Lake.findLeanInstall?}

{docstring Lake.findLeanLib?}

{docstring Lake.findLeanSysroot?}

{docstring Lake.findModule?}

{docstring Lake.findPackage?}

{docstring Lake.flush}

{docstring Lake.foldlUtf8}

{docstring Lake.foldlUtf8M}

{docstring Lake.getAugmentedEnv}

{docstring Lake.getAugmentedLeanPath}

{docstring Lake.getAugmentedLeanSrcPath}

{docstring Lake.getAugmentedSharedLibPath}

{docstring Lake.getBinderIds}

{docstring Lake.getBuildConfig}

{docstring Lake.getBuildContext}

{docstring Lake.getElan?}

{docstring Lake.getElanHome?}

{docstring Lake.getElanInstall?}

{docstring Lake.getElanToolchain}

{docstring Lake.getEnvLeanPath}

{docstring Lake.getEnvLeanSrcPath}

{docstring Lake.getEnvSharedLibPath}

{docstring Lake.getFileMTime}

{docstring Lake.getIsOldMode}

{docstring Lake.getIsQuiet}

{docstring Lake.getIsVerbose}

{docstring Lake.getLake}

{docstring Lake.getLakeEnv}

{docstring Lake.getLakeHome}

{docstring Lake.getLakeInstall}

{docstring Lake.getLakeInstall?}

{docstring Lake.getLakeLibDir}

{docstring Lake.getLakeSrcDir}

{docstring Lake.getLean}

{docstring Lake.getLeanAr}

{docstring Lake.getLeanCc}

{docstring Lake.getLeanCc?}

{docstring Lake.getLeanIncludeDir}

{docstring Lake.getLeanInstall}

{docstring Lake.getLeanLibDir}

{docstring Lake.getLeanPath}

{docstring Lake.getLeanSharedLib}

{docstring Lake.getLeanSrcDir}

{docstring Lake.getLeanSrcPath}

{docstring Lake.getLeanSysroot}

{docstring Lake.getLeanSystemLibDir}

{docstring Lake.getLeanTrace}

{docstring Lake.getLeanc}

{docstring Lake.getLog}

{docstring Lake.getLogPos}

{docstring Lake.getNoBuild}

{docstring Lake.getNoCache}

{docstring Lake.getPkgUrlMap}

{docstring Lake.getRootPackage}

{docstring Lake.getSearchPath}

{docstring Lake.getSharedLibPath}

{docstring Lake.getTrace}

{docstring Lake.getTrustHash}

{docstring Lake.getTryCache}

{docstring Lake.getUrl}

{docstring Lake.getVerbosity}

{docstring Lake.guardCycle}

{docstring Lake.hexEncodeByte}

{docstring Lake.hydrateOpaqueType}

{docstring Lake.initLibraryFacetConfigs}

{docstring Lake.initModuleFacetConfigs}

{docstring Lake.initPackageFacetConfigs}

{docstring Lake.initSharedLib}

{docstring Lake.inputBinFile}

{docstring Lake.inputFile}

{docstring Lake.inputTextFile}

{docstring Lake.instToJsonFilePath_lake}

{docstring Lake.isUriUnreservedMark}

{docstring Lake.isVerLike}

{docstring Lake.lakeBuildHome?}

{docstring Lake.lakeExe}

{docstring Lake.leanArExe}

{docstring Lake.leanCcExe}

{docstring Lake.leanExe}

{docstring Lake.leanExeAttr}

{docstring Lake.leanLibAttr}

{docstring Lake.leanSharedLib}

{docstring Lake.leanSharedLibDir}

{docstring Lake.leancExe}

{docstring Lake.libraryDataDecl}

{docstring Lake.libraryFacetAttr}

{docstring Lake.lintDriverAttr}

{docstring Lake.logError}

{docstring Lake.logInfo}

{docstring Lake.logOutput}

{docstring Lake.logSerialMessage}

{docstring Lake.logToStream}

{docstring Lake.logVerbose}

{docstring Lake.logWarning}

{docstring Lake.lpad}

{docstring Lake.matchBinder}

{docstring Lake.maybeRegisterJob}

{docstring Lake.mixTraceArray}

{docstring Lake.mixTraceList}

{docstring Lake.mkBuildContext}

{docstring Lake.mkBuildSpec}

{docstring Lake.mkCmdLog}

{docstring Lake.mkConfigBuildSpec}

{docstring Lake.mkDRBMap}

{docstring Lake.mkExceptionMessage}

{docstring Lake.mkFacetConfig}

{docstring Lake.mkFacetJobConfig}

{docstring Lake.mkHoleFrom}

{docstring Lake.mkLakeContext}

{docstring Lake.mkMessageLogString}

{docstring Lake.mkMessageNoPos}

{docstring Lake.mkMessageString}

{docstring Lake.mkMessageStringCore}

{docstring Lake.mkOrdNameMap}

{docstring Lake.mkParserErrorMessage}

{docstring Lake.mkRBArray}

{docstring Lake.mkRelPathString}

{docstring Lake.mkTargetFacetBuild}

{docstring Lake.mkTargetJobConfig}

{docstring Lake.moduleDataDecl}

{docstring Lake.moduleFacetAttr}

{docstring Lake.monitorJobs}

{docstring Lake.nameToSharedLib}

{docstring Lake.nameToStaticLib}

{docstring Lake.noBuildCode}

{docstring Lake.ofFamily}

{docstring Lake.optsExt}

{docstring Lake.packageAttr}

{docstring Lake.packageDataDecl}

{docstring Lake.packageDepAttr}

{docstring Lake.packageFacetAttr}

{docstring Lake.parseExeTargetSpec}

{docstring Lake.parsePackageSpec}

{docstring Lake.parseTargetSpec}

{docstring Lake.parseTargetSpecs}

{docstring Lake.platformTrace}

{docstring Lake.postUpdateAttr}

{docstring Lake.print!}

{docstring Lake.proc}

{docstring Lake.pureHash}

{docstring Lake.pushLogEntry}

{docstring Lake.rawProc}

{docstring Lake.readTraceFile?}

{docstring Lake.recBuildExternDynlibs}

{docstring Lake.recBuildWithIndex}

{docstring Lake.recFetch}

{docstring Lake.recFetchAcyclic}

{docstring Lake.recFetchMemoize}

{docstring Lake.registerJob}

{docstring Lake.registerOrderedTagAttribute}

{docstring Lake.resolveCustomTarget}

{docstring Lake.resolveDefaultPackageTarget}

{docstring Lake.resolveExeTarget}

{docstring Lake.resolveExternLibTarget}

{docstring Lake.resolveLibTarget}

{docstring Lake.resolveLibTarget.resolveFacet}

{docstring Lake.resolveModuleTarget}

{docstring Lake.resolvePackageTarget}

{docstring Lake.resolveTargetBaseSpec}

{docstring Lake.resolveTargetInPackage}

{docstring Lake.resolveTargetInWorkspace}

{docstring Lake.rpad}

{docstring Lake.runBuild}

{docstring Lake.scriptAttr}

{docstring Lake.setTrace}

{docstring Lake.sharedLibExt}

{docstring Lake.sharedLibPathEnvVar}

{docstring Lake.stringToLegalOrSimpleName}

{docstring Lake.takeLog}

{docstring Lake.takeLogFrom}

{docstring Lake.takeTrace}

{docstring Lake.tar}

{docstring Lake.targetAttr}

{docstring Lake.targetDataDecl}

{docstring Lake.termTry_Else_}

{docstring Lake.testDriverAttr}

{docstring Lake.testProc}

{docstring Lake.toFamily}

{docstring Lake.toUpperCamelCase}

{docstring Lake.toUpperCamelCaseString}

{docstring Lake.toolchainFileName}

{docstring Lake.uiVersionString}

{docstring Lake.untar}

{docstring Lake.updateAction}

{docstring Lake.uriEncode}

{docstring Lake.uriEncodeChar}

{docstring Lake.uriEscapeByte}

{docstring Lake.uriEscapeChar}

{docstring Lake.verLit}

{docstring Lake.version.isRelease}

{docstring Lake.version.major}

{docstring Lake.version.minor}

{docstring Lake.version.patch}

{docstring Lake.version.specialDesc}

{docstring Lake.versionString}

{docstring Lake.versionStringCore}

{docstring Lake.versionTagPresets}

{docstring Lake.withExtractLog}

{docstring Lake.withLockFile}

{docstring Lake.withLogErrorPos}

{docstring Lake.withLoggedIO}

{docstring Lake.withRegisterJob}

{docstring Lake.writeTraceFile}

{docstring Lake.zpad}
