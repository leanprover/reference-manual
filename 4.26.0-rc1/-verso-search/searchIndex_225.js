window.docContents[225].resolve({"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Comparisons":{"contents":"Equality and inequality tests on Int are typically performed using the decidability of its equality and ordering relations or using the BEq Int and Ord Int instances.\n\n\n\nNon-strict inequality of integers, usually accessed via the ≤ operator.a ≤ b is defined as b - a ≥ 0, using Int.NonNeg.\n\nStrict inequality of integers, usually accessed via the < operator.a < b when a + 1 ≤ b.\n\nDecides whether two integers are equal. Usually accessed via the DecidableEq Int instance.This function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.Examples:* show (7 : Int) = (3 : Int) + (4 : Int) by decide* if (6 : Int) = (3 : Int) * (2 : Int) then \"yes\" else \"no\" = \"yes\"* (¬ (6 : Int) = (3 : Int)) = true\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","header":"20.2.4.5. Comparisons","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Comparisons"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion":{"contents":"Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence.\n\nTransforms the hash map into an array of mappings in some order.\n\nTransforms the hash map into a list of mappings in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","header":"20.18.3.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion"},"/The-Type-System/Inductive-Types/#structure-params":{"contents":"Just like ordinary inductive type declarations, the header of the structure declaration contains a signature that may specify both parameters and a resulting universe.\nStructures may not define indexed families.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Structure Declarations","header":"4.4.2.1. Structure Parameters","id":"/The-Type-System/Inductive-Types/#structure-params"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Linear-Integer-Normalization-in-simp-___arith":{"contents":"* #7000 adds helper theorems for justifying the linear integer\nnormalizer.* #7002 implements the normalizer for linear integer arithmetic\nexpressions. It is not connect to simp +arith yet because of some\nspurious [simp] attributes.* #7011 adds simp +arith for integers. It uses the new grind\nnormalizer for linear integer arithmetic. We still need to implement\nsupport for dividing the coefficients by their GCD. It also fixes\nseveral bugs in the normalizer.* #7015 makes sure simp +arith normalizes coefficients in linear\ninteger polynomials. There is still one todo: tightening the bound of\ninequalities.* #7030 adds completes the linear integer inequality normalizer for\ngrind. The missing normalization step replaces a linear inequality of\nthe form a_1*x_1 + ... + a_n*x_n + b <= 0 with a_1/k * x_1 + ... + a_n/k * x_n + ceil(b/k) <= 0 where k = gcd(a_1, ..., a_n).\nceil(b/k) is implemented using the helper cdiv b k.* #7040 ensures that terms such as f (2*x + y) and f (y + x + x)\nhave the same normal form when using simp +arith* #7043 deprecates the tactics simp_arith, simp_arith!,\nsimp_all_arith and simp_all_arith!. Users can just use the +arith\noption.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"Linear Integer Normalization in simp +arith","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Linear-Integer-Normalization-in-simp-___arith"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc1-_LPAR_2025-11-19_RPAR_--Lake":{"contents":"* #10861 fixes input_dir tracking to also recurse through\nsubdirectories. The filter of an input_dir will be applied to each\nfile in the directory tree (the path names of directories will not be\nchecked).* #10883 fixes a bug with Lake's cache where revisions were stored at the\nincorrect path. Revisions were stored at <rev>/<pkg>.jsonl rather than\nthe correct <pkg>/<rev>.jsonl.* #10959 enables Lake users to require Reservoir dependencies by a\nsemantic version range. On a lake update, Lake will fetch the\npackage's version information from Reservoir and select the newest\nversion of the package that satisfies the range.* #11062 changes Lake's debug build type to use -O0 instead of -Og\nwhen compiling C code. -Og was found to be insufficient for debugging\ncompiled Lean code -- relevant code was stilled optimized out.* #11063 changes the math and math-lax templates for lake new and\nlake init to use the version of Mathlib corresponding to the current\nLean toolchain. Thus, lake +x.y.z new <pkg> math will use the Mathlib\nfor Lean x.y.z. On the other hand, lake update on such packages will\nno longer update Mathlib automatically. Users will need to change the\nMathlib revision in the configuration file before updating.* #11117 fixes a bug where Lake ignored moreLinkObjs and moreLinkLibs\non a lean_exe.* #11118 adds Job.sync as a standard way of declaring a synchronous\njob.* #11169 changes all module build keys in Lake to be scoped by their\npackage. This enables building modules with the same name in different\npackages (something previously only well-supported for executable\nroots).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0-rc1 (2025-11-19)","header":"Lake","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc1-_LPAR_2025-11-19_RPAR_--Lake"}});