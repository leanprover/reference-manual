window.docContents[47].resolve({"/Basic-Types/The-Empty-Type/#empty":{"contents":"The empty type Empty represents impossible values.\nIt is an inductive type with no constructors whatsoever.\n\nWhile the trivial type Unit, which has a single constructor that takes no parameters, can be used to model computations where a result is unwanted or uninteresting, Empty can be used in situations where no computation should be possible at all.\nInstantiating a polymorphic type with Empty can mark some of its constructors—those with a parameter of the corresponding type—as impossible; this can rule out certain code paths that are not desired.\n\nThe presence of a term with type Empty indicates that an impossible code path has been reached.\nThere will never be a value with this type, due to the lack of constructors.\nOn an impossible code path, there's no reason to write further code; the function Empty.elim can be used to escape an impossible path.\n\nThe universe-polymorphic equivalent of Empty is PEmpty.\n\nThe empty type. It has no constructors.Use Empty.elim in contexts where a value of type Empty is in scope.\n\nThe universe-polymorphic empty type, with no constructors.PEmpty can be used in any universe, but this flexibility can lead to worse error messages and more\nchallenges with universe level unification. Prefer the type Empty or the proposition False when\npossible.\n\nImpossible Code PathsThe type signature of the function f indicates that it might throw exceptions, but allows the exception type to be anything:def f (n : Nat) : Except ε Nat := pure n\nInstantiating f's exception type with Empty exploits the fact that f never actually throws an exception to convert it to a function whose type indicates that no exceptions will be thrown.\nIn particular, it allows Empty.elim to be used to avoid handing the impossible exception value.def g (n : Nat) : Nat :=\n  match f (ε := Empty) n with\n  | .error e =>\n    Empty.elim e\n  | .ok v => v\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.10. The Empty Type","id":"/Basic-Types/The-Empty-Type/#empty"},"/Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions":{"contents":"Definitions add a new constant to the global environment as a name that stands for a term.\nAs part of the kernel's definitional equality, this new constant may be replaced via δ-reduction with the term that it stands for.\nIn the elaborator, this replacement is governed by the constant's reducibility.\nThe new constant may be universe polymorphic, in which case occurrences may instantiate it with different universe level parameters.\n\nFunction definitions may be recursive.\nTo preserve the consistency of Lean's type theory as a logic, recursive functions must either be opaque to the kernel (e.g. by declaring them partial) or proven to terminate with one of the strategies described in the section on recursive definitions.\n\nThe headers and bodies of definitions are elaborated together.\nIf the header is incompletely specified (e.g. a parameter's type or the codomain is missing), then the body may provide sufficient information for the elaborator to reconstruct the missing parts.\nHowever, instance implicit parameters must be specified in the header or as section variables.\n\nDefinitionsDefinitions that use := associate the term on the right-hand side with the constant's name.\nThe term is wrapped in a fun for each parameter, and the type is found by binding the parameters in a function type.\nDefinitions with def are semireducible.Definitions may use pattern matching.\nThese definitions are desugared to uses of match.Values of structure types, or functions that return them, may be defined by providing values for their fields, following where:\n\nAbbreviationsAbbreviations are identical to definitions with def, except they are reducible.\n\nOpaque constants are defined constants that are not subject to δ-reduction in the kernel.\nThey are useful for specifying the existence of some function.\nUnlike axioms, opaque declarations can only be used for types that are inhabited, so they do not risk introducing inconsistency.\nAlso unlike axioms, the inhabitant of the type is used in compiled code.\nThe implemented_by attribute can be used to instruct the compiler to emit a call to some other function as the compilation of an opaque constant.\n\nOpaque ConstantsOpaque definitions with right-hand sides are elaborated like other definitions.\nThis demonstrates that the type is inhabited; the inhabitant plays no further role.Opaque constants may also be specified without right-hand sides.\nThe elaborator fills in the right-hand side by synthesizing an instance of Inhabited, or Nonempty if that fails.\n\n","context":"Lean Reference\u0009Definitions","header":"7.3. Definitions","id":"/Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions"},"/Definitions/Headers-and-Signatures/#parameter-syntax":{"contents":"After the name, if present, is the header's signature.\nThe signature specifies the declaration's parameters and type.\n\nDeclaration SignaturesA signature consists of zero or more parameters, followed by a colon and a type.\n\nOptional SignaturesSignatures are often optional.\nIn these cases, parameters may be supplied even if the type is omitted.\n\nParameters may have three forms:\n\n* An identifier, which names a parameter but does not provide a type.\n   These parameters' types must be inferred during elaboration.* An underscore (_), which indicates a parameter that is not accessible by name in the local scope.\n   These parameters' types must also be inferred during elaboration.* A bracketed binder, which may specify every aspect of one or more parameters, including their names, their types, default values, and whether they are explicit, implicit, strictly implicit, or instance-implicit.\n\n","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","header":"7.2.2. Parameters and Types","id":"/Definitions/Headers-and-Signatures/#parameter-syntax"},"/Interacting-with-Lean/#interaction":{"contents":"Lean is designed for interactive use, rather than as a batch-mode system in which whole files are fed in and then translated to either object code or error messages.\nMany programming languages designed for interactive use provide a REPL,Short for “Read-Eval-Print Loop”, because code is parsed (“read”), evaluated, and the result displayed, with this process repeated as many times as desired. at which code can be input and tested, along with commands for loading source files, type checking terms, or querying the environment.\nLean's interactive features are based on a different paradigm.\nRather than a separate command prompt outside of the program, Lean provides commands for accomplishing the same tasks in the context of a source file.\nBy convention, commands that are intended for interactive use rather than as part of a durable code artifact are prefixed with #.\n\nInformation from Lean commands is available in the message log, which accumulates output from the elaborator.\nEach entry in the message log is associated with a specific source range and has a severity.\nThere are three severities: information is used for messages that do not indicate a problem, warning indicates a potential problem, and error indicates a definite problem.\nFor interactive commands, results are typically returned as informational messages that are associated with the command's leading keyword.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"3. Interacting with Lean","id":"/Interacting-with-Lean/#interaction"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Other":{"contents":"* #7129 optimizes the performance of the unused variables linter in the\ncase of a definition with a huge Expr representation* #7173 introduces a trace node for each deriving handlers invocation\nfor the benefit of trace.profiler* #7184 adds support for LEAN_BACKTRACE on macOS. This previously only\nworked with glibc, but it can not be enabled for all Unix-like systems,\nsince e.g. Musl does not support it.* #7190 makes the stage2 Leanc build use the stage2 oleans rather than\nstage1 oleans. This was happening because Leanc's own OLEAN_OUT is at\nthe build root rather than the lib/lean subdirectory, so when the build\nadded this OLEAN_OUT to LEAN_PATH no oleans were found there and the\nsearch fell back to the stage1 installation location.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Other","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Other"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Pretty-Printing":{"contents":"* #7589 changes the structure instance notation pretty printer so that\nfields are omitted if their value is definitionally equal to the default\nvalue for the field (up to reducible transparancy). Setting\npp.structureInstances.defaults to true forces such fields to be pretty\nprinted anyway.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)","header":"Pretty Printing","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Pretty-Printing"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Highlights":{"contents":"'Unknown identifier' code actions\n\n* #7665 and #8180 add\nsupport for code actions that resolve 'Unknown identifier' errors by either importing the missing declaration or by\nchanging the identifier to one from the environment.\n\nNew Language Features\n\n* #8449 and #8516\nupstream and extend the Mathlib clear_value tactic. Given a\nlocal definition x : T := v, the tactic clear_value x replaces it\nwith a hypothesis x : T, or throws an error if the goal does not\ndepend on the value v. The syntax clear_value (h : x = _) creates a\nhypothesis h : x = _ before clearing the value of x. Any expression definitionally equal to x\ncan be used in place of the underscore.\nFurthermore, clear_value * clears all values that can be cleared, or throws an\nerror if none can be cleared.* #8512 adds a value_of% ident term that elaborates to the value of\nthe local or global constant ident. This is useful for creating\ndefinition hypotheses:let x := ... complicated expression ...\nhave hx : x = value_of% x := rfl\n* #8450 adds a feature to the subst tactic so that when x : X := v\nis a local definition, subst x substitutes v for x in the goal and\nremoves x. Previously the tactic would throw an error.* #8037 introduces a noConfusionType construction that’s sub-quadratic\nin size, and reduces faster. The previous noConfusion construction with\ntwo nested match statements is quadratic in size and reduction behavior.\nUsing some helper definitions, a linear size construction is possible.* #8104 makes fun_induction and fun_cases (try to) unfold the\nfunction application of interest in the goal. The old behavior can be\nenabled with set_option tactic.fun_induction.unfolding false. For\nfun_cases this does not work yet when the function’s result type\ndepends on one of the arguments, see issue #8296.* #8171 omits cases from functional induction/cases principles that are\nimplemented by contradiction (or, more generally, False.elim,\nabsurd or `noConfusion). Breaking change in the sense that there are\nfewer goals to prove after using functional induction.* #8106 adds a register_linter_set command for declaring linter sets.\nThe getLinterValue function now checks if the present linter is\ncontained in a set that has been enabled (using the set_option command\nor on the command line).* #8267 makes #guard_msgs to treat trace messages separate from\ninfo, warning and error. It also introduces the ability to say\n#guard_msgs (pass info), like (drop info) so far, and also adds\n(check info) as the explicit form of (info), for completeness.\n\nLibrary Highlights\n\n* #8358 introduces a very minimal version of the new iterator library.\nIt comes with list iterators and various consumers, namely toArray,\ntoList, toListRev, ForIn, fold, foldM and drain. All\nconsumers also come in a partial variant that can be used without any\nproofs. This limited version of the iterator library generates decent\ncode, even with the old code generator.* #7352 reworks the simp set around the Id monad, to not elide or\nunfold pure and Id.run* #8313 changes the definition of Vector so it no longer extends\nArray. This prevents Array API from \"leaking through\".\n\nOther Highlights\n\n* Performance optimizations in dsimp:* #6973 stops dsimp from visiting proof terms, which should make\nsimp and dsimp more efficient.* #7428 adds a dsimp cache to simp. Previously each dsimp call from\nsimp started with a fresh cache. As a result, time spent in simp while\ncompiling Mathlib is reduced by over 45%, giving an overall 8% speedup to\nMathlib compilation.* #8221 adjusts the experimental module system to not export the bodies\nof defs unless opted out by the new attribute @[expose] on the def\nor on a surrounding section.* #8559 and #8560 fix an adversarial\nsoundness attack described  in #8554. The\nattack exploits the fact that assert! no longer aborts execution, and\nthat users can redirect error messages.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Highlights","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Highlights"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc1-_LPAR_2025-11-19_RPAR_--Tactics":{"contents":"* #10848 fixes an issue where adding a missing case name after the pipe\nin induction would not remove the now-obsolete error message.* #10858 improves the done tactic in grind interactive mode. It now\ndisplays the grind state diagnostics for all unsolved subgoals.* #10859 fixes auto-completion for set_option in grind interactive\nmode.* #10862 implements the show_term combinator in grind interactive\nmode.* #10874 uses the correct context for elaborating the grind state\nfilter.* #10877 fixes theory propagation issue in grind order.* #10881 fixes a proof instability source in grind.* #10887 uses the new TermInfo.isDisplayableTerm when hovering over\ncases tactic anchors in the grind interactive mode.* #10890 adds a +lax configuration option for grind, causing it to\nignore parameters referring to non-existent theorems, or to theorems for\nwhich we can't generate a pattern. This allows throwing large sets of\ntheorems (e.g. from a premise selection enginre) into grind to see\nwhat happens.* #10899 ensures the generated instantiate tactic instantiates the\ntheorems using the same order used by finish?* #10916 implements parameter optimization for the generated\ninstantiate tactics produced by finish?.\nWe use a simple parameter optimizer that takes two sets as input: the\nlower and upper bounds.\nThe lower bound consists of the theorems actually used in the proof\nterm, while the upper bound includes all the theorems instantiated in a\nparticular theorem instantiation step.\nThe lower bound is often sufficient to replay the proof, but in some\ncases, additional theorems must be included because a theorem\ninstantiation may contribute to the proof by providing terms and many\nnot be present in the final proof term.* #10919 implements the have <ident>? : <prop> tactic for the grind\ninteractive mode. The proposition is proved using the default grind\nsearch strategy. This tactic is also useful for inspecting or querying\nthe current grind state.* #10920 adds support for grind +premises, calling the currently\nconfigured premise selection algorithm and including the results as\nparameters to grind. (Recall that there is not currently a default\npremise selector provided by Lean4: you need a downstream premise\nselector to make use of this.)* #10936 fixes issues in grind => finish? that were preventing\ngenerated grind tactic scripts from being successfully replayed.* #10937 fixes a missing counter reset at the cases tactic in grind\ninteractive mode.* #10938 ensures solver grind tactics (e.g., ac, ring, lia, etc)\nprocess pending facts after making progress.* #10939 fixes another instance of the “default parameter value in\nconstructor” footgun, which was affecting the cases tactic in the\ngrind interactive mode.* #10948 ensures that finish? produces partial tactic scripts\ncontaining sorrys.\nWe may add an option to disable this feature in the future.\nIt is enabled by default because it provides a useful way to debug\ngrind failures.* #10949 ensures that solver propagation steps are necessary in the\ngenerated tactic script to close the goal.* #10950 adds the mbtc tactic to the grind interactive mode. It\nimplements model-based theory combination. It also ensures finish? is\ncapable of generating it.* #10951 fixes a bug in the cutsat incremental model construction. The\nmodel was not being reset when new (unsatisfied) equalities were\nasserted.* #10955 fixes a regression in the grind order module introduced by* #10956 fixes a bug in the equality propagation procedure in\ngrind.order. Specifically, it affects the procedure that asserts\nequalities in the grind core state that are implied by (ring)\ninequalities in the grind.order module.* #10960 fixes a bug in the grind linarith model/counterexample\nconstruction.* #10961 adds support for scientific literals for Rat in grind.\ngrind does not yet add support for this kind of literal in arbitrary\nfields.* #10962 fixes a spurious warning message in grind.* #10964 adds a propagator for a^(n+m) and removes its normalizer. This\nchange was motivated by issue #10661* #10965 ensures that model-based theory combination in grind cutsat\nconsiders nonlinear terms. Nonlinear multiplications such as x * y are\ntreated as uninterpreted symbols in cutsat.* #10971 adds a LawfulOfScientific class, providing compatibility with\na Lean.Grind.Field structure.* #10975 adds the combinator  · t_1 ... t_n to the grind interactive\nmode. The finish? tactic now generates scripts using this combinator\nto conform to Mathlib coding standards. The new format is also more\ncompact. Example:/--\ninfo: Try this:\n  [apply] ⏎\n    instantiate only [= mem_indices_of_mem, insert, = getElem_def]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #f590\n    · cases #ffdf\n      · instantiate only\n        instantiate only [= Array.getElem_set]\n      · instantiate only\n        instantiate only [size, = HashMap.mem_insert, = HashMap.getElem_insert, = Array.getElem_push]\n    · instantiate only [= mem_indices_of_mem, = getElem_def]\n      instantiate only [usr getElem_indices_lt]\n      instantiate only [size]\n      cases #ffdf\n      · instantiate only [=_ WF]\n        instantiate only [= getElem?_neg, = getElem?_pos, = Array.getElem_set]\n        instantiate only [WF']\n      · instantiate only\n        instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert, = Array.getElem_push]\n-/\n#guard_msgs in\nexample (m : IndexMap α β) (a a' : α) (b : β) (h : a' ∈ m.insert a b) :\n    (m.insert a b)[a'] = if h' : a' == a then b else m[a'] := by\n  grind => finish?\n* #10978 implements the following grind improvements:1. set_option can now be used to set grind configuration options in\nthe interactive mode.2. Fixes a bug in the repeated theorem instantiation detection.3. Adds the macro use [...] as a shorthand for instantiate only [...].* #10990 adds the set_config tactic for setting grind configuration\noptions. It uses the same syntax used for setting configuration options\nin the grind main tactic.* #10991 renames cutsat in configuration options and trace messages to\nlia.* #10992 ensures that grind +premises silently drops warnings and\nerrors about bad suggestions.* #10997 adds support for configuration options at finish and\nfinish?.* #11003 adds support for specifying anchors to restrict the search space\nin grind when using grind only. Anchors can limit which case splits\nare performed and which local lemmas are instantiated.* #11012 ensures the grind tactics finish and finish? can take\nparameters.* #11026 fixes a nontermination and missing propagation bug in grind order. It also register relevant case-splits for arithmetic.* #11028 ensures that grind? +premises removes +premises from the\n\"Try this\" suggestion.* #11029 changes the terminology used from \"premise selection\" to\n\"library suggestions\". This will be more understandable to users (we\ndon't assume anyone is familiar with the premise selection literature),\nand avoids a conflict with the existing use of \"premise\" in Lean\nterminology (e.g. \"major premise\" in induction, as well as generally the\nsynonym for \"hypothesis\"/\"argument\").* #11030 adds a library suggestion engine for local theorems. To be\nuseful, I still need to write more combinators to re-rank and combine\nsuggestions from multiple engines.* #11032 implements simp? +suggestions, which uses the configured\nlibrary suggestion engine to add relevant theorems to the simp call.\nsimp +suggestions without the ? prints a message requiring adding\nthe ?.* #11034 adds a new suggestion to finish?. It now generates the grind\ntactic script as before, and a finish only tactic. Example:/--\ninfo: Try these:\n  [apply] ⏎\n    instantiate only [findIdx, insert, = mem_indices_of_mem]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #1bba\n    · instantiate only [findIdx]\n    · instantiate only\n      instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert]\n  [apply] finish only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert, #1bba]\n-/\nexample (m : IndexMap α β) (a : α) (b : β) :\n    (m.insert a b).findIdx a = if h : a ∈ m then m.findIdx a else m.size := by\n  grind => finish?\n* #11039 fixes the grind invalid universe level regression reported in\n#11036* #11040 fixes a panic that occurred during the processing of generalized\nE-matching patterns in grind.* #11047 implements (nested term) equality propagation in grind order.\nThat is, it propagates implied equalities from grind order back to the\ngrind core. Examples:open Lean Grind Std\n\n* #11049 implements equality propagation for Nat in grind order.\ngrind order supports offset equalities for rings, but it has an\nadapter for Nat. Example:example (a b : Nat) (f : Nat → Int) : a ≤ b + 1 → b + 1 ≤ a → f (1 + a) = f (1 + b + 1) := by\n  grind -offset -mbtc -lia -linarith (splits := 0)\n* #11050 fixes equality propagation for Nat in grind order.* #11051 removes the grind offset module because it is (now) subsumed\nby grind order.* #11057 implements grind? using the new grind => finish?\ninfrastructure.* #11061 fixes a deep recursion issue in the kernel when type-checking a\nproof term produced by grind.* #11071 ensures that the denote functions used to implement\nproof-by-reflection terms in grind are abbreviations. This change\neliminates the need for the withAbstractAtoms gadget.* #11075 updates simp? +suggestions so that if a name is ambiguous\n(because of namespaces) all alternatives are used, rather than erroring.* #11077 fixes the anchor values produced by grind?* #11080 fixes a panic during equality propagation in the grind ring\nmodule. If the maximum number of steps has been reached, the polynomials\nmay not be fully simplified.* #11084 fixes a stack overflow that occurs when constructing a proof\nterm in grind.* #11087 enables grind to case bash on Sum and PSum.* #11092 ensures that grind ac denotation functions used in proof by\nreflection are marked as abbrev.* #11098 updates the suggestions tactic so the printed message includes\nhoverable type information (and displays scores and flags when\nrelevant).* #11099 improves the support for universe-metavariables in grind.* #11101 fixes an initialization issue for local Function.Injective f\nhypotheses.* #11126 ensures grind does not fail when applying injection to a\nhypothesis that cannot be cleared because of forward dependencies.* #11133 fixes disequality propagation for constructor applications in\ngrind. The equivalence class representatives may be distinct\nconstructor applications, but we must ensure they have the same type.\nExamples that were panic'ing before this PR:example (a b : List Nat)\n    : a ≍ ([] : List Int) → b ≍ ([1] : List Int) → a = b ∨ p → p := by\n  grind\n\n* #11135 ensures that checkExp is used in grind lia (formerly known\nas grind cutsat) and grind ring to prevent stack overflows.* #11136 adds support for try? to use induction; it will only perform\ninduction on inductive types defined in the current namespace and/or\nmodule; so in particular for now it will not induct on built-in\ninductives such as Nat or List.* #11137 fixes a stackoverflow during proof construction in grind.* #11145 fixes a bug in isMatchCondCandidate used in grind. The\nmissing condition was causing a \"not internalized term\" grind internal\nerror.* #11147 refactors the implementation of the symmetric equality\ncongruence rule used in grind.* #11148 addst the cases_next tactic to the grind interactive mode.* #11149 adds a user-extension mechanism for the try? tactic. You can\neither use the @[try_suggestion] attribute on a declaration with\nsignature MVarId -> Try.Info -> MetaM (Array (TSyntax `tactic)) to\nproduce suggestions, or the register_try?_tactic <stx> command with a\nfixed piece of syntax. User-extensions are only tried after the\nbuilt-in try strategies have been tried and failed.* #11157 implements the #grind_lint command, a diagnostic tool for\nanalyzing the behavior of theorems annotated for theorem instantiation.\nThe command helps identify problematic theorems that produce excessive\nor unbounded instance generation during E-matching, which can lead to\nperformance issues.\nThe main entry point is:#grind_lint check\nwhich analyzes all theorems marked with the @[grind] attribute.\nFor each theorem, it creates an artificial goal and runs grind,\ncollecting statistics about the number of instances produced.\nResults are summarized using info messages, and detailed breakdowns are\nshown for lemmas exceeding a configurable threshold.\nAdditional subcommands are provided for targeted inspection and control:* #grind_lint inspect thm: analyzes one or more specific theorems in\ndetail* #grind_lint mute thm: excludes a theorem from instantiation during\nanalysis* #grind_lint skip thm: omits a theorem from being analyzed by\n#grind_lint check* #11166 implements the following improvements to the #grind_lint\ncommand:1. More informative messages when the number of instances exceeds the\nminimum threshold.2. A code action for #grind_lint inspect that inserts\nset_option trace.grind.ematch.instance true whenever the number of\ninstances exceeds\nthe minimum threshold.3. Displaying doc strings for grind configuration options in\n#grind_lint.4. Improve doc strings for #grind_lint inspect and #grind_lint check.* #11167 implements support for #grind_lint check in module <module>.\nMathlib does not use namespaces, so we need to restrict the\n#grind_lint search space using module (prefix) names. Example:/--\ninfo: instantiating `Array.filterMap_some` triggers more than 100 additional `grind` theorem instantiations\n---\ninfo: Array.filterMap_some\n[thm] instances\n  [thm] Array.filterMap_filterMap ↦ 94\n  [thm] Array.size_filterMap_le ↦ 5\n  [thm] Array.filterMap_some ↦ 1\n---\ninfo: instantiating `Array.range_succ` triggers 22 additional `grind` theorem instantiations\n-/\n#guard_msgs in\n#grind_lint check (min := 20) in module Init.Data.Array\n* #11168 changes the default library suggestions (e.g. for grind +suggestions or `simp_all? +suggestions) to include the theorems from\nthe current file in addition to the output of Sine Qua Non.* #11170 adds tactic and term mode macros for ∎ (typed \\qed) which\nexpand to try?. The term mode version captures any produced\nsuggestions and prepends by.* #11171 ensures that tactics using library suggestions set the caller\nfield, so the premise selection engine has access to this. We'll later\nuse this to filter out some modules for grind, which we know have\nalready been fully annotated.* #11172 removes simp_all? +suggestions from try? for now. It's\nreally slow out in Mathlib; too often the suggestions cause simp to\nloop. Until we have the ability for try? to move past a timeing-out\ntactic (or maybe even until we have parallelism), it needs to be\nremoved.* #11174 modifies the try? framework, so each subsidiary tactic runs\nwith a separate maxHeartbeats budget.* #11187 adds syntax for specifying grind_pattern constraints and\nextends the EMatchTheorem object.* #11189 implements grind_pattern constraints. They are useful for\ncontrolling theorem instantiation in grind. As an example, consider\nthe following two theorems:theorem extract_empty {start stop : Nat} :\n    (#[] : Array α).extract start stop = #[] := …\n\n* #11193 uses the new grind_pattern constraints to fix cases where an\nunbounded number of theorem instantiations would be generated for\ncertain theorems in the standard library.* #11194 the redundant grind parameter warning message. It now checks\nthe grind theorem instantiation constraints too.* #11197 implements try? using the new finish? infrastructure. It\nalso removes the old tracing infrastructure, which is now obsolete.\nExample:/--\ninfo: Try these:\n  [apply] grind\n  [apply] grind only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert, #1bba]\n  [apply] grind only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert]\n  [apply] grind =>\n    instantiate only [findIdx, insert, = mem_indices_of_mem]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #1bba\n    · instantiate only [findIdx]\n    · instantiate only\n      instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert]\n-/\n#guard_msgs in\nexample (m : IndexMap α β) (a : α) (b : β) :\n    (m.insert a b).findIdx a = if h : a ∈ m then m.findIdx a else m.size := by\n  try?\n* #11203 fixes a few minor issues in the new Action framework used in\ngrind. The goal is to eventually delete the old SearchM\ninfrastructure. The main solve function used by grind is now based\non the Action framework. The PR also deletes dead code in SearchM.* #11204 has #grind_list check produce a \"Try this:\" suggestion with\n#grind_list inspect commands, as this is usually the next step in\ndealing with problematic cases. We also fix the grind pattern for one\ntheorem, as part of testing the workflow. More to follow.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0-rc1 (2025-11-19)","header":"Tactics","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc1-_LPAR_2025-11-19_RPAR_--Tactics"}});