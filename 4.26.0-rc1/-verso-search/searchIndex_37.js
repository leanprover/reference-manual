window.docContents[37].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic":{"contents":"These operators treat bitvectors as numbers.\nSome operations are signed, while others are unsigned.\nBecause bitvectors are understood as two's complement numbers, addition, subtraction and multiplication coincide for the signed and unsigned interpretations.\n\nAdds two bitvectors. This can be interpreted as either signed or unsigned addition modulo 2^n.\nUsually accessed via the + operator.SMT-LIB name: bvadd.\n\nSubtracts one bitvector from another. This can be interpreted as either signed or unsigned subtraction\nmodulo 2^n. Usually accessed via the - operator.\n\nMultiplies two bitvectors. This can be interpreted as either signed or unsigned multiplication\nmodulo 2^n. Usually accessed via the * operator.SMT-LIB name: bvmul.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"20.5.5.8. Arithmetic","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Re-Ordered-Operations":{"contents":"Sometimes, it can be convenient to partially apply a function to its second argument.\nThese functions reverse the order of arguments, making it this easier.\n\nMaps a function over a functor, with parameters swapped so that the function comes last.This function is Functor.map with the parameters reversed, typically used via the <&> operator.Conventions for notations in identifiers:* The recommended spelling of <&> in identifiers is mapRev.\n\nSame as Bind.bind but with arguments swapped.Conventions for notations in identifiers:* The recommended spelling of =<< in identifiers is bindLeft.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009API Reference","header":"14.4.5. Re-Ordered Operations","id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Re-Ordered-Operations"},"/Introduction/#dependency-licenses":{"contents":"\n\n","context":"Lean Reference\u0009Introduction","header":"Open-Source Licenses","id":"/Introduction/#dependency-licenses"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-nested":{"contents":"Executes the given conv block without converting regular goal into a conv goal.\n\nFocuses, converts the conv goal ⊢ lhs into a regular goal ⊢ lhs = rhs, and then executes the given tactic block.\n\nExecutes the given tactic block without converting conv goal into a regular goal.\n\nExecutes the given conv block without converting regular goal into a conv goal.\n\nconv => cs runs cs in sequence on the target t,\nresulting in t', which becomes the new target subgoal.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.5. Nested Tactics","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-nested"},"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen":{"contents":"This section is a tutorial that introduces the most important concepts of mvcgen top-down.\nRecall that you need to import Std.Tactic.Do and open Std.Do to run these examples:\n\nimport Std.Tactic.Do\n\n\nopen Std.Do\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic","header":"18.1. Verifying Imperative Programs Using  mvcgen","id":"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen"},"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen--Control-Flow":{"contents":"Let us consider another example that combines for loops with an early return.\nList.Nodup is a predicate that asserts that a given list does not contain any duplicates.\nThe function nodup below decides this predicate:def nodup (l : List Int) : Bool := Id.run do\n  let mut seen : Std.HashSet Int := ∅\n  for x in l do\n    if x ∈ seen then\n      return false\n    seen := seen.insert x\n  return true\n\n\nThis function is correct if it returns true for every list that satisfies List.Nodup and false for every list that does not.\nJust as it was in mySum, the use of do-notation and the Id monad is an internal implementation detail of nodup.\nThus, the proof begins by using Id.of_wp_run_eq to make the proof state amenable to mvcgen:theorem nodup_correct (l : List Int) : nodup l ↔ l.Nodup := by\n  generalize h : nodup l = r\n  apply Id.of_wp_run_eq h\n  mvcgen\n  invariants\n  · Invariant.withEarlyReturn\n      (onReturn := fun ret seen => ⌜ret = false ∧ ¬l.Nodup⌝)\n      (onContinue := fun xs seen =>\n        ⌜(∀ x, x ∈ seen ↔ x ∈ xs.prefix) ∧ xs.prefix.Nodup⌝)\n  with grind\n\n\nThe proof has the same succinct structure as for the initial mySum example, because we again offload all proofs to grind and its existing automation around List.Nodup.\nTherefore, the only difference is in the loop invariant.\nSince our loop has an early return, we construct the invariant using the helper function Invariant.withEarlyReturn.\nThis function allows us to specify the invariant in three parts:* onReturn ret seen holds after the loop was left through an early return with value ret.\n  In case of nodup, the only value that is ever returned is false, in which case nodup has decided there is a duplicate in the list.* onContinue xs seen is the regular induction step that proves the invariant is preserved each loop iteration.\n  The iteration state is captured by the cursor xs.\n  The given example asserts that the set seen contains all the elements of previous loop iterations and asserts that there were no duplicates so far.* onExcept must hold when the loop throws an exception.\n  There are no exceptions in Id, so we leave it unspecified to use the default.\n  (Exceptions will be discussed at a later point.)\n\nNote that the form mvcgen invariants? will suggest an initial invariant using Invariant.withEarlyReturn, so there is no need to memorize the exact syntax for specifying invariants:example (l : List Int) : nodup l ↔ l.Nodup := by\n  generalize h : nodup l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants? <;> sorry\nThe tactic suggests a starting invariant.\nThis starting point will not allow the proof to succeed—after all, if the invariant can be inferred by the system, then there's no need to make the user specify it—but it does provide a reminder of the correct syntax to use for assertions in the current monad:Try this:\n  [apply] invariants\n  ·\n    Invariant.withEarlyReturn (onReturn := fun r letMuts => ⌜l.Nodup ∧ (r = true ↔ l.Nodup)⌝) (onContinue :=\n      fun xs letMuts => ⌜xs.prefix = [] ∧ letMuts = ∅ ∨ xs.suffix = [] ∧ l.Nodup⌝)\n\n\nNow consider the following direct (and excessively golfed) proof without mvcgen:theorem nodup_correct_directly (l : List Int) : nodup l ↔ l.Nodup := by\n  rw [nodup]\n  generalize hseen : (∅ : Std.HashSet Int) = seen\n  change ?lhs ↔ l.Nodup\n  suffices h : ?lhs ↔ l.Nodup ∧ ∀ x ∈ l, x ∉ seen by grind\n  clear hseen\n  induction l generalizing seen with grind [Id.run_pure, Id.run_bind]\n\n\nSome observations:* The proof is even shorter than the one with mvcgen.* The use of generalize to generalize the accumulator relies on there being exactly one occurrence of ∅ to generalize. If that were not the case, we would have to copy parts of the program into the proof. This is a no-go for larger functions.* grind splits along the control flow of the function and reasons about Id, given the right lemmas.\n  While this works for Id.run_pure and Id.run_bind, it would not work for Id.run_seq, for example, because that lemma is not E-matchable.\n  If grind would fail, we would be forced to do all the control flow splitting and monadic reasoning by hand until grind could pick up again.\n\nThe usual way to avoid replicating the control flow of a definition in a proof is to use the fun_cases or fun_induction tactics.\nUnfortunately, fun_cases does not help with control flow inside a forIn application.\nThe mvcgen tactic, on the other hand, ships with support for many forIn implementations.\nIt can easily be extended (with @[spec] annotations) to support custom forIn implementations.\nFurthermore, an mvcgen-powered proof will never need to copy any part of the original program.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Verifying Imperative Programs Using  mvcgen","header":"18.1.3. Control Flow","id":"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen--Control-Flow"},"/The-Type-System/Quotients/#quotients-nested-inductives":{"contents":"Because Quot is not an inductive type, types implemented as quotients may not occur around nested occurrences in inductive type declarations.\nThese types declarations must be rewritten to remove the nested quotient, which can often be done by defining a quotient-free version and then separately defining an equivalence relation that implements the desired equality relation.\n\nNested Inductive Types and QuotientsThe nested inductive type of rose trees nests the recursive occurrence of RoseTree under List:inductive RoseTree (α : Type u) where\n  | leaf : α → RoseTree α\n  | branch : List (RoseTree α) → RoseTree α\nHowever, taking a quotient of the List that identifies all elements in the style of squash types causes Lean to reject the declaration:inductive SetTree (α : Type u) where\n  | leaf : α → SetTree α\n  | branch :\n    Quot (fun (xs ys : List (SetTree α)) => True) →\n    SetTree α\n(kernel) arg #2 of 'SetTree.branch' contains a non valid occurrence of the datatypes being declared\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Logical Model","header":"4.5.5.2. Quotients and Inductive Types","id":"/The-Type-System/Quotients/#quotients-nested-inductives"}});