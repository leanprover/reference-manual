window.docContents[59].resolve({"/Basic-Types/Strings/#string-api-pos":{"contents":"A byte position in a String, according to its UTF-8 encoding.Character positions (counting the Unicode code points rather than bytes) are represented by plain\nNats. Indexing a String by a String.Pos.Raw takes constant time, while character positions need to\nbe translated internally to byte positions, which takes linear time.A byte position p is valid for a string s if 0 ≤ p ≤ s.rawEndPos and p lies on a UTF-8\ncharacter boundary, see String.Pos.IsValid.There is another type, String.Pos, which bundles the validity predicate. Using String.Pos\ninstead of String.Pos.Raw is recommended because it will lead to less error handling and fewer edge cases.Get the underlying byte index of a String.Pos.Raw\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"20.8.4.5. Raw Positions","id":"/Basic-Types/Strings/#string-api-pos"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers--Weakest-Preconditions":{"contents":"The weakest precondition semantics of a monad are provided by the WP type class.\nInstances of WP determine the monad's postcondition shape and provide the logical rules for interpreting the monad's operations as a predicate transformer in its postcondition shape.\n\nA weakest precondition interpretation of a monadic program x : m α in terms of a predicate\ntransformer PredTrans ps α. The monad m determines ps : PostShape.For practical reasoning, an instance of WPMonad m ps is typically needed in addition to WP m ps.Interpret a monadic program x : m α in terms of a predicate transformer PredTrans ps α.\n\nWeakest Preconditionswp⟦x⟧ Q is defined as (WP.wp x).apply Q.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Predicate Transformers","header":"17.2.3.1. Weakest Preconditions","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers--Weakest-Preconditions"},"/The--mvcgen--tactic/Predicate-Transformers/#mvcgen-adequacy":{"contents":"Monads that can be invoked from pure code typically provide a invocation operator that takes any required input state as a parameter and returns either a value paired with an output state or some kind of exceptional value.\nExamples include StateT.run, ExceptT.run, and Id.run.\nAdequacy lemmas provide a bridge between statements about invocations of monadic programs and those programs' weakest precondition semantics as given by their WP instances.\nThey show that a property about the invocation is true if its weakest precondition is true.\n\nAdequacy lemma for Id.run.\nUseful if you want to prove a property about an expression x defined as Id.run prog and you\nwant to use mvcgen to reason about prog.\n\nAdequacy lemma for StateM.run.\nUseful if you want to prove a property about an expression x defined as StateM.run prog s and\nyou want to use mvcgen to reason about prog.\n\nAdequacy lemma for StateM.run'.\nUseful if you want to prove a property about an expression x defined as StateM.run' prog s and\nyou want to use mvcgen to reason about prog.\n\nAdequacy lemma for ReaderM.run.\nUseful if you want to prove a property about an expression x defined as ReaderM.run prog r and\nyou want to use mvcgen to reason about prog.\n\nAdequacy lemma for Except.\nUseful if you want to prove a property about an expression prog : Except ε α and you want to use\nmvcgen to reason about prog.\n\nAdequacy lemma for EStateM.run.\nUseful if you want to prove a property about an expression x defined as EStateM.run prog s and\nyou want to use mvcgen to reason about prog.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Predicate Transformers","header":"17.2.3.3. Adequacy Lemmas","id":"/The--mvcgen--tactic/Predicate-Transformers/#mvcgen-adequacy"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Library":{"contents":"* #11257 adds the definition of BitVec.cpop, which relies on the more\n  general BitVec.cpopNatRec, and build some theory around it. The name\n  cpop aligns with the RISCV ISA\n  nomenclature.* #11438 renames the namespace Std.Range to Std.Legacy.Range. Instead\n  of using Std.Range and [a:b] notation, the new range type Std.Rco\n  and its corresponding a...b notation should be used. There are also\n  other ranges with open/closed/infinite boundary shapes in\n  Std.Data.Range.Polymorphic and the new range notation also works for\n  Int, Int8, UInt8, Fin etc.* #11446 moves many constants of the iterator API from Std.Iterators to\n  the Std namespace in order to make them more convenient to use. These\n  constants include, but are not limited to, Iter, IterM and\n  IteratorLoop. This is a breaking change. If something breaks, try\n  adding open Std in order to make these constants available again. If\n  some constants in the Std.Iterators namespace cannot be found, they\n  can be found directly in Std now.* #11499 adds the Context type for cancellation with context\n  propagation. It works by storing a tree of forks of the main context,\n  providing a way to control cancellation.* #11532 adds the new operation MonadAttach.attach that attaches a\n  proof that a postcondition holds to the return value of a monadic\n  operation. Most non-CPS monads in the standard library support this\n  operation in a nontrivial way. The PR also changes the filterMapM,\n  mapM and flatMapM combinators so that they attach postconditions to\n  the user-provided monadic functions passed to them. This makes it\n  possible to prove termination for some of these for which it wasn't\n  possible before. Additionally, the PR adds many missing lemmas about\n  filterMap(M) and map(M) that were needed in the course of this PR.* #11693 makes it possible to verify loops over iterators. It provides\n  MPL spec lemmas about for loops over pure iterators. It also provides\n  spec lemmas that rewrite loops over mapM, filterMapM or filterM\n  iterator combinators into loops over their base iterator.* #11705 provides many lemmas about Int ranges, in analogy to those\n  about Nat ranges. A few necessary basic Int lemmas are added. The PR\n  also removes simp annotations on Rcc.toList_eq_toList_rco,\n  Nat.toList_rcc_eq_toList_rco and consorts.* #11706 removes the IteratorCollect type class and hereby simplifies\n  the iterator API. Its limited advantages did not justify the complexity\n  cost.* #11710 extends the get-elem tactic for ranges so that it supports\n  subarrays. Example:example {a : Array Nat} (h : a.size = 28) : Id Unit := do\n  let mut x := 0\n  for h : i in *...(3 : Nat) do\n    x := a[1...4][i]\n* #11716 adds more MPL spec lemmas for all combinations of for loops,\n  fold(M) and the filter(M)/filterMap(M)/map(M) iterator combinators.\n  These kinds of loops over these combinators (e.g. it.mapM) are first\n  transformed into loops over their base iterators (it), and if the base\n  iterator is of type Iter _ or IterM Id _, then another spec lemma\n  exists for proving Hoare triples about it using an invariant and the\n  underlying list (it.toList). The PR also fixes a bug that MPL always\n  assigns the default priority to spec lemmas if Std.Tactic.Do.Syntax is\n  not imported and a bug that low-priority lemmas are preferred about\n  high-priority ones.* #11724 adds more event_loop_locks to fix race conditions.* #11728 introduces some additional lemmas around BitVec.extractLsb'\n  and BitVec.extractLsb.* #11760 allows grind to use List.eq_nil_of_length_eq_zero (and\n  Array.eq_empty_of_size_eq_zero), but only when it has already proved\n  the length is zero.* #11761 adds some grind_pattern guard conditions to potentially\n  expensive theorems.* #11762 moves the grind pattern from Sublist.eq_of_length to the\n  slightly more general Sublist.eq_of_length_le, and adds a grind\n  pattern guard so it only activates if we have a proof of the hypothesis.* #11767 introduces two induction principles for bitvectors, based on the\n  concat and cons operations. We show how this principle can be useful to\n  reason about bitvectors by refactoring two population count lemmas\n  (cpopNatRec_zero_le and toNat_cpop_append) and introducing a new\n  lemma (toNat_cpop_not).\n  To use the induction principle we also move cpopNatRec_cons_of_le and\n  cpopNatRec_cons_of_lt earlier in the popcount section (they are the\n  building blocks enabling us to take advantage of the new induction\n  principle).* #11772 fixes a bug in the optimized and unsafe implementation of\n  Array.foldlM.* #11774 fixes a mismatch between the behavior of foldlM and\n  foldlMUnsafe in the three array\n  types. This mismatch is only exposed when manually specifying a stop\n  value greater than the size\n  of the array and only exploitable through native_decide.* #11779 fixes an oversight in the initial #11772 PR.* #11784 just adds an optional start position argument to\n  PersistentArray.forM* #11789 makes the FinitenessRelation structure, which is helpful when\n  proving the finiteness of iterators, part of the public API. Previously,\n  it was marked internal and experimental.* #11794 implements the function getMaxFVar? for implementing SymM\n  primitives.* #11834 adds num? parameter to mkPatternFromTheorem to control how\n  many leading quantifiers are stripped when creating a pattern. This\n  enables matching theorems where only some quantifiers should be\n  converted to pattern variables.* #11848 fixes a bug at Name.beq reported by\n  gasstationcodemanager@gmail.com* #11852 changes the definition of the iterator combinators takeWhileM\n  and dropWhileM so that they use MonadAttach. This is only relevant\n  in rare cases, but makes it sometimes possible to prove such combinators\n  finite when the finiteness depends on properties of the monadic\n  predicate.* #11901 adds gcd_left_comm lemmas for both Nat and Int:* Nat.gcd_left_comm: gcd m (gcd n k) = gcd n (gcd m k)* Int.gcd_left_comm: gcd a (gcd b c) = gcd b (gcd a c)* #11905 provides a Decidable instance for Nat.isPowerOfTwo based on\n  the formula (n ≠ 0) ∧ (n &&& (n - 1)) = 0.* #11907 implements PersistentHashMap.findKeyD and\n  PersistentHashSet.findD. The motivation is avoid two memory\n  allocations (Prod.mk and Option.some) when the collections contains\n  the key.* #11945 changes the runtime implementation of the Decidable (xs = #[])\n  and Decidable (#[] = xs) instances to use Array.isEmpty. Previously,\n  decide (xs = #[]) would first convert xs into a list and then\n  compare it against List.nil.* #11979 adds suggest_for annotations such that Int*.toNatClamp is\n  suggested for Int*.toNat.* #11989 removes a leftover example from\n  src/Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Clz.lean.* #11993 adds grind annotations to the lemmas about Subarray and\n  ListSlice.* #12058 implements iteration over ranges for Fin and Char.* #12139 adds «term_⁻¹» to the recommended_spelling for inv,\n  matching\n  the pattern used by all other operators which include both the function\n  and the syntax in their spelling lists.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0-rc1 (2026-01-26)","header":"Library","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Library"}});