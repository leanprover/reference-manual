window.docContents[179].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Arithmetic":{"contents":"Typically, arithmetic operations on Fin should be accessed using Lean's overloaded arithmetic notation, particularly via the instances Add (Fin n), Sub (Fin n), Mul (Fin n), Div (Fin n),  and Mod (Fin n).\nHeterogeneous operators such as Fin.natAdd do not have corresponding heterogeneous instances (e.g. HAdd) to avoid confusing type inference behavior.\n\nAddition modulo n, usually invoked via the + operator.Examples:* (2 : Fin 8) + (2 : Fin 8) = (4 : Fin 8)* (2 : Fin 3) + (2 : Fin 3) = (1 : Fin 3)\n\nAdds a natural number to a Fin, increasing the bound.This is a generalization of Fin.succ.Fin.addNat is a version of this function that takes its Nat parameter second.Examples:* Fin.natAdd 3 (5 : Fin 8) = (8 : Fin 11)* Fin.natAdd 1 (0 : Fin 8) = (1 : Fin 9)* Fin.natAdd 1 (2 : Fin 8) = (3 : Fin 9)\n\nAdds a natural number to a Fin, increasing the bound.This is a generalization of Fin.succ.Fin.natAdd is a version of this function that takes its Nat parameter first.Examples:* Fin.addNat (5 : Fin 8) 3 = (8 : Fin 11)* Fin.addNat (0 : Fin 8) 1 = (1 : Fin 9)* Fin.addNat (1 : Fin 8) 2 = (3 : Fin 10)\n\nMultiplication modulo n, usually invoked via the * operator.Examples:* (2 : Fin 10) * (2 : Fin 10) = (4 : Fin 10)* (2 : Fin 10) * (7 : Fin 10) = (4 : Fin 10)* (3 : Fin 10) * (7 : Fin 10) = (1 : Fin 10)\n\nSubtraction modulo n, usually invoked via the - operator.Examples:* (5 : Fin 11) - (3 : Fin 11) = (2 : Fin 11)* (3 : Fin 11) - (5 : Fin 11) = (9 : Fin 11)\n\nSubtraction of a natural number from a Fin, with the bound narrowed.This is a generalization of Fin.pred. It is guaranteed to not underflow or wrap around.Examples:* (5 : Fin 9).subNat 2 (by decide) = (3 : Fin 7)* (5 : Fin 9).subNat 0 (by decide) = (5 : Fin 9)* (3 : Fin 9).subNat 3 (by decide) = (0 : Fin 6)\n\nDivision of bounded numbers, usually invoked via the / operator.The resulting value is that computed by the / operator on Nat. In particular, the result of\ndivision by 0 is 0.Examples:* (5 : Fin 10) / (2 : Fin 10) = (2 : Fin 10)* (5 : Fin 10) / (0 : Fin 10) = (0 : Fin 10)* (5 : Fin 10) / (7 : Fin 10) = (0 : Fin 10)\n\nModulus of bounded numbers, usually invoked via the % operator.The resulting value is that computed by the % operator on Nat.\n\nModulus of bounded numbers with respect to a Nat.The resulting value is that computed by the % operator on Nat.\n\nLogarithm base 2 for bounded numbers.The resulting value is the same as that computed by Nat.log2. In particular, the result for 0 is\n0.Examples:* (8 : Fin 10).log2 = (3 : Fin 10)* (7 : Fin 10).log2 = (2 : Fin 10)* (4 : Fin 10).log2 = (2 : Fin 10)* (3 : Fin 10).log2 = (1 : Fin 10)* (1 : Fin 10).log2 = (0 : Fin 10)* (0 : Fin 10).log2 = (0 : Fin 10)\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"20.3.3.2. Arithmetic","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Arithmetic"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion--Unbundled-Variants":{"contents":"Unbundled sets separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the module Std.TreeSet.Raw.\n\nTree sets without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer TreeSet\nover TreeSet.Raw. Lemmas about the operations on Std.TreeSet.Raw are available in the\nmodule Std.Data.TreeSet.Raw.Lemmas.A tree set stores elements of a certain type in a certain order. It depends on a comparator function\nthat defines an ordering on the keys and provides efficient order-dependent queries, such as\nretrieval of the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e only one of them\ncan be contained in a single tree set at the same time.To avoid expensive copies, users should make sure that the tree set is used linearly.Internally, the tree sets are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.Internal implementation detail of the tree set.\n\nWell-formedness predicate for tree sets. Users of TreeSet will not need to interact with\nthis. Users of TreeSet.Raw will need to provide proofs of WF to lemmas and should use lemmas\nlike WF.empty and WF.insert (which are always named exactly like the operations they are about)\nto show that set operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.Internal implementation detail of the tree map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets\u0009Conversion","header":"20.19.10.6.1. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion--Unbundled-Variants"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax":{"contents":"Lean supports programming with functors, applicative functors, and monads via special syntax:\n\n* Infix operators are provided for the most common operations.* An embedded language called do-notation allows the use of imperative syntax when writing programs in a monad.\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation","header":"18.3. Syntax","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads":{"contents":"Monads are primarily used via do-notation.\nHowever, it can sometimes be convenient to describe monadic computations via operators.\n\n\n\nMonad Operatorsact >>= f is syntax for Bind.bind act f.Similarly, the reversed operator f =<< act is syntax for Bind.bind act f.The Kleisli composition operators Bind.kleisliRight and Bind.kleisliLeft also have infix operators.\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009Infix Operators","header":"18.3.1.3. Monads","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads"},"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Consuming-Pure-Iterators":{"contents":"Folds a function over an iterator from the left, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in order, using f.It is equivalent to it.toList.foldl.\n\nFolds a monadic function over an iterator from the left, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in order, using f.It is equivalent to it.toList.foldlM.\n\nSteps through the whole iterator, counting the number of outputs emitted.Performance:This function's runtime is linear in the number of steps taken by the iterator.\n\nReturns true if the pure predicate p returns true for\nany element emitted by the iterator it.O(|xs|). Short-circuits upon encountering the first match. The elements in it are\nexamined in order of iteration.\n\nReturns true if the monadic predicate p returns true for\nany element emitted by the iterator it.O(|xs|). Short-circuits upon encountering the first match. The elements in it are\nexamined in order of iteration.\n\nReturns true if the pure predicate p returns true for\nall element emitted by the iterator it.O(|xs|). Short-circuits upon encountering the first match. The elements in it are\nexamined in order of iteration.\n\nReturns true if the monadic predicate p returns true for\nall element emitted by the iterator it.O(|xs|). Short-circuits upon encountering the first match. The elements in it are\nexamined in order of iteration.\n\nReturns the first output of the iterator for which the predicate p returns true, or none if\nno such output is found.O(|it|). Short-circuits upon encountering the first match. The elements in it are examined in\norder of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.find? always terminates after finitely many steps.Examples:* [7, 6, 5, 8, 1, 2, 6].iter.find? (· < 5) = some 1* [7, 6, 5, 8, 1, 2, 6].iter.find? (· < 1) = none\n\nReturns the first output of the iterator for which the monadic predicate p returns true, or\nnone if no such element is found.O(|it|). Short-circuits when f returns true. The outputs of it are examined in order of\niteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findM? always terminates after finitely many steps.Example:#eval [7, 6, 5, 8, 1, 2, 6].iter.findM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 6\nAlmost! 5\nsome 1\n\n\nReturns the first non-none result of applying f to each output of the iterator, in order.\nReturns none if f returns none for all outputs.O(|it|). Short-circuits when f returns some _.The outputs of it are examined in order of\niteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findSome? always terminates after finitely many steps.Examples:* [7, 6, 5, 8, 1, 2, 6].iter.findSome? (fun x => if x < 5 then some (10 * x) else none) = some 10* [7, 6, 5, 8, 1, 2, 6].iter.findSome? (fun x => if x < 1 then some (10 * x) else none) = none\n\nReturns the first non-none result of applying the monadic function f to each output\nof the iterator, in order. Returns none if f returns none for all outputs.O(|it|). Short-circuits when f returns some _. The outputs of it are\nexamined in order of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findSomeM? always terminates after finitely many steps.Example:#eval [7, 6, 5, 8, 1, 2, 6].iter.findSomeM? fun i => do\n  if i < 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\nAlmost! 6\nAlmost! 5\nsome 10\n\n\nReturns the n-th value emitted by it, or none if it terminates earlier.For monadic iterators, the monadic effects of this operation may differ from manually iterating\nto the n-th value because atIdx? can take shortcuts. By the signature, the return value\nis guaranteed to plausible in the sense of IterM.IsPlausibleNthOutputStep.This function is only available for iterators that explicitly support it by implementing\nthe IteratorAccess typeclass.\n\nIf possible, takes n steps with the iterator it and\nreturns the n-th emitted value, or none if it finished\nbefore emitting n values.This function requires a Productive instance proving that the iterator will always emit a value\nafter a finite number of skips. If the iterator is not productive or such an instance is not\navailable, consider using it.allowNontermination.atIdxSlow? instead of it.atIdxSlow?. However,\nit is not possible to formally verify the behavior of the partial variant.\n\n","context":"Lean Reference\u0009Iterators\u0009Consuming Iterators","header":"22.3.2. Consuming Pure Iterators","id":"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Consuming-Pure-Iterators"}});