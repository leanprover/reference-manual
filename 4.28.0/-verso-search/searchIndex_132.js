window.docContents[132].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map, and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.If the returned Bool is true, then the returned map is unaltered. If the Bool is false, then\nthe returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the hash map for which the given function returns false.\n\nUpdates the values of the hash map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.Note: this replacement behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insert function on HashSet and HashSet.Raw behaves differently: it will return the set\nunchanged if a matching key is already present.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.\n\nInserts multiple mappings into the hash map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insertMany function on HashSet and HashSet.Raw behaves differently: it will prefer the first\nappearance.\n\nInserts multiple keys with the value () into the hash map by iterating over the given collection\nand calling insertIfNew. If the same key appears multiple times, the first occurrence takes\nprecedence.This is mainly useful to implement HashSet.insertMany, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Maps","header":"20.19.4.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Modification"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Documentation":{"contents":"* #8934 adds explanations for a few errors concerning noncomputability,\nredundant match alternatives, and invalid inductive declarations.* #8990 adds missing docstrings for grind's internal algebra\ntype classes, for inclusion in the reference manual.* #8998 makes the docstrings related to Format and Repr have\nconsistent formatting and style, and adds missing docstrings.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Documentation","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Documentation"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Documentation":{"contents":"* #10632 adds missing docstrings for ByteArray and makes existing ones\nconsistent with our style.* #10640 adds a missing docstring and applies our style guide to parts of\nthe String API.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)","header":"Documentation","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Documentation"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind--Injective-functions":{"contents":"#10445,\n#10447,\n#10482, and\n#10483 add support for injective functions in grind.\n\n/-! Add some injectivity theorems. -/\n\ndef double (x : Nat) := 2*x\n\n@[grind inj] theorem double_inj : Function.Injective double := by\n  grind [Function.Injective, double]\n\nstructure InjFn (α : Type) (β : Type) where\n  f : α → β\n  h : Function.Injective f\n\ninstance : CoeFun (InjFn α β) (fun _ => α → β) where\n  coe s := s.f\n\n@[grind inj] theorem fn_inj (F : InjFn α β) : Function.Injective (F : α → β) := by\n  grind [Function.Injective, cases InjFn]\n\ndef toList (a : α) : List α := [a]\n\n@[grind inj] theorem toList_inj : Function.Injective (toList : α → List α) := by\n  grind [Function.Injective, toList]\n\n/-! Examples -/\n\nexample (x y : Nat) : toList (double x) = toList (double y) → x = y := by\n  grind\n\nexample (f : InjFn (List Nat) α) (x y z : Nat)\n    : f (toList (double x)) = f (toList y) →\n      y = double z →\n      x = z := by\n  grind\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights\u0009Grind","header":"Injective functions","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind--Injective-functions"}});