window.docContents[218].resolve({"/Definitions/Recursive-Definitions/#wf-rel":{"contents":"A relation ≺ is a well-founded relation if there exists no infinitely descending chain\n\n x_0 ≻ x_1 ≻ \\cdots\n\nIn Lean, types that are equipped with a canonical well-founded relation are instances of the WellFoundedRelation type class.\n\nA type that has a standard well-founded relation.Instances are used to prove that functions terminate using well-founded recursion by showing that\nrecursive calls reduce some measure according to a well-founded relation. This relation can combine\nwell-founded relations on the recursive function's parameters.A well-founded relation on α.A proof that rel is, in fact, well-founded.\n\n\n\nThe most important instances are:\n\n* Nat, ordered by (· < ·).* Prod, ordered lexicographically: (a₁, b₁) ≺ (a₂, b₂) if and only if a₁ ≺ a₂ or a₁ = a₂ and b₁ ≺ b₂.* Every type that is an instance of the SizeOf type class, which provides a method SizeOf.sizeOf, has a well-founded relation.\n  For these types, x₁ ≺ x₂ if and only if sizeOf x₁ < sizeOf x₂. For inductive types, a SizeOf instance is automatically derived by Lean.\n\n\n\nNote that there exists a low-priority instance instSizeOfDefault that provides a SizeOf instance for any type, and always returns 0.\nThis instance cannot be used to prove that a function terminates using well-founded recursion because 0 < 0 is false.\n\n\n\nDefault Size InstanceFunction types in general do not have a well-founded relation that's useful for termination proofs.\nInstance synthesis thus selects instSizeOfDefault and the corresponding well-founded relation.\nIf the measure is a function, the default SizeOf instance is selected and the proof cannot succeed.def fooInst (b : Bool → Bool) : Unit := fooInst (b ∘ b)\ntermination_by b\ndecreasing_by\n  guard_target =\n    @sizeOf (Bool → Bool) (instSizeOfDefault _) (b ∘ b) < sizeOf b\n  simp only [sizeOf, default.sizeOf]\n  guard_target = 0 < 0\n  simp\n  guard_target = False\n  sorry\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","header":"7.6.3.1. Well-Founded Relations","id":"/Definitions/Recursive-Definitions/#wf-rel"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Token-and-Literal-Kinds":{"contents":"A number of named kinds are associated with the basic tokens produced by the parser.\nTypically, single-token syntax productions consist of a node that contains a single atom; the kind saved in the node allows the value to be recognized.\nAtoms for literals are not interpreted by the parser: string atoms include their leading and trailing double-quote characters along with any escape sequences contained within, and hexadecimal numerals are saved as a string that begins with \"0x\".\nHelpers such as Lean.TSyntax.getString are provided to perform this decoding on demand.\n\n\n\nThe pseudo-kind assigned to identifiers: `ident.The name `ident is not actually used as a kind for Syntax.node values. It is used by\nconvention as the kind of Syntax.ident values.\n\n`str is the node kind of string literals like \"foo\".\n\n`interpolatedStrKind is the node kind of an interpolated string literal like \"value = {x}\"\nin s!\"value = {x}\".\n\n`interpolatedStrLitKind is the node kind of interpolated string literal\nfragments like \"value = { and }\" in s!\"value = {x}\".\n\n`char is the node kind of character literals like 'A'.\n\n`num is the node kind of number literals like 42 and 0xa1\n\n`scientific is the node kind of floating point literals like 1.23e-3.\n\n`name is the node kind of name literals like `foo.\n\n`fieldIdx is the node kind of projection indices like the 2 in x.2.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"23.4.3. Token and Literal Kinds","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Token-and-Literal-Kinds"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Notation":{"contents":"The syntax of stateful predicates overlaps with that of ordinary Lean terms.\nIn particular, stateful predicates use the usual syntax for logical connectives and quantifiers.\nThe syntax associated with stateful predicates is automatically enabled in contexts such as pre- and postconditions where they are clearly intended; other contexts must explicitly opt in to the syntax using spred.\nThe usual meanings of these operators can be recovered by using the term operator.\n\nPredicate Termsspred indicates that logical connectives and quantifiers should be understood as those pertaining to stateful predicates, while term indicates that they should have the usual meaning.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Stateful Predicates","header":"17.2.1.2. Notation","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Notation"},"/The--mvcgen--tactic/Proof-Mode/#mvcgen-proof-mode":{"contents":"Stateful goals can be proven using a special proof mode in which goals are rendered with two contexts of hypotheses: the ordinary Lean context, which contains Lean variables, and a special stateful context, which contains assumptions about the monadic state.\nIn the proof mode, the goal is an SPred, rather than a Prop, and the entire goal is equivalent to an entailment relation (SPred.entails) from the conjunction of the hypotheses to the conclusion.\n\nProof Mode GoalsProof mode goals are rendered as a series of named hypotheses, one per line, followed by ⊢ₛ and a goal.\n\nIn the proof mode, special tactics manipulate the stateful context.\nThese tactics are described in their own section in the tactic reference.\n\nWhen working with concrete monads, mvcgen typically does not result in stateful proof goals—they are simplified away.\nHowever, monad-polymorphic theorems can lead to stateful goals remaining.\n\nStateful ProofsThe function bump increments its state by the indicated amount and returns the resulting value.variable [Monad m] [WPMonad m ps]\ndef bump (n : Nat) : StateT Nat m Nat := do\n  modifyThe Nat (· + n)\n  getThe Nat\nThis specification lemma for bump is proved in an intentionally low-level manner to demonstrate the intermediate proof states:theorem bump_correct :\n      ⦃ fun n => ⌜n = k⌝ ⦄\n      bump (m := m) i\n      ⦃ ⇓ r n => ⌜r = n ∧ n = k + i⌝ ⦄ := by\n  mintro n_eq_k\n  unfold bump\n  unfold modifyThe\n  mspec\n  mspec\n  mpure_intro\n  constructor\n  . trivial\n  . simp_all\nThe lemma can also be proved using only the simplifier:theorem bump_correct' :\n    ⦃ fun n => ⌜n = k⌝ ⦄\n    bump (m := m) i\n    ⦃ ⇓ r n => ⌜r = n ∧ n = k + i⌝ ⦄ := by\n  mintro _\n  simp_all [bump]\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic","header":"17.5. Proof Mode","id":"/The--mvcgen--tactic/Proof-Mode/#mvcgen-proof-mode"}});