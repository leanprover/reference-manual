window.docContents[211].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms":{"contents":"Computes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog.\n\nComputes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlogf.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10f.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2f.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"20.6.2.6. Logarithms","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Substrings--Modifications":{"contents":"Removes the specified number of characters (Unicode code points) from the beginning of a substring\nby advancing its start position.If the substring's end position is reached, the start position is not advanced past it.\n\nRemoves the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position. The start position is moved to the position of\nthe first character for which the predicate returns false, or to the substring's end position if\nthe predicate always returns true.\n\nRemoves the specified number of characters (Unicode code points) from the end of a substring\nby moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRemoves the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position. The end position is moved just after the position\nof the last character for which the predicate returns false, or to the substring's start position\nif the predicate always returns true.\n\nRetains only the specified number of characters (Unicode code points) at the beginning of a\nsubstring, by moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRetains only the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position towards its start position.\n\nRetains only the specified number of characters (Unicode code points) at the end of a substring, by\nmoving its start position towards its end position.If the substring's end position is reached, the start position is not advanced past it.\n\nRetains only the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position towards its end position.\n\nReturns the region of the substring delimited by the provided start and stop positions, as a\nsubstring. The positions are interpreted with respect to the substring's start position, rather than\nthe underlying string.If the resulting substring is empty, then the resulting substring is a substring of the empty string\n\"\". Otherwise, the underlying string is that of the input substring with the beginning and end\npositions adjusted.\n\nRemoves leading and trailing whitespace from a substring by first moving its start position to the\nfirst non-whitespace character, and then moving its end position to the last non-whitespace\ncharacter.If the substring consists only of whitespace, then the resulting substring's start position is moved\nto its end position.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \" red green blue \".toRawSubstring.trim.toString = \"red green blue\"* \" red green blue \".toRawSubstring.trim.startPos = ⟨1⟩* \" red green blue \".toRawSubstring.trim.stopPos = ⟨15⟩* \"     \".toRawSubstring.trim.startPos = ⟨5⟩\n\nRemoves leading whitespace from a substring by moving its start position to the first non-whitespace\ncharacter, or to its end position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nRemoves trailing whitespace from a substring by moving its end position to the last non-whitespace\ncharacter, or to its start position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nSplits a substring s on occurrences of the separator string sep. The default separator is \" \".When sep is empty, the result is [s]. When sep occurs in overlapping patterns, the first match\nis taken. There will always be exactly n+1 elements in the returned list if there were n\nnon-overlapping matches of sep in the string. The separators are not included in the returned\nsubstrings, which are all substrings of s's string.\n\nGiven a Substring, returns another one which has valid endpoints\nand represents the same substring according to Substring.toString.\n(Note, the substring may still be inverted, i.e. beginning greater than end.)\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Substrings","header":"20.8.4.12.7. Modifications","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Substrings--Modifications"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams":{"contents":"Lean provides a consistent filesystem API on all supported platforms.\nThese are the key concepts:\n\n Files\n\nFiles are an abstraction provided by operating systems that provide random access to persistently-stored data, organized hierarchically into directories.\n\n Directories\n\nDirectories, also known as folders, may contain files or other directories.\n  Fundamentally, a directory maps names to the files and/or directories that it contains.\n\n File Handles\n\nFile handles (Handle) are abstract references to files that have been opened for reading and/or writing.\n  A file handle maintains a mode that determines whether reading and/or writing are allowed, along with a cursor that points at a specific location in the file.\n  Reading from or writing to a file handle advances the cursor.\n  File handles may be buffered, which means that reading from a file handle may not return the current contents of the persistent data, and writing to a file handle may not modify them immediately.\n\n Paths\n\nFiles are primarily accessed via paths (System.FilePath).\n  A path is a sequence of directory names, potentially terminated by a file name.\n  They are represented by strings in which separator characters The current platform's separator characters are listed in System.FilePath.pathSeparators. delimit the names.The details of paths are platform-specific.\n  Absolute paths begin in a root directory; some operating systems have a single root, while others may have multiple root directories.\n  Relative paths do not begin in a root directory and require that some other directory be taken as a starting point.\n  In addition to directories, paths may contain the special directory names ., which refers to the directory in which it is found, and .., which refers to prior directory in the path.Filenames, and thus paths, may end in one or more extensions that identify the file's type.\n  Extensions are delimited by the character System.FilePath.extSeparator.\n  On some platforms, executable files have a special extension (System.FilePath.exeExtension).\n\n Streams\n\nStreams are a higher-level abstraction over files, both providing additional functionality and hiding some details of files.\n  While file handles are essentially a thin wrapper around the operating system's representation, streams are implemented in Lean as a structure called IO.FS.Stream.\n  Because streams are implemented in Lean, user code can create additional streams, which can be used seamlessly together with those provided in the standard library.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"21.5. Files, File Handles, and Streams","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams"},"/The--grind--tactic/Reducibility/#The-Lean-Language-Reference--The--grind--tactic--Reducibility":{"contents":"Reducible definitions in terms are eagerly unfolded by grind.\nThis enables more efficient definitional equality comparisons and indexing.\n\nReducibility and Congruence ClosureThe definition of one is not reducible:def one := 1\nThis means that grind does not unfold it:example : one = 1 := by grind\n`grind` failed\ncase grind\nh : ¬one = 1\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] False propositions\n  [cutsat] Assignment satisfying linear constraints\ntwo, on the other hand, is an abbreviation and thus reducible:abbrev two := 2\ngrind unfolds two before adding it to the “whiteboard”, allowing the proof to be completed immediately:example : two = 2 := by grind\n\n\nE-matching patterns also unfold reducible definitions.\nThe patterns generated for theorems about abbreviations are expressed in terms of the unfolded abbreviations.\nAbbreviations should not generally be recursive; in particular, when using grind, recursive abbreviations can result in poor indexing performance and unpredictable patterns.\n\nE-matching and Unfolding AbbreviationsWhen adding grind annotations to theorems, E-matching patterns are generated based on the theorem statement.\nThese patterns determine when the theorem is instantiated.\nThe theorem one_eq_1 mentions the semireducible definition one, and the resulting pattern is also one:def one := 1\n\n@[grind? =]\ntheorem one_eq_1 : one = 1 := by rfl\none_eq_1: [one]\nApplying the same annotation to a theorem about the reducible abbreviation two results in a pattern in which two is unfolded:abbrev two := 2\n\n@[grind? =]\ntheorem two_eq_2: two = 2 := by grind\ntwo_eq_2: [@OfNat.ofNat `[Nat] `[2] `[instOfNatNat 2]]\n\n\nRecursive Abbreviations and grindUsing the grind attribute to add E-matching patterns for a recursive abbreviation's equational lemmas does not result in useful patterns for recursive abbreviations.\nThe @[grind?] attribute on this definition of the Fibonacci function results in three patterns, each corresponding to one of the three possibilities:@[grind?]\ndef fib : Nat → Nat\n  | 0 => 0\n  | 1 => 1\n  | n + 2 => fib n + fib (n + 1)\nfib.eq_1: [fib `[0]]\nfib.eq_2: [fib `[1]]\nfib.eq_3: [fib (#0 + 2)]\nReplacing the definition with an abbreviation results in patterns in which occurrences of the function are unfolded.\nThese patterns are not particularly useful:@[grind?]\nabbrev fib : Nat → Nat\n  | 0 => 0\n  | 1 => 1\n  | n + 2 => fib n + fib (n + 1)\nfib.eq_1: [@OfNat.ofNat `[Nat] `[0] `[instOfNatNat 0]]\nfib.eq_2: [@OfNat.ofNat `[Nat] `[1] `[instOfNatNat 1]]\nfib.eq_3: [@HAdd.hAdd `[Nat] `[Nat] `[Nat] `[instHAdd] (fib #0) (fib (#0 + 1))]\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"16.11. Reducibility","id":"/The--grind--tactic/Reducibility/#The-Lean-Language-Reference--The--grind--tactic--Reducibility"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers--Weakest-Precondition-Monad-Morphisms":{"contents":"Most of the built-in specification lemmas for mvcgen relies on the presence of a WPMonad instance, in addition to the WP instance.\nIn addition to being lawful, weakest preconditions of the monad's implementations of pure and bind should correspond to the pure and bind operators for the predicate transformer monad.\nWithout a WPMonad instance, mvcgen typically returns the original proof goal unchanged.\n\nA monad with weakest preconditions (WP) that is also a monad morphism, preserving pure and\nbind.In practice, mvcgen is not useful for reasoning about programs in a monad that is without a\nWPMonad instance. The specification lemmas for Pure.pure and Bind.bind, as well as those for\noperators like Functor.map, require that their monad have a WPMonad instance.WP.wp preserves pure.WP.wp preserves bind.\n\nMissing WPMonad InstanceThis reimplementation of Id has a WP instance, but no WPMonad instance:def Identity (α : Type u) : Type u := α\n\nvariable {α : Type u}\n\ndef Identity.run (act : Identity α) : α := act\n\ninstance : Monad Identity where\n  pure x := x\n  bind x f := f x\n\ninstance : WP Identity .pure where\n  wp x := PredTrans.pure x\n\ntheorem Identity.of_wp_run_eq {x : α} {prog : Identity α}\n    (h : Identity.run prog = x) (P : α → Prop) :\n    (⊢ₛ wp⟦prog⟧ (⇓ a => ⟨P a⟩)) → P x := by\n  intro h'\n  simpa [← h] using h'\nThe missing instance prevents mvcgen from using its specifications for pure and bind.\nThis tends to show up as a verification condition that's equal to the original goal.\nThis function that reverses a list:def rev (xs : List α) : Identity (List α) := do\n  let mut out := []\n  for x in xs do\n    out := x :: out\n  return out\nIt is correct if it is equal to List.reverse.\nHowever, mvcgen does not make the goal easier to prove:theorem rev_correct :\n    (rev xs).run = xs.reverse := by\n  generalize h : (rev xs).run = x\n  apply Identity.of_wp_run_eq h\n  mvcgen [rev]\nunsolved goals\ncase vc1.a\nα✝ : Type u_1\nxs x : List α✝\nh : (rev xs).run = x\nout✝ : List α✝ := []\n⊢ (wp⟦do\n      let r ←\n        forIn xs out✝ fun x r => do\n            pure PUnit.unit\n            pure (ForInStep.yield (x :: r))\n      pure r⟧\n    (PostCond.noThrow fun a => { down := a = xs.reverse })).down\nWhen the verification condition is just the original problem, without even any simplification of bind, the problem is usually a missing WPMonad instance.\nThe issue can be resolved by adding a suitable instance:instance : WPMonad Identity .pure where\n  wp_pure _ := rfl\n  wp_bind _ _ := rfl\nWith this instance, and a suitable invariant, mvcgen and grind can prove the theorem.theorem rev_correct :\n    (rev xs).run = xs.reverse := by\n  generalize h : (rev xs).run = x\n  apply Identity.of_wp_run_eq h\n  simp only [rev]\n  mvcgen invariants\n  · ⇓⟨xs, out⟩ =>\n    ⌜out = xs.prefix.reverse⌝\n  with grind\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Predicate Transformers","header":"17.2.3.2. Weakest Precondition Monad Morphisms","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers--Weakest-Precondition-Monad-Morphisms"},"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices":{"contents":"Type constructors may take two kinds of arguments: parameters  and indices.\nParameters must be used consistently in the entire definition; all occurrences of the type constructor in each constructor in the declaration must take precisely the same argument.\nIndices may vary among the occurrences of the type constructor.\nAll parameters must precede all indices in the type constructor's signature.\n\nParameters that occur prior to the colon (':') in the type constructor's signature are considered parameters to the entire inductive type declaration.\nThey are always parameters that must be uniform throughout the type's definition.\nGenerally speaking, parameters that occur after the colon are indices that may vary throughout the definition of the type.\nHowever, if the option inductive.autoPromoteIndices is true, then syntactic indices that could have been parameters are made into parameters.\nAn index could have been a parameter if all of its type dependencies are themselves parameters and it is used uniformly as an uninstantiated variable in all occurrences of the inductive type's type constructor in all constructors.\n\nPromote indices to parameters in inductive types whenever possible.\n\nIndices can be seen as defining a family of types.\nEach choice of indices selects a type from the family, which has its own set of available constructors.\nType constructors with indices are said to specify indexed families  of types.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","header":"4.4.1.1. Parameters and Indices","id":"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices"}});