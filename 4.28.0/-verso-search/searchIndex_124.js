window.docContents[124].resolve({"/Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers":{"contents":"exists e₁, e₂, ... is shorthand for refine ⟨e₁, e₂, ...⟩; try trivial.\nIt is useful for existential goals.\n\nIntroduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a let or function type.* intro by itself introduces one anonymous hypothesis, which can be accessed\nby e.g. assumption. It is equivalent to intro _.* intro x y introduces two hypotheses and names them. Individual hypotheses\ncan be anonymized via _, given a type ascription, or matched against a pattern:-- ... ⊢ α × β → ...\nintro (a, b)\n-- ..., a : α, b : β ⊢ ...\n* intro rfl is short for intro h; subst h, if h is an equality where the left-hand or right-hand side\nis a variable.* Alternatively, intro can be combined with pattern matching much like fun:intro\n| n + 1, 0 => tac\n| ...\n\n\nintros repeatedly applies intro to introduce zero or more hypotheses\nuntil the goal is no longer a binding expression\n(i.e., a universal quantifier, function type, implication, or have/let),\nwithout performing any definitional reductions (no unfolding, beta, eta, etc.).\nThe introduced hypotheses receive inaccessible (hygienic) names.intros x y z is equivalent to intro x y z and exists only for historical reasons.\nThe intro tactic should be preferred in this case.Properties and relations* intros succeeds even when it introduces no hypotheses.* repeat intro is like intros, but it performs definitional reductions\nto expose binders, and as such it may introduce more hypotheses than intros.* intros is equivalent to intro _ _ … _,\nwith the fewest trailing _ placeholders needed so that the goal is no longer a binding expression.\nThe trailing introductions do not perform any definitional reductions.ExamplesImplications:example (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\nLet-bindings:example : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\nDoes not unfold definitions:def AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n\nThe rintro tactic is a combination of the intros tactic with rcases to\nallow for destructuring patterns while introducing variables. See rcases for\na description of supported patterns. For example, rintro (a | ⟨b, c⟩) ⟨d, e⟩\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables a d e and the other with b c d e.rintro, unlike rcases, also supports the form (x y : ty) for introducing\nand type-ascripting multiple variables at once, similar to binders.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"14.5.3. Quantifiers","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers"}});