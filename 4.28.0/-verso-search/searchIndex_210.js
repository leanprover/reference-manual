window.docContents[210].resolve({"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Size":{"contents":"Returns the number of bytes in the byte array.This is the number of bytes actually in the array, as distinct from its capacity, which is the\namount of memory presently allocated for the array.\n\nRetrieves the size of the array as a platform-specific fixed-width integer.Because USize is big enough to address all memory on every platform that Lean supports,\nthere are in practice no ByteArrays that have more elements that USize can count.\n\nReturns true when s contains zero bytes.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"20.17.1.2. Size","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Size"},"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Consuming-Monadic-Iterators":{"contents":"Iterates over the whole iterator, applying the monadic effects of each step, discarding all\nemitted values.\n\nFolds a function over an iterator from the left, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in order, using f.It is equivalent to it.toList.foldl.\n\nFolds a monadic function over an iterator from the left, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in order, using f.The monadic effects of f are interleaved with potential effects caused by the iterator's step\nfunction. Therefore, it may not be equivalent to (← it.toList).foldlM.\n\nSteps through the whole iterator, counting the number of outputs emitted.Performance:This function's runtime is linear in the number of steps taken by the iterator.\n\nReturns ULift.up true if the pure predicate p returns true for\nany element emitted by the iterator it.O(|it|). Short-circuits upon encountering the first match. The outputs of it are\nexamined in order of iteration.\n\nReturns ULift.up true if the monadic predicate p returns ULift.up true for\nany element emitted by the iterator it.O(|it|). Short-circuits upon encountering the first match. The outputs of it are\nexamined in order of iteration.\n\nReturns ULift.up true if the pure predicate p returns true for\nall elements emitted by the iterator it.O(|it|). Short-circuits upon encountering the first mismatch. The outputs of it are\nexamined in order of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.toListRev always terminates after finitely many steps.\n\nReturns ULift.up true if the monadic predicate p returns ULift.up true for\nall elements emitted by the iterator it.O(|it|). Short-circuits upon encountering the first mismatch. The outputs of it are\nexamined in order of iteration.\n\nReturns the first output of the iterator for which the predicate p returns true, or none if\nno such output is found.O(|it|). Short-circuits upon encountering the first match. The elements in it are examined in\norder of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.find? always terminates after finitely many steps.Examples:* ([7, 6, 5, 8, 1, 2, 6].iterM Id).find? (· < 5) = pure (some 1)* ([7, 6, 5, 8, 1, 2, 6].iterM Id).find? (· < 1) = pure none\n\nReturns the first output of the iterator for which the monadic predicate p returns true, or\nnone if no such element is found.O(|it|). Short-circuits when f returns true. The outputs of it are examined in order of\niteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findM? always terminates after finitely many steps.Example:#eval ([7, 6, 5, 8, 1, 2, 6].iterM IO).findM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 6\nAlmost! 5\nsome 1\n\n\nReturns the first non-none result of applying f to each output of the iterator, in order.\nReturns none if f returns none for all outputs.O(|it|). Short-circuits when f returns some _.The outputs of it are examined in order of\niteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findSome? always terminates after finitely many steps.Examples:* ([7, 6, 5, 8, 1, 2, 6].iterM Id).findSome? (fun x => if x < 5 then some (10 * x) else none) = pure (some 10)* ([7, 6, 5, 8, 1, 2, 6].iterM Id).findSome? (fun x => if x < 1 then some (10 * x) else none) = pure none\n\nReturns the first non-none result of applying the monadic function f to each output\nof the iterator, in order. Returns none if f returns none for all outputs.O(|it|). Short-circuits when f returns some _. The outputs of it are\nexamined in order of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findSomeM? always terminates after finitely many steps.Example:#eval ([7, 6, 5, 8, 1, 2, 6].iterM IO).findSomeM? fun i => do\n  if i < 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\nAlmost! 6\nAlmost! 5\nsome 10\n\n\nReturns the n-th value emitted by it, or none if it terminates earlier.For monadic iterators, the monadic effects of this operation may differ from manually iterating\nto the n-th value because atIdx? can take shortcuts. By the signature, the return value\nis guaranteed to plausible in the sense of IterM.IsPlausibleNthOutputStep.This function is only available for iterators that explicitly support it by implementing\nthe IteratorAccess typeclass.\n\n","context":"Lean Reference\u0009Iterators\u0009Consuming Iterators","header":"22.3.3. Consuming Monadic Iterators","id":"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Consuming-Monadic-Iterators"},"/Source-Files-and-Modules/#module-syntax":{"contents":"Lean's concrete syntax is extensible.\nIn a language like Lean, it's not possible to completely describe the syntax once and for all, because libraries may define syntax in addition to new constants or inductive types.\nRather than completely describing the language here, the overall framework is described, while the syntax of each language construct is documented in the section to which it belongs.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Source Files and Modules","header":"5.2. Concrete Syntax","id":"/Source-Files-and-Modules/#module-syntax"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control":{"contents":"skip does nothing.\n\nTactic to check that a named hypothesis has a given type and/or value.* guard_hyp h : t checks the type up to reducible defeq,* guard_hyp h :~ t checks the type up to default defeq,* guard_hyp h :ₛ t checks the type up to syntactic equality,* guard_hyp h :ₐ t checks the type up to alpha equality.* guard_hyp h := v checks value up to reducible defeq,* guard_hyp h :=~ v checks value up to default defeq,* guard_hyp h :=ₛ v checks value up to syntactic equality,* guard_hyp h :=ₐ v checks the value up to alpha equality.The value v is elaborated using the type of h as the expected type.\n\nTactic to check that the target agrees with a given expression.* guard_target = e checks that the target is defeq at reducible transparency to e.* guard_target =~ e checks that the target is defeq at default transparency to e.* guard_target =ₛ e checks that the target is syntactically equal to e.* guard_target =ₐ e checks that the target is alpha-equivalent to e.The term e is elaborated with the type of the goal as the expected type, which is mostly\nuseful within conv mode.\n\nTactic to check equality of two expressions.* guard_expr e = e' checks that e and e' are defeq at reducible transparency.* guard_expr e =~ e' checks that e and e' are defeq at default transparency.* guard_expr e =ₛ e' checks that e and e' are syntactically equal.* guard_expr e =ₐ e' checks that e and e' are alpha-equivalent.Both e and e' are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using isDefEqGuarded) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n\ndone succeeds iff there are no remaining goals.\n\nThe tactic sleep ms sleeps for ms milliseconds and does nothing.\nIt is used for debugging purposes only.\n\nstop is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as repeat sorry.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"14.5.20. Control Flow","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control"}});