window.docContents[104].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From-Bitvectors":{"contents":"Obtain the BitVec that contains the 2's complement representation of the ISize.\n\nObtains the ISize whose 2's complement representation is the given BitVec.\n\nObtain the BitVec that contains the 2's complement representation of the Int8.\n\nObtains the Int8 whose 2's complement representation is the given BitVec 8.\n\nObtain the BitVec that contains the 2's complement representation of the Int16.\n\nObtains the Int16 whose 2's complement representation is the given BitVec 16.\n\nObtain the BitVec that contains the 2's complement representation of the Int32.\n\nObtains the Int32 whose 2's complement representation is the given BitVec 32.\n\nObtain the BitVec that contains the 2's complement representation of the Int64.\n\nObtains the Int64 whose 2's complement representation is the given BitVec 64.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","header":"20.4.4.3.5. To and From Bitvectors","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From-Bitvectors"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Compiler":{"contents":"* #6928 makes extern decls evaluate as ⊤ rather than the default value\nof ⊥ in the LCNF elimDeadBranches analysis.* #6930 changes the name generation of specialized LCNF decls so they\ndon't strip macro scopes. This avoids name collisions for\nspecializations created in distinct macro scopes. Since the normal\nName.append function checks for the presence of macro scopes, we need to\nuse appendCore.* #6976 extends the behavior of the sync flag for Task.map/bind etc.\nto encompass synchronous execution even when they first have to wait on\ncompletion of the first task, drastically lowering the overhead of such\ntasks. Thus the flag is now equivalent to e.g. .NET's\nTaskContinuationOptions.ExecuteSynchronously.* #7037 relaxes the minimum required glibc version for Lean and Lean\nexecutables to 2.26 on x86-64 Linux* #7041 marks several LCNF-specific environment extensions as having an\nasyncMode of .sync rather than the default of .mainOnly, so they work\ncorrectly even in async contexts.* #7086 makes the arity reduction pass in the new code generator match\nthe old one when it comes to the behavior of decls with no used\nparameters. This is important, because otherwise we might create a\ntop-level decl with no params that contains unreachable code, which\nwould get evaluated unconditionally during initialization. This actually\nhappens when initializing Init.Core built with the new code generator.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Compiler","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Compiler"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Async-Framework":{"contents":"Async framework has been extended with:\n\n* POSIX signal handlers (#9258);* Std.Sync.Notify, an alternative to CondVar suited for concurrency (#10368);* Std.Broadcast, a multi-consumer, multi-producer channel to Std.Sync (#10369);* StreamMap, a type that enables multiplexing in asynchronous streams (#10400);* Std.CancellationToken (#10510).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Async Framework","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Async-Framework"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Remote-Caching-with-Lake":{"contents":"#10188 adds support for remote artifact caches (e.g., Reservoir) to\nLake. As part of this support, a new suite of lake cache CLI commands\nhas been introduced to help manage Lake's cache. Also, the existing\nlocal cache support has been overhauled for better interplay with the\nnew remote support.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Remote Caching with Lake","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Remote-Caching-with-Lake"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Other":{"contents":"* #11727 adds a Python script that helps find which commit introduced a\n  behavior change in Lean. It supports multiple bisection modes and\n  automatically downloads CI artifacts when available.* #11735 adds a standalone script to download pre-built CI artifacts from\n  GitHub Actions. This allows us to quickly switch commits without\n  rebuilding.* #11887 makes the external checker lean4checker available as the\n  existing leanchecker binary already known to elan, allowing for\n  out-of-the-box access to it.* #12121 wraps info trees produced by the lean Verso docstring\n  codeblock in a context info node.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0-rc1 (2026-01-26)","header":"Other","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Other"}});