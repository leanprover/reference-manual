window.docContents[49].resolve({"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Building-and-Running":{"contents":"\n\nBuilds the specified facts of the specified targets.Each of the targets is specified by a string of the form:The optional @ and + markers can be used to disambiguate packages and modules from file paths as well as executables, and libraries, which are specified by name as target.\nIf not provided, package defaults to the workspace's root package.\nIf the same target name exists in multiple packages in the workspace, then the first occurrence of the target name found in a topological sort of the package dependency graph is selected.\nModule targets may also be specified by their filename, with an optional facet after a colon.The available facets depend on whether a package, library, executable, or module is to be built.\nThey are listed in the section on facets.\n\nTarget and Facet Specifications* a* The default facet(s) of target a\n* @a* The default targets of package a\n* +A* The Lean artifacts of module A (because the default facet of modules is leanArts)\n* @a/b* The default facet of target b of package a\n* @a/+A:c* The C file compiled from module A of package a\n* :foo* The root package's facet foo\n* A/B/C.lean:o* The compiled object code for the module in the file A/B/C.lean\n\n\n\nExits with code 0 if the workspace's root package has any default targets configured.\nErrors (with exit code 1) otherwise.check-build does not verify that the configured default targets are valid.\nIt merely verifies that at least one is specified.\n\n\n\n\n\nBuilds a set of targets, reporting progress on standard error and outputting the results on standard out.\nTarget results are output in the same order they are listed and end with a newline.\nIf --json is set, results are formatted as JSON.\nOtherwise, they are printed as raw strings.Targets which do not have output configured will be printed as an empty string or null.\nFor executable targets, the output is the path to the built executable.Targets are specified using the same syntax as in build.\n\nLooks for the executable target exe-target in the workspace, builds it if it is out of date, and then runs\nit with the given args in Lake's environment.See build for the syntax of target specifications and env for a description of how the environment is set up.\n\n\n\nIf no package is specified, deletes the build directories of every package in the workspace.\nOtherwise, it just deletes those of the specified packages.\n\n\n\nWhen cmd is provided, it is executed in the Lake environment with arguments args.If cmd is not provided, Lake prints the environment in which it runs tools.\nThis environment is system-specific.\n\n\n\nBuilds the imports of the given file and then runs lean on it using the workspace's root package's additional Lean arguments and the given args, in that order.\nThe lean process is executed in Lake's environment.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"22.1.2.6. Building and Running","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Building-and-Running"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Development-Tools--Tests-and-Linters":{"contents":"\n\nTest the workspace's root package using its configured test driver.A test driver that is an executable will be built and then run with the package configuration's testDriverArgs plus the CLI args.\nA test driver that is a Lake script is run with the same arguments as an executable test driver.\nA library test driver will just be built; it is expected that tests are implemented such that failures cause the build to fail via elaboration-time errors.\n\n\n\nLint the workspace's root package using its configured lint driverA script lint driver will be run with the  package configuration's\nlintDriverArgs plus the CLI args. An executable lint driver will be\nbuilt and then run like a script.\n\n\n\nCheck if there is a properly configured test driverExits with code 0 if the workspace's root package has a properly\nconfigured lint driver. Errors (with code 1) otherwise.Does NOT verify that the configured test driver actually exists in the\npackage or its dependencies. It merely verifies that one is specified.This is useful for distinguishing between failing tests and incorrectly configured packages.\n\n\n\nCheck if there is a properly configured lint driverExits with code 0 if the workspace's root package has a properly\nconfigured lint driver. Errors (with code 1) otherwise.Does NOT verify that the configured lint driver actually exists in the\npackage or its dependencies. It merely verifies that one is specified.This is useful for distinguishing between failing lints and incorrectly configured packages.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface\u0009Development Tools","header":"22.1.2.7.1. Tests and Linters","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Development-Tools--Tests-and-Linters"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--___Finally___-Computations":{"contents":"Monads that provide the ability to ensure an action happens, regardless of exceptions or other\nfailures.MonadFinally.tryFinally' is used to desugar try ... finally ... syntax.Runs an action, ensuring that some other action always happens afterward.More specifically, tryFinally' x f runs x and then the “finally” computation f. If x\nsucceeds with some value a : α, f (some a) is returned. If x fails for m's definition of\nfailure, f none is returned.tryFinally' can be thought of as performing the same role as a finally block in an imperative\nprogramming language.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Exceptions","header":"14.5.7.3. “Finally” Computations","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--___Finally___-Computations"},"/Namespaces-and-Sections/#section-variables":{"contents":"Section variables are parameters that are automatically added to declarations that mention them.\nThis occurs whether or not the option autoImplicit is true.\nSection variables may be implicit, strict implicit, or explicit; instance implicit section variables are treated specially.\n\nWhen the name of a section variable is encountered in a non-theorem declaration, it is added as a parameter.\nAny instance implicit section variables that mention the variable are also added.\nIf any of the variables that were added depend on other variables, then those variables are added as well; this process is iterated until no more dependencies remain.\nAll section variables are added in the order in which they are declared, before all other parameters.\nSection variables are added only when they occur in the statement of a theorem.\nOtherwise, modifying the proof of a theorem could change its statement if the proof term made use of a section variable.\n\nVariables are declared using the variable command.\n\nVariable Declarations\n\nThe bracketed binders allowed after variable match the syntax used in definition headers.\n\nSection VariablesIn this section, automatic implicit parameters are disabled, but a number of section variables are defined.section\nset_option autoImplicit false\nuniverse u\nvariable {α : Type u} (xs : List α) [Zero α] [Add α]\nBecause automatic implicit parameters are disabled, the following definition fails:def addAll (lst : List β) : β :=\n  lst.foldr (init := 0) (· + ·)\nUnknown identifier `β`\nOn the other hand, not even xs needs to be written directly in the definition:def addAll :=\n  xs.foldr (init := 0) (· + ·)\n\n\nTo add a section variable to a theorem even if it is not explicitly mentioned in the statement, mark the variable with the include command.\nAll variables marked for inclusion are added to all theorems.\nThe omit command removes the inclusion mark from a variable; it's typically a good idea to use it with in.\n\n\n\nIncluded and Omitted Section VariablesThis section's variables include a predicate as well as everything needed to prove that it holds universally, along with a useless extra assumption.section\nvariable {p : Nat → Prop}\nvariable (pZero : p 0) (pStep : ∀ n, p n → p (n + 1))\nvariable (pFifteen : p 15)\nHowever, only p is added to this theorem's assumptions, so it cannot be proved.theorem p_all : ∀ n, p n := by\n  intro n\n  induction n\nThe include command causes the additional assumptions to be added unconditionally:include pZero pStep pFifteen\n\ntheorem p_all : ∀ n, p n := by\n  intro n\n  induction n <;> simp [*]\nBecause the spurious assumption pFifteen was inserted, Lean issues a warning:automatically included section variable(s) unused in theorem `p_all`:\n  pFifteen\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit pFifteen in theorem ...\n\nNote: This linter can be disabled with `set_option linter.unusedSectionVars false`\nThis can be avoided by using omitto remove pFifteen:include pZero pStep pFifteen\n\nomit pFifteen in\ntheorem p_all : ∀ n, p n := by\n  intro n\n  induction n <;> simp [*]\nend\n\n\n\n\n","context":"Lean Reference\u0009Namespaces and Sections\u0009Section Scopes","header":"6.2.2. Section Variables","id":"/Namespaces-and-Sections/#section-variables"},"/The-Type-System/Inductive-Types/#mutual-inductive-types":{"contents":"Inductive types may be mutually recursive.\nMutually recursive definitions of inductive types are specified by defining the types in a mutual ... end block.\n\nMutually Defined Inductive TypesThe type EvenOddList in a prior example used a Boolean index to select whether the list in question should have an even or odd number of elements.\nThis distinction can also be expressed by the choice of one of two mutually inductive types EvenList and OddList:mutual\n  inductive EvenList (α : Type u) : Type u where\n    | nil : EvenList α\n    | cons : α → OddList α → EvenList α\n  inductive OddList (α : Type u) : Type u where\n    | cons : α → EvenList α → OddList α\nend\n\nexample : EvenList String := .cons \"x\" (.cons \"y\" .nil)\nexample : OddList String := .cons \"x\" (.cons \"y\" (.cons \"z\" .nil))\nexample : OddList String := .cons \"x\" (.cons \"y\" .nil)\nUnknown constant `OddList.nil`\n\nNote: Inferred this name from the expected resulting type of `.nil`:\n  OddList String\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.5. Mutual Inductive Types","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types"},"/Type-Classes/Instance-Synthesis/#instance-synth":{"contents":"Instance synthesis is a recursive search procedure that either finds an instance for a given type class or fails.\nIn other words, given a type that is registered as a type class, instance synthesis attempts to construct a term with said type.\nIt respects reducibility: semireducible or irreducible definitions are not unfolded, so instances for a definition are not automatically treated as instances for its unfolding unless it is reducible.\nThere may be multiple possible instances for a given class; in this case, declared priorities and order of declaration are used as tiebreakers, in that order, with more recent instances taking precedence over earlier ones with the same priority.\n\nThis search procedure is efficient in the presence of diamonds and does not loop indefinitely when there are cycles.\nDiamonds occur when there is more than one route to a given goal, and cycles are situations when two instances each could be solved if the other were solved.\nDiamonds occur regularly in practice when encoding mathematical concepts using type classes, and Lean's coercion feature  naturally leads to cycles, e.g. between finite sets and finite multisets.\n\nInstance synthesis can be tested using the #synth command.\nAdditionally, inferInstance and inferInstanceAs can be used to synthesize an instance in a position where the instance itself is needed.\n\ninferInstance synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the [i : α] argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\nα is not a class.) Example:#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n\n\ninferInstanceAs α synthesizes a value of any target type by typeclass\ninference. This is just like inferInstance except that α is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some α' which is definitionally equal to α,\nbut the instance we are looking for is only registered for α (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"11.3. Instance Synthesis","id":"/Type-Classes/Instance-Synthesis/#instance-synth"}});