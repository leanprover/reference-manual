<!DOCTYPE html>
<html>
  <head>
<meta name="robots" content="noindex">
                        <link rel="canonical" href="https://lean-lang.org/doc/reference/4.21.0-rc3/Terms/Pattern-Matching/" />
                        
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Pattern Matching</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "âŽ";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script type="module" src="static/search/search-init.js"></script>
    <script defer="defer" data-domain="lean-lang.org/doc/reference/latest" src="https://plausible.io/js/script.outbound-links.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="current numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-terms" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-terms" checked="checked"></label><span class="number">10.</span>Â <span class=""><a href="Terms/#terms">Terms</a></span></div>
              <table><tr class="numbered"><td class="num">10.1.</td><td><a href="Terms/Identifiers/#identifiers-and-resolution">Identifiers</a></td></tr><tr class="numbered"><td class="num">10.2.</td><td><a href="Terms/Function-Types/#function-types">Function Types</a></td></tr><tr class="numbered"><td class="num">10.3.</td><td><a href="Terms/Functions/#function-terms">Functions</a></td></tr><tr class="numbered"><td class="num">10.4.</td><td><a href="Terms/Function-Application/#function-application">Function Application</a></td></tr><tr class="numbered"><td class="num">10.5.</td><td><a href="Terms/Literals/#The-Lean-Language-Reference--Terms--Literals">Literals</a></td></tr><tr class="numbered"><td class="num">10.6.</td><td><a href="Terms/Structures-and-Constructors/#The-Lean-Language-Reference--Terms--Structures-and-Constructors">Structures and Constructors</a></td></tr><tr class="numbered"><td class="num">10.7.</td><td><a href="Terms/Conditionals/#if-then-else">Conditionals</a></td></tr><tr class="current numbered"><td class="num">10.8.</td><td><a href="Terms/Pattern-Matching/#pattern-matching">Pattern Matching</a></td></tr><tr class="numbered"><td class="num">10.9.</td><td><a href="Terms/Holes/#The-Lean-Language-Reference--Terms--Holes">Holes</a></td></tr><tr class="numbered"><td class="num">10.10.</td><td><a href="Terms/Type-Ascription/#The-Lean-Language-Reference--Terms--Type-Ascription">Type Ascription</a></td></tr><tr class="numbered"><td class="num">10.11.</td><td><a href="Terms/Quotation-and-Antiquotation/#The-Lean-Language-Reference--Terms--Quotation-and-Antiquotation">Quotation and Antiquotation</a></td></tr><tr class="numbered"><td class="num">10.12.</td><td><a href="Terms/do--Notation/#The-Lean-Language-Reference--Terms--do--Notation"><code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">10.13.</td><td><a href="Terms/Proofs/#The-Lean-Language-Reference--Terms--Proofs">Proofs</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-pattern-matching" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-pattern-matching" checked="checked"></label><span class="number">10.8.</span>Â <span class="current"><a href="Terms/Pattern-Matching/#pattern-matching">Pattern Matching</a></span></div>
              <ol>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="syntax"><span class="keyword">match</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">generalizing</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">motive</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">â€¦</span><span class="keyword">)</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">with</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">(</span><span class="meta">â€¦</span><span class="meta">)|*</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">â€¦</span><span class="meta">)*</span></span></a></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___matchDiscr-next"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___inaccessible"><span class="syntax"><span class="keyword">.(</span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___namedPattern"><span class="syntax"><span class="meta">â€¦</span><span class="keyword">@</span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___namedPattern-next"><span class="syntax"><span class="meta">â€¦</span><span class="keyword">@</span><span class="meta">â€¦</span><span class="keyword">:</span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types">Types</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Pattern-Equality-Proofs">Pattern Equality Proofs</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Explicit-Motives">Explicit Motives</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Discriminant-Refinement">Discriminant Refinement</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.4.</span> <a href="Terms/Pattern-Matching/#match-generalization">Generalization</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Terms/Pattern-Matching/#match_pattern-functions">Custom Pattern Functions</a></span></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Attr___simple-next-next-next-next-next"><span class="syntax"><span class="keyword">match_pattern</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Terms/Pattern-Matching/#pattern-fun">Pattern Matching Functions</a></span></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___fun-next-next-next-next-next"><span class="syntax"><span class="keyword">fun</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">â€¦</span><span class="meta">)*</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Other-Pattern-Matching-Operators">Other Pattern Matching Operators</a></span></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean____FLQQ_term_Matches_____FLQQ_"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">matches</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><span class="syntax"><span class="keyword">nomatch</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___nofun"><span class="syntax"><span class="keyword">nofun</span></span></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Terms/Conditionals/#if-then-else" rel="prev" title="10.7. Conditionals"><span class="arrow">â†</span><span class="where">10.7. Conditionals</span></a><a class="local-button active" href="Terms/Holes/#The-Lean-Language-Reference--Terms--Holes" rel="next" title="10.9. Holes"><span class="where">10.9. Holes</span><span class="arrow">â†’</span></a></nav>
          <section>
            <h1>
              10.8.Â Pattern Matching<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=pattern-matching" title="Permalink">ðŸ”—</a></span></h1>
            <p>
              <span id="--tech-term-Pattern-matching" class="def-technical-term"><em>Pattern matching</em></span> is a way to recognize and destructure values using a syntax of <span id="--tech-term-patterns" class="def-technical-term"><em>patterns</em></span> that are a subset of the terms.
A pattern that recognizes and destructures a value is similar to the syntax that would be used to construct the value.
One or more <span id="--tech-term-match-discriminants" class="def-technical-term"><em>match discriminants</em></span> are simultaneously compared to a series of <span id="--tech-term-match-alternatives" class="def-technical-term"><em>match alternatives</em></span>.
Discriminants may be named.
Each alternative contains one or more comma-separated sequences of patterns; all pattern sequences must contain the same number of patterns as there are discriminants.
When a pattern sequence matches all of the discriminants, the term following the corresponding <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">=&gt;</code></a></span> is evaluated in an environment extended with values for each <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-Pattern-variables">pattern variable</a> as well as an equality hypothesis for each named discriminant.
This term is called the <span id="--tech-term-right-hand-side" class="def-technical-term"><em>right-hand side</em></span> of the match alternative.</p>
            <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
              <span class="label">syntax</span><span class="title">Pattern Matching</span><div class="text">
                <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___match"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.match"><code class="hover-info"><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><span class="keyword">match</span>
          <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.generalizingParam"><span class="keyword">(</span><span class="keyword">generalizing</span> <span class="keyword">:=</span> <span class="bnf">(</span><span class="nonterminal" data-kind="Lean.Parser.Term.trueVal">trueVal</span> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.falseVal">falseVal</span><span class="bnf">)</span><span class="keyword">)</span></span></span><span class="bnf">)?</span>
          </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.motive"><span class="keyword">(</span><span class="keyword">motive</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span><span class="keyword">)</span></span></span><span class="bnf">)?</span>
          </span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal documented" data-kind="Lean.Parser.Term.matchDiscr"><code class="hover-info"><code class="docstring">`matchDiscr` matches a "match discriminant", either `h : tm` or `tm`, used in `match` as
`match h1 : e1, e2, h3 : e3 with ...`. </code></code>matchDiscr</span></span><span class="bnf">,*</span>
        </span><span class="keyword">with</span>
      <span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="bnf">,*</span></span></span><span class="bnf">)|*</span> </span><span class="keyword">=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)*</span></span></span></span></pre></div>
              </div>
            <div class="namedocs" id="matchDiscr">
              <span class="label">syntax</span><span class="title">Match Discriminants</span><div class="text">
                <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___matchDiscr"><span class="nonterminal" data-kind="matchDiscr">matchDiscr</span> <span class="bnf">::=</span>
    <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.matchDiscr"><code class="hover-info"><code class="docstring">`matchDiscr` matches a "match discriminant", either `h : tm` or `tm`, used in `match` as
`match h1 : e1, e2, h3 : e3 with ...`. </code></code><span class="from-nonterminal" data-kind="null"></span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___matchDiscr-next"><span class="nonterminal" data-kind="matchDiscr">matchDiscr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.matchDiscr"><code class="hover-info"><code class="docstring">`matchDiscr` matches a "match discriminant", either `h : tm` or `tm`, used in `match` as
`match h1 : e1, e2, h3 : e3 with ...`. </code></code><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
              </div>
            <p>
              Pattern matching expressions may alternatively use <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-Quasiquotation">quasiquotations</a> as patterns, matching the corresponding <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="29">Lean.Syntax</span></a></code> values and treating the contents of <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-antiquotations">antiquotations</a> as ordinary patterns.
Quotation patterns are compiled differently than other patterns, so if one pattern in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> is syntax, then all of them must be.
Quotation patterns are described in <a href="Notations-and-Macros/Macros/#quote-patterns">the section on quotations</a>.</p>
            <p>
              Patterns are a subset of the terms.
They consist of the following:</p>
            <dl><dt> Catch-All Patterns</dt><dd><p>
                  The hole syntax <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">_</span></code> is a pattern that matches any value and binds no pattern variables.
  Catch-all patterns are not entirely equivalent to unused pattern variables.
  They can be used in positions where the pattern's typing would otherwise require a more specific <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-Inaccessible-patterns">inaccessible pattern</a>, while variables cannot be used in these positions.</p>
                </dd><dt> Identifiers</dt><dd><p>
                  If an identifier is not bound in the current scope and is not applied to arguments, then it represents a pattern variable.
  <span id="--tech-term-Pattern-variables" class="def-technical-term"><em>Pattern variables</em></span> match any value, and the values thus matched are bound to the pattern variable in the local environment in which the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-right-hand-side">right-hand side</a> is evaluated.
  If the identifier is bound, it is a pattern if it is bound to the <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-constructors">constructor</a> of an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive type</a> or if its definition has the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1492">match_pattern</span></code> attribute.</p>
                </dd><dt> Applications</dt><dd><p>
                  Function applications are patterns if the function being applied is an identifier that is bound to a constructor or that has the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1492">match_pattern</span></code> attribute and if all arguments are also patterns.
  If the identifier is a constructor, the pattern matches values built with that constructor if the argument patterns match the constructor's arguments.
  If it is a function with the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1492">match_pattern</span></code> attribute, then the function application is unfolded and the resulting term's <a class="technical-term" href="The-Type-System/#--tech-term-normal-form">normal form</a> is used as the pattern.
  Default arguments are inserted as usual, and their normal forms are used as patterns.
  <a class="technical-term" href="Terms/Function-Application/#--tech-term-ellipsis">Ellipses</a>, however, result in all further arguments being treated as universal patterns, even those with associated default values or tactics.</p>
                </dd><dt> Literals</dt><dd><p>
                  <a href="Basic-Types/Characters/#char-syntax">Character literals</a> and <a href="Basic-Types/Strings/#string-syntax">string literals</a> are patterns that match the corresponding character or string.
  <a href="Basic-Types/Strings/#raw-string-literals">Raw string literals</a> are allowed as patterns, but <a href="Basic-Types/Strings/#string-interpolation">interpolated strings</a> are not.
  <a href="Basic-Types/Natural-Numbers/#nat-syntax">Natural number literals</a> in patterns are interpreted by synthesizing the corresponding <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Literals/#OfNat___mk"><span class="const token" data-binding="const-OfNat" data-verso-hover="616">OfNat</span></a></code> instance and reducing the resulting term to <a class="technical-term" href="The-Type-System/#--tech-term-normal-form">normal form</a>, which must be a pattern.
  Similarly, <a class="technical-term" href="Terms/Literals/#--tech-term-scientific-literals">scientific literals</a> are interpreted via the corresponding <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Literals/#OfScientific___mk"><span class="const token" data-binding="const-OfScientific" data-verso-hover="1484">OfScientific</span></a></code> instance.
  While <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Floating-Point-Numbers/#Float-next"><span class="const token" data-binding="const-Float" data-verso-hover="342">Float</span></a></code> has such an instance, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Floating-Point-Numbers/#Float-next"><span class="const token" data-binding="const-Float" data-verso-hover="342">Float</span></a></code>s cannot be used as patterns because the instance relies on an opaque function that can't be reduced to a valid pattern.</p>
                </dd><dt> Structure Instances</dt><dd><p>
                  <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-structure-instance">Structure instances</a> may be used as patterns.
  They are interpreted as the corresponding structure constructor.</p>
                </dd><dt> Quoted names</dt><dd><p>
                  Quoted names, such as <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">`x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">`</span><span class="unknown token" data-binding="">`</span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>, match the corresponding <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1493">Lean.Name</span></code> value.</p>
                </dd><dt> Macros</dt><dd><p>
                  Macros in patterns are expanded.
  They are patterns if the resulting expansions are patterns.</p>
                </dd><dt> Inaccessible patterns</dt><dd><p>
                  <span id="--tech-term-Inaccessible-patterns" class="def-technical-term">Inaccessible patterns</span> are patterns that are forced to have a particular value by later typing constraints.
  Any term may be used as an inaccessible term.
  Inaccessible terms are parenthesized, with a preceding period (<code>.</code>).</p>
                </dd></dl><div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
              <span class="label">syntax</span><span class="title">Inaccessible Patterns</span><div class="text">
                <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___inaccessible"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.inaccessible"><code class="hover-info"><code class="docstring">`.(e)` marks an "inaccessible pattern", which does not influence evaluation of the pattern match, but may be necessary for type-checking.
In contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.
</code></code><span class="keyword">.(</span><span class="nonterminal" data-kind="term.pseudo">term</span><span class="keyword">)</span></span></pre></div>
              </div>
            <details class="example"><summary class="description">Inaccessible Patterns</summary><div class="example-content">
                <p>
                  A number's <em>parity</em> is whether it's even or odd:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-46201" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Parity" data-verso-hover="1494" id="Nat___parity">Parity</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-46233">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Parity.even" data-verso-hover="1495" id="Nat___parity">even</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity" data-verso-hover="1494">Parity</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Parity.odd" data-verso-hover="1496" id="Nat___parity">odd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity" data-verso-hover="1494">Parity</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="7">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-46317">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.parity" data-verso-hover="1497" id="Nat___parity">Nat.parity</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.335" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity" data-verso-hover="1494">Parity</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.335" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-46358" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.335" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-46358" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.even" data-verso-hover="1495">.even</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">n'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-46406" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">n'</span><span class="unknown token" data-binding="">.</span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Nat.parity" data-verso-hover="1497">parity</span></a><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-46406" data-verso-hover="51">with</span></a><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.even" data-verso-hover="1495">.even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.odd" data-verso-hover="1496">.odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.odd" data-verso-hover="1496">.odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-46473">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.840" data-verso-hover="1498">eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
        </span><span class="tactic"><label for="tactic-state-10889739285932860748-46530-46532"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-46530" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10889739285932860748-46530-46532"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.335" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="inter-text">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="inter-text">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="inter-text">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="inter-text">1</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-46533-46538"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-46533" data-verso-hover="386">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-46533-46538"><span class="tactic-state">All goals completed! ðŸ™</span></span><span class="inter-text">
      </span><span class="var token" data-binding="var-_uniq.840" data-verso-hover="1498">eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">â–¸</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.even" data-verso-hover="1495">.even</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.441" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                  Because a value of type <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity" data-verso-hover="1494">Parity</span></a></code> contains half of a number (rounded down) as part of its representation of evenness or oddness, division by two can be implemented (in an unconventional manner) by finding a parity and then extracting the number.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-46830">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-half" data-verso-hover="892">half</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-46860" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Nat.parity" data-verso-hover="1497">parity</span></a><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-46860" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.(</span><span class="var token" data-binding="var-_uniq.64" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text">     </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.even" data-verso-hover="1495">.even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64" data-verso-hover="7">h</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.(</span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="7">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.odd" data-verso-hover="1496">.odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="7">h</span><span class="inter-text">  </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="7">h</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                  Because the index structure of <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.even" data-verso-hover="1495">Parity.even</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#Nat___parity"><span class="const token" data-binding="const-Parity.odd" data-verso-hover="1496">Parity.odd</span></a></code> force the number to have a certain form that is not otherwise a valid pattern, patterns that match on it must use inaccessible patterns for the number being divided.</p>
                </div>
              </details><p>
              Patterns may additionally be named.
<span id="--tech-term-Named-patterns" class="def-technical-term">Named patterns</span> associate a name with a pattern; in subsequent patterns and on the right-hand side of the match alternative, the name refers to the part of the value that was matched by the given pattern.
Named patterns are written with an <code>@</code> between the name and the pattern.
Just like discriminants, named patterns may also be provided with names for equality assumptions.</p>
            <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
              <span class="label">syntax</span><span class="title">Named Patterns</span><div class="text">
                <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___namedPattern"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.namedPattern"><code class="hover-info"><code class="docstring">`x@e` or `x@h:e` matches the pattern `e` and binds its value to the identifier `x`.
If present, the identifier `h` is bound to a proof of `x = e`. </code></code><span class="nonterminal" data-kind="ident">ident</span><span class="keyword">@</span><span class="from-nonterminal" data-kind="null"></span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___namedPattern-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.namedPattern"><code class="hover-info"><code class="docstring">`x@e` or `x@h:e` matches the pattern `e` and binds its value to the identifier `x`.
If present, the identifier `h` is bound to a proof of `x = e`. </code></code><span class="nonterminal" data-kind="ident">ident</span><span class="keyword">@</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="keyword">:</span></span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
              </div>
            <section>
              <h2 id="The-Lean-Language-Reference--Terms--Pattern-Matching--Types">
                10.8.1.Â Types</h2>
              <p>
                Each discriminant must be well typed.
Because patterns are a subset of terms, their types can also be checked.
Each pattern that matches a given discriminant must have the same type as the corresponding discriminant.</p>
              <p>
                The <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-right-hand-side">right-hand side</a> of each match alternative should have the same type as the overall <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> term.
To support dependent types, matching a discriminant against a pattern refines the types that are expected within the scope of the pattern.
In both subsequent patterns in the same match alternative and the right-hand side's type, occurrences of the discriminant are replaced by the pattern that it was matched against.</p>
              <details class="example"><summary class="description">Type Refinement</summary><div class="example-content">
                  <p>
                    This <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-indexed-families">indexed family</a> describes mostly-balanced trees, with the depth encoded in the type.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-51725" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499" id="BalancedTree___rbranch">BalancedTree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-51754" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-51772" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-51779">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree.empty" data-verso-hover="1500" id="BalancedTree___rbranch">empty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree.branch" data-verso-hover="1501" id="BalancedTree___rbranch">branch</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="1502">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="45">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="1502">right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree.lbranch" data-verso-hover="1503" id="BalancedTree___rbranch">lbranch</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.150" data-verso-hover="1504">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.152" data-verso-hover="45">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="1502">right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree.rbranch" data-verso-hover="1505" id="BalancedTree___rbranch">rbranch</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.210" data-verso-hover="1502">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.208" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.212" data-verso-hover="45">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.254" data-verso-hover="1504">right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.208" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.208" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    To begin the implementation of a function to construct a perfectly balanced tree with some initial element and a given depth, a <a class="technical-term" href="Terms/Holes/#--tech-term-hole">hole</a> can be used for the definition.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-52372">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree.filledWith" data-verso-hover="1506">BalancedTree.filledWith</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">depth</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">depth</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
Î± : Type u
x : Î±
depth : Nat
âŠ¢ BalancedTree Î± depth</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    The error message demonstrates that the tree should have the indicated depth.</p>
                  <div class="error">
                    <pre>don't know how to synthesize placeholder
context:
Î± : Type u
x : Î±
depth : Nat
âŠ¢ BalancedTree Î± depth
</pre></div>
                  <p>
                    Matching on the expected depth and inserting holes results in an error message for each hole.
These messages demonstrate that the expected type has been refined, with <code>depth</code> replaced by the matched values.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-52913">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree.filledWith" data-verso-hover="1506">BalancedTree.filledWith</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">depth</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">depth</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-52993" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">depth</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-52993" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
Î± : Type u
x : Î±
depth : Nat
âŠ¢ BalancedTree Î± 0</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
Î± : Type u
x : Î±
depth n : Nat
âŠ¢ BalancedTree Î± (n + 1)</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    The first hole yields the following message:</p>
                  <div class="error">
                    <pre>don't know how to synthesize placeholder
context:
Î± : Type u
x : Î±
depth : Nat
âŠ¢ BalancedTree Î± 0
</pre></div>
                  <p>
                    The second hole yields the following message:</p>
                  <div class="error">
                    <pre>don't know how to synthesize placeholder
context:
Î± : Type u
x : Î±
depth n : Nat
âŠ¢ BalancedTree Î± (n + 1)
</pre></div>
                  <p>
                    Matching on the depth of a tree and the tree itself leads to a refinement of the tree's type according to the depth's pattern.
This means that certain combinations are not well-typed, such as <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree.branch" data-verso-hover="1501">branch</span></a></code>, because refining the second discriminant's type yields <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39072" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span></code> which does not match the constructor's type.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-53805">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-BalancedTree.isPerfectlyBalanced" data-verso-hover="1507" id="BalancedTree___isPerfectlyBalanced">BalancedTree.isPerfectlyBalanced</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1502">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree" data-verso-hover="1499">BalancedTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-53892" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1502">t</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-53892" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree.empty" data-verso-hover="1500">.empty</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type mismatch
  left.branch val right
has type
  BalancedTree ?m.54 (?m.51 + 1) : Type ?u.47
but is expected to have type
  BalancedTree Î± 0 : Type u</code></span></span><a href="Terms/Pattern-Matching/#BalancedTree___rbranch"><span class="const token" data-binding="const-BalancedTree.branch" data-verso-hover="1501">.branch</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">right</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">isPerfectlyBalanced</span><span class="inter-text"> </span><span class="unknown token" data-binding="">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&&</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">isPerfectlyBalanced</span><span class="inter-text"> </span><span class="unknown token" data-binding="">right</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>type mismatch
  left.branch val right
has type
  BalancedTree ?m.54 (?m.51 + 1) : Type ?u.47
but is expected to have type
  BalancedTree Î± 0 : Type u
</pre></div>
                  </div>
                </details><section>
                <h3 id="The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Pattern-Equality-Proofs">
                  10.8.1.1.Â Pattern Equality Proofs</h3>
                <p>
                  When a discriminant is named, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> generates a proof that the pattern and discriminant are equal, binding it to the provided name in the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-right-hand-side">right-hand side</a>.
This is useful to bridge the gap between dependent pattern matching on indexed families and APIs that expect explicit propositional arguments, and it can help tactics that make use of assumptions to succeed.</p>
                <details class="example"><summary class="description">Pattern Equality Proofs</summary><div class="example-content">
                    <p>
                      The function <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#last___"><span class="const token" data-binding="const-last?" data-verso-hover="1508">last?</span></a></code>, which either throws an exception or returns the last element of its argument, uses the standard library function <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___getLast"><span class="const token" data-binding="const-List.getLast" data-verso-hover="1509">List.getLast</span></a></code>.
This function expects a proof that the list in question is nonempty.
Naming the match on <code>xs</code> ensures that there's an assumption in scope that states that <code>xs</code> is equal to <code>_ :: _</code>, which <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="" data-verso-hover="665">simp_all</span></a></code> uses to discharge the goal.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-55115">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-last?" data-verso-hover="1508" id="last___">last?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="43">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except" data-verso-hover="1335">Except</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="43">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-55164" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1510">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-55164" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except.error" data-verso-hover="1511">.error</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="1512">"Can't take first element of empty list"</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except.ok" data-verso-hover="1513">.ok</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___getLast"><span class="const token" data-binding="const-List.getLast" data-verso-hover="1509">getLast</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-55281">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">â‰ </span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-55296-55298"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic'-55296">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-55296-55298"><span class="tactic-state">All goals completed! ðŸ™</span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-1458013944079840301-55299-55307"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-55299" data-verso-hover="661">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.151" data-verso-hover="1510">h'</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1458013944079840301-55299-55307"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="49">Type ?u.7</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.52" data-verso-hover="45">headâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.53" data-verso-hover="50">tailâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1515">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.52" data-verso-hover="45">headâœ</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="405"> :: </span></a><span class="var token" data-binding="var-_uniq.53" data-verso-hover="50">tailâœ</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.151" data-verso-hover="1510">h'</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-55309-55317"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-55309" data-verso-hover="665">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-55309-55317"><span class="tactic-state">All goals completed! ðŸ™</span></span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Without the name, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="" data-verso-hover="665">simp_all</span></a></code> is unable to find the contradiction.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-55441">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-last?'" data-verso-hover="1516" id="last______">last?'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="43">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except" data-verso-hover="1335">Except</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="43">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-55491" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-55491" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except.error" data-verso-hover="1511">.error</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="1512">"Can't take first element of empty list"</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Except___error"><span class="const token" data-binding="const-Except.ok" data-verso-hover="1513">.ok</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___getLast"><span class="const token" data-binding="const-List.getLast" data-verso-hover="1509">getLast</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-55604">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">â‰ </span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-9620738031235837755-55619-55621"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic'-55619">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9620738031235837755-55619-55621"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="49">Type ?u.7</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.51" data-verso-hover="45">headâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.52" data-verso-hover="50">tailâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.135" data-verso-hover="1510">h'</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-9620738031235837755-55622-55630"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-55622" data-verso-hover="661">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.135" data-verso-hover="1510">h'</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9620738031235837755-55622-55630"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="49">Type ?u.7</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.51" data-verso-hover="45">headâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.52" data-verso-hover="50">tailâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.135" data-verso-hover="1510">h'</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">simp_all made no progress</code></span></span><span class="tactic"><label for="tactic-state-9620738031235837755-55632-55640"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-55632" data-verso-hover="665">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9620738031235837755-55632-55640"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="49">Type ?u.7</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.51" data-verso-hover="45">headâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.52" data-verso-hover="50">tailâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1514">Î±</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.135" data-verso-hover="1510">h'</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="50">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="404">]</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span></span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>simp_all made no progress
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Explicit-Motives">
                  10.8.1.2.Â Explicit Motives</h3>
                <p>
                  Pattern matching is not a built-in primitive of Lean.
Instead, it is translated to applications of <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-recursor">recursors</a> via <a class="technical-term" href="Elaboration-and-Compilation/#--tech-term-auxiliary-matching-functions">auxiliary matching functions</a>.
Both require a <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-motive"><em>motive</em></a> that explains the relationship between the discriminant and the resulting type.
Generally, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> elaborator is capable of synthesizing an appropriate motive, and the refinement of types that occurs during pattern matching is a result of the motive that was selected.
In some specialized circumstances, a different motive may be needed and may be provided explicitly using the <code>(motive := â€¦)</code> syntax of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span>.
This motive should be a function type that expects at least as many parameters as there are discriminants.
The type that results from applying a function with this type to the discriminants in order is the type of the entire <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> term, and the type that results from applying a function with this type to all patterns in each alternative is the type of that alternative's <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-right-hand-side">right-hand side</a>.</p>
                <details class="example"><summary class="description">Matching with an Explicit Motive</summary><div class="example-content">
                    <p>
                      An explicit motive can be used to provide type information that is otherwise unavailable from the surrounding context.
Attempting to match on a number and a proof that it is in fact <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">5</span></code> is an error, because there's no reason to connect the number to the proof:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-57193" data-verso-hover="6">#eval</span></a><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-57201" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-57201" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Invalid match expression: This pattern contains metavariables:
  Eq.refl ?m.76</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="1517">"ok"</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>Invalid match expression: This pattern contains metavariables:
  Eq.refl ?m.76
</pre></div>
                    <p>
                      An explicit motive explains the relationship between the discriminants:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"ok"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-57449" data-verso-hover="6">#eval</span></a></span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-57457" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.motive-57463">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-57457" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="1517">"ok"</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>"ok"
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Discriminant-Refinement">
                  10.8.1.3.Â Discriminant Refinement</h3>
                <p>
                  When matching on an indexed family, the indices must also be discriminants.
Otherwise, the pattern would not be well typed: it is a type error if an index is just a variable but the type of a constructor requires a more specific value.
However, a process called <span id="--tech-term-discriminant-refinement" class="def-technical-term">discriminant refinement</span> automatically adds indices as additional discriminants.</p>
                <details class="example"><summary class="description">Discriminant Refinement</summary><div class="example-content">
                    <p>
                      In the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-f" data-verso-hover="1518">f</span></code>, the equality proof is the only discriminant.
However, equality is an indexed family, and the match is only valid when <code>n</code> is an additional discriminant.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-58205">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-f" data-verso-hover="1518">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="1519">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-58247" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="1519">p</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-58247" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="1517">"ok"</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.print : command</code></code><code class="kw">#print</code></span> demonstrates that the additional discriminant was added automatically.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def f : (n : Nat) â†’ n = 3 â†’ String :=
fun n p =&gt;
  match 3, p with
  | .(n), â‹¯ =&gt; "ok"</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-58426">#print</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-f" data-verso-hover="1518">f</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>def f : (n : Nat) â†’ n = 3 â†’ String :=
fun n p =&gt;
  match 3, p with
  | .(n), â‹¯ =&gt; "ok"
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="match-generalization">
                  10.8.1.4.Â Generalization<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=match-generalization" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  The pattern match elaborator automatically determines the motive by finding occurrences of the discriminants in the expected type, generalizing them in the types of subsequent discriminants so that the appropriate pattern can be substituted.
Additionally, occurrences of the discriminants in the types of variables in the context are generalized and substituted by default.
This latter behavior can be turned off by passing the <code>(generalizing := false)</code> flag to <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span>.</p>
                <details class="example"><summary class="description">Matching, With and Without Generalization</summary><div class="example-content">
                    <p>
                      In this definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-boolCases" data-verso-hover="1520">boolCases</span></code>, the assumption <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.43424" data-verso-hover="154">b</span></code> is generalized in the type of <code>h</code> and then replaced with the actual pattern.
This means that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.43446" data-verso-hover="1521">ifTrue</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.43469" data-verso-hover="1522">ifFalse</span></code> have the types <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.43472" data-verso-hover="54">Î±</span></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.43493" data-verso-hover="54">Î±</span></code> in their respective cases, but <code>h</code>'s type mentions the original discriminant.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-59725">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-boolCases" data-verso-hover="1520">boolCases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1521">ifTrue</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1522">ifFalse</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-59828" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.72" data-verso-hover="1523">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-59828" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">  </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1524">ifTrue</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Application type mismatch: In the application
  ifTrue h
the argument
  h
has type
  b = true : Prop
but is expected to have type
  true = true : Prop</code></span></span><span class="var token" data-binding="var-_uniq.72" data-verso-hover="1523">h</span></span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1525">ifFalse</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Application type mismatch: In the application
  ifFalse h
the argument
  h
has type
  b = false : Prop
but is expected to have type
  false = false : Prop</code></span></span><span class="var token" data-binding="var-_uniq.72" data-verso-hover="1526">h</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The error for the first case is typical of both:</p>
                    <div class="error">
                      <pre>Application type mismatch: In the application
  ifTrue h
the argument
  h
has type
  b = true : Prop
but is expected to have type
  true = true : Prop
</pre></div>
                    <p>
                      Turning off generalization allows type checking to succeed, because <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.43516" data-verso-hover="154">b</span></code> remains in the types of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.43538" data-verso-hover="1521">ifTrue</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.43561" data-verso-hover="1522">ifFalse</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-60269">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-boolCases" data-verso-hover="1520">boolCases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1521">ifTrue</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1522">ifFalse</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="54">Î±</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-60372" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.generalizingParam-60378">generalizing</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.falseVal-60395">false</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="1523">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="154">b</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-60372" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">  </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1521">ifTrue</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="1523">h</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1522">ifFalse</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="1526">h</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      In the generalized version, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a></code> could have been used as the proof arguments as an alternative.</p>
                    </div>
                  </details></section>
              </section>
            <section>
              <h2 id="match_pattern-functions">
                10.8.2.Â Custom Pattern Functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=match_pattern-functions" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                In patterns, defined constants with the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1492">match_pattern</span></code> attribute are unfolded and normalized rather than rejected.
This allows a more convenient syntax to be used for many patterns.
In the standard library, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1371">Nat.add</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">HAdd.hAdd</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Add___mk"><span class="const token" data-binding="const-Add.add" data-verso-hover="1527">Add.add</span></a></code>, and <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Neg___mk"><span class="const token" data-binding="const-Neg.neg" data-verso-hover="630">Neg.neg</span></a></code> all have this attribute, which allows patterns like <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.44418" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span></code> instead of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44487" data-verso-hover="7">n</span></code>.
Similarly, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#Unit___unit"><span class="const token" data-binding="const-Unit.unit" data-verso-hover="1394">Unit.unit</span></a></code> are definitions that set the respective <a class="technical-term" href="The-Type-System/Universes/#--tech-term-universe-parameters">universe parameters</a> of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="960">PUnit.unit</span></a></code> to 0; the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1492">match_pattern</span></code> attribute on <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#Unit___unit"><span class="const token" data-binding="const-Unit.unit" data-verso-hover="1394">Unit.unit</span></a></code> allows it to be used in patterns, where it expands to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="960">PUnit.unit</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">}</span></code>.</p>
              <div class="namedocs" id="attr-next-next-next-next">
                <span class="label">attribute</span><span class="title">Attribute for Match Patterns</span><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1492">match_pattern</span></code> attribute indicates that a definition should be unfolded, rather than rejected, in a pattern.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">match_pattern</span><span class="from-nonterminal" data-kind="null"></span></pre></div>
                </div>
              <details class="example"><summary class="description">Match Patterns Follow Reduction</summary><div class="example-content">
                  <p>
                    The following function can't be compiled:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-61789">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-nonzero" data-verso-hover="1528" id="nonzero">nonzero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-61823" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-61823" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Invalid pattern(s): `k` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching:
  .(Nat.add 1 k)</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">true</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    The error message on the pattern <code>1 + _</code> is:</p>
                  <div class="error">
                    <pre>Invalid pattern(s): `k` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching:
  .(Nat.add 1 k)
</pre></div>
                  <p>
                    This is because <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1371">Nat.add</span></a></code> is defined by recursion on its second parameter, equivalently to:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-62199">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-add" data-verso-hover="1529">add</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">a</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="929">Nat.zero</span></a><span class="inter-text">   </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">a</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.49" data-verso-hover="7">a</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1371">Nat.add</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.49" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    No <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-___-reduction">Î¹-reduction</a> is possible, because the value being matched is a variable, not a constructor.
<code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45668" data-verso-hover="7">k</span></code> gets stuck as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1371">Nat.add</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45739" data-verso-hover="7">k</span></code>, which is not a valid pattern.</p>
                  <p>
                    In the case of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.45754" data-verso-hover="7">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span></code>, that is, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1371">Nat.add</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45798" data-verso-hover="7">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="929">.zero</span></a><span class="unknown token" data-binding="">)</span></code>, the second pattern matches, so it reduces to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___add"><span class="const token" data-binding="const-Nat.add" data-verso-hover="1371">Nat.add</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45802" data-verso-hover="7">k</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="929">.zero</span></a><span class="unknown token" data-binding="">)</span></code>.
The second pattern now matches, yielding <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45806" data-verso-hover="7">k</span></code>, which is a valid pattern.</p>
                  </div>
                </details></section>
            <section>
              <h2 id="pattern-fun">
                10.8.3.Â Pattern Matching Functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=pattern-fun" title="Permalink">ðŸ”—</a></span></h2>
              <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">Pattern-Matching Functions</span><div class="text">
                  <p>
                    Functions may be specified via pattern matching by writing a sequence of patterns after <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.fun : term</code></code><code class="kw">fun</code></span>, each preceded by a vertical bar (<code>|</code>).</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___fun-next-next-next-next-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.fun"><span class="keyword">fun</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="bnf">,*</span> </span></span><span class="keyword">=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)*</span></span></span></span></pre><p>
                    This desugars to a function that immediately pattern-matches on its arguments.</p>
                  </div>
                </div>
              <details class="example"><summary class="description">Pattern-Matching Functions</summary><div class="example-content">
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#isZero___"><span class="const token" data-binding="const-isZero" data-verso-hover="1530">isZero</span></a></code> is defined using a pattern-matching function abstraction, while <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Pattern-Matching/#isZero___"><span class="const token" data-binding="const-isZero'" data-verso-hover="1531">isZero'</span></a></code> is defined using a pattern match expression:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-63412">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-isZero" data-verso-hover="1530" id="isZero___">isZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-63443">fun</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-63481">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-isZero'" data-verso-hover="1531" id="isZero___">isZero'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-63513">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-63526" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-63526" data-verso-hover="51">with</span></a><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    Because the former is syntactic sugar for the latter, they are definitionally equal:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-63669">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#isZero___"><span class="const token" data-binding="const-isZero" data-verso-hover="1530">isZero</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#isZero___"><span class="const token" data-binding="const-isZero'" data-verso-hover="1531">isZero'</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#rfl-next"><span class="const token" data-binding="const-rfl" data-verso-hover="156">rfl</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    The desugaring is visible in the output of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.print : command</code></code><code class="kw">#print</code></span>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def isZero : Nat â†’ Bool :=
fun x =&gt;
  match x with
  | 0 =&gt; true
  | x =&gt; false</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-63822">#print</span></span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#isZero___"><span class="const token" data-binding="const-isZero" data-verso-hover="1530">isZero</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    outputs</p>
                  <div class="information">
                    <pre>def isZero : Nat â†’ Bool :=
fun x =&gt;
  match x with
  | 0 =&gt; true
  | x =&gt; false
</pre></div>
                  <p>
                    while</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def isZero' : Nat â†’ Bool :=
fun n =&gt;
  match n with
  | 0 =&gt; true
  | x =&gt; false</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-63987">#print</span></span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#isZero___"><span class="const token" data-binding="const-isZero'" data-verso-hover="1531">isZero'</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    outputs</p>
                  <div class="information">
                    <pre>def isZero' : Nat â†’ Bool :=
fun n =&gt;
  match n with
  | 0 =&gt; true
  | x =&gt; false
</pre></div>
                  </div>
                </details></section>
            <section>
              <h2 id="The-Lean-Language-Reference--Terms--Pattern-Matching--Other-Pattern-Matching-Operators">
                10.8.4.Â Other Pattern Matching Operators</h2>
              <p>
                In addition to <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> and <span class="hl lean keyword-of"><code class="hover-info"><code>termIfLet : term</code><span class="sep"></span><code class="docstring">`if let pat := d then t else e` is a shorthand syntax for:
```
match d with
| pat =&gt; t
| _ =&gt; e
```
It matches `d` against the pattern `pat` and the bindings are available in `t`.
If the pattern does not match, it returns `e` instead.
</code></code><a href="Terms/Conditionals/#termIfLet"><code class="kw">if let</code></a></span>, there are a few other operators that perform pattern matching.</p>
              <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">The <code class="plain-keyword">matches</code> Operator</span><div class="text">
                  <p>
                    The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Â«term_Matches_|Â» : term</code></code><a href="Terms/Pattern-Matching/#Lean____FLQQ_term_Matches_____FLQQ_"><code class="kw">matches</code></a></span> operator returns <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the term on the left matches the pattern on the right.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean____FLQQ_term_Matches_____FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Â«term_Matches_|Â»"><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">matches</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span></span></span></pre></div>
                </div>
              <p>
                When branching on the result of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Â«term_Matches_|Â» : term</code></code><a href="Terms/Pattern-Matching/#Lean____FLQQ_term_Matches_____FLQQ_"><code class="kw">matches</code></a></span>, it's usually better to use <span class="hl lean keyword-of"><code class="hover-info"><code>termIfLet : term</code><span class="sep"></span><code class="docstring">`if let pat := d then t else e` is a shorthand syntax for:
```
match d with
| pat =&gt; t
| _ =&gt; e
```
It matches `d` against the pattern `pat` and the bindings are available in `t`.
If the pattern does not match, it returns `e` instead.
</code></code><a href="Terms/Conditionals/#termIfLet"><code class="kw">if let</code></a></span>, which can bind pattern variables in addition to checking whether a pattern matches.</p>
              <p>
                If there are no constructor patterns that could match a discriminant or sequence of discriminants, then the code in question is unreachable, as there must be a false assumption in the local context.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.nomatch : term</code><span class="sep"></span><code class="docstring">Empty match/ex falso. `nomatch e` is of arbitrary type `Î± : Sort u` if
Lean can show that an empty set of patterns is exhaustive given `e`'s type,
e.g. because it has no constructors.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><code class="kw">nomatch</code></a></span> expression is a match with zero cases that can have any type whatsoever, so long as there are no possible cases that could match the discriminants.</p>
              <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">Caseless Pattern Matches</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___nomatch"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.nomatch"><code class="hover-info"><code class="docstring">Empty match/ex falso. `nomatch e` is of arbitrary type `Î± : Sort u` if
Lean can show that an empty set of patterns is exhaustive given `e`'s type,
e.g. because it has no constructors.
</code></code><span class="keyword">nomatch</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="bnf">,*</span></span></span></pre></div>
                </div>
              <details class="example"><summary class="description">Inconsistent Indices</summary><div class="example-content">
                  <p>
                    There are no constructor patterns that can match both proofs in this example:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-65526">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1532">p1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="312">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="148">"Hello"</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1533">p2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="312">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="1534">"world"</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.nomatch-65585" data-verso-hover="1535">nomatch</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1532">p1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1533">p2</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    This is because they separately refine the value of <code>x</code> to unequal strings.
Thus, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.nomatch : term</code><span class="sep"></span><code class="docstring">Empty match/ex falso. `nomatch e` is of arbitrary type `Î± : Sort u` if
Lean can show that an empty set of patterns is exhaustive given `e`'s type,
e.g. because it has no constructors.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><code class="kw">nomatch</code></a></span> operator allows the example's body to prove <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> (or any other proposition or type).</p>
                  </div>
                </details><p>
                When the expected type is a function type, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.nofun : term</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nofun"><code class="kw">nofun</code></a></span> is shorthand for a function that takes as many parameters as the type indicates in which the body is <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.nomatch : term</code><span class="sep"></span><code class="docstring">Empty match/ex falso. `nomatch e` is of arbitrary type `Î± : Sort u` if
Lean can show that an empty set of patterns is exhaustive given `e`'s type,
e.g. because it has no constructors.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><code class="kw">nomatch</code></a></span> applied to all of the parameters.</p>
              <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">Caseless Functions</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___nofun"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.nofun"><span class="keyword">nofun</span></span></pre></div>
                </div>
              <details class="example"><summary class="description">Impossible Functions</summary><div class="example-content">
                  <p>
                    Instead of introducing arguments for both equality proofs and then using both in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.nomatch : term</code><span class="sep"></span><code class="docstring">Empty match/ex falso. `nomatch e` is of arbitrary type `Î± : Sort u` if
Lean can show that an empty set of patterns is exhaustive given `e`'s type,
e.g. because it has no constructors.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch"><code class="kw">nomatch</code></a></span>, it is possible to use <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.nofun : term</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nofun"><code class="kw">nofun</code></a></span>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-66429">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="312">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="148">"Hello"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="312">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="1534">"world"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">â†’</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nofun"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.nofun-66480">nofun</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </details></section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Terms/Conditionals/#if-then-else" rel="prev" title="10.7. Conditionals"><span class="arrow">â†</span><span class="where">10.7. Conditionals</span></a><a class="local-button active" href="Terms/Holes/#The-Lean-Language-Reference--Terms--Holes" rel="next" title="10.9. Holes"><span class="where">10.9. Holes</span><span class="arrow">â†’</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

