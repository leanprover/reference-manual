window.docContents[108].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Sequence-Operations--Bit-Extraction":{"contents":"Returns the most significant bit in a bitvector.\n\nReturns the ith most significant bit, or false if i ≥ w.\n\nReturns the ith most significant bit.\n\nReturns the ith most significant bit or none if i ≥ w.\n\nReturns the ith least significant bit or false if i ≥ w.\n\nReturns the ith least significant bit.\n\nReturns the ith least significant bit, or none if i ≥ w.\n\nExtracts the bits from hi down to lo (both inclusive) from a bitvector, which is implicitly\nzero-extended if necessary.The resulting bitvector has size hi - lo + 1.SMT-LIB name: extract.\n\nExtracts the bits start to start + len - 1 from a bitvector of size n to yield a\nnew bitvector of size len. If start + len > n, then the bitvector is zero-extended.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference\u0009Sequence Operations","header":"20.5.5.6.1. Bit Extraction","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Sequence-Operations--Bit-Extraction"},"/Iterators/Iterator-Combinators/#The-Lean-Language-Reference--Iterators--Iterator-Combinators--Monadic-Combinators":{"contents":"Converts a monadic iterator (IterM Id β) over Id into a pure iterator (Iter β).\n\nGiven an iterator it and a natural number n, it.take n is an iterator that outputs\nup to the first n of it's values in order and then terminates.Marble diagram:it          ---a----b---c--d-e--⊥\nit.take 3   ---a----b---c⊥\n\nit          ---a--⊥\nit.take 3   ---a--⊥\nTermination properties:* Finite instance: only if it is productive* Productive instance: only if it is productivePerformance:This combinator incurs an additional O(1) cost with each output of it.\n\nGiven an iterator it and a predicate P, it.takeWhile P is an iterator that outputs\nthe values emitted by it until one of those values is rejected by P.\nIf some emitted value is rejected by P, the value is dropped and the iterator terminates.In situations where P is monadic, use takeWhileM instead.Marble diagram (ignoring monadic effects):Assuming that the predicate P accepts a and b but rejects c:it               ---a----b---c--d-e--⊥\nit.takeWhile P   ---a----b---⊥\n\nit               ---a----⊥\nit.takeWhile P   ---a----⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveDepending on P, it is possible that it.takeWhile P is finite (or productive) although it is not.\nIn this case, the Finite (or Productive) instance needs to be proved manually.Performance:This combinator calls P on each output of it until the predicate evaluates to false. Then\nit terminates.\n\nGiven an iterator it and a monadic predicate P, it.takeWhileM P is an iterator that outputs\nthe values emitted by it until one of those values is rejected by P.\nIf some emitted value is rejected by P, the value is dropped and the iterator terminates.If P is pure, then the simpler variant takeWhile can be used instead.Marble diagram (ignoring monadic effects):Assuming that the predicate P accepts a and b but rejects c:it                ---a----b---c--d-e--⊥\nit.takeWhileM P   ---a----b---⊥\n\nit                ---a----⊥\nit.takeWhileM P   ---a----⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveDepending on P, it is possible that it.takeWhileM P is finite (or productive) although it is not.\nIn this case, the Finite (or Productive) instance needs to be proved manually.Performance:This combinator calls P on each output of it until the predicate evaluates to false. Then\nit terminates.\n\nNote: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants takeWhile and takeWhileM are easier to use\nand sufficient for most use cases.Given an iterator it and a monadic predicate P, it.takeWhileWithPostcondition P is an iterator\nthat emits the values emitted by it until one of those values is rejected by P.\nIf some emitted value is rejected by P, the value is dropped and the iterator terminates.P is expected to return PostconditionT m (ULift Bool). The PostconditionT transformer allows\nthe caller to intrinsically prove properties about P's return value in the monad m, enabling\ntermination proofs depending on the specific behavior of P.Marble diagram (ignoring monadic effects):Assuming that the predicate P accepts a and b but rejects c:it                                ---a----b---c--d-e--⊥\nit.takeWhileWithPostcondition P   ---a----b---⊥\n\nit                                ---a----⊥\nit.takeWhileWithPostcondition P   ---a----⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveDepending on P, it is possible that it.takeWhileWithPostcondition P is finite (or productive)\nalthough it is not. In this case, the Finite (or Productive) instance needs to be proved\nmanually.Performance:This combinator calls P on each output of it until the predicate evaluates to false. Then\nit terminates.\n\nThis combinator is only useful for advanced use cases.Given a finite iterator it, returns an iterator that behaves exactly like it but is of the same\ntype as it.take n.Marble diagram:it          ---a----b---c--d-e--⊥\nit.toTake   ---a----b---c--d-e--⊥\nTermination properties:* Finite instance: always* Productive instance: alwaysPerformance:This combinator incurs an additional O(1) cost with each output of it.\n\nGiven an iterator it and a natural number n, it.drop n is an iterator that forwards all of\nit's output values except for the first n.Marble diagram:it          ---a----b---c--d-e--⊥\nit.drop 3   ---------------d-e--⊥\n\nit          ---a--⊥\nit.drop 3   ------⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is productivePerformance:Currently, this combinator incurs an additional O(1) cost with each output of it, even when the iterator\ndoes not drop any elements anymore.\n\nGiven an iterator it and a predicate P, it.dropWhile P is an iterator that\nemits the values emitted by it starting from the first value that is rejected by P.\nThe elements before are dropped.In situations where P is monadic, use dropWhileM instead.Marble diagram (ignoring monadic effects):Assuming that the predicate P accepts a and b but rejects c:it               ---a----b---c--d-e--⊥\nit.dropWhile P   ------------c--d-e--⊥\n\nit               ---a----⊥\nit.dropWhile P   --------⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is finiteDepending on P, it is possible that it.dropWhileM P is productive although\nit is not. In this case, the Productive instance needs to be proved manually.Performance:This combinator calls P on each output of it until the predicate evaluates to false. After\nthat, the combinator incurs an addictional O(1) cost for each value emitted by it.\n\nGiven an iterator it and a monadic predicate P, it.dropWhileM P is an iterator that\nemits the values emitted by it starting from the first value that is rejected by P.\nThe elements before are dropped.If P is pure, then the simpler variant dropWhile can be used instead.Marble diagram (ignoring monadic effects):Assuming that the predicate P accepts a and b but rejects c:it                ---a----b---c--d-e--⊥\nit.dropWhileM P   ------------c--d-e--⊥\n\nit                ---a----⊥\nit.dropWhileM P   --------⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is finiteDepending on P, it is possible that it.dropWhileM P is finite (or productive) although\nit is not. In this case, the Finite (or Productive) instance needs to be proved manually.\nUse dropWhileWithPostcondition if the termination behavior depends on P's behavior.Performance:This combinator calls P on each output of it until the predicate evaluates to false. After\nthat, the combinator incurs an addictional O(1) cost for each value emitted by it.\n\nNote: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants dropWhile and dropWhileM are easier to use\nand sufficient for most use cases.Given an iterator it and a monadic predicate P, it.dropWhileWithPostcondition P is an iterator\nthat emits the values emitted by it starting from the first value that is rejected by P.\nThe elements before are dropped.P is expected to return PostconditionT m (ULift Bool). The PostconditionT transformer allows\nthe caller to intrinsically prove properties about P's return value in the monad m, enabling\ntermination proofs depending on the specific behavior of P.Marble diagram (ignoring monadic effects):Assuming that the predicate P accepts a and b but rejects c:it                                ---a----b---c--d-e--⊥\nit.dropWhileWithPostcondition P   ------------c--d-e--⊥\n\nit                                ---a----⊥\nit.dropWhileWithPostcondition P   --------⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is finiteDepending on P, it is possible that it.dropWhileWithPostcondition P is finite (or productive) although\nit is not. In this case, the Finite (or Productive) instance needs to be proved manually.Performance:This combinator calls P on each output of it until the predicate evaluates to false. After\nthat, the combinator incurs an additional O(1) cost for each value emitted by it.\n\nProduces an iterator that emits one value of it, then drops n - 1 elements, then emits another\nvalue, and so on. In other words, it emits every n-th value of it, starting with the first one.If n = 0, the iterator behaves like for n = 1: It emits all values of it.Marble diagram:it               ---1----2----3---4----5\nit.stepSize 2    ---1---------3--------5\nAvailability:This operation is currently only available for iterators implementing IteratorAccess,\nsuch as PRange.iter range iterators.Termination properties:* Finite instance: only if the base iterator it is finite* Productive instance: always\n\nIf it is an iterator, then it.map f is another iterator that applies a\nfunction f to all values emitted by it and emits the result.In situations where f is monadic, use mapM instead.Marble diagram:it         ---a --b --c --d -e ----⊥\nit.map     ---a'--b'--c'--d'-e'----⊥\n(given that f a = a', f b = b' etc.)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is productivePerformance:For each value emitted by the base iterator it, this combinator calls f.\n\nIf it is an iterator, then it.mapM f is another iterator that applies a monadic\nfunction f to all values emitted by it and emits the result.The base iterator it being monadic in m, f can return values in any monad n for which a\nMonadLiftT m n instance is available.If f is pure, then the simpler variant it.map can be used instead.Marble diagram (without monadic effects):it          ---a --b --c --d -e ----⊥\nit.mapM     ---a'--b'--c'--d'-e'----⊥\n(given that f a = pure a', f b = pure b' etc.)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveFor certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.mapM will be finite even if it isn't.If that does not help, the more general combinator it.mapWithPostcondition f makes it possible to\nmanually prove Finite and Productive instances depending on the concrete choice of f.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nNote: This is a very general combinator that requires an advanced understanding of monads, dependent\ntypes and termination proofs. The variants map and mapM are easier to use and sufficient\nfor most use cases.If it is an iterator, then it.mapWithPostcondition f is another iterator that applies a monadic\nfunction f to all values emitted by it and emits the result.f is expected to return PostconditionT n _. The base iterator it being monadic in\nm, n can be different from m, but it.mapWithPostcondition f expects a MonadLiftT m n\ninstance. The PostconditionT transformer allows the caller to intrinsically prove properties about\nf's return value in the monad n, enabling termination proofs depending on the specific behavior\nof f.Marble diagram (without monadic effects):it                          ---a --b --c --d -e ----⊥\nit.mapWithPostcondition     ---a'--b'--c'--d'-e'----⊥\n(given that f a = pure a', f b = pure b' etc.)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveFor certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.mapWithPostcondition will be finite even if it isn't.In such situations, the missing instances can be proved manually if the postcondition bundled in\nthe PostconditionT n monad is strong enough. In the given example, a suitable postcondition might\nbe fun _ => False.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nTransforms an m-monadic iterator with values in β into an n-monadic iterator with\nvalues in ULift β. Requires a MonadLift m (ULiftT n) instance.Marble diagram:it            ---a    ----b    ---c    --d    ---⊥\nit.uLift n    ---.up a----.up b---.up c--.up d---⊥\nTermination properties:* Finite: only if the original iterator is finite* Productive: only if the original iterator is productive\n\nLet it be an iterator and f a function mapping it's outputs to iterators.\nThen it.flatMap f is an iterator that goes over it and for each output, it applies f and\niterates over the resulting iterator. it.flatMap f emits all values obtained from the inner\niterators -- first, all of the first inner iterator, then all of the second one, and so on.Marble diagram:it                 ---a      --b      c    --d -⊥\nf a                    a1-a2⊥\nf b                             b1-b2⊥\nf c                                    c1-c2⊥\nf d                                           ⊥\nit.flatMap         ----a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it and the inner iterators are finite* Productive instance: only if it is finite and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it or an internal iterator.For each value emitted by the outer iterator it, this combinator calls f.\n\nLet it be an iterator and f a monadic function mapping it's outputs to iterators.\nThen it.flatMapM f is an iterator that goes over it and for each output, it applies f and\niterates over the resulting iterator. it.flatMapM f emits all values obtained from the inner\niterators -- first, all of the first inner iterator, then all of the second one, and so on.Marble diagram (without monadic effects):it                 ---a      --b      c    --d -⊥\nf a                    a1-a2⊥\nf b                             b1-b2⊥\nf c                                    c1-c2⊥\nf d                                           ⊥\nit.flatMapM        ----a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it and the inner iterators are finite* Productive instance: only if it is finite and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it or an internal iterator.For each value emitted by the outer iterator it, this combinator calls f.\n\nLet it₁ and it₂ be iterators and f a function mapping it₁'s outputs to iterators\nof the same type as it₂. Then it₁.flatMapAfter f it₂ first goes over it₂ and then over\nit₁.flatMap f it₂, emitting all their values.The main purpose of this combinator is to represent the intermediate state of a flatMap iterator\nthat is currently iterating over one of the inner iterators.Marble diagram:it₁                            --b      c    --d -⊥\nit₂                      a1-a2⊥\nf b                               b1-b2⊥\nf c                                      c1-c2⊥\nf d                                             ⊥\nit.flatMapAfter  f it₂   a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it₁, it₂ and the inner iterators are finite* Productive instance: only if it₁ is finite and it₂ and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it₁, it₂ or an internal\niterator.For each value emitted by the outer iterator it₁, this combinator calls f.\n\nLet it₁ and it₂ be iterators and f a monadic function mapping it₁'s outputs to iterators\nof the same type as it₂. Then it₁.flatMapAfterM f it₂ first goes over it₂ and then over\nit₁.flatMap f it₂, emitting all their values.The main purpose of this combinator is to represent the intermediate state of a flatMap iterator\nthat is currently iterating over one of the inner iterators.Marble diagram (without monadic effects):it₁                            --b      c    --d -⊥\nit₂                      a1-a2⊥\nf b                               b1-b2⊥\nf c                                      c1-c2⊥\nf d                                             ⊥\nit.flatMapAfterM f it₂   a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it₁, it₂ and the inner iterators are finite* Productive instance: only if it₁ is finite and it₂ and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it₁, it₂ or an internal\niterator.For each value emitted by the outer iterator it₁, this combinator calls f.\n\nIf it is an iterator, then it.filter f is another iterator that applies a\npredicate f to all values emitted by it and emits them only if they are accepted by f.In situations where f is monadic, use filterM instead.Marble diagram (without monadic effects):it            ---a--b--c--d-e--⊥\nit.filter     ---a-----c-------⊥\n(given that f a = f c = true and f b = f d = d e = false)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be productive even though\nno Productive instance is provided. For example, if f always returns True, the resulting\niterator will be productive as long as it is. In such situations, the missing instance needs to\nbe proved manually.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned value.\n\nIf it is an iterator, then it.filterM f is another iterator that applies a monadic\npredicate f to all values emitted by it and emits them only if they are accepted by f.The base iterator it being monadic in m, f can return values in any monad n for which a\nMonadLiftT m n instance is available.If f is pure, then the simpler variant it.filter can be used instead.Marble diagram (without monadic effects):it             ---a--b--c--d-e--⊥\nit.filterM     ---a-----c-------⊥\n(given that f a = f c = pure true and f b = f d = d e = pure false)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.filterWithPostcondition will be finite -- and productive -- even if it\nisn't.In such situations, the more general combinator it.filterWithPostcondition f makes it possible to\nmanually prove Finite and Productive instances depending on the concrete choice of f.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nNote: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants filter and filterM are easier to use and\nsufficient for most use cases.If it is an iterator, then it.filterWithPostcondition f is another iterator that applies a monadic\npredicate f to all values emitted by it and emits them only if they are accepted by f.f is expected to return PostconditionT n (ULift Bool). The base iterator it being monadic in\nm, n can be different from m, but it.filterWithPostcondition f expects a MonadLiftT m n\ninstance. The PostconditionT transformer allows the caller to intrinsically prove properties about\nf's return value in the monad n, enabling termination proofs depending on the specific behavior\nof f.Marble diagram (without monadic effects):it                             ---a--b--c--d-e--⊥\nit.filterWithPostcondition     ---a-----c-------⊥\n(given that f a = f c = pure true and f b = f d = d e = pure false)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.filterWithPostcondition will be finite -- and productive -- even if it\nisn't.In such situations, the missing instances can be proved manually if the postcondition bundled in\nthe PostconditionT n monad is strong enough. In the given example, a suitable postcondition might\nbe fun _ => False.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nIf it is an iterator, then it.filterMap f is another iterator that applies a function f to all\nvalues emitted by it. f is expected to return an Option. If it returns none, then nothing is\nemitted; if it returns some x, then x is emitted.In situations where f is monadic, use filterMapM instead.Marble diagram:it               ---a --b--c --d-e--⊥\nit.filterMap     ---a'-----c'-------⊥\n(given that f a = some a', f c = c' and f b = f d = d e = none)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be productive even though\nno Productive instance is provided. For example, if f never returns none, then\nthis combinator will preserve productiveness. In such situations, the missing instance needs to\nbe proved manually.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned Option value.\n\nIf it is an iterator, then it.filterMapM f is another iterator that applies a monadic\nfunction f to all values emitted by it. f is expected to return an Option inside the monad.\nIf f returns none, then nothing is emitted; if it returns some x, then x is emitted.The base iterator it being monadic in m, f can return values in any monad n for which a\nMonadLiftT m n instance is available.If f is pure, then the simpler variant it.filterMap can be used instead.Marble diagram (without monadic effects):it                ---a --b--c --d-e--⊥\nit.filterMapM     ---a'-----c'-------⊥\n(given that f a = pure (some a)', f c = pure (some c') and f b = f d = d e = pure none)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f never returns none, then\nthis combinator will preserve productiveness. If f is an ExceptT monad and will always fail,\nthen it.filterMapM will be finite even if it isn't. In the first case, consider\nusing the map/mapM/mapWithPostcondition combinators instead, which provide more instances out of\nthe box.If that does not help, the more general combinator it.filterMapWithPostcondition f makes it\npossible to manually prove Finite and Productive instances depending on the concrete choice of f.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned Option value.\n\nNote: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants filterMap and filterMapM are easier to use\nand sufficient for most use cases.If it is an iterator, then it.filterMapWithPostcondition f is another iterator that applies a\nmonadic function f to all values emitted by it. f is expected to return an Option inside the\nmonad. If f returns none, then nothing is emitted; if it returns some x, then x is emitted.f is expected to return PostconditionT n (Option _). The base iterator it being monadic in\nm, n can be different from m, but it.filterMapWithPostcondition f expects a MonadLiftT m n\ninstance. The PostconditionT transformer allows the caller to intrinsically prove properties about\nf's return value in the monad n, enabling termination proofs depending on the specific behavior\nof f.Marble diagram (without monadic effects):it                                ---a --b--c --d-e--⊥\nit.filterMapWithPostcondition     ---a'-----c'-------⊥\n(given that f a = pure (some a)', f c = pure (some c') and f b = f d = d e = pure none)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finiteFor certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f never returns none, then\nthis combinator will preserve productiveness. If f is an ExceptT monad and will always fail,\nthen it.filterMapWithPostcondition will be finite even if it isn't. In the first case, consider\nusing the map/mapM/mapWithPostcondition combinators instead, which provide more instances out of\nthe box.In such situations, the missing instances can be proved manually if the postcondition bundled in\nthe PostconditionT n monad is strong enough. If f always returns some _, a suitable\npostcondition is fun x => x.isSome; if f always fails, a suitable postcondition might be\nfun _ => False.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned Option value.\n\nGiven two iterators left and right, left.zip right is an iterator that yields pairs of\noutputs of left and right. When one of them terminates,\nthe zip iterator will also terminate.Marble diagram:left               --a        ---b        --c\nright                 --x         --y        --⊥\nleft.zip right     -----(a, x)------(b, y)-----⊥\nTermination properties:* Finite instance: only if either left or right is finite and the other is productive* Productive instance: only if left and right are productiveThere are situations where left.zip right is finite (or productive) but none of the instances\nabove applies. For example, if the computation happens in an Except monad and left immediately\nfails when calling step, then left.zip right will also do so. In such a case, the Finite\n(or Productive) instance needs to be proved manually.Performance:This combinator incurs an additional O(1) cost with each step taken by left or right.Right now, the compiler does not unbox the internal state, leading to worse performance than\npossible.\n\n“Attaches” individual proofs to an iterator of values that satisfy a predicate P, returning an\niterator with values in the corresponding subtype { x // P x }.Termination properties:* Finite instance: only if the base iterator is finite* Productive instance: only if the base iterator is productive\n\n","context":"Lean Reference\u0009Iterators\u0009Iterator Combinators","header":"21.4.2. Monadic Combinators","id":"/Iterators/Iterator-Combinators/#The-Lean-Language-Reference--Iterators--Iterator-Combinators--Monadic-Combinators"},"/Source-Files-and-Modules/#The-Lean-Language-Reference--Source-Files-and-Modules--Module-System-Errors-and-Patterns--Recipe-for-Porting-Existing-Files":{"contents":"To gain the benefits of the module system, source files must be made into modules.\nStart by enabling the module system throughout all files with minimal breaking changes:1. Prefix all files with module.2. Make all existing imports public unless they will be used only in proofs.* Add import all when errors that mention references to private data occur.* Add public meta import when errors that mention “must be meta” occur.\n   The public may be omitted when defining local-only metaprograms.3. Prefix the remainder of the file with @[expose] public section or, for programming-focused files, with public section.\n   The latter should be used for programs that will be run but not reasoned about.\n\nAfter an initial build under the module system succeeds, the dependencies between modules can be iteratively minimized.\nIn particular, removing uses of public and @[expose] will help avoid unnecessary rebuilds.\n\n","context":"Lean Reference\u0009Source Files and Modules\u0009Module System Errors and Patterns","header":"5.6.1. Recipe for Porting Existing Files","id":"/Source-Files-and-Modules/#The-Lean-Language-Reference--Source-Files-and-Modules--Module-System-Errors-and-Patterns--Recipe-for-Porting-Existing-Files"},"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Other-Pattern-Matching-Operators":{"contents":"In addition to match and if let, there are a few other operators that perform pattern matching.\n\nThe matches OperatorThe matches operator returns true if the term on the left matches the pattern on the right.\n\nWhen branching on the result of matches, it's usually better to use if let, which can bind pattern variables in addition to checking whether a pattern matches.\n\n\n\nIf there are no constructor patterns that could match a discriminant or sequence of discriminants, then the code in question is unreachable, as there must be a false assumption in the local context.\nThe nomatch expression is a match with zero cases that can have any type whatsoever, so long as there are no possible cases that could match the discriminants.\n\nCaseless Pattern Matches\n\nInconsistent IndicesThere are no constructor patterns that can match both proofs in this example:example (p1 : x = \"Hello\") (p2 : x = \"world\") : False :=\n  nomatch p1, p2\nThis is because they separately refine the value of x to unequal strings.\nThus, the nomatch operator allows the example's body to prove False (or any other proposition or type).\n\nWhen the expected type is a function type, nofun is shorthand for a function that takes as many parameters as the type indicates in which the body is nomatch applied to all of the parameters.\n\nCaseless Functions\n\nImpossible FunctionsInstead of introducing arguments for both equality proofs and then using both in a nomatch, it is possible to use nofun.example : x = \"Hello\" → x = \"world\" → False := nofun\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching","header":"10.8.4. Other Pattern Matching Operators","id":"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Other-Pattern-Matching-Operators"},"/The-Type-System/Inductive-Types/#inductive-types":{"contents":"Inductive types are the primary means of introducing new types to Lean.\nWhile universes, functions, and quotient types are built-in primitives that could not be added by users, every other type in Lean is either an inductive type or defined in terms of universes, functions, and inductive types.\nInductive types are specified by their type constructors  and their constructors;  their other properties are derived from these.\nEach inductive type has a single type constructor, which may take both universe parameters and ordinary parameters.\nInductive types may have any number of constructors; these constructors introduce new values whose types are headed by the inductive type's type constructor.\n\nBased on the type constructor and the constructors for an inductive type, Lean derives a recursor.\nLogically, recursors represent induction principles or elimination rules; computationally, they represent primitive recursive computations.\nThe termination of recursive functions is justified by translating them into uses of the recursors, so Lean's kernel only needs to perform type checking of recursor applications, rather than including a separate termination analysis.\nLean additionally produces a number of helper constructions based on the recursor,The term recursor is always used, even for non-recursive types. which are used elsewhere in the system.\n\nStructures are a special case of inductive types that have exactly one constructor.\nWhen a structure is declared, Lean generates helpers that enable additional language features to be used with the new structure.\n\nThis section describes the specific details of the syntax used to specify both inductive types and structures, the new constants and definitions in the environment that result from inductive type declarations, and the run-time representation of inductive types' values in compiled code.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System","header":"4.4. Inductive Types","id":"/The-Type-System/Inductive-Types/#inductive-types"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Library-Updates":{"contents":"* Developments in the async machinery;* Standardization of the integer division API;* Conversions between finite types;* API expansion of BitVec and tree maps;* Proofs of Bitwuzla rewrite rules;* Improvements to List/Array/Vector, as well as HashMap and Int/Nat.\n\nSee the Library section below for details.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Highlights","header":"Library Updates","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Library-Updates"}});