window.docContents[245].resolve({"/Build-Tools-and-Distribution/Lake/#lake-config-lean":{"contents":"The Lean format for Lake package configuration files provides a domain-specific language for the declarative features that are supported in the TOML format.\nAdditionally, it provides the ability to write Lean code to implement any necessary build logic that is not expressible declaratively.\n\nBecause the Lean format is a Lean source file, it can be edited using all the features of the Lean language server.\nAdditionally, Lean's metaprogramming framework allows elaboration-time side effects to be used to implement features such as configuration steps that are conditional on the current platform.\nHowever, a consequence of the Lean configuration format being a Lean file is that it is not feasible to process such files using tools that are not themselves written in Lean.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format","header":"24.1.3.2. Lean Format","id":"/Build-Tools-and-Distribution/Lake/#lake-config-lean"},"/Error-Explanations/About___--projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--About___--projNonPropFromProp":{"contents":"\n\nThis error occurs when attempting to project a piece of data from a proof of a proposition using an\nindex projection. For example, if h is a proof of an existential proposition, attempting to\nextract the witness h.1 is an example of this error. Such projections are disallowed because they\nmay violate Lean's prohibition of large elimination from Prop (refer to the\nPropositions manual section for further details).\n\nInstead of an index projection, consider using a pattern-matching\nlet, match expression, or a\ndestructuring tactic like cases to eliminate from one propositional type to another. Note\nthat such elimination is only valid if the resulting value is also in Prop; if it is not,\nthe error lean.propRecLargeElim\nwill be raised.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"About:  projNonPropFromProp","id":"/Error-Explanations/About___--projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--About___--projNonPropFromProp"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#option-monad":{"contents":"Ordinarily, Option is thought of as data, similarly to a nullable type.\nIt can also be considered as a monad, and thus a way of performing computations.\nThe Option monad and its transformer OptionT can be understood as describing computations that may terminate early, discarding the results.\nCallers can check for early termination and invoke a fallback if desired using OrElse.orElse or by treating it as a MonadExcept Unit.\n\nAdds the ability to fail to a monad. Unlike ordinary exceptions, there is no way to signal why a\nfailure occurred.\n\nExecutes an action that might fail in the underlying monad m, returning none in case of failure.\n\nConverts a computation from the underlying monad into one that could fail, even though it does not.This function is typically implicitly accessed via a MonadLiftT instance as part of automatic\nlifting.\n\nConverts an action that returns an Option into one that might fail, with none indicating\nfailure.\n\nSucceeds with the provided value.\n\nSequences two potentially-failing actions. The second action is run only if the first succeeds.\n\nA recoverable failure.\n\nRecovers from failures. Typically used via the <|> operator.\n\nHandles failures by treating them as exceptions of type Unit.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.6. Option","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#option-monad"},"/Interacting-with-Lean/#format-join":{"contents":"The operators in this section are useful when there is some kind of repeated content, such as the elements of a list.\nThis is typically done by including line in their separator parameters, using a bracketing operator\n\nConcatenates a list of Formats with ++.\n\nIntercalates the given list with the given sep format.The list items are formatting using ToFormat.format.\n\nConcatenates the given list after prepending pre to each element.The list items are formatting using ToFormat.format.\n\nConcatenates the given list after appending the given suffix to each element.The list items are formatting using ToFormat.format.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.3. Sequences","id":"/Interacting-with-Lean/#format-join"},"/Iterators/Reasoning-About-Iterators/#The-Lean-Language-Reference--Iterators--Reasoning-About-Iterators--Equivalence":{"contents":"Iterator equivalence is defined in terms of the observable behavior of iterators, rather than their implementations.\nIn particular, the internal state is ignored.\n\nEquivalence relation on iterators. Equivalent iterators behave the same as long as the\ninternal state of them is not directly inspected.Two iterators (possibly of different types) are equivalent if they have the same\nIterator.IsPlausibleStep relation and their step functions are the same up to equivalence of the\nsuccessor iterators. This coinductive definition captures the idea that the only relevant feature\nof an iterator is its step function. Other information retrievable from the iterator -- for example,\nwhether it is a list iterator or an array iterator -- is totally irrelevant for the equivalence\njudgement.\n\nEquivalence relation on monadic iterators. Equivalent iterators behave the same as long as the\ninternal state of them is not directly inspected.Two iterators (possibly of different types) are equivalent if they have the same\nIterator.IsPlausibleStep relation and their step functions are the same up to equivalence of the\nsuccessor iterators. This coinductive definition captures the idea that the only relevant feature\nof an iterator is its step function. Other information retrievable from the iterator -- for example,\nwhether it is a list iterator or an array iterator -- is totally irrelevant for the equivalence\njudgement.\n\n","context":"Lean Reference\u0009Iterators\u0009Reasoning About Iterators","header":"21.5.4. Equivalence","id":"/Iterators/Reasoning-About-Iterators/#The-Lean-Language-Reference--Iterators--Reasoning-About-Iterators--Equivalence"},"/Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Exporting-Names":{"contents":"Exporting a name makes it available in the current namespace.\nUnlike a definition, this alias is completely transparent: uses are resolved directly to the original name.\nExporting a name to the root namespace makes it available without qualification; the Lean standard library does this for names such as the constructors of Option and key type class methods such as get.\n\nExporting NamesThe export command adds names from other namespaces to the current namespace, as if they had been declared in it.\nWhen the current namespace is opened, these exported names are also brought into scope.Internally, exported names are registered as aliases of their targets.\nFrom the perspective of the kernel, only the original name exists; the elaborator resolves aliases as part of resolving identifiers to names.\n\nExported NamesThe declaration of the inductive type Veg.Leafy establishes the constructors Veg.Leafy.spinach and Veg.Leafy.cabbage:namespace Veg\ninductive Leafy where\n  | spinach\n  | cabbage\nexport Leafy (spinach)\nend Veg\nexport Veg.Leafy (cabbage)\nThe first export command makes Veg.Leafy.spinach accessible as Veg.spinach because the current namespace is Veg.\nThe second makes Veg.Leafy.cabbage accessible as cabbage, because the current namespace is the root namespace.\n\n","context":"Lean Reference\u0009Namespaces and Sections\u0009Namespaces","header":"6.1.2. Exporting Names","id":"/Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Exporting-Names"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-intro":{"contents":"If the main goal's target type is an inductive type, constructor solves it with\nthe first matching constructor, or else fails.\n\nThe injection tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if c is a constructor of an inductive datatype, and if (c t₁)\nand (c t₂) are two terms that are equal then  t₁ and t₂ are equal too.\nIf q is a proof of a statement of conclusion t₁ = t₂, then injection applies\ninjectivity to derive the equality of all arguments of t₁ and t₂ placed in\nthe same positions. For example, from (a::b) = (c::d) we derive a=c and b=d.\nTo use this tactic t₁ and t₂ should be constructor applications of the same constructor.\nGiven h : a::b = c::d, the tactic injection h adds two new hypothesis with types\na = c and b = d to the main goal.\nThe tactic injection h with h₁ h₂ uses the names h₁ and h₂ to name the new hypotheses.\n\ninjections applies injection to all hypotheses recursively\n(since injection can produce new hypotheses). Useful for destructing nested\nconstructor equalities like (a::b::c) = (d::e::f).\n\nApplies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.example : True ∨ False := by\n  left\n  trivial\n\n\nApplies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.example {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Inductive Types","header":"13.5.14.1. Introduction","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-intro"},"/The-Type-System/Inductive-Types/#inductive-types-runtime-special-support":{"contents":"Not every inductive type is represented as indicated here—some inductive types have special support from the Lean compiler:\n\n* The representation of the fixed-width integer types UInt8, …, UInt64, Int8, …, Int64, and USize depends on the whether the code is compiled for a 32- or 64-bit architecture.\n  Their representation is described in a dedicated section.* Char is represented by uint32_t. Because Char values never require more than 21 bits, they are always unboxed.* Float is represented by a pointer to a Lean object that contains a “double”.* An enum inductive type of at least 2 and at most 2^{32} constructors, each of which has no parameters, is represented by the first type of uint8_t, uint16_t, uint32_t that is sufficient to assign a unique value to each constructor. For example, the type Bool is represented by uint8_t, with values 0 for false and 1 for true. * Decidable α is represented the same way as Bool * Nat and Int are represented by lean_object *.\n  Their representations are described in more detail in the section on natural numbers and the section on integers.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation","header":"4.4.4.1. Exceptions","id":"/The-Type-System/Inductive-Types/#inductive-types-runtime-special-support"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Tactics":{"contents":"* #10445 adds helper definitions in preparation for the upcoming\ninjective function support in grind.* #10447 adds the [grind inj] attribute for marking injectivity\ntheorems for grind.* #10448 modifies the \"issues\" grind diagnostics prints. Previously we\nwould just describe synthesis failures. These messages were confusing to\nusers, as in fact the linarith module continues to work, but less\ncapably. For most of the issues, we now explain the resulting change in\nbehaviour. There is a still a TODO to explain the change when\nIsOrderedRing is not available.* #10449 ensures that issues reported by the E-matching module are\ndisplayed only when set_option grind.debug true is enabled. Users\nreported that these messages are too distracting and not very useful.\nThey are more valuable for library developers when annotating their\nlibraries.* #10461 fixes unnecessary case splits generated by the grind mbtc\nmodule. Here, mbtc stands for model-based theory combination.* #10463 adds Nat.sub_zero as a grind normalization rule.* #10465 skips cast-like helper grind functions during grind mbtc* #10466 reduces noise in the 'Equivalence classes' section of the\ngrind diagnostics. It now uses a notion of support expressions.\nRight now, it is hard-coded, but we will probably make it extensible in\nthe future. The current definition is* #10469 fixes an incorrect optimization in the grind canonicalizer.\nSee the new test for an example that exposes the problem.* #10472 adds a code action for grind parameters. We need to use\nset_option grind.param.codeAction true to enable the option. The PR\nalso adds a modifier to instruct grind to use the \"default\" pattern\ninference strategy.* #10473 ensures the code action messages produced by grind include the\nfull context* #10474 adds a doc string for the ! parameter modifier in grind.* #10477 ensures sorts are internalized by grind.* #10480 fixes a bug in the equality resolution frontend used in grind.* #10481 generalizes the theorem activation function used in grind.\nThe goal is to reuse it to implement the injective function module.* #10482 fixes symbol collection for the @[grind inj] attribute.* #10483 completes support for injective functions in grind. See\nexamples:/-! Add some injectivity theorems. -/\n\ndef double (x : Nat) := 2*x\n\n@[grind inj] theorem double_inj : Function.Injective double := by\n  grind [Function.Injective, double]\n\nstructure InjFn (α : Type) (β : Type) where\n  f : α → β\n  h : Function.Injective f\n\ninstance : CoeFun (InjFn α β) (fun _ => α → β) where\n  coe s := s.f\n\n@[grind inj] theorem fn_inj (F : InjFn α β) : Function.Injective (F : α → β) := by\n  grind [Function.Injective, cases InjFn]\n\ndef toList (a : α) : List α := [a]\n\n@[grind inj] theorem toList_inj : Function.Injective (toList : α → List α) := by\n  grind [Function.Injective, toList]\n\n/-! Examples -/\n\nexample (x y : Nat) : toList (double x) = toList (double y) → x = y := by\n  grind\n\nexample (f : InjFn (List Nat) α) (x y z : Nat)\n    : f (toList (double x)) = f (toList y) →\n      y = double z →\n      x = z := by\n  grind\n* #10486 adds and expands grind related docstrings.* #10529 adds some helper theorems for the upcoming grind order solver.* #10553 implements infrastructure for the new grind order module.* #10562 simplifies the grind order module, and internalizes the order\nconstraints. It removes the Offset type class because it introduced\ntoo much complexity. We now cover the same use cases with a simpler\napproach:* Any type that implements at least Std.IsPreorder* Arbitrary ordered rings.* Nat by the Nat.ToInt adapter.* #10583 allows users to declare additional grind constraint\npropagators for declarations that already include propagators in core.* #10589 adds helper theorems for implementing  grind order* #10590 implements proof term construction for grind order.* #10594 implements proof construction for theory propagation in grind order.* #10596 implements the function for adding new edges to the graph used\nby grind order. The graph maintains the transitive closure of all\nasserted constraints.* #10598 implements support for positive constraints in grind order.\nThe new module can already solve problems such as:example [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsPreorder α]\n    (a b c : α) : a ≤ b → b ≤ c → c < a → False := by\n  grind\n\nexample [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsPreorder α]\n    (a b c d : α) : a ≤ b → b ≤ c → c < d → d ≤ a → False := by\n  grind\n\nexample [LE α] [Std.IsPreorder α]\n    (a b c : α) : a ≤ b → b ≤ c → a ≤ c := by\n  grind\n\nexample [LE α] [Std.IsPreorder α]\n    (a b c d : α) : a ≤ b → b ≤ c → c ≤ d → a ≤ d := by\n  grind\n* #10599 fixes the support for Nat in grind order. This module uses\nthe Nat.ToInt adapter.* #10600 implements support for negative constraints in grind order.\nExamples:open Lean Grind\nexample [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsLinearPreorder α]\n    (a b c d : α) : a ≤ b → ¬ (c ≤ b) → ¬ (d ≤ c) → d < a → False := by\n  grind -linarith (splits := 0)\n\nexample [LE α] [Std.IsLinearPreorder α]\n    (a b c d : α) : a ≤ b → ¬ (c ≤ b) → ¬ (d ≤ c) → ¬ (a ≤ d) → False := by\n  grind -linarith (splits := 0)\n\nexample [LE α] [LT α] [Std.LawfulOrderLT α] [Std.IsLinearPreorder α] [CommRing α] [OrderedRing α]\n    (a b c d : α) : a - b ≤ 5 → ¬ (c ≤ b) → ¬ (d ≤ c + 2) → d ≤ a - 8 → False := by\n  grind -linarith (splits := 0)\n* #10601 fixes a panic in grind order when order is not a partial\norder.* #10604 implements the method processNewEq in grind order. It is\nresponsible for processing equalities propagated by the grind E-graph.* #10607 adds infrastructure for the upcoming grind tactic mode, which\nwill be similar to the conv mode. The goal is to extend grind from a\nterminal tactic into an interactive mode: grind => ….* #10677 implements the basic tactics for the new grind interactive\nmode. While many additional grind tactics will be added later, the\nfoundational framework is already operational. The following grind\ntactics are currently implemented: skip, done, finish, lia, and\nring.\nalso removes the notion of grind fallback procedure since it\nis subsumed by the new framework. Examples:example (x y : Nat) : x ≥ y + 1 → x > 0 := by\n  grind => skip; lia; done\n* #10679 fixes an issue where \"Invalid alternative name\" errors from\ninduction stick around after removing the offending alternative.* #10690 adds the instantiate, show_true, show_false,\nshow_asserted, and show_eqcs tactics for the grind interactive\nmode. The show tactic take an optional \"filter\" and are used to probe\nthe grind state. Example:example (as bs cs : Array α) (v₁ v₂ : α)\n        (i₁ i₂ j : Nat)\n        (h₁ : i₁ < as.size)\n        (h₂ : bs = as.set i₁ v₁)\n        (h₃ : i₂ < bs.size)\n        (h₃ : cs = bs.set i₂ v₂)\n        (h₄ : i₁ ≠ j ∧ i₂ ≠ j)\n        (h₅ : j < cs.size)\n        (h₆ : j < as.size)\n        : cs[j] = as[j] := by\n  grind =>\n    instantiate\n    -- Display asserted facts with `generation > 0`\n    show_asserted gen > 0\n    -- Display propositions known to be `True`, containing `j`, and `generation > 0`\n    show_true j && gen > 0\n    -- Display equivalence classes with terms that contain `as` or `bs`\n    show_eqcs as || bs\n    instantiate\n* #10695 fixes an issue where non-macro members of a mutual block\nwere discarded if there was at least one macro present.* #10706 adds the have tactic for the grind interactive mode.\nExample:example {a b c d e : Nat}\n    : a > 0 → b > 0 → 2*c + e <= 2 → e = d + 1 → a*b + 2 > 2*c + d := by\n  grind =>\n    have : a*b > 0 := Nat.mul_pos h h_1\n    lia\n* #10707 ensures the finish tactic in grind interactive mode fails\nand reports diagnostics when goal is not closed.* #10709 implements anchors (also known as stable hash codes) for\nreferencing terms occurring in a grind goal. It also introduces the\ncommands show_splits and show_state. The former displays the anchors\nfor candidate case splits in the current grind goal.* #10715 improves anchor stability (aka stable hash codes) used to\nreference terms in a grind goal.* #10731 adds the following tactics to the grind interactive mode:* focus <grind_tac_seq>* next => <grind_tac_seq>* any_goals <grind_tac_seq>* all_goals <grind_tac_seq>* grind_tac <;> grind_tac* cases <anchor>* tactic => <tac_seq>* #10737 adds the tactics linarith, ac, fail, first, try,\nfail_if_success, and admit to grind interactive mode.* #10740 improves the tactics ac, linarith, lia, ring tactics in\ngrind interactive mode. They now fail if no progress has been made.\nThey also generate an info message with counterexample/basis if the goal\nwas not closed.* #10746 implements parameters for the instantiate tactic in the\ngrind interactive mode. Users can now select both global and local\ntheorems. Local theorems are selected using anchors. It also adds the\nshow_thms tactic for displaying local theorems. Example:example (as bs cs : Array α) (v₁ v₂ : α)\n        (i₁ i₂ j : Nat)\n        (h₁ : i₁ < as.size)\n        (h₂ : bs = as.set i₁ v₁)\n        (h₃ : i₂ < bs.size)\n        (h₃ : cs = bs.set i₂ v₂)\n        (h₄ : i₁ ≠ j ∧ i₂ ≠ j)\n        (h₅ : j < cs.size)\n        (h₆ : j < as.size)\n        : cs[j] = as[j] := by\n  grind =>\n    instantiate = Array.getElem_set\n    instantiate Array.getElem_set\n* #10747 implements infrastructure for finish? and grind? tactics.* #10748 implements the repeat tactical for the grind interactive\nmode.* #10767 implements the new control interface for implementing grind\nsearch strategies. It will replace the SearchM framework.* #10778 ensures that grind interactive mode is hygienic. It also adds\ntactics for renaming inaccessible names: rename_i h_1 ... h_n and\nnext h_1 ... h_n => .., and expose_names for automatically generated\ntactic scripts. The PR also adds helper functions for implementing\ncase-split actions.* #10779 implements hover information for grind anchors. Anchors are\nstable hash codes for referencing terms in the grind state. The anchors\nwill be used when auto generating tactic scripts.* #10791 adds a silent info message with the grind state in its\ninteractive mode. The message is shown only when there is exactly one\ngoal in the grind interactive mode. The condition is a workaround for\ncurrent limitations of our InfoTree.* #10798 implements the grind actions intro, intros, assertNext,\nassertAll.* #10801 implements the splitNext action for grind.* #10808 implements support for compressing auto-generated grind tactic\nsequences.* #10811 implements proper case-split anchor generation in the\nsplitNext action, which will be used to implement grind? and\nfinish?.* #10812 implements lia, linarith, and ac actions for grind\ninteractive mode.* #10824 implements the cases? tactic for the grind interactive mode.\nIt provides a convenient way to select anchors. Users can filter the\ncandidates using the filter language.* #10828 implements a compact notation for inspecting the grind state\nin interactive mode. Within a grind tactic block, each tactic may\noptionally have a suffix of the form | filter?.* #10833 implements infrastructure for evaluating grind tactics in the\nGrindM monad. We are going to use it to check whether auto-generated\ntactics can effectively close the original goal.* #10834 implements the ring action for grind.* #10836 implements support for Action in the grind solver extensions\n(SolverExtension). It also provides the Solvers.mkAction function\nthat constructs an Action using all registered solvers. The generated\naction is \"fair,\" that is, a solver cannot prevent other solvers from\nmaking progress.* #10837 implements the finish? tactic for the grind interactive\nmode. When it successfully closes the goal, it produces a code action\nthat allows the user to close the goal using explicit grind tactic\nsteps, i.e., without any search. It also makes explicit which solvers\nhave been used.* #10841 improves the grind tactic generated by the instantiate\naction in tracing mode. It also updates the syntax for the instantiate\ntactic, making it similar to simp. For example:* instantiate only [thm1, thm2] instantiates only theorems thm1 and\nthm2.* instantiate [thm1, thm2] instantiates theorems marked with the\n@[grind] attribute and theorems thm1 and thm2.* #10843 implements the set_option tactic in grind interactive mode.* #10846 fixes a few issues on instance only [...] tactic generation at\nfinish?.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)","header":"Tactics","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Tactics"}});