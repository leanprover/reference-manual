window.docContents[39].resolve({"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Connectives-and-Quantifiers":{"contents":"Predicate ConnectivesSyntactic sugar for SPred.and.Syntactic sugar for SPred.or.Syntactic sugar for SPred.not.Syntactic sugar for SPred.imp.Syntactic sugar for SPred.iff.\n\nConjunction in SPred: states that satisfy P and satisfy Q satisfy spred(P ∧ Q).\n\nConjunction of a list of stateful predicates. A state satisfies conjunction env if it satisfies\nall predicates in env.\n\nDisjunction in SPred: states that either satisfy P or satisfy Q satisfy spred(P ∨ Q).\n\nNegation in SPred: states that do not satisfy P satisfy spred(¬ P).\n\nImplication in SPred: states that satisfy Q whenever they satisfy P satisfy spred(P → Q).\n\nBiimplication in SPred: states that either satisfy both P and Q or satisfy neither satisfy\nspred(P ↔ Q).\n\nPredicate QuantifiersEach form of universal quantification is syntactic sugar for an invocation of SPred.forall on a function that takes the quantified variable as a parameter.Each form of existential quantification is syntactic sugar for an invocation of SPred.exists on a function that takes the quantified variable as a parameter.\n\nUniversal quantifier in SPred.\n\nExistential quantifier in SPred.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Stateful Predicates","header":"18.2.1.3. Connectives and Quantifiers","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Connectives-and-Quantifiers"},"/The-Type-System/Inductive-Types/#recursors":{"contents":"Every inductive type is equipped with a recursor.\nThe recursor is completely determined by the signatures of the type constructor and the constructors.\nRecursors have function types, but they are primitive and are not definable using fun.\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model","header":"4.4.3.1. Recursors","id":"/The-Type-System/Inductive-Types/#recursors"},"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Compiler___-runtime___-and-FFI":{"contents":"* #4685 fixes a typo in the C run_new_frontend signature* #4729 has IR checker suggest using noncomputable* #5143 adds a shared library for Lake* #5437 removes (syntactically) duplicate imports (@euprunin)* #5462 updates src/lake/lakefile.toml to the adjusted Lake build process* #5541 removes new shared libs before build to better support Windows* #5558 make lean.h compile with MSVC (@kant2002)* #5564 removes non-conforming size-0 arrays (@eric-wieser)\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.13.0 (2024-11-01)","header":"Compiler, runtime, and FFI","id":"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Compiler___-runtime___-and-FFI"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Pretty-Printing":{"contents":"* #10122 adds support for pretty printing using generalized field\nnotation (dot notation) for private definitions on public types. It also\nmodifies dot notation elaboration to resolve names after removing the\nprivate prefix, which enables using dot notation for private definitions\non private imported types.* #10373 adds a pp.unicode option and a unicode(\"→\", \"->\") syntax\ndescription alias for the lower-level unicodeSymbol \"→\" \"->\" parser.\nThe syntax is added to the notation command as well. When pp.unicode\nis true (the default) then the first form is used when pretty printing,\nand otherwise the second ASCII form is used. A variant, unicode(\"→\", \"->\", preserveForPP) causes the -> form to be preferred; delaborators\ncan insert → directly into the syntax, which will be pretty printed\nas-is; this allows notations like fun to use custom options such as\npp.unicode.fun to opt into the unicode form when pretty printing.* #10374 adds the options pp.piBinderNames and\npp.piBinderNames.hygienic. Enabling pp.piBinderNames causes\nnon-dependent pi binder names to be pretty printed, rather than be\nomitted. When pp.piBinderNames.hygienic is false (the default) then\nonly non-hygienic such biner names are pretty printed. Setting pp.all\nenables pp.piBinderNames if it is not otherwise explicitly set.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Pretty Printing","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Pretty-Printing"}});