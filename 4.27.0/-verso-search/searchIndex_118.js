window.docContents[118].resolve({"/Error-Explanations/About___--synthInstanceFailed/#The-Lean-Language-Reference--Error-Explanations--About___--synthInstanceFailed--Examples":{"contents":"Using the Wrong Binary Operation#eval \"A\" + \"3\"\nfailed to synthesize instance of type class\n  HAdd String String ?m.4\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\n#eval \"A\" ++ \"3\"\nThe binary operation + is associated with the HAdd type class, and there's no way to add\ntwo strings. The binary operation ++, associated with the HAppend type class, is the\ncorrect way to append strings.\n\nArguments Have the Wrong Typedef x : Int := 3\n#eval x ++ \"meters\"\nfailed to synthesize instance of type class\n  HAppend Int String ?m.4\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\ndef x : Int := 3\n#eval ToString.toString x ++ \"meters\"\nLean does not allow integers and strings to be added directly. The function\nToString.toString uses type class overloading to convert values to strings; by successfully\nsearching for an instance of ToString Int, the second example will succeed.\n\nMissing Type Class Instanceinductive MyColor where\n  | chartreuse | sienna | thistle\n\ndef forceColor (oc : Option MyColor) :=\n  oc.get!\nfailed to synthesize instance of type class\n  Inhabited MyColor\n\nHint: Adding the command `deriving instance Inhabited for MyColor` may allow Lean to derive the missing instance.\ninductive MyColor where\n  | chartreuse | sienna | thistle\nderiving Inhabited\n\ndef forceColor (oc : Option MyColor) :=\n  oc.get!\ninductive MyColor where\n  | chartreuse | sienna | thistle\n\nderiving instance Inhabited for MyColor\n\ndef forceColor (oc : Option MyColor) :=\n  oc.get!\ninductive MyColor where\n  | chartreuse | sienna | thistle\n\ninstance : Inhabited MyColor where\n  default := .sienna\n\ndef forceColor (oc : Option MyColor) :=\n  oc.get!\nType class synthesis can fail because an instance of the type class simply needs to be provided.\nThis commonly happens for type classes like Repr, BEq, ToJson and\nInhabited. Lean can often automatically generate instances of the\ntype class with the deriving keyword either when the type is defined or with the stand-alone\nderiving command.\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  synthInstanceFailed","header":"Examples","id":"/Error-Explanations/About___--synthInstanceFailed/#The-Lean-Language-Reference--Error-Explanations--About___--synthInstanceFailed--Examples"},"/Namespaces-and-Sections/#namespaces":{"contents":"Names that contain periods (that aren't inside guillemets) are hierarchical names; the periods separate the components of a name.\nAll but the final component of a name are the namespace, while the final component is the name itself.\n\nNamespaces serve to group related definitions, theorems, types, and other declarations.\nWhen a namespace corresponds to a type's name, generalized field notation can be used to access its contents.\nIn addition to organizing names, namespaces also group syntax extensions, attributes, and instances.\n\nNamespaces are orthogonal to modules: a module is a unit of code that is elaborated, compiled, and loaded together, but there is no necessary connection between a module's name and the names that it provides.\nA module may contain names in any namespace, and the nesting structure of hierarchical modules is unrelated to that of hierarchical namespaces.\n\nThere is a root namespace, ordinarily denoted by simply omitting a namespace.\nIt can be explicitly indicated by beginning a name with _root_.\nThis can be necessary in contexts where a name would otherwise be interpreted relative to an ambient namespace (e.g. from a section scope) or local scope.\n\nExplicit Root NamespaceNames in the current namespace take precedence over names in the root namespace.\nIn this example, color in the definition of Forest.statement refers to Forest.color:def color := \"yellow\"\nnamespace Forest\ndef color := \"green\"\ndef statement := s!\"Lemons are {color}\"\nend Forest\n#eval Forest.statement\n\"Lemons are green\"\nWithin the Forest namespace, references to color in the root namespace must be qualified with _root_:namespace Forest\ndef nextStatement :=\n  s!\"Ripe lemons are {_root_.color}, not {color}\"\nend Forest\n#eval Forest.nextStatement\n\"Ripe lemons are yellow, not green\"\n\n\n\n\n\n\n","context":"Lean Reference\u0009Namespaces and Sections","header":"6.1. Namespaces","id":"/Namespaces-and-Sections/#namespaces"},"/ValidatingProofs/#validating-printing-axioms":{"contents":"The blue double check marks appear  even when there are explicit uses of sorry or incomplete proofs in the dependencies of the theorem.\nBecause both sorry and incomplete proofs are elaborated to axioms, their presence can be detected by listing the axioms that a proof relies on.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Validating a Lean Proof","header":"Printing Axioms","id":"/ValidatingProofs/#validating-printing-axioms"}});