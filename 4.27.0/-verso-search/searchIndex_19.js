window.docContents[19].resolve({"/Basic-Types/Natural-Numbers/#nat-api-pow2":{"contents":"A natural number n is a power of two if there exists some k : Nat such that n = 2 ^ k.\n\nReturns the least power of two that's greater than or equal to n.Examples:* Nat.nextPowerOfTwo 0 = 1* Nat.nextPowerOfTwo 1 = 1* Nat.nextPowerOfTwo 2 = 2* Nat.nextPowerOfTwo 3 = 4* Nat.nextPowerOfTwo 5 = 8\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"20.1.4.4. Powers of Two","id":"/Basic-Types/Natural-Numbers/#nat-api-pow2"},"/Error-Explanations/About___--invalidField/#The-Lean-Language-Reference--Error-Explanations--About___--invalidField":{"contents":"\n\nThis error indicates that an expression containing a dot followed by an identifier was encountered,\nand that it wasn't possible to understand the identifier as a field.\n\nLean's field notation is very powerful, but this can also make it confusing: the expression\ncolor.value can either be a single identifier.\nit can be a reference to the field of a structure, and it\nand be a calling a function on the value color with\ngeneralized field notation.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"About:  invalidField","id":"/Error-Explanations/About___--invalidField/#The-Lean-Language-Reference--Error-Explanations--About___--invalidField"},"/Source-Files-and-Modules/#keywords-and-identifiers":{"contents":"An identifier consists of one or more identifier components, separated by '.'.\n\nIdentifier components consist of a letter or letter-like character or an underscore ('_'), followed by zero or more identifier continuation characters.\nLetters are English letters, upper- or lowercase, and the letter-like characters include a range of non-English alphabetic scripts, including the Greek script which is widely used in Lean, the Coptic script, the members of the Unicode letter-like symbol block, which contains a number of double-struck characters (including ℕ and ℤ) and abbreviations, the Latin-1 supplemental letters (with the exception of × and ÷), and the Latin Extended-A block.\nIdentifier continuation characters consist of letters, letter-like characters, underscores ('_'), exclamation marks (!), question marks (?), subscripts, and single quotes (').\nAs an exception, underscore alone is not a valid identifier.\n\n\n\nIdentifiers components may also be surrounded by double guillemets ('«' and '»').\nSuch identifier components may contain any character at all aside from '»', even '«', '.', and newlines.\nThe guillemets are not part of the resulting identifier component, so «x» and x denote the same identifier.\n«Nat.add», on the other hand, is an identifier with a single component, while Nat.add has two.\n\n\n\nSome potential identifier components may be reserved keywords.\nThe specific set of reserved keywords depends on the set of active syntax extensions, which may depend on the set of imported files and the currently-opened  namespaces; it is impossible to enumerate for Lean as a whole.\nThese keywords must also be quoted with guillemets to be used as identifier components in most syntactic contexts.\nContexts in which keywords may be used as identifiers without guillemets, such as constructor names in inductive types, are raw identifier contexts.\n\nIdentifiers that contain one or more '.' characters, and thus consist of more than one identifier component, are called hierarchical identifiers.\nHierarchical identifiers are used to represent both import names and names in a namespace.\n\n","context":"Lean Reference\u0009Source Files and Modules\u0009Concrete Syntax","header":"5.2.3. Keywords and Identifiers","id":"/Source-Files-and-Modules/#keywords-and-identifiers"},"/The--grind--tactic/Annotating-Libraries-for--grind/#The-Lean-Language-Reference--The--grind--tactic--Annotating-Libraries-for--grind--Backwards-and-Forwards-Reasoning":{"contents":"Use @[grind ←] (which generates patterns from the conclusion of the theorem) for backwards reasoning theorems, i.e. theorems that should be tried when their conclusion matches a goal.\nSome examples of theorems in the standard library that are annotated with grind ← are:* Array.not_mem_empty (a : α) : ¬ a ∈ #[]\n* Array.getElem_filter\n  {xs : Array α} {p : α → Bool} {i : Nat}\n  (h : i < (xs.filter p).size) :\n  p (xs.filter p)[i]\n* List.Pairwise.tail\n  {l : List α} (h : Pairwise R l) :\n  Pairwise R l.tail\nIn each case, the lemma is relevant when its conclusion matches a proof goal.\n\nUse @[grind →] (which generates patterns from the hypotheses) for forwards reasoning theorems,\ni.e. where facts should be propagated from existing facts on the whiteboard.\nSome examples of theorems in the standard library that are annotated with grind → are:* List.getElem_of_getElem? {l : List α} :\n  l[i]? = some a →\n  ∃ h : i < l.length, l[i] = a\n* Array.mem_of_mem_erase [BEq α] {a b : α} {xs : Array α}\n  (h : a ∈ xs.erase b) :\n  a ∈ xs\n* List.forall_none_of_filterMap_eq_nil\n  (h : filterMap f xs = []) :\n  ∀ x ∈ xs, f x = none\nIn these cases, the theorems' assumptions determine when they are relevant.\n\nThere are many uses for custom patterns created with the grind_pattern command.\nOne common use is to introduce inequalities about terms, or membership propositions.\n\nWe might havevariable [BEq α]\n\ntheorem count_le_size {a : α} {xs : Array α} : count a xs ≤ xs.size :=\n  ...\n\ngrind_pattern count_le_size => count a xs\nwhich will register this inequality as soon as a count a xs term is encountered (even if the problem has not previously involved inequalities).\n\nWe can also use multi-patterns to be more restrictive, e.g. only introducing an inequality about sizes if the whiteboard already contains facts about sizes:\n\ntheorem size_pos_of_mem {xs : Array α} (h : a ∈ xs) : 0 < xs.size :=\n  sorry\n\ngrind_pattern size_pos_of_mem => a ∈ xs, xs.size\n\n\nUnlike a @[grind →] attribute, which would cause this theorem to be instantiated whenever a ∈ xs is encountered, this pattern will only be used when xs.size is already on the whiteboard.\n(Note that this grind pattern could also be produced using the @[grind <=] attribute, which looks at the conclusion first, then backwards through the hypotheses to select patterns.\nOn the other hand, @[grind →] would select only a ∈ xs.)\n\nIn Mathlib we might want to enable polynomial reasoning about the sine and cosine functions,\nand so add a custom grind patterntheorem sin_sq_add_cos_sq : sin x ^ 2 + cos x ^ 2 = 1 := ...\n\ngrind_pattern sin_sq_add_cos_sq => sin x, cos x\nwhich will instantiate the theorem as soon as both sin x and cos x (with the same x) are encountered.\nThis theorem will then automatically enter the Gröbner basis module, and be used to reason about polynomial expressions involving both sin x and cos x.\nOne both alternatively, more aggressively, write two separate grind patterns so that this theorem instantiated when either sin x or cos x is encountered.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Annotating Libraries for  grind","header":"17.10.2. Backwards and Forwards Reasoning","id":"/The--grind--tactic/Annotating-Libraries-for--grind/#The-Lean-Language-Reference--The--grind--tactic--Annotating-Libraries-for--grind--Backwards-and-Forwards-Reasoning"}});