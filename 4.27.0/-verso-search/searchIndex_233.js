window.docContents[233].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Unbundled-Variants":{"contents":"Unbundled maps separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the module Std.DTreeMap.Raw.\n\nDependent tree maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer DTreeMap\nover DTreeMap.Raw. Lemmas about the operations on Std.DTreeMap.Raw are available in the\nmodule Std.Data.DTreeMap.Raw.Lemmas.A tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one entry\nwith key either a or b in a tree map. Looking up either a or b always yields the same entry,\nif any is present. The get operations of the dependent tree map additionally require a\nLawfulEqCmp instance to ensure that cmp a b = .eq always implies a = b, so that their\nrespective value types are equal.To avoid expensive copies, users should make sure that the tree map is used linearly.Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.Internal implementation detail of the tree map.\n\nWell-formedness predicate for tree maps. Users of DTreeMap will not need to interact with\nthis. Users of DTreeMap.Raw will need to provide proofs of WF to lemmas and should use lemmas\nlike WF.empty and WF.insert (which are always named exactly like the operations they are about)\nto show that map operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.Internal implementation detail of the tree map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"20.19.9.7. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Unbundled-Variants"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Properties":{"contents":"Returns true if the hash set contains no elements.Note that if your BEq instance is not reflexive or your Hashable instance is not\nlawful, then it is possible that this function returns false even though m.contains a = false\nfor all a.\n\nThe number of elements present in the set\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Sets","header":"20.19.7.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Properties"},"/Coercions/Coercing-Between-Types/#coercion-impl":{"contents":"The appropriate CoeHead, CoeOut, Coe, or CoeTail instance is sufficient to cause a desired coercion to be inserted.\nHowever, the implementation of the coercion should be registered as a coercion using the coe attribute.\nThis causes Lean to display uses of the coercion with the ↑ operator.\nIt also causes the norm_cast tactic to treat the coercion as a cast, rather than as an ordinary function.\n\nCoercion DeclarationsThe @[coe] attribute on a function (which should also appear in a\ninstance : Coe A B := ⟨myFn⟩ declaration) allows the delaborator to show\napplications of this function as ↑ when printing expressions.\n\nImplementing CoercionsThe enum inductive type Weekday represents the days of the week:inductive Weekday where\n  | mo | tu | we | th | fr | sa | su\nAs a seven-element type, it contains the same information as Fin 7.\nThere is a bijection:def Weekday.toFin : Weekday → Fin 7\n  | mo => 0\n  | tu => 1\n  | we => 2\n  | th => 3\n  | fr => 4\n  | sa => 5\n  | su => 6\n\ndef Weekday.fromFin : Fin 7 → Weekday\n  | 0 => mo\n  | 1 => tu\n  | 2 => we\n  | 3 => th\n  | 4 => fr\n  | 5 => sa\n  | 6 => su\nEach type can be coerced to the other:instance : Coe Weekday (Fin 7) where\n  coe := Weekday.toFin\n\ninstance : Coe (Fin 7) Weekday where\n  coe := Weekday.fromFin\nWhile this works, instances of the coercions that occur in Lean's output are not presented using the coercion operator, which is what Lean users expect.\nInstead, the name Weekday.fromFin is used explicitly:def wednesday : Weekday := (2 : Fin 7)\n\n#print wednesday\ndef wednesday : Weekday :=\nWeekday.fromFin 2\nAdding the coe attribute to the definition of a coercion causes it to be displayed using the coercion operator:attribute [coe] Weekday.fromFin\nattribute [coe] Weekday.toFin\n\ndef friday : Weekday := (5 : Fin 7)\n\n#print friday\ndef friday : Weekday :=\n↑5\n\n\n","context":"Lean Reference\u0009Coercions\u0009Coercing Between Types","header":"12.2.1. Implementing Coercions","id":"/Coercions/Coercing-Between-Types/#coercion-impl"}});