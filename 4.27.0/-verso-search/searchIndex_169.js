window.docContents[169].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Comparisons":{"contents":"Unsigned less-than-or-equal-to for bitvectors.SMT-LIB name: bvule.\n\nSigned less-than-or-equal-to for bitvectors.SMT-LIB name: bvsle.\n\nUnsigned less-than for bitvectors.SMT-LIB name: bvult.\n\nSigned less-than for bitvectors.SMT-LIB name: bvslt.Examples:* BitVec.slt 6#4 7 = true* BitVec.slt 7#4 8 = false\n\nBitvectors have decidable equality.This should be used via the instance DecidableEq (BitVec w).\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"20.5.5.4. Comparisons","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Comparisons"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.\nIf the returned Bool is true, then the returned map is unaltered. If the Bool is false,\nthen the returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the map for which the given function returns false.\n\nUpdates the values of the map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nInserts multiple mappings into the tree map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for TreeMap, DTreeMap, TreeMap.Raw and DTreeMap.Raw.\nThe insertMany function on TreeSet and TreeSet.Raw behaves differently: it will prefer the first\nappearance.\n\nPartitions a tree map into two tree maps based on a predicate.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"20.19.9.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Modification"},"/Error-Explanations/About___--inductiveParamMissing/#The-Lean-Language-Reference--Error-Explanations--About___--inductiveParamMissing":{"contents":"\n\nThis error occurs when an inductive type constructor is partially applied in the type of one of its\nconstructors such that one or more parameters of the type are omitted. The elaborator requires that\nall parameters of an inductive type be specified everywhere that type is referenced in its\ndefinition, including in the types of its constructors.\n\nIf it is necessary to allow the type constructor to be partially applied, without specifying a given\ntype parameter, that parameter must be converted to an index. See the manual section on\nInductive Types for further explanation of the difference between indices\nand parameters.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"About:  inductiveParamMissing","id":"/Error-Explanations/About___--inductiveParamMissing/#The-Lean-Language-Reference--Error-Explanations--About___--inductiveParamMissing"},"/Iterators/Iterator-Combinators/#The-Lean-Language-Reference--Iterators--Iterator-Combinators":{"contents":"The documentation for iterator combinators often includes marble diagrams that show the relationship between the elements returned by the underlying iterators and the elements returned by the combinator's iterator.\nMarble diagrams provide examples, not full specifications.\nThese diagrams consist of a number of rows.\nEach row shows an example of an iterator's output, where - indicates a skip, a term indicates a value returned with yield, and ⊥ indicates the end of iteration.\nSpaces indicate that iteration did not occur.\nUnbound identifiers in the marble diagram stand for arbitrary values of the iterator's element type.\n\nVertical alignment in the marble diagram indicates a causal relationship: when two elements are aligned, it means that consuming the iterator in the lower row results in the upper rows being consumed.\nIn particular, consuming up to the nth column of the lower iterator results in the consumption of the first n columns from the upper iterator.\n\nA marble diagram for an identity iterator combinator that returns each element from the underlying iterator looks like this:it    ---a-----b---c----d⊥\nit.id ---a-----b---c----d⊥\n\n\nA marble diagram for an iterator combinator that duplicates each element of the underlying iterator looks like this:it           ---a  ---b  ---c  ---d⊥\nit.double    ---a-a---b-b---c-c---d-d⊥\n\n\nThe marble diagram for Iter.filter shows how some elements of the underlying iterator do not occur in the filtered iterator, but also that stepping the filtered iterator results in a skip when the underlying iterator returns a value that doesn't satisfy the predicate:it            ---a--b--c--d-e--⊥\nit.filter     ---a-----c-------⊥\nThe diagram requires an explanatory note:(given that f a = f c = true and f b = f d = d e = false)\n\nThe diagram for Iter.zip shows how consuming the combined iterator consumes the underlying iterators:left               --a        ---b        --c\nright                 --x         --y        --⊥\nleft.zip right     -----(a, x)------(b, y)-----⊥\nThe zipped iterator emits skips so long as left does.\nWhen left emits a, the zipped iterator emits one more skip.\nAfter this, the zipped iterator switches to consuming right, and it emits skips so long as right does.\nWhen right emits x, the zipped iterator emits the pair (a, x).\nThis interleaving of left and right continues until one of them stops, at which point the zipped iterator stops.\nBlank spaces in the upper rows of the marble diagram indicate that the iterator is not being consumed at that step.\n\n\n\n\n\n","context":"Lean Reference\u0009Iterators","header":"21.4. Iterator Combinators","id":"/Iterators/Iterator-Combinators/#The-Lean-Language-Reference--Iterators--Iterator-Combinators"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-term-helpers":{"contents":"These tactics are used during elaboration of terms to satisfy obligations that arise.\n\nConstructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using ts to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition.\n\nget_elem_tactic is the tactic automatically called by the notation arr[i]\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\nget_elem_tactic_extensible and gives a diagnostic error message otherwise;\nusers are encouraged to extend get_elem_tactic_extensible instead of this tactic.\n\nget_elem_tactic_trivial has been deprecated in favour of get_elem_tactic_extensible.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.20. Term Elaboration Backends","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-term-helpers"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-debug":{"contents":"trace_state prints the current goal state.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.6. Debugging Utilities","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-debug"},"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Discriminant-Refinement":{"contents":"When matching on an indexed family, the indices must also be discriminants.\nOtherwise, the pattern would not be well typed: it is a type error if an index is just a variable but the type of a constructor requires a more specific value.\nHowever, a process called discriminant refinement automatically adds indices as additional discriminants.\n\nDiscriminant RefinementIn the definition of f, the equality proof is the only discriminant.\nHowever, equality is an indexed family, and the match is only valid when n is an additional discriminant.def f (n : Nat) (p : n = 3) : String :=\n  match p with\n  | rfl => \"ok\"\nUsing #print demonstrates that the additional discriminant was added automatically.#print f\ndef f : (n : Nat) → n = 3 → String :=\nfun n p =>\n  match 3, p with\n  | .(n), ⋯ => \"ok\"\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching\u0009Types","header":"10.8.1.3. Discriminant Refinement","id":"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Discriminant-Refinement"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Lake":{"contents":"* #10861 fixes input_dir tracking to also recurse through\nsubdirectories. The filter of an input_dir will be applied to each\nfile in the directory tree (the path names of directories will not be\nchecked).* #10883 fixes a bug with Lake's cache where revisions were stored at the\nincorrect path. Revisions were stored at <rev>/<pkg>.jsonl rather than\nthe correct <pkg>/<rev>.jsonl.* #10959 enables Lake users to require Reservoir dependencies by a\nsemantic version range. On a lake update, Lake will fetch the\npackage's version information from Reservoir and select the newest\nversion of the package that satisfies the range.* #11062 changes Lake's debug build type to use -O0 instead of -Og\nwhen compiling C code. -Og was found to be insufficient for debugging\ncompiled Lean code -- relevant code was stilled optimized out.* #11063 changes the math and math-lax templates for lake new and\nlake init to use the version of Mathlib corresponding to the current\nLean toolchain. Thus, lake +x.y.z new <pkg> math will use the Mathlib\nfor Lean x.y.z. On the other hand, lake update on such packages will\nno longer update Mathlib automatically. Users will need to change the\nMathlib revision in the configuration file before updating.* #11117 fixes a bug where Lake ignored moreLinkObjs and moreLinkLibs\non a lean_exe.* #11118 adds Job.sync as a standard way of declaring a synchronous\njob.* #11169 changes all module build keys in Lake to be scoped by their\npackage. This enables building modules with the same name in different\npackages (something previously only well-supported for executable\nroots).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0 (2025-12-13)","header":"Lake","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Lake"}});