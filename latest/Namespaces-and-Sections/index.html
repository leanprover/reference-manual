<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Namespaces and Sections</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: 0.75rem;
  margin-top: 0.75rem;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: 1.5rem;
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 1.5rem 1.5rem;
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "âŽ";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot" checked="checked"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="current numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-namespaces-sections" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-namespaces-sections" checked="checked"></label><span class="number">6.</span>Â <span class="current"><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Namespaces-and-Sections/#namespaces">Namespaces</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Namespaces-and-Section-Scopes">Namespaces and Section Scopes</a></span></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="syntax"><span class="keyword">open</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___openHiding"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">hiding</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___openRenaming"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">renaming</span><span class="ws"> </span><span class="meta">(</span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">â†’</span><span class="ws"> </span><span class="meta">â€¦</span><span class="meta">),*</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___openOnly"><span class="syntax"><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">(</span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___openScoped"><span class="syntax"><span class="keyword">scoped</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Exporting-Names">Exporting Names</a></span></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___export"><span class="syntax"><span class="keyword">export</span><span class="ws"> </span><span class="meta">â€¦</span><span class="ws"> </span><span class="keyword">(</span><span class="meta">â€¦</span><span class="keyword">)</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Namespaces-and-Sections/#scopes">Section Scopes</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Namespaces-and-Sections/#scope-commands">Controlling Section Scopes</a></span></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="syntax"><span class="keyword">section</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="syntax"><span class="keyword">namespace</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___end"><span class="syntax"><span class="keyword">end</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___end-next"><span class="syntax"><span class="keyword">end</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><span class="syntax"><span class="keyword">in</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="Namespaces-and-Sections/#section-variables">Section Variables</a></span></li>
                <li>
                  <a href="Namespaces-and-Sections/#Lean___Parser___Command___variable"><span class="syntax"><span class="keyword">variable</span><span class="ws"> </span><span class="meta">â€¦</span></span></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Source-Files-and-Modules/#files" rel="prev" title="5. Source Files and Modules"><span class="arrow">â†</span><span class="where">5. Source Files and Modules</span></a><a class="local-button active" href="Definitions/#definitions" rel="next" title="7. Definitions"><span class="where">7. Definitions</span><span class="arrow">â†’</span></a></nav>
          <section>
            <h1>
              6.Â Namespaces and Sections<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=namespaces-sections" title="Permalink">ðŸ”—</a></span></h1>
            <p>
              Names are organized into hierarchical <span id="--tech-term-namespaces" class="def-technical-term"><em>namespaces</em></span>, which are collections of names.
Namespaces are the primary means of organizing APIs in Lean: they provide an ontology of operations, grouping related items.
Additionally, while this is not done by giving them names in the namespace, the effects of features such as <a href="Notations-and-Macros/#language-extension">syntax extensions</a>, <a class="technical-term" href="Type-Classes/#--tech-term-instances">instances</a>, and <a class="technical-term" href="Attributes/#--tech-term-Attributes">attributes</a> can be attached to a namespace.</p>
            <p>
              Sorting operations into namespaces organizes libraries conceptually, from a global perspective.
Any given Lean file will, however, typically not use all names equally.
<a class="technical-term" href="Namespaces-and-Sections/#--tech-term-section">Sections</a> provide a means of ordering a local view of the globally-available collection of names, as well as a way to precisely control the scope of compiler options along with language extensions, instances, and attributes.
They also allow parameters shared by many declarations to be declared centrally and propagated as needed using the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.variable : command</code><span class="sep"></span><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {Î± : Type u}      -- implicit
    (a : Î±)           -- explicit
    [instBEq : BEq Î±] -- instance implicit, named
    [Hashable Î±]      -- instance implicit, anonymous

  def isEqual (b : Î±) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {Î± : Type u} (a : Î±) [instBEq : BEq Î±] (b : Î±) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : Î±} := a == b â†” b == a

  #check eqComm
  -- eqComm.{u} {Î± : Type u} {a : Î±} [instBEq : BEq Î±] {b : Î±} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src Ã— String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {Î± : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString Î±]  -- available in the proof as `Î±` is included
  (a : Î±)       -- available in the proof as mentioned in the header
  {Î² : Type}    -- not available in the proof
  [ToString Î²]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString Î±]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___variable"><code class="kw">variable</code></a></span> command.</p>
            <section>
              <h2 id="namespaces">
                6.1.Â Namespaces<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=namespaces" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Names that contain periods (that aren't inside <a class="technical-term" href="Source-Files-and-Modules/#--tech-term-guillemets">guillemets</a>) are hierarchical names; the periods separate the <em>components</em> of a name.
All but the final component of a name are the namespace, while the final component is the name itself.</p>
              <p>
                Namespaces serve to group related definitions, theorems, types, and other declarations.
When a namespace corresponds to a type's name, <a class="technical-term" href="Terms/Function-Application/#--tech-term-generalized-field-notation">generalized field notation</a> can be used to access its contents.
In addition to organizing names, namespaces also group <a href="Notations-and-Macros/#language-extension">syntax extensions</a>, <a href="Attributes/#attributes">attributes</a>, and <a href="Type-Classes/#type-classes">instances</a>.</p>
              <p>
                Namespaces are orthogonal to <a class="technical-term" href="Source-Files-and-Modules/#--tech-term-module">modules</a>: a module is a unit of code that is elaborated, compiled, and loaded together, but there is no necessary connection between a module's name and the names that it provides.
A module may contain names in any namespace, and the nesting structure of hierarchical modules is unrelated to that of hierarchical namespaces.</p>
              <p>
                There is a root namespace, ordinarily denoted by simply omitting a namespace.
It can be explicitly indicated by beginning a name with <code>_root_</code>.
This can be necessary in contexts where a name would otherwise be interpreted relative to an ambient namespace (e.g. from a <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-section-scope">section scope</a>) or local scope.</p>
              <details class="example"><summary class="description">Explicit Root Namespace</summary><div class="example-content">
                  <p>
                    Names in the current namespace take precedence over names in the root namespace.
In this example, <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-Forest.color" data-verso-hover="781">color</span></a></code> in the definition of <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-Forest.statement" data-verso-hover="782">Forest.statement</span></a></code> refers to <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-Forest.color" data-verso-hover="781">Forest.color</span></a></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1839">def</span> <span class="const token" data-binding="const-color" data-verso-hover="783" id="Forest___statement">color</span> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="784">"yellow"</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-1861" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">Forest</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1878">def</span> <span class="const token" data-binding="const-Forest.color" data-verso-hover="781" id="Forest___statement">color</span> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="785">"green"</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1899">def</span> <span class="const token" data-binding="const-Forest.statement" data-verso-hover="782" id="Forest___statement">statement</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termS!_-1916">s!</span><span class="unknown token" data-binding="">"Lemons are {</span><a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-Forest.color" data-verso-hover="781">color</span></a><span class="unknown token" data-binding="">}"</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-1939" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">Forest</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"Lemons are green"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-1978" data-verso-hover="6">#eval</span></a></span> <a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-Forest.statement" data-verso-hover="782">Forest.statement</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>"Lemons are green"
</pre></div>
                  <p>
                    Within the <code>Forest</code> namespace, references to <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-color" data-verso-hover="783">color</span></a></code> in the root namespace must be qualified with <code>_root_</code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-2184" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">Forest</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2201">def</span> <span class="const token" data-binding="const-Forest.nextStatement" data-verso-hover="786" id="Forest___nextStatement">nextStatement</span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-termS!_-2224">s!</span><span class="unknown token" data-binding="">"Ripe lemons are {</span><a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-color" data-verso-hover="787">_root_.color</span></a><span class="unknown token" data-binding="">}, not {</span><a href="Namespaces-and-Sections/#Forest___statement"><span class="const token" data-binding="const-Forest.color" data-verso-hover="781">color</span></a><span class="unknown token" data-binding="">}"</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-2272" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">Forest</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"Ripe lemons are yellow, not green"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-2312" data-verso-hover="6">#eval</span></a></span> <a href="Namespaces-and-Sections/#Forest___nextStatement"><span class="const token" data-binding="const-Forest.nextStatement" data-verso-hover="786">Forest.nextStatement</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>"Ripe lemons are yellow, not green"
</pre></div>
                  </div>
                </details><section>
                <h3 id="The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Namespaces-and-Section-Scopes">
                  6.1.1.Â Namespaces and Section Scopes</h3>
                <p>
                  Every <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-section-scope">section scope</a> has a <span id="--tech-term-current-namespace" class="def-technical-term"><em>current namespace</em></span>, which is determined by the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command.<span class="marginalia"><span class="note">The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command is described in the <a href="Namespaces-and-Sections/#scope-commands">section on commands that introduce section scopes</a>.</span></span>
Names that are declared within the section scope are added to the current namespace.
If the declared name has more than one component, then its namespace is nested within the current namespace; the body of the declaration's current namespace is the nested namespace.
Section scopes also include a set of <span id="--tech-term-opened-namespaces" class="def-technical-term"><em>opened namespaces</em></span>, which are namespaces whose contents are in scope without additional qualification.
<a class="technical-term" href="IO/Tasks-and-Threads/#--tech-term-resolving-next">Resolving</a> an identifier to a particular name takes the current namespace and opened namespaces into account.
However, <span id="--tech-term-protected" class="def-technical-term">protected</span> declarations (that is, those with the <code class="plain-keyword">protected</code> <a href="Definitions/Modifiers/#declaration-modifiers">modifier</a>) are not brought into scope their namespace is opened.
The rules for resolving identifiers into names that take the current namespace and opened namespaces into account are described in the <a href="Terms/Identifiers/#identifiers-and-resolution">section on identifiers as terms</a>.</p>
                <details class="example"><summary class="description">Current Namespace</summary><div class="example-content">
                    <p>
                      Defining an inductive type results in the type's constructors being placed in its namespace, in this case as <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="788">HotDrink.coffee</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="789">HotDrink.tea</span></a></code>, and <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="790">HotDrink.cocoa</span></a></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-3925" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-HotDrink" data-verso-hover="791" id="HotDrink___cocoa">HotDrink</span> <span class="keyword token" data-binding="kw-occ-null-3944">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="788" id="HotDrink___cocoa">coffee</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="789" id="HotDrink___cocoa">tea</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="790" id="HotDrink___cocoa">cocoa</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Outside the namespace, these names must be qualified unless the namespace is opened:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">HotDrink.tea : HotDrink</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4092">#check</span></a></span> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="789">HotDrink.tea</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>HotDrink.tea : HotDrink
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4207">#check</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'tea'</code></span></span><span class="unknown token" data-binding="">tea</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'tea'
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-4299" data-verso-hover="118">section</span></a>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-4307" data-verso-hover="119">open</span></a> <span class="unknown token" data-binding="">HotDrink</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">HotDrink.tea : HotDrink</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4321">#check</span></a></span> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="789">tea</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-4332" data-verso-hover="124">end</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>HotDrink.tea : HotDrink
</pre></div>
                    <p>
                      If a function is defined directly inside the <code>HotDrink</code> namespace, then the body of the function is elaborated with the current namespace set to <code>HotDrink</code>.
The constructors are in scope:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4586">def</span> <span class="const token" data-binding="const-HotDrink.ofString?" data-verso-hover="792" id="HotDrink___ofString___">HotDrink.ofString?</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink" data-verso-hover="791">HotDrink</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="literal string token" data-binding="" data-verso-hover="793">"coffee"</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="788">coffee</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="literal string token" data-binding="" data-verso-hover="794">"tea"</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="789">tea</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="literal string token" data-binding="" data-verso-hover="795">"cocoa"</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="790">cocoa</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      Defining another inductive type creates a new namespace:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-4797" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-ColdDrink" data-verso-hover="796" id="ColdDrink">ColdDrink</span> <span class="keyword token" data-binding="kw-occ-null-4817">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-ColdDrink.water" data-verso-hover="797" id="ColdDrink">water</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-ColdDrink.juice" data-verso-hover="798" id="ColdDrink">juice</span>
<span class="unknown token" data-binding=""></span></code><p>
                      From within the <code>HotDrink</code> namespace, <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#ColdDrink___toString"><span class="const token" data-binding="const-HotDrink.toString" data-verso-hover="799">HotDrink.toString</span></a></code> can be defined without an explicit prefix.
Defining a function in the <code>ColdDrink</code> namespace requires an explicit <code>_root_</code> qualifier to avoid defining <code>HotDrink.ColdDrink.toString</code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-5101" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">HotDrink</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5121">def</span> <span class="const token" data-binding="const-HotDrink.toString" data-verso-hover="799" id="ColdDrink___toString">toString</span> <span class="unknown token" data-binding="">:</span> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink" data-verso-hover="791">HotDrink</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="788">coffee</span></a> <span class="unknown token" data-binding="">=&gt;</span> <span class="literal string token" data-binding="" data-verso-hover="793">"coffee"</span>
  <span class="unknown token" data-binding="">|</span> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="789">tea</span></a> <span class="unknown token" data-binding="">=&gt;</span> <span class="literal string token" data-binding="" data-verso-hover="794">"tea"</span>
  <span class="unknown token" data-binding="">|</span> <a href="Namespaces-and-Sections/#HotDrink___cocoa"><span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="790">cocoa</span></a> <span class="unknown token" data-binding="">=&gt;</span> <span class="literal string token" data-binding="" data-verso-hover="795">"cocoa"</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5218">def</span> <span class="const token" data-binding="const-ColdDrink.toString" data-verso-hover="800" id="ColdDrink___toString">_root_.ColdDrink.toString</span> <span class="unknown token" data-binding="">:</span> <a href="Namespaces-and-Sections/#ColdDrink"><span class="const token" data-binding="const-ColdDrink" data-verso-hover="796">ColdDrink</span></a> <span class="unknown token" data-binding="">â†’</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Namespaces-and-Sections/#ColdDrink"><span class="const token" data-binding="const-ColdDrink.water" data-verso-hover="797">.water</span></a> <span class="unknown token" data-binding="">=&gt;</span> <span class="literal string token" data-binding="" data-verso-hover="801">"water"</span>
  <span class="unknown token" data-binding="">|</span> <a href="Namespaces-and-Sections/#ColdDrink"><span class="const token" data-binding="const-ColdDrink.juice" data-verso-hover="798">.juice</span></a> <span class="unknown token" data-binding="">=&gt;</span> <span class="literal string token" data-binding="" data-verso-hover="802">"juice"</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-5316" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">HotDrink</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `â‰‹` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> command opens a namespace, making its contents available in the current section scope.
There are many variations on opening namespaces, providing flexibility in managing the local scope.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Opening Namespaces</span><div class="text">
                    <p>
                      The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `â‰‹` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> command is used to open a namespace:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___open"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.open"><code class="hover-info"><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `â‰‹` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><span class="keyword">open</span> <span class="nonterminal" data-kind="Lean.Parser.Command.openDecl.pseudo">openDecl</span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl">
                  <span class="label">open declaration</span><span class="title">Opening Entire Namespaces</span><div class="text">
                    <p>
                      A sequence of one or more identifiers results in each namespace in the sequence being opened:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openSimple"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openSimple"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre><p>
                      Each namespace in the sequence is considered relative to all currently-open namespaces, yielding a set of namespaces.
Every namespace in this set is opened before the next namespace in the sequence is processed.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Opening Nested Namespaces</summary><div class="example-content">
                    <p>
                      Namespaces to be opened are considered relative to the currently-open namespaces.
If the same component occurs in different namespace paths, a single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `â‰‹` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> command can be used to open all of them by iteratively bringing each into scope.
This example defines names in a variety of namespaces:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-6574" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">A</span> -- _root_.A
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6598">def</span> <span class="const token" data-binding="const-A.a1" data-verso-hover="803" id="A___B___C___a3">a1</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-6610" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">B</span> -- _root_.A.B
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6636">def</span> <span class="const token" data-binding="const-A.B.a2" data-verso-hover="804" id="A___B___C___a3">a2</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-6648" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">C</span> -- _root_.A.B.C
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6676">def</span> <span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="805" id="A___B___C___a3">a3</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-6688" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">C</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-6694" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">B</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-6700" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">A</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-6706" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">B</span> -- _root_.B
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6730">def</span> <span class="const token" data-binding="const-B.a4" data-verso-hover="806" id="A___B___C___a3">a4</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-6742" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">C</span> -- _root_.B.C
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6768">def</span> <span class="const token" data-binding="const-B.C.a5" data-verso-hover="807" id="A___B___C___a3">a5</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-6780" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">C</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-6786" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">B</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-6792" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">C</span> -- _root_.C
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6816">def</span> <span class="const token" data-binding="const-C.a6" data-verso-hover="808" id="A___B___C___a3">a6</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-6828" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">C</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The names are:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.a1" data-verso-hover="803">A.a1</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.B.a2" data-verso-hover="804">A.B.a2</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="805">A.B.C.a3</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-B.a4" data-verso-hover="806">B.a4</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-B.C.a5" data-verso-hover="807">B.C.a5</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-C.a6" data-verso-hover="808">C.a6</span></a></code></p>
                        </li>
                      </ul>
                    <p>
                      All six names can be brought into scope with a single iterated <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `â‰‹` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> command:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-7081" data-verso-hover="118">section</span></a>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-7089" data-verso-hover="119">open</span></a> <span class="unknown token" data-binding="">A</span> <span class="unknown token" data-binding="">B</span> <span class="unknown token" data-binding="">C</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-7100">example</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.a1" data-verso-hover="803">a1</span></a><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.B.a2" data-verso-hover="804">a2</span></a><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="805">a3</span></a><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-B.a4" data-verso-hover="806">a4</span></a><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-B.C.a5" data-verso-hover="807">a5</span></a><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-C.a6" data-verso-hover="808">a6</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-7136" data-verso-hover="124">end</span>
<span class="unknown token" data-binding=""></span></code><p>
                      If the initial namespace in the command is <code>A.B</code> instead, then neither <code>_root_.A</code>, <code>_root_.B</code>, nor <code>_root_.B.C</code> is opened:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-7309" data-verso-hover="118">section</span></a>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-7317" data-verso-hover="119">open</span></a> <span class="unknown token" data-binding="">A.B</span> <span class="unknown token" data-binding="">C</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-7328">example</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'a1'</code></span></span><span class="unknown token" data-binding="">a1</span></span><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.B.a2" data-verso-hover="804">a2</span></a><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="805">a3</span></a><span class="unknown token" data-binding="">,</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'a4'</code></span></span><span class="unknown token" data-binding="">a4</span></span><span class="unknown token" data-binding="">,</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'a5'</code></span></span><span class="unknown token" data-binding="">a5</span></span><span class="unknown token" data-binding="">,</span> <a href="Namespaces-and-Sections/#A___B___C___a3"><span class="const token" data-binding="const-C.a6" data-verso-hover="808">a6</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-7364" data-verso-hover="124">end</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'a1'
</pre></div>
                    <div class="error">
                      <pre>unknown identifier 'a4'
</pre></div>
                    <div class="error">
                      <pre>unknown identifier 'a5'
</pre></div>
                    <p>
                      Opening <code>A.B</code> makes <code>A.B.C</code> visible as <code>C</code> along with <code>_root_.C</code>, so the subsequent <code>C</code> opens both.</p>
                    </div>
                  </details><div class="namedocs" id="Lean___Parser___Command___openDecl-next">
                  <span class="label">open declaration</span><span class="title">Hiding Names</span><div class="text">
                    <p>
                      A <code class="plain-keyword">hiding</code> declaration specifies a set of names that should <em>not</em> be brought into scope.
In contrast to opening an entire namespace, the provided identifier must uniquely designate a namespace to be opened.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openHiding"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openHiding"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">hiding</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl-next-next">
                  <span class="label">open declaration</span><span class="title">Renaming</span><div class="text">
                    <p>
                      A <code class="plain-keyword">renaming</code> declaration allows some names from the opened namespace to be renamed; they are accessible under the new name in the current section scope.
The provided identifier must uniquely designate a namespace to be opened.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openRenaming"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openRenaming"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">renaming</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.openRenamingItem"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">â†’</span> <span class="nonterminal" data-kind="ident">ident</span></span></span><span class="bnf">),*</span></span></span></pre><p>
                      An ASCII arrow (<code>-&gt;</code>) may be used instead of the Unicode arrow (<code>â†’</code>).</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl-next-next-next">
                  <span class="label">open declaration</span><span class="title">Restricted Opening</span><div class="text">
                    <p>
                      Parentheses indicate that <em>only</em> the  names listed in the parentheses should be brought into scope.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openOnly"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openOnly"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span><span class="keyword">)</span></span></pre><p>
                      The indicated namespace is added to each currently-opened namespace, and each name is considered in each resulting namespace.
All of the listed names must be unambiguous; that is, they must exist in exactly one of the considered namespaces.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl-next-next-next-next">
                  <span class="label">open declaration</span><span class="title">Scoped Declarations Only</span><div class="text">
                    <p>
                      The <code class="plain-keyword">scoped</code> keyword indicates that all scoped attributes, instances, and syntax from the provided namespaces should be opened, while not making any of the names available.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openScoped"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openScoped"><span class="keyword">scoped</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Opening Scoped Declarations</summary><div class="example-content">
                    <p>
                      In this example, a scoped <a class="technical-term" href="Notations-and-Macros/Notations/#--tech-term-notation">notation</a> and a definition are created in the namespace <code>NS</code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-10418" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">NS</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.scoped-10431">scoped</span> <a href="Notations-and-Macros/Notations/#Lean___Parser___Command___notation"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.notation-10431">notation</span></a> <span class="literal string token" data-binding="" data-verso-hover="809">"{!{"</span> <span class="var token" data-binding="var-_uniq.69" data-verso-hover="810">e</span> <span class="literal string token" data-binding="" data-verso-hover="811">"}!}"</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.69" data-verso-hover="810">e</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.69" data-verso-hover="810">e</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10471">def</span> <span class="const token" data-binding="const-NS.three" data-verso-hover="812" id="NS___three">three</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10486" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">NS</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Outside of the namespace, the notation is not available:</p>
                    <pre class="syntax-error hl lean"><code class="line">def x := {!{ "pear" }<span class="parse-message has-info error"><code class="hover-info">unexpected token '!'; expected '}'</code>!</span>}</code></pre><div class="error">
                      <pre>&lt;example&gt;:1:21-1:22: unexpected token '!'; expected '}'</pre></div>
                    <p>
                      An <code class="plain-keyword">open scoped</code> command makes the notation available:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-10771" data-verso-hover="119">open</span></a> <a href="Namespaces-and-Sections/#Lean___Parser___Command___openScoped"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.openScoped-10776">scoped</span></a> <span class="unknown token" data-binding="">NS</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10786">def</span> <span class="const token" data-binding="const-x" data-verso-hover="813">x</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{!{</span> <span class="literal string token" data-binding="" data-verso-hover="814">"pear"</span> <span class="unknown token" data-binding="">}!}</span>
<span class="unknown token" data-binding=""></span></code><p>
                      However, the name <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#NS___three"><span class="const token" data-binding="const-NS.three" data-verso-hover="812">NS.three</span></a></code> is not in scope:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10909">def</span> <span class="const token" data-binding="const-y" data-verso-hover="815">y</span> <span class="unknown token" data-binding="">:=</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'three'</code></span></span><span class="unknown token" data-binding="">three</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'three'
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Exporting-Names">
                  6.1.2.Â Exporting Names</h3>
                <p>
                  <span id="--tech-term-Exporting" class="def-technical-term"><em>Exporting</em></span> a name makes it available in the current namespace.
Unlike a definition, this alias is completely transparent: uses are resolved directly to the original name.
Exporting a name to the root namespace makes it available without qualification; the Lean standard library does this for names such as the constructors of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> and key type class methods such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MonadState.get" data-verso-hover="816">get</span></code>.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Exporting Names</span><div class="text">
                    <p>
                      The <code class="plain-keyword">export</code> command adds names from other namespaces to the current namespace, as if they had been declared in it.
When the current namespace is opened, these exported names are also brought into scope.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___export"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.export"><code class="hover-info"><code class="docstring">Adds names from other namespaces to the current namespace.

The command `export Some.Namespace (nameâ‚ nameâ‚‚)` makes `nameâ‚` and `nameâ‚‚`:

- visible in the current namespace without prefix `Some.Namespace`, like `open`, and
- visible from outside the current namespace `N` as `N.nameâ‚` and `N.nameâ‚‚`.

## Examples

```lean
namespace Morning.Sky
  def star := "venus"
end Morning.Sky

namespace Evening.Sky
  export Morning.Sky (star)
  -- `star` is now in scope
  #check star
end Evening.Sky

-- `star` is visible in `Evening.Sky`
#check Evening.Sky.star
```
</code></code><span class="keyword">export</span> <span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span><span class="keyword">)</span></span></pre><p>
                      Internally, exported names are registered as aliases of their targets.
From the perspective of the kernel, only the original name exists; the elaborator resolves aliases as part of <a class="technical-term" href="IO/Tasks-and-Threads/#--tech-term-resolving-next">resolving</a> identifiers to names.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Exported Names</summary><div class="example-content">
                    <p>
                      The declaration of the <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive type</a> <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy" data-verso-hover="817">Veg.Leafy</span></a></code> establishes the constructors <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="818">Veg.Leafy.spinach</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="819">Veg.Leafy.cabbage</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-12130" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">Veg</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-12144" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Veg.Leafy" data-verso-hover="817" id="Veg___Leafy___cabbage">Leafy</span> <span class="keyword token" data-binding="kw-occ-null-12160">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="820" id="Veg___Leafy___cabbage">spinach</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="821" id="Veg___Leafy___cabbage">cabbage</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___export"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-12190" data-verso-hover="822">export</span></a> <span class="unknown token" data-binding="">Leafy</span> <span class="unknown token" data-binding="">(</span><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="820">spinach</span></a><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-12213" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">Veg</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___export"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-12221" data-verso-hover="822">export</span></a> <span class="unknown token" data-binding="">Veg.Leafy</span> <span class="unknown token" data-binding="">(</span><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="819">cabbage</span></a><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The first <code class="plain-keyword">export</code> command makes <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="818">Veg.Leafy.spinach</span></a></code> accessible as <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="818">Veg.spinach</span></a></code> because the <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-current-namespace-next">current namespace</a> is <code>Veg</code>.
The second makes <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="819">Veg.Leafy.cabbage</span></a></code> accessible as <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Veg___Leafy___cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="819">cabbage</span></a></code>, because the current namespace is the root namespace.</p>
                    </div>
                  </details></section>
              </section>
            <section>
              <h2 id="scopes">
                6.2.Â Section Scopes<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=scopes" title="Permalink">ðŸ”—</a></span></h2>
              <p>
                Many commands have an effect for the current <span id="--tech-term-section-scope" class="def-technical-term"><em>section scope</em></span> (sometimes just called "scope" when clear).
Every Lean module has a section scope.
Nested scopes are created via the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> commands, as well as the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> command combinator.</p>
              <p>
                The following data are tracked in section scopes:</p>
              <dl><dt> The Current Namespace</dt><dd><p>
                    The <span id="--tech-term-current-namespace-next" class="def-technical-term"><em>current namespace</em></span> is the namespace into which new declarations will be defined.
  Additionally, <a class="technical-term" href="IO/Tasks-and-Threads/#--tech-term-resolving-next">name resolution</a> includes all prefixes of the current namespace in the scope for global names.</p>
                  </dd><dt> Opened Namespaces</dt><dd><p>
                    When a namespace is <span id="--tech-term-opened" class="def-technical-term"><em>opened</em></span>, its names become available without an explicit prefix in the current scope.
  Additionally, scoped attributes and <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-rules">scoped syntax extensions</a> in namespaces that have been opened are active in the current section scope.</p>
                  </dd><dt> Options</dt><dd><p>
                    Compiler options are reverted to their original values at the end of the scope in which they were modified.</p>
                  </dd><dt> Section Variables</dt><dd><p>
                    <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-Section-variables">Section variables</a> are names (or <a class="technical-term" href="Type-Classes/#--tech-term-instance-implicit-next">instance implicit</a> parameters) that are automatically added as parameters to definitions.
  They are also added as universally-quantified assumptions to theorems when they occur in the theorem's statement.</p>
                  </dd></dl><section>
                <h3 id="scope-commands">
                  6.2.1.Â Controlling Section Scopes<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=scope-commands" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> command creates a new <span id="--tech-term-section" class="def-technical-term">section</span> scope, but does not modify the current namespace, opened namespaces, or section variables.
Changes made to the section scope are reverted when the section ends.
Sections may optionally be named; the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command that closes a named section must use the same name.
If section names have multiple components (that is, if they contain <code>.</code>-separated names), then multiple nested sections are introduced.
Section names have no other effect, and are a readability aid.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Sections</span><div class="text">
                    <p>
                      The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> command creates a section scope that lasts either until an <code>end</code> command or the end of the file.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___section"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.section"><code class="hover-info"><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><span class="keyword">section</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">?</span></span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Named Section</summary><div class="example-content">
                    <p>
                      The name <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="823">english</span></a></code> is defined in the <code>Greetings</code> namespace.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4096">def</span> <span class="const token" data-binding="const-Greetings.english" data-verso-hover="823" id="Greetings___english">Greetings.english</span> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="148">"Hello"</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Outside its namespace, it cannot be evaluated.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4225" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'english'
</pre></div>
                    <p>
                      Opening a section allows modifications to the global scope to be contained.
This section is named <code>Greetings</code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-4419" data-verso-hover="118">section</span></a> <span class="unknown token" data-binding="">Greetings</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Even though the section name matches the definition's namespace, the name is not in scope because section names are purely for readability and ease of refactoring.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4651" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'english'
</pre></div>
                    <p>
                      Opening the namespace <code>Greetings</code> brings <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="823">Greetings.english</span></a></code> as <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces-and-Sections/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="823">english</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-4861" data-verso-hover="119">open</span></a> <span class="unknown token" data-binding="">Greetings</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"Hello"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4877" data-verso-hover="6">#eval</span></a></span> <a href="Namespaces-and-Sections/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="823">english</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>"Hello"
</pre></div>
                    <p>
                      The section's name must be used to close it.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid 'end', name is missing (expected Greetings)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-5036" data-verso-hover="124">end</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid 'end', name is missing (expected Greetings)
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-5132" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">Greetings</span>
<span class="unknown token" data-binding=""></span></code><p>
                      When the section is closed, the effects of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `â‰‹` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> command are reverted.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-5307" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'english'
</pre></div>
                    </div>
                  </details><p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command creates a new section scope.
Within this section scope, the current namespace is the name provided in the command, interpreted relative to the current namespace in the surrounding section scope.
Like sections, changes made to the section scope are reverted when the namespace's scope ends.</p>
                <p>
                  To close a namespace, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command requires a suffix of the current namespace, which is removed.
All section scopes introduced by the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command that introduced part of that suffix are closed.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Namespace Declarations</span><div class="text">
                    <p>
                      The <code>namespace</code> command modifies the current namespace by appending the provided identifier.</p>
                    <p>
                      creates a section scope that lasts either until an <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command or the end of the file.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___namespace"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.namespace"><code class="hover-info"><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><span class="keyword">namespace</span> <span class="nonterminal" data-kind="ident">ident</span></span></pre></div>
                  </div>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Section and Namespace Terminators</span><div class="text">
                    <p>
                      Without an identifier, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> closes the most recently opened section, which must be anonymous.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___end"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.end"><code class="hover-info"><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><span class="keyword">end</span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      With an identifier, it closes the most recently opened section section or namespace.
If it is a section, the identifier be a suffix of the concatenated names of the sections opened since the most recent <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command.
If it is a namespace, then the identifier must be a suffix of the current namespace's extensions since the most recent <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> that is still open; afterwards, the current namespace will have had this suffix removed.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___end-next"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.end"><code class="hover-info"><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><span class="keyword">end</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span></span></pre></div>
                  </div>
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><code class="kw">end</code></a></span> that closes a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><code class="kw">mutual</code></a></span> block is part of the syntax of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><code class="kw">mutual</code></a></span>, rather than the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command.</p>
                <details class="example"><summary class="description">Nesting Namespaces and Sections</summary><div class="example-content">
                    <p>
                      Namespaces and sections may be nested.
A single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command may close one or more namespaces or one or more sections, but not a mix of the two.</p>
                    <p>
                      After setting the current namespace to <code>A.B.C</code> with two separate commands, <code>B.C</code> may be removed with a single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-7752" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">A.B</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-7766" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">C</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-7778" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">B.C</span>
<span class="unknown token" data-binding=""></span></code><p>
                      At this point, the current namespace is <code>A</code>.</p>
                    <p>
                      Next, an anonymous section and the namespace <code>D.E</code> are opened:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-7907" data-verso-hover="118">section</span></a>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-7915" data-verso-hover="120">namespace</span></a> <span class="unknown token" data-binding="">D.E</span>
<span class="unknown token" data-binding=""></span></code><p>
                      At this point, the current namespace is <code>A.D.E</code>.
An <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command cannot close all three due to the intervening section:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid 'end', name mismatch (expected Â«Â».D.E)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-8146" data-verso-hover="124">end</span></span> <span class="unknown token" data-binding="">A.D.E</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid 'end', name mismatch (expected Â«Â».D.E)
</pre></div>
                    <p>
                      Instead, namespaces and sections must be ended separately.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-8301" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">D.E</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-8309" data-verso-hover="124">end</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-8313" data-verso-hover="124">end</span> <span class="unknown token" data-binding="">A</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  Rather than opening a section for a single command, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> combinator can be used to create single-command section scope.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> combinator is right-associative, allowing multiple scope modifications to be stacked.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Local Section Scopes</span><div class="text">
                    <p>
                      The <code>in</code> command combinator introduces a section scope for a single command.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___in"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.in"><span class="nonterminal" data-kind="command.pseudo">command</span> <span class="keyword">in</span>
      <span class="nonterminal" data-kind="command.pseudo">command</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> for Local Scopes</summary><div class="example-content">
                    <p>
                      The contents of a namespace can be made available for a single command using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8990">def</span> <span class="const token" data-binding="const-Dessert.cupcake" data-verso-hover="824" id="Dessert___cupcake">Dessert.cupcake</span> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="825">"delicious"</span>

<a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-9026" data-verso-hover="119">open</span></a> <span class="unknown token" data-binding="">Dessert</span> <a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-9026">in</span></a>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"delicious"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9042" data-verso-hover="6">#eval</span></a></span> <a href="Namespaces-and-Sections/#Dessert___cupcake"><span class="const token" data-binding="const-Dessert.cupcake" data-verso-hover="824">cupcake</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      After the single command, the effects of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `â‰‹` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> are reverted.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9201" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'cupcake'</code></span></span><span class="unknown token" data-binding="">cupcake</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'cupcake'
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="section-variables">
                  6.2.2.Â Section Variables<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=section-variables" title="Permalink">ðŸ”—</a></span></h3>
                <p>
                  <span id="--tech-term-Section-variables" class="def-technical-term"><em>Section variables</em></span> are parameters that are automatically added to declarations that mention them.
This occurs whether or not the option <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Headers-and-Signatures/#autoImplicit"><span class="option token" data-binding="option-autoImplicit" data-verso-hover="245">autoImplicit</span></a></code> is <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>.
Section variables may be implicit, strict implicit, or explicit; instance implicit section variables are treated specially.</p>
                <p>
                  When the name of a section variable is encountered in a non-theorem declaration, it is added as a parameter.
Any instance implicit section variables that mention the variable are also added.
If any of the variables that were added depend on other variables, then those variables are added as well; this process is iterated until no more dependencies remain.
All section variables are added in the order in which they are declared, before all other parameters.
Section variables are added only when they occur in the <em>statement</em> of a theorem.
Otherwise, modifying the proof of a theorem could change its statement if the proof term made use of a section variable.</p>
                <p>
                  Variables are declared using the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.variable : command</code><span class="sep"></span><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {Î± : Type u}      -- implicit
    (a : Î±)           -- explicit
    [instBEq : BEq Î±] -- instance implicit, named
    [Hashable Î±]      -- instance implicit, anonymous

  def isEqual (b : Î±) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {Î± : Type u} (a : Î±) [instBEq : BEq Î±] (b : Î±) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : Î±} := a == b â†” b == a

  #check eqComm
  -- eqComm.{u} {Î± : Type u} {a : Î±} [instBEq : BEq Î±] {b : Î±} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src Ã— String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {Î± : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString Î±]  -- available in the proof as `Î±` is included
  (a : Î±)       -- available in the proof as mentioned in the header
  {Î² : Type}    -- not available in the proof
  [ToString Î²]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString Î±]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___variable"><code class="kw">variable</code></a></span> command.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Variable Declarations</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___variable"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.variable"><code class="hover-info"><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {Î± : Type u}      -- implicit
    (a : Î±)           -- explicit
    [instBEq : BEq Î±] -- instance implicit, named
    [Hashable Î±]      -- instance implicit, anonymous

  def isEqual (b : Î±) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {Î± : Type u} (a : Î±) [instBEq : BEq Î±] (b : Î±) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : Î±} := a == b â†” b == a

  #check eqComm
  -- eqComm.{u} {Î± : Type u} {a : Î±} [instBEq : BEq Î±] {b : Î±} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src Ã— String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {Î± : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString Î±]  -- available in the proof as `Î±` is included
  (a : Î±)       -- available in the proof as mentioned in the header
  {Î² : Type}    -- not available in the proof
  [ToString Î²]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString Î±]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><span class="keyword">variable</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <p>
                  The bracketed binders allowed after <code>variable</code> match the <a href="Definitions/Headers-and-Signatures/#bracketed-parameter-syntax">syntax used in definition headers</a>.</p>
                <details class="example"><summary class="description">Section Variables</summary><div class="example-content">
                    <p>
                      In this section, automatic implicit parameters are disabled, but a number of section variables are defined.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-10803" data-verso-hover="118">section</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-10811" data-verso-hover="89">set_option</span> <a href="Definitions/Headers-and-Signatures/#autoImplicit"><span class="option token" data-binding="option-autoImplicit" data-verso-hover="245">autoImplicit</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-10811" data-verso-hover="89">false</span>
<a href="The-Type-System/Universes/#Lean___Parser___Command___universe-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.universe-10841" data-verso-hover="249">universe</span></a> <span class="unknown token" data-binding="">u</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-10852" data-verso-hover="121">variable</span></a> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10867" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Zero___mk"><span class="const token" data-binding="const-Zero" data-verso-hover="826">Zero</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Add___mk"><span class="const token" data-binding="const-Add" data-verso-hover="621">Add</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">Î±</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
                      Because automatic implicit parameters are disabled, the following definition fails:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11056">def</span> <span class="const token" data-binding="const-addAll" data-verso-hover="827">addAll</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="248">lst</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'Î²'</code></span></span><span class="unknown token" data-binding="">Î²</span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'Î²'</code></span></span><span class="unknown token" data-binding="">Î²</span></span> <span class="unknown token" data-binding="">:=</span>
  <span class="var token" data-binding="var-_uniq.15" data-verso-hover="248">lst</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___foldr"><span class="const token" data-binding="const-List.foldr" data-verso-hover="828">foldr</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">init</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="247">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'Î²'
</pre></div>
                    <p>
                      On the other hand, not even <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span></code> needs to be written directly in the definition:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11276">def</span> <span class="const token" data-binding="const-addAll" data-verso-hover="829">addAll</span> <span class="unknown token" data-binding="">:=</span>
  <span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___foldr"><span class="const token" data-binding="const-List.foldr" data-verso-hover="828">foldr</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">init</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="46">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Â·</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">Â·</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  To add a section variable to a theorem even if it is not explicitly mentioned in the statement, mark the variable with the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.include : command</code><span class="sep"></span><code class="docstring">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all
theorems in the remainder of the current section, differing from the default behavior of
conditionally including variables based on use in the theorem header. Other commands are
not affected. `include` is usually followed by `in theorem ...` to limit the inclusion
to the subsequent declaration.
</code></code><code class="kw">include</code></span> command.
All variables marked for inclusion are added to all theorems.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.omit : command</code><span class="sep"></span><code class="docstring">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it
can also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in
which case all instance variables that unify with the given type are omitted. `omit` should usually
only be used in conjunction with `in` in order to keep the section structure simple.
</code></code><code class="kw">omit</code></span> command removes the inclusion mark from a variable; it's typically a good idea to use it with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span>.</p>
                <details class="example"><summary class="description">Included and Omitted Section Variables</summary><div class="example-content">
                    <p>
                      This section's variables include a predicate as well as everything needed to prove that it holds universally, along with a useless extra assumption.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-12063" data-verso-hover="118">section</span></a>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-12071" data-verso-hover="121">variable</span></a> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="830">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">â†’</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-12099" data-verso-hover="121">variable</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.46" data-verso-hover="831">pZero</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="830">p</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="832">pStep</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">â†’</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="830">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<a href="Namespaces-and-Sections/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-12157" data-verso-hover="121">variable</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.202" data-verso-hover="833">pFifteen</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="830">p</span> <span class="typed token" data-binding="" data-verso-hover="7">15</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      However, only <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="830">p</span></code> is added to this theorem's assumptions, so it cannot be proved.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-12317">theorem</span> <span class="const token" data-binding="const-p_all" data-verso-hover="834">p_all</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-7900654738583061598-12347-12349"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
case zero
p : Nat â†’ Prop
âŠ¢ p 0

case succ
p : Nat â†’ Prop
nâœ : Nat
aâœ : p nâœ
âŠ¢ p (nâœ + 1)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-12347" data-verso-hover="10">by</span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7900654738583061598-12347-12349"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.130" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.130" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-2901107005390282279-12352-12359"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-12352" data-verso-hover="659">intro</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2901107005390282279-12352-12359"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-2288354547432366360-12362-12373"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-12362" data-verso-hover="717">induction</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2288354547432366360-12362-12373"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-76" checked="checked"><span for="--verso-unique-76" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-77"><span for="--verso-unique-77" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.121" data-verso-hover="835">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.include : command</code><span class="sep"></span><code class="docstring">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all
theorems in the remainder of the current section, differing from the default behavior of
conditionally including variables based on use in the theorem header. Other commands are
not affected. `include` is usually followed by `in theorem ...` to limit the inclusion
to the subsequent declaration.
</code></code><code class="kw">include</code></span> command causes the additional assumptions to be added unconditionally:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.include-12542" data-verso-hover="836">include</span> <span class="unknown token" data-binding="">pZero</span> <span class="unknown token" data-binding="">pStep</span> <span class="unknown token" data-binding="">pFifteen</span>

<span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">automatically included section variable(s) unused in theorem 'p_all':
  pFifteen
consider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:
  omit pFifteen in theorem ...
note: this linter can be disabled with `set_option linter.unusedSectionVars false`</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-12572">theorem</span></span> <span class="const token" data-binding="const-p_all" data-verso-hover="837">p_all</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-15473931363566042194-12602-12604"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-12602" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15473931363566042194-12602-12604"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="838">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.577" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.577" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5836508971191156253-12607-12614"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-12607" data-verso-hover="659">intro</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5836508971191156253-12607-12614"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="838">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5770899696256825619-12617-12628"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-12617" data-verso-hover="717">induction</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5770899696256825619-12617-12628"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-80" checked="checked"><span for="--verso-unique-80" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="838">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-81"><span for="--verso-unique-81" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="838">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.121" data-verso-hover="835">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-5770899696256825619-12629-12632"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5770899696256825619-12629-12632"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-82" checked="checked"><span for="--verso-unique-82" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="838">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-83"><span for="--verso-unique-83" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="838">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="830">pâœ</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.578" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.121" data-verso-hover="835">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">nâœ</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-12633-12641"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-12633" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-12633-12641"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                      Because the spurious assumption <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="833">pFifteen</span></code> was inserted, Lean issues a warning:</p>
                    <div class="warning">
                      <pre>automatically included section variable(s) unused in theorem 'p_all':
  pFifteen
consider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:
  omit pFifteen in theorem ...
note: this linter can be disabled with `set_option linter.unusedSectionVars false`
</pre></div>
                    <p>
                      This can be avoided by using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.omit : command</code><span class="sep"></span><code class="docstring">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it
can also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in
which case all instance variables that unify with the given type are omitted. `omit` should usually
only be used in conjunction with `in` in order to keep the section structure simple.
</code></code><code class="kw">omit</code></span>to remove <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.45" data-verso-hover="833">pFifteen</span></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.include-13190" data-verso-hover="836">include</span> <span class="unknown token" data-binding="">pZero</span> <span class="unknown token" data-binding="">pStep</span> <span class="unknown token" data-binding="">pFifteen</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.omit-13220" data-verso-hover="839">omit</span> <span class="unknown token" data-binding="">pFifteen</span> <a href="Namespaces-and-Sections/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-13220">in</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-13237">theorem</span> <span class="const token" data-binding="const-p_all" data-verso-hover="840">p_all</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">âˆ€</span> <span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11720856619499974715-13267-13269"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-13267" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11720856619499974715-13267-13269"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.667" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.667" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-12136461684776294292-13272-13279"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-13272" data-verso-hover="659">intro</span></a> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12136461684776294292-13272-13279"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-17726173775398757344-13282-13293"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-13282" data-verso-hover="717">induction</span></a> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17726173775398757344-13282-13293"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-86" checked="checked"><span for="--verso-unique-86" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-87"><span for="--verso-unique-87" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.215" data-verso-hover="835">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">nâœ</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">nâœ</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-17726173775398757344-13294-13297"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17726173775398757344-13294-13297"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-88" checked="checked"><span for="--verso-unique-88" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-89"><span for="--verso-unique-89" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> â†’ <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="831">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="832">pStep</span></span><span class="colon">:</span><span class="type">âˆ€ (<span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span> â†’ <span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.668" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">nâœ</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.215" data-verso-hover="835">aâœ</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">nâœ</span></span></span></span><span class="conclusion"><span class="prefix">âŠ¢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="830">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">nâœ</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-13298-13306"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-13298" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13298-13306"><span class="tactic-state">All goals completed! ðŸ™</span></span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-13320" data-verso-hover="124">end</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Source-Files-and-Modules/#files" rel="prev" title="5. Source Files and Modules"><span class="arrow">â†</span><span class="where">5. Source Files and Modules</span></a><a class="local-button active" href="Definitions/#definitions" rel="next" title="7. Definitions"><span class="where">7. Definitions</span><span class="arrow">â†’</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

