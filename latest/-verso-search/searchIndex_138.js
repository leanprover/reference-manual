window.docContents[138].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Searching":{"contents":"Checks whether a slice has a match of the pattern pat anywhere.This function is generic over all currently supported patterns.Examples:* \"coffee tea water\".toSlice.contains Char.isWhitespace = true* \"tea\".toSlice.contains (fun (c : Char) => c == 'X') = false* \"coffee tea water\".toSlice.contains \"tea\" = true\n\nChecks whether the slice (s) begins with the pattern (pat).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.startsWith \"red\" = true* \"red green blue\".toSlice.startsWith \"green\" = false* \"red green blue\".toSlice.startsWith \"\" = true* \"red green blue\".toSlice.startsWith 'r' = true* \"red green blue\".toSlice.startsWith Char.isLower = true\n\nChecks whether the slice (s) ends with the pattern (pat).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.endsWith \"blue\" = true* \"red green blue\".toSlice.endsWith \"green\" = false* \"red green blue\".toSlice.endsWith \"\" = true* \"red green blue\".toSlice.endsWith 'e' = true* \"red green blue\".toSlice.endsWith Char.isLower = true\n\nChecks whether a slice only consists of matches of the pattern pat.Short-circuits at the first pattern mis-match.This function is generic over all currently supported patterns.Examples:* \"brown\".toSlice.all Char.isLower = true* \"brown and orange\".toSlice.all Char.isLower = false* \"aaaaaa\".toSlice.all 'a' = true* \"aaaaaa\".toSlice.all \"aa\" = true* \"aaaaaaa\".toSlice.all \"aa\" = false\n\nFinds the position of the first match of the pattern pat in a slice s. If there\nis no match none is returned.This function is generic over all currently supported patterns.Examples:* (\"coffee tea water\".toSlice.find? Char.isWhitespace).map (·.get!) == some ' '* \"tea\".toSlice.find? (fun (c : Char) => c == 'X') == none* (\"coffee tea water\".toSlice.find? \"tea\").map (·.get!) == some 't'\n\nFinds the position of the first match of the pattern pat in a slice, starting\nfrom the end of the slice and traversing towards the start. If there is no match none is\nreturned.This function is generic over all currently supported patterns except\nString/String.Slice.Examples:* (\"coffee tea water\".toSlice.revFind? Char.isWhitespace).map (·.get!) == some ' '* \"tea\".toSlice.revFind? (fun (c : Char) => c == 'X') == none\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"20.8.4.11.1.7. Searching","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Searching"},"/Elaboration-and-Compilation/#parser":{"contents":"Lean's parser is a recursive-descent parser that uses dynamic tables based on Pratt parsing to resolve operator precedence and associativity.\nWhen grammars are unambiguous, the parser does not need to backtrack; in the case of ambiguous grammars, a memoization table similar to that used in Packrat parsing avoids exponential blowup.\nParsers are highly extensible: users may define new syntax in any command, and that syntax becomes available in the next command.\nThe open namespaces in the current section scope also influence which parsing rules are used, because parser extensions may be set to be active only when a given namespace is open.\n\nWhen ambiguity is encountered, the longest matching parse is selected.\nIf there is no unique longest match, then both matching parses are saved in the syntax tree in a choice node to be resolved later by the elaborator.\nWhen the parser fails, it returns a Syntax.missing node, allowing for error recovery.\n\nWhen successful, the parser saves sufficient information to reconstruct the original source file.\nUnsuccessful parses may miss some information for the regions of the file that cannot be parsed.\nThe SourceInfo record type records information about the origin of a piece of syntax, including its source location and the surrounding whitespace.\nBased on the SourceInfo field, there are three relationships that Syntax can have to a source file:\n\n* SourceInfo.original indicates that the syntax value was produced directly by the parser.* SourceInfo.synthetic indicates that the syntax value was produced programmatically, e.g. by the macro expander. Synthetic syntax may nonetheless be marked canonical, in which case the Lean user interface treats it as if the user had written it. Synthetic syntax is annotated with positions in the original file, but does not include leading or trailing whitespace.* SourceInfo.none indicates no relationship to a file.\n\nThe parser maintains a token table that tracks the reserved words that are currently part of the language.\nDefining new syntax or opening namespaces can cause a formerly-valid identifier to become a keyword.\n\nEach production in Lean's grammar is named.\nThe name of a production is called its kind.\nThese syntax kinds are important, because they are the key used to look up the interpretation of the syntax in the elaborator's tables.\n\nSyntax extensions are described in more detail in a dedicated chapter.\n\n","context":"Lean Reference\u0009Elaboration and Compilation","header":"2.1. Parsing","id":"/Elaboration-and-Compilation/#parser"},"/Error-Explanations/About___--inductionWithNoAlts/#The-Lean-Language-Reference--Error-Explanations--About___--inductionWithNoAlts--Examples":{"contents":"Adding Explicit Cases to an Induction Prooftheorem zero_mul (m : Nat) : 0 * m = 0 := by\n  induction m with n n_ih\n  rw [Nat.mul_zero]\n  rw [Nat.mul_succ]\n  rw [Nat.add_zero]\n  rw [n_ih]\nInvalid syntax for induction tactic: The `with` keyword must be followed by a tactic or by an alternative (e.g. `| zero =>`), but here it is followed by the identifier `n`.\ntheorem zero_mul (m : Nat) : 0 * m = 0 := by\n  induction m with\n  | zero =>\n    rw [Nat.mul_zero]\n  | succ n n_ih =>\n    rw [Nat.mul_succ]\n    rw [Nat.add_zero]\n    rw [n_ih]\nThe broken example has the structure of a correct proof in the Natural Numbers Game, and this\nproof will work if you import Mathlib and replace induction with induction'. Induction tactics\nin basic Lean expect the with keyword to be followed by a series of cases, and the names\nfor the inductive case are provided in the succ case rather than being provided\nup-front.\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  inductionWithNoAlts","header":"Examples","id":"/Error-Explanations/About___--inductionWithNoAlts/#The-Lean-Language-Reference--Error-Explanations--About___--inductionWithNoAlts--Examples"},"/Notations-and-Macros/Defining-New-Syntax/#syntax-categories":{"contents":"Lean's parser contains a table of syntax categories, which correspond to nonterminals in a context-free grammar.\nSome of the most important categories are terms, commands, universe levels, priorities, precedences, and the categories that represent tokens such as literals.\nTypically, each syntax kind corresponds to a category.\nNew categories can be declared using declare_syntax_cat.\n\nDeclaring Syntactic CategoriesDeclares a new syntactic category.\n\nThe leading identifier behavior is an advanced feature that usually does not need to be modified.\nIt controls the behavior of the parser when it encounters an identifier, and can sometimes cause the identifier to be treated as a non-reserved keyword instead.\nThis is used to avoid turning the name of every tactic into a reserved keyword.\n\nSpecifies how the parsing table lookup function behaves for identifiers.The function Lean.Parser.prattParser uses two tables: one each for leading and trailing parsers.\nThese tables map tokens to parsers. Because keyword tokens are distinct from identifier tokens,\nkeywords and identifiers cannot be confused, even when they are syntactically identical.\nSpecifying an alternative leading identifier behavior allows greater flexibility and makes it\npossible to avoid reserved keywords in some situations.When the leading token is syntactically an identifier, the current syntax category's\nLeadingIdentBehavior specifies how the parsing table lookup function behaves, and allows\ncontrolled “punning” between identifiers and keywords. This feature is used to avoid creating a\nreserved symbol for each built-in tactic (e.g., apply or assumption). As a result, tactic names\ncan be used as identifiers.If the leading token is an identifier, then the parser just executes the parsers associated\nwith the auxiliary token “ident”, which parses identifiers.If the leading token is an identifier <foo>, and there are parsers P associated with the token\n<foo>, then the parser executes P. Otherwise, it executes only the parsers associated with the\nauxiliary token “ident”, which parses identifiers.If the leading token is an identifier <foo>, then it executes the parsers associated with token\n<foo> and parsers associated with the auxiliary token “ident”, which parses identifiers.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"23.4.10. Syntax Categories","id":"/Notations-and-Macros/Defining-New-Syntax/#syntax-categories"},"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax":{"contents":"Syntax may additionally be annotated with a type that specifies which syntax category it belongs to.\n\nThe TSyntax structure contains a type-level list of syntax categories along with a syntax tree.\nThe list of syntax categories typically contains precisely one element, in which case the list structure itself is not shown.\n\nTyped syntax, which tracks the potential kinds of the Syntax it contains.While syntax quotations produce or expect TSyntax values of the correct kinds, this is not\notherwise enforced; it can easily be circumvented by direct use of the constructor.The underlying Syntax value.\n\nSyntaxNodeKinds is a set of SyntaxNodeKind, implemented as a list.Singleton SyntaxNodeKinds are extremely common. They are written as name literals, rather than as\nlists; list syntax is required only for empty or non-singleton sets of kinds.\n\nQuasiquotations prevent the substitution of typed syntax that does not come from the correct syntactic category.\nFor many of Lean's built-in syntactic categories, there is a set of coercions that appropriately wrap one kind of syntax for another category, such as a coercion from the syntax of string literals to the syntax of terms.\nAdditionally, many helper functions that are only valid on some syntactic categories are defined for the appropriate typed syntax only.\n\n\n\nThe constructor of TSyntax is public, and nothing prevents users from constructing values that break internal invariants.\nThe use of TSyntax should be seen as a way to reduce common mistakes, rather than rule them out entirely.\n\nIn addition to TSyntax, there are types that represent arrays of syntax, with or without separators.\nThese correspond to  repeated elements in syntax declarations or antiquotations.\n\nAn array of syntaxes of kind ks.\n\nAn array of syntax elements that alternate with the given separator. Each syntax element has a kind\ndrawn from ks.Separator arrays result from repetition operators such as ,*.\nCoercions to and from Array (TSyntax ks) insert or remove\nseparators as required. The untyped equivalent is Lean.Syntax.SepArray.The array of elements and separators, ordered like\n#[el1, sep1, el2, sep2, el3].\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"23.4.7. Typed Syntax","id":"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-iteration":{"contents":"iterate n tac runs tac exactly n times.\niterate tac runs tac repeatedly until failure.iterate's argument is a tactic sequence,\nso multiple tactics can be run using iterate n (tac₁; tac₂; ⋯) oriterate n\n  tac₁\n  tac₂\n  ⋯\n\n\nrepeat tac repeatedly applies tac so long as it succeeds.\nThe tactic tac may be a tactic sequence, and if tac fails at any point in its execution,\nrepeat will revert any partial changes that tac made to the tactic state.The tactic tac should eventually fail, otherwise repeat tac will run indefinitely.See also:* try tac is like repeat tac but will apply tac at most once.* repeat' tac recursively applies tac to each goal.* first | tac1 | tac2 implements the backtracking used by repeat\n\nrepeat' tac recursively applies tac on all of the goals so long as it succeeds.\nThat is to say, if tac produces multiple subgoals, then repeat' tac is applied to each of them.See also:* repeat tac simply repeatedly applies tac.* repeat1' tac is repeat' tac but requires that tac succeed for some goal at least once.\n\nrepeat1' tac recursively applies to tac on all of the goals so long as it succeeds,\nbut repeat1' tac fails if tac succeeds on none of the initial goals.See also:* repeat tac simply applies tac repeatedly.* repeat' tac is like repeat1' tac but it does not require that tac succeed at least once.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures","header":"14.3.1.5. Repetition and Iteration","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-iteration"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Language":{"contents":"* #11553 makes simpH, used in the match equation generator, produce a\n  proof term. This is in preparation for a bigger refactoring in #11512.* #11666 makes sure that when a matcher is compiled using a sparse cases,\n  that equation generation also uses sparse cases to split.\n  This fixes #11665.* #11669 makes sure that proofs about ctorIdx passed to grind pass\n  the debug.grind checks, despite reducing a semireducible definition.* #11670 fixes the grind support for Nat.ctorIdx. Nat constructors\n  appear in grind as offsets or literals, and not as a node marked\n  .constr, so handle that case as well.* #11673 fixes an issue where a by in the public scope could create an\n  auxiliary theorem for the proof whose type does not match the expected\n  type in the public scope.* #11696 improves match generalization such that it abstracts\n  metavariables in types of local variables and in the result type of the\n  match over the match discriminants. Previously, a metavariable in the\n  result type would silently default to the behavior of generalizing :=\n  false, and a metavariable in the type of a free variable would lead to\n  an error (#8099). Example of a match that elaborates now but\n  previously wouldn't:example (a : Nat) (ha : a = 37) :=\n    (match a with | 42 => by contradiction | n => n) = 37\nThis is because the result type of the match is a metavariable that\n  was not abstracted over a and hence generalization failed; the result\n  is that contradiction cannot pick up the proof ha : 42 = 37.\n  The old behavior can be recovered by passing (generalizing := false)\n  to the match.* #11698 makes mvcgen early return after simplifying discriminants,\n  avoiding a rewrite on an ill-formed match.* #11714 gives a focused error message when a user tries to name an\n  example, and tweaks error messages for attempts to define multiple\n  opaque names at once.* #11718 adds a test for issue #11655, which it seems was fixed by #11695* #11721 improves the performance of the functions for generating\n  congruence lemmas, used by simp\n  and a few other components.* #11726 upstreams dependency-management commands from Mathlib:* #import_path Foo prints the transitive import chain that brings\n  Foo into scope* assert_not_exists Foo errors if declaration Foo exists (for\n  dependency management)* assert_not_imported Module warns if Module is transitively\n  imported* #check_assertions verifies all pending assertions are eventually\n  satisfied* #11731 makes the cache in expreqfn use mimalloc for a small\n  performance win across the board.* #11748 fixes an edge case where some tactics did not allow access to\n  private declarations inside private proofs under the module system* #11756 fixes an issue where grind fails when trying to unfold a\n  definition by pattern matching imported by import all (or from a\n  non-module).* #11780 ensures that pretty-printing of unification hints inserts a\n  space after |- resp. ⊢.* #11871 makes mvcgen with tac fail if tac fails on one of the VCs,\n  just as induction ... with tac fails if tac fails on one of the\n  goals. The old behavior can be recovered by writing mvcgen with try\n  tac instead.* #11875 adds the directory Meta/DiscrTree and reorganizes the code\n  into different files. Motivation: we are going to have new functions for\n  retrieving simplification theorems for the new structural simplifier.* #11882 adds a guard to TagDeclarationExtension.tag to check if the\n  declaration name is anonymous and return early if so. This prevents a\n  panic that could occur when modifiers like meta or noncomputable are\n  used in combination with syntax errors.* #11896 fixes a panic that occurred when a theorem had a docstring on an\n  auxiliary definition within a where clause.* #11908 adds two features to the message testing commands:\n  a new #guard_panic command that succeeds if the nested command produces\n  a panic message (useful for testing commands expected to panic), and a\n  substring := true option for #guard_msgs that checks if the docstring\n  appears as a substring of the output rather than requiring an exact match.* #11919 improves the error message when initialize (or opaque) fails\n  to find an Inhabited or Nonempty instance.* #11926 adds an unsafe modifier to an existing helper function user\n  unsafeEIO, and also leaves the function private.* #11933 adds utility functions for managing the message log during\n  tactic\n  evaluation, and refactors existing code to use them.* #11940 fixes module system visibiltity issues when trying to declare a\n  public inductive inside a mutual block.* #11941 reverts #11696.* #11991 fixes declare_syntax_cat declaring a local category leading to\n  import errors when used in module without public section.* #12026 fixes an issue where attributes like @[irreducible] would not\n  be allowed under the module system unless combined with @[exposed],\n  but the former may be helpful without the latter to ensure downstream\n  non-modules are also affected.* #12045 disables the import all check across package boundaries. Now\n  any module can import all any other module.* #12048 fixes a bug where mvcgen loses VCs, resulting in unassigned\n  metavariables. It is fixed by making all emitted VCs synthetic opaque.* #12122 adds support for Verso docstrings in where clauses.* #12148 reverts #12000, which introduced a regression where simp\n  incorrectly rejects valid rewrites for perm lemmas.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0-rc1 (2026-01-26)","header":"Language","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Language"}});