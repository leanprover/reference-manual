window.docContents[8].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Creation":{"contents":"Creates a new empty tree map. It is also possible and recommended to\nuse the empty collection notations ∅ and {} to create an empty tree map. simp replaces\nempty with ∅.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"20.19.9.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Creation"},"/Interacting-with-Lean/#hash-eval":{"contents":"The #eval command is used to run code as a program.\nIn particular, it is capable of executing IO actions, it uses a call-by-value evaluation strategy, partial functions are executed, and both types and proofs are erased.\nUse #reduce to instead reduce terms using the reduction rules that are part of definitional equality.\n\nEvaluating Terms#eval e evaluates the expression e by compiling and evaluating it.* The command attempts to use ToExpr, Repr, or ToString instances to print the result.* If e is a monadic value of type m ty, then the command tries to adapt the monad m\nto one of the monads that #eval supports, which include IO, CoreM, MetaM, TermElabM, and CommandElabM.\nUsers can define MonadEval instances to extend the list of supported monads.The #eval command gracefully degrades in capability depending on what is imported.\nImporting the Lean.Elab.Command module provides full capabilities.Due to unsoundness, #eval refuses to evaluate expressions that depend on sorry, even indirectly,\nsince the presence of sorry can lead to runtime instability and crashes.\nThis check can be overridden with the #eval! e command.Options:* If eval.pp is true (default: true) then tries to use ToExpr instances to make use of the\nusual pretty printer. Otherwise, only tries using Repr and ToString instances.* If eval.type is true (default: false) then pretty prints the type of the evaluated value.* If eval.derive.repr is true (default: true) then attempts to auto-derive a Repr instance\nwhen there is no other way to print the result.See also: #reduce e for evaluation by term reduction.\n\n#eval always elaborates and compiles the provided term.\nIt then checks whether the term transitively depends on any uses of sorry, in which case evaluation is terminated unless the command was invoked as #eval!.\nThis is because compiled code may rely on compile-time invariants (such as array lookups being in-bounds) that are ensured by proofs of suitable statements, and running code that contains incomplete proofs (or uses of sorry that “prove” incorrect statements) can cause Lean itself to crash.\n\n\n\nThe way the code is run depends on its type:* If the type is in the IO monad, then it is executed in a context where standard output and standard error are captured and redirected to the Lean message log.\n   If the returned value's type is not Unit, then it is displayed as if it were the result of a non-monadic expression.* If the type is in one of the internal Lean metaprogramming monads (CommandElabM, TermElabM, MetaM, or CoreM), then it is run in the current context.\n    For example, the environment will contain the definitions that are in scope where #eval is invoked.\n    As with IO, the resulting value is displayed as if it were the result of a non-monadic expression.\n    When Lean is running under Lake, its working directory (and thus the working directory for IO actions) is the current workspace.* If the type is in some other monad m, and there is a MonadLiftT m CommandElabM or MonadEvalT m CommandElabM instance, then MonadLiftT.monadLift or MonadEvalT.monadEval is used to transform the monad into one that may be run with #eval, after which it is run as usual.* If the term's type is not in any of the supported monads, then it is treated as a pure value.\n  The compiled code is run, and the result is displayed.Auxiliary definitions or other environment modifications that result from elaborating the term in #eval are discarded.\nIf the term is an action in a metaprogramming monad, then changes made to the environment by running the monadic action are preserved.\n\n\n\n\n\nResults are displayed using a ToExpr, ToString, or Repr instance, if they exist.\nIf not, and eval.derive.repr is true, Lean attempts to derive a suitable Repr instance.\nIt is an error if no suitable instance can be found or derived.\nSetting eval.pp to false disables the use of ToExpr instances by #eval.\n\nDisplaying Output#eval cannot display functions:#eval fun x => x + 1\ncould not synthesize a `ToExpr`, `Repr`, or `ToString` instance for type\n  Nat → Nat\nIt is capable of deriving instances to display output that has no ToString or Repr instance:inductive Quadrant where\n  | nw | sw | se | ne\n\n#eval Quadrant.nw\nQuadrant.nw\nThe derived instance is not saved.\nDisabling eval.derive.repr causes #eval to fail:set_option eval.derive.repr false\n#eval Quadrant.nw\ncould not synthesize a `ToExpr`, `Repr`, or `ToString` instance for type\n  Quadrant\n\n\n('#eval' command) enables using 'ToExpr' instances to pretty print the result, otherwise uses 'Repr' or 'ToString' instances\n\n('#eval' command) enables pretty printing the type of the result\n\n('#eval' command) enables auto-deriving 'Repr' instances as a fallback\n\nMonads can be given the ability to execute in #eval by defining a suitable MonadLiftMonadLift is described in the section on lifting monads. or MonadEval instance.\nJust as MonadLiftT is the transitive closure of MonadLift instances, MonadEvalT is the transitive closure of MonadEval instances.\nAs with MonadLiftT users should not define additional instances of MonadEvalT directly.\n\nTypeclass used for adapting monads. This is similar to MonadLift, but instances are allowed to\nmake use of default state for the purpose of synthesizing such an instance, if necessary.\nEvery MonadLift instance gives a MonadEval instance.The purpose of this class is for the #eval command,\nwhich looks for a MonadEval m CommandElabM or MonadEval m IO instance.Evaluates a value from monad m into monad n.\n\nThe transitive closure of MonadEval.Evaluates a value from monad m into monad n.\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.1. Evaluating Terms","id":"/Interacting-with-Lean/#hash-eval"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-change":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"14.6.4. Changing the Goal","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-change"},"/The-Type-System/Inductive-Types/#well-formed-inductives":{"contents":"Inductive type declarations are subject to a number of well-formedness requirements.\nThese requirements ensure that Lean remains consistent as a logic when it is extended with the inductive type's new rules.\nThey are conservative: there exist potential inductive types that do not undermine consistency, but that these requirements nonetheless reject.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model","header":"4.4.3.2. Well-Formedness Requirements","id":"/The-Type-System/Inductive-Types/#well-formed-inductives"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Boolean-Equality-Tests":{"contents":"The Boolean equality operator == is overloaded by defining instances of BEq.\nThe companion class Hashable specifies a hashing procedure for a type.\nWhen a type has both BEq and Hashable instances, then the hashes computed should respect the BEq instance: two values equated by BEq.beq should always have the same hash.\n\nBEq α is a typeclass for supplying a boolean-valued equality relation on\nα, notated as a == b. Unlike DecidableEq α (which uses a = b), this\nis Bool valued instead of Prop valued, and it also does not have any\naxioms like being reflexive or agreeing with =. It is mainly intended for\nprogramming applications. See LawfulBEq for a version that requires that\n== and = coincide.Typically we prefer to put the \"more variable\" term on the left,\nand the \"more constant\" term on the right.Boolean equality, notated as a == b.Conventions for notations in identifiers:* The recommended spelling of == in identifiers is beq.\n\nTypes that can be hashed into a UInt64.Hashes a value into a UInt64.\n\nAn opaque hash mixing operation, used to implement hashing for products.\n\nA Boolean equality test coincides with propositional equality.In other words:* a == b implies a = b.* a == a is true.If a == b evaluates to true, then a and b are equal in the logic.\n\nReflBEq α says that the BEq implementation is reflexive.== is reflexive, that is, (a == a) = true.\n\nEquivBEq says that the BEq implementation is an equivalence relation.\n\nThe BEq α and Hashable α instances on α are compatible. This means that a == b implies\nhash a = hash b.This is automatic if the BEq instance is lawful.If a == b, then hash a = hash b.\n\nA lawful hash function respects its Boolean equality test.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"10.5.1. Boolean Equality Tests","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Boolean-Equality-Tests"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Apply-___try-this___-Suggestions":{"contents":"#10524 adds support for interactivity (hover, go-to-definitions) for \"try this\"\nmessages that were introduced in #9966. In doing so, it moves the link\nto apply a suggestion to a separate [apply] button in front of the\nsuggestion.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Apply \"try this\" Suggestions","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Apply-___try-this___-Suggestions"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Library":{"contents":"* #11257 adds the definition of BitVec.cpop, which relies on the more\n  general BitVec.cpopNatRec, and build some theory around it. The name\n  cpop aligns with the RISCV ISA\n  nomenclature.* #11438 renames the namespace Std.Range to Std.Legacy.Range. Instead\n  of using Std.Range and [a:b] notation, the new range type Std.Rco\n  and its corresponding a...b notation should be used. There are also\n  other ranges with open/closed/infinite boundary shapes in\n  Std.Data.Range.Polymorphic and the new range notation also works for\n  Int, Int8, UInt8, Fin etc.* #11446 moves many constants of the iterator API from Std.Iterators to\n  the Std namespace in order to make them more convenient to use. These\n  constants include, but are not limited to, Iter, IterM and\n  IteratorLoop. This is a breaking change. If something breaks, try\n  adding open Std in order to make these constants available again. If\n  some constants in the Std.Iterators namespace cannot be found, they\n  can be found directly in Std now.* #11499 adds the Context type for cancellation with context\n  propagation. It works by storing a tree of forks of the main context,\n  providing a way to control cancellation.* #11532 adds the new operation MonadAttach.attach that attaches a\n  proof that a postcondition holds to the return value of a monadic\n  operation. Most non-CPS monads in the standard library support this\n  operation in a nontrivial way. The PR also changes the filterMapM,\n  mapM and flatMapM combinators so that they attach postconditions to\n  the user-provided monadic functions passed to them. This makes it\n  possible to prove termination for some of these for which it wasn't\n  possible before. Additionally, the PR adds many missing lemmas about\n  filterMap(M) and map(M) that were needed in the course of this PR.* #11693 makes it possible to verify loops over iterators. It provides\n  MPL spec lemmas about for loops over pure iterators. It also provides\n  spec lemmas that rewrite loops over mapM, filterMapM or filterM\n  iterator combinators into loops over their base iterator.* #11705 provides many lemmas about Int ranges, in analogy to those\n  about Nat ranges. A few necessary basic Int lemmas are added. The PR\n  also removes simp annotations on Rcc.toList_eq_toList_rco,\n  Nat.toList_rcc_eq_toList_rco and consorts.* #11706 removes the IteratorCollect type class and hereby simplifies\n  the iterator API. Its limited advantages did not justify the complexity\n  cost.* #11710 extends the get-elem tactic for ranges so that it supports\n  subarrays. Example:example {a : Array Nat} (h : a.size = 28) : Id Unit := do\n  let mut x := 0\n  for h : i in *...(3 : Nat) do\n    x := a[1...4][i]\n* #11716 adds more MPL spec lemmas for all combinations of for loops,\n  fold(M) and the filter(M)/filterMap(M)/map(M) iterator combinators.\n  These kinds of loops over these combinators (e.g. it.mapM) are first\n  transformed into loops over their base iterators (it), and if the base\n  iterator is of type Iter _ or IterM Id _, then another spec lemma\n  exists for proving Hoare triples about it using an invariant and the\n  underlying list (it.toList). The PR also fixes a bug that MPL always\n  assigns the default priority to spec lemmas if Std.Tactic.Do.Syntax is\n  not imported and a bug that low-priority lemmas are preferred about\n  high-priority ones.* #11724 adds more event_loop_locks to fix race conditions.* #11728 introduces some additional lemmas around BitVec.extractLsb'\n  and BitVec.extractLsb.* #11760 allows grind to use List.eq_nil_of_length_eq_zero (and\n  Array.eq_empty_of_size_eq_zero), but only when it has already proved\n  the length is zero.* #11761 adds some grind_pattern guard conditions to potentially\n  expensive theorems.* #11762 moves the grind pattern from Sublist.eq_of_length to the\n  slightly more general Sublist.eq_of_length_le, and adds a grind\n  pattern guard so it only activates if we have a proof of the hypothesis.* #11767 introduces two induction principles for bitvectors, based on the\n  concat and cons operations. We show how this principle can be useful to\n  reason about bitvectors by refactoring two population count lemmas\n  (cpopNatRec_zero_le and toNat_cpop_append) and introducing a new\n  lemma (toNat_cpop_not).\n  To use the induction principle we also move cpopNatRec_cons_of_le and\n  cpopNatRec_cons_of_lt earlier in the popcount section (they are the\n  building blocks enabling us to take advantage of the new induction\n  principle).* #11772 fixes a bug in the optimized and unsafe implementation of\n  Array.foldlM.* #11774 fixes a mismatch between the behavior of foldlM and\n  foldlMUnsafe in the three array\n  types. This mismatch is only exposed when manually specifying a stop\n  value greater than the size\n  of the array and only exploitable through native_decide.* #11779 fixes an oversight in the initial #11772 PR.* #11784 just adds an optional start position argument to\n  PersistentArray.forM* #11789 makes the FinitenessRelation structure, which is helpful when\n  proving the finiteness of iterators, part of the public API. Previously,\n  it was marked internal and experimental.* #11794 implements the function getMaxFVar? for implementing SymM\n  primitives.* #11834 adds num? parameter to mkPatternFromTheorem to control how\n  many leading quantifiers are stripped when creating a pattern. This\n  enables matching theorems where only some quantifiers should be\n  converted to pattern variables.* #11848 fixes a bug at Name.beq reported by\n  gasstationcodemanager@gmail.com* #11852 changes the definition of the iterator combinators takeWhileM\n  and dropWhileM so that they use MonadAttach. This is only relevant\n  in rare cases, but makes it sometimes possible to prove such combinators\n  finite when the finiteness depends on properties of the monadic\n  predicate.* #11901 adds gcd_left_comm lemmas for both Nat and Int:* Nat.gcd_left_comm: gcd m (gcd n k) = gcd n (gcd m k)* Int.gcd_left_comm: gcd a (gcd b c) = gcd b (gcd a c)* #11905 provides a Decidable instance for Nat.isPowerOfTwo based on\n  the formula (n ≠ 0) ∧ (n &&& (n - 1)) = 0.* #11907 implements PersistentHashMap.findKeyD and\n  PersistentHashSet.findD. The motivation is avoid two memory\n  allocations (Prod.mk and Option.some) when the collections contains\n  the key.* #11945 changes the runtime implementation of the Decidable (xs = #[])\n  and Decidable (#[] = xs) instances to use Array.isEmpty. Previously,\n  decide (xs = #[]) would first convert xs into a list and then\n  compare it against List.nil.* #11979 adds suggest_for annotations such that Int*.toNatClamp is\n  suggested for Int*.toNat.* #11989 removes a leftover example from\n  src/Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Clz.lean.* #11993 adds grind annotations to the lemmas about Subarray and\n  ListSlice.* #12058 implements iteration over ranges for Fin and Char.* #12139 adds «term_⁻¹» to the recommended_spelling for inv,\n  matching\n  the pattern used by all other operators which include both the function\n  and the syntax in their spelling lists.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0 (2026-01-26)","header":"Library","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Library"}});