window.docContents[123].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Boundaries--Adjustment":{"contents":"Given a slice and a valid position within the slice, obtain a new slice on the same underlying\nstring by replacing the start of the slice with the given position.\n\nGiven a slice and a valid position within the slice, obtain a new slice on the same underlying\nstring by replacing the end of the slice with the given position.\n\nGiven a slice and two valid positions within the slice, obtain a new slice on the same underlying\nstring formed by the new bounds.\n\nGiven a slice and two valid positions within the slice, obtain a new slice on the same underlying\nstring formed by the new bounds, or panic if the given end is strictly less than the given start.\n\nRemoves the specified number of characters (Unicode code points) from the start of the slice.If n is greater than the amount of characters in s, returns an empty slice.Examples:* \"red green blue\".toSlice.drop 4 == \"green blue\".toSlice* \"red green blue\".toSlice.drop 10 == \"blue\".toSlice* \"red green blue\".toSlice.drop 50 == \"\".toSlice\n\nRemoves the specified number of characters (Unicode code points) from the end of the slice.If n is greater than the amount of characters in s, returns an empty slice.Examples:* \"red green blue\".toSlice.dropEnd 5 == \"red green\".toSlice* \"red green blue\".toSlice.dropEnd 11 == \"red\".toSlice* \"red green blue\".toSlice.dropEnd 50 == \"\".toSlice\n\nCreates a new slice that contains the longest suffix of s for which pat matched\n(potentially repeatedly).Examples:* \"red green blue\".toSlice.dropEndWhile Char.isLower == \"red green \".toSlice* \"red green blue\".toSlice.dropEndWhile 'e' == \"red green blu\".toSlice* \"red green blue\".toSlice.dropEndWhile (fun (_ : Char) => true) == \"\".toSlice\n\nIf pat matches a prefix of s, returns the remainder. Returns s unmodified\notherwise.Use String.Slice.dropPrefix? to return none when pat does not match a prefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropPrefix \"red \" == \"green blue\".toSlice* \"red green blue\".toSlice.dropPrefix \"reed \" == \"red green blue\".toSlice* \"red green blue\".toSlice.dropPrefix 'r' == \"ed green blue\".toSlice* \"red green blue\".toSlice.dropPrefix Char.isLower == \"ed green blue\".toSlice\n\nIf pat matches a prefix of s, returns the remainder. Returns none otherwise.Use String.Slice.dropPrefix to return the slice\nunchanged when pat does not match a prefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropPrefix? \"red \" == some \"green blue\".toSlice* \"red green blue\".toSlice.dropPrefix? \"reed \" == none* \"red green blue\".toSlice.dropPrefix? 'r' == some \"ed green blue\".toSlice* \"red green blue\".toSlice.dropPrefix? Char.isLower == some \"ed green blue\".toSlice\n\nIf pat matches a suffix of s, returns the remainder. Returns s unmodified\notherwise.Use String.Slice.dropSuffix? to return none when pat does not match a\nprefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropSuffix \" blue\" == \"red green\".toSlice* \"red green blue\".toSlice.dropSuffix \"bluu \" == \"red green blue\".toSlice* \"red green blue\".toSlice.dropSuffix 'e' == \"red green blu\".toSlice* \"red green blue\".toSlice.dropSuffix Char.isLower == \"red green blu\".toSlice\n\nIf pat matches a suffix of s, returns the remainder. Returns none otherwise.Use String.Slice.dropSuffix to return the slice\nunchanged when pat does not match a prefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropSuffix? \" blue\" == some \"red green\".toSlice* \"red green blue\".toSlice.dropSuffix? \"bluu \" == none* \"red green blue\".toSlice.dropSuffix? 'e' == some \"red green blu\".toSlice* \"red green blue\".toSlice.dropSuffix? Char.isLower == some \"red green blu\".toSlice\n\nCreates a new slice that contains the longest prefix of s for which pat matched\n(potentially repeatedly).Examples:* \"red green blue\".toSlice.dropWhile Char.isLower == \" green blue\".toSlice* \"red green blue\".toSlice.dropWhile 'r' == \"ed green blue\".toSlice* \"red red green blue\".toSlice.dropWhile \"red \" == \"green blue\".toSlice* \"red green blue\".toSlice.dropWhile (fun (_ : Char) => true) == \"\".toSlice\n\nCreates a new slice that contains the first n characters (Unicode code points) of s.If n is greater than the amount of characters in s, returns s.Examples:* \"red green blue\".toSlice.take 3 == \"red\".toSlice* \"red green blue\".toSlice.take 1 == \"r\".toSlice* \"red green blue\".toSlice.take 0 == \"\".toSlice* \"red green blue\".toSlice.take 100 == \"red green blue\".toSlice\n\nCreates a new slice that contains the last n characters (Unicode code points) of s.If n is greater than the amount of characters in s, returns s.Examples:* \"red green blue\".toSlice.takeEnd 4 == \"blue\".toSlice* \"red green blue\".toSlice.takeEnd 1 == \"e\".toSlice* \"red green blue\".toSlice.takeEnd 0 == \"\".toSlice* \"red green blue\".toSlice.takeEnd 100 == \"red green blue\".toSlice\n\nCreates a new slice that contains the suffix prefix of s for which pat matched\n(potentially repeatedly).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.takeEndWhile Char.isLower == \"blue\".toSlice* \"red green blue\".toSlice.takeEndWhile 'e' == \"e\".toSlice* \"red green blue\".toSlice.takeEndWhile (fun (_ : Char) => true) == \"red green blue\".toSlice\n\nCreates a new slice that contains the longest prefix of s for which pat matched\n(potentially repeatedly).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.takeWhile Char.isLower == \"red\".toSlice* \"red green blue\".toSlice.takeWhile 'r' == \"r\".toSlice* \"red red green blue\".toSlice.takeWhile \"red \" == \"red red \".toSlice* \"red green blue\".toSlice.takeWhile (fun (_ : Char) => true) == \"red green blue\".toSlice\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference\u0009Boundaries","header":"20.8.4.11.1.3.1. Adjustment","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Boundaries--Adjustment"},"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Managing--let--Expressions":{"contents":"Extracts let and have expressions from within the target or a local hypothesis,\nintroducing new local definitions.* extract_lets extracts all the lets from the target.* extract_lets x y z extracts all the lets from the target and uses x, y, and z for the first names.\nUsing _ for a name leaves it unnamed.* extract_lets x y z at h operates on the local hypothesis h instead of the target.For example, given a local hypotheses if the form h : let x := v; b x, then extract_lets z at h\nintroduces a new local definition z := v and changes h to be h : b z.\n\nLifts let and have expressions within a term as far out as possible.\nIt is like extract_lets +lift, but the top-level lets at the end of the procedure\nare not extracted as local hypotheses.* lift_lets lifts let expressions in the target.* lift_lets at h lifts let expressions at the given local hypothesis.For example,example : (let x := 1; x) = 1 := by\n  lift_lets\n  -- ⊢ let x := 1; x = 1\n  ...\n\n\nTransforms let expressions into have expressions when possible.* let_to_have transforms lets in the target.* let_to_have at h transforms lets in the given local hypothesis.\n\n* clear_value x... clears the values of the given local definitions.\nA local definition x : α := v becomes a hypothesis x : α.* clear_value (h : x = _) adds a hypothesis h : x = v before clearing the value of x.\nThis is short for have h : x = v := rfl; clear_value x.\nAny value definitionally equal to v can be used in place of _.* clear_value * clears values of all hypotheses that can be cleared.\nFails if none can be cleared.These syntaxes can be combined. For example, clear_value x y * ensures that x and y are cleared\nwhile trying to clear all other local definitions,\nand clear_value (hx : x = _) y * with hx does the same while first adding the hx : x = v hypothesis.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"14.5.10. Managing  let  Expressions","id":"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Managing--let--Expressions"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Documentation":{"contents":"* #7947 adds some docstrings to clarify the functions of\nLean.mkFreshId, Lean.Core.mkFreshUserName,\nLean.Elab.Term.mkFreshBinderName, and\nLean.Meta.mkFreshBinderNameForTactic.* #8018 adjusts the RArray docstring to the new reality from #8014.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Documentation","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Documentation"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Ffi":{"contents":"* #12098 removes the requirement that libraries compiled against the lean\n  headers must use -fwrapv.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0-rc1 (2026-01-26)","header":"Ffi","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-rc1-_LPAR_2026-01-26_RPAR_--Ffi"}});