window.docContents[100].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Iteration":{"contents":"Returns a finite iterator for the given array.\nThe iterator yields the elements of the array in order and then terminates.The monadic version of this iterator is Array.iterM.Termination properties:* Finite instance: always* Productive instance: always\n\nReturns a finite iterator for the given array starting at the given index.\nThe iterator yields the elements of the array in order and then terminates.The monadic version of this iterator is Array.iterFromIdxM.Termination properties:* Finite instance: always* Productive instance: always\n\nReturns a finite monadic iterator for the given array.\nThe iterator yields the elements of the array in order and then terminates. There are no side\neffects.The pure version of this iterator is Array.iter.Termination properties:* Finite instance: always* Productive instance: always\n\nReturns a finite monadic iterator for the given array starting at the given index.\nThe iterator yields the elements of the array in order and then terminates.The pure version of this iterator is Array.iterFromIdx.Termination properties:* Finite instance: always* Productive instance: always\n\nFolds a function over an array from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the array in reverse order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (exclusive) to stop (inclusive), so no folding occurs unless start > stop.\nBy default, the entire array is used.Examples:* #[a, b, c].foldr f init  = f a (f b (f c init))* #[1, 2, 3].foldr (toString ¬∑ ++ ¬∑) \"\" = \"123\"* #[1, 2, 3].foldr (s!\"({¬∑} {¬∑})\") \"!\" = \"(1 (2 (3 !)))\"\n\nFolds a monadic function over an array from the right, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in reverse order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (exclusive) to stop (inclusive), so no folding occurs unless start > stop.\nBy default, the entire array is folded.Examples:example [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ≤) :\n  Array.foldrM (m := m) f x‚ÇÄ #[a, b, c] = (do\n    let x‚ÇÅ ‚Üê f c x‚ÇÄ\n    let x‚ÇÇ ‚Üê f b x‚ÇÅ\n    let x‚ÇÉ ‚Üê f a x‚ÇÇ\n    pure x‚ÇÉ)\n  := by rfl\nexample [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ≤) :\n  Array.foldrM (m := m) f x‚ÇÄ #[a, b, c] (start := 2) = (do\n    let x‚ÇÅ ‚Üê f b x‚ÇÄ\n    let x‚ÇÇ ‚Üê f a x‚ÇÅ\n    pure x‚ÇÇ)\n  := by rfl\n\n\nFolds a function over an array from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the array in order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (inclusive) to stop (exclusive), so no folding occurs unless start < stop.\nBy default, the entire array is used.Examples:* #[a, b, c].foldl f z  = f (f (f z a) b) c* #[1, 2, 3].foldl (¬∑ ++ toString ¬∑) \"\" = \"123\"* #[1, 2, 3].foldl (s!\"({¬∑} {¬∑})\") \"\" = \"((( 1) 2) 3)\"\n\nFolds a monadic function over a list from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in order, using f.The optional parameters start and stop control the region of the array to be folded. Folding\nproceeds from start (inclusive) to stop (exclusive), so no folding occurs unless start < stop.\nBy default, the entire array is folded.Examples:example [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ±) :\n    Array.foldlM (m := m) f x‚ÇÄ #[a, b, c] = (do\n      let x‚ÇÅ ‚Üê f x‚ÇÄ a\n      let x‚ÇÇ ‚Üê f x‚ÇÅ b\n      let x‚ÇÉ ‚Üê f x‚ÇÇ c\n      pure x‚ÇÉ)\n  := by rfl\nexample [Monad m] (f : Œ± ‚Üí Œ≤ ‚Üí m Œ±) :\n    Array.foldlM (m := m) f x‚ÇÄ #[a, b, c] (start := 1) = (do\n      let x‚ÇÅ ‚Üê f x‚ÇÄ b\n      let x‚ÇÇ ‚Üê f x‚ÇÅ c\n      pure x‚ÇÇ)\n  := by rfl\n\n\nApplies the monadic action f to each element of an array, in order.The optional parameters start and stop control the region of the array to which f should be\napplied. Iteration proceeds from start (inclusive) to stop (exclusive), so f is not invoked\nunless start < stop. By default, the entire array is used.\n\nApplies the monadic action f to each element of an array from right to left, in reverse order.The optional parameters start and stop control the region of the array to which f should be\napplied. Iteration proceeds from start (exclusive) to stop (inclusive), so no f is not invoked\nunless start > stop. By default, the entire array is used.\n\nMaps f over the array and collects the results with <|>. The result for the end of the array is\nfailure.Examples:* #[[], [1, 2], [], [2]].firstM List.head? = some 1* #[[], [], []].firstM List.head? = none* #[].firstM List.head? = none\n\nComputes the sum of the elements of an array.Examples:* #[a, b, c].sum = a + (b + (c + 0))* #[1, 2, 5].sum = 8\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"20.16.4.8. Iteration","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Iteration"},"/Basic-Types/Maps-and-Sets/#ExtHashMap":{"contents":"The declarations in this section should be imported using import Std.ExtHashMap.\n\nHash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.In contrast to regular hash maps, Std.ExtHashMap offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over hash maps.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.HashMap.Raw and\nStd.HashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nHashMap or ExtHashMap over HashMap.Raw.Dependent hash maps, in which keys may occur in their values' types, are available as\nStd.ExtDHashMap in the module Std.Data.ExtDHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"20.19.4. Extensional Hash Maps","id":"/Basic-Types/Maps-and-Sets/#ExtHashMap"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Validity":{"contents":"Returns true if p is a valid UTF-8 position in the string s.This means that p ‚â§ s.rawEndPos and p lies on a UTF-8 character boundary. At runtime, this\noperation takes constant time.Examples:* String.Pos.isValid \"abc\" ‚ü®0‚ü© = true* String.Pos.isValid \"abc\" ‚ü®1‚ü© = true* String.Pos.isValid \"abc\" ‚ü®3‚ü© = true* String.Pos.isValid \"abc\" ‚ü®4‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®0‚ü© = true* String.Pos.isValid \"ùí´(A)\" ‚ü®1‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®2‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®3‚ü© = false* String.Pos.isValid \"ùí´(A)\" ‚ü®4‚ü© = true\n\nEfficiently checks whether a position is at a UTF-8 character boundary of the slice s.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"20.8.4.5.2. Validity","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Validity"},"/Introduction/#history-of-lean":{"contents":"Leonardo de Moura launched the Lean project when he was at Microsoft Research in 2013, and Lean 0.1 was officially released on June 16, 2014.\nThe goal of the Lean project is to combine the high level of trust provided by a small, independently-implementable logical kernel with the convenience and automation of tools like SMT solvers, while scaling to large problems.\nThis vision still guides the development of Lean, as we invest in improved automation, improved performance, and user-friendliness; the trusted core proof checker is still minimal and independent implementations exist.\n\nThe initial versions of Lean were primarily configured as C++ libraries in which client code could carry out trustworthy proofs that were independently checkable.\nIn these early years, the design of Lean rapidly evolved towards traditional interactive provers, first with tactics written in Lua, and later with a dedicated front-end syntax.\nJanuary 20, 2017 saw the first release of the Lean 3.0 series.\nLean 3 achieved widespread adoption by mathematicians, and pioneered self-extensibility: tactics, notations, and top-level commands could all be defined in Lean itself.\nThe mathematics community built Mathlib, which at the end of Lean 3 had over one million lines of formalized mathematics, with all proofs mechanically checked.\nThe system itself, however, was still implemented in C++, which imposed limits on Lean's flexibility and made it more difficult to develop due to the diverse skills required.\n\nDevelopment of Lean 4 began in 2018, culminating in the 4.0 release on September 8, 2023.\nLean 4 represents an important milestone: as of version 4, Lean is self-hosted‚Äîapproximately 90% of the code that implements Lean is itself written in Lean.\nLean 4's rich extension API provides users with the ability to adapt it to their needs, rather than relying on the core developers to add necessary features.\nAdditionally, self-hosting makes the development process much faster, so features and performance can be delivered more quickly; Lean 4 is faster and scales to larger problems than Lean 3.\nMathlib was successfully ported to Lean 4 in 2023 through a community effort supported by the Lean developers, and it has now grown to over 1.5 million lines.\nEven though Mathlib has grown by 50%, Lean 4 checks it faster than Lean 3 could check its smaller library.\nThe development process for Lean 4 was approximately as long as that of all prior versions combined, and we are now delighted with its design‚Äîno further rewrites are planned.\n\nLeonardo de Moura and his co-founder, Sebastian Ullrich, launched the Lean Focused Research Organization (FRO) nonprofit in July of 2023 within Convergent Research, with philanthropic support from the Simons Foundation International, the Alfred P. Sloan Foundation, and Richard Merkin.\nThe FRO currently has more than ten employees working to support the growth and scalability of Lean and the broader Lean community.\n\n","context":"Lean Reference\u0009Introduction","header":"1.1. History","id":"/Introduction/#history-of-lean"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Other":{"contents":"* #11328 fixes freeing memory accidentally retained for each document\nversion in the language server on certain elaboration workloads. The\nissue must have existed since 4.18.0.* #11437 adds recording functionality such that shake can more\nprecisely track whether an import should be preserved solely for its\nattribute commands.* #11496 implements new flags and annotations for shake for use in\nMathlib:Options:\n--keep-implied\nPreserves existing imports that are implied by other imports and thus\nnot technically needed\nanymore--keep-prefix\nIf an import X would be replaced in favor of a more specific import\nX.Y... it implies,\npreserves the original import instead. More generally, prefers\ninserting import X even if it\nwas not part of the original imports as long as it was in the original\ntransitive import closure\nof the current module.--keep-public\nPreserves all public imports to avoid breaking changes for external\ndownstream modules--add-public\nAdds new imports as public if they have been in the original public\nclosure of that module.\nIn other words, public imports will not be removed from a module\nunless they are unused even\nin the private scope, and those that are removed will be re-added as\npublic in downstream\nmodules even if only needed in the private scope there. Unlike\n--keep-public, this may\nintroduce breaking changes but will still limit the number of inserted\nimports.Annotations:\nThe following annotations can be added to Lean files in order to\nconfigure the behavior of\nshake. Only the substring shake:  directly followed by a directive\nis checked for, so multiple\ndirectives can be mixed in one line such as -- shake: keep-downstream, shake: keep-all, and they\ncan be surrounded by arbitrary comments such as -- shake: keep (metaprogram output dependency).* module -- shake: keep-downstream:\nPreserves this module in all (current) downstream modules, adding new\nimports of it if needed.* module -- shake: keep-all:\nPreserves all existing imports in this module as is. New imports now\nneeded because of upstream\nchanges may still be added.* import X -- shake: keep:\nPreserves this specific import in the current module. The most common\nuse case is to preserve a\npublic import that will be needed in downstream modules to make sense\nof the output of a\nmetaprogram defined in this module. For example, if a tactic is\ndefined that may synthesize a\nreference to a theorem when run, there is no way for shake to detect\nthis by itself and the\nmodule of that theorem should be publicly imported and annotated with\nkeep in the tactic's\nmodule.public import X  -- shake: keep (metaprogram output dependency)\n\n...\n\nelab \\\"my_tactic\\\" : tactic => do\n... mkConst ``f -- f, defined in X, may appear in the output of\nthis tactic\n```* #11507 optimizes the filesystem accesses during importing for a ~3% win\non Linux, potentially more on other platforms.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0-rc1 (2025-12-14)","header":"Other","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Other"}});