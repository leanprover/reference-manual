window.docContents[148].resolve({"/Error-Explanations/About___--invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--About___--invalidDottedIdent--Examples":{"contents":"Insufficient Type Informationdef reverseDuplicate (xs : List α) :=\n  .reverse (xs ++ xs)\nInvalid dotted identifier notation: The expected type of `.reverse` could not be determined\n\nHint: Using one of these would be unambiguous:\n  [apply] `Array.reverse`\n  [apply] `BitVec.reverse`\n  [apply] `List.reverse`\n  [apply] `Vector.reverse`\n  [apply] `List.IsInfix.reverse`\n  [apply] `List.IsPrefix.reverse`\n  [apply] `List.IsSuffix.reverse`\n  [apply] `List.Sublist.reverse`\n  [apply] `Lean.Grind.AC.Seq.reverse`\n  [apply] `Std.DTreeMap.Internal.Impl.reverse`\n  [apply] `Std.Tactic.BVDecide.BVUnOp.reverse`\n  [apply] `Std.DTreeMap.Internal.Impl.Ordered.reverse`\ndef reverseDuplicate (xs : List α) : List α :=\n  .reverse (xs ++ xs)\nBecause the return type of reverseDuplicate is not specified, the expected type of .reverse\ncannot be determined. Lean will not use the type of the argument xs ++ xs to infer the\nomitted namespace. Adding the return type List α allows Lean to infer the type of .reverse\nand thus the appropriate namespace (List) in which to resolve this identifier.Note that this means that changing the return type of reverseDuplicate changes how .reverse\nresolves: if the return type is T, then Lean will (attempt to) resolve .reverse to a function\nT.reverse whose return type is T—even if T.reverse does not take an argument of type\nList α.\n\nDotted Identifier Where Type Universe Expectedexample (n : Nat) :=\n  match n > 42 with\n  | .true  => n - 1\n  | .false => n + 1\nInvalid dotted identifier notation: Not supported on type universe\n  Prop\nexample (n : Nat) :=\n  match decide (n > 42) with\n  | .true  => n - 1\n  | .false => n + 1\nThe proposition n > 42 has type Prop, which, being a type universe, does not support\ndotted-identifier notation. As this example demonstrates, attempting to use this notation in such a\ncontext is almost always an error. The intent in this example was for .true and .false to be\nBooleans, not propositions; however, match expressions do not\nautomatically perform this coercion for decidable propositions. Explicitly adding decide\nmakes the discriminant a Bool and allows the dotted-identifier resolution to succeed.\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  invalidDottedIdent","header":"Examples","id":"/Error-Explanations/About___--invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--About___--invalidDottedIdent--Examples"},"/Interacting-with-Lean/#format-brackets":{"contents":"These operators make it easier to achieve a consistent parenthesization style.\n\nCreates a format l ++ f ++ r with a flattening group, nesting the contents by the length of l.The group's FlattenBehavior is allOrNone; for fill use Std.Format.bracketFill.\n\nCreates the format \"[\" ++ f ++ \"]\" with a flattening group, nesting by one space.sbracket is short for “square bracket”.\n\nCreates the format \"(\" ++ f ++ \")\" with a flattening group, nesting by one space.\n\nCreates a format l ++ f ++ r with a flattening group, nesting the contents by the length of l.The group's FlattenBehavior is fill; for allOrNone use Std.Format.bracketFill.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.5. Brackets and Parentheses","id":"/Interacting-with-Lean/#format-brackets"}});