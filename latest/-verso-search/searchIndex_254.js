window.docContents[254].resolve({"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Options":{"contents":"For performance, the elaborator and many tactics construct indices and caches.\nMany of these take reducibility into account, and there's no way to invalidate and regenerate them if reducibility changes globally.\nUnsafe changes to reducibility settings that could have unpredictable results are disallowed by default, but they can be enabled by using the allowUnsafeReducibility option.\n\nenables users to modify the reducibility settings for declarations even when such changes are deemed potentially hazardous. For example, simp and type class resolution maintain term indices where reducible declarations are expanded.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Controlling Reduction","header":"7.6.6.3. Options","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Options"},"/Interacting-with-Lean/#format-repr":{"contents":"The Repr type class is used to provide a standard representation for data that can be parsed and evaluated to obtain an equivalent value.\nThis is not a strict correctness criterion: for some types, especially those with embedded propositions, it is impossible to achieve.\nHowever, the output produced by a Repr instance should be as close as possible to something that can be parsed and evaluated.\n\nIn addition to being machine-readable, this representation should be convenient for humans to understand—in particular, lines should not be too long, and nested values should be indented.\nThis is achieved through a two-step process:1. The Repr instance produces an intermediate document of type Std.Format, which compactly represents a set of strings that differ with respect to the placement of newlines and indentation.2. A rendering process selects the “best” representative from the set, according to criteria such as a desired maximum line length.In particular, Std.Format can be built compositionally, so Repr instances don't need to take the surrounding indentation context into account.\n\n\n\n\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.7. Formatted Output","id":"/Interacting-with-Lean/#format-repr"},"/Notations-and-Macros/Defining-New-Syntax/#syntax-data":{"contents":"Lean's parser produces a concrete syntax tree, of type Lean.Syntax.\nLean.Syntax is an inductive type that represents all of Lean's syntax, including commands, terms, tactics, and any custom extensions.\nAll of these are represented by a few basic building blocks:\n\n Atoms\n\nAtoms are the fundamental terminals of the grammar, including literals (such as those for characters and numbers), parentheses, operators, and keywords.\n\n Identifiers\n\nIdentifiers represent names, such as x, Nat, or Nat.add.\n  Identifier syntax includes a list of pre-resolved names that the identifier might refer to.\n\n Nodes\n\nNodes represent the parsing of nonterminals.\n  Nodes contain a syntax kind, which identifies the syntax rule that the node results from, along with an array of child Syntax values.\n\n Missing Syntax\n\nWhen the parser encounters an error, it returns a partial result, so Lean can provide some feedback about partially-written programs or programs that contain mistakes.\n  Partial results contain one or more instances of missing syntax.\n\n\n\nAtoms and identifiers are collectively referred to as tokens.\n\nLean syntax trees.Syntax trees are used pervasively throughout Lean: they are produced by the parser, transformed by\nthe macro expander, and elaborated. They are also produced by the delaborator and presented to\nusers.A portion of the syntax tree that is missing because of a parse error.The indexing operator on Syntax also returns Syntax.missing when the index is out of bounds.A node in the syntax tree that may have further syntax as child nodes. The node's kind\ndetermines its interpretation.For nodes produced by the parser, the info field is typically Lean.SourceInfo.none, and source\ninformation is stored in the corresponding fields of identifiers and atoms. This field is used in\ntwo ways:1. The delaborator uses it to associate nodes with metadata that are used to implement\ninteractive features.2. Nodes created by quotations use the field to mark the syntax as synthetic (storing the result\nof Lean.SourceInfo.fromRef) even when its leading or trailing tokens are not.A non-identifier atomic component of syntax.All of the following are atoms:* keywords, such as def, fun, and inductive* literals, such as numeric or string literals* punctuation and delimiters, such as (, ), and =>.Identifiers are represented by the Lean.Syntax.ident constructor. Atoms also correspond to\nquoted strings inside syntax declarations.An identifier.In addition to source information, identifiers have the following fields:* rawVal is the literal substring from the input file* val is the parsed Lean name, potentially including macro scopes.* preresolved is the list of possible declarations this could refer to, populated by\nquotations.\n\nA possible binding of an identifier in the context in which it was quoted.Identifiers in quotations may refer to either global declarations or to namespaces that are in scope\nat the site of the quotation. These are saved in the Syntax.ident constructor and are part of the\nimplementation of hygienic macros.A potential namespace referenceA potential global constant or section variable reference, with additional field accesses\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"23.4.1. Syntax Model","id":"/Notations-and-Macros/Defining-New-Syntax/#syntax-data"},"/The--grind--tactic/Annotating-Libraries-for--grind/#The-Lean-Language-Reference--The--grind--tactic--Annotating-Libraries-for--grind--Simp-Lemmas":{"contents":"Typically, many theorems that are annotated with @[simp] should also be annotated with @[grind =].\nOne significant exception is that typically we avoid having @[simp] theorems that introduce an if on the right hand side, instead preferring a pair of theorems with the positive and negative conditions as hypotheses.\nBecause grind is designed to perform case splitting, it is generally better to instead annotate the single theorem introducing the if with @[grind =].\n\nBesides using @[grind =] to encourage grind to perform rewriting from left to right, you can also use @[grind _=_] to “saturate”, allowing bidirectional rewriting whenever either side is encountered.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Annotating Libraries for  grind","header":"16.10.1. Simp Lemmas","id":"/The--grind--tactic/Annotating-Libraries-for--grind/#The-Lean-Language-Reference--The--grind--tactic--Annotating-Libraries-for--grind--Simp-Lemmas"},"/The-Type-System/Quotients/#quotient-api":{"contents":"The quotient API relies on a pre-existing Setoid instance.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.4. Quotient API","id":"/The-Type-System/Quotients/#quotient-api"},"/Type-Classes/Class-Declarations/#class-abbrev":{"contents":"In some cases, many related type classes may co-occur throughout a codebase.\nRather than writing all the names repeatedly, it would be possible to define a class that extends all the classes in question, contributing no new methods itself.\nHowever, this new class has a disadvantage: its instances must be declared explicitly.\n\nThe class abbrev command allows the creation of class abbreviations in which one name is short for a number of other class parameters.\nBehind the scenes, a class abbreviation is represented by a class that extends all the others.\nIts constructor is additionally declared to be an instance so the new class can be constructed by instance synthesis alone.\n\nClass AbbreviationsBoth plusTimes1 and plusTimes2 require that their parameters' type have Add and Mul instances:class abbrev AddMul (α : Type u) := Add α, Mul α\n\ndef plusTimes1 [AddMul α] (x y z : α) := x + y * z\n\nclass AddMul' (α : Type u) extends Add α, Mul α\n\ndef plusTimes2 [AddMul' α] (x y z : α) := x + y * z\nBecause AddMul is a class abbrev, no additional declarations are necessary to use plusTimes1 with Nat:#eval plusTimes1 2 5 7\n37\nHowever, plusTimes2 fails, because there is no AddMul' Nat instance—no instances whatsoever have yet been declared:#eval plusTimes2 2 5 7\nfailed to synthesize instance of type class\n  AddMul' ?m.8\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\nDeclaring a very general instance takes care of the problem for Nat and every other type:instance [Add α] [Mul α] : AddMul' α where\n\n#eval plusTimes2 2 5 7\n37\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Class Declarations","header":"10.1.2. Class Abbreviations","id":"/Type-Classes/Class-Declarations/#class-abbrev"},"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Instance-Search-Summary":{"contents":"Generally speaking, instance synthesis is a recursive search procedure that may, in general, backtrack arbitrarily.\nSynthesis may succeed with an instance term, fail if no such term can be found, or get stuck if there is insufficient information.\nA detailed description of the instance synthesis algorithm is available in .\nAn instance search problem is given by a type class applied to concrete arguments; these argument values may or may not be known.\nInstance search attempts every locally-bound variable whose type is a class, as well as each registered instance, in order of priority and definition.\nWhen candidate instances themselves have instance-implicit parameters, they impose further synthesis tasks.\n\nA problem is only attempted when all of the input parameters to the type class are known.\nWhen a problem cannot yet be attempted, then that branch is stuck; progress in other subproblems may result in the problem becoming solvable.\nOutput or semi-output parameters may be either known or unknown at the start of instance search.\nOutput parameters are ignored when checking whether an instance matches the problem, while semi-output parameters are considered.\n\nEvery candidate solution for a given problem is saved in a table; this prevents infinite regress in case of cycles as well as exponential search overheads in the presence of diamonds (that is, multiple paths by which the same goal can be achieved).\nA branch of the search fails when any of the following occur:\n\n* All potential instances have been attempted, and the search space is exhausted.* The instance size limit specified by the option synthInstance.maxSize is reached.* The synthesized value of an output parameter does not match the specified value in the search problem.\nFailed branches are not retried.\n\nIf search would otherwise fail or get stuck, the search process attempts to use matching default instances in order of priority.\nFor default instances, the input parameters do not need to be fully known, and may be instantiated by the instances parameter values.\nDefault instances may take instance-implicit parameters, which induce further recursive search.\n\nSuccessful branches in which the problem is fully known (that is, in which there are no unsolved metavariables) are pruned, and further potentially-successful instances are not attempted, because no later instance could cause the previously-succeeding branch to fail.\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"10.3.1. Instance Search Summary","id":"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Instance-Search-Summary"},"/ValidatingProofs/#The-Lean-Language-Reference--Validating-a-Lean-Proof--Re-Checking-Proofs-with--lean4checker--Instructions":{"contents":"Build your project using build, run lean4checker --fresh on the module that contains the theorem of interest, and check that no error is reported.\n\n","context":"Lean Reference\u0009Validating a Lean Proof\u0009Re-Checking Proofs with  lean4checker","header":"Instructions","id":"/ValidatingProofs/#The-Lean-Language-Reference--Validating-a-Lean-Proof--Re-Checking-Proofs-with--lean4checker--Instructions"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Tactics":{"contents":"* #11664 adds support for Nat.cast in grind linarith. It now uses\n  Grind.OrderedRing.natCast_nonneg. Example:open Lean Grind Std\nattribute [instance] Semiring.natCast\n\nvariable [Lean.Grind.CommRing R] [LE R] [LT R] [LawfulOrderLT R] [IsLinearOrder R] [OrderedRing R]\n\nexample (a : Nat) : 0 ≤ (a : R) := by grind\nexample (a b : Nat) : 0 ≤ (a : R) + (b : R) := by grind\n* #11677 adds basic support for equality propagation in grind linarith\n  for the IntModule case. This covers only the basic case. See note in\n  the code.\n  We remark this feature is irrelevant for CommRing since grind ring\n  already has much better support for equality propagation.* #11678 fixes a bug in registerNonlinearOccsAt used to implement\n  grind lia. This issue was originally reported at:\n  https://leanprover.zulipchat.com/#narrow/channel/113489-new-members/topic/Weirdness.20with.20cutsat/near/562099515* #11691 fixes grind to support dot notation on declarations in the\n  lemma list.* #11700 adds a link to the grind docstring. The link directs users to\n  the section describing grind in the reference manual.* #11712 avoids invoking TC synthesis and other inference mechanisms in\n  the simprocs of bv_decide. This can give significant speedups on\n  problems that pressure these simprocs.* #11717 improves the performance of bv_decide's rewriter on large\n  problems.* #11736 fixes an issue where exact? would not suggest private\n  declarations defined in the current module.* #11739 turns even more commonly used bv_decide theorems that require\n  unification into fast simprocs\n  using syntactic equality. This pushes the overall performance across\n  sage/app7 to <= 1min10s for\n  every problem.* #11749 fixes a bug in the function selectNextSplit? used in grind.\n  It was incorrectly computing the generation of each candidate.* #11758 improves support for nonstandard Int/Nat instances in\n  grind and simp +arith.* #11765 implements user-defined grind attributes. They are useful for\n  users that want to implement tactics using the grind infrastructure\n  (e.g., progress* in Aeneas). New grind attributes are declared using\n  the commandregister_grind_attr my_grind\nThe command is similar to register_simp_attr. Recall that similar to\n  register_simp_attr, the new attribute cannot be used in the same file\n  it is declared.opaque f : Nat → Nat\nopaque g : Nat → Nat\n\n@[my_grind] theorem fax : f (f x) = f x := sorry\n\nexample theorem fax2 : f (f (f x)) = f x := by\n  fail_if_success grind\n  grind [my_grind]\n* #11769 uses the new support for user-defined grind attributes to\n  implement the default [grind] attribute.* #11770 implements support for user-defined attributes at\n  grind_pattern. After declaring a grind attribute with\n  register_grind_attr my_grind, one can write:grind_pattern [my_grind] fg => g (f x)\n* #11776 adds the attributes [grind norm] and [grind unfold] for\n  controlling the grind normalizer/preprocessor.* #11785 disables closed term extraction in the reflection terms used by\n  bv_decide. These terms do\n  not profit at all from closed term extraction but can in practice cause\n  thousands of new closed term\n  declarations which in turn slows down the compiler.* #11787 adds support for incrementally processing local declarations in\n  grind. Instead of processing all hypotheses at once during goal\n  initialization, grind now tracks which local declarations have been\n  processed via Goal.nextDeclIdx and provides APIs to process new\n  hypotheses incrementally.\n  This feature will be used by the new SymM monad for efficient symbolic\n  simulation.* #11788 introduces SymM, a new monad for implementing symbolic\n  simulators (e.g., verification condition generators) in Lean. The monad\n  addresses performance issues found in symbolic simulators built on top\n  of user-facing tactics like apply and intros.* #11792 adds isDebugEnabled for checking whether grind.debug is set\n  to true when grind was initialized.* #11793 adds functions for creating maximally shared terms from\n  maximally shared terms. It is more efficient than creating an expression\n  and then invoking shareCommon. We are going to use these functions for\n  implementing the symbolic simulation primitives.* #11797 simplifies AlphaShareCommon.State by separating the persistent\n  and transient parts of the state.* #11800 adds the function Sym.replaceS, which is similar to\n  replace_fn available in the kernel but assumes the input is maximally\n  shared and ensures the output is also maximally shared. The PR also\n  generalizes the AlphaShareBuilder API.* #11802 adds the function Sym.instantiateS and its variants, which are\n  similar to Expr.instantiate but assumes the input is maximally shared\n  and ensures the output is also maximally shared.* #11803 implements intro (and its variants) for SymM. These versions\n  do not use reduction or infer types, and ensure expressions are\n  maximally shared.* #11806 refactors the Goal type used in grind. The new\n  representation allows multiple goals with different metavariables to\n  share the same GoalState. This is useful for automation such as\n  symbolic simulator, where applying theorems create multiple goals that\n  inherit the same E-graph, congruence closure and solvers state, and\n  other accumulated facts.* #11810 adds a new transparency mode .none in which no definitions are\n  unfolded.* #11813 introduces a fast pattern matching and unification module for\n  the symbolic simulation framework (Sym). The design prioritizes\n  performance by using a two-phase approach:Phase 1 (Syntactic Matching)* Patterns use de Bruijn indices for expression variables and renamed\n  level params (_uvar.0, _uvar.1, ...) for universe variables* Matching is purely structural after reducible definitions are unfolded\n  during preprocessing* Universe levels treat max and imax as uninterpreted functions (no\n  AC reasoning)* Binders and term metavariables are deferred to Phase 2Phase 2 (Pending Constraints)* Handles binders (Miller patterns) and metavariable unification* Converts remaining de Bruijn variables to metavariables* Falls back to isDefEq when necessary* #11814 implements instantiateRevBetaS, which is similar to\n  instantiateRevS but beta-reduces nested applications whose function\n  becomes a lambda after substitution.* #11815 optimizes pattern matching by skipping proof and instance\n  arguments during Phase 1 (syntactic matching).* #11819 adds some basic infrastructure for a structural (and cheaper)\n  isDefEq predicate for pattern matching and unification in Sym.* #11820 adds optimized abstractFVars and abstractFVarsRange for\n  converting free variables to de Bruijn indices during pattern\n  matching/unification.* #11824 implements isDefEqS, a lightweight structural definitional\n  equality for the symbolic simulation framework. Unlike the full\n  isDefEq, it avoids expensive operations while still supporting Miller\n  pattern unification.* #11825 completes the new pattern matching and unification procedures\n  for the symbolic simulation framework using a two-phase approach.* #11833 fixes a few typos, adds missing docstrings, and adds a (simple)\n  missing optimization.* #11837 adds BackwardRule for efficient goal transformation via\n  backward chaining in SymM.* #11847 adds a new solverMode field to bv_decide's configuration,\n  allowing users to configure\n  the SAT solver for different kinds of workloads.* #11849 fixes missing zetaDelta support at the pattern\n  matching/unification procedure in the new Sym framework.* #11850 fixes a bug in the new pattern matching procedure for the Sym\n  framework. It was not correctly handling assigned metavariables during\n  pattern matching.* #11851 fixes Sym/Intro.lean support for have-declarations.* #11856 adds the basic infrastructure for the structural simplifier used\n  by the symbolic simulation (Sym) framework.* #11857 adds an incremental variant of shareCommon for expressions\n  constructed from already-shared subterms. We use this when an expression\n  e was produced by a Lean API (e.g., inferType, mkApp4) that does\n  not preserve maximal sharing, but the inputs to that API were already\n  maximally shared. Unlike shareCommon, this function does not use a\n  local Std.HashMap ExprPtr Expr to track visited nodes. This is more\n  efficient when the number of new (unshared) nodes is small, which is the\n  common case when wrapping API calls that build a few constructor nodes\n  around shared inputs.* #11858 changes bv_decide's heuristic for what kinds of structures to\n  split on to also allow\n  splitting on structures where the fields have dependently typed widths.\n  For example:structure Byte (w : Nat) where\n  /-- A two's complement integer value of width `w`. -/\n  val : BitVec w\n  /-- A per-bit poison mask of width `w`. -/\n  poison : BitVec w\nThis is to allow handling situations such as (x : Byte 8) where the\n  width becomes concrete after\n  splitting is done.* #11860 adds CongrInfo analysis for function applications in the\n  symbolic simulator framework. CongrInfo determines how to build\n  congruence proofs for rewriting subterms efficiently, categorizing\n  functions into:* none: no arguments can be rewritten (e.g., proofs)* fixedPrefix: common case where implicit/instance arguments form a\n  fixed prefix and explicit arguments can be rewritten (e.g., HAdd.hAdd,\n  Eq)* interlaced: rewritable and non-rewritable arguments alternate (e.g.,\n  HEq)* congrTheorem: uses auto-generated congruence theorems for functions\n  with dependent proof arguments (e.g., Array.eraseIdx)* #11866 implements the core simplification loop for the Sym framework,\n  with efficient congruence-based argument rewriting.* #11868 implements Sym.Simp.Theorem.rewrite? for rewriting terms using\n  equational theorems in Sym.* #11869 adds configuration flag Meta.Context.cacheInferType. You can\n  use it to disable the inferType cache at MetaM. We use this flag to\n  implement SymM because it has its own cache based on pointer equality.* #11878 documents assumptions made by the symbolic simulation framework\n  regarding structural matching and definitional equality.* #11880 adds a with_unfolding_none tactic that sets the transparency\n  mode to .none, in which no definitions are unfolded. This complements\n  the existing with_unfolding_all tactic and provides tactic-level\n  access to the TransparencyMode.none added in\n  https://github.com/leanprover/lean4/pull/11810.* #11881 fixes an issue where grind failed to prove f ≠ 0 from f * r\n  ≠ 0 when using Lean.Grind.CommSemiring, but succeeded with\n  Lean.Grind.Semiring.* #11884 adds discrimination tree support for the symbolic simulation\n  framework.\n  The new DiscrTree.lean module converts Pattern values into\n  discrimination\n  tree keys, treating proof/instance arguments and pattern variables as\n  wildcards\n  (Key.star). Motivation: efficient pattern retrieval during rewriting.* #11886 adds getMatch and getMatchWithExtra for retrieving patterns\n  from\n  discrimination trees in the symbolic simulation framework. \n  The PR also adds uses DiscrTree to implement indexing in Sym.simp.* #11888 refactors Sym.simp to make it more general and customizable.\n  It also moves the code\n  to its own subdirectory Meta/Sym/Simp.* #11889 improves the discrimination tree retrieval performance used by\n  Sym.simp.* #11890 ensures that Sym.simp checks thresholds for maximum recursion\n  depth and maximum number of steps. It also invokes checkSystem.\n  Additionally, this PR simplifies the main loop. Assigned metavariables\n  and zetaDelta reduction are now handled by installing pre/post\n  methods.* #11892 optimizes the construction on congruence proofs in simp.\n  It uses some of the ideas used in Sym.simp.* #11898 adds support for simplifying lambda expressions in Sym.simp.\n  It is much more efficient than standard simp for very large lambda\n  expressions with many binders. The key idea is to generate a custom\n  function extensionality theorem for the type of the lambda being\n  simplified.* #11900 adds a done flag to the result returned by Simprocs in\n  Sym.simp.* #11906 tries to minimize the number of expressions created at\n  AlphaShareCommon.* #11909 reorganizes the monad hierarchy for symbolic computation in\n  Lean.* #11911 minimizes the number of expression allocations performed by\n  replaceS and instantiateRevBetaS.* #11914 factors out the have-telescope support used in simp, and\n  implements it using the MonadSimp interface. The goal is to\n  use this nice infrastructure for both Meta.simp and Sym.simp.* #11918 filters deprecated lemmas from exact? and rw? suggestions.* #11920 implements support for simplifying have telescopes in\n  Sym.simp.* #11923 adds a new option to the function simpHaveTelescope in which\n  the have telescope is simplified in two passes:* In the first pass, only the values and the body are simplified.* In the second pass, unused declarations are eliminated.* #11932 eliminates super-linear kernel type checking overhead when\n  simplifying lambda expressions. I improved the proof term produced by\n  mkFunext. This function is used in Sym.simp when simplifying lambda\n  expressions.* #11946 adds a +locals configuration option to the grind tactic that\n  automatically adds all definitions from the current file as e-match\n  theorems. This provides a convenient alternative to manually adding\n  [local grind] attributes to each definition. In the form grind?\n  +locals, it is also helpful for discovering which local declarations it\n  may be useful to add [local grind] attributes to.* #11947 adds a +locals configuration option to the simp, simp_all,\n  and dsimp tactics that automatically adds all definitions from the\n  current file to unfold.* #11949 adds a new first_par tactic combinator that runs multiple\n  tactics in parallel and returns the first successful result (cancelling\n  the others).* #11950 implements simpForall and simpArrow in Sym.simp.* #11962 fixes library suggestions to include private proof-valued\n  structure fields.* #11967 implements a new strategy for simplifying have-telescopes in\n  Sym.simp that achieves linear kernel type-checking time instead of\n  quadratic.* #11974 optimizes congruence proof construction in Sym.simp by\n  avoiding\n  inferType calls on expressions that are less likely to be cached.\n  Instead of\n  inferring types of expressions like @HAdd.hAdd Nat Nat Nat instAdd 5,\n  we infer\n  the type of the function prefix @HAdd.hAdd Nat Nat Nat instAdd and\n  traverse\n  the forall telescope.* #11976 adds missing type checking for pattern variables during pattern\n  matching/unification to prevent incorrect matches.* #11985 implements support for auto-generated congruence theorems in\n  Sym.simp, enabling simplification of functions with complex argument\n  dependencies such as proof arguments and Decidable instances.* #11999 adds support for simplifying the arguments of over-applied and\n  under-applied function application terms in Sym.simp, completing the\n  implementation for all three congruence strategies (fixed prefix,\n  interlaced, and congruence theorems).* #12006 fixes the pretty-printing of the extract_lets tactic.\n  Previously, the pretty-printer would expect a space after the\n  extract_lets tactic, when it was followed by another tactic on the\n  same line: for example,\n  extract_lets; exact foo\n  would be changed to\n  extract_lets ; exact foo.* #12012 implements support for rewrite on over-applied terms in\n  Sym.simp. Example: rewriting id f a using id_eq.* #12031 adds Sym.Simp.evalGround, a simplification procedure for\n  evaluating ground terms of builtin numeric types. It is designed for\n  Sym.simp.* #12032 adds Dischargers to Sym.simp, and ensures the cached results\n  are consistent.* #12033 adds support for conditional rewriting rules to Sym.simp.* #12035 adds simpControl, a simproc that handles control-flow\n  expressions such as if-then-else. It simplifies conditions while\n  avoiding unnecessary work on branches that won't be taken.* #12039 implements match-expression simplification for Sym.simp.* #12040 adds simprocs for simplifying cond and dependent\n  if-then-else in Sym.simp.* #12053 adds support for offset terms in SymM. This is essential for\n  handling equational theorems for functions that pattern match on natural\n  numbers in Sym.simp. Without this, it cannot handle simple examples\n  such as pw (a + 2) where pw pattern matches on n+1.* #12077 implements simprocs for String and Char. It also ensures\n  reducible definitions are unfolded in SymM* #12096 cleanups temporary metavariables generated when applying\n  rewriting rules in Sym.simp.* #12099 ensures Sym.simpGoal does not use mkAppM. It also increases\n  the default number of maximum steps in Sym.simp.* #12100 adds a comparison between MetaM and SymM for a benchmark was\n  proposed during the Lean@Google Hackathon.* #12101 improves the the Sym.simp APIs. It is now easier to reuse the\n  simplifier cache between different simplification steps. We use the APIs\n  to improve the benchmark at #12100.* #12134 adds a new benchmark shallow_add_sub_cancel.lean that\n  demonstrates symbolic simulation using a shallow embedding into monadic\n  do notation, as opposed to the deep embedding approach in\n  add_sub_cancel.lean.* #12143 adds an API for building symbolic simulation engines and\n  verification\n  condition generators that leverage grind. The API wraps Sym\n  operations to\n  work with grind's Goal type, enabling lightweight symbolic execution\n  while\n  carrying grind state for discharge steps.* #12145 moves the pre-shared commonly used expressions from GrindM to\n  SymM.* #12147 adds a new API for helping users write focused rewrites.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0 (2026-01-26)","header":"Tactics","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Tactics"}});