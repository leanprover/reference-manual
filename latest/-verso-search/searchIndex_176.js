window.docContents[176].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Element-Predicates":{"contents":"Checks whether a is an element of as, using == to compare elements.Array.elem is a synonym that takes the element before the array.Examples:* #[1, 4, 2, 3, 3, 7].contains 3 = true* Array.contains #[1, 4, 2, 3, 3, 7] 5 = false\n\nChecks whether a is an element of as, using == to compare elements.Array.contains is a synonym that takes the array before the element.For verification purposes, Array.elem is simplified to Array.contains.Example:* Array.elem 3 #[1, 4, 2, 3, 3, 7] = true* Array.elem 5 #[1, 4, 2, 3, 3, 7] = false\n\nReturns the first element of the array for which the predicate p returns true, or none if no\nsuch element is found.Examples:* #[7, 6, 5, 8, 1, 2, 6].find? (· < 5) = some 1* #[7, 6, 5, 8, 1, 2, 6].find? (· < 1) = none\n\nReturns the last element of the array for which the predicate p returns true, or none if no\nsuch element is found.Examples:* #[7, 6, 5, 8, 1, 2, 6].findRev? (· < 5) = some 2* #[7, 6, 5, 8, 1, 2, 6].findRev? (· < 1) = none\n\nReturns the index of the first element for which p returns true, or the size of the array if\nthere is no such element.Examples:* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 5) = 4* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 1) = 7\n\nReturns the index of the first element for which p returns true, or none if there is no such\nelement.Examples:* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 5) = some 4* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 1) = none\n\nFinds the index of the first element of an array for which the monadic predicate p returns true.\nElements are examined in order from left to right, and the search is terminated when an element that\nsatisfies p is found. If no such element exists in the array, then none is returned.\n\nReturns the index of the first element for which p returns true, or none if there is no such\nelement. The index is returned as a Fin, which guarantees that it is in bounds.Examples:* #[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· < 5) = some (4 : Fin 7)* #[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· < 1) = none\n\nReturns the first element of the array for which the monadic predicate p returns true, or none\nif no such element is found. Elements of the array are checked in order.The monad m is restricted to Type → Type to avoid needing to use ULift Bool in p's type.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 6\nAlmost! 5\nsome 1\n\n\nReturns the last element of the array for which the monadic predicate p returns true, or none\nif no such element is found. Elements of the array are checked in reverse, from right to left..The monad m is restricted to Type → Type to avoid needing to use ULift Bool in p's type.Example:#eval #[7, 5, 8, 1, 2, 6, 5, 8].findRevM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 5\nAlmost! 6\nsome 2\n\n\nReturns the first non-none result of applying the function f to each element of the\narray, in order. Returns none if f returns none for all elements.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findSome? fun i =>\n  if i < 5 then\n    some (i * 10)\n  else\n    none\nsome 10\n\n\nReturns the first non-none result of applying the function f to each element of the\narray, in order. Panics if f returns none for all elements.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findSome? fun i =>\n  if i < 5 then\n    some (i * 10)\n  else\n    none\nsome 10\n\n\nReturns the first non-none result of applying the monadic function f to each element of the\narray, in order. Returns none if f returns none for all elements.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findSomeM? fun i => do\n  if i < 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\nAlmost! 6\nAlmost! 5\nsome 10\n\n\nReturns the first non-none result of applying f to each element of the array in reverse order,\nfrom right to left. Returns none if f returns none for all elements of the array.Examples:* #[7, 6, 5, 8, 1, 2, 6].findSome? (fun x => if x < 5 then some (10 * x) else none) = some 10* #[7, 6, 5, 8, 1, 2, 6].findSome? (fun x => if x < 1 then some (10 * x) else none) = none\n\nReturns the first non-none result of applying the monadic function f to each element of the\narray in reverse order, from right to left. Once a non-none result is found, no further elements\nare checked. Returns none if f returns none for all elements of the array.Examples:#eval #[1, 2, 0, -4, 1].findSomeRevM? (m := Except String) fun x => do\n  if x = 0 then throw \"Zero!\"\n  else if x < 0 then return (some x)\n  else return none\nExcept.ok (some (-4))\n#eval #[1, 2, 0, 4, 1].findSomeRevM? (m := Except String) fun x => do\n  if x = 0 then throw \"Zero!\"\n  else if x < 0 then return (some x)\n  else return none\nExcept.error \"Zero!\"\n\n\nReturns true if p returns true for every element of as.Short-circuits upon encountering the first false.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.Examples:* #[a, b, c].all p = (p a && (p b && p c))* #[2, 4, 6].all (· % 2 = 0) = true* #[2, 4, 5, 6].all (· % 2 = 0) = false\n\nReturns true if the monadic predicate p returns true for every element of as.Short-circuits upon encountering the first false. The elements in as are examined in order from\nleft to right.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.\n\nReturns true if p returns true for any element of as.Short-circuits upon encountering the first true.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.Examples:* #[2, 4, 6].any (· % 2 = 0) = true* #[2, 4, 6].any (· % 2 = 1) = false* #[2, 4, 5, 6].any (· % 2 = 0) = true* #[2, 4, 5, 6].any (· % 2 = 1) = true\n\nReturns true if the monadic predicate p returns true for any element of as.Short-circuits upon encountering the first true. The elements in as are examined in order from\nleft to right.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.\n\nReturns true if no two elements of as are equal according to the == operator.Examples:* #[\"red\", \"green\", \"blue\"].allDiff = true* #[\"red\", \"green\", \"red\"].allDiff = false* (#[] : Array Nat).allDiff = true\n\nReturns true if as and bs have the same length and they are pairwise related by eqv.Short-circuits at the first non-related pair of elements.Examples:* #[1, 2, 3].isEqv #[2, 3, 4] (· < ·) = true* #[1, 2, 3].isEqv #[2, 2, 4] (· < ·) = false* #[1, 2, 3].isEqv #[2, 3] (· < ·) = false\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"20.16.4.12. Element Predicates","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Element-Predicates"},"/Basic-Types/Characters/#char-model":{"contents":"From the perspective of Lean's logic, characters consist of a 32-bit unsigned integer paired with a proof that it is a valid Unicode scalar value.\n\nCharacters are Unicode scalar values.The underlying Unicode scalar value as a UInt32.The value must be a legal scalar value.\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters","header":"20.7.1. Logical Model","id":"/Basic-Types/Characters/#char-model"},"/Error-Explanations/About___--ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--About___--ctorResultingTypeMismatch--Examples":{"contents":"Typo in Resulting Typeinductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Treee α\nUnexpected resulting type for constructor `Tree.node`: Expected an application of\n  Tree\nbut found\n  ?m.2\ninductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Tree α\n\n\nMissing Resulting Type After Constructor Parameterinductive Credential where\n  | pin      : Nat\n  | password : String\nUnexpected resulting type for constructor `Credential.pin`: Expected\n  Credential\nbut found\n  Nat\ninductive Credential where\n  | pin      : Nat → Credential\n  | password : String → Credential\ninductive Credential where\n  | pin (num : Nat)\n  | password (str : String)\nIf the type of a constructor is annotated, the full type—including the resulting type—must be\nprovided. Alternatively, constructor parameters can be written using named binders; this allows the\nomission of the constructor's resulting type because it contains no indices.\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  ctorResultingTypeMismatch","header":"Examples","id":"/Error-Explanations/About___--ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--About___--ctorResultingTypeMismatch--Examples"},"/Error-Explanations/About___--propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--About___--propRecLargeElim--Examples":{"contents":"Defining an Intermediate Data Value Within a Proofexample {α : Type} [inst : Nonempty α] (p : α → Prop) :\n    ∃ x, p x ∨ ¬ p x :=\n  let val :=\n    match inst with\n    | .intro x => x\n  ⟨val, Classical.em (p val)⟩\nTactic `cases` failed with a nested error:\nTactic `induction` failed: recursor `Nonempty.casesOn` can only eliminate into `Prop`\n\nα : Type\nmotive : Nonempty α → Sort ?u.48\nh_1 : (x : α) → motive ⋯\ninst✝ : Nonempty α\n⊢ motive inst✝ after processing\n  _\nthe dependent pattern matcher can solve the following kinds of equations\n- <var> = <term> and <term> = <var>\n- <term> = <term> where the terms are definitionally equal\n- <constructor> = <constructor>, examples: List.cons x xs = List.cons y ys, and List.cons x xs = List.nil\nexample {α : Type} [inst : Nonempty α] (p : α → Prop) :\n    ∃ x, p x ∨ ¬ p x :=\n  match inst with\n  | .intro x => ⟨x, Classical.em (p x)⟩\nEven though the example being defined has a propositional\ntype, the body of val does not; it has type α : Type. Thus, pattern-matching on the proof of\nNonempty α (a proposition) to produce val requires eliminating that proof into a\nnon-propositional type and is disallowed. Instead, the match\nexpression must be moved to the top level of the example, where the result is a\nProp-valued proof of the existential claim stated in the example's header. This\nrestructuring could also be done using a pattern-matching let\nbinding.\n\nExtracting the Witness from an Existential Proofdef getWitness {α : Type u} {p : α → Prop} (h : ∃ x, p x) : α :=\n  match h with\n  | .intro x _ => x\nTactic `cases` failed with a nested error:\nTactic `induction` failed: recursor `Exists.casesOn` can only eliminate into `Prop`\n\nα : Type u\np : α → Prop\nmotive : (∃ x, p x) → Sort ?u.52\nh_1 : (x : α) → (h : p x) → motive ⋯\nh✝ : ∃ x, p x\n⊢ motive h✝ after processing\n  _\nthe dependent pattern matcher can solve the following kinds of equations\n- <var> = <term> and <term> = <var>\n- <term> = <term> where the terms are definitionally equal\n- <constructor> = <constructor>, examples: List.cons x xs = List.cons y ys, and List.cons x xs = List.nil\n-- This is `Exists.elim`\ntheorem useWitness {α : Type u} {p : α → Prop} {q : Prop}\n    (h : ∃ x, p x) (hq : (x : α) → p x → q) : q :=\n  match h with\n  | .intro x hx => hq x hx\ndef getWitness {α : Type u} {p : α → Prop}\n    (h : (x : α) ×' p x) : α :=\n  match h with\n  | .mk x _ => x\nIn this example, simply relocating the pattern-match is insufficient; the attempted definition\ngetWitness is fundamentally unsound. (Consider the case where p is\nfun (n : Nat) => n > 0: if h and h' are proofs of ∃ x, x > 0, with h using\nwitness 1 and h' witness 2, then since h = h' by proof irrelevance, it follows that\ngetWitness h = getWitness h'—i.e., 1 = 2.)Instead, getWitness must be rewritten: either the resulting type of the function must be a\nproposition (the first fixed example above), or h must not be a proposition (the second).In the first corrected example, the resulting type of useWitness is now a proposition q. This\nallows us to pattern-match on h—since we are eliminating into a propositional type—and pass the\nunpacked values to hq. From a programmatic perspective, one can view useWitness as rewriting\ngetWitness in continuation-passing style, restricting subsequent computations to use its result\nonly to construct values in Prop, as required by the prohibition on propositional large\nelimination. Note that useWitness is the existential elimination principle Exists.elim.The second corrected example changes the type of h from an existential proposition to a\nType-valued dependent pair (corresponding to the PSigma type constructor). Since\nthis type is not propositional, eliminating into α : Type u is no longer invalid, and the\npreviously attempted pattern match now type-checks.\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  propRecLargeElim","header":"Examples","id":"/Error-Explanations/About___--propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--About___--propRecLargeElim--Examples"},"/The-Simplifier/Simplification-vs-Rewriting/#simp-vs-rw":{"contents":"Both simp and rw/rewrite use equational lemmas to replace parts of terms with equivalent alternatives.\nTheir intended uses and their rewriting strategies differ, however.\nTactics in the simp family are primarily used to reformulate a problem in a standardized way, making it more amenable to both human understanding and further automation.\nIn particular, simplification should never render an otherwise-provable goal impossible.\nTactics in the rw family are primarily used to apply hand-selected transformations that do not always preserve provability nor place terms in standardized forms.\nThese different emphases are reflected in the differences of behavior between the two families of tactics.\n\nThe simp tactics primarily rewrite from the inside out.\nThe smallest possible expressions are simplified first so that they can unlock further simplification opportunities for the surrounding expressions.\nThe rw tactics select the leftmost outermost subterm that matches the pattern, rewriting it a single time.\nBoth tactics allow their strategy to be overridden: when adding a lemma to a simp set, the ↓ modifier causes it to be applied prior to the simplification of subterms, and the occs field of rw's configuration parameter allows a different occurrence to be selected, either via a whitelist or a blacklist.\n\n\n","context":"Lean Reference\u0009The Simplifier","header":"15.7. Simplification vs Rewriting","id":"/The-Simplifier/Simplification-vs-Rewriting/#simp-vs-rw"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Lake":{"contents":"* #11683 fixes an inconsistency in the way Lake and Lean view the\n  transitivity of a meta import. Lake now works as Lean expects and\n  includes the meta segment of all transitive imports of a meta import\n  in its transitive trace.* #11859 removes the need to write .ofNat for numeric options in\n  lakefile.lean. Note that lake translate-config incorrectly assumed\n  this was already legal in earlier revisions.* #11921 adds lake shake as a built-in Lake command, moving the shake\n  functionality from script/Shake.lean into the Lake CLI.* #12034 changes the default of enableArtifactCache to use the\n  workspace's enableArtifactCache setting if the package is a dependency\n  and LAKE_ARTIFACT_CACHE is not set. This means that dependencies of a\n  project with enableArtifactCache set will also, by default, use Lake's\n  local artifact cache.* #12037 fixes two Lake cache issues: a bug where a failed upload would\n  not produce an error and a mistake in the --wfail checks of the cache\n  commands.* #12076 adds additional debugging information to a run of lake build\n  --no-build via a .nobuild trace file. When a build fails due to\n  needing a rebuild, Lake emits the new expected trace next as .nobuild\n  file next to the build's old .trace. The inputs recorded in these\n  files can then be compared to debug what caused the mismatch.* #12086 fixes a bug where a lake build --no-build would exit with code\n  3 if the optional job to fetch a GitHub or Reservoir release for a\n  package failed (even if nothing else needed rebuilding).* #12105 fixes the lake query output for targets which produce an\n  Array or List of a value with a custom QueryText or QueryJson\n  instance (e.g., deps and transDeps).* #12112 revives the ability to specify modules in dependencies via the\n  basic +mod target key.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0 (2026-01-26)","header":"Lake","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Lake"}});