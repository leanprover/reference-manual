window.docContents[172].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Comparisons":{"contents":"Returns either p₁ or p₂, whichever has the least byte index.\n\nReturns the size of the byte slice delineated by the positions lo and hi.\n\nChecks whether substrings of two strings are equal. Substrings are indicated by their starting\npositions and a size in UTF-8 bytes. Returns false if the indicated substring does not exist in\neither string.This is a legacy function. The recommended alternative is to construct slices representing the\nstrings to be compared and use the BEq instance of String.Slice.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"20.8.4.5.4. Comparisons","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Comparisons"},"/Basic-Types/The-Unit-Type/#The-Lean-Language-Reference--Basic-Types--The-Unit-Type--Definitional-Equality":{"contents":"Unit-like types are inductive types that have a single constructor which takes no non-proof parameters.\nPUnit is one such type.\nAll elements of unit-like types are definitionally equal to all other elements.\n\nDefinitional Equality of UnitEvery term with type Unit is definitionally equal to every other term with type Unit:example (e1 e2 : Unit) : e1 = e2 := rfl\n\n\nDefinitional Equality of Unit-Like TypesBoth CustomUnit and AlsoUnit are unit-like types, with a single constructor that takes no parameters.\nEvery pair of terms with either type is definitionally equal.inductive CustomUnit where\n  | customUnit\n\nexample (e1 e2 : CustomUnit) : e1 = e2 := rfl\n\nstructure AlsoUnit where\n\nexample (e1 e2 : AlsoUnit) : e1 = e2 := rfl\nTypes with parameters, such as WithParam, are also unit-like if they have a single constructor that does not take parameters.inductive WithParam (n : Nat) where\n  | mk\n\nexample (x y : WithParam 3) : x = y := rfl\nConstructors with non-proof parameters are not unit-like, even if the parameters are all unit-like types.inductive NotUnitLike where\n  | mk (u : Unit)\nexample (e1 e2 : NotUnitLike) : e1 = e2 := rfl\nType mismatch\n  rfl\nhas type\n  ?m.13 = ?m.13\nbut is expected to have type\n  e1 = e2\nConstructors of unit-like types may take parameters that are proofs.inductive ProofUnitLike where\n  | mk : 2 = 2 → ProofUnitLike\n\nexample (e1 e2 : ProofUnitLike) : e1 = e2 := rfl\n\n\n","context":"Lean Reference\u0009Basic Types\u0009The Unit Type","header":"20.9.1. Definitional Equality","id":"/Basic-Types/The-Unit-Type/#The-Lean-Language-Reference--Basic-Types--The-Unit-Type--Definitional-Equality"},"/Error-Explanations/About___--invalidField/#The-Lean-Language-Reference--Error-Explanations--About___--invalidField--Examples":{"contents":"Incorrect Field Name#eval (4 + 2).suc\nInvalid field `suc`: The environment does not contain `Nat.suc`, so it is not possible to project the field `suc` from an expression\n  4 + 2\nof type `Nat`\n#eval (4 + 1).succ\nThe simplest reason for an invalid field error is that the function being sought, like Nat.suc,\ndoes not exist.\n\nProjecting from the Wrong Expression#eval '>'.leftpad 10 ['a', 'b', 'c']\nInvalid field `leftpad`: The environment does not contain `Char.leftpad`, so it is not possible to project the field `leftpad` from an expression\n  '>'\nof type `Char`\n#eval ['a', 'b', 'c'].leftpad 10 '>'\nThe type of the expression before the dot entirely determines the function being called by the field\nprojection. There is no Char.leftpad, and the only way to invoke List.leftpad with generalized\nfield notation is to have the list come before the dot.\n\nType is Not Specificdef double_plus_one {α} [Add α] (x : α) :=\n   (x + x).succ\nInvalid field notation: Field projection operates on types of the form `C ...` where C is a constant. The expression\n  x + x\nhas type `α` which does not have the necessary form.\ndef double_plus_one (x : Nat) :=\n   (x + x).succ\nThe Add type class is sufficient for performing the addition x + x, but the .succ field notation\ncannot operate without knowing more about the actual type from which succ is being projected.\n\nInsufficient Type Informationexample := fun (n) => n.succ.succ\nInvalid field notation: Type of\n  n\nis not known; cannot resolve field `succ`\n\nHint: Consider replacing the field projection with a call to one of the following:\n  • `Fin.succ`\n  • `Nat.succ`\n  • `Lean.Level.succ`\n  • `Std.PRange.succ`\n  • `Lean.Level.PP.Result.succ`\n  • `Std.Time.Internal.Bounded.LE.succ`\nexample := fun (n : Nat) => n.succ.succ\nGeneralized field notation can only be used when it is possible to determine the type that is being\nprojected. Type annotations may need to be added to make generalized field notation work.\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  invalidField","header":"Examples","id":"/Error-Explanations/About___--invalidField/#The-Lean-Language-Reference--Error-Explanations--About___--invalidField--Examples"},"/ValidatingProofs/#The-Lean-Language-Reference--Validating-a-Lean-Proof--Re-Checking-Proofs-with--lean4checker--Significance":{"contents":"The lean4checker tool reads the declarations and proofs as they are stored by lean during building (the .olean files), and replays them through the kernel.\nIt trusts that the .olean files are structurally correct.\n\n","context":"Lean Reference\u0009Validating a Lean Proof\u0009Re-Checking Proofs with  lean4checker","header":"Significance","id":"/ValidatingProofs/#The-Lean-Language-Reference--Validating-a-Lean-Proof--Re-Checking-Proofs-with--lean4checker--Significance"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Lake":{"contents":"* #7185 refactors Lake's build internals to enable the introduction of\ntargets and facets beyond packages, modules, and libraries. Facets,\nbuild keys, build info, and CLI commands have been generalized to\narbitrary target types.* #7393 adds autocompletion support for Lake configuration fields in the\nLean DSL at the indented whitespace after an existing field.\nAutocompletion in the absence of any fields is currently still not\nsupported.Breaking change: The nonstandard braced configuration syntax now uses a semicolon ; rather than a comma , as a separator. Indentation can still be used as an alternative to the separator.* #7399 reverts the new builtin initializers, elaborators, and macros in\nLake back to non-builtin.* #7504 augments the Lake configuration data structures declarations\n(e.g., PackageConfig, LeanLibConfig) to produce additional metadata\nwhich is used to automatically generate the Lean & TOML encoders and\ndecoders via metaprograms.* #7543 unifies the configuration declarations of dynamic targets,\nexternal libraries, Lean libraries, and Lean executables into a single\ndata type stored in a unified map within a package.Breaking change: Users can no longer define multiple targets with the same name but different kinds (e.g., a Lean executable and a Lean library both named foo). This should not effect most users as the Lake DSL already discouraged this.* #7576 changes Lake to produce and use response files on Windows when\nbuilding executables and libraries (static and shared). This is done to\navoid potentially exceeding Windows command line length limits.* #7586 changes the static.export facet for Lean libraries to produce\nthin static libraries.* #7608 removes the use of the Lake plugin in the Lake build and in\nconfiguration files.* #7667 changes Lake to log messages from a Lean configuration the same\nway it logs message from a Lean build. This, for instance, removes\nredundant severity captions.* #7703 adds input_file and input_dir as new target types. It also\nadds the needs configuration option for Lean libraries and\nexecutables. This option generalizes extraDepTargets (which will be\ndeprecated in the future), providing much richer support for declaring\ndependencies across package and target type boundaries.* #7716 adds the moreLinkObjs and moreLinkLibs options for Lean\npackages, libraries, and executables. These serves as functional\nreplacements for extern_lib and provided additional flexibility.Breaking change: precompileModules now only loads modules of the current library individually. Modules of other libraries are loaded together via that library's shared library.* #7732 deprecates extraDepTargets and fixes a bug caused by the\nconfiguration refactor.* #7758 removes the -lstdcpp extra link argument from the FFI example.\nIt is not actually necessary.* #7763 corrects build key fetches to produce jobs with the proper data\nkinds and fixes a failed coercion from key literals to targets.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)","header":"Lake","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Lake"}});