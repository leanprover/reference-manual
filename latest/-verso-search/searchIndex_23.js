window.docContents[23].resolve({"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Implementing-Ranges":{"contents":"The built-in range types may be used with any type, but their usefulness depends on the presence of certain type class instances.\nGenerally speaking, ranges are either checked for membership, enumerated or iterated over.\nTo check whether an value is contained in a range, DecidableLT and DecidableLE instances are used to compare the value to the range's respective open and closed endpoints.\nTo get an iterator for a range, instances of Std.PRange.UpwardEnumerable and Std.PRange.LawfulUpwardEnumerable are all that's needed.\nTo iterate directly over it in a for loop, Std.PRange.LawfulUpwardEnumerableLE and Std.PRange.LawfulUpwardEnumerableLT are required as well.\nTo enumerate a range (e.g. by calling toList), it must be proven finite.\nThis is done by supplying instances of Std.Rxi.IsAlwaysFinite, Std.Rxc.IsAlwaysFinite, or Std.Rxo.IsAlwaysFinite.\n\nImplementing RangesThe enumeration type Day represents the days of the week:inductive Day where\n  | mo | tu | we | th | fr | sa | su\nderiving Repr\nWhile it's already possible to use this type in ranges, they're not particularly useful.\nThere's no membership instance:#eval Day.we ∈ (Day.mo...=Day.fr)\nfailed to synthesize instance of type class\n  Membership Day (Std.Rcc Day)\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\nRanges can't be iterated over:#eval show IO Unit from\n  for d in Day.mo...=Day.fr do\n    IO.println s!\"It's {repr d}\"\nfailed to synthesize instance for 'for_in%' notation\n  ForIn (EIO IO.Error) (Std.Rcc Day) ?m.11\nNor can they be enumerated, even though the type is finite:#eval (Day.sa...*).toList\nfailed to synthesize instance of type class\n  Std.PRange.UpwardEnumerable Day\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\nMembership tests require DecidableLT and DecidableLE instances.\nAn easy way to get these is to number each day, and compare the numbers:def Day.toNat : Day → Nat\n  | mo => 0\n  | tu => 1\n  | we => 2\n  | th => 3\n  | fr => 4\n  | sa => 5\n  | su => 6\n\ninstance : LT Day where\n  lt d1 d2 := d1.toNat < d2.toNat\n\ninstance : LE Day where\n  le d1 d2 := d1.toNat ≤ d2.toNat\n\ninstance : DecidableLT Day :=\n  fun d1 d2 => inferInstanceAs (Decidable (d1.toNat < d2.toNat))\n\ninstance : DecidableLE Day :=\n  fun d1 d2 => inferInstanceAs (Decidable (d1.toNat ≤ d2.toNat))\nWith these instances available, membership tests work as expected:def Day.isWeekday (d : Day) : Bool := d ∈ Day.mo...Day.sa\n#eval Day.th.isWeekday\ntrue\n#eval Day.sa.isWeekday\nfalse\nIteration and enumeration are both variants on repeatedly applying a successor function until either the upper bound of the range or the largest element of the type is reached.\nThis successor function is Std.PRange.UpwardEnumerable.succ?.\nIt's also convenient to have a definition of the function in Day's namespace for use with generalized field notation:def Day.succ? : Day → Option Day\n  | mo => some tu\n  | tu => some we\n  | we => some th\n  | th => some fr\n  | fr => some sa\n  | sa => some su\n  | su => none\n\ninstance : Std.PRange.UpwardEnumerable Day where\n  succ? := Day.succ?\nIteration also requires a proof that the implementation of succ? is sensible.\nIts properties are expressed in terms of Std.PRange.UpwardEnumerable.succMany?, which iterates the application of succ? a certain number of times and has a default implementation in terms of Nat.repeat and succ?.\nIn particular, an instance of LawfulUpwardEnumerable requires proofs that Std.PRange.UpwardEnumerable.succMany? corresponds to the default implementation along with a proof that repeatedly applying the successor never yields the same element again.The first step is to write two helper lemmas for the two proofs about succMany?.\nWhile they could be written inline in the instance declaration, it's convenient for them to have the @[simp] attribute.@[simp]\ntheorem Day.succMany?_zero (d : Day) :\n  Std.PRange.succMany? 0 d = some d := by\n  simp [Std.PRange.succMany?, Nat.repeat]\n\n@[simp]\ntheorem Day.succMany?_add_one (n : Nat) (d : Day) :\n    Std.PRange.succMany? (n + 1) d =\n    (Std.PRange.succMany? n d).bind Std.PRange.succ? := by\n  simp [Std.PRange.succMany?, Nat.repeat, Std.PRange.succ?]\nProving that there are no cycles in successor uses a convenient helper lemma that calculates the number of successor steps between any two days.\nIt is marked @[grind →] because when assumptions that match its premises are present, it adds a great deal of new information:@[grind →]\ntheorem Day.succMany?_steps {d d' : Day} {steps} :\n    Std.PRange.succMany? steps d = some d' →\n    if d ≤ d' then steps = d'.toNat - d.toNat\n    else False := by\n  intro h\n  match steps with\n  | 0 | 1 | 2 | 3 | 4 | 5 | 6 =>\n    cases d <;> cases d' <;>\n    simp_all +decide [Std.PRange.succMany?, Nat.repeat, Day.succ?]\n  | n + 7 =>\n    simp at h\n    cases h' : (Std.PRange.succMany? n d) with\n    | none =>\n      simp_all\n    | some d'' =>\n      rw [h'] at h\n      cases d'' <;> contradiction\nWith that helper, the proof is quite short:instance : Std.PRange.LawfulUpwardEnumerable Day where\n  ne_of_lt d1 d2 h := by grind [Std.PRange.UpwardEnumerable.LT]\n  succMany?_zero := Day.succMany?_zero\n  succMany?_add_one := Day.succMany?_add_one\nProving the three kinds of enumerable ranges to be finite makes it possible to enumerate ranges of days:instance : Std.Rxo.IsAlwaysFinite Day where\n  finite init hi :=\n    ⟨7, by cases init <;> simp [Std.PRange.succ?, Day.succ?]⟩\n\ninstance : Std.Rxc.IsAlwaysFinite Day where\n  finite init hi :=\n    ⟨7, by cases init <;> simp [Std.PRange.succ?, Day.succ?]⟩\n\ninstance : Std.Rxi.IsAlwaysFinite Day where\n  finite init := ⟨7, by cases init <;> rfl⟩\ndef allWeekdays : List Day := (Day.mo...Day.sa).toList\n#eval allWeekdays\n[Day.mo, Day.tu, Day.we, Day.th, Day.fr]\nAdding a Std.PRange.Least? instance allows enumeration of left-unbounded ranges:instance : Std.PRange.Least? Day where\n  least? := some .mo\n\ndef allWeekdays' : List Day := (*...Day.sa).toList\n#eval allWeekdays'\n[Day.mo, Day.tu, Day.we, Day.th, Day.fr]\nIt's also possible to create an iterator that can be enumerated, but it can't yet be used with for:#eval (Day.we...Day.fr).iter.toList\n[Day.we, Day.th]\n#eval show IO Unit from do\n  for d in (Day.mo...Day.th).iter do\n    IO.println s!\"It's {repr d}.\"\nfailed to synthesize instance for 'for_in%' notation\n  ForIn (EIO IO.Error) (Std.Iter Day) ?m.12\nThe last step to enable iteration, thus making ranges of days fully-featured, is to prove that the less-than and less-than-or-equal-to relations on Day correspond to the notions of inequality that are derived from iterating the successor function.\nThis is captured in the classes Std.PRange.LawfulUpwardEnumerableLT and Std.PRange.LawfulUpwardEnumerableLE, which require that the two notions are logically equivalent:instance : Std.PRange.LawfulUpwardEnumerableLT Day where\n  lt_iff d1 d2 := by\n    constructor\n    . intro lt\n      simp only [Std.PRange.UpwardEnumerable.LT, Day.succMany?_add_one]\n      exists d2.toNat - d1.toNat.succ\n      cases d1 <;> cases d2 <;>\n      simp_all [Day.toNat, Std.PRange.succ?, Day.succ?] <;>\n      contradiction\n    . intro ⟨steps, eq⟩\n      have := Day.succMany?_steps eq\n      cases d1 <;> cases d2 <;>\n      simp only [if_false_right] at this <;>\n      cases this <;> first | decide | contradiction\n\ninstance : Std.PRange.LawfulUpwardEnumerableLE Day where\n  le_iff d1 d2 := by\n    constructor\n    . intro le\n      simp only [Std.PRange.UpwardEnumerable.LE]\n      exists d2.toNat - d1.toNat\n      cases d1 <;> cases d2 <;>\n      simp_all [Day.toNat, Std.PRange.succ?, Day.succ?] <;>\n      contradiction\n    . intro ⟨steps, eq⟩\n      have := Day.succMany?_steps eq\n      cases d1 <;> cases d2 <;>\n      simp only [if_false_right] at this <;>\n      cases this <;> grind\nIt is now possible to iterate over ranges of days:#eval show IO Unit from do\n  for x in (Day.mo...Day.th).iter do\n    IO.println s!\"It's {repr x}\"\nIt's Day.mo\nIt's Day.tu\nIt's Day.we\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Ranges","header":"20.18.3. Implementing Ranges","id":"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Implementing-Ranges"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Executables":{"contents":"Executable TargetsTo define an executable in which all configurable fields have their default values, use lean_exe with no further fields.The default configuration can be modified by providing the new values.\n\nThe fields of lean_exe are those of the LeanExeConfig structure.\n\nA Lean executable's declarative configuration.The subdirectory of the package's source directory containing the executable's\nLean source file. Defaults simply to said srcDir.(This will be passed to lean as the -R option.)The root module of the binary executable.\nShould include a main definition that will serve\nas the entry point of the program.The root is built by recursively building its\nlocal imports (i.e., fellow modules of the workspace).Defaults to the name of the target.The name of the binary executable.\nDefaults to the target name with any . replaced with a -.An Array of targets to build before the executable's modules.Deprecated. Use needs instead.\nAn Array of target names to build before the executable's modules.Enables the executable to interpret Lean files (e.g., via\nLean.Elab.runFrontend) by exposing symbols within the  executable\nto the Lean interpreter.Implementation-wise, on Windows, the Lean shared libraries are linked\nto the executable and, on other systems, the executable is linked with\n-rdynamic. This increases the size of the binary on Linux and, on Windows,\nrequires libInit_shared.dll and libleanshared.dll to  be co-located\nwith the executable or part of PATH (e.g., via lake exe). Thus, this\nfeature should only be enabled when necessary.Defaults to false.The module facets to build and combine into the executable.\nIf shouldExport is true, the module facets should export any symbols\na user may expect to lookup in the executable. For example, the Lean\ninterpreter will use exported symbols in the executable. Thus, shouldExport\nwill be true if supportInterpreter := true.Defaults to a singleton of Module.oExportFacet (if shouldExport) or\nModule.oFacet. That is, the  object file compiled from the Lean source,\npotentially with exported Lean symbols.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format\u0009Targets","header":"24.1.3.2.4.2. Executables","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Executables"},"/Error-Explanations/About___--ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--About___--ctorResultingTypeMismatch":{"contents":"\n\nIn an inductive declaration, the resulting type of each constructor must match the type being\ndeclared; if it does not, this error is raised. That is, every constructor of an inductive type must\nreturn a value of that type. See the Inductive Types manual section for\nadditional details. Note that it is possible to omit the resulting type for a constructor if the\ninductive type being defined has no indices.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"About:  ctorResultingTypeMismatch","id":"/Error-Explanations/About___--ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--About___--ctorResultingTypeMismatch"},"/Error-Explanations/About___--propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--About___--propRecLargeElim":{"contents":"\n\nThis error occurs when attempting to eliminate a proof of a proposition into a higher type universe.\nBecause Lean's type theory does not allow large elimination from Prop, it is invalid to\npattern-match on such values—e.g., by using let or\nmatch—to produce a piece of data in a non-propositional universe\n(i.e., Type u). More precisely, the motive of a propositional recursor must be a proposition.\n(See the manual section on Subsingleton Elimination for exceptions\nto this rule.)\n\nNote that this error will arise in any expression that eliminates from a proof into a\nnon-propositional universe, even if that expression occurs within another expression of\npropositional type (e.g., in a let binding in a proof). The\n“Defining an intermediate data value within a proof” example below demonstrates such an occurrence.\nErrors of this kind can usually be resolved by moving the recursor application “outward,” so that\nits motive is the proposition being proved rather than the type of data-valued term.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"About:  propRecLargeElim","id":"/Error-Explanations/About___--propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--About___--propRecLargeElim"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Exceptions":{"contents":"Except ε α is a type which represents either an error of type ε or a successful result with a\nvalue of type α.Except ε : Type u → Type v is a Monad that represents computations that may throw exceptions:\nthe pure operation is Except.ok and the bind operation returns the first encountered\nExcept.error.A failure value of type εA success value of type α\n\nA successful computation in the Except ε monad: a is returned, and no exception is thrown.\n\nSequences two operations that may throw exceptions, allowing the second to depend on the value\nreturned by the first.If the first operation throws an exception, then it is the result of the computation. If the first\nsucceeds but the second throws an exception, then that exception is the result. If both succeed,\nthen the result is the result of the second computation.This is the implementation of the >>= operator for Except ε.\n\nTransforms a successful result with a function, doing nothing when an exception is thrown.Examples:* (pure 2 : Except String Nat).map toString = pure 2* (throw \"Error\" : Except String Nat).map toString = throw \"Error\"\n\nTransforms exceptions with a function, doing nothing on successful results.Examples:* (pure 2 : Except String Nat).mapError (·.length) = pure 2* (throw \"Error\" : Except String Nat).mapError (·.length) = throw 5\n\nHandles exceptions thrown in the Except ε monad.If ma is successful, its result is returned. If it throws an exception, then handle is invoked\non the exception's value.Examples:* (pure 2 : Except String Nat).tryCatch (pure ·.length) = pure 2* (throw \"Error\" : Except String Nat).tryCatch (pure ·.length) = pure 5* (throw \"Error\" : Except String Nat).tryCatch (fun x => throw (\"E: \" ++ x)) = throw \"E: Error\"\n\nRecovers from exceptions thrown in the Except ε monad. Typically used via the <|> operator.Except.tryCatch is a related operator that allows the recovery procedure to depend on which\nexception was thrown.\n\nReturns true if the value is Except.ok, false otherwise.\n\nReturns none if an exception was thrown, or some around the value on success.Examples:* (pure 10 : Except String Nat).toOption = some 10* (throw \"Failure\" : Except String Nat).toOption = none\n\nReturns true if the value is Except.ok, false otherwise.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Exceptions","header":"14.5.7.1. Exceptions","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Exceptions--Exceptions"},"/Notations-and-Macros/Macros/#token-antiquotations":{"contents":"In addition to antiquotations of complete syntax, Lean features token antiquotations which allow the source information of an atom to be replaced with the source information from some other syntax.\nThe resulting synthetic source information is marked canonical so that it will be used for error messages, proof states, and other feedback.\nThis is primarily useful to control the placement of error messages or other information that Lean reports to users.\nA token antiquotation does not allow an arbitrary atom to be inserted via evaluation.\nA token antiquotation consists of an atom (that is, a keyword)\n\nToken AntiquotationsToken antiquotations replace the source information (of type SourceInfo) on a token with the source information from some other syntax.\n\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009Quotation","header":"22.5.3.3. Token Antiquotations","id":"/Notations-and-Macros/Macros/#token-antiquotations"},"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Options":{"contents":"use optimization that relies on 'morally canonical' instances during type class resolution\n\nmaximum amount of heartbeats per typeclass resolution problem. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit\n\nmaximum number of instances used to construct a solution in the type class instance synthesis procedure\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.8. Options","id":"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Options"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Signature-help":{"contents":"#8511 implements signature help support in the editors.\nSee the demo in the PR description.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Signature help","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Signature-help"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Highlights--Module-System-Stabilized":{"contents":"#11637 declares the module system as no longer experimental and makes the experimental.module option a no-op.\n\nSee the Modules and Visibility section in the reference manual for the documentation.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0-rc1 (2025-12-14)\u0009Highlights","header":"Module System Stabilized","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Highlights--Module-System-Stabilized"}});