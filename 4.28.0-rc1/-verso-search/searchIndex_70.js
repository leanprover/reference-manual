window.docContents[70].resolve({"/Basic-Types/Characters/#char-syntax":{"contents":"Character literals consist of a single character or an escape sequence enclosed in single quotes (', Unicode 'APOSTROPHE' (U+0027)).\nBetween these single quotes, the character literal may contain character other that ', including newlines, which are included literally (with the caveat that all newlines in a Lean source file are interpreted as '\\n', regardless of file encoding and platform).\nSpecial characters may be escaped with a backslash, so '\\'' is a character literal that contains a single quote.\nThe following forms of escape sequences are accepted:\n\n \\r, \\n, \\t, \\\\, \\\", \\'\n\nThese escape sequences have the usual meaning, mapping to CR, LF, tab, backslash, double quote, and single quote, respectively.\n\n \\xNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the two-digit hexadecimal code.\n\n \\uNNNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the four-digit hexadecimal code.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters","header":"20.7.3. Syntax","id":"/Basic-Types/Characters/#char-syntax"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration":{"contents":"Option can be thought of as a collection that contains at most one value.\nFrom this perspective, iteration operators can be understood as performing some operation on the contained value, if present, or doing nothing if not.\n\nChecks whether an optional value either satisfies a Boolean predicate or is none.Examples:* `(some 33).all (· % 2 == 0) = false* `(some 22).all (· % 2 == 0) = true* `none.all (fun x : Nat => x % 2 == 0) = true\n\nChecks whether an optional value is not none and satisfies a Boolean predicate.Examples:* `(some 33).any (· % 2 == 0) = false* `(some 22).any (· % 2 == 0) = true* `none.any (fun x : Nat => true) = false\n\nKeeps an optional value only if it satisfies a Boolean predicate.If Option is thought of as a collection that contains at most one element, then Option.filter is\nanalogous to List.filter or Array.filter.Examples:* (some 5).filter (· % 2 == 0) = none* (some 4).filter (· % 2 == 0) = some 4* none.filter (fun x : Nat => x % 2 == 0) = none* none.filter (fun x : Nat => true) = none\n\nKeeps an optional value only if it satisfies a monadic Boolean predicate.If Option is thought of as a collection that contains at most one element, then Option.filterM\nis analogous to List.filterM.\n\nExecutes a monadic action on an optional value if it is present, or does nothing if there is no\nvalue.Examples:#eval ((some 5).forM set : StateM Nat Unit).run 0\n((), 5)\n#eval (none.forM (fun x : Nat => set x) : StateM Nat Unit).run 0\n((), 0)\n\n\nApply a function to an optional value, if present.From the perspective of Option as a container with at most one value, this is analogous to\nList.map. It can also be accessed via the Functor Option instance.Examples:* (none : Option Nat).map (· + 1) = none* (some 3).map (· + 1) = some 4\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.This is an alias for Option.mapM, which already works for applicative functors.\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.Runs a monadic function f on an optional value, returning the result. If the optional value is\nnone, the function is not called and the result is also none.From the perspective of Option as a container with at most one element, this is analogous to\nList.mapM, returning the result of running the monadic function on all elements of the container.This function only requires m to be an applicative functor. An alias Option.mapA is provided.\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"20.12.2.5. Iteration","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration"},"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Range-Related-Type-Classes":{"contents":"This typeclass provides the function succ? : α → Option α that computes the successor of\nelements of α, or none if no successor exists.\nIt also provides the function succMany?, which computes n-th successors.succ? is expected to be acyclic: No element is its own transitive successor.\nIf α is ordered, then every element larger than a : α should be a transitive successor of a.\nThese properties and the compatibility of succ? with succMany? are encoded in the typeclasses\nLawfulUpwardEnumerable, LawfulUpwardEnumerableLE and LawfulUpwardEnumerableLT.Maps elements of α to their successor, or none if no successor exists.Maps elements of α to their n-th successor, or none if no successor exists.\nThis should semantically behave like repeatedly applying succ?, but it might be more efficient.LawfulUpwardEnumerable ensures the compatibility with succ?.If no other implementation is provided in UpwardEnumerable instance, succMany? repeatedly\napplies succ?.\n\nAccording to UpwardEnumerable.LE, a is less than or equal to b if b is a or a transitive\nsuccessor of a.\n\nAccording to UpwardEnumerable.LT, a is less than b if b is a proper transitive successor of\na. 'Proper' means that b is the n-th successor of a, where n > 0.Given LawfulUpwardEnumerable α, no element of α is less than itself.\n\nThis typeclass ensures that an UpwardEnumerable α instance is well-behaved.There is no cyclic chain of successors.The 0-th successor of a is a itself.The n + 1-th successor of a is the successor of the n-th successor, given that said\nsuccessors actually exist.\n\nThe typeclass Least? α optionally provides a smallest element of α, least? : Option α.The main use case of this typeclass is to use it in combination with UpwardEnumerable to\nobtain a (possibly infinite) ascending enumeration of all elements of α.Returns the smallest element of α, or none if α is empty.Only empty types are allowed to define least? := none. If α is ordered and nonempty, then\nthe value of least? should be the smallest element according to the order on α.\n\nThis propositional typeclass ensures that UpwardEnumerable.succ? will never return none.\nIn other words, it ensures that there will always be a successor.\n\nThis propositional typeclass ensures that UpwardEnumerable.succ? is injective.The implementation of UpwardEnumerable.succ? for α is injective.\n\nThis type class ensures that right-unbounded ranges (i.e., for a bound a,\na...*, a<...* and *...*) are always finite.\nThis is a prerequisite for many functions and instances, such as\nRci.toList or ForIn'.For every elements init, there exists a chain of successors that\nresults in an element that has no successors.\n\nThis typeclass provides support for the size function for ranges with closed lower bound\n(Ric.size,\nRio.size and\nRii.size).The returned size should be equal to the number of elements returned by toList. This\ncondition is captured by the typeclass\nLawfulHasSize.Returns the number of elements starting from lo that satisfy the given upper bound.\n\nThis type class ensures that right-closed ranges (i.e., for bounds a and b,\na...=b, a<...=b and *...=b) are always finite.\nThis is a prerequisite for many functions and instances, such as\nRcc.toList or ForIn'.For every pair of elements init and hi, there exists a chain of successors that\nresults in an element that either has no successors or is greater than hi.\n\nThis typeclass provides support for the size function for ranges with closed lower bound\n(Rcc.size,\nRco.size and\nRci.size).The returned size should be equal to the number of elements returned by toList. This\ncondition is captured by the typeclass\nLawfulHasSize.Returns the number of elements starting from lo that satisfy the given upper bound.\n\n","context":"Lean Reference\u0009Basic Types\u0009Ranges","header":"20.18.2. Range-Related Type Classes","id":"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Range-Related-Type-Classes"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors":{"contents":"Mutual inductive types are provided with primitive recursors, just like non-mutually-defined inductive types.\nThese recursors take into account that they must process the other types in the group, and thus will have a motive for each inductive type.\nBecause all inductive types in the mutual group are required to have identical parameters, the recursors still take the parameters first, abstracting them over the motives and the rest of the recursor.\nAdditionally, because the recursor must process the group's other types, it will require cases for each constructor of each of the types in the group.\nThe actual dependency structure between the types is not taken into account; even if an additional motive or constructor case is not really required due to there being fewer mutual dependencies than there could be, the generated recursor still requires them.\n\nEven and oddmutual\n  inductive Even : Nat → Prop where\n    | zero : Even 0\n    | succ : Odd n → Even (n + 1)\n  inductive Odd : Nat → Prop where\n    | succ : Even n → Odd (n + 1)\nend\nEven.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : {n : Nat} → (a : Odd n) → motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) →\n  ∀ {a : Nat} (t : Even a), motive_1 a t\nOdd.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) → ∀ {a : Nat} (t : Odd a), motive_2 a t\n\n\nSpuriously mutual typesThe types Two and Three are defined in a mutual block, even though they do not refer to each other:mutual\n  inductive Two (α : Type) where\n    | mk : α → α → Two α\n  inductive Three (α : Type) where\n    | mk : α → α → α → Three α\nend\nTwo's recursor, Two.rec, nonetheless requires a motive and a case for Three:Two.rec.{u} {α : Type}\n  {motive_1 : Two α → Sort u}\n  {motive_2 : Three α → Sort u}\n  (mk : (a a_1 : α) → motive_1 (Two.mk a a_1)) :\n  ((a a_1 a_2 : α) → motive_2 (Three.mk a a_1 a_2)) → (t : Two α) → motive_1 t\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","header":"4.4.5.2. Recursors","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors"}});