window.docContents[221].resolve({"/Axioms/#print-axioms":{"contents":"The command #print axioms, followed by a defined identifier, displays all the axioms that a definition transitively relies on.\nIn other words, if a proof uses another proof, which itself uses an axiom, then the axiom is reported by #print axioms for both.\n\nThis can be used to audit the assumptions made by a proof, for instance detecting that a proof transitively depends on the sorry tactic.def lazy : 4 == 2 + 1 + 1 := by sorry\n#print axioms lazy\n'lazy' depends on axioms: [sorryAx]\nPrinting Axioms of Simple DefinitionsConsider the following three constants:def addThree (n : Nat) : Nat := 1 + n + 2\ntheorem excluded_middle (P : Prop) : P ∨ ¬ P := Classical.em P\ntheorem simple_equality (P : Prop) : (P ∨ False) = P := or_false P\nRegular functions like addThree that we might want to actually evaluation typically do not depend on any axioms:#print axioms addThree\n'addThree' does not depend on any axioms\nThe excluded middle theorem is only true if we use classical reasoning, so the foundation for classical reasoning shows up alongside other axioms:#print axioms excluded_middle\n'excluded_middle' depends on axioms: [propext, Classical.choice, Quot.sound]\nFinally, the idea that two equivalent propositions are equal directly relies on propositional extensionality.#print axioms simple_equality\n'simple_equality' depends on axioms: [propext]\nUsing #print axioms with #guard_msgsYou can use #print axioms\ntogether with #guard_msgs to ensure\nthat updates to libraries from other projects cannot silently\nintroduce unwanted dependencies on axioms.For example, if the proof of double_neg_elim below changed in such a way that it used more\naxioms than those listed, then the #guard_msgs command would report an error.theorem double_neg_elim (P : Prop) : (¬ ¬ P) = P :=\n  propext Classical.not_not\n\n/--\ninfo: 'double_neg_elim' depends on axioms:\n  [propext, Classical.choice, Quot.sound]\n-/\n#guard_msgs (whitespace := lax) in\n#print axioms double_neg_elim\n\n\n\n","context":"Lean Reference\u0009Axioms","header":"8.5. Displaying Axiom Dependencies","id":"/Axioms/#print-axioms"},"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Hashing":{"contents":"Computes a hash of a bitvector, combining 64-bit words using mixHash.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"20.5.5.5. Hashing","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Hashing"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans","header":"20.11.4. API Reference","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays","header":"20.17.1. API Reference","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Sorting":{"contents":"A stable merge sort.This function is a simplified implementation that's designed to be easy to reason about, rather than\nfor efficiency. In particular, it uses the non-tail-recursive List.merge function and traverses\nlists unnecessarily.It is replaced at runtime by an efficient implementation that has been proven to be equivalent.\n\nMerges two lists, using le to select the first element of the resulting list if both are\nnon-empty.If both input lists are sorted according to le, then the resulting list is also sorted according\nto le. O(|xs| + |ys|).This implementation is not tail-recursive, but it is replaced at runtime by a proven-equivalent\ntail-recursive merge.\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"20.15.3.9. Sorting","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Sorting"},"/Definitions/Recursive-Definitions/#mutual-partial-fixpoint":{"contents":"Lean supports the definition of mutually recursive functions using partial fixpoint.\nMutual recursion may be introduced using a mutual block, but it also results from let rec expressions and where blocks.\nThe rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the elaboration steps for mutual groups.\n\nIf all functions in the mutual group have the partial_fixpoint clause, then this strategy is used.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.4. Mutual Recursion with Partial Fixpoints","id":"/Definitions/Recursive-Definitions/#mutual-partial-fixpoint"},"/Error-Explanations/About___--synthInstanceFailed/#The-Lean-Language-Reference--Error-Explanations--About___--synthInstanceFailed":{"contents":"\n\n\n\nType classes are the mechanism that Lean and many other\nprogramming languages use to handle overloaded operations. The code that handles a particular\noverloaded operation is an instance of a type class; deciding which instance to use for a given\noverloaded operation is called synthesizing an instance.\n\nAs an example, when Lean encounters an expression x + y where x and y both\nhave type Int, it is necessary to look up how it should add two integers and also look up\nwhat the resulting type will be. This is described as synthesizing an instance of the type class\nHAdd Int Int t for some type t.\n\nMany failures to synthesize an instance of a type class are the result of using the wrong binary\noperation. Both success and failure are not always straightforward, because some instances are\ndefined in terms of other instances, and Lean must recursively search to find appropriate instances.\nIt's possible to inspect Lean's instance synthesis, and this\ncan be helpful for diagnosing tricky failures of type class instance synthesis.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"About:  synthInstanceFailed","id":"/Error-Explanations/About___--synthInstanceFailed/#The-Lean-Language-Reference--Error-Explanations--About___--synthInstanceFailed"},"/Introduction/#typographical-conventions":{"contents":"This document makes use of a number of typographical and layout conventions to indicate various aspects of the information being presented.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Introduction","header":"1.2. Typographical Conventions","id":"/Introduction/#typographical-conventions"},"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Observing-Uniqueness":{"contents":"Ensuring that arrays and strings are uniquely referenced is key to writing fast code in Lean.\nThe primitive dbgTraceIfShared can be used to check whether a data structure is aliased.\nWhen called, it returns its argument unchanged, printing the provided trace message if the argument's reference count is greater than one.\n\nDisplay the given message if a is shared, that is, RC(a) > 1\n\nDue to the specifics of how #eval is implemented, using dbgTraceIfShared with #eval can be misleading.\nInstead, it should be used in code that's explicitly compiled and run.\n\nObserving UniquenessThis program reads a line of input from the user, printing it after replacing its first character with a space.\nReplacing characters in a string uses an in-place update if the string is not shared and the characters are both contained in the 7-bit ASCII subset of Unicode.\nThe dbgTraceIfShared call does nothing, indicating that the string will indeed be updated in place rather than copied.def process (str : String) (h : str.startPos ≠ str.endPos) : IO Unit := do\n  IO.println ((dbgTraceIfShared \"String update\" str).startPos.set ' ' h)\n\ndef main : IO Unit := do\n  let line := (← (← IO.getStdin).getLine).trimAscii.copy\n  if h : line.startPos ≠ line.endPos then\n    process line h\nWhen run with this input:Here is input.\nthe program emits: ere is input.\nwith an empty standard error output:\nThis version of the program retains a reference to the original string, which necessitates copying the string in the call to String.set.\nThis fact is visible in its standard error output.def process (str : String) (h : str.startPos ≠ str.endPos) : IO Unit := do\n  IO.println ((dbgTraceIfShared \"String update\" str).startPos.set ' ' h)\n\ndef main : IO Unit := do\n  let line := (← (← IO.getStdin).getLine).trimAscii.copy\n  if h : line.startPos ≠ line.endPos then\n    process line h\n  IO.println \"Original input:\"\n  IO.println line\nWhen run with this input:Here is input.\nthe program emits: ere is input.\nOriginal input:\nHere is input.\nIn its standard error, the message passed to dbgTraceIfShared is visible.shared RC String update\n\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Reference Counting","header":"12.2.1. Observing Uniqueness","id":"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Observing-Uniqueness"}});