window.docContents[87].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Constructing-Arrays":{"contents":"Constructs a new empty array with initial capacity 0.Use Array.emptyWithCapacity to create an array with a greater initial capacity.\n\nConstructs a new empty array with initial capacity c.\n\nConstructs a single-element array that contains v.Examples:* Array.singleton 5 = #[5]* Array.singleton \"one\" = #[\"one\"]\n\nConstructs an array that contains all the numbers from 0 to n, exclusive.Examples:* Array.range 5 := #[0, 1, 2, 3, 4]* Array.range 0 := #[]* Array.range 1 := #[0]\n\nConstructs an array of numbers of size size, starting at start and increasing by\nstep at each element.In other words, Array.range' start size step is #[start, start+step, ..., start+(len-1)*step].Examples:* Array.range' 0 3 (step := 1) = #[0, 1, 2]* Array.range' 0 3 (step := 2) = #[0, 2, 4]* Array.range' 0 4 (step := 2) = #[0, 2, 4, 6]* Array.range' 3 4 (step := 2) = #[3, 5, 7, 9]\n\nReturns an array of all elements of Fin n in order, starting at 0.Examples:* Array.finRange 0 = (#[] : Array (Fin 0))* Array.finRange 2 = (#[0, 1] : Array (Fin 2))\n\nCreates an array by applying f to each potential index in order, starting at 0.Examples:* Array.ofFn (n := 3) toString = #[\"0\", \"1\", \"2\"]* Array.ofFn (fun i => #[\"red\", \"green\", \"blue\"].get i.val i.isLt) = #[\"red\", \"green\", \"blue\"]\n\nCreates an array that contains n repetitions of v.The corresponding List function is List.replicate.Examples:* Array.replicate 2 true = #[true, true]* Array.replicate 3 () = #[(), (), ()]* Array.replicate 0 \"anything\" = #[]\n\nAppends two arrays. Normally used via the ++ operator.Appending arrays takes time proportional to the length of the second array.Examples:* #[1, 2, 3] ++ #[4, 5] = #[1, 2, 3, 4, 5].* #[] ++ #[4, 5] = #[4, 5].* #[1, 2, 3] ++ #[] = #[1, 2, 3].\n\nAppends an array and a list.Takes time proportional to the length of the list..Examples:* #[1, 2, 3].appendList [4, 5] = #[1, 2, 3, 4, 5].* #[].appendList [4, 5] = #[4, 5].* #[1, 2, 3].appendList [] = #[1, 2, 3].\n\nPads xs : Array α on the left with repeated occurrences of a : α until it is of size n. If xs\nalready has at least n elements, it is returned unmodified.Examples:* #[1, 2, 3].leftpad 5 0 = #[0, 0, 1, 2, 3]* #[\"red\", \"green\", \"blue\"].leftpad 4 \"blank\" = #[\"blank\", \"red\", \"green\", \"blue\"]* #[\"red\", \"green\", \"blue\"].leftpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]* #[\"red\", \"green\", \"blue\"].leftpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]\n\nPads xs : Array α on the right with repeated occurrences of a : α until it is of length n. If\nl already has at least n elements, it is returned unmodified.Examples:* #[1, 2, 3].rightpad 5 0 = #[1, 2, 3, 0, 0]* #[\"red\", \"green\", \"blue\"].rightpad 4 \"blank\" = #[\"red\", \"green\", \"blue\", \"blank\"]* #[\"red\", \"green\", \"blue\"].rightpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]* #[\"red\", \"green\", \"blue\"].rightpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"20.16.4.1. Constructing Arrays","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Constructing-Arrays"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Patterns":{"contents":"String slices feature generalized search patterns.\nRather than being defined to work only for characters or for strings, many operations on slices accept arbitrary patterns.\nNew types can be made into patterns by defining instances of the classes in this section.\nThe Lean standard library provides instances that allow the following types to be used for both forward and backward searching:\n\n* Pattern Type* Meaning* Char* Matches the provided character\n* Char → Bool* Matches any character that satisfies the predicate* String* Matches occurrences of the given string* String.Slice* Matches occurrences of the string represented by the slice\n\nProvides a conversion from a pattern to an iterator of SearchStep that searches for matches\nof the pattern from the start towards the end of a Slice.Builds an iterator of SearchStep corresponding to matches of pat along the slice\ns. The SearchSteps returned by this iterator must contain ranges that are\nadjacent, non-overlapping and cover all of s.\n\nProvides simple pattern matching capabilities from the start of a Slice.While these operations can be implemented on top of ToForwardSearcher some patterns allow\nfor more efficient implementations. This class can be used to specialize for them. If there is no\nneed to specialize in this fashion, then\nForwardPattern.defaultImplementation can be used\nto automatically derive an instance.Checks whether the slice starts with the pattern.Checks whether the slice starts with the pattern. If it does, the slice is returned with the\nprefix removed; otherwise the result is none.\n\nProvides a conversion from a pattern to an iterator of SearchStep searching for matches of\nthe pattern from the end towards the start of a Slice.Build an iterator of SearchStep corresponding to matches of pat along the slice\ns. The SearchSteps returned by this iterator must contain ranges that are\nadjacent, non-overlapping and cover all of s.\n\nProvides simple pattern matching capabilities from the end of a Slice.While these operations can be implemented on top of ToBackwardSearcher, some patterns allow\nfor more efficient implementations. This class can be used to specialize for them. If there is no\nneed to specialize in this fashion, then\nBackwardPattern.defaultImplementation can be\nused to automatically derive an instance.Checks whether the slice ends with the pattern.Checks whether the slice ends with the pattern. If it does, the slice is returned with the\nsuffix removed; otherwise the result is none.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices","header":"20.8.4.11.2. Patterns","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--Patterns"},"/Build-Tools-and-Distribution/#build-tools-and-distribution":{"contents":"The Lean toolchain is the collection of command-line tools that are used to check proofs and compile programs in collections of Lean files.\nToolchains are managed by elan, which installs toolchains as needed.\nLean toolchains are designed to be self-contained, and most command-line users will never need to explicitly invoke any other than lake and elan.\nThey contain the following tools: lean\n\nThe Lean compiler, used to elaborate and compile a Lean source file.\n\n lake\n\nThe Lean build tool, used to incrementally invoke lean and other tools while tracking dependencies.\n\n leanc\n\nThe C compiler that ships with Lean, which is a version of Clang.\n\n leanmake\n\nAn implementation of the make build tool, used for compiling C dependencies.\n\n leanchecker\n\nA tool that replays elaboration results from .olean files through the Lean kernel, providing additional assurance that all terms were properly checked.\n\n\n\nIn addition to these build tools, toolchains contain files that are needed to build Lean code.\nThis includes source code, .olean files, compiled libraries, C header files, and the compiled Lean run-time system.\nThey also include external proof automation tools that are used by tactics included with Lean, such as cadical for bv_decide.\n\n\n\n\n\n","context":"Lean Reference","header":"24. Build Tools and Distribution","id":"/Build-Tools-and-Distribution/#build-tools-and-distribution"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Inhabited-Types":{"contents":"Inhabited α is a typeclass that says that α has a designated element,\ncalled (default : α). This is sometimes referred to as a \"pointed type\".This class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, Array.get! arr i : α returns\na value of type α when arr : Array α, but if i is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type α (and in fact this is required\nfor logical consistency), so in this case it returns default.default is a function that produces a \"default\" element of any\nInhabited type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value.\n\nNonempty α is a typeclass that says that α is not an empty type,\nthat is, there exists an element in the type. It differs from Inhabited α\nin that Nonempty α is a Prop, which means that it does not actually carry\nan element of α, only a proof that there exists such an element.\nGiven Nonempty α, you can construct an element of α nonconstructively\nusing Classical.choice.If val : α, then α is nonempty.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"10.5.5. Inhabited Types","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Inhabited-Types"},"/Type-Classes/Class-Declarations/#class-inductive":{"contents":"Most type classes follow the paradigm of a set of overloaded methods from which clients may choose freely.\nThis is naturally modeled by a product type, from which the overloaded methods are projections.\nSome classes, however, are sum types: they require that the recipient of the synthesized instance first check which of the available instance constructors was provided.\nTo account for these classes, a class declaration may consist of an arbitrary inductive type, not just an extended form of structure declaration.\n\nClass Inductive Type Declarations\n\nClass inductive types are just like other inductive types, except they may participate in instance synthesis.\nThe paradigmatic example of a class inductive is Decidable: synthesizing an instance in a context with free variables amounts to synthesizing the decision procedure, but if there are no free variables, then the truth of the proposition can be established by instance synthesis alone (as is done by the decide tactic).\n\n","context":"Lean Reference\u0009Type Classes\u0009Class Declarations","header":"10.1.1. Sum Types as Classes","id":"/Type-Classes/Class-Declarations/#class-inductive"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Displaying-import-hierarchy":{"contents":"#8654 (together with #620 for vscode-lean4) adds\na new module hierarchy component in\nVS Code that can be used to navigate both the import tree of a module\nand the imported-by tree of a module.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Displaying import hierarchy","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Displaying-import-hierarchy"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Language":{"contents":"* #11553 makes simpH, used in the match equation generator, produce a\n  proof term. This is in preparation for a bigger refactoring in #11512.* #11666 makes sure that when a matcher is compiled using a sparse cases,\n  that equation generation also uses sparse cases to split.\n  This fixes #11665.* #11669 makes sure that proofs about ctorIdx passed to grind pass\n  the debug.grind checks, despite reducing a semireducible definition.* #11670 fixes the grind support for Nat.ctorIdx. Nat constructors\n  appear in grind as offsets or literals, and not as a node marked\n  .constr, so handle that case as well.* #11673 fixes an issue where a by in the public scope could create an\n  auxiliary theorem for the proof whose type does not match the expected\n  type in the public scope.* #11696 improves match generalization such that it abstracts\n  metavariables in types of local variables and in the result type of the\n  match over the match discriminants. Previously, a metavariable in the\n  result type would silently default to the behavior of generalizing :=\n  false, and a metavariable in the type of a free variable would lead to\n  an error (#8099). Example of a match that elaborates now but\n  previously wouldn't:example (a : Nat) (ha : a = 37) :=\n    (match a with | 42 => by contradiction | n => n) = 37\nThis is because the result type of the match is a metavariable that\n  was not abstracted over a and hence generalization failed; the result\n  is that contradiction cannot pick up the proof ha : 42 = 37.\n  The old behavior can be recovered by passing (generalizing := false)\n  to the match.* #11698 makes mvcgen early return after simplifying discriminants,\n  avoiding a rewrite on an ill-formed match.* #11714 gives a focused error message when a user tries to name an\n  example, and tweaks error messages for attempts to define multiple\n  opaque names at once.* #11718 adds a test for issue #11655, which it seems was fixed by #11695* #11721 improves the performance of the functions for generating\n  congruence lemmas, used by simp\n  and a few other components.* #11726 upstreams dependency-management commands from Mathlib:* #import_path Foo prints the transitive import chain that brings\n  Foo into scope* assert_not_exists Foo errors if declaration Foo exists (for\n  dependency management)* assert_not_imported Module warns if Module is transitively\n  imported* #check_assertions verifies all pending assertions are eventually\n  satisfied* #11731 makes the cache in expreqfn use mimalloc for a small\n  performance win across the board.* #11748 fixes an edge case where some tactics did not allow access to\n  private declarations inside private proofs under the module system* #11756 fixes an issue where grind fails when trying to unfold a\n  definition by pattern matching imported by import all (or from a\n  non-module).* #11780 ensures that pretty-printing of unification hints inserts a\n  space after |- resp. ⊢.* #11871 makes mvcgen with tac fail if tac fails on one of the VCs,\n  just as induction ... with tac fails if tac fails on one of the\n  goals. The old behavior can be recovered by writing mvcgen with try\n  tac instead.* #11875 adds the directory Meta/DiscrTree and reorganizes the code\n  into different files. Motivation: we are going to have new functions for\n  retrieving simplification theorems for the new structural simplifier.* #11882 adds a guard to TagDeclarationExtension.tag to check if the\n  declaration name is anonymous and return early if so. This prevents a\n  panic that could occur when modifiers like meta or noncomputable are\n  used in combination with syntax errors.* #11896 fixes a panic that occurred when a theorem had a docstring on an\n  auxiliary definition within a where clause.* #11908 adds two features to the message testing commands:\n  a new #guard_panic command that succeeds if the nested command produces\n  a panic message (useful for testing commands expected to panic), and a\n  substring := true option for #guard_msgs that checks if the docstring\n  appears as a substring of the output rather than requiring an exact match.* #11919 improves the error message when initialize (or opaque) fails\n  to find an Inhabited or Nonempty instance.* #11926 adds an unsafe modifier to an existing helper function user\n  unsafeEIO, and also leaves the function private.* #11933 adds utility functions for managing the message log during\n  tactic\n  evaluation, and refactors existing code to use them.* #11940 fixes module system visibiltity issues when trying to declare a\n  public inductive inside a mutual block.* #11941 reverts #11696.* #11991 fixes declare_syntax_cat declaring a local category leading to\n  import errors when used in module without public section.* #12026 fixes an issue where attributes like @[irreducible] would not\n  be allowed under the module system unless combined with @[exposed],\n  but the former may be helpful without the latter to ensure downstream\n  non-modules are also affected.* #12045 disables the import all check across package boundaries. Now\n  any module can import all any other module.* #12048 fixes a bug where mvcgen loses VCs, resulting in unassigned\n  metavariables. It is fixed by making all emitted VCs synthetic opaque.* #12122 adds support for Verso docstrings in where clauses.* #12148 reverts #12000, which introduced a regression where simp\n  incorrectly rejects valid rewrites for perm lemmas.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0 (2026-01-26)","header":"Language","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Language"}});