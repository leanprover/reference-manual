window.docContents[237].resolve({"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans":{"contents":"The Boolean values, true and false.Logically speaking, this is equivalent to Prop (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile Bool corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.The Boolean value false, not to be confused with the proposition False.The Boolean value true, not to be confused with the proposition True.\n\nThe constructors Bool.true and Bool.false are exported from the Bool namespace, so they can be written true and false.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.11. Booleans","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering--Partitioning":{"contents":"Extracts the first n elements of xs, or the whole list if n is greater than xs.length.O(min n |xs|).Examples:* [a, b, c, d, e].take 0 = []* [a, b, c, d, e].take 3 = [a, b, c]* [a, b, c, d, e].take 6 = [a, b, c, d, e]\n\nExtracts the first n elements of xs, or the whole list if n is greater than xs.length.O(min n |xs|). This is a tail-recursive version of List.take, used at runtime.Examples:* [a, b, c, d, e].takeTR 0 = []* [a, b, c, d, e].takeTR 3 = [a, b, c]* [a, b, c, d, e].takeTR 6 = [a, b, c, d, e]\n\nReturns the longest initial segment of xs for which p returns true.O(|xs|).Examples:* [7, 6, 4, 8].takeWhile (· > 5) = [7, 6]* [7, 6, 6, 5].takeWhile (· > 5) = [7, 6, 6]* [7, 6, 6, 8].takeWhile (· > 5) = [7, 6, 6, 8]\n\nReturns the longest initial segment of xs for which p returns true.O(|xs|). This is a tail-recursive version of List.take, used at runtime.Examples:* [7, 6, 4, 8].takeWhileTR (· > 5) = [7, 6]* [7, 6, 6, 5].takeWhileTR (· > 5) = [7, 6, 6]* [7, 6, 6, 8].takeWhileTR (· > 5) = [7, 6, 6, 8]\n\nRemoves the first n elements of the list xs. Returns the empty list if n is greater than the\nlength of the list.O(min n |xs|).Examples:* [0, 1, 2, 3, 4].drop 0 = [0, 1, 2, 3, 4]* [0, 1, 2, 3, 4].drop 3 = [3, 4]* [0, 1, 2, 3, 4].drop 6 = []\n\nRemoves the longest prefix of a list for which p returns true.Elements are removed from the list until one is encountered for which p returns false. This\nelement and the remainder of the list are returned.O(|l|).Examples:* [1, 3, 2, 4, 2, 7, 4].dropWhile (· < 4) = [4, 2, 7, 4]* [8, 3, 2, 4, 2, 7, 4].dropWhile (· < 4) = [8, 3, 2, 4, 2, 7, 4]* [8, 3, 2, 4, 2, 7, 4].dropWhile (· < 100) = []\n\nRemoves the last element of the list, if one exists.Examples:* [].dropLast = []* [\"tea\"].dropLast = []* [\"tea\", \"coffee\", \"juice\"].dropLast = [\"tea\", \"coffee\"]\n\nRemoves the last element of the list, if one exists.This is a tail-recursive version of List.dropLast, used at runtime.Examples:* [].dropLastTR = []* [\"tea\"].dropLastTR = []* [\"tea\", \"coffee\", \"juice\"].dropLastTR = [\"tea\", \"coffee\"]\n\nSplits a list at an index, resulting in the first n elements of l paired with the remaining\nelements.If n is greater than the length of l, then the resulting pair consists of l and the empty\nlist. List.splitAt is equivalent to a combination of List.take and List.drop, but it is more\nefficient.Examples:* [\"red\", \"green\", \"blue\"].splitAt 2 = ([\"red\", \"green\"], [\"blue\"])* [\"red\", \"green\", \"blue\"].splitAt 3 = ([\"red\", \"green\", \"blue], [])* [\"red\", \"green\", \"blue\"].splitAt 4 = ([\"red\", \"green\", \"blue], [])\n\nSplits a list into the longest initial segment for which p returns true, paired with the\nremainder of the list.O(|l|).Examples:* [6, 8, 9, 5, 2, 9].span (· > 5) = ([6, 8, 9], [5, 2, 9])* [6, 8, 9, 5, 2, 9].span (· > 10) = ([], [6, 8, 9, 5, 2, 9])* [6, 8, 9, 5, 2, 9].span (· > 0) = ([6, 8, 9, 5, 2, 9], [])\n\nSplits a list into the longest segments in which each pair of adjacent elements are related by R.O(|l|).Examples:* [1, 1, 2, 2, 2, 3, 2].splitBy (· == ·) = [[1, 1], [2, 2, 2], [3], [2]]* [1, 2, 5, 4, 5, 1, 4].splitBy (· < ·) = [[1, 2, 5], [4, 5], [1, 4]]* [1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ => true) = [[1, 2, 5, 4, 5, 1, 4]]* [1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ => false) = [[1], [2], [5], [4], [5], [1], [4]]\n\nReturns a pair of lists that together contain all the elements of as. The first list contains\nthose elements for which p returns true, and the second contains those for which p returns\nfalse.O(|l|). as.partition p is equivalent to (as.filter p, as.filter (not ∘ p)), but it is slightly\nmore efficient since it only has to do one pass over the list.Examples:* [1, 2, 5, 2, 7, 7].partition (· > 2) = ([5, 7, 7], [1, 2, 2])* [1, 2, 5, 2, 7, 7].partition (fun _ => false) = ([], [1, 2, 5, 2, 7, 7])* [1, 2, 5, 2, 7, 7].partition (fun _ => true) = ([1, 2, 5, 2, 7, 7], [])\n\nReturns a pair of lists that together contain all the elements of as. The first list contains\nthose elements for which the monadic predicate p returns true, and the second contains those for\nwhich p returns false. The list's elements are examined in order, from left to right.This is a monadic version of List.partition.Example:def posOrNeg (x : Int) : Except String Bool :=\n  if x > 0 then pure true\n  else if x < 0 then pure false\n  else throw \"Zero is not positive or negative\"\n#eval [-1, 2, 3].partitionM posOrNeg\nExcept.ok ([2, 3], [-1])\n#eval [0, 2, 3].partitionM posOrNeg\nExcept.error \"Zero is not positive or negative\"\n\n\nApplies a function that returns a disjoint union to each element of a list, collecting the Sum.inl\nand Sum.inr results into separate lists.Examples:* [0, 1, 2, 3].partitionMap (fun x => if x % 2 = 0 then .inl x else .inr x) = ([0, 2], [1, 3])* [0, 1, 2, 3].partitionMap (fun x => if x = 0 then .inl x else .inr x) = ([0], [1, 2, 3])\n\nGroups the elements of a list xs according to the function key, returning a hash map in which\neach group is associated with its key. Groups preserve the relative order of elements in xs.Example:#eval [0, 1, 2, 3, 4, 5, 6].groupByKey (· % 2)\nStd.HashMap.ofList [(0, [0, 2, 4, 6]), (1, [1, 3, 5])]\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference\u0009Filtering","header":"20.15.3.12.1. Partitioning","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering--Partitioning"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key a or a key that is equal to a according\nto the comparator cmp. There is also a Prop-valued version\nof this: a ∈ t is equivalent to t.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for equality checks, while for tree maps, both use the given comparator cmp.\n\nGiven a proof that a mapping for the given key is present, retrieves the mapping for the given key.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, panicking if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning none if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\nReturns a list of all keys present in the tree map in ascending  order.\n\nReturns an array of all keys present in the tree map in ascending  order.\n\nReturns a list of all values present in the tree map in ascending  order.\n\nReturns an array of all values present in the tree map in ascending  order.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps","header":"20.19.8.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries"},"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Transformation":{"contents":"Transforms a pair by applying functions to both elements.Examples:* (1, 2).map (· + 1) (· * 3) = (2, 6)* (1, 2).map toString (· * 3) = (\"1\", 6)\n\nSwaps the elements in a pair.Examples:* (1, 2).swap = (2, 1)* (\"orange\", -87).swap = (-87, \"orange\")\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples\u0009Ordered Pairs\u0009API Reference","header":"20.13.1.1.1. Transformation","id":"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Transformation"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Packaging-and-Distribution--Cached-Cloud-Builds":{"contents":"These commands are still experimental.\nThey are likely change in future versions of Lake based on user feedback.\nPackages that use Reservoir cloud build archives should enable the platformIndependent setting.\n\n\n\nPacks the root package's build directory into a gzipped tar archive using tar.\nIf a path for the archive is not specified, the archive in the package's Lake directory (.lake) and named according to its buildArchive setting.\nThis command does not build any artifacts: it only archives what is present.\nUsers should ensure that the desired artifacts are present before running this command.\n\n\n\nUnpacks the contents of the gzipped tar archive archive.tgz into the root package's build directory.\nIf archive.tgz is not specified, the package's buildArchive setting is used to determine a filename, and the file is expected in package's Lake directory (.lake).\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface\u0009Packaging and Distribution","header":"24.1.2.10.1. Cached Cloud Builds","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Packaging-and-Distribution--Cached-Cloud-Builds"},"/Definitions/Recursive-Definitions/#structural-recursion":{"contents":"Structurally recursive functions are those in which each recursive call is on a structurally smaller term than the argument.\nThe same parameter must decrease in all recursive calls; this parameter is called the decreasing parameter.\nStructural recursion is stronger than the primitive recursion that recursors provide, because the recursive call can use more deeply nested sub-terms of the argument, rather than only an immediate sub-term.\nThe constructions used to implement structural recursion are, however, implemented using the recursor; these helper constructions are described in the section on inductive types.\n\nThe rules that govern structural recursion are fundamentally syntactic in nature.\nThere are many recursive definitions that exhibit structurally recursive computational behavior, but which are not accepted by these rules; this is a fundamental consequence of the analysis being fully automatic.\nWell-founded recursion provides a semantic approach to demonstrating termination that can be used in situations where a recursive function is not structurally recursive, but it can also be used when a function that computes according to structural recursion doesn't satisfy the syntactic requirements.\n\n\n\nStructural Recursion vs SubtractionThe function countdown is structurally recursive.\nThe parameter n was matched against the pattern n' + 1, which means that n' is a direct subterm of n in the second branch of the pattern match:def countdown (n : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n' + 1 => n' :: countdown n'\nReplacing pattern matching with an equivalent Boolean test and subtraction results in an error:def countdown' (n : Nat) : List Nat :=\n  if n == 0 then []\n  else\n    let n' := n - 1\n    n' :: countdown' n'\nfail to show termination for\n  countdown'\nwith errors\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    countdown' n'\n\n\nfailed to prove termination, possible solutions:\n  - Use `have`-expressions to prove the remaining goals\n  - Use `termination_by` to specify a different well-founded relation\n  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\nn : Nat\nh✝ : ¬(n == 0) = true\nn' : Nat := n - 1\n⊢ n - 1 < n\nThis is because there was no pattern matching on the parameter n.\nWhile this function indeed terminates, the argument that it does so is based on properties of if, the equality test, and subtraction, rather than being a generic feature of Nat being an inductive type.\nThese arguments are expressed using well-founded recursion, and a slight change to the function definition allows Lean's automatic support for well-founded recursion to construct an alternative termination proof.\nThis version branches on the decidability of propositional equality for Nat rather than the result of a Boolean equality test:def countdown' (n : Nat) : List Nat :=\n  if n = 0 then []\n  else\n    let n' := n - 1\n    n' :: countdown' n'\nHere, Lean's automation automatically constructs a termination proof from facts about propositional equality and subtraction.\nIt uses well-founded recursion rather than structural recursion behind the scenes.\n\n\n\nStructural recursion may be used explicitly or automatically.\nWith explicit structural recursion, the function definition declares which parameter is the decreasing parameter.\nIf no termination strategy is explicitly declared, Lean performs a search for a decreasing parameter as well as a decreasing measure for use with well-founded recursion.\nExplicitly annotating structural recursion has the following benefits:\n\n* It can speed up elaboration, because no search occurs.* It documents the termination argument for readers.* In situations where structural recursion is explicitly desired, it prevents the accidental use of well-founded recursion.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.2. Structural Recursion","id":"/Definitions/Recursive-Definitions/#structural-recursion"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-sequencing":{"contents":"In addition to running tactics one after the other, each being used to solve the main goal, the tactic language supports sequencing tactics according to the way in which goals are produced.\nThe <;> tactic combinator allows a tactic to be applied to every subgoal produced by some other tactic.\nIf no new goals are produced, then the second tactic is not run.\n\ntac <;> tac' runs tac on the main goal and tac' on each produced goal,\nconcatenating all goals produced by tac'.If the tactic fails on any of the subgoals, then the whole <;> tactic fails.\n\nSubgoal SequencingIn this proof state:x : Nat\nh : x = 1 ∨ x = 2\n⊢ x < 3\nthe tactic cases h yields the following two goals:case inl\nx : Nat\nh✝ : x = 1\n⊢ x < 3\n\ncase inr\nx : Nat\nh✝ : x = 2\n⊢ x < 3\nRunning cases h ; simp [*] causes simp to solve the first goal, leaving the second behind:case inr\nx : Nat\nh✝ : x = 2\n⊢ x < 3\nReplacing the ; with <;> and running cases h <;> simp [*] solves both of the new goals with simp:\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures\u0009Goal Selection","header":"14.3.1.3.1. Sequencing","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-sequencing"},"/The--mvcgen--tactic/Enabling--mvcgen--For-Monads/#The-Lean-Language-Reference--The--mvcgen--tactic--Enabling--mvcgen--For-Monads":{"contents":"If a monad is implemented in terms of monad transformers that are provided by the Lean standard library, such as ExceptT and StateT, then it should not require additional instances.\nOther monads will require instances of WP, LawfulMonad, and WPMonad.\nThe tactic has been designed to support monads that model single-threaded control with state that might be interrupted; in other words, the effects that are present in ordinary imperative programming.\nMore exotic effects have not yet been investigated.\n\nOnce the basic instances are provided, the next step is to prove an adequacy lemma.\nThis lemma should show that the weakest precondition for running the monadic computation and asserting a desired predicate is in fact sufficient to prove the predicate.\n\nIn addition to the definition of the monad, typical libraries provide a set of primitive operators.\nEach of these should be provided with a specification lemma.\nIt may additionally be useful to make the internals of the state private, and export a carefully-designed set of assertion operators.\n\nThe specification lemmas for the library's primitive operators should ideally be precise specifications of the operators as predicate transformers.\nWhile it's often easier to think in terms of how the operator transforms an input state into an output state, verification condition generation will work more reliably when postconditions are completely free.\nThis allows automation to instantiate the postcondition with the exact precondition of the next statement, rather than needing to show an entailment.\nIn other words, specifications that specify the precondition as a function of the postcondition work better in practice than specifications that merely relate the pre- and postconditions.\n\nSchematic PostconditionsThe function double doubles a natural number state:def double : StateM Nat Unit := do\n  modify (2 * ·)\nThinking chronologically, a reasonable specification is that value of the output state is twice that of the input state.\nThis is expressed using a schematic variable that stands for the initial state:theorem double_spec :\n    ⦃ fun s => ⌜s = n⌝ ⦄ double ⦃ ⇓ () s => ⌜s = 2 * n⌝ ⦄ := by\n  simp [double]\n  mvcgen with grind\nHowever, an equivalent specification that treats the postcondition schematically will lead to smaller verification conditions when double is used in other functions:@[spec]\ntheorem better_double_spec {Q : PostCond Unit (.arg Nat .pure)} :\n    ⦃ fun s => Q.1 () (2 * s) ⦄ double ⦃ Q ⦄ := by\n  simp [double]\n  mvcgen with grind\nThe first projection of the postcondition is its stateful assertion.\nNow, the precondition merely states that the postcondition should hold for double the initial state.\n\nA Logging MonadThe monad LogM maintains an append-only log during a computation:structure LogM (β : Type u) (α : Type v) : Type (max u v) where\n  log : Array β\n  value : α\n\ninstance : Monad (LogM β) where\n  pure x := ⟨#[], x⟩\n  bind x f :=\n    let { log, value } := f x.value\n    { log := x.log ++ log, value }\nIt has a LawfulMonad instance as well.The log can be written to using log, and a value and the associated log can be computed using LogM.run.def log (v : β) : LogM β Unit := { log := #[v], value := () }\n\ndef LogM.run (x : LogM β α) : α × Array β := (x.value, x.log)\nRather than writing it from scratch, the WP instance uses PredTrans.pushArg.\nThis operator was designed to model state monads, but LogM can be seen as a state monad that can only append to the state.\nThis appending is visible in the body of the instance, where the initial state and the log that resulted from the action are appended:instance : WP (LogM β) (.arg (Array β) .pure) where\n  wp\n    | { log, value } =>\n      PredTrans.pushArg (fun s => PredTrans.pure (value, s ++ log))\nThe WPMonad instance also benefits from the conceptual model as a state monad and admits very short proofs:instance : WPMonad (LogM β) (.arg (Array β) .pure) where\n  wp_pure x := by\n    simp [wp, PredTrans.pushArg, PredTrans.pure, Pure.pure]\n  wp_bind := by\n    simp [wp, PredTrans.pushArg, PredTrans.bind, Bind.bind]\nThe adequacy lemma has one important detail: the result of the weakest precondition transformation is applied to the empty array.\nThis is necessary because the logging computation has been modeled as an append-only state, so there must be some initial state.\nSemantically, the empty array is the correct choice so as to not place items in a log that don't come from the program; technically, it must also be a value that commutes with the append operator on arrays.theorem LogM.of_wp_run_eq {x : α × Array β} {prog : LogM β α}\n    (h : LogM.run prog = x) (P : α × Array β → Prop) :\n    (⊢ₛ wp⟦prog⟧ (⇓ v l => ⌜P (v, l)⌝) #[]) → P x := by\n  rw [← h]\n  intro h'\n  simp [wp] at h'\n  exact h'\nNext, each operator in the library should be provided with a specification lemma.\nThere is only one: log.\nFor new monads, these proofs must often break the abstraction boundaries of Hoare triples and weakest preconditions; the specifications that they provide can then be used abstractly by clients of the library.theorem log_spec {x : β} :\n    ⦃ fun s => ⌜s = s'⌝ ⦄ log x ⦃ ⇓ () s => ⌜s = s'.push x⌝ ⦄ := by\n  simp [log, Triple, wp]\nA better specification for log uses a schematic postcondition:variable {Q : PostCond Unit (.arg (Array β) .pure)}\n\n@[spec]\ntheorem log_spec_better {x : β} :\n    ⦃ fun s => Q.1 () (s.push x) ⦄ log x ⦃ Q ⦄ := by\n  simp [log, Triple, wp]\nA function logUntil that logs all the natural numbers up to some bound will always result in a log whose length is equal to its argument:def logUntil (n : Nat) : LogM Nat Unit := do\n  for i in 0...n do\n    log i\n\ntheorem logUntil_length : (logUntil n).run.2.size = n := by\n  generalize h : (logUntil n).run = x\n  unfold logUntil at h\n  apply LogM.of_wp_run_eq h\n  mvcgen invariants\n  · ⇓⟨xs, _⟩ s => ⌜xs.pos = s.size⌝\n  with\n    simp_all [List.Cursor.pos] <;>\n    grind [Std.PRange.Nat.size_rco, Std.Rco.length_toList]\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic","header":"17.4. Enabling  mvcgen  For Monads","id":"/The--mvcgen--tactic/Enabling--mvcgen--For-Monads/#The-Lean-Language-Reference--The--mvcgen--tactic--Enabling--mvcgen--For-Monads"}});