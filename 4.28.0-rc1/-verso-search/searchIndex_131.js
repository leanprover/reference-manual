window.docContents[131].resolve({"/Axioms/#axioms":{"contents":"Axioms are postulated constants.\nWhile the axiom's type must itself be a type (that is, it must have type Sort u), there are no further requirements.\nAxioms do not reduce to other terms.\n\nAxioms can be used to experiment with the consequences of an idea before investing the time required to construct a model or prove a theorem.\nThey can also be used to adopt reasoning principles that can't otherwise be accessed in Lean's type theory; Lean itself provides three such axioms that are known to be consistent.\nHowever, axioms should be used with caution: axioms that are inconsistent with one another, or just false, undermine the very foundations of proofs.\nLean automatically tracks the axioms that each proof depends on so that they can be audited.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"8. Axioms","id":"/Axioms/#axioms"},"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Size":{"contents":"Computes the size of the subarray.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","header":"20.16.5.2. Size","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Size"},"/Basic-Types/Maps-and-Sets/#DTreeMap":{"contents":"The declarations in this section should be imported using import Std.DTreeMap.\n\nDependent tree maps.A tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one entry\nwith key either a or b in a tree map. Looking up either a or b always yields the same entry,\nif any is present. The get operations of the dependent tree map additionally require a\nLawfulEqCmp instance to ensure that cmp a b = .eq always implies a = b, so that their\nrespective value types are equal.To avoid expensive copies, users should make sure that the tree map is used linearly.Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.For use in proofs, the type Std.ExtDTreeMap of extensional dependent tree maps should be\npreferred. This type comes with several extensionality lemmas and provides the same functions but\nrequires a TransCmp instance to work with.These tree maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.DTreeMap.Raw and\nStd.DTreeMap.Raw.WF unbundle the invariant from the tree map. When in doubt, prefer\nDTreeMap over DTreeMap.Raw.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"20.19.9. Dependent Tree-Based Maps","id":"/Basic-Types/Maps-and-Sets/#DTreeMap"},"/Basic-Types/Strings/#string-api-lookup":{"contents":"Operations that select a sub-region of a string (for example, a prefix or suffix of it) return a slice into the original string rather than allocating a new string.\nUse String.Slice.copy to convert the slice into a new string.\n\nReturns a String.Slice that contains the first n characters (Unicode code points) of\ns.If n is greater than s.length, returns s.toSlice.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.Examples:* \"red green blue\".take 3 == \"red\".toSlice* \"red green blue\".take 1 == \"r\".toSlice* \"red green blue\".take 0 == \"\".toSlice* \"red green blue\".take 100 == \"red green blue\".toSlice* \"مرحبا بالعالم\".take 5 == \"مرحبا\".toSlice\n\nCreates a string slice that contains the longest prefix of s in which pat matched\n(potentially repeatedly).This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".takeWhile Char.isLower == \"red\".toSlice* \"red green blue\".takeWhile 'r' == \"r\".toSlice* \"red red green blue\".takeWhile \"red \" == \"red red \".toSlice* \"red green blue\".takeWhile (fun (_ : Char) => true) == \"red green blue\".toSlice\n\nReturns a String.Slice that contains the last n characters (Unicode code points) of\ns.If n is greater than s.length, returns s.toSlice.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.Examples:* \"red green blue\".takeEnd 4 == \"blue\".toSlice* \"red green blue\".takeEnd 1 == \"e\".toSlice* \"red green blue\".takeEnd 0 == \"\".toSlice* \"red green blue\".takeEnd 100 == \"red green blue\".toSlice* \"مرحبا بالعالم\".takeEnd 5 == \"لعالم\".toSlice\n\nCreates a string slice that contains the longest suffix of s in which pat matched\n(potentially repeatedly).This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".takeEndWhile Char.isLower == \"blue\".toSlice* \"red green blue\".takeEndWhile 'e' == \"e\".toSlice* \"red green blue\".takeEndWhile (fun (_ : Char) => true) == \"red green blue\".toSlice\n\nReturns a String.Slice obtained by removing the specified number of characters (Unicode code\npoints) from the start of the string.If n is greater than s.length, returns an empty slice.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.Examples:* \"red green blue\".drop 4 == \"green blue\".toSlice* \"red green blue\".drop 10 == \"blue\".toSlice* \"red green blue\".drop 50 == \"\".toSlice* \"مرحبا بالعالم\".drop 3 == \"با بالعالم\".toSlice\n\nCreates a string slice by removing the longest prefix from s in which pat matched\n(potentially repeatedly).This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".dropWhile Char.isLower == \" green blue\".toSlice* \"red green blue\".dropWhile 'r' == \"ed green blue\".toSlice* \"red red green blue\".dropWhile \"red \" == \"green blue\".toSlice* \"red green blue\".dropWhile (fun (_ : Char) => true) == \"\".toSlice\n\nReturns a String.Slice obtained by removing the specified number of characters (Unicode code\npoints) from the end of the string.If n is greater than s.length, returns an empty slice.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.Examples:* \"red green blue\".dropEnd 5 == \"red green\".toSlice* \"red green blue\".dropEnd 11 == \"red\".toSlice* \"red green blue\".dropEnd 50 == \"\".toSlice* \"مرحبا بالعالم\".dropEnd 3 == \"مرحبا بالع\".toSlice\n\nCreates a new string by removing the longest suffix from s in which pat matches\n(potentially repeatedly).This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".dropEndWhile Char.isLower == \"red green \".toSlice* \"red green blue\".dropEndWhile 'e' == \"red green blu\".toSlice* \"red green blue\".dropEndWhile (fun (_ : Char) => true) == \"\".toSlice\n\nIf pat matches a prefix of s, returns the remainder. Returns none otherwise.Use String.dropPrefix to return the slice\nunchanged when pat does not match a prefix.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".dropPrefix? \"red \" == some \"green blue\".toSlice* \"red green blue\".dropPrefix? \"reed \" == none* \"red green blue\".dropPrefix? 'r' == some \"ed green blue\".toSlice* \"red green blue\".dropPrefix? Char.isLower == some \"ed green blue\".toSlice\n\nIf pat matches a prefix of s, returns the remainder. Returns s unmodified\notherwise.Use String.dropPrefix? to return none when pat does not match a prefix.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".dropPrefix \"red \" == \"green blue\".toSlice* \"red green blue\".dropPrefix \"reed \" == \"red green blue\".toSlice* \"red green blue\".dropPrefix 'r' == \"ed green blue\".toSlice* \"red green blue\".dropPrefix Char.isLower == \"ed green blue\".toSlice\n\nIf pat matches a suffix of s, returns the remainder. Returns none otherwise.Use String.dropSuffix to return the slice\nunchanged when pat does not match a prefix.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".dropSuffix? \" blue\" == some \"red green\".toSlice* \"red green blue\".dropSuffix? \"bluu \" == none* \"red green blue\".dropSuffix? 'e' == some \"red green blu\".toSlice* \"red green blue\".dropSuffix? Char.isLower == some \"red green blu\".toSlice\n\nIf pat matches a suffix of s, returns the remainder. Returns s unmodified\notherwise.Use String.dropSuffix? to return none when pat does not match a prefix.This is a cheap operation because it does not allocate a new string to hold the result.\nTo convert the result into a string, use String.Slice.copy.This function is generic over all currently supported patterns.Examples:* \"red green blue\".dropSuffix \" blue\" == \"red green\".toSlice* \"red green blue\".dropSuffix \"bluu \" == \"red green blue\".toSlice* \"red green blue\".dropSuffix 'e' == \"red green blu\".toSlice* \"red green blue\".dropSuffix Char.isLower == \"red green blu\".toSlice\n\nRemoves leading and trailing whitespace from a string.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trimAscii == \"abc\".toSlice* \"   abc\".trimAscii == \"abc\".toSlice* \"abc \\t  \".trimAscii == \"abc\".toSlice* \"  abc   \".trimAscii == \"abc\".toSlice* \"abc\\ndef\\n\".trimAscii == \"abc\\ndef\".toSlice\n\nRemoves leading whitespace from a string by returning a slice whose start position is the first\nnon-whitespace character, or the end position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trimAsciiStart == \"abc\".toSlice* \"   abc\".trimAsciiStart == \"abc\".toSlice* \"abc \\t  \".trimAsciiStart == \"abc \\t  \".toSlice* \"  abc   \".trimAsciiStart == \"abc   \".toSlice* \"abc\\ndef\\n\".trimAsciiStart == \"abc\\ndef\\n\".toSlice\n\nRemoves trailing whitespace from a string by returning a slice whose end position is the last\nnon-whitespace character, or the start position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trimAsciiEnd == \"abc\".toSlice* \"   abc\".trimAsciiEnd == \"   abc\".toSlice* \"abc \\t  \".trimAsciiEnd == \"abc\".toSlice* \"  abc   \".trimAsciiEnd == \"  abc\".toSlice* \"abc\\ndef\\n\".trimAsciiEnd == \"abc\\ndef\".toSlice\n\nConsistently de-indents the lines in a string, removing the same amount of leading whitespace from\neach line such that the least-indented line has no leading whitespace.The number of leading whitespace characters to remove from each line is determined by counting the\nnumber of leading space (' ') and tab ('\\t') characters on lines after the first line that also\ncontain non-whitespace characters. No distinction is made between tab and space characters; both\ncount equally.The least number of leading whitespace characters found is then removed from the beginning of each\nline. The first line's leading whitespace is not counted when determining how far to de-indent the\nstring, but leading whitespace is removed from it.Examples:* \"Here:\\n  fun x =>\\n    x + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n  x + 1\"* \"Here:\\n\\t\\tfun x =>\\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n \\tx + 1\"* \"Here:\\n\\t\\tfun x =>\\n \\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n\\n \\tx + 1\"\n\nReturns the first character in s. If s = \"\", returns (default : Char).Examples:* \"abc\".front = 'a'* \"\".front = (default : Char)\n\nReturns the last character in s. If s = \"\", returns (default : Char).Examples:* \"abc\".back = 'c'* \"\".back = (default : Char)\n\nFinds the position of the first match of the pattern pattern in a slice s. If there\nis no match s.endPos is returned.This function is generic over all currently supported patterns.Examples:* (\"coffee tea water\".find Char.isWhitespace).get! == ' '* \"tea\".find (fun (c : Char) => c == 'X') == \"tea\".endPos* (\"coffee tea water\".find \"tea\").get! == 't'\n\nFinds the position of the first match of the pattern pattern in a string, starting\nfrom the end of the slice and traversing towards the start. If there is no match none is\nreturned.This function is generic over all currently supported patterns except\nString/String.Slice.Examples:* (\"coffee tea water\".toSlice.revFind? Char.isWhitespace).map (·.get!) == some ' '* \"tea\".toSlice.revFind? (fun (c : Char) => c == 'X') == none\n\nChecks whether a string has a match of the pattern pat anywhere.This function is generic over all currently supported patterns.Examples:* \"coffee tea water\".contains Char.isWhitespace = true* \"tea\".contains (fun (c : Char) => c == 'X') = false* \"coffee tea water\".contains \"tea\" = true\n\nConstructs a new string obtained by replacing all occurrences of pattern with\nreplacement in s.This function is generic over all currently supported patterns. The replacement may be a\nString or a String.Slice.Examples:* \"red green blue\".replace 'e' \"\" = \"rd grn blu\"* \"red green blue\".replace (fun c => c == 'u' || c == 'e') \"\" = \"rd grn bl\"* \"red green blue\".replace \"e\" \"\" = \"rd grn blu\"* \"red green blue\".replace \"ee\" \"E\" = \"red grEn blue\"* \"red green blue\".replace \"e\" \"E\" = \"rEd grEEn bluE\"* \"aaaaa\".replace \"aa\" \"b\" = \"bba\"* \"abc\".replace \"\" \"k\" = \"kakbkck\"\n\nFinds the position of the first match of the pattern pattern in a slice s. If there\nis no match s.endPos is returned.This function is generic over all currently supported patterns.Examples:* (\"coffee tea water\".find Char.isWhitespace).get! == ' '* \"tea\".find (fun (c : Char) => c == 'X') == \"tea\".endPos* (\"coffee tea water\".find \"tea\").get! == 't'\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"20.8.4.6. Lookups and Modifications","id":"/Basic-Types/Strings/#string-api-lookup"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind":{"contents":"\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Grind","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind"}});