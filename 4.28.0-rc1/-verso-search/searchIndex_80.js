window.docContents[80].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Size":{"contents":"Gets the number of elements stored in an array.This is a cached value, so it is O(1) to access. The space allocated for an array, referred to as\nits capacity, is at least as large as its size, but may be larger. The capacity of an array is an\ninternal detail that's not observable by Lean code.\n\nReturns the size of the array as a platform-native unsigned integer.This is a low-level version of Array.size that directly queries the runtime system's\nrepresentation of arrays. While this is not provable, Array.usize always returns the exact size of\nthe array since the implementation only supports arrays of size less than USize.size.\n\nChecks whether an array is empty.An array is empty if its size is 0.Examples:* (#[] : Array String).isEmpty = true* #[1, 2].isEmpty = false* #[()].isEmpty = false\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"20.16.4.2. Size","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Size"},"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--Syntax":{"contents":"Lean does not have dedicated floating-point literals.\nInstead, floating-point literals are resolved via the appropriate instances of the OfScientific and Neg type classes.\n\nFloating-Point LiteralsThe term(-2.523 : Float)\nis syntactic sugar for(Neg.neg (OfScientific.ofScientific 22523 true 4) : Float)\nand the term(413.52 : Float32)\nis syntactic sugar for(OfScientific.ofScientific 41352 true 2 : Float32)\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers","header":"20.6.1. Syntax","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--Syntax"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key. There is also a Prop-valued version\nof this: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for comparisons, while for hash maps, both use ==.\n\nRetrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof\nof a ∈ m.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, panicking if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning none if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Dependent Hash Maps","header":"20.19.5.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Queries"},"/Basic-Types/Optional-Values/#option":{"contents":"Option α is the type of values which are either some v for some v﻿:﻿α, or none.\nIn functional programming, this type is used similarly to nullable types: none represents the absence of a value.\nAdditionally, partial functions from α to β can be represented by the type α → Option β, where none results when the function is undefined for some input.\nComputationally, these partial functions represent the possibility of failure or errors, and they correspond to a program that can terminate early but not throw an informative exception.Option can also be thought of as being similar to a list that contains at most one element.\nFrom this perspective, iterating over Option consists of carrying out an operation only when a value is present.\nThe Option API makes frequent use of this perspective.Options as NullabilityThe function Std.HashMap.get? looks up a specified key a : α inside a HashMap α β:Std.HashMap.get?.{u, v} {α : Type u} {β : Type v}\n  [BEq α] [Hashable α]\n  (m : HashMap α β) (a : α) :\n  Option β\nBecause there is no way to know in advance whether the key is actually in the map, the return type is Option β, where none means the key was not in the map, and some b means that the key was found and b is the value retrieved.The xs[i] syntax, which is used to index into collections when there is an available proof that i is a valid index into xs, has a variant xs[i]? that returns an optional value depending on whether the given index is valid.\nIf m﻿:﻿HashMap α β and a﻿:﻿α, then m[a]? is equivalent to HashMap.get? m a.Options as Safe NullabilityIn many programming languages, it is important to remember to check for the null value.\nWhen using Option, the type system requires these checks in the right places: Option α and α are not the same type, and converting from one to the other requires handling the case of none.\nThis can be done via helpers such as Option.getD, or with pattern matching.def postalCodes : Std.HashMap Nat String :=\n  Std.HashMap.emptyWithCapacity 1 |>.insert 12345 \"Schenectady\"\n#eval postalCodes[12346]?.getD \"not found\"\n\"not found\"\n#eval\n  match postalCodes[12346]? with\n  | none => \"not found\"\n  | some city => city\n\"not found\"\n#eval\n  if let some city := postalCodes[12345]? then\n    city\n  else\n    \"not found\"\n\"Schenectady\"\n\n\nOptional values, which are either some around a value from the underlying type or none.Option can represent nullable types or computations that might fail. In the codomain of a function\ntype, it can also represent partiality.No value.Some value of type α.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.12. Optional Values","id":"/Basic-Types/Optional-Values/#option"},"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Ordering":{"contents":"Lexicographical order for products.Two pairs are lexicographically ordered if their first elements are ordered or if their first\nelements are equal and their second elements are ordered.\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples\u0009Ordered Pairs\u0009API Reference","header":"20.13.1.1.3. Ordering","id":"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Ordering"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-lemmas":{"contents":"exact e closes the main goal if its target type matches that of e.\n\napply e tries to match the current goal against the conclusion of e's type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.The apply tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n\nrefine e behaves like exact e, except that named (?x) or unnamed (?_)\nholes in e that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n\nrefine' e behaves like refine e, except that unsolved placeholders (_)\nand implicit parameters are also converted into new goals.\n\nsolve_by_elim calls apply on the main goal to find an assumption whose head matches\nand then repeatedly calls apply on the generated subgoals until no subgoals remain,\nperforming at most maxDepth (defaults to 6) recursive steps.solve_by_elim discharges the current goal or fails.solve_by_elim performs backtracking if subgoals can not be solved.By default, the assumptions passed to apply are the local context, rfl, trivial,\ncongrFun and congrArg.The assumptions can be modified with similar syntax as for simp:* solve_by_elim [h₁, h₂, ..., hᵣ] also applies the given expressions.* solve_by_elim only [h₁, h₂, ..., hᵣ] does not include the local context,\nrfl, trivial, congrFun, or congrArg unless they are explicitly included.* solve_by_elim [-h₁, ... -hₙ] removes the given local hypotheses.* solve_by_elim using [a₁, ...] uses all lemmas which have been labelled\nwith the attributes aᵢ (these attributes must be created using register_label_attr).solve_by_elim* tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)Optional arguments passed via a configuration argument as solve_by_elim (config := { ... })* maxDepth: number of attempts at discharging generated subgoals* symm: adds all hypotheses derived by symm (defaults to true).* exfalso: allow calling exfalso and trying again if solve_by_elim fails\n(defaults to true).* transparency: change the transparency mode when calling apply. Defaults to .default,\nbut it is often useful to change to .reducible,\nso semireducible definitions will not be unfolded when trying to apply a lemma.See also the doc-comment for Lean.Meta.Tactic.Backtrack.BacktrackConfig for the options\nproc, suspend, and discharge which allow further customization of solve_by_elim.\nBoth apply_assumption and apply_rules are implemented via these hooks.\n\napply_rules [l₁, l₂, ...] tries to solve the main goal by iteratively\napplying the list of lemmas [l₁, l₂, ...] or by applying a local hypothesis.\nIf apply generates new goals, apply_rules iteratively tries to solve those goals.\nYou can use apply_rules [-h] to omit a local hypothesis.apply_rules will also use rfl, trivial, congrFun and congrArg.\nThese can be disabled, as can local hypotheses, by using apply_rules only [...].You can use apply_rules using [a₁, ...] to use all lemmas which have been labelled\nwith the attributes aᵢ (these attributes must be created using register_label_attr).You can pass a further configuration via the syntax apply_rules (config := {...}).\nThe options supported are the same as for solve_by_elim (and include all the options for apply).apply_rules will try calling symm on hypotheses and exfalso on the goal as needed.\nThis can be disabled with apply_rules (config := {symm := false, exfalso := false}).You can bound the iteration depth using the syntax apply_rules (config := {maxDepth := n}).Unlike solve_by_elim, apply_rules does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n\nas_aux_lemma => tac does the same as tac, except that it wraps the resulting expression\ninto an auxiliary lemma. In some cases, this significantly reduces the size of expressions\nbecause the proof term is not duplicated.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"14.5.6. Lemmas","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-lemmas"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Language":{"contents":"* #10763 improves match compilation: Branch on variables in the order\nsuggested by the first remaining alternative, and do not branch when the\nfirst remaining alternative does not require it. This fixes\nhttps://github.com/leanprover/lean4/issues/10749. With set_option backwards.match.rowMajor false the old behavior can be turned on.* #10823 lets the match compilation procedure use sparse case analysis\nwhen the patterns only match on some but not all constructors of an\ninductive type. This way, less code is produce. Before, code handling\neach of the other cases was then optimized and commoned-up by later\ncompilation pipeline, but that is wasteful to do.* #10826 fixes the location of the “deprecated constant” and similar\nerror messages on field notation (e.f, (e).f, e |>. f). Fixes\n#10821.* #10851 lets match compilation use exfalso as soon as no alternatives\nare left. This way, the compiler does not have to look at subsequent\ncase splits.* #10865 makes the spec Std.Do.Spec.forIn'_list and friends more\nuniverse polymorphic.* #10872 improves the performance of mvcgen by an optimized\nimplementation for try (mpure_intro; trivial). This tactic sequence is\nused to eagerly discharge VCs and in the process instantiates schematic\nvariables.* #10926 topologically sorts abstracted vars in\nMeta.Closure.mkValueTypeClosure if MVars are being abstracted.\nFixes #10705* #10931 strips the Expr.mdata that WF.Fix uses to associate goal\nwith recursive calls from the goal presented to the tactics.\nFixes #10895.* #10944 runs enableRealizationsForConst on sizeOf declarations. Fixes\n#10573.* #10980 tries to preserve names of pattern variables in match\nalternatives in decreasing_by, by telescoping into the concrete\nalternative rather than the type of the matcher's alt. Fixes #10976.* #11011 extracts some refactorings from #10763, including dropping dead\ncode and not failing in inaccessibleAsCtor, which leadas to (slightly)\nbetter error messages, and also on the grounds that the failing\nalternative may actually be unreachable.* #11024 lets Bool have .ctorIdx like any other inductive.* #11068 removes the verifyEnum functions from the bv_decide frontend.\nThese functions looked at the implementation of matchers to see if they\nreally do the matching that they claim to do. This breaks that\nabstraction barrier, and should not be necessary, as only functions with\na MatcherInfo env entry are considered here, which should all play\nnicely.* #11072 adds “sparse casesOn” constructions. They are similar to\n.casesOn, but have arms only for some constructors and a catch-all\n(providing t.ctorIdx ≠ 42 assumptions). The compiler has native\nsupport for these constructors and now (because of the similarity) also\nthe per-constructor elimination principles.* #11094 makes workspaceSymbol benchmarks modules, so that they are\nless sensitive to additions of private symbols in the standard library.* #11095 makes use of hasIndepIndices. That function was unused since\ncommit 54f6517ca36b237b40e02aac62ea36dbd4179758, but it seems it should\nbe used.* #11107 tests the missing cases error.* #11122 fixes a problem for structures with diamond inheritance: rather\nthan copying docstrings (which are not available unless .server.olean\nis loaded), we link to them. Adds tests.* #11125 adds a filter for premise selectors to ensure deprecated\ntheorems are not returned.* #11132 adds support for grind +suggestions and simp_all? +suggestions in try?. It outputs grind only [X, Y, Z] or simp_all only [X, Y, Z] suggestions (rather than just +suggestions).* #11146 fixes a bug in #11125. Added a test this time ...* #11150 adds a new, inactive and unused doElem_elab attribute that\nwill allow users to register custom elaborators for doElems in the\nform of the new type DoElab. The old do elaborator is active by\ndefault but can be switched off by disabling the new option\nbackward.do.legacy.* #11161 adds getEntry/getEntry?/getEntry!/getEntryD operation on\nDTreeMap.* #11184 modifies the error message that is returned when more than one\nsynthetic metavariable can't be resolved.* #11190 avoids running into an “unknown free variable” when printing the\n“Failed to compile pattern matching” error. Fixes #11186.* #11191 makes sure that inside a realizeConst the maxHeartbeat\noption is effective.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0 (2025-12-13)","header":"Language","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Language"}});