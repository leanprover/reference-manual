window.docContents[110].resolve({"/Basic-Types/Fixed-Precision-Integers/#fixed-int-comparisons":{"contents":"The operators in this section are rarely invoked by name.\nTypically, comparisons operations on fixed-width integers should use the decidability of the corresponding relations, which consist of the equality type Eq and those implemented in instances of LE and LT.\n\n\n\n\n\nNon-strict inequality of word-sized unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of word-sized signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 8-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 8-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the ≤ operator.\n\nNon-strict inequality of 16-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 16-bit signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 32-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 32-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the ≤ operator.\n\nNon-strict inequality of 64-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the ≤ operator.\n\nNon-strict inequality of 64-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the ≤ operator.\n\nStrict inequality of word-sized unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of word-sized signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the < operator.\n\nStrict inequality of 8-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 8-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nStrict inequality of 16-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 16-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nStrict inequality of 32-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 32-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nStrict inequality of 64-bit unsigned integers, defined as inequality of the corresponding\nnatural numbers. Usually accessed via the < operator.\n\nStrict inequality of 64-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the < operator.\n\nDecides whether two word-sized unsigned integers are equal. Usually accessed via the\nDecidableEq USize instance.This function is overridden at runtime with an efficient implementation.Examples:* USize.decEq 123 123 = .isTrue rfl* (if (6 : USize) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : USize) = 7 by decide\n\nDecides whether two word-sized signed integers are equal. Usually accessed via the\nDecidableEq ISize instance.This function is overridden at runtime with an efficient implementation.Examples:* ISize.decEq 123 123 = .isTrue rfl* (if ((-7) : ISize) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : ISize) = 7 by decide\n\nDecides whether two 8-bit unsigned integers are equal. Usually accessed via the DecidableEq UInt8\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* UInt8.decEq 123 123 = .isTrue rfl* (if (6 : UInt8) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt8) = 7 by decide\n\nDecides whether two 8-bit signed integers are equal. Usually accessed via the DecidableEq Int8\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int8.decEq 123 123 = .isTrue rfl* (if ((-7) : Int8) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int8) = 7 by decide\n\nDecides whether two 16-bit unsigned integers are equal. Usually accessed via the\nDecidableEq UInt16 instance.This function is overridden at runtime with an efficient implementation.Examples:* UInt16.decEq 123 123 = .isTrue rfl* (if (6 : UInt16) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt16) = 7 by decide\n\nDecides whether two 16-bit signed integers are equal. Usually accessed via the DecidableEq Int16\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int16.decEq 123 123 = .isTrue rfl* (if ((-7) : Int16) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int16) = 7 by decide\n\nDecides whether two 32-bit unsigned integers are equal. Usually accessed via the\nDecidableEq UInt32 instance.This function is overridden at runtime with an efficient implementation.Examples:* UInt32.decEq 123 123 = .isTrue rfl* (if (6 : UInt32) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt32) = 7 by decide\n\nDecides whether two 32-bit signed integers are equal. Usually accessed via the DecidableEq Int32\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int32.decEq 123 123 = .isTrue rfl* (if ((-7) : Int32) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int32) = 7 by decide\n\nDecides whether two 64-bit unsigned integers are equal. Usually accessed via the\nDecidableEq UInt64 instance.This function is overridden at runtime with an efficient implementation.Examples:* UInt64.decEq 123 123 = .isTrue rfl* (if (6 : UInt64) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : UInt64) = 7 by decide\n\nDecides whether two 64-bit signed integers are equal. Usually accessed via the DecidableEq Int64\ninstance.This function is overridden at runtime with an efficient implementation.Examples:* Int64.decEq 123 123 = .isTrue rfl* (if ((-7) : Int64) = 7 then \"yes\" else \"no\") = \"no\"* show (7 : Int64) = 7 by decide\n\nDecides whether one word-sized unsigned integer is less than or equal to another. Usually accessed\nvia the DecidableLE USize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : USize) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : USize) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : USize) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : USize) ≤ 7 by decide\n\nDecides whether one word-sized signed integer is less than or equal to another. Usually accessed via\nthe DecidableLE ISize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : ISize) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : ISize) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : ISize) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : ISize) ≤ 7 by decide\n\nDecides whether one 8-bit unsigned integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt8) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt8) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt8) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt8) ≤ 7 by decide\n\nDecides whether one 8-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int8) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int8) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int8) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int8) ≤ 7 by decide\n\nDecides whether one 16-bit unsigned integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt16) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt16) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt16) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt16) ≤ 7 by decide\n\nDecides whether one 16-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int16) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int16) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int16) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int16) ≤ 7 by decide\n\nDecides whether one 32-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt32) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt32) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt32) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt32) ≤ 7 by decide\n\nDecides whether one 32-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int32) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int32) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int32) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int32) ≤ 7 by decide\n\nDecides whether one 64-bit unsigned integer is less than or equal to another. Usually accessed via the\nDecidableLE UInt64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (15 : UInt64) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : UInt64) ≤ 5 then \"yes\" else \"no\") = \"no\"* (if (5 : UInt64) ≤ 15 then \"yes\" else \"no\") = \"yes\"* show (7 : UInt64) ≤ 7 by decide\n\nDecides whether one 8-bit signed integer is less than or equal to another. Usually accessed via the\nDecidableLE Int64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int64) ≤ 7 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int64) ≤ 15 then \"yes\" else \"no\") = \"yes\"* (if (15 : Int64) ≤ 5 then \"yes\" else \"no\") = \"no\"* show (7 : Int64) ≤ 7 by decide\n\nDecides whether one word-sized unsigned integer is strictly less than another. Usually accessed via\nthe DecidableLT USize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : USize) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : USize) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : USize) < 7) by decide\n\nDecides whether one word-sized signed integer is strictly less than another. Usually accessed via the\nDecidableLT ISize instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : ISize) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : ISize) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : ISize) < 7) by decide\n\nDecides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt8) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt8) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt8) < 7) by decide\n\nDecides whether one 8-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int8 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int8) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int8) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int8) < 7) by decide\n\nDecides whether one 16-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt16) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt16) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt16) < 7) by decide\n\nDecides whether one 16-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int16 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int16) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int16) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int16) < 7) by decide\n\nDecides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt32) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt32) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt32) < 7) by decide\n\nDecides whether one 32-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int32 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int32) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int32) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int32) < 7) by decide\n\nDecides whether one 64-bit unsigned integer is strictly less than another. Usually accessed via the\nDecidableLT UInt64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if (6 : UInt64) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : UInt64) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : UInt64) < 7) by decide\n\nDecides whether one 8-bit signed integer is strictly less than another. Usually accessed via the\nDecidableLT Int64 instance.This function is overridden at runtime with an efficient implementation.Examples:* (if ((-7) : Int64) < 7 then \"yes\" else \"no\") = \"yes\"* (if (5 : Int64) < 5 then \"yes\" else \"no\") = \"no\"* show ¬((7 : Int64) < 7) by decide\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"20.4.4.4. Comparisons","id":"/Basic-Types/Fixed-Precision-Integers/#fixed-int-comparisons"},"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Compiler":{"contents":"* #11479 enables the specializer to also recursively specialize in some\n  non trivial higher order situations.* #11729 internalizes all arguments of Quot.lift during LCNF conversion,\n  preventing panics in certain\n  non trivial programs that use quotients.* #11874 improves the performance of getLine by coalescing the locking\n  of the underlying FILE*.* #11916 adds a symbol to the runtime for marking Array\n  non-linearities. This should allow users to\n  spot them more easily in profiles or hunt them down using a debugger.* #11983 fixes the floatLetIn pass to not move variables in case it\n  could break linearity (owned variables being passed with RC 1). This\n  mostly improves the situation in the parser which previously had many\n  functions that were supposed to be linear in terms of ParserState but\n  the compiler made them non-linear. For an example of how this affected\n  parsers:def optionalFn (p : ParserFn) : ParserFn := fun c s =>\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let s      := p c s\n  let s      := if s.hasError && s.pos == iniPos then s.restore iniSz iniPos else s\n  s.mkNode nullKind iniSz\npreviously moved the let iniSz := ... declaration into the hasError\n  branch. However, this means that at the point of calling the inner\n  parser (p c s), the original state s needs to have RC>1 because it\n  is used later in the hasError branch, breaking linearity. This fix\n  prevents such moves, keeping iniSz before the p c s call.* #12003 splits up the SCC that the compiler manages into (potentially)\n  multiple ones after\n  performing lambda lifting. This aids both the closed term extractor and\n  the elimDeadBranches pass as\n  they are both negatively influenced when more declarations than required\n  are within one SCC.* #12008 ensures that the LCNF simplifier already constant folds decision\n  procedures (Decidable\n  operations) in the base phase.* #12010 fixe a superliniear behavior in the closed subterm extractor.* #12123 fixes an issue that may sporadically trigger ASAN to got into a\n  deadlock when running a subprocess through the IO.Process.spawn\n  framework.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.28.0 (2026-01-26)","header":"Compiler","id":"/releases/v4.28.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___28___0-_LPAR_2026-01-26_RPAR_--Compiler"}});