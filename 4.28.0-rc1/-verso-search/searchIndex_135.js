window.docContents[135].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Cosine":{"contents":"Computes the cosine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncos.\n\nComputes the cosine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncosf.\n\nComputes the hyperbolic cosine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncosh.\n\nComputes the hyperbolic cosine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncoshf.\n\nComputes the arc cosine (inverse cosine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacos.\n\nComputes the arc cosine (inverse cosine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacosf.\n\nComputes the hyperbolic arc cosine (inverse cosine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacosh.\n\nComputes the hyperbolic arc cosine (inverse cosine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacoshf.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Trigonometry","header":"20.6.2.9.2. Cosine","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Cosine"},"/The--mvcgen--tactic/Overview/#The-Lean-Language-Reference--The--mvcgen--tactic--Overview":{"contents":"The workflow of mvcgen consists of the following:\n\n1. Monadic programs are re-interpreted according to a predicate transformer semantics.\n   An instance of WP determines the monad's interpretation.\n   Each program is interpreted as a mapping from arbitrary postconditions to the weakest precondition that would ensure the postcondition.\n   This step is invisible to most users, but library authors who want to enable their monads to work with mvcgen need to understand it.2. Programs are composed from smaller programs.\n   Each statement in a do-block is associated with a predicate transformer, and there are general-purpose rules for combining these statements with sequencing and control-flow operators.\n   A statement with its pre- and postconditions is called a Hoare triple.\n   In a program, the postcondition of each statement should suffice to prove the precondition of the next one, and loops require a specified loop invariant, which is a statement that must be true at the beginning of the loop and at the end of each iteration.\n   Designated specification lemmas associate functions with Hoare triples that specify them.3. Applying the weakest-precondition semantics of a monadic program to a desired proof goal results in the precondition that must hold in order to prove the goal.\n   Any missing steps such as loop invariants or proofs that a statement's precondition implies its postcondition become new subgoals.\n   These missing steps are called the verification conditions.\n   The mvcgen tactic performs this transformation, replacing the goal with its verification conditions.\n   During this transformation, mvcgen uses specification lemmas to discharge proofs about individual statements.4. After supplying loop invariants, many verification conditions can in practice be discharged automatically.\n   Those that cannot can be proven using either a special proof mode or ordinary Lean tactics, depending on whether they are expressed in the logic of program assertions or as ordinary propositions.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic","header":"17.1. Overview","id":"/The--mvcgen--tactic/Overview/#The-Lean-Language-Reference--The--mvcgen--tactic--Overview"},"/The-Simplifier/Rewrite-Rules/#simp-rewrites":{"contents":"The simplifier has three kinds of rewrite rules:\n\n Declarations to unfold\n\nThe simplifier will only unfold reducible definitions by default.\n  However, a rewrite rule can be added for any semireducible or irreducible definition that causes the simplifier to unfold it as well.\n  When the simplifier is running in definitional mode (dsimp and its variants), definition unfolding only replaces the defined name with its value; otherwise, it also uses the equational lemmas produced by the equation compiler.\n\n Equational lemmas\n\nThe simplifier can treat equality proofs as rewrite rules, in which case the left side of the equality will be replaced with the right. These equational lemmas may have any number of parameters. The simplifier instantiates parameters to make the left side of the equality match the goal, and it performs a proof search to instantiate any additional parameters.\n\n Simplification procedures\n\nThe simplifier supports simplification procedures, known as simprocs, that use Lean metaprogramming to perform rewrites that can't be efficiently specified using equations. Lean includes simprocs for the most important operations on built-in types.\n\n\n\n\n\nDue to propositional extensionality, equational lemmas can rewrite propositions to simpler, logically equivalent propositions.\nWhen the simplifier rewrites a proof goal to True, it automatically closes it.\nAs a special case of equational lemmas, propositions other than equality can be tagged as rewrite rules\nThey are preprocessed into rules that rewrite the proposition to True.\n\nRewriting PropositionsWhen asked to simplify an equality of pairs:α β : Type\nw y : α\nx z : β\n⊢ (w, x) = (y, z)\nsimp yields a conjunction of equalities:α β : Type\nw y : α\nx z : β\n⊢ w = y ∧ x = z\nThe default simp set contains Prod.mk.injEq, which shows the equivalence of the two statements:Prod.mk.injEq.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) :\n  ∀ (fst_1 : α) (snd_1 : β),\n    ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 ∧ snd = snd_1)\n\n\nIn addition to rewrite rules, simp has a number of built-in reduction rules, controlled by the config parameter.\nEven when the simp set is empty, simp can replace let-bound variables with their values, reduce match expressions whose discriminants are constructor applications, reduce structure projections applied to constructors, or apply lambdas to their arguments.\n\n","context":"Lean Reference\u0009The Simplifier","header":"15.2. Rewrite Rules","id":"/The-Simplifier/Rewrite-Rules/#simp-rewrites"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Documentation":{"contents":"* #6886 adds recommended spellings for many notations defined in Lean\ncore, using the recommended_spelling command from #6869.* #6950 adds a style guide and a naming convention for the standard\nlibrary.* #6962 improves the doc-string for List.toArray.* #6998 modifies the Prop docstring to point out that every\nproposition is propositionally equal to either True or False. This\nwill help point users toward seeing that Prop is like Bool.* #7026 clarifies the styling of do blocks, and enhances the naming\nconventions with information about the ext and mono name components\nas well as advice about primed names and naming of simp sets.* #7111 extends the standard library style guide with guidance on\nuniverse variables, notations and Unicode usage, and structure\ndefinitions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Documentation","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Documentation"}});