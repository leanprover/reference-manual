window.docContents[243].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--Run-Time-Characteristics":{"contents":"Because Fin n is a structure in which only a single field is not a proof, it is a trivial wrapper.\nThis means that it is represented identically to the underlying natural number in compiled code.\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers","header":"20.3.1. Run-Time Characteristics","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--Run-Time-Characteristics"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Modification":{"contents":"Inserts the given element into the set. If the tree set already contains an element that is\nequal (with regard to cmp) to the given element, then the tree set is returned unchanged.Note: this non-replacement behavior is true for TreeSet and TreeSet.Raw.\nThe insert function on TreeMap, DTreeMap, TreeMap.Raw and DTreeMap.Raw behaves\ndifferently: it will overwrite an existing mapping.\n\nInserts multiple elements into the tree set by iterating over the given collection and calling\ninsert. If the same element (with respect to cmp) appears multiple times, the first occurrence\ntakes precedence.Note: this precedence behavior is true for TreeSet and TreeSet.Raw. The insertMany function on\nTreeMap, DTreeMap, TreeMap.Raw and DTreeMap.Raw behaves differently: it will prefer the last\nappearance.\n\nChecks whether an element is present in a set and inserts the element if it was not found.\nIf the tree set already contains an element that is equal (with regard to cmp to the given\nelement, then the tree set is returned unchanged.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nRemoves the given key if it exists.\n\nErases multiple items from the tree set by iterating over the given collection and calling erase.\n\nRemoves all elements from the tree set for which the given function returns false.\n\nReturns a set that contains all mappings of t₁ and `t₂.This function ensures that t₁ is used linearly.\nHence, as long as t₁ is unshared, the performance characteristics follow the following imperative\ndescription: Iterate over all mappings in t₂, inserting them into t₁.Hence, the runtime of this method scales logarithmically in the size of t₁ and linearly in the\nsize of t₂ as long as t₁ is unshared.\n\nPartitions a tree set into two tree sets based on a predicate.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","header":"20.19.10.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Modification"},"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators":{"contents":"There are three primary ways to consume an iterator: Converting it to a sequential data structure\n\nThe functions Iter.toList, Iter.toArray, and their monadic equivalents IterM.toList and IterM.toArray, construct a lists or arrays that contain the values from the iterator, in order.\n  Only finite iterators can be converted to sequential data structures.\n\n for loops\n\nA for loop can consume an iterator, making each value available in its body.\n  This requires that the iterator have either an instance of IteratorLoop or IteratorLoopPartial for the loop's monad.\n\n Stepping through iterators\n\nIterators can provide their values one-by-one, with client code explicitly requesting each new value in turn.\n  When stepped through, iterators perform only enough computation to yield the requested value.\n\n\n\nConverting Iterators to ListsIn countdown, an iterator over a range is transformed into an iterator over strings using Iter.map.\nThis call to Iter.map does not result in any iteration over the range until Iter.toList is called, at which point each element of the range is produced and transformed into a string.def countdown : String :=\n  let steps : Iter String := (0...10).iter.map (s!\"{10 - ·}!\\n\")\n  String.join steps.toList\n\n#eval IO.println countdown\n10!\n9!\n8!\n7!\n6!\n5!\n4!\n3!\n2!\n1!\n\n\nConverting Infinite Iterators to ListsAttempting to construct a list of all the natural numbers from an iterator fails:def allNats : List Nat :=\n  let steps : Iter Nat := (0...*).iter\n  steps.toList\nThe resulting error message states that there is no Finite instance:failed to synthesize\n  Finite (Std.Rxi.Iterator Nat) Id\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nIf the failure to synthesize the instance is due to a missing proof, or if an infinite loop is desirable for an application, then the fact that consuming the iterator may not terminate can be hidden using Iter.allowNontermination:def allNats : List Nat :=\n  let steps : Iter Nat := (0...*).iter\n  steps.allowNontermination.toList\n\n\nConsuming Iterators in LoopsThis program creates an iterator of strings from a range, and then consumes the strings in a for loop:def countdown (n : Nat) : IO Unit := do\n  let steps : Iter String := (0...n).iter.map (s!\"{n - ·}!\")\n  for i in steps do\n    IO.println i\n  IO.println \"Blastoff!\"\n\n#eval countdown 5\n5!\n4!\n3!\n2!\n1!\nBlastoff!\n\n\nConsuming Iterators DirectlyThe function countdown calls the range iterator's step function directly, handling each of the three possible cases.def countdown (n : Nat) : IO Unit := do\n  let steps : Iter Nat := (0...n).iter\n  go steps\nwhere\n  go iter := do\n    match iter.step with\n    | .done _ => pure ()\n    | .skip iter' _ => go iter'\n    | .yield iter' i _ => do\n      IO.println s!\"{i}!\"\n      if i == 2 then\n        IO.println s!\"Almost there...\"\n      go iter'\n  termination_by iter.finitelyManySteps\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Iterators","header":"21.3. Consuming Iterators","id":"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators"},"/Iterators/Iterator-Definitions/#The-Lean-Language-Reference--Iterators--Iterator-Definitions--Accessing-Elements":{"contents":"Some iterators support efficient random access.\nFor example, an array iterator can skip any number of elements in constant time by incrementing the index that it maintains into the array.\n\nIteratorAccess α m provides efficient implementations for random access or iterators that support\nit. it.nextAtIdx? n either returns the step in which the n-th value of it is emitted\n(necessarily of the form .yield _ _) or .done if it terminates before emitting the n-th\nvalue.For monadic iterators, the monadic effects of this operation may differ from manually iterating\nto the n-th value because nextAtIdx? can take shortcuts. By the signature, the return value\nis guaranteed to plausible in the sense of IterM.IsPlausibleNthOutputStep.This class is experimental and users of the iterator API should not explicitly depend on it.\n\nReturns the step in which it yields its n-th element, or .done if it terminates earlier.\nIn contrast to step, this function will always return either .yield or .done but never a\n.skip step.For monadic iterators, the monadic effects of this operation may differ from manually iterating\nto the n-th value because nextAtIdx? can take shortcuts. By the signature, the return value\nis guaranteed to plausible in the sense of IterM.IsPlausibleNthOutputStep.This function is only available for iterators that explicitly support it by implementing\nthe IteratorAccess typeclass.\n\n","context":"Lean Reference\u0009Iterators\u0009Iterator Definitions","header":"21.2.3. Accessing Elements","id":"/Iterators/Iterator-Definitions/#The-Lean-Language-Reference--Iterators--Iterator-Definitions--Accessing-Elements"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-other":{"contents":"trivial tries different simple tactics (e.g., rfl, contradiction, ...)\nto close the current goal.\nYou can use the command macro_rules to extend the set of tactics used. Example:macro_rules | `(tactic| trivial) => `(tactic| simp)\n\n\nSimilar to first, but succeeds only if one the given tactics solves the current goal.\n\nand_intros applies And.intro until it does not make progress.\n\ninfer_instance is an abbreviation for exact inferInstance.\nIt synthesizes a value of any target type by typeclass inference.\n\nexpose_names renames all inaccessible variables with accessible names, making them available\nfor reference in generated tactics. However, this renaming introduces machine-generated names\nthat are not fully under user control. expose_names is primarily intended as a preamble for\nauto-generated end-game tactic scripts. It is also useful as an alternative to\nset_option tactic.hygienic false. If explicit control over renaming is needed in the\nmiddle of a tactic script, consider using structured tactic scripts with\nmatch .. with, induction .. with, or intro with explicit user-defined names,\nas well as tactics such as next, case, and rename_i.\n\nunhygienic tacs runs tacs with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. Warning: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use unhygienic if possible.example : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n\n\nThe run_tac doSeq tactic executes code in TacticM Unit.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.22. Other","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-other"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Library___-Dyadic-rationals":{"contents":"* #9993 defines the dyadic rationals, showing they are an ordered ring\nembedding into the rationals.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)\u0009Highlights","header":"Library: Dyadic rationals","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Library___-Dyadic-rationals"}});