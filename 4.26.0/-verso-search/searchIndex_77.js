window.docContents[77].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Sizes":{"contents":"Each fixed-width integer has a size, which is the number of distinct values that can be represented by the type.\nThis is not equivalent to C's sizeof operator, which instead determines how many bytes the type occupies.\n\nThe number of distinct values representable by USize, that is, 2^System.Platform.numBits.\n\nThe number of distinct values representable by ISize, that is, 2^System.Platform.numBits.\n\nThe number of distinct values representable by UInt8, that is, 2^8 = 256.\n\nThe number of distinct values representable by Int8, that is, 2^8 = 256.\n\nThe number of distinct values representable by UInt16, that is, 2^16 = 65536.\n\nThe number of distinct values representable by Int16, that is, 2^16 = 65536.\n\nThe number of distinct values representable by UInt32, that is, 2^32 = 4294967296.\n\nThe number of distinct values representable by Int32, that is, 2^32 = 4294967296.\n\nThe number of distinct values representable by UInt64, that is, 2^64 = 18446744073709551616.\n\nThe number of distinct values representable by Int64, that is, 2^64 = 18446744073709551616.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"20.4.4.1. Sizes","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Sizes"},"/Basic-Types/Maps-and-Sets/#TreeSet":{"contents":"Tree sets.A tree set stores elements of a certain type in a certain order. It depends on a comparator function\nthat defines an ordering on the keys and provides efficient order-dependent queries, such as\nretrieval of the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one of them\nbe contained in a single tree set at the same time.To avoid expensive copies, users should make sure that the tree set is used linearly.Internally, the tree sets are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.For use in proofs, the type Std.ExtTreeSet of extensional tree sets should be preferred. This\ntype comes with several extensionality lemmas and provides the same functions but requires a\nTransCmp instance to work with.These tree sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.TreeSet.Raw and\nStd.TreeSet.Raw.WF unbundle the invariant from the tree set. When in doubt, prefer\nTreeSet over TreeSet.Raw.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"20.19.10. Tree-Based Sets","id":"/Basic-Types/Maps-and-Sets/#TreeSet"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Extracting-Values":{"contents":"Extracts the value from an option that can be proven to be some.\n\nExtracts the value from an Option, panicking on none.\n\nGets an optional value, returning a given default on none.This function is @[macro_inline], so dflt will not be evaluated unless opt turns out to be\nnone.Examples:* (some \"hello\").getD \"goodbye\" = \"hello\"* none.getD \"goodbye\" = \"goodbye\"\n\nGets the value in an option, monadically computing a default value on none.This is the monadic analogue of Option.getD.\n\nLifts an optional value to any Alternative, sending none to failure.\n\nA case analysis function for Option.Given a value for none and a function to apply to the contents of some, Option.elim checks\nwhich constructor a given Option consists of, and uses the appropriate argument.Option.elim is an elimination principle for Option. In particular, it is a non-dependent version\nof Option.recOn. It can also be seen as a combination of Option.map and Option.getD.Examples:* (some \"hello\").elim 0 String.length = 5* none.elim 0 String.length = 0\n\nA monadic case analysis function for Option.Given a fallback computation for none and a monadic operation to apply to the contents of some,\nOption.elimM checks which constructor a given Option consists of, and uses the appropriate\nargument.Option.elimM can also be seen as a combination of Option.mapM and Option.getDM. It is a\nmonadic analogue of Option.elim.\n\nApplies a function to a two optional values if both are present. Otherwise, if one value is present,\nit is returned and the function is not used.The value is some (fn a b) if the inputs are some a and some b. Otherwise, the behavior is\nequivalent to Option.orElse: if only one input is some x, then the value is some x, and if\nboth are none, then the value is none.Examples:* Option.merge (· + ·) none (some 3) = some 3* Option.merge (· + ·) (some 2) (some 3) = some 5* Option.merge (· + ·) (some 2) none = some 2* Option.merge (· + ·) none none = none\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"20.12.2.1. Extracting Values","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Extracting-Values"},"/Iterators/Iterator-Combinators/#The-Lean-Language-Reference--Iterators--Iterator-Combinators--Pure-Combinators":{"contents":"Converts wraps the state of an iterator into an IterM object.\n\nConverts a pure iterator (Iter β) into a monadic iterator (IterM Id β) in the\nidentity monad Id.\n\nGiven an iterator it and a natural number n, it.take n is an iterator that outputs\nup to the first n of it's values in order and then terminates.Marble diagram:it          ---a----b---c--d-e--⊥\nit.take 3   ---a----b---c⊥\n\nit          ---a--⊥\nit.take 3   ---a--⊥\nTermination properties:* Finite instance: only if it is productive* Productive instance: only if it is productivePerformance:This combinator incurs an additional O(1) cost with each output of it.\n\nGiven an iterator it and a predicate P, it.takeWhile P is an iterator that outputs\nthe values emitted by it until one of those values is rejected by P.\nIf some emitted value is rejected by P, the value is dropped and the iterator terminates.Marble diagram:Assuming that the predicate P accepts a and b but rejects c:it               ---a----b---c--d-e--⊥\nit.takeWhile P   ---a----b---⊥\n\nit               ---a----⊥\nit.takeWhile P   ---a----⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveDepending on P, it is possible that it.takeWhile P is finite (or productive) although it is not.\nIn this case, the Finite (or Productive) instance needs to be proved manually.Performance:This combinator calls P on each output of it until the predicate evaluates to false. Then\nit terminates.\n\nThis combinator is only useful for advanced use cases.Given a finite iterator it, returns an iterator that behaves exactly like it but is of the same\ntype as it.take n.Marble diagram:it          ---a----b---c--d-e--⊥\nit.toTake   ---a----b---c--d-e--⊥\nTermination properties:* Finite instance: always* Productive instance: alwaysPerformance:This combinator incurs an additional O(1) cost with each output of it.\n\nGiven an iterator it and a natural number n, it.drop n is an iterator that forwards all of\nit's output values except for the first n.Marble diagram:it          ---a----b---c--d-e--⊥\nit.drop 3   ---------------d-e--⊥\n\nit          ---a--⊥\nit.drop 3   ------⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is productivePerformance:Currently, this combinator incurs an additional O(1) cost with each output of it, even when the iterator\ndoes not drop any elements anymore.\n\nGiven an iterator it and a predicate P, it.dropWhile P is an iterator that\nemits the values emitted by it starting from the first value that is rejected by P.\nThe elements before are dropped.In situations where P is monadic, use dropWhileM instead.Marble diagram:Assuming that the predicate P accepts a and b but rejects c:it               ---a----b---c--d-e--⊥\nit.dropWhile P   ------------c--d-e--⊥\n\nit               ---a----⊥\nit.dropWhile P   --------⊥\nTermination properties:* Finite instance: only if it is finite* Productive instance: only if it is finiteDepending on P, it is possible that it.dropWhileM P is productive although\nit is not. In this case, the Productive instance needs to be proved manually.Performance:This combinator calls P on each output of it until the predicate evaluates to false. After\nthat, the combinator incurs an additional O(1) cost for each value emitted by it.\n\nProduces an iterator that emits one value of it, then drops n - 1 elements, then emits another\nvalue, and so on. In other words, it emits every n-th value of it, starting with the first one.If n = 0, the iterator behaves like for n = 1: It emits all values of it.Marble diagram:it               ---1----2----3---4----5\nit.stepSize 2    ---1---------3--------5\nAvailability:This operation is currently only available for iterators implementing IteratorAccess,\nsuch as PRange.iter range iterators.Termination properties:* Finite instance: only if the base iterator it is finite* Productive instance: always\n\nIf it is an iterator, then it.map f is another iterator that applies a\nfunction f to all values emitted by it and emits the result.In situations where f is monadic, use mapM instead.Marble diagram:it         ---a --b --c --d -e ----⊥\nit.map     ---a'--b'--c'--d'-e'----⊥\n(given that f a = a', f b = b' etc.)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is productivePerformance:For each value emitted by the base iterator it, this combinator calls f.\n\nIf it is an iterator, then it.mapM f is another iterator that applies a monadic\nfunction f to all values emitted by it and emits the result.The base iterator it being monadic in m, f can return values in any monad n for which a\nMonadLiftT m n instance is available.If f is pure, then the simpler variant it.map can be used instead.Marble diagram (without monadic effects):it          ---a --b --c --d -e ----⊥\nit.mapM     ---a'--b'--c'--d'-e'----⊥\n(given that f a = pure a', f b = pure b' etc.)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveFor certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.mapM will be finite even if it isn't.If that does not help, the more general combinator it.mapWithPostcondition f makes it possible to\nmanually prove Finite and Productive instances depending on the concrete choice of f.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nNote: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants map and mapM are easier to use and\nsufficient for most use cases.If it is an iterator, then it.mapWithPostcondition f is another iterator that applies a monadic\nfunction f to all values emitted by it and emits the result.f is expected to return PostconditionT n _, where n is an arbitrary monad.\nThe PostconditionT transformer allows the caller to intrinsically prove properties about\nf's return value in the monad n, enabling termination proofs depending on the specific behavior\nof f.Marble diagram (without monadic effects):it                          ---a --b --c --d -e ----⊥\nit.mapWithPostcondition     ---a'--b'--c'--d'-e'----⊥\n(given that f a = pure a', f b = pure b' etc.)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is productiveFor certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.mapWithPostcondition will be finite even if it isn't.In such situations, the missing instances can be proved manually if the postcondition bundled in\nthe PostconditionT n monad is strong enough. In the given example, a suitable postcondition might\nbe fun _ => False.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nTransforms an iterator with values in β into one with values in ULift β.Most other combinators like map cannot switch between universe levels. This combinators\nmakes it possible to transition to a higher universe.Marble diagram:it            ---a    ----b    ---c    --d    ---⊥\nit.uLift n    ---.up a----.up b---.up c--.up d---⊥\nTermination properties:* Finite: only if the original iterator is finite* Productive: only if the original iterator is productive\n\nLet it be an iterator and f a function mapping it's outputs to iterators.\nThen it.flatMap f is an iterator that goes over it and for each output, it applies f and\niterates over the resulting iterator. it.flatMap f emits all values obtained from the inner\niterators -- first, all of the first inner iterator, then all of the second one, and so on.Marble diagram:it                 ---a      --b      c    --d -⊥\nf a                    a1-a2⊥\nf b                             b1-b2⊥\nf c                                    c1-c2⊥\nf d                                           ⊥\nit.flatMap         ----a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it and the inner iterators are finite* Productive instance: only if it is finite and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it or an internal iterator.For each value emitted by the outer iterator it, this combinator calls f.\n\nLet it be an iterator and f a monadic function mapping it's outputs to iterators.\nThen it.flatMapM f is an iterator that goes over it and for each output, it applies f and\niterates over the resulting iterator. it.flatMapM f emits all values obtained from the inner\niterators -- first, all of the first inner iterator, then all of the second one, and so on.Marble diagram (without monadic effects):it                 ---a      --b      c    --d -⊥\nf a                    a1-a2⊥\nf b                             b1-b2⊥\nf c                                    c1-c2⊥\nf d                                           ⊥\nit.flatMapM        ----a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it and the inner iterators are finite* Productive instance: only if it is finite and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it or an internal iterator.For each value emitted by the outer iterator it, this combinator calls f.\n\nLet it₁ and it₂ be iterators and f a function mapping it₁'s outputs to iterators\nof the same type as it₂. Then it₁.flatMapAfter f it₂ first goes over it₂ and then over\nit₁.flatMap f it₂, emitting all their values.The main purpose of this combinator is to represent the intermediate state of a flatMap iterator\nthat is currently iterating over one of the inner iterators.Marble diagram:it₁                            --b      c    --d -⊥\nit₂                      a1-a2⊥\nf b                               b1-b2⊥\nf c                                      c1-c2⊥\nf d                                             ⊥\nit.flatMapAfter  f it₂   a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it₁, it₂ and the inner iterators are finite* Productive instance: only if it₁ is finite and it₂ and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it₁, it₂ or an internal\niterator.For each value emitted by the outer iterator it₁, this combinator calls f.\n\nLet it₁ and it₂ be iterators and f a monadic function mapping it₁'s outputs to iterators\nof the same type as it₂. Then it₁.flatMapAfterM f it₂ first goes over it₂ and then over\nit₁.flatMap f it₂, emitting all their values.The main purpose of this combinator is to represent the intermediate state of a flatMap iterator\nthat is currently iterating over one of the inner iterators.Marble diagram (without monadic effects):it₁                            --b      c    --d -⊥\nit₂                      a1-a2⊥\nf b                               b1-b2⊥\nf c                                      c1-c2⊥\nf d                                             ⊥\nit.flatMapAfterM f it₂   a1-a2----b1-b2--c1-c2----⊥\nTermination properties:* Finite instance: only if it₁, it₂ and the inner iterators are finite* Productive instance: only if it₁ is finite and it₂ and the inner iterators are productiveFor certain functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided out of the box. For example, if the outer\niterator is productive and the inner\niterators are productive and provably never empty, then the resulting iterator is also productive.Performance:This combinator incurs an additional O(1) cost with each output of it₁, it₂ or an internal\niterator.For each value emitted by the outer iterator it₁, this combinator calls f.\n\nIf it is an iterator, then it.filter f is another iterator that applies a\npredicate f to all values emitted by it and emits them only if they are accepted by f.In situations where f is monadic, use filterM instead.Marble diagram (without monadic effects):it            ---a--b--c--d-e--⊥\nit.filter     ---a-----c-------⊥\n(given that f a = f c = true and f b = f d = d e = false)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be productive even though\nno Productive instance is provided. For example, if f always returns True, the resulting\niterator will be productive as long as it is. In such situations, the missing instance needs to\nbe proved manually.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned value.\n\nIf it is an iterator, then it.filterM f is another iterator that applies a monadic\npredicate f to all values emitted by it and emits them only if they are accepted by f.If f is pure, then the simpler variant it.filter can be used instead.Marble diagram (without monadic effects):it             ---a--b--c--d-e--⊥\nit.filterM     ---a-----c-------⊥\n(given that f a = f c = pure true and f b = f d = d e = pure false)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.filterWithPostcondition will be finite -- and productive -- even if it\nisn't.In such situations, the more general combinator it.filterWithPostcondition f makes it possible to\nmanually prove Finite and Productive instances depending on the concrete choice of f.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nNote: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants filter and filterM are easier to use and\nsufficient for most use cases.If it is an iterator, then it.filterWithPostcondition f is another iterator that applies a monadic\npredicate f to all values emitted by it and emits them only if they are accepted by f.f is expected to return PostconditionT n (ULift Bool), where n is an arbitrary monad.\nThe PostconditionT transformer allows the caller to intrinsically prove properties about\nf's return value in the monad n, enabling termination proofs depending on the specific behavior\nof f.Marble diagram (without monadic effects):it                             ---a--b--c--d-e--⊥\nit.filterWithPostcondition     ---a-----c-------⊥\n(given that f a = f c = pure true and f b = f d = d e = pure false)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f is an ExceptT monad and\nwill always fail, then it.filterWithPostcondition will be finite -- and productive -- even if it\nisn't.In such situations, the missing instances can be proved manually if the postcondition bundled in\nthe PostconditionT n monad is strong enough. In the given example, a suitable postcondition might\nbe fun _ => False.Performance:For each value emitted by the base iterator it, this combinator calls f.\n\nIf it is an iterator, then it.filterMap f is another iterator that applies a function f to all\nvalues emitted by it. f is expected to return an Option. If it returns none, then nothing is\nemitted; if it returns some x, then x is emitted.In situations where f is monadic, use filterMapM instead.Marble diagram:it               ---a --b--c --d-e--⊥\nit.filterMap     ---a'-----c'-------⊥\n(given that f a = some a', f c = c' and f b = f d = d e = none)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be productive even though\nno Productive instance is provided. For example, if f never returns none, then\nthis combinator will preserve productiveness. In such situations, the missing instance needs to\nbe proved manually.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned Option value.\n\nIf it is an iterator, then it.filterMapM f is another iterator that applies a monadic\nfunction f to all values emitted by it. f is expected to return an Option inside the monad.\nIf f returns none, then nothing is emitted; if it returns some x, then x is emitted.If f is pure, then the simpler variant it.filterMap can be used instead.Marble diagram (without monadic effects):it                ---a --b--c --d-e--⊥\nit.filterMapM     ---a'-----c'-------⊥\n(given that f a = pure (some a)', f c = pure (some c') and f b = f d = d e = pure none)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finite`For certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f never returns none, then\nthis combinator will preserve productiveness. If f is an ExceptT monad and will always fail,\nthen it.filterMapM will be finite even if it isn't. In the first case, consider\nusing the map/mapM/mapWithPostcondition combinators instead, which provide more instances out\nof the box.If that does not help, the more general combinator it.filterMapWithPostcondition f makes it\npossible to manually prove Finite and Productive instances depending on the concrete choice of f.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned Option value.\n\nNote: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants filterMap and filterMapM are easier to use\nand sufficient for most use cases.If it is an iterator, then it.filterMapWithPostcondition f is another iterator that applies a monadic\nfunction f to all values emitted by it. f is expected to return an Option inside the monad.\nIf f returns none, then nothing is emitted; if it returns some x, then x is emitted.f is expected to return PostconditionT n (Option _), where n is an arbitrary monad.\nThe PostconditionT transformer allows the caller to intrinsically prove properties about\nf's return value in the monad n, enabling termination proofs depending on the specific behavior\nof f.Marble diagram (without monadic effects):it                                ---a --b--c --d-e--⊥\nit.filterMapWithPostcondition     ---a'-----c'-------⊥\n(given that f a = pure (some a'), f c = pure (some c') and f b = f d = d e = pure none)Termination properties:* Finite instance: only if it is finite* Productive instance: only if it is finiteFor certain mapping functions f, the resulting iterator will be finite (or productive) even though\nno Finite (or Productive) instance is provided. For example, if f never returns none, then\nthis combinator will preserve productiveness. If f is an ExceptT monad and will always fail,\nthen it.filterMapWithPostcondition will be finite even if it isn't. In the first case, consider\nusing the map/mapM/mapWithPostcondition combinators instead, which provide more instances out of\nthe box.In such situations, the missing instances can be proved manually if the postcondition bundled in\nthe PostconditionT n monad is strong enough. If f always returns some _, a suitable\npostcondition is fun x => x.isSome; if f always fails, a suitable postcondition might be\nfun _ => False.Performance:For each value emitted by the base iterator it, this combinator calls f and matches on the\nreturned Option value.\n\nGiven two iterators left and right, left.zip right is an iterator that yields pairs of\noutputs of left and right. When one of them terminates,\nthe zip iterator will also terminate.Marble diagram:left               --a        ---b        --c\nright                 --x         --y        --⊥\nleft.zip right     -----(a, x)------(b, y)-----⊥\nTermination properties:* Finite instance: only if either left or right is finite and the other is productive* Productive instance: only if left and right are productiveThere are situations where left.zip right is finite (or productive) but none of the instances\nabove applies. For example, if left immediately terminates but right always skips, then\nleft.zip.right is finite even though no Finite (or even Productive) instance is available.\nSuch instances need to be proved manually.Performance:This combinator incurs an additional O(1) cost with each step taken by left or right.Right now, the compiler does not unbox the internal state, leading to worse performance than\ntheoretically possible.\n\n“Attaches” individual proofs to an iterator of values that satisfy a predicate P, returning an\niterator with values in the corresponding subtype { x // P x }.Termination properties:* Finite instance: only if the base iterator is finite* Productive instance: only if the base iterator is productive\n\n","context":"Lean Reference\u0009Iterators\u0009Iterator Combinators","header":"21.4.1. Pure Combinators","id":"/Iterators/Iterator-Combinators/#The-Lean-Language-Reference--Iterators--Iterator-Combinators--Pure-Combinators"},"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-ToInt":{"contents":"The LIA solver can also process linear constraints that contain natural numbers.\nIt converts them into integer constraints using Int.ofNat.\n\nNatural Numbers as Linear Integer Arithmeticexample (x y z : Nat) :\n    x < y + z →\n    y + 1 < z →\n    z + x < 3 * z := by\n  grind\n\n\nThere is an extensible mechanism via the Lean.Grind.ToInt type class to tell the solver that a type embeds in the integers.\nUsing this, we can solve goals such as:\n\nexample (a b c : Fin 11) : a ≤ 2 → b ≤ 3 → c = a + b → c ≤ 5 := by\n  grind\n\nexample (a : Fin 2) : a ≠ 0 → a ≠ 1 → False := by\n  grind\n\nexample (a b c : UInt64) : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n\n\nToInt α I asserts that α can be embedded faithfully into an interval I in the integers.The embedding function.The embedding function is injective.The embedding function lands in the interval.\n\nAn interval in the integers (either finite, half-infinite, or infinite).The finite interval [lo, hi).The half-infinite interval [lo, ∞).The half-infinite interval (-∞, hi).The infinite interval (-∞, ∞).\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.6. Other Types","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-ToInt"}});