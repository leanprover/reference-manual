window.docContents[42].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic--Signed-Operations":{"contents":"Returns the absolute value of a signed bitvector.\n\nNegation of bitvectors. This can be interpreted as either signed or unsigned negation modulo 2^n.\nUsually accessed via the - prefix operator.SMT-LIB name: bvneg.\n\nSigned T-division (using the truncating rounding convention) for bitvectors. This function obeys the\nLean convention that division by zero returns zero.Examples:* (7#4).sdiv 2 = 3#4* (-9#4).sdiv 2 = -4#4* (5#4).sdiv -2 = -2#4* (-7#4).sdiv (-2) = 3#4\n\nSigned division for bitvectors using the SMT-LIB using the\nSMT-LIB convention,\nwhere division by zero returns BitVector.allOnes n.Specifically, x.smtSDiv 0 = if x >= 0 then -1 else 1SMT-LIB name: bvsdiv.\n\nRemainder for signed division rounded to negative infinity.SMT-LIB name: bvsmod.\n\nRemainder for signed division rounding to zero.SMT-LIB name: bvsrem.\n\nChecks whether addition of x and y results in signed overflow, treating x and y as 2's\ncomplement signed bitvectors.SMT-LIB name: bvsaddo.\n\nChecks whether the subtraction of x and y results in signed overflow, treating x and y as\n2's complement signed bitvectors.SMT-Lib name: bvssubo.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference\u0009Arithmetic","header":"20.5.5.8.2. Signed Operations","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic--Signed-Operations"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Boundaries":{"contents":"A UTF-8 byte position that points at the end of a string, just after the last character.* \"abc\".rawEndPos = ⟨3⟩* \"L∃∀N\".rawEndPos = ⟨8⟩\n\nReturns true if a specified byte position is greater than or equal to the position which points to\nthe end of a string. Otherwise, returns false.Examples:* (0 |> \"abc\".next |> \"abc\".next |> \"abc\".atEnd) = false* (0 |> \"abc\".next |> \"abc\".next |> \"abc\".next |> \"abc\".next |> \"abc\".atEnd) = true* (0 |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".atEnd) = false* (0 |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".atEnd) = true* \"abc\".atEnd ⟨4⟩ = true* \"L∃∀N\".atEnd ⟨7⟩ = false* \"L∃∀N\".atEnd ⟨8⟩ = true\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"20.8.4.5.2. Boundaries","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--Boundaries"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Utilities":{"contents":"The Current DirectoryA macro that expands to the path of package's directory\nduring the Lakefile's elaboration.\n\nConfiguration OptionsA macro that expands to the specified configuration option (or none,\nif the option has not been set) during the Lakefile's elaboration.Configuration arguments are set either via the Lake CLI (by the -K option)\nor via the with clause in a require statement.\n\nCompile-Time ConditionalsThe meta if command has two forms:meta if <c:term> then <a:command>\nmeta if <c:term> then <a:command> else <b:command>\nIt expands to the command a if the term c evaluates to true\n(at elaboration time). Otherwise, it expands to command b (if an else\nclause is provided).One can use this command to specify, for example, external library targets\nonly available on specific platforms:meta if System.Platform.isWindows then\nextern_lib winOnlyLib := ...\nelse meta if System.Platform.isOSX then\nextern_lib macOnlyLib := ...\nelse\nextern_lib linuxOnlyLib := ...\n\n\nCommand SequencesThe do command syntax groups multiple similarly indented commands together.\nThe group can then be passed to another command that usually only accepts a\nsingle command (e.g., meta if).\n\nCompile-Time Side EffectsExecutes a term of type IO α at elaboration-time\nand produces an expression corresponding to the result via ToExpr α.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"24.1.3.2.7. Utilities","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Utilities"},"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent--Examples":{"contents":"Insufficient type informationdef reverseDuplicate (xs : List α) :=\n  .reverse (xs ++ xs)\nInvalid dotted identifier notation: The expected type of `.reverse` could not be determined\ndef reverseDuplicate (xs : List α) : List α :=\n  .reverse (xs ++ xs)\nBecause the return type of reverseDuplicate is not specified, the expected type of .reverse\ncannot be determined. Lean will not use the type of the argument xs ++ xs to infer the omitted\nnamespace. Adding the return type List α allows Lean to infer the type of .reverse and thus the\nappropriate namespace (List) in which to resolve this identifier.Note that this means that changing the return type of reverseDuplicate changes how .reverse\nresolves: if the return type is  T, then Lean will (attempt to) resolve .reverse to a function\nT.reverse whose return type is T—even if T.reverse does not take an argument of type\nList α.\n\nDotted identifier where type universe expectedexample (n : Nat) :=\n  match n > 42 with\n  | .true  => n - 1\n  | .false => n + 1\nInvalid dotted identifier notation: Not supported on type universe\n  Prop\nexample (n : Nat) :=\n  match decide (n > 42) with\n  | .true  => n - 1\n  | .false => n + 1\nThe proposition n > 42 has type Prop, which, being a type universe, does not support\ndotted-identifier notation. As this example demonstrates, attempting to use this notation in such a\ncontext is almost always an error. The intent in this example was for .true and .false to be\nBooleans, not propositions; however, match expressions do not automatically perform this coercion\nfor decidable propositions. Explicitly adding decide makes the discriminant a Bool and allows\nthe dotted-identifier resolution to succeed.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.invalidDottedIdent","header":"Examples","id":"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent--Examples"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Files-and-Directories":{"contents":"Returns the current working directory of the executing process.\n\nReturns the file name of the currently-running executable.\n\nReturns the directory that the current executable is located in.\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.6. Files and Directories","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Files-and-Directories"},"/Notations-and-Macros/Macros/#macro-monad-hygiene":{"contents":"Hygiene is implemented by adding macro scopes to the identifiers that occur in syntax.\nOrdinarily, the process of quotation adds all necessary scopes, but macros that construct syntax directly must add macro scopes to the identifiers that they introduce.\n\nIncrements the macro scope counter so that inside the body of x the macro\nscope is fresh.\n\nAdd a new macro scope to the name n.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009The Macro Monad","header":"22.5.2.2. Hygiene-Related Operations","id":"/Notations-and-Macros/Macros/#macro-monad-hygiene"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Other":{"contents":"* #6285 upstreams the ToLevel typeclass from mathlib and uses it to\nfix the existing ToExpr instances so that they are truly universe\npolymorphic (previously it generated malformed expressions when the\nuniverse level was nonzero). We improve on the mathlib definition of\nToLevel to ensure the class always lives in Type, irrespective of\nthe universe parameter.* #6363 fixes errors at load time in the comparison mode of the Firefox\nprofiler.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Other","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Other"},"/releases/v4.16.0/#release-v4___16___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.16.0 (2025-02-03)","id":"/releases/v4.16.0/#release-v4___16___0"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Pretty-Printing":{"contents":"* #7954 improves pp.oneline, where it now preserves tags when\ntruncating formatted syntax to a single line. Note that the [...]\ncontinuation does not yet have any functionality to enable seeing the\nuntruncated syntax. Closes #3681.* #8617 fixes (1) an issue where private names are not unresolved when\nthey are pretty printed, (2) an issue where in pp.universes mode names\nwere allowed to shadow local names, (3) an issue where in match\npatterns constants shadowing locals wouldn't use _root_, and (4) an\nissue where tactics might have an incorrect \"try this\" when\npp.fullNames is set. Adds more delaboration tests for name\nunresolution.* #8626 closes #3791, making sure that the Syntax formatter inserts\nwhitespace before and after comments in the leading and trailing text of\nSyntax to avoid having comments comment out any following syntax, and to\navoid comments' lexical syntax from being interpreted as being part of\nanother syntax. If the text contains newlines before or after any\ncomments, they are formatted as hard newlines rather than soft newlines.\nFor example, -- comments will have a hard newline after them. Note:\nmetaprograms generating Syntax with comments should be sure to include\nnewlines at the ends of -- comments.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Pretty Printing","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Pretty-Printing"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Pretty-Printing":{"contents":"* #10376 modifies pretty printing of fun binders, suppressing the safe\nshadowing feature among the binders in the same fun. For example,\nrather than pretty printing as fun x x => 0, we now see fun x x_1 => 0. The calculation is done per fun, so for example fun x => id fun x => 0 pretty prints as-is, taking advantage of safe shadowing.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)","header":"Pretty Printing","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Pretty-Printing"},"/releases/v4.25.0/#release-v4___25___0":{"contents":"For this release, 398 changes landed. In addition to the 141 feature additions and 83 fixes listed below there were 21 refactoring changes, 9 documentation improvements, 4 performance improvements, 5 improvements to the test suite and 135 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.25.0 (2025-11-14)","id":"/releases/v4.25.0/#release-v4___25___0"}});