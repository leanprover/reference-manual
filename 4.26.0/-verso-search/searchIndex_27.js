window.docContents[27].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants":{"contents":"Unbundled maps separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the modules Std.HashSet.Raw and Std.HashSet.RawLemmas.\n\nHash sets without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer HashSet\nover HashSet.Raw. Lemmas about the operations on Std.Data.HashSet.Raw are available in the\nmodule Std.Data.HashSet.RawLemmas.This is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash set is used linearly to\navoid expensive copies.The hash set uses == (provided by the BEq typeclass) to compare elements and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.Internal implementation detail of the hash set.\n\nWell-formedness predicate for hash sets. Users of HashSet will not need to interact with this.\nUsers of HashSet.Raw will need to provide proofs of WF to lemmas and should use lemmas like\nWF.empty and WF.insert (which are always named exactly like the operations they are about) to\nshow that set operations preserve well-formedness.Internal implementation detail of the hash set\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"20.19.6.7. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants"},"/Iterators/#iterators":{"contents":"An iterator provides sequential access to each element of some source of data.\nTypical iterators allow the elements in a collection, such as a list, array, or TreeMap to be accessed one by one, but they can also provide access to data by carrying out some monadic effect, such as reading files.\nIterators provide a common interface to all of these operations.\nCode that is written to the iterator API can be agnostic as to the source of the data.\n\nEach iterator maintains an internal state that enables it to determine the next value.\nBecause Lean is a pure functional language, consuming an iterator does not invalidate it, but instead copies it with an updated state.\nAs usual, reference counting is used to optimize programs that use values only once into programs that destructively modify values.\n\nTo use iterators, import Std.Data.Iterators.\n\nMixing CollectionsCombining a list and an array using List.zip or Array.zip would ordinarily require converting one of them into the other collection.\nUsing iterators, they can be processed without conversion:def colors : Array String := #[\"purple\", \"gray\", \"blue\"]\ndef codes : List String := [\"aa27d1\", \"a0a0a0\", \"0000c5\"]\n\n#eval colors.iter.zip codes.iter |>.toArray\n#[(\"purple\", \"aa27d1\"), (\"gray\", \"a0a0a0\"), (\"blue\", \"0000c5\")]\n\n\nAvoiding Intermediate StructuresIn this example, an array of colors and a list of color codes are combined.\nThe program separates three intermediate stages:1. The names and codes are combined into pairs.2. The pairs are transformed into readable strings.3. The strings are combined with newlines.def colors : Array String := #[\"purple\", \"gray\", \"blue\"]\n\ndef codes : List String := [\"aa27d1\", \"a0a0a0\", \"0000c5\"]\n\ndef go : IO Unit := do\n  let colorCodes := colors.iter.zip codes.iter\n  let colorCodes := colorCodes.map fun (name, code) =>\n    s!\"{name} ↦ #{code}\"\n  let colorCodes := colorCodes.fold (init := \"\") fun x y =>\n    if x.isEmpty then y else x ++ \"\\n\" ++ y\n  IO.println colorCodes\n\n#eval go\npurple ↦ #aa27d1\ngray ↦ #a0a0a0\nblue ↦ #0000c5\nThe intermediate stages of the computation do not allocate new data structures.\nInstead, all the steps of the transformation are fused into a single loop, with Iter.fold carrying out one step at a time.\nIn each step, a single color and color code are combined into a pair, rewritten to a string, and added to the result string.\n\nThe Lean standard library provides three kinds of iterator operations.\nProducers create a new iterator from some source of data.\nThey determine which data is to be returned by an iterator, and how this data is to be computed, but they are not in control of when the computations occur.\nConsumers use the data in an iterator for some purpose.\nConsumers request the iterator's data, and the iterator computes only enough data to satisfy a consumer's requests.\nCombinators are both consumers and producers: they create new iterators from existing iterators.\nExamples include Iter.map and Iter.filter.\nThe resulting iterators produce data by consuming their underlying iterators, and do not actually iterate over the underlying collection until they themselves are consumed.\n\nEach built-in collection for which it makes sense to do so can be iterated over.\nIn other words, the collection libraries include iterator producers.\nBy convention, a collection type Coll provides a function Coll.iter that returns an iterator over the elements of a collection.\nExamples include List.iter, Array.iter, and TreeMap.iter.\nAdditionally, other built-in types such as ranges support iteration using the same convention.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"21. Iterators","id":"/Iterators/#iterators"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases":{"contents":"A number of aliases are provided for commonly-used typed syntax varieties.\nThese aliases allow code to be written at a higher level of abstraction.\n\nSyntax that represents a Lean term.\n\nSyntax that represents a command.\n\nSyntax that represents a universe level.\n\nSyntax that represents a tactic.\n\nSyntax that represents a precedence (e.g. for an operator).\n\nSyntax that represents a priority (e.g. for an instance declaration).\n\nSyntax that represents an identifier.\n\nSyntax that represents a string literal.\n\nSyntax that represents a character literal.\n\nSyntax that represents a quoted name literal that begins with a back-tick.\n\nSyntax that represents a numeric literal.\n\nSyntax that represents a scientific numeric literal that may have decimal and exponential parts.\n\nSyntax that represents macro hygiene info.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"22.4.8. Aliases","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--DevOps___CI":{"contents":"* #4427 uses Namespace runners for CI for leanprover/lean4.* #4440 fixes speedcenter tests in CI.* #4441 fixes that workflow change would break CI for unrebased PRs.* #4442 fixes Wasm release-ci.* 6d265b fixes for github.event.pull_request.merge_commit_sha sometimes not being available.* 16cad2 adds optimization for CI to not fetch complete history.* #4544 causes releases to be marked as prerelease on GitHub.* #4446 switches Lake to using src/lake/lakefile.toml to avoid needing to load a version of Lake to build Lake.* Nix* 5eb5fa fixes update-stage0-commit for Nix.* #4476 adds gdb to Nix shell.* e665a0 fixes update-stage0 for Nix.* 4808eb fixes cacheRoots for Nix.* #3811 adds platform-dependent flag to lib target.* #4587 adds linking of -lStd back into nix build flags on darwin.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"DevOps/CI","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--DevOps___CI"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Grind-is-released___":{"contents":"Lean now includes a new SMT-style tactic grind, along with annotations for the Lean standard library.\ngrind ships theory-specific solvers, including cutsat (superseding omega, with model construction)\nand a new Gröbner basis solver.\n\nAlso see the chapter on grind in the reference manual.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Grind is released!","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Grind-is-released___"}});