window.docContents[103].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Bitwise-Operations":{"contents":"Typically, bitwise operations on fixed-width integers should be accessed using Lean's overloaded operators, particularly their instances of ShiftLeft, ShiftRight, AndOp, OrOp, and XorOp.\n\n\n\nBitwise and for word-sized unsigned integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for word-sized signed integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 8-bit unsigned integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 8-bit signed integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 16-bit unsigned integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 16-bit signed integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 32-bit unsigned integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 32-bit signed integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 64-bit unsigned integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise and for 64-bit signed integers. Usually accessed via the &&& operator.Each bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for word-sized unsigned integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for word-sized signed integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 8-bit unsigned integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 8-bit signed integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 16-bit unsigned integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 16-bit signed integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 32-bit unsigned integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 32-bit signed integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 64-bit unsigned integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise or for 64-bit signed integers. Usually accessed via the ||| operator.Each bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for word-sized unsigned integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for word-sized signed integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 8-bit unsigned integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 8-bit signed integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 16-bit unsigned integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 16-bit signed integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 32-bit unsigned integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 32-bit signed integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 64-bit unsigned integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of both input\nintegers are set.This function is overridden at runtime with an efficient implementation.\n\nBitwise exclusive or for 64-bit signed integers. Usually accessed via the ^^^ operator.Each bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for word-sized unsigned integers. Usually\naccessed via the ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for word-sized signed integers. Usually accessed\nvia the ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so ISize.complement a = -(a + 1).This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 8-bit unsigned integers. Usually accessed\nvia the ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 8-bit signed integers. Usually accessed via\nthe ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so Int8.complement a = -(a + 1).This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 16-bit unsigned integers. Usually accessed\nvia the ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 16-bit signed integers. Usually accessed via\nthe ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so Int16.complement a = -(a + 1).This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 32-bit unsigned integers. Usually accessed\nvia the ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 32-bit signed integers. Usually accessed via\nthe ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so Int32.complement a = -(a + 1).This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 64-bit unsigned integers. Usually accessed\nvia the ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.This function is overridden at runtime with an efficient implementation.\n\nBitwise complement, also known as bitwise negation, for 64-bit signed integers. Usually accessed via\nthe ~~~ prefix operator.Each bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so Int64.complement a = -(a + 1).This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for word-sized unsigned integers. Usually accessed via the <<< operator.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for word-sized signed integers. Usually accessed via the <<< operator.Signed integers are interpreted as bitvectors according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 8-bit unsigned integers. Usually accessed via the <<< operator.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 8-bit signed integers. Usually accessed via the <<< operator.Signed integers are interpreted as bitvectors according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 16-bit unsigned integers. Usually accessed via the <<< operator.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 16-bit signed integers. Usually accessed via the <<< operator.Signed integers are interpreted as bitvectors according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 32-bit unsigned integers. Usually accessed via the <<< operator.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 32-bit signed integers. Usually accessed via the <<< operator.Signed integers are interpreted as bitvectors according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 64-bit unsigned integers. Usually accessed via the <<< operator.This function is overridden at runtime with an efficient implementation.\n\nBitwise left shift for 64-bit signed integers. Usually accessed via the <<< operator.Signed integers are interpreted as bitvectors according to the two's complement representation.This function is overridden at runtime with an efficient implementation.\n\nBitwise right shift for word-sized unsigned integers. Usually accessed via the >>> operator.This function is overridden at runtime with an efficient implementation.\n\nArithmetic right shift for word-sized signed integers. Usually accessed via the <<< operator.The high bits are filled with the value of\nthe most significant bit.This function is overridden at runtime with an efficient implementation.\n\nBitwise right shift for 8-bit unsigned integers. Usually accessed via the >>> operator.This function is overridden at runtime with an efficient implementation.\n\nArithmetic right shift for 8-bit signed integers. Usually accessed via the <<< operator.The high bits are filled with the value of the most significant bit.This function is overridden at runtime with an efficient implementation.\n\nBitwise right shift for 16-bit unsigned integers. Usually accessed via the >>> operator.This function is overridden at runtime with an efficient implementation.\n\nArithmetic right shift for 16-bit signed integers. Usually accessed via the <<< operator.The high bits are filled with the value of the most significant bit.This function is overridden at runtime with an efficient implementation.\n\nBitwise right shift for 32-bit unsigned integers. Usually accessed via the >>> operator.This function is overridden at runtime with an efficient implementation.\n\nArithmetic right shift for 32-bit signed integers. Usually accessed via the <<< operator.The high bits are filled with the value of the most significant bit.This function is overridden at runtime with an efficient implementation.\n\nBitwise right shift for 64-bit unsigned integers. Usually accessed via the >>> operator.This function is overridden at runtime with an efficient implementation.\n\nArithmetic right shift for 64-bit signed integers. Usually accessed via the <<< operator.The high bits are filled with the value of the most significant bit.This function is overridden at runtime with an efficient implementation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"20.4.4.6. Bitwise Operations","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Bitwise-Operations"},"/Build-Tools-and-Distribution/Lake/#lake-environment":{"contents":"\n\nWhen invoking the Lean compiler or other tools, Lake sets or modifies a number of environment variables.\nThese values are system-dependent.\nInvoking env without any arguments displays the environment variables and their values.\nOtherwise, the provided command is invoked in Lake's environment.\n\nThe following variables are set, overriding previous values:* LAKE* The detected Lake executable\n* LAKE_HOME* The detected Lake home\n* LEAN_SYSROOT* The detected Lean toolchain directory\n* LEAN_AR* The detected Lean ar binary\n* LEAN_CC* The detected C compiler (if not using the bundled one)\n\nThe following variables are augmented with additional information:* LEAN_PATH* Lake's and the workspace's Lean library directories are added.\n* LEAN_SRC_PATH* Lake's and the workspace's source directories are added.\n* PATH* Lean's, Lake's, and the workspace's binary directories are added.\n    On Windows, Lean's and the workspace's library directories are also added.\n* DYLD_LIBRARY_PATH* On macOS, Lean's and the workspace's library directories are added.\n* LD_LIBRARY_PATH* On platforms other than Windows and macOS, Lean's and the workspace's library directories are added.\n\nLake itself can be configured with the following environment variables:* ELAN_HOME* The location of the Elan installation, which is used for automatic toolchain updates.* ELAN* The location of the elan binary, which is used for automatic toolchain updates.\n    If it is not set, an occurrence of elan must exist on the PATH.* LAKE_HOME* The location of the Lake installation.\n    This environment variable is only consulted when Lake is unable to determine its installation path from the location of the lake executable that's currently running.\n* LEAN_SYSROOT* The location of the Lean installation, used to find the Lean compiler, the standard library, and other bundled tools.\n    Lake first checks whether its binary is colocated with a Lean install, using that installation if so.\n    If not, or if LAKE_OVERRIDE_LEAN is true, then Lake consults LEAN_SYSROOT.\n    If this is not set, Lake consults the LEAN environment variable to find the Lean compiler, and attempts to find the Lean installation relative to the compiler.\n    If LEAN is set but empty, Lake considers Lean to be disabled.\n    If LEAN_SYSROOT and LEAN are unset, the first occurrence of lean on the PATH is used to find the installation.\n* LEAN_CC and LEAN_AR* If LEAN_CC and/or LEAN_AR is set, its value is used as the C compiler or ar command when building libraries.\n    If not, Lake will fall back to the bundled tool in the Lean installation.\n    If the bundled tool is not found, the value of CC or AR, followed by a cc or ar on the PATH, are used.\n* LAKE_NO_CACHE* If true, Lake does not use cached builds from Reservoir or GitHub.\n    This environment variable can be overridden using the --try-cache command-line option.* LAKE_ARTIFACT_CACHE* If true, Lake uses the artifact cache.\n    This is an experimental feature.* LAKE_CACHE_KEY* Defines an authentication key for the remote artifact cache.* LAKE_CACHE_ARTIFACT_ENDPOINT* The base URL for for the remote artifact cache used for artifact uploads.\n    If set, then LAKE_CACHE_REVISION_ENDPOINT must also be set.\n    If neither of these are set, Lake will use Reservoir instead.* LAKE_CACHE_REVISION_ENDPOINT* The base URL for the remote artifact cache used to upload the input/output mappings for each artifact.\n    If set, then LAKE_CACHE_ARTIFACT_ENDPOINT must also be set.\n    If neither of these are set, Lake will use Reservoir instead.\n\nLake considers an environment variable to be true when its value is y, yes, t, true, on, or 1, compared case-insensitively.\nIt considers a variable to be false when its value is n, no, f, false, off, or 0, compared case-insensitively.\nIf the variable is unset, or its value is neither true nor false, a default value is used.\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"24.1.2.1. Environment Variables","id":"/Build-Tools-and-Distribution/Lake/#lake-environment"},"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Collectors":{"contents":"Collectors consume an iterator, returning all of its data in a list or array.\nTo be collected, an iterator must be finite and have an IteratorCollect or IteratorCollectPartial instance.\n\nTraverses the given iterator and stores the emitted values in an array.This function requires a Finite instance proving that the iterator will finish after a finite\nnumber of steps. If the iterator is not finite or such an instance is not available, consider using\nit.allowNontermination.toArray instead of it.toArray. However, it is not possible to formally\nverify the behavior of the partial variant.\n\nTraverses the given iterator and stores the emitted values in an array.This function requires a Finite instance proving that the iterator will finish after a finite\nnumber of steps. If the iterator is not finite or such an instance is not available, consider using\nit.allowNontermination.toArray instead of it.toArray. However, it is not possible to formally\nverify the behavior of the partial variant.\n\nTraverses the given iterator and stores the emitted values in a list. Because\nlists are prepend-only, toListRev is usually more efficient that toList.This function requires a Finite instance proving that the iterator will finish after a finite\nnumber of steps. If the iterator is not finite or such an instance is not available, consider using\nit.allowNontermination.toList instead of it.toList. However, it is not possible to\nformally verify the behavior of the partial variant.\n\nTraverses the given iterator and stores the emitted values in a list. Because\nlists are prepend-only, toListRev is usually more efficient that toList.This function requires a Finite instance proving that the iterator will finish after a finite\nnumber of steps. If the iterator is not finite or such an instance is not available, consider using\nit.allowNontermination.toList instead of it.toList. However, it is not possible to\nformally verify the behavior of the partial variant.\n\nTraverses the given iterator and stores the emitted values in reverse order in a list. Because\nlists are prepend-only, this toListRev is usually more efficient that toList.This function requires a Finite instance proving that the iterator will finish after a finite\nnumber of steps. If the iterator is not finite or such an instance is not available, consider using\nit.allowNontermination.toListRev instead of it.toListRev. However, it is not possible to\nformally verify the behavior of the partial variant.\n\nTraverses the given iterator and stores the emitted values in reverse order in a list. Because\nlists are prepend-only, this toListRev is usually more efficient that toList.This function requires a Finite instance proving that the iterator will finish after a finite\nnumber of steps. If the iterator is not finite or such an instance is not available, consider using\nit.allowNontermination.toListRev instead of it.toListRev. However, it is not possible to\nformally verify the behavior of the partial variant.\n\nIteratorCollect α m provides efficient implementations of collectors for α-based\niterators. Right now, it is limited to a potentially optimized toArray implementation.This class is experimental and users of the iterator API should not explicitly depend on it.\nThey can, however, assume that consumers that require an instance will work for all iterators\nprovided by the standard library.Note: For this to be compositional enough to be useful, toArrayMapped would need to accept a\ntermination proof for the specific mapping function used instead of the blanket Finite α m\ninstance. Otherwise, most combinators like map cannot implement their own instance relying on\nthe instance of their base iterators. However, fixing this is currently low priority.Maps the emitted values of an iterator using the given function and collects the results in an\nArray. This is an internal implementation detail. Consider using it.map f |>.toArray instead.\n\nThis is the default implementation of the IteratorLoop class.\nIt simply iterates through the iterator using IterM.step, incrementally building up the desired\ndata structure. For certain iterators, more efficient implementations are possible and should be\nused instead.\n\nAsserts that a given IteratorCollect instance is equal to IteratorCollect.defaultImplementation.\n(Even though equal, the given instance might be vastly more efficient.)\n\nIteratorCollectPartial α m provides efficient implementations of collectors for α-based\niterators. Right now, it is limited to a potentially optimized partial toArray implementation.This class is experimental and users of the iterator API should not explicitly depend on it.\nThey can, however, assume that consumers that require an instance will work for all iterators\nprovided by the standard library.Maps the emitted values of an iterator using the given function and collects the results in an\nArray. This is an internal implementation detail.\nConsider using it.map f |>.allowNontermination.toArray instead.\n\nThis is the default implementation of the IteratorLoopPartial class.\nIt simply iterates through the iterator using IterM.step, incrementally building up the desired\ndata structure. For certain iterators, more efficient implementations are possible and should be\nused instead.\n\n","context":"Lean Reference\u0009Iterators\u0009Consuming Iterators","header":"21.3.4. Collectors","id":"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Collectors"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-branching":{"contents":"Tactic proofs may use pattern matching and conditionals.\nHowever, their meaning is not quite the same as it is in terms.\nWhile terms are expected to be executed once the values of their variables are known, proofs are executed with their variables left abstract and should consider all cases simultaneously.\nThus, when if and match are used in tactics, their meaning is reasoning by cases rather than selection of a concrete branch.\nAll of their branches are executed, and the condition or pattern match is used to refine the main goal with more information in each branch, rather than to select a single branch.\n\nIn tactic mode, if t then tac1 else tac2 is alternative syntax for:by_cases t\n· tac1\n· tac2\nIt performs case distinction on h† : t or h† : ¬t, where h† is an anonymous\nhypothesis, and tac1 and tac2 are the subproofs. (It doesn't actually use\nnondependent if, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an ite application use\nrefine if t then ?_ else ?_.)\n\nIn tactic mode, if h : t then tac1 else tac2 can be used as alternative syntax for:by_cases h : t\n· tac1\n· tac2\nIt performs case distinction on h : t or h : ¬t and tac1 and tac2 are the subproofs.You can use ?_ or _ for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for tac1 or tac2 then it will require the goal to be closed\nby the end of the block.\n\nReasoning by cases with ifIn each branch of the if, an assumption is added that reflects whether n = 0.example (n : Nat) : if n = 0 then n < 1 else n > 0 := by\n  if n = 0 then\n    simp [*]\n  else\n    simp only [↓reduceIte, gt_iff_lt, *]\n    omega\n\n\nmatch performs case analysis on one or more expressions.\nSee Induction and Recursion.\nThe syntax for the match tactic is the same as term-mode match, except that\nthe match arms are tactics instead of expressions.example (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\nWhen pattern matching, instances of the discriminant in the goal are replaced with the patterns that match them in each branch.\nEach branch must then prove the refined goal.\nCompared to the cases tactic, using match can allow a greater degree of flexibility in the cases analysis being performed, but the requirement that each branch solve its goal completely makes it more difficult to incorporate into larger automation scripts.\n\nReasoning by cases with matchIn each branch of the match, the discriminant n has been replaced by either 0 or k + 1.example (n : Nat) : if n = 0 then n < 1 else n > 0 := by\n  match n with\n  | 0 =>\n    simp\n  | k + 1 =>\n    simp\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures","header":"13.3.1.2. Branching","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-branching"},"/Terms/Function-Application/#The-Lean-Language-Reference--Terms--Function-Application--Pipeline-Syntax":{"contents":"Pipeline syntax provides alternative ways to write function applications.\nRepeated pipelines use parsing precedence instead of nested parentheses to nest applications of functions to positional arguments.\n\nPipelinesRight pipe notation applies the term to the right of the pipe to the one on its left.Left pipe notation applies the term on the left of the pipe to the one on its right.\n\nThe intuition behind right pipeline notation is that the values on the left are being fed to the first function, its results are fed to the second one, and so forth.\nIn left pipeline notation, values on the right are fed leftwards.\n\nRight pipeline notationRight pipelines can be used to call a series of functions on a term.\nFor readers, they tend to emphasize the data that's being transformed.#eval \"Hello!\" |> String.toList |> List.reverse |> List.head!\n'!'\n\n\nLeft pipeline notationLeft pipelines can be used to call a series of functions on a term.\nThey tend to emphasize the functions over the data.#eval List.head! <| List.reverse <| String.toList <| \"Hello!\"\n'!'\n\n\nPipeline FieldsThere is a version of pipeline notation that's used for generalized field notation.\n\ne |>.f arg is an alternative syntax for (e).f arg.Pipeline FieldsSome functions are inconvenient to use with pipelines because their argument order is not conducive.\nFor example, Array.push takes an array as its first argument, not a Nat, leading to this error:#eval #[1, 2, 3] |> Array.push 4\nfailed to synthesize\n  OfNat (Array ?m.4) 4\nnumerals are polymorphic in Lean, but the numeral `4` cannot be used in a context where the expected type is\n  Array ?m.4\ndue to the absence of the instance above\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nUsing pipeline field notation causes the array to be inserted at the first type-correct position:#eval #[1, 2, 3] |>.push 4\n#[1, 2, 3, 4]\nThis process can be iterated:#eval #[1, 2, 3] |>.push 4 |>.reverse |>.push 0 |>.reverse\n#[0, 1, 2, 3, 4]\n\n\n","context":"Lean Reference\u0009Terms\u0009Function Application","header":"10.4.2. Pipeline Syntax","id":"/Terms/Function-Application/#The-Lean-Language-Reference--Terms--Function-Application--Pipeline-Syntax"},"/Terms/Pattern-Matching/#pattern-matching":{"contents":"Pattern matching is a way to recognize and destructure values using a syntax of patterns that are a subset of the terms.\nA pattern that recognizes and destructures a value is similar to the syntax that would be used to construct the value.\nOne or more match discriminants are simultaneously compared to a series of match alternatives.\nDiscriminants may be named.\nEach alternative contains one or more comma-separated sequences of patterns; all pattern sequences must contain the same number of patterns as there are discriminants.\nWhen a pattern sequence matches all of the discriminants, the term following the corresponding => is evaluated in an environment extended with values for each pattern variable as well as an equality hypothesis for each named discriminant.\nThis term is called the right-hand side of the match alternative.\n\nPattern Matching\n\nMatch Discriminants\n\nPattern matching expressions may alternatively use quasiquotations as patterns, matching the corresponding Lean.Syntax values and treating the contents of antiquotations as ordinary patterns.\nQuotation patterns are compiled differently than other patterns, so if one pattern in a match is syntax, then all of them must be.\nQuotation patterns are described in the section on quotations.\n\nPatterns are a subset of the terms.\nThey consist of the following:\n\n Catch-All Patterns\n\nThe hole syntax _ is a pattern that matches any value and binds no pattern variables.\n  Catch-all patterns are not entirely equivalent to unused pattern variables.\n  They can be used in positions where the pattern's typing would otherwise require a more specific inaccessible pattern, while variables cannot be used in these positions.\n\n Identifiers\n\nIf an identifier is not bound in the current scope and is not applied to arguments, then it represents a pattern variable.\n  Pattern variables match any value, and the values thus matched are bound to the pattern variable in the local environment in which the right-hand side is evaluated.\n  If the identifier is bound, it is a pattern if it is bound to the constructor of an inductive type or if its definition has the match_pattern attribute.\n\n Applications\n\nFunction applications are patterns if the function being applied is an identifier that is bound to a constructor or that has the match_pattern attribute and if all arguments are also patterns.\n  If the identifier is a constructor, the pattern matches values built with that constructor if the argument patterns match the constructor's arguments.\n  If it is a function with the match_pattern attribute, then the function application is unfolded and the resulting term's normal form is used as the pattern.\n  Default arguments are inserted as usual, and their normal forms are used as patterns.\n  Ellipses, however, result in all further arguments being treated as universal patterns, even those with associated default values or tactics.\n\n Literals\n\nCharacter literals and string literals are patterns that match the corresponding character or string.\n  Raw string literals are allowed as patterns, but interpolated strings are not.\n  Natural number literals in patterns are interpreted by synthesizing the corresponding OfNat instance and reducing the resulting term to normal form, which must be a pattern.\n  Similarly, scientific literals are interpreted via the corresponding OfScientific instance.\n  While Float has such an instance, Floats cannot be used as patterns because the instance relies on an opaque function that can't be reduced to a valid pattern.\n\n Structure Instances\n\nStructure instances may be used as patterns.\n  They are interpreted as the corresponding structure constructor.\n\n Quoted names\n\nQuoted names, such as `x and ``none, match the corresponding Lean.Name value.\n\n Macros\n\nMacros in patterns are expanded.\n  They are patterns if the resulting expansions are patterns.\n\n Inaccessible patterns\n\nInaccessible patterns are patterns that are forced to have a particular value by later typing constraints.\n  Any term may be used as an inaccessible term.\n  Inaccessible terms are parenthesized, with a preceding period (.).\n\n\n\nInaccessible Patterns\n\nInaccessible PatternsA number's parity is whether it's even or odd:inductive Parity : Nat → Type where\n  | even (h : Nat) : Parity (h + h)\n  | odd (h : Nat) : Parity ((h + h) + 1)\n\ndef Nat.parity (n : Nat) : Parity n :=\n  match n with\n  | 0 => .even 0\n  | n' + 1 =>\n    match n'.parity with\n    | .even h => .odd h\n    | .odd h =>\n      have eq : (h + 1) + (h + 1) = (h + h + 1 + 1) :=\n        by omega\n      eq ▸ .even (h + 1)\nBecause a value of type Parity contains half of a number (rounded down) as part of its representation of evenness or oddness, division by two can be implemented (in an unconventional manner) by finding a parity and then extracting the number.def half (n : Nat) : Nat :=\n  match n, n.parity with\n  | .(h + h),     .even h => h\n  | .(h + h + 1), .odd h  => h\nBecause the index structure of Parity.even and Parity.odd force the number to have a certain form that is not otherwise a valid pattern, patterns that match on it must use inaccessible patterns for the number being divided.\n\nPatterns may additionally be named.\nNamed patterns associate a name with a pattern; in subsequent patterns and on the right-hand side of the match alternative, the name refers to the part of the value that was matched by the given pattern.\nNamed patterns are written with an @ between the name and the pattern.\nJust like discriminants, named patterns may also be provided with names for equality assumptions.\n\nNamed Patterns\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Terms","header":"10.8. Pattern Matching","id":"/Terms/Pattern-Matching/#pattern-matching"},"/The-Simplifier/Configuring-Simplification/#simp-options":{"contents":"Some global options affect simp:\n\nEnable/disable simprocs (simplification procedures).\n\nWhen tracing is enabled, calls to simp or dsimp will print an equivalent simp only call.\n\nenable the 'unnecessary simpa' linter\n\nenable/disable tracing for the given module and submodules\n\nenable/disable tracing for the given module and submodules\n\n","context":"Lean Reference\u0009The Simplifier\u0009Configuring Simplification","header":"16.6.1. Options","id":"/The-Simplifier/Configuring-Simplification/#simp-options"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Compiler":{"contents":"* #10625 implements zero cost BaseIO by erasing the IO.RealWorld\nparameter from argument lists and structures. This is a major breaking\nchange for FFI.* #10727 fixes name mangling to be unambiguous / injective by adding 00\nfor disambiguation where necessary. Additionally, the inverse function,\nLean.Name.unmangle has been added which can be used to unmangle a\nmangled identifier. This unmangler has been added to demonstrate the\ninjectivity but also to allow unmangling identifiers e.g. for debugging\npurposes.* #10856 performs more widening in ElimDeadBranches in an attempt to\nimprove performance in situations with a lot of local precision.* #10864 reduces the amount of symbols in our DLLs by cutting open a\nlinking cycle of the shape:Environment -> Compiler -> Meta -> Environment* #10982 changes the closure allocator to use the general allocator\ninstead of the small object one.\nThis is because users may create closures with a gigantic amount of\nclosed variables which in turn\nboost the size of the closure beyond the small object threshold.* #11000 fixes a memleak caused by the Lean based IO.waitAny\nimplementation by reverting it.* #11010 makes the eager lambda lifting heuristic more predictable by\nblocking it from lifting from\nany kind of inlineable function, not just @[inline]. It also adapts\nthe doc-string to describe\nwhat is actually going on.* #11020 improves the detection of situations where we branch multiple\ntimes on the same value in the\ncode generator. Previously this would only consider repeated branching\non function arguments, now on\narbitrary values.* #11042 fixes a case of overeager constant folding on UInts where the\ncompiler would mistakenly\nassume 0 - x = x.* #11043 fixes a case of overeager constant folding on Nat where the\ncompiler would mistakenly assume 0 - x = x (see also #11042 for the\nsame bug on UInts).* #11044 enforces users of the constant folder API to provide proofs of\ntheir algebraic properties,\nthus hopefully avoiding bugs such as #11042 and #11043 in the future.* #11056 fixes ST.Ref.ptrEq to act as described in the docs. This fixes\ntwo bugs:1. The recent IO.RealWorld elimination PR overlooked this function\n(afaik this is the only one),\ncausing its return value to be generally wrong.2. The implementation of ptrEq would previously always consider two\ndifferent cells with pointer\nequivalent value to be pointer equal. However, the function is supposed\nto check whether two\nRef are the same cell, not whether the contained elements are.* #11151 fixes some details in the Markdown renderings of Verso\ndocstrings, and adds tests to keep them correct. Also adds tests for\nVerso docstring metadata.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0 (2025-12-13)","header":"Compiler","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Compiler"}});