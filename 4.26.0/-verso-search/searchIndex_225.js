window.docContents[225].resolve({"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Comparisons":{"contents":"Equality and inequality tests on Int are typically performed using the decidability of its equality and ordering relations or using the BEq Int and Ord Int instances.\n\n\n\nNon-strict inequality of integers, usually accessed via the ≤ operator.a ≤ b is defined as b - a ≥ 0, using Int.NonNeg.\n\nStrict inequality of integers, usually accessed via the < operator.a < b when a + 1 ≤ b.\n\nDecides whether two integers are equal. Usually accessed via the DecidableEq Int instance.This function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.Examples:* show (7 : Int) = (3 : Int) + (4 : Int) by decide* if (6 : Int) = (3 : Int) * (2 : Int) then \"yes\" else \"no\" = \"yes\"* (¬ (6 : Int) = (3 : Int)) = true\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","header":"20.2.4.5. Comparisons","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Comparisons"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion":{"contents":"Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence.\n\nTransforms the hash map into an array of mappings in some order.\n\nTransforms the hash map into a list of mappings in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","header":"20.19.3.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion"},"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Monad-Transformers-and-Lifting":{"contents":"Real-world programs often use monads that are built from multiple monad transformers, with operations being frequently lifted from one monad to another.\nVerification of these programs requires taking this into account.\nWe can tweak the previous example to demonstrate this.\n\n\n\nNow, there is an application with two separate monads, both built using transformers:abbrev CounterM := StateT Supply (ReaderM String)\n\nabbrev AppM := StateT Bool CounterM\nInstead of using StateM Supply, mkFresh uses CounterM:def mkFresh : CounterM Nat := do\n  let n ← (·.counter) <$> get\n  modify fun s => { s with counter := s.counter + 1 }\n  pure n\nmkFreshN is defined in terms of AppM, which includes multiple states and a reader effect.\nThe definition of mkFreshN lifts mkFresh into AppM:def mkFreshN (n : Nat) : AppM (List Nat) := do\n  let mut acc := #[]\n  for _ in [:n] do\n    let n ← mkFresh\n    acc := acc.push n\n  return acc.toList\n\n\nThen the mvcgen-based proof goes through unchanged:@[spec]\ntheorem mkFresh_spec (c : Nat) :\n    ⦃fun state => ⌜state.counter = c⌝⦄\n    mkFresh\n    ⦃⇓ r state => ⌜r = c ∧ c < state.counter⌝⦄ := by\n  --TODO: mvcgen [mkFresh] with grind\n  sorry\n\n@[spec]\ntheorem mkFreshN_spec (n : Nat) :\n    ⦃⌜True⌝⦄ mkFreshN n ⦃⇓ r => ⌜r.Nodup⌝⦄ := by\n  -- `liftCounterM` here ensures unfolding\n  mvcgen [mkFreshN]\n  invariants\n  · ⇓⟨xs, acc⟩ _ state =>\n      ⌜(∀ n ∈ acc, n < state.counter) ∧ acc.toList.Nodup⌝\n  with grind\n\n\nThe WPMonad type class asserts that wp⟦prog⟧ distributes over the Monad operations (“monad morphism”).\nThis proof might not look much more exciting than when only a single monad was involved.\nHowever, under the radar of the user the proof builds on a cascade of specifications for MonadLift instances.\n\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Tutorial: Verifying Imperative Programs Using  mvcgen","header":"18.6.5. Monad Transformers and Lifting","id":"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Monad-Transformers-and-Lifting"},"/The-Type-System/Inductive-Types/#structure-params":{"contents":"Just like ordinary inductive type declarations, the header of the structure declaration contains a signature that may specify both parameters and a resulting universe.\nStructures may not define indexed families.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Structure Declarations","header":"4.4.2.1. Structure Parameters","id":"/The-Type-System/Inductive-Types/#structure-params"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Linear-Integer-Normalization-in-simp-___arith":{"contents":"* #7000 adds helper theorems for justifying the linear integer\nnormalizer.* #7002 implements the normalizer for linear integer arithmetic\nexpressions. It is not connect to simp +arith yet because of some\nspurious [simp] attributes.* #7011 adds simp +arith for integers. It uses the new grind\nnormalizer for linear integer arithmetic. We still need to implement\nsupport for dividing the coefficients by their GCD. It also fixes\nseveral bugs in the normalizer.* #7015 makes sure simp +arith normalizes coefficients in linear\ninteger polynomials. There is still one todo: tightening the bound of\ninequalities.* #7030 adds completes the linear integer inequality normalizer for\ngrind. The missing normalization step replaces a linear inequality of\nthe form a_1*x_1 + ... + a_n*x_n + b <= 0 with a_1/k * x_1 + ... + a_n/k * x_n + ceil(b/k) <= 0 where k = gcd(a_1, ..., a_n).\nceil(b/k) is implemented using the helper cdiv b k.* #7040 ensures that terms such as f (2*x + y) and f (y + x + x)\nhave the same normal form when using simp +arith* #7043 deprecates the tactics simp_arith, simp_arith!,\nsimp_all_arith and simp_all_arith!. Users can just use the +arith\noption.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"Linear Integer Normalization in simp +arith","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Linear-Integer-Normalization-in-simp-___arith"}});