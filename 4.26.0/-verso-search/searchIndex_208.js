window.docContents[208].resolve({"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Conversions":{"contents":"Converts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\nConverts true to 1 and false to 0.\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans\u0009API Reference","header":"20.11.4.3. Conversions","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Conversions"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Conversions":{"contents":"Converts a packed array of bytes to a linked list.\n\nInterprets a ByteArray of size 8 as a big-endian UInt64.Panics if the array's size is not 8.\n\nInterprets a ByteArray of size 8 as a little-endian UInt64.Panics if the array's size is not 8.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"20.17.1.4. Conversions","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Conversions"},"/Basic-Types/Integers/#int-div":{"contents":"The Div Int and Mod Int instances implement Euclidean division, described in the reference for Int.ediv.\nThis is not, however, the only sensible convention for rounding and remainders in division.\nFour pairs of division and modulus functions are available, implementing various conventions.\n\nDivision by 0In all integer division conventions, division by 0 is defined to be 0:#eval Int.ediv 5 0\n#eval Int.ediv 0 0\n#eval Int.ediv (-5) 0\n#eval Int.bdiv 5 0\n#eval Int.bdiv 0 0\n#eval Int.bdiv (-5) 0\n#eval Int.fdiv 5 0\n#eval Int.fdiv 0 0\n#eval Int.fdiv (-5) 0\n#eval Int.tdiv 5 0\n#eval Int.tdiv 0 0\n#eval Int.tdiv (-5) 0\nAll evaluate to 0.0\n\n\nInteger division that uses the E-rounding convention. Usually accessed via the / operator.\nDivision by zero is defined to be zero, rather than an error.In the E-rounding convention (Euclidean division), Int.emod x y satisfies 0 ≤ Int.emod x y < Int.natAbs y\nfor y ≠ 0 and Int.ediv is the unique function satisfying Int.emod x y + (Int.ediv x y) * y = x\nfor y ≠ 0.This means that Int.ediv x y is ⌊x / y⌋ when y > 0 and ⌈x / y⌉ when y < 0.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* (7 : Int) / (0 : Int) = 0* (0 : Int) / (7 : Int) = 0* (12 : Int) / (6 : Int) = 2* (12 : Int) / (-6 : Int) = -2* (-12 : Int) / (6 : Int) = -2* (-12 : Int) / (-6 : Int) = 2* (12 : Int) / (7 : Int) = 1* (12 : Int) / (-7 : Int) = -1* (-12 : Int) / (7 : Int) = -2* (-12 : Int) / (-7 : Int) = 2\n\nInteger modulus that uses the E-rounding convention. Usually accessed via the % operator.In the E-rounding convention (Euclidean division), Int.emod x y satisfies 0 ≤ Int.emod x y < Int.natAbs y\nfor y ≠ 0 and Int.ediv is the unique function satisfying Int.emod x y + (Int.ediv x y) * y = x\nfor y ≠ 0.This function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.Examples:* (7 : Int) % (0 : Int) = 7* (0 : Int) % (7 : Int) = 0* (12 : Int) % (6 : Int) = 0* (12 : Int) % (-6 : Int) = 0* (-12 : Int) % (6 : Int) = 0* (-12 : Int) % (-6 : Int) = 0* (12 : Int) % (7 : Int) = 5* (12 : Int) % (-7 : Int) = 5* (-12 : Int) % (7 : Int) = 2* (-12 : Int) % (-7 : Int) = 2\n\nInteger division using the T-rounding convention.In the T-rounding convention (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0. In this convention, Int.tmod a b + b * (Int.tdiv a b) = a.This function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.Examples:* (7 : Int).tdiv (0 : Int) = 0* (0 : Int).tdiv (7 : Int) = 0* (12 : Int).tdiv (6 : Int) = 2* (12 : Int).tdiv (-6 : Int) = -2* (-12 : Int).tdiv (6 : Int) = -2* (-12 : Int).tdiv (-6 : Int) = 2* (12 : Int).tdiv (7 : Int) = 1* (12 : Int).tdiv (-7 : Int) = -1* (-12 : Int).tdiv (7 : Int) = -1* (-12 : Int).tdiv (-7 : Int) = 1\n\nInteger modulo using the T-rounding convention.In the T-rounding convention (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0 and Int.tmod a 0 = a.In this convention, Int.tmod a b + b * (Int.tdiv a b) = a. Additionally,\nInt.natAbs (Int.tmod a b) = Int.natAbs a % Int.natAbs b, and when b does not divide a,\nInt.tmod a b has the same sign as a.This function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.Examples:* (7 : Int).tmod (0 : Int) = 7* (0 : Int).tmod (7 : Int) = 0* (12 : Int).tmod (6 : Int) = 0* (12 : Int).tmod (-6 : Int) = 0* (-12 : Int).tmod (6 : Int) = 0* (-12 : Int).tmod (-6 : Int) = 0* (12 : Int).tmod (7 : Int) = 5* (12 : Int).tmod (-7 : Int) = 5* (-12 : Int).tmod (7 : Int) = -5* (-12 : Int).tmod (-7 : Int) = -5\n\nBalanced division.This returns the unique integer so that b * (Int.bdiv a b) + Int.bmod a b = a.Examples:* (7 : Int).bdiv 0 = 0* (0 : Int).bdiv 7 = 0* (12 : Int).bdiv 6 = 2* (12 : Int).bdiv 7 = 2* (12 : Int).bdiv 8 = 2* (12 : Int).bdiv 9 = 1* (-12 : Int).bdiv 6 = -2* (-12 : Int).bdiv 7 = -2* (-12 : Int).bdiv 8 = -1* (-12 : Int).bdiv 9 = -1\n\nBalanced modulus.This version of integer modulus uses the balanced rounding convention, which guarantees that\n-m / 2 ≤ Int.bmod x m < m/2 for m ≠ 0 and Int.bmod x m is congruent to x modulo m.If m = 0, then Int.bmod x m = x.Examples:* (7 : Int).bmod 0 = 7* (0 : Int).bmod 7 = 0* (12 : Int).bmod 6 = 0* (12 : Int).bmod 7 = -2* (12 : Int).bmod 8 = -4* (12 : Int).bmod 9 = 3* (-12 : Int).bmod 6 = 0* (-12 : Int).bmod 7 = 2* (-12 : Int).bmod 8 = -4* (-12 : Int).bmod 9 = -3\n\nInteger division using the F-rounding convention.In the F-rounding convention (flooring division), Int.fdiv x y satisfies Int.fdiv x y = ⌊x / y⌋\nand Int.fmod is the unique function satisfying Int.fmod x y + (Int.fdiv x y) * y = x.Examples:* (7 : Int).fdiv (0 : Int) = 0* (0 : Int).fdiv (7 : Int) = 0* (12 : Int).fdiv (6 : Int) = 2* (12 : Int).fdiv (-6 : Int) = -2* (-12 : Int).fdiv (6 : Int) = -2* (-12 : Int).fdiv (-6 : Int) = 2* (12 : Int).fdiv (7 : Int) = 1* (12 : Int).fdiv (-7 : Int) = -2* (-12 : Int).fdiv (7 : Int) = -2* (-12 : Int).fdiv (-7 : Int) = 1\n\nInteger modulus using the F-rounding convention.In the F-rounding convention (flooring division), Int.fdiv x y satisfies Int.fdiv x y = ⌊x / y⌋\nand Int.fmod is the unique function satisfying Int.fmod x y + (Int.fdiv x y) * y = x.Examples:* (7 : Int).fmod (0 : Int) = 7* (0 : Int).fmod (7 : Int) = 0* (12 : Int).fmod (6 : Int) = 0* (12 : Int).fmod (-6 : Int) = 0* (-12 : Int).fmod (6 : Int) = 0* (-12 : Int).fmod (-6 : Int) = 0* (12 : Int).fmod (7 : Int) = 5* (12 : Int).fmod (-7 : Int) = -2* (-12 : Int).fmod (7 : Int) = 2* (-12 : Int).fmod (-7 : Int) = -5\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference\u0009Arithmetic","header":"20.2.4.3.1. Division","id":"/Basic-Types/Integers/#int-div"},"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Range-Types":{"contents":"A range of elements of α with a closed lower bound and an open upper bound.a...b or a...<b is the range of all values greater than or equal to a : α and\nless than b : α. This is notation for Rco.mk a b.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given left-closed right-open range as an array in ascending order.\n\nReturns the elements of the given left-closed right-open range as a list in ascending order.\n\nReturns the number of elements contained in the given left-closed right-open range.\n\nChecks whether the range contains any value.This function returns a meaningful value given LawfulUpwardEnumerable and\nLawfulUpwardEnumerableLT instances.\n\nA range of elements of α with closed lower and upper bounds.a...=b is the range of all values greater than or equal to a : α and less than or\nequal to b : α. This is notation for Rcc.mk a b.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given closed range as an array in ascending order.\n\nReturns the elements of the given closed range as a list in ascending order.\n\nReturns the number of elements contained in the given closed range.\n\nChecks whether the range contains any value.This function returns a meaningful value given LawfulUpwardEnumerable and\nLawfulUpwardEnumerableLE instances.\n\nAn upward-unbounded range of elements of α with a closed lower bound.a...* is the range of all values greater than or equal to a : α.\nThis is notation for Rci.mk a.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given left-closed right-unbounded range as an array in ascending order.\n\nReturns the elements of the given left-closed right-unbounded range as a list in ascending order.\n\nReturns the number of elements contained in the given left-closed right-unbounded range.\n\nChecks whether the range contains any value.\nThis function exists for completeness and always returns false:\nThe closed lower bound is contained in the range, so\nleft-closed right-unbounded ranges are never empty.\n\nA range of elements of α with an open lower and upper bounds.a<...b or a<...<b is the range of all values greater than a : α and less than\nb : α. This is notation for Roo.mk a b.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given open range as an array in ascending order.\n\nReturns the elements of the given open range as a list in ascending order.\n\nReturns the number of elements contained in the given open range.\n\nChecks whether the range contains any value.This function returns a meaningful value given LawfulUpwardEnumerable and\nLawfulUpwardEnumerableLT instances.\n\nA range of elements of α with an open lower bound and a closed upper bound.a<...=b is the range of all values greater than a : α and less than or equal to\nb : α. This is notation for Roc.mk a b.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given left-open right-closed range as an array in ascending order.\n\nReturns the elements of the given left-open right-closed range as a list in ascending order.\n\nReturns the number of elements contained in the given left-open right-closed range.\n\nChecks whether the range contains any value.This function returns a meaningful value given LawfulUpwardEnumerable and\nLawfulUpwardEnumerableLT instances.\n\nAn upward-unbounded range of elements of α with an open lower bound.a<...* is the range of all values greater than a : α.\nThis is notation for Roi.mk a.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given left-open right-unbounded range as an array in ascending order.\n\nReturns the elements of the given left-open right-unbounded range as a list in ascending order.\n\nReturns the number of elements contained in the given left-open right-unbounded range.\n\nChecks whether the range contains any value.This function returns a meaningful value given a LawfulUpwardEnumerable instance.\n\nA downward-unbounded range of elements of α with an open upper bound.*...b or *...<b is the range of all values less than b : α.\nThis is notation for Rio.mk b.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given closed range as an array in ascending order.\n\nReturns the elements of the given closed range as a list in ascending order.\n\nReturns the number of elements contained in the given closed range.\n\nChecks whether the range contains any value.This function returns a meaningful value given LawfulUpwardEnumerable,\nLawfulUpwardEnumerableLT and LawfulUpwardEnumerableLeast? instances.\n\nA downward-unbounded range of elements of α with a closed upper bound.*...=b is the range of all values less than or equal to b : α.\nThis is notation for Ric.mk b.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given closed range as an array in ascending order.\n\nReturns the elements of the given closed range as a list in ascending order.\n\nReturns the number of elements contained in the given closed range.\n\nChecks whether the range contains any value.\nThis function exists for completeness and always returns false:\nThe closed upper bound is contained in the range, so\nleft-unbounded right-closed ranges are never empty.\n\nA full range of all elements of α. Its only inhabitant is the range *...*, which is\nnotation for Rii.mk.\n\nReturns an iterator over the given range. This iterator will emit the elements of the range\nin increasing order.\n\nReturns the elements of the given full range as an array in ascending order.\n\nReturns the elements of the given full range as a list in ascending order.\n\nReturns the number of elements contained in the full range.\n\nChecks whether the range contains any value.This function returns a meaningful value given LawfulUpwardEnumerable and\nLawfulUpwardEnumerableLeast? instances.\n\n","context":"Lean Reference\u0009Basic Types\u0009Ranges","header":"20.18.1. Range Types","id":"/Basic-Types/Ranges/#The-Lean-Language-Reference--Basic-Types--Ranges--Range-Types"},"/Basic-Types/Strings/#string-api-compare":{"contents":"The LT String instance is defined by the lexicographic ordering on strings based on the LT Char instance.\nLogically, this is modeled by the lexicographic ordering on the lists that model strings, so List.Lex defines the order.\nIt is decidable, and the decision procedure is overridden at runtime with efficient code that takes advantage of the run-time representation of strings.\n\nNon-strict inequality on strings, typically used via the ≤ operator.a ≤ b is defined to mean ¬ b < a.\n\nReturns the first position where the two strings differ.If one string is a prefix of the other, then the returned position is the end position of the\nshorter string. If the strings are identical, then their end position is returned.Examples:* \"tea\".firstDiffPos \"ten\" = ⟨2⟩* \"tea\".firstDiffPos \"tea\" = ⟨3⟩* \"tea\".firstDiffPos \"teas\" = ⟨3⟩* \"teas\".firstDiffPos \"tea\" = ⟨3⟩\n\nChecks whether the first string (p) is a prefix of the second (s).String.startsWith is a version that takes the potential prefix after the string.Examples:* \"red\".isPrefixOf \"red green blue\" = true* \"green\".isPrefixOf \"red green blue\" = false* \"\".isPrefixOf \"red green blue\" = true\n\nChecks whether the first string (s) begins with the second (pre).String.isPrefix is a version that takes the potential prefix before the string.Examples:* \"red green blue\".startsWith \"red\" = true* \"red green blue\".startsWith \"green\" = false* \"red green blue\".startsWith \"\" = true* \"red\".startsWith \"red\" = true\n\nChecks whether the first string (s) ends with the second (post).Examples:* \"red green blue\".endsWith \"blue\" = true* \"red green blue\".endsWith \"green\" = false* \"red green blue\".endsWith \"\" = true* \"red\".endsWith \"red\" = true\n\nDecides whether two strings are equal. Normally used via the DecidableEq String instance and the\n= operator.At runtime, this function is overridden with an efficient native implementation.\n\nComputes a hash for strings.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"20.8.4.8. Comparisons","id":"/Basic-Types/Strings/#string-api-compare"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-in-Continuation-Passing-Style":{"contents":"Continuation-passing-style state monads represent stateful computations as functions that, for any type whatsoever, take an initial state and a continuation (modeled as a function) that accepts a value and an updated state.\nAn example of such a type is (δ : Type u) → σ → (α → σ → δ) → δ, though StateCpsT is a transformer that can be applied to any monad.\nState monads in continuation passing style have different performance characteristics than tuple-based state monads; for some applications, it may be worth benchmarking them.\n\n\n\nAn alternative implementation of a state monad transformer that internally uses continuation passing\nstyle instead of tuples.\n\nRuns an action from the underlying monad in the monad with state. The state is not modified.This function is typically implicitly accessed via a MonadLiftT instance as part of automatic\nlifting.\n\nRuns a stateful computation that's represented using continuation passing style by providing it with\nan initial state and a continuation.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value, discarding the final state.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value paired with the final state.While the state is internally represented in continuation passing style, the resulting value is the\nsame as for a non-CPS state monad.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009State","header":"14.5.4.3. State Monads in Continuation Passing Style","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-in-Continuation-Passing-Style"}});