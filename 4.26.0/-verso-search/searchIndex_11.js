window.docContents[11].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--String-Modifications":{"contents":"Replaces the character at a specified position in a string with a new character. If the position is\ninvalid, the string is returned unchanged.If both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.This is a legacy function. The recommended alternative is String.ValidPos.set, combined with\nString.pos or another means of obtaining a String.ValidPos.Examples:* \"abc\".set ⟨1⟩ 'B' = \"aBc\"* \"abc\".set ⟨3⟩ 'D' = \"abc\"* \"L∃∀N\".set ⟨4⟩ 'X' = \"L∃XN\"* \"L∃∀N\".set ⟨2⟩ 'X' = \"L∃∀N\" because '∃' is a multi-byte character, so the byte index 2 is an\ninvalid position.\n\nReplaces the character at position p in the string s with the result of applying f to that\ncharacter. If p is an invalid position, the string is returned unchanged.If both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.This is a legacy function. The recommended alternative is String.ValidPos.set, combined with\nString.pos or another means of obtaining a String.ValidPos.Examples:* \"abc\".modify ⟨1⟩ Char.toUpper = \"aBc\"* \"abc\".modify ⟨3⟩ Char.toUpper = \"abc\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Positions","header":"20.8.4.5.6. String Modifications","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Positions--String-Modifications"},"/Namespaces-and-Sections/#namespaces-sections":{"contents":"Names are organized into hierarchical namespaces, which are collections of names.\nNamespaces are the primary means of organizing APIs in Lean: they provide an ontology of operations, grouping related items.\nAdditionally, while this is not done by giving them names in the namespace, the effects of features such as syntax extensions, instances, and attributes can be attached to a namespace.\n\nSorting operations into namespaces organizes libraries conceptually, from a global perspective.\nAny given Lean file will, however, typically not use all names equally.\nSections provide a means of ordering a local view of the globally-available collection of names, as well as a way to precisely control the scope of compiler options along with language extensions, instances, and attributes.\nThey also allow parameters shared by many declarations to be declared centrally and propagated as needed using the variable command.\n\n\n\n\n\n","context":"Lean Reference","header":"6. Namespaces and Sections","id":"/Namespaces-and-Sections/#namespaces-sections"},"/Terms/Function-Types/#function-types":{"contents":"Lean's function types describe more than just the function's domain and codomain.\nThey also provide instructions for elaborating application sites by indicating that some parameters are to be discovered automatically via unification or type class synthesis, that others are optional with default values, and that yet others should be synthesized using a custom tactic script.\nFurthermore, their syntax contains support for abbreviating curried functions.\n\nFunction typesDependent function types include an explicit name:Non-dependent function types do not:\n\nCurried Function TypesDependent function types may include multiple parameters that have the same type in a single set of parentheses:This is equivalent to repeating the type annotation for each parameter name in a nested function type.\n\nImplicit, Optional, and Auto ParametersFunction types can describe functions that take implicit, instance implicit, optional, and automatic parameters.\nAll but instance implicit parameters require one or more names.\n\nMultiple Parameters, Same TypeThe type of Nat.add can be written in the following ways:* Nat → Nat → Nat* (a : Nat) → (b : Nat) → Nat* (a b : Nat) → NatThe last two types allow the function to be used with named arguments; aside from this, all three are equivalent.\n\n","context":"Lean Reference\u0009Terms","header":"10.2. Function Types","id":"/Terms/Function-Types/#function-types"},"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Control-Flow":{"contents":"Let us consider another example that combines for loops with an early return.\nList.Nodup is a predicate that asserts that a given list does not contain any duplicates.\nThe function nodup below decides this predicate:def nodup (l : List Int) : Bool := Id.run do\n  let mut seen : Std.HashSet Int := ∅\n  for x in l do\n    if x ∈ seen then\n      return false\n    seen := seen.insert x\n  return true\n\n\nThis function is correct if it returns true for every list that satisfies List.Nodup and false for every list that does not.\nJust as it was in mySum, the use of do-notation and the Id monad is an internal implementation detail of nodup.\nThus, the proof begins by using Id.of_wp_run_eq to make the proof state amenable to mvcgen:theorem nodup_correct (l : List Int) : nodup l ↔ l.Nodup := by\n  generalize h : nodup l = r\n  apply Id.of_wp_run_eq h\n  mvcgen\n  invariants\n  · Invariant.withEarlyReturn\n      (onReturn := fun ret seen => ⌜ret = false ∧ ¬l.Nodup⌝)\n      (onContinue := fun xs seen =>\n        ⌜(∀ x, x ∈ seen ↔ x ∈ xs.prefix) ∧ xs.prefix.Nodup⌝)\n  with grind\n\n\nThe proof has the same succinct structure as for the initial mySum example, because we again offload all proofs to grind and its existing automation around List.Nodup.\nTherefore, the only difference is in the loop invariant.\nSince our loop has an early return, we construct the invariant using the helper function Invariant.withEarlyReturn.\nThis function allows us to specify the invariant in three parts:* onReturn ret seen holds after the loop was left through an early return with value ret.\n  In case of nodup, the only value that is ever returned is false, in which case nodup has decided there is a duplicate in the list.* onContinue xs seen is the regular induction step that proves the invariant is preserved each loop iteration.\n  The iteration state is captured by the cursor xs.\n  The given example asserts that the set seen contains all the elements of previous loop iterations and asserts that there were no duplicates so far.* onExcept must hold when the loop throws an exception.\n  There are no exceptions in Id, so we leave it unspecified to use the default.\n  (Exceptions will be discussed at a later point.)\n\nNote that the form mvcgen invariants? will suggest an initial invariant using Invariant.withEarlyReturn, so there is no need to memorize the exact syntax for specifying invariants:example (l : List Int) : nodup l ↔ l.Nodup := by\n  generalize h : nodup l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants? <;> sorry\nThe tactic suggests a starting invariant.\nThis starting point will not allow the proof to succeed—after all, if the invariant can be inferred by the system, then there's no need to make the user specify it—but it does provide a reminder of the correct syntax to use for assertions in the current monad:Try this:\n  [apply] invariants\n  ·\n    Invariant.withEarlyReturn (onReturn := fun r letMuts => ⌜l.Nodup ∧ (r = true ↔ l.Nodup)⌝) (onContinue :=\n      fun xs letMuts => ⌜xs.prefix = [] ∧ letMuts = ∅ ∨ xs.suffix = [] ∧ l.Nodup⌝)\n\n\nNow consider the following direct (and excessively golfed) proof without mvcgen:theorem nodup_correct_directly (l : List Int) : nodup l ↔ l.Nodup := by\n  rw [nodup]\n  generalize hseen : (∅ : Std.HashSet Int) = seen\n  change ?lhs ↔ l.Nodup\n  suffices h : ?lhs ↔ l.Nodup ∧ ∀ x ∈ l, x ∉ seen by grind\n  clear hseen\n  induction l generalizing seen with grind [Id.run_pure, Id.run_bind]\n\n\nSome observations:* The proof is even shorter than the one with mvcgen.* The use of generalize to generalize the accumulator relies on there being exactly one occurrence of ∅ to generalize. If that were not the case, we would have to copy parts of the program into the proof. This is a no-go for larger functions.* grind splits along the control flow of the function and reasons about Id, given the right lemmas.\n  While this works for Id.run_pure and Id.run_bind, it would not work for Id.run_seq, for example, because that lemma is not E-matchable.\n  If grind would fail, we would be forced to do all the control flow splitting and monadic reasoning by hand until grind could pick up again.\n\nThe usual way to avoid replicating the control flow of a definition in a proof is to use the fun_cases or fun_induction tactics.\nUnfortunately, fun_cases does not help with control flow inside a forIn application.\nThe mvcgen tactic, on the other hand, ships with support for many forIn implementations.\nIt can easily be extended (with @[spec] annotations) to support custom forIn implementations.\nFurthermore, an mvcgen-powered proof will never need to copy any part of the original program.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Tutorial: Verifying Imperative Programs Using  mvcgen","header":"18.6.3. Control Flow","id":"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Control-Flow"},"/The-Simplifier/Invoking-the-Simplifier/#simp-tactic-naming":{"contents":"Lean's simplifier can be invoked in a variety of ways.\nThe most common patterns are captured in a set of tactics.\nThe tactic reference contains a complete list of simplification tactics.\n\nSimplification tactics all contain simp in their name.\nAside from that, they are named according to a system of prefixes and suffixes that describe their functionality:\n\n -! suffix\n\nSets the autoUnfold configuration option to true, causing the simplifier to unfold all definitions\n\n -? suffix\n\nCauses the simplifier to keep track of which rules it employed during simplification and suggest a minimal simp set as an edit to the tactic script\n\n -_arith suffix\n\nEnables the use of linear arithmetic simplification rules\n\n d- prefix\n\nCauses the simplifier to simplify only with rewrites that hold definitionally\n\n -_all suffix\n\nCauses the simplifier to repeatedly simplify all assumptions and the conclusion of the goal, taking as many hypotheses into account as possible, until no further simplification is possible\n\n\n\nThere are two further simplification tactics, simpa and simpa!, which are used to simultaneously simplify a goal and either a proof term or an assumption before discharging the goal.\nThis simultaneous simplification makes proofs more robust to changes in the simp set.\n\n\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.1. Invoking the Simplifier","id":"/The-Simplifier/Invoking-the-Simplifier/#simp-tactic-naming"},"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes":{"contents":"Types are classified by universes. Universes are also referred to as sorts.\nEach universe has a level,  which is a natural number.\nThe Sort operator constructs a universe from a given level. \nIf the level of a universe is smaller than that of another, the universe itself is said to be smaller.\nWith the exception of propositions (described later in this chapter), types in a given universe may only quantify over types in smaller universes.\nSort 0 is the type of propositions, while each Sort (u + 1) is a type that describes data.\n\nEvery universe is an element of the next larger universe, so Sort 5 includes Sort 4.\nThis means that the following examples are accepted:\n\nexample : Sort 5 := Sort 4\nexample : Sort 2 := Sort 1\n\n\nOn the other hand, Sort 3 is not an element of Sort 5:\n\nexample : Sort 5 := Sort 3\n\n\nType mismatch\n  Type 2\nhas type\n  Type 3\nof sort `Type 4` but is expected to have type\n  Type 4\nof sort `Type 5`\n\n\nSimilarly, because Unit is in Sort 1, it is not in Sort 2:\n\nexample : Sort 1 := Unit\n\n\nexample : Sort 2 := Unit\n\n\nType mismatch\n  Unit\nhas type\n  Type\nof sort `Type 1` but is expected to have type\n  Type 1\nof sort `Type 2`\n\n\nBecause propositions and data are used differently and are governed by different rules, the abbreviations Type and Prop are provided to make the distinction more convenient.   \nType u is an abbreviation for Sort (u + 1), so Type 0 is Sort 1 and Type 3 is Sort 4.\nType 0 can also be abbreviated Type, so Unit : Type and Type : Type 1.\nProp is an abbreviation for Sort 0.\n\n\n\n\n\n","context":"Lean Reference\u0009Type System","header":"4.3. Universes","id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind--New-pattern-inference-heuristic":{"contents":"#10422 and #10432\nimplement the new E-matching pattern inference heuristic for\ngrind. Here is a summary of the\nnew behavior.\n\n* [grind =], [grind =_], [grind _=_], [grind <-=]: no changes; we keep the current behavior.* [grind ->], [grind <-], [grind =>], [grind <=]: we stop using the minimal indexable subexpression and instead use the first indexable one.* [grind! <mod>]: behaves like [grind <mod>] but uses the minimal indexable subexpression restriction. We generate an error if the user writes [grind! =], [grind! =_], [grind! _=_], or [grind! <-=], since there is no pattern search in these cases.* [grind]: it tries =, =_, <-, ->, <=, => with and without the minimal indexable subexpression restriction. For the ones that work, we generate a code action to encourage users to select the one they prefer.* [grind!]: it tries <-, ->, <=, => using the minimal indexable subexpression restriction. For the ones that work, we generate a code action to encourage users to select the one they prefer.* [grind? <mod>]: where <mod> is one of the modifiers above, it behaves like [grind <mod>] but also displays the pattern.\n\nExample:\n\n/--\ninfo: Try these:\n  • [grind =] for pattern: [f (g #0)]\n  • [grind =_] for pattern: [r #0 #0]\n  • [grind! ←] for pattern: [g #0]\n-/\n#guard_msgs in\n@[grind] axiom fg₇ : f (g x) = r x x\n\n\nImportant: Users can still use the old pattern inference heuristic\nby setting:\n\nset_option backward.grind.inferPattern true\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights\u0009Grind","header":"New pattern inference heuristic","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind--New-pattern-inference-heuristic"}});