window.docContents[127].resolve({"/Interacting-with-Lean/#format-api":{"contents":"A representation of a set of strings, in which the placement of newlines and indentation differ.Given a specific line width, specified in columns, the string that uses the fewest lines can be\nselected.The pretty-printing algorithm is based on Wadler's paper\nA Prettier Printer.The empty format.A position where a newline may be inserted if the current group does not fit within the allotted\ncolumn width.align tells the formatter to pad with spaces to the current indentation level, or else add a\nnewline if we are already at or past the indent.If force is true, then it will pad to the indent even if it is in a flattened group.Example:open Std Format in\n#eval IO.println (nest 2 <| \".\" ++ align ++ \"a\" ++ line ++ \"b\")\n. a\n  b\nA node containing a plain string.If the string contains newlines, the formatter emits them and then indents to the current level.nest indent f increases the current indentation level by indent while rendering f.Example:open Std Format in\ndef fmtList (l : List Format) : Format :=\n  let f := joinSep l  (\", \" ++ Format.line)\n  group (nest 1 <| \"[\" ++ f ++ \"]\")\nThis will be written all on one line, but if the text is too large, the formatter will put in\nlinebreaks after the commas and indent later lines by 1.Concatenation of two Formats.Creates a new flattening group for the given inner Format.Used for associating auxiliary information (e.g. Exprs) with Format objects.\n\nDetermines how groups should have linebreaks inserted when the text would overfill its remaining\nspace.* allOrNone will make a linebreak on every Format.line in the group or none of them.[1,\n 2,\n 3]\n* fill will only make linebreaks on as few Format.lines as possible:[1, 2,\n 3]\nEither all Format.lines in the group will be newlines, or all of them will be spaces.As few Format.lines in the group as possible will be newlines.\n\nCreates a group in which as few Format.lines as possible are rendered as newlines.This is an alias for Format.group, with FlattenBehavior set to fill.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.1. Documents","id":"/Interacting-with-Lean/#format-api"},"/Iterators/Run-Time-Considerations/#The-Lean-Language-Reference--Iterators--Run-Time-Considerations":{"contents":"For many use cases, using iterators can give a performance benefit by avoiding allocating intermediate data structures.\nWithout iterators, zipping a list with an array requires first converting one of them to the other type, allocating an intermediate structure, and then using the appropriate zip function.\nUsing iterators, the intermediate structure can be avoided.\n\nWhen an iterator is consumed, the resulting computation should be thought of as a single loop, even if the iterator itself is built using combinators from a number of underlying iterators.\nOne step of the loop may carry out multiple steps from the underlying iterators.\nIn many cases, the Lean compiler can optimize iterator computations, removing the intermediate overhead, but this is not guaranteed.\nWhen profiling shows that significant time is taken by a tight loop that involves multiple sources of data, it can be necessary to inspect the compiler's IR to see whether the iterators' operations were fused.\nIn particular, if the IR contains many pattern matches over steps, then it can be a sign of a failure to inline or specialize.\nIf this is the case, it may be necessary to write a tail-recursive function by hand rather than using the higher-level API.\n\n","context":"Lean Reference\u0009Iterators","header":"21.1. Run-Time Considerations","id":"/Iterators/Run-Time-Considerations/#The-Lean-Language-Reference--Iterators--Run-Time-Considerations"},"/Run-Time-Code/Foreign-Function-Interface/#ffi-borrowing":{"contents":"By default, all lean_object * parameters of an extern function are considered owned.\nThe external code is passed a “virtual RC token” and is responsible for passing this token along to another consuming function (exactly once) or freeing it via lean_dec.\nTo reduce reference counting overhead, parameters can be marked as borrowed by prefixing their type with @&.\nBorrowed objects must only be passed to other non-consuming functions (arbitrarily often) or converted to owned values using lean_inc.\nIn lean.h, the lean_object * aliases lean_obj_arg and b_lean_obj_arg are used to mark this difference on the C side.\nReturn values and @[export] parameters are always owned at the moment.\n\nBorrowed ParametersParameters may be marked as borrowed by prefixing their types with @&.\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Foreign Function Interface\u0009The Lean ABI","header":"23.4.1.2. Borrowing","id":"/Run-Time-Code/Foreign-Function-Interface/#ffi-borrowing"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers":{"contents":"A predicate transformer is a function from postconditions for some postcondition state into assertions for that state.\nThe function must be conjunctive, which means it must distribute over PostCond.and.\n\nThe type of predicate transformers for a given ps : PostShape and return type α : Type.\nA predicate transformer x : PredTrans ps α is a function that takes a postcondition\nQ : PostCond α ps and returns a precondition x.apply Q : Assertion ps.Apply the predicate transformer to a postcondition.The predicate transformer is conjunctive: t (Q₁ ∧ₚ Q₂) ⊣⊢ₛ t Q₁ ∧ t Q₂.\nSo the stronger the postcondition, the stronger the resulting precondition.\n\nTransforming a conjunction of postconditions is the same as the conjunction of transformed\npostconditions.\n\nThe stronger the postcondition, the stronger the transformed precondition.\n\nPredicate transformers form a monad.\nThe pure operator is the identity transformer; it simply instantiates the postcondition with the its argument.\nThe bind operator composes predicate transformers.\n\n\n\n\n\nThe helper operators PredTrans.pushArg, PredTrans.pushExcept, and PredTrans.pushOption modify a predicate transformer by adding a standard side effect.\nThey are used to implement the WP instances for transformers such as StateT, ExceptT, and OptionT; they can also be used to implement monads that can be thought of in terms of one of these.\nFor example, PredTrans.pushArg is typically used for state monads, but can also be used to implement a reader monad's instance, treating the reader's value as read-only state.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers","header":"18.2.3. Predicate Transformers","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Predicate-Transformers"},"/The-Type-System/Inductive-Types/#inductive-types-runtime-relevance":{"contents":"Types and proofs have no run-time representation.\nThat is, if an inductive type is a Prop, then its values are erased prior to compilation.\nSimilarly, all theorem statements and types are erased.\nTypes with run-time representations are called relevant, while types without run-time representations are called irrelevant.\n\nTypes are irrelevantEven though List.cons has the following signature, which indicates three parameters:List.cons.{u} {α : Type u} : α → List α → List α\nits run-time representation has only two, because the type argument is run-time irrelevant.\n\nProofs are irrelevantEven though Fin.mk has the following signature, which indicates three parameters:Fin.mk {n : Nat} (val : Nat) : val < n → Fin n\nits run-time representation has only two, because the proof is erased.\n\nIn most cases, irrelevant values simply disappear from compiled code.\nHowever, in cases where some representation is required (such as when they are arguments to polymorphic constructors), they are represented by a trivial value.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation","header":"4.4.4.2. Relevance","id":"/The-Type-System/Inductive-Types/#inductive-types-runtime-relevance"}});