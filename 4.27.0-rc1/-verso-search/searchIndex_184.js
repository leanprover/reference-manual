window.docContents[184].resolve({"/Build-Tools-and-Distribution/Lake/#test-lint-drivers":{"contents":"A test driver is responsible for running the tests for a package.\nTest drivers may be executable targets or Lake scripts, in which case the test command runs them, or they may be libraries, in which case test causes them to be elaborated, with the expectation that test failures are registered as elaboration failures.\n\nSimilarly, a lint driver is responsible for checking the code for stylistic issues.\nLint drivers may be executables or scripts, which are run by lint.\n\nA test or lint driver can be configured by either setting the testDriver or lintDriver package configuration options or by tagging a script, executable, or library with the test_driver or lint_driver attribute in a Lean-format configuration file.\nA definition in a dependency can be used as a test or lint driver by using the <pkg>/<name> syntax for the appropriate configuration option.\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","header":"24.1.1.4. Test and Lint Drivers","id":"/Build-Tools-and-Distribution/Lake/#test-lint-drivers"},"/Source-Files-and-Modules/#module-scopes":{"contents":"A module is a source file that has opted in to a distinction between public and private information.\nLean ensures that private information can change without affecting clients that import only its public information.\nThis discipline brings a number of benefits: Much-improved average build times\n\nChanges to files that affect only non-exported information (e.g. proofs, comments, and docstrings) will not trigger rebuilds outside of these files.\n  Even when dependent files have to be rebuilt, those files that cannot be affected (as determined by their import annotations) can be skipped.\n\n Control over API evolution\n\nLibrary authors can trust that changes to non-exported information will not affect downstream users of their library.\n  If only a function's signature is exposed, then downstream users cannot rely on definitional equalities that involve its unfolding; this means that the library's author is free to adopt a more efficient algorithm without unintentionally breaking client code.\n\n Avoiding accidental unfolding\n\nLimiting the scope in which definitions can be unfolded allows for avoiding both reductions that should be replaced by application of more specific theorems as well as unproductive reductions that were not in fact necessary.\n  This improves the speed of proof elaboration.\n\n Smaller executables\n\nSeparating compile-time and run-time code allows for more aggressive dead code elimination, guaranteeing that metaprograms such as tactics do not make it into the final binary.\n\n Reduced memory usage\n\nExcluding private information such as proofs from importing can improve Lean's memory use both while building and editing a project.\n  Porting mathlib4 to the module system has shown savings close to 50% from this even before imports are further minimized.\n\n\n\nModules contain two separate scopes: the public scope consists of information that is visible in modules that import a module, while the private scope consists of information that is generally visible only within the module.\nSome examples of information that can be private or public include: Names\n\nConstants (such as definitions, inductive types, or constructors) may be private or public.\n  A public constant's type may only refer to public names.\n\n Definitions\n\nA public definition may be exposed or not.\n  If a public definition is not exposed, then it cannot be unfolded in contexts that only have access to the public scope.\n  Instead, clients must rely on the theorems about the definition that are provided in the public scope.\n\n\n\nEach declaration has default visibility rules.\nGenerally speaking, all names are private by default, unless defined in a public section.\nEven public names usually place the bodies of definitions in the private scope, and even proofs in exposed definitions are kept private.\nThe specific visibility rules for each declaration command are documented together with the declaration itself.\n\nPrivate and Public DefinitionsThe module Greet.Create defines a function greeting.\nBecause there are no visibility modifiers, this function defaults to the private scope:The definition of greeting is not visible in the module Greet, even though it imports Greet.Create:Unknown identifier `greeting`\nIf greeting is made public, then greetTwice can refer to it:\n\nExposed and Unexposed DefinitionsThe module Greet.Create defines a public function greeting.Although the definition of greeting is visible in the module Greet, it cannot be unfolded in a proof because the definition's body is in the private scope of Greet:Invalid simp theorem `greeting`: Expected a definition with an exposed body\nAdding the @[expose] attribute exposes the definition so that downstream modules can unfold greeting:Now, the proof can proceed:\n\nProofs are PrivateIn this module, the function incr is public, but its implementation is not exposed:Nonetheless, the proof of the theorem incr_eq_plus1 can unfold its definition.\nThis is because proofs of theorems are in the private scope.\nThis is the case both for public and private theorems.\n\nThe option backward.privateInPublic can be used while transitioning from ordinary source files to modules.\nWhen it is set to true, private definitions are exported, though their names are not accessible in importing modules.\nHowever, references to them in the public part of their defining module are allowed.\nSuch references result in a warning unless the option backward.privateInPublic.warn is set to false.\nThese warnings can be used to locate and eventually eliminate these references, allowing backward.privateInPublic to be disabled.\nSimilarly, backward.proofsInPublic causes proofs created with by to be public, rather than private; this can enable by to fill in metavariables in its expected type.\nMost use cases for backward.proofsInPublic also require that backward.privateInPublic is enabled.\n\n(module system) Export private declarations, allowing for arbitrary access to them while code is being ported to the module system. Such accesses will generate warnings\nunless backward.privateInPublic.warn is disabled.\n\n(module system) Warn on accesses to private declarations that are allowed only by backward.privateInPublic being enabled.\n\n(module system) Do not abstract proofs used in the public scope into auxiliary theorems. Enabling this option may lead to failures or, when backward.privateInPublic and its warn sub-option are enabled, additional warnings from private accesses.\n\nExporting Private DefinitionsIn the module L.Defs, the public definition of f refers to the private definition drop2 in its signature.\nBecause backward.privateInPublic is true, this is allowed, resulting in a warning:Private declaration `drop2` accessed publicly; this is allowed only because the `backward.privateInPublic` option is enabled.\n\nDisable `backward.privateInPublic.warn` to silence this warning.\nWhen the module is imported, references to f use drop2 as a default argument value; however, its name is inaccessible in the module L:@f Nat xs (@drop2✝ Nat) : List Nat\n\n\nProofs in PublicIn the plain source file NotMod, the definition of two uses the content of the proof to fill out the numeric value in the definition by solving a metavariable:Converting this file to a module results in an error, because the body of the definition is exposed in the public part but the proof is private and thus cannot change the public type:tactic execution is stuck, goal contains metavariables\n  ?m.3 + ?m.3 = ?m.5\nSetting the option backward.proofsInPublic causes the proof to be in the public part of the module so it can solve the metavariable:However, it is typically better style to reformulate the definition so that the proof has a complete goal:\n\nThe private scope of a module may be imported into another module using the all modifier.\nBy default, this is only allowed if the imported module and the current module are from the same Lake package, as its main purpose is to allow for separating definitions and proofs into separate modules for internal organization of a library.\nThe Lake package or library option allowImportAll can be set to allow other packages to access to the current package's private scopes via import all.\nThe imported private scope includes private imports of the imported module, including nested import alls.\nAs a consequence, the set of private scopes accessible to the current module is the transitive closure of import all declarations.\n\nThe module system's import all is more powerful than import without the module system.\nIt makes imported private definitions accessible directly by name, as if they were defined in the current module.\nA secondary use case for import all is to access code in multiple modules within a library that should nonetheless not be provided to downstream consumers, as well as to allow tests to access information that is not part of the public API.\n\nImporting Private InformationThis library separates a module of definitions from a module of lemmas.\nThis is a common pattern in Lean code.However, because Tree.count is not exposed, the proof in the lemma file cannot unfold it:Invalid simp theorem `count`: Expected a definition with an exposed body\nImporting the private scope from Tree.Basic into the lemma module allows the definition to be unfolded in the proof.\n\n\n\n","context":"Lean Reference\u0009Source Files and Modules","header":"5.4. Modules and Visibility","id":"/Source-Files-and-Modules/#module-scopes"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-goals":{"contents":"all_goals tac runs tac on each goal, concatenating the resulting goals, if any.\n\nany_goals tac applies the tactic tac to every goal, and succeeds if at\nleast one application succeeds.\n\n* case tag => tac focuses on the goal with case name tag and solves it using tac,\nor else fails.* case tag x₁ ... xₙ => tac additionally renames the n most recent hypotheses\nwith inaccessible names to the given names.* case tag₁ | tag₂ => tac is equivalent to (case tag₁ => tac); (case tag₂ => tac).\n\ncase' is similar to the case tag => tac tactic, but does not ensure the goal\nhas been solved after applying tac, nor admits the goal if tac failed.\nRecall that case closes the goal using sorry when tac fails, and\nthe tactic execution is not interrupted.\n\nnext => tac focuses on the next goal and solves it using tac, or else fails.\nnext x₁ ... xₙ => tac additionally renames the n most recent hypotheses with\ninaccessible names to the given names.\n\nfocus tac focuses on the main goal, suppressing all other goals, and runs tac on it.\nUsually · tac, which enforces that the goal is closed by tac, should be preferred.\n\n· conv focuses on the main conv goal and tries to solve it using s.\n\n· conv focuses on the main conv goal and tries to solve it using s.\n\nfail_if_success t fails if the tactic t succeeds.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.2. Goal Selection","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-goals"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Breaking-changes":{"contents":"* #8751 adds the nondep field of Expr.letE to the C++ data model.Breaking change: Expr.updateLet! is renamed to Expr.updateLetE!.* #8105 adds support for server-sided RpcRef reuse and fixes a bug\nwhere trace nodes in the InfoView would close while the file was still being processed.Breaking change: Since WithRpcRef is now capable of tracking its identity\nto decide which WithRpcRef usage constitutes a reuse, the constructor of\nWithRpcRef has been made private to discourage downstream users from\ncreating WithRpcRef instances with manually-set ids. Instead, WithRpcRef.mk\n(which lives in BaseIO) is now the preferred way to create WithRpcRef instances.* #8654 adds server-side support for a new module hierarchy component in\nVS Code.Breaking change: This PR augments the .ilean format with the direct imports of a file\nin order to implement the $/lean/moduleHierarchy/importedBy request and bumps the .ilean format version.* #8804 implements first-class support for nondependent let expressions\nin the elaborator.Breaking change: Uses of letLambdaTelescope/mkLetFVars need to use generalizeNondepLet := false;\nsee the PR description for more info.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Breaking changes","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Breaking-changes"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Overhaul-of-the-String-Type":{"contents":"* #10304 redefines String to be the type of byte arrays b\nfor which b.IsValidUtf8. This moves the data model of strings much closer to the actual data representation at runtime.* #10457 introduces safe alternatives to String.Pos and Substring\nthat can only represent valid positions/slices. Specifically, the PR* introduces the predicate String.Pos.IsValid;* proves several nontrivial equivalent conditions for String.Pos.IsValid;* introduces String.ValidPos, which is a String.Pos with an IsValid proof;* introduces String.Slice, which is like Substring but made from String.ValidPos instead of Pos;* introduces String.Pos.IsValidForSlice, which is like String.Pos.IsValid but for slices;* introduces String.Slice.Pos, which is like String.ValidPos but for slices;* introduces various functions for converting between the two types of positions.* #10514 defines the new String.Slice API.* #10713 enforces rules around arithmetic of String.Pos.Raw.Breaking Change: The HAdd and HSub instances for String.Pos.Raw are have been removed.\nSee the PR description for more information.* #10735 moves many operations involving String.Pos.Raw to a the\nString.Pos.Raw namespace.Breaking Change: After this PR, String.pos_lt_eq is no longer a simp lemma.\nAdd String.Pos.Raw.lt_iff as a simp lemma if your proofs break.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Overhaul of the String Type","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Overhaul-of-the-String-Type"}});