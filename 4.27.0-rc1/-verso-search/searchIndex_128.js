window.docContents[128].resolve({"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Properties":{"contents":"Returns the “sign” of the integer as another integer:* 1 for positive numbers,* -1 for negative numbers, and* 0 for 0.Examples:* Int.sign 34 = 1* Int.sign 2 = 1* Int.sign 0 = 0* Int.sign -1 = -1* Int.sign -362 = -1\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","header":"20.2.4.1. Properties","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Properties"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Head-and-Tail":{"contents":"Returns the first element of a non-empty list.\n\nReturns the first element in the list, if there is one. Returns none if the list is empty.Use List.headD to provide a fallback value for empty lists, or List.head! to panic on empty\nlists.Examples:* ([] : List Nat).head? = none* [3, 2, 1].head? = some 3\n\nReturns the first element in the list if there is one, or fallback if the list is empty.Use List.head? to return an Option, and List.head! to panic on empty lists.Examples:* [].headD \"empty\" = \"empty\"* [].headD 2 = 2* [\"head\", \"shoulders\", \"knees\"].headD \"toes\" = \"head\"\n\nReturns the first element in the list. If the list is empty, panics and returns default.Safer alternatives include:* List.head, which requires a proof that the list is non-empty,* List.head?, which returns an Option, and* List.headD, which returns an explicitly-provided fallback value on empty lists.\n\nDrops the first element of a nonempty list, returning the tail. Returns [] when the argument is\nempty.Examples:* [\"apple\", \"banana\", \"grape\"].tail = [\"banana\", \"grape\"]* [\"apple\"].tail = []* ([] : List String).tail = []\n\nDrops the first element of a nonempty list, returning the tail. If the list is empty, this function\npanics when executed and returns the empty list.Safer alternatives include* tail, which returns the empty list without panicking,* tail?, which returns an Option, and* tailD, which returns a fallback value when passed the empty list.Examples:* [\"apple\", \"banana\", \"grape\"].tail! = [\"banana\", \"grape\"]* [\"banana\", \"grape\"].tail! = [\"grape\"]\n\nDrops the first element of a nonempty list, returning the tail. Returns none when the argument is\nempty.Alternatives include List.tail, which returns the empty list on failure, List.tailD, which\nreturns an explicit fallback value, and List.tail!, which panics on the empty list.Examples:* [\"apple\", \"banana\", \"grape\"].tail? = some [\"banana\", \"grape\"]* [\"apple\"].tail? = some []* ([] : List String).tail = none\n\nDrops the first element of a nonempty list, returning the tail. Returns none when the argument is\nempty.Alternatives include List.tail, which returns the empty list on failure, List.tail?, which\nreturns an Option, and List.tail!, which panics on the empty list.Examples:* [\"apple\", \"banana\", \"grape\"].tailD [\"orange\"] = [\"banana\", \"grape\"]* [\"apple\"].tailD [\"orange\"] = []* [].tailD [\"orange\"] = [\"orange\"]\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"20.15.3.4. Head and Tail","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Head-and-Tail"},"/Definitions/Recursive-Definitions/#partial-functions":{"contents":"The partial modifier may only be applied to function definitions.\nPartial functions are not required to demonstrate termination, and Lean does not attempt to do so.\nThese functions are “partial” in the sense that they do not necessarily specify a mapping from each element of the domain to an element of the codomain, because they might fail to terminate for some or all elements of the domain.\nThey are elaborated into pre-definitions that contain explicit recursion, and type checked using the kernel; however, they are subsequently treated as opaque constants by the logic.\n\nThe function's return type must be inhabited; this ensures soundness.\nOtherwise, a partial function could have a type such as Unit → Empty.\nTogether with Empty.elim, the existence of such a function could be used to prove False even if it does not reduce.\n\nWith partial definitions, the kernel is responsible for the following:\n\n* It ensures that the pre-definition's type is indeed a well-formed type.* It checks that the pre-definition's type is a function type.* It ensures that the function's codomain is inhabited by demanding a Nonempty or Inhabited instance.* It checks that the resulting term would be type-correct if Lean had recursive definitions.\n\nEven though recursive definitions are not part of the kernel's type theory, the kernel can still be used to check that the body of the definition has the right type.\nThis works the same way as in other functional languages: uses of recursion are type checked by checking the body in an environment in which the definition is already associated with its type.\nHaving ensured that it type checks, the body is discarded and only the opaque constant is retained by the kernel.\nAs with all Lean functions, the compiler generates code from the elaborated pre-definition.\n\nEven though partial functions are not unfolded by the kernel, it is still possible to reason about other functions that call them so long as this reasoning doesn't depend on the implementation of the partial function itself.\n\nPartial Functions in ProofsThe recursive function nextPrime inefficiently computes the next prime number after a given number by repeatedly testing candidates with trial division.\nBecause there are infinitely many prime numbers, it always terminates; however, formulating this proof would be nontrivial.\nIt is thus marked partial.def isPrime (n : Nat) : Bool := Id.run do\n  for i in [2:n] do\n    if i * i > n then return true\n    if n % i = 0 then return false\n  return true\n\npartial def nextPrime (n : Nat) : Nat :=\n  let n := n + 1\n  if isPrime n then n else nextPrime n\nIt is nonetheless possible to prove that the following two functions are equal:def answerUser (n : Nat) : String :=\n  s!\"The next prime is {nextPrime n}\"\n\ndef answerOtherUser (n : Nat) : String :=\n  \" \".intercalate [\n    \"The\",\n    \"next\",\n    \"prime\",\n    \"is\",\n    toString (nextPrime n)\n  ]\nIn fact, the proof is by rfl:theorem answer_eq_other : answerUser = answerOtherUser := by\n  rfl\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial and Unsafe Definitions","header":"7.6.5.1. Partial Functions","id":"/Definitions/Recursive-Definitions/#partial-functions"},"/Introduction/#reference-boxes":{"contents":"Definitions, inductive types, syntax formers, and tactics have specific descriptions.\nThese descriptions are marked as follows:\n\n/--\nEvenness: a number is even if it can be evenly divided by two.\n-/\ninductive Even : Nat → Prop where\n  | /-- 0 is considered even here -/\n    zero : Even 0\n  | /-- If `n` is even, then so is `n + 2`. -/\n    plusTwo : Even n → Even (n + 2)\nEvenness: a number is even if it can be evenly divided by two.0 is considered even hereIf n is even, then so is n + 2.\n\n","context":"Lean Reference\u0009Introduction\u0009Typographical Conventions","header":"1.2.4. Constant, Syntax, and Tactic References","id":"/Introduction/#reference-boxes"},"/Notations-and-Macros/#language-extension":{"contents":"Different mathematical fields have their own notational conventions, and many notations are re-used with differing meanings in different fields.\nIt is important that formal developments are able to use established notations: formalizing mathematics is already difficult, and the mental overhead of translating between syntaxes can be substantial.\nAt the same time, it's important to be able to control the scope of notational extensions.\nMany fields use related notations with very different meanings, and it should be possible to combine developments from these separate fields in a way where both readers and the system know which convention is in force in any given region of a file.\n\nLean addresses the problem of notational extensibility with a variety of mechanisms, each of which solves a different aspect of the problem.\nThey can be combined flexibly to achieve the necessary results:\n\n* The extensible parser  allows a great variety of notational conventions to be implemented declaratively, and combined flexibly.* Macros allow new syntax to be easily mapped to existing syntax, which is a simple way to provide meaning to new constructs.\n  Due to hygiene and automatic propagation of source positions, this process doesn't interfere with Lean's interactive features.* Elaborators provide new syntax with the same tools available to Lean's own syntax in cases where a macro is insufficiently expressive.* Notations allow the simultaneous definition of a parser extension, a macro, and a pretty printer.\n   When defining infix, prefix, or postfix operators, custom operators automatically take care of precedence and associativity.* Low-level parser extensions allow the parser to be extended in ways that modify its rules for tokens and whitespace, or that even completely replace Lean's syntax. This is an advanced topic that requires familiarity with Lean internals; nevertheless, the possibility of doing this without modifying the compiler is important. This reference manual is written using a language extension that replaces Lean's concrete syntax with a Markdown-like language for writing documents, but the source files are still Lean files.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"22. Notations and Macros","id":"/Notations-and-Macros/#language-extension"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-classical":{"contents":"classical tacs runs tacs in a scope where Classical.propDecidable is a low priority\nlocal instance.Note that classical is a scoping tactic: it adds the instance only within the\nscope of the tactic.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.1. Classical Logic","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-classical"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Documentation":{"contents":"* #6009 fixes a typo in the docstring for prec and makes the text\nslightly more precise.* #6040 join → flatten in docstring* #6110 does some mild refactoring of the Lean.Elab.StructInst module\nwhile adding documentation.* #6144 converts 3 doc-string to module docs since it seems that this is\nwhat they were intended to be!* #6150 refine kernel code comments* #6158 adjust file reference in Data.Sum* #6239 explains the order in which Expr.abstract introduces de Bruijn\nindices.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Documentation","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Documentation"}});