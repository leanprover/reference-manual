window.docContents[18].resolve({"/Iterators/Iterator-Definitions/#iterator-plausibility":{"contents":"In addition to the step function, instances of Iterator include a relation Iterator.IsPlausibleStep.\nThis relation exists because most iterators both maintain invariants over their internal state and yield values in a predictable manner.\nFor example, array iterators track both an array and a current index into it.\nStepping an array iterator results in an iterator over the same underlying array; it yields a value when the index is small enough, or is done otherwise.\nThe plausible steps from an iterator state are those which are related to it via the iterator's implementation of IsPlausibleStep.\nTracking plausibility at the logical level makes it feasible to reason about termination behavior for monadic iterators.\n\nBoth Iter.Step and IterM.Step are defined in terms of PlausibleIterStep; thus, both types can be used with leading dot notation for its namespace.\nAn Iter.Step or IterM.Step can be analyzed using the three match pattern functions PlausibleIterStep.yield, PlausibleIterStep.skip, and PlausibleIterStep.done.\nThese functions pair the information in the underlying IterStep with the surrounding proof object.\n\nA variant of IterStep that bundles the step together with a proof that it is \"plausible\".\nThe plausibility predicate will later be chosen to assert that a state is a plausible successor\nof another state. Having this proof bundled up with the step is important for termination proofs.See IterM.Step and Iter.Step for the concrete choice of the plausibility predicate.\n\nMatch pattern for the yield case. See also IterStep.yield.\n\nMatch pattern for the skip case. See also IterStep.skip.\n\nMatch pattern for the done case. See also IterStep.done.\n\n","context":"Lean Reference\u0009Iterators\u0009Iterator Definitions","header":"21.2.1. Plausibility","id":"/Iterators/Iterator-Definitions/#iterator-plausibility"}});