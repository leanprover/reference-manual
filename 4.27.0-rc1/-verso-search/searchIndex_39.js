window.docContents[39].resolve({"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed":{"contents":"\n\nThis error occurs when the type of a definition is not fully specified and Lean is unable to infer\nits type from the available information. If the definition has parameters, this error refers only to\nthe resulting type after the colon (the error\nlean.inferBinderTypeFailed indicates\nthat a parameter type could not be inferred).\n\nTo resolve this error, provide additional type information in the definition. This can be done\nstraightforwardly by providing an explicit resulting type after the colon in the definition\nheader. Alternatively, if an explicit resulting type is not provided, adding further type\ninformation to the definition's body—such as by specifying implicit type arguments or giving\nexplicit types to let binders—may allow Lean to infer the type of the definition. Look for type\ninference or implicit argument synthesis errors that arise alongside this one to identify\nambiguities that may be contributing to this error.\n\nNote that when an explicit resulting type is provided—even if that type contains holes—Lean will not\nuse information from the definition body to help infer the type of the definition or its parameters.\nThus, adding an explicit resulting type may also necessitate adding type annotations to parameters\nwhose types were previously inferrable. Additionally, it is always necessary to provide an explicit\ntype in a theorem declaration: the theorem syntax requires a type annotation, and the elaborator\nwill never attempt to use the theorem body to infer the proposition being proved.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.inferDefTypeFailed","id":"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Connectives-and-Quantifiers":{"contents":"Predicate ConnectivesSyntactic sugar for SPred.and.Syntactic sugar for SPred.or.Syntactic sugar for SPred.not.Syntactic sugar for SPred.imp.Syntactic sugar for SPred.iff.\n\nConjunction in SPred: states that satisfy P and satisfy Q satisfy spred(P ∧ Q).\n\nConjunction of a list of stateful predicates. A state satisfies conjunction env if it satisfies\nall predicates in env.\n\nDisjunction in SPred: states that either satisfy P or satisfy Q satisfy spred(P ∨ Q).\n\nNegation in SPred: states that do not satisfy P satisfy spred(¬ P).\n\nImplication in SPred: states that satisfy Q whenever they satisfy P satisfy spred(P → Q).\n\nBiimplication in SPred: states that either satisfy both P and Q or satisfy neither satisfy\nspred(P ↔ Q).\n\nPredicate QuantifiersEach form of universal quantification is syntactic sugar for an invocation of SPred.forall on a function that takes the quantified variable as a parameter.Each form of existential quantification is syntactic sugar for an invocation of SPred.exists on a function that takes the quantified variable as a parameter.\n\nUniversal quantifier in SPred.\n\nExistential quantifier in SPred.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Stateful Predicates","header":"18.2.1.3. Connectives and Quantifiers","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Connectives-and-Quantifiers"},"/The-Type-System/Inductive-Types/#recursors":{"contents":"Every inductive type is equipped with a recursor.\nThe recursor is completely determined by the signatures of the type constructor and the constructors.\nRecursors have function types, but they are primitive and are not definable using fun.\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model","header":"4.4.3.1. Recursors","id":"/The-Type-System/Inductive-Types/#recursors"},"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Compiler___-runtime___-and-FFI":{"contents":"* #4685 fixes a typo in the C run_new_frontend signature* #4729 has IR checker suggest using noncomputable* #5143 adds a shared library for Lake* #5437 removes (syntactically) duplicate imports (@euprunin)* #5462 updates src/lake/lakefile.toml to the adjusted Lake build process* #5541 removes new shared libs before build to better support Windows* #5558 make lean.h compile with MSVC (@kant2002)* #5564 removes non-conforming size-0 arrays (@eric-wieser)\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.13.0 (2024-11-01)","header":"Compiler, runtime, and FFI","id":"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Compiler___-runtime___-and-FFI"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Pretty-Printing":{"contents":"* #10122 adds support for pretty printing using generalized field\nnotation (dot notation) for private definitions on public types. It also\nmodifies dot notation elaboration to resolve names after removing the\nprivate prefix, which enables using dot notation for private definitions\non private imported types.* #10373 adds a pp.unicode option and a unicode(\"→\", \"->\") syntax\ndescription alias for the lower-level unicodeSymbol \"→\" \"->\" parser.\nThe syntax is added to the notation command as well. When pp.unicode\nis true (the default) then the first form is used when pretty printing,\nand otherwise the second ASCII form is used. A variant, unicode(\"→\", \"->\", preserveForPP) causes the -> form to be preferred; delaborators\ncan insert → directly into the syntax, which will be pretty printed\nas-is; this allows notations like fun to use custom options such as\npp.unicode.fun to opt into the unicode form when pretty printing.* #10374 adds the options pp.piBinderNames and\npp.piBinderNames.hygienic. Enabling pp.piBinderNames causes\nnon-dependent pi binder names to be pretty printed, rather than be\nomitted. When pp.piBinderNames.hygienic is false (the default) then\nonly non-hygienic such biner names are pretty printed. Setting pp.all\nenables pp.piBinderNames if it is not otherwise explicitly set.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Pretty Printing","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Pretty-Printing"}});