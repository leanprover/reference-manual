window.docContents[60].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Properties":{"contents":"Returns the number of mappings present in the map.\n\nReturns true if the tree map contains no mappings.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps","header":"20.19.8.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Properties"},"/Error-Explanations/About___--unknownIdentifier/#The-Lean-Language-Reference--Error-Explanations--About___--unknownIdentifier--Examples":{"contents":"Variable Not in Scopeexample (s : IO.FS.Stream) := do\n  IO.withStdout s do\n    let text := \"Hello\"\n    IO.println text\n  IO.println s!\"Wrote '{text}' to stream\"\nUnknown identifier `text`\nexample (s : IO.FS.Stream) := do\n  let text := \"Hello\"\n  IO.withStdout s do\n    IO.println text\n  IO.println s!\"Wrote '{text}' to stream\"\nAn unknown identifier error occurs on the last line of this example because the variable text is\nnot in scope. The let-binding on the third line is scoped to the\ninner do block and cannot be\naccessed in the outer do block. Moving this binding to the outer\ndo block—from which it remains\nin scope in the inner block as well—resolves the issue.\n\nMissing Namespaceinductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\ndef red : Color :=\n  rgb 255 0 0\nUnknown identifier `rgb`\ninductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\ndef red : Color :=\n  Color.rgb 255 0 0\ninductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\nopen Color in\ndef red : Color :=\n  rgb 255 0 0\nIn this example, the identifier rgb on the last line does not resolve to the Color constructor\nof that name. This is because the constructor's name is actually Color.rgb: all constructors of an\ninductive type have names in that type's namespace. Because the Color namespace is not open, the\nidentifier rgb cannot be used without its namespace prefix.One way to resolve this error is to provide the fully qualified constructor name Color.rgb; the\ndotted-identifier notation .rgb can also be used, since the expected type of .rgb 255 0 0 is\nColor. Alternatively, one can open the Color namespace and continue to omit the Color prefix\nfrom the identifier.\n\nProtected Constant Name Without Namespace Prefixprotected def A.x := ()\n\nopen A\n\nexample := x\nUnknown identifier `x`\nprotected def A.x := ()\n\nopen A\n\nexample := A.x\nprotected def A.x := ()\n\nopen A (x)\n\nexample := x\nIn this example, because the constant A.x is protected, it cannot be referred to by the suffix\nx even with the namespace A open. Therefore, the identifier x fails to resolve. Instead, to\nrefer to a protected constant, it is necessary to include at least its innermost namespace—in this\ncase, A. Alternatively, the restricted opening syntax—demonstrated in the second corrected\nexample—allows a protected constant to be referred to by its unqualified name, without opening the\nremainder of the namespace in which it occurs (see the manual section on\nNamespaces and Sections for details).\n\nUnresolvable Name Inferred by Dotted-Identifier Notationdef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  .toNat (b₁ || b₂)\nUnknown constant `Nat.toNat`\n\nNote: Inferred this name from the expected resulting type of `.toNat`:\n  Nat\ndef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  (b₁ || b₂).toNat\ndef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  Bool.toNat (b₁ || b₂)\nIn this example, the dotted-identifier notation .toNat causes Lean to infer an unresolvable\nname (Nat.toNat). The namespace used by dotted-identifier notation is always inferred from\nthe expected type of the expression in which it occurs, which—due to the type annotation on\ndisjoinToNat—is Nat in this example. To use the namespace of an argument's type—as the author of\nthis code seemingly intended—use generalized field notation as shown in the first corrected\nexample. Alternatively, the correct namespace can be explicitly specified by writing the fully\nqualified function name.\n\nAuto-bound variablesset_option relaxedAutoImplicit false in\ndef thisBreaks (x : α₁) (y : size₁) := ()\n\nset_option autoImplicit false in\ndef thisAlsoBreaks (x : α₂) (y : size₂) := ()\nUnknown identifier `size₁`\n\nNote: It is not possible to treat `size₁` as an implicitly bound variable here because it has multiple characters while the `relaxedAutoImplicit` option is set to `false`.\nset_option relaxedAutoImplicit true in\ndef thisWorks (x : α₁) (y : size₁) := ()\n\nset_option autoImplicit true in\ndef thisAlsoWorks (x : α₂) (y : size₂) := ()\nset_option relaxedAutoImplicit false in\ndef thisWorks {size₁} (x : α₁) (y : size₁) := ()\n\nset_option autoImplicit false in\ndef thisAlsoWorks {α₂ size₂} (x : α₂) (y : size₂) := ()\nLean's default behavior, when it encounters an identifier it can't identify in the type of a\ndefinition, is to add automatic implicit parameters\nfor those unknown identifiers. However, many files or projects disable this feature by setting the\nautoImplicit or relaxedAutoImplicit options to false.Without re-enabling the autoImplicit or relaxedAutoImplicit options, the easiest\nway to fix this error is to add the unknown identifiers as\nordinary implicit parameters as shown in the example above.\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  unknownIdentifier","header":"Examples","id":"/Error-Explanations/About___--unknownIdentifier/#The-Lean-Language-Reference--Error-Explanations--About___--unknownIdentifier--Examples"},"/The-Simplifier/Simp-sets/#simp-sets":{"contents":"A collection of rules used by the simplifier is called a simp set.\nA simp set is specified in terms of modifications from a default simp set.\nThese modifications can include adding rules, removing rules, or adding a set of rules.\nThe only modifier to the simp tactic causes it to start with an empty simp set, rather than the default one.\nRules are added to the default simp set using the simp attribute.\n\nRegistering simp LemmasThe simp attribute adds a declaration to the default simp set.\nIf the declaration is a definition, the definition is marked for unfolding; if it is a theorem, then the theorem is registered as a rewrite rule.\n\nCustom simp sets are created with registerSimpAttr, which must be run during initialization by placing it in an initialize block.\nAs a side effect, it creates a new attribute with the same interface as simp that adds rules to the custom simp set.\nThe returned value is a SimpExtension, which can be used to programmatically access the contents of the custom simp set.\nThe simp tactics can be instructed to use the new simp set by including its attribute name in the rule list.\n\nRegisters the given name as a custom simp set. Applying the name as an attribute to a name adds it\nto the simp set, and using the name as a parameter to the simp tactic causes simp to use the\nincluded lemmas.Custom simp sets must be registered during initialization.The description should be a short, singular noun phrase that describes the contents of the custom\nsimp set.\n\nThe environment extension that contains a simp set, returned by Lean.Meta.registerSimpAttr.Use the simp set's attribute or Lean.Meta.addSimpTheorem to add theorems to the simp set. Use\nLean.Meta.SimpExtension.getTheorems to get the contents.\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.3. Simp sets","id":"/The-Simplifier/Simp-sets/#simp-sets"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Pretty-printing":{"contents":"* #4976 introduces @[app_delab], a macro for creating delaborators for particular constants. The @[app_delab ident] syntax resolves ident to its constant name name and then expands to @[delab app.name].* #4982 fixes a bug where the pretty printer assumed structure projections were type correct (such terms can appear in type mismatch errors). Improves hoverability of #print output for structures.* #5218 and #5239 add pp.exprSizes debugging option. When true, each pretty printed expression is prefixed with [size a/b/c], where a is the size without sharing, b is the actual size, and c is the size with the maximum possible sharing.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Pretty printing","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Pretty-printing"}});