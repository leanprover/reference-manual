window.docContents[230].resolve({"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Iteration":{"contents":"A left fold on ByteArray that iterates over an array from low to high indices, computing a\nrunning value.Each element of the array is combined with the value from the prior elements using a function\nf. The initial value init is the starting value before any elements have been\nprocessed.ByteArray.foldlM is a monadic variant of this function.\n\nA monadic left fold on ByteArray that iterates over an array from low to high indices,\ncomputing a running value.Each element of the array is combined with the value from the prior elements using a monadic\nfunction f. The initial value init is the starting value before any elements have\nbeen processed.\n\nThe reference implementation of ForIn.forIn for ByteArray.In compiled code, this is replaced by the more efficient ByteArray.forInUnsafe.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"20.17.1.6. Iteration","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Iteration"},"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Properties":{"contents":"Floating-point numbers fall into one of three categories:\n\n* Finite numbers are ordinary floating-point values.* Infinities, which may be positive or negative, result from division by zero.* NaNs, which are not numbers, result from other undefined operations, such as the square root of a negative number.\n\nChecks whether a floating-point number is a positive or negative infinite number, but not a finite\nnumber or NaN.This function does not reduce in the kernel. It is compiled to the C operator isinf.\n\nChecks whether a floating-point number is a positive or negative infinite number, but not a finite\nnumber or NaN.This function does not reduce in the kernel. It is compiled to the C operator isinf.\n\nChecks whether a floating point number is NaN (“not a number”) value.NaN values result from operations that might otherwise be errors, such as dividing zero by zero.This function does not reduce in the kernel. It is compiled to the C operator isnan.\n\nChecks whether a floating point number is NaN (\"not a number\") value.NaN values result from operations that might otherwise be errors, such as dividing zero by zero.This function does not reduce in the kernel. It is compiled to the C operator isnan.\n\nChecks whether a floating-point number is finite, that is, whether it is normal, subnormal, or zero,\nbut not infinite or NaN.This function does not reduce in the kernel. It is compiled to the C operator isfinite.\n\nChecks whether a floating-point number is finite, that is, whether it is normal, subnormal, or zero,\nbut not infinite or NaN.This function does not reduce in the kernel. It is compiled to the C operator isfinite.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"20.6.2.1. Properties","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Properties"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Adjustment":{"contents":"Returns the previous valid position before the given position, given a proof that the position\nis not the start position, which guarantees that such a position exists.\n\nReturns the previous valid position before the given position, or panics if the position is\nthe start position.\n\nReturns the previous valid position before the given position, or none if the position is\nthe start position.\n\nAdvances a valid position on a string to the next valid position, given a proof that the\nposition is not the past-the-end position, which guarantees that such a position exists.\n\nAdvances a valid position on a string to the next valid position, or panics if the given\nposition is the past-the-end position.\n\nAdvances a valid position on a string to the next valid position, or returns none if the\ngiven position is the past-the-end position.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Positions","header":"20.8.4.4.4. Adjustment","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Adjustment"},"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--Integrating--grind-___s-Features":{"contents":"This example demonstrates how the various submodules of grind are seamlessly integrated.\nIn particular we can:* instantiate theorems from the library, using custom patterns,* perform case splitting,* do linear integer arithmetic reasoning, including modularity conditions, and* do Gröbner basis reasoning\nall without providing explicit instructions to drive the interactions between these modes of reasoning.\n\nFor this example we'll begin with a “mocked up” version of the real numbers, and the sin and cos functions.\nOf course, this example works without any changes using Mathlib's versions of these!\n\n\n\naxiom R : Type\n\n\n@[instance] axiom instCommRingR : Lean.Grind.CommRing R\n\n\naxiom sin : R → R\naxiom cos : R → R\naxiom trig_identity : ∀ x, (cos x)^2 + (sin x)^2 = 1\n\n\nOur first step is to tell grind to “put the trig identity on the whiteboard” whenever it sees a goal involving sin or cos:grind_pattern trig_identity => cos x\ngrind_pattern trig_identity => sin x\nNote here we use two different patterns for the same theorem, so the theorem is instantiated even if grind sees just one of these functions.\nIf we preferred to more conservatively instantiate the theorem only when both sin and cos are present, we could have used a multi-pattern:grind_pattern trig_identity => cos x, sin x\nFor this example, either approach will work.\n\nBecause grind immediately notices the trig identity, we can prove goals like this:example : (cos x + sin x)^2 = 2 * cos x * sin x + 1 := by\n  grind\nHere grind does the following:1. It notices cos x and sin x, so instantiates the trig identity.2. It notices that this is a polynomial in CommRing R, and sends it to the Gröbner basis module.\n   No calculation happens at this point: it's the first polynomial relation in this ring, so the Gröbner basis is updated to [(cos x)^2 + (sin x)^2 - 1].3. It notices that the left and right hand sides of the goal are polynomials in CommRing R, and sends them to the Gröbner basis module for normalization.Since their normal forms modulo (cos x)^2 + (sin x)^2 = 1 are equal, their equivalence classes are merged, and the goal is solved.We can also do this sort of argument when congruence closure is needed:example (f : R → Nat) :\n    f ((cos x + sin x)^2) = f (2 * cos x * sin x + 1) := by\n  grind\nAs before, grind instantiates the trig identity, notices that (cos x + sin x)^2 and 2 * cos x * sin x + 1 are equal modulo (cos x)^2 + (sin x)^2 = 1,\nputs those algebraic expressions in the same equivalence class, and then puts the function applications f ((cos x + sin x)^2) and f (2 * cos x * sin x + 1) in the same equivalence class,\nand closes the goal.Notice that we've used an arbitrary function f : R → Nat here; let's check that grind can use some linear integer arithmetic reasoning after the Gröbner basis steps:example (f : R → Nat) :\n    4 * f ((cos x + sin x)^2) ≠ 2 + f (2 * cos x * sin x + 1) := by\n  grind\nHere grind first works out that this goal reduces to 4 * n ≠ 2 + n for some n : Nat (i.e. by identifying the two function applications as described above), and then uses modularity to derive a contradiction.Finally, we can also mix in some case splitting:example (f : R → Nat) :\n    max 3 (4 * f ((cos x + sin x)^2)) ≠\n      2 + f (2 * cos x * sin x + 1) := by\n  grind\nAs before, grind first does the instantiation and Gröbner basis calculations required to identify the two function applications.\nHowever the cutsat algorithm by itself can't do anything with max 3 (4 * n) ≠ 2 + n.\nNext, after instantiating Nat.max_def (automatically, because of an annotation in the standard library) which states ∀ {n m : Nat}, max n m = if n ≤ m then m else n, grind can then case split on the inequality.\nIn the branch 3 ≤ 4 * n, cutsat again uses modularity to prove 4 * n ≠ 2 + n.\nIn the branch 4 * n < 3, cutsat quickly determines n = 0, and then notices that 4 * 0 ≠ 2 + 0.This has been, of course, a quite artificial example!\nIn practice, this sort of automatic integration of different reasoning modes is very powerful: the central “whiteboard” which tracks instantiated theorems and equivalence classes can hand off relevant terms and equalities to the appropriate modules (here, cutsat and Gröbner bases), which can then return new facts to the whiteboard.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples","header":"17.10.1. Integrating  grind 's Features","id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--Integrating--grind-___s-Features"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Assertions":{"contents":"The language of assertions about monadic programs is parameterized by a postcondition shape, which describes the inputs to and outputs from a computation in a given monad.\nPreconditions may mention the initial values of the monad's state, while postconditions may mention the returned value, the final values of the monad's state, and must furthermore account for any exceptions that could have been thrown.\nThe postcondition shape of a given monad determines the states and exceptions in the monad.\nPostShape.pure describes a monad in which assertions may not mention any states, PostShape.arg describes a state value, and PostShape.except describes a possible exception.\nBecause these constructors can be continually added, the postcondition shape of a monad transformer can be defined in terms of the postcondition shape of the underlying transformed monad.\nBehind the scenes, an Assertion is translated into an appropriate SPred by translating the postcondition shape into a list of state types, discarding exceptions.\n\nThe “shape” of the postconditions that are used to reason about a monad.A postcondition shape is an abstraction of many possible monadic effects, based on the structure of pure functions that can simulate them. The postcondition shape of a monad is given by its WP instance. This shape is used to determine both its Assertions and its PostConds.The assertions and postconditions in this monad use neither state nor exceptions.The assertions in this monad may mention the current value of a state of type σ, and\npostconditions may mention the state's final value.The postconditions in this monad include assertions about exceptional values of type ε that\nresult from premature termination.\n\nExtracts the list of state types under PostShape.arg constructors, discarding exception types.The state types determine the shape of assertions in the monad.\n\nAn assertion about the state fields for a monad whose postcondition shape is ps.Concretely, this is an abbreviation for SPred applied to the .args in the given predicate shape, so all theorems about SPred apply.Examples:example : Assertion (.arg ρ .pure) = (ρ → ULift Prop) := rfl\nexample : Assertion (.except ε .pure) = ULift Prop := rfl\nexample : Assertion (.arg σ (.except ε .pure)) = (σ → ULift Prop) := rfl\nexample : Assertion (.except ε (.arg σ .pure)) = (σ → ULift Prop) := rfl\n\n\nA postcondition for the given predicate shape, with one Assertion for the terminating case and\none Assertion for each .except layer in the predicate shape.variable (α σ ε : Type)\nexample : PostCond α (.arg σ .pure) = ((α → σ → ULift Prop) × PUnit) := rfl\nexample : PostCond α (.except ε .pure) = ((α → ULift Prop) × (ε → ULift Prop) × PUnit) := rfl\nexample : PostCond α (.arg σ (.except ε .pure)) = ((α → σ → ULift Prop) × (ε → ULift Prop) × PUnit) := rfl\nexample : PostCond α (.except ε (.arg σ .pure)) = ((α → σ → ULift Prop) × (ε → σ → ULift Prop) × PUnit) := rfl\n\n\nPostconditionsSyntactic sugar for a nested sequence of product constructors, terminating in (), in which the first element is an assertion about non-exceptional return values and the remaining elements are assertions about the exceptional cases for a postcondition.\n\nAn assertion about each potential exception that's declared in a postcondition shape.Examples:example : ExceptConds (.pure) = Unit := rfl\nexample : ExceptConds (.except ε .pure) = ((ε → ULift Prop) × Unit) := rfl\nexample : ExceptConds (.arg σ (.except ε .pure)) = ((ε → ULift Prop) × Unit) := rfl\nexample : ExceptConds (.except ε (.arg σ .pure)) = ((ε → σ → ULift Prop) × Unit) := rfl\n\n\nPostconditions for programs that might throw exceptions come in two varieties. The total correctness interpretation ⦃P⦄ prog ⦃⇓ r => Q' r⦄ asserts that, given P holds, then prog terminates and Q' holds for the result. The partial correctness interpretation ⦃P⦄ prog ⦃⇓? r => Q' r⦄ asserts that, given P holds, and if prog terminates then Q' holds for the result.\n\nException-Free PostconditionsA postcondition expressing total correctness.\nThat is, it expresses that the asserted computation finishes without throwing an exception\nand the result satisfies the given predicate p.\n\nA postcondition expressing total correctness.\nThat is, it expresses that the asserted computation finishes without throwing an exception\nand the result satisfies the given predicate p.\n\nPartial PostconditionsA postcondition expressing partial correctness.\nThat is, it expresses that if the asserted computation finishes without throwing an exception\nthen the result satisfies the given predicate p.\nNothing is asserted when the computation throws an exception.\n\nA postcondition expressing partial correctness.\nThat is, it expresses that if the asserted computation finishes without throwing an exception\nthen the result satisfies the given predicate p.\nNothing is asserted when the computation throws an exception.\n\nPostcondition EntailmentSyntactic sugar for PostCond.entails\n\nEntailment of postconditions.This consists of:* Entailment of the assertion about the return value, for all possible return values.* Entailment of the exception conditions.While implication of postconditions (PostCond.imp) results in a new postcondition, entailment is\nan ordinary proposition.\n\nPostcondition ConjunctionSyntactic sugar for PostCond.and\n\nConjunction of postconditions.This is defined pointwise, as the conjunction of the assertions about the return value and the\nconjunctions of the assertions about each potential exception.\n\nPostcondition ImplicationSyntactic sugar for PostCond.imp\n\nImplication of postconditions.This is defined pointwise, as the implication of the assertions about the return value and the\nimplications of each of the assertions about each potential exception.While entailment of postconditions (PostCond.entails) is an ordinary proposition, implication of\npostconditions is itself a postcondition.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers","header":"18.2.2. Assertions","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Assertions"},"/The-Type-System/Inductive-Types/#iota-reduction":{"contents":"In addition to adding new constants to the logic, inductive type declarations also add new reduction rules.\nThese rules govern the interaction between recursors and constructors; specifically recursors that have constructors as their major premise.\nThis form of reduction is called ι-reduction (iota reduction).\n\nWhen the recursor's major premise is a constructor with no recursive parameters, the recursor application reduces to an application of the constructor's minor premise to the constructor's arguments.\nIf there are recursive parameters, then these arguments to the minor premise are found by applying the recursor to the recursive occurrence.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Recursors","header":"4.4.3.1.2. Reduction","id":"/The-Type-System/Inductive-Types/#iota-reduction"}});