window.docContents[180].resolve({"/Basic-Propositions/Propositional-Equality/#UIP":{"contents":"Because of definitional proof irrelevance, propositional equality proofs are unique: two mathematical objects cannot be equal in different ways.theorem Eq.unique {α : Sort u}\n    (x y : α)\n    (p1 p2 : x = y) :\n    p1 = p2 := by\n  rfl\nStreicher's axiom K is also a consequence of definitional proof irrelevance, as is its computation rule.\nAxiom K is a principle that's logically equivalent to Eq.unique, implemented as an alternative recursor for propositional equality.def K {α : Sort u}\n    {motive : {x : α} → x = x → Sort v}\n    (d : {x : α} → motive (Eq.refl x))\n    (x : α) (z : x = x) :\n    motive z :=\n  d\n\nexample {α : Sort u} {a : α}\n    {motive : {x : α} → x = x → Sort u}\n    {d : {x : α} → motive (Eq.refl x)}\n    {v : motive (Eq.refl a)} :\n    K (motive := motive) d a rfl = d := by\n  rfl\n\n\n","context":"Lean Reference\u0009Basic Propositions\u0009Propositional Equality","header":"19.4.1. Uniqueness of Equality Proofs","id":"/Basic-Propositions/Propositional-Equality/#UIP"},"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Construction":{"contents":"The greatest value of Fin (n+1), namely n.Examples:* Fin.last 4 = (4 : Fin 5)* (Fin.last 0).val = (0 : Nat)\n\nThe successor, with an increased bound.This differs from adding 1, which instead wraps around.Examples:* (2 : Fin 3).succ = (3 : Fin 4)* (2 : Fin 3) + 1 = (0 : Fin 3)\n\nThe predecessor of a non-zero element of Fin (n+1), with the bound decreased.Examples:* (4 : Fin 8).pred (by decide) = (3 : Fin 7)* (1 : Fin 2).pred (by decide) = (0 : Fin 1)\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"20.3.3.1. Construction","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Construction"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Iteration":{"contents":"Returns a finite iterator over the elements of a hash set.\nThe iterator yields the elements of the set in order and then terminates.Termination properties:* Finite instance: always* Productive instance: always\n\nCheck if all elements satisfy the predicate, short-circuiting if a predicate fails.\n\nCheck if any element satisfies the predicate, short-circuiting if a predicate succeeds.\n\nFolds the given function over the elements of the hash set in some order.\n\nMonadically computes a value by folding the given function over the elements in the hash set in some\norder.\n\nSupport for the for loop construct in do blocks.\n\nCarries out a monadic action on each element in the hash set in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"20.19.6.5. Iteration","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Iteration"},"/Basic-Types/Ranges/#ranges":{"contents":"A range represents a series of consecutive elements of some type, from a lower bound to an upper bound.\nThe bounds may be open, in which case the bound value is not part of the range, or closed, in which case the bound value is part of the range.\nEither bound may be omitted, in which case the range extends infinitely in the corresponding direction.\n\nRanges have dedicated syntax that consists of a starting point, ..., and an ending point.\nThe starting point may be either *, which denotes a range that continues infinitely downwards, or a term, which denotes a range with a specific starting value.\nBy default, ranges are left-closed: they contain their starting points.\nA trailing < indicates that the range is left-open and does not contain its starting point.\nThe ending point may be *, in which case the range continues infinitely upwards, or a term, which denotes a range with a specific ending value.\nBy default, ranges are right-open: they do not contain their ending points.\nThe ending point may be prefixed with < to indicate that it is right-open; this is the default and does not change the meaning, but may be easier to read.\nIt may also be prefixed with = to indicate that the range is right-closed and contains its ending point.\n\nRanges of Natural NumbersThe range that contains the numbers 3 through 6 can be written in a variety of ways:#eval (3...7).toList\n[3, 4, 5, 6]\n#eval (3...=6).toList\n[3, 4, 5, 6]\n#eval (2<...=6).toList\n[3, 4, 5, 6]\n\n\nFinite and Infinite RangesThis range cannot be converted to a list, because it is infinite:#eval (3...*).toList\nFiniteness of a left-closed, right-unbounded range is indicated by the presence of an instance of Std.Rxi.IsAlwaysFinite, which does not exist for Nat.\nStd.Rco is the type of these ranges, and the name Std.Rxi.IsAlwaysFinite indicates that it determines finiteness for all right-unbounded ranges.failed to synthesize instance of type class\n  Std.Rxi.IsAlwaysFinite Nat\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\nAttempting to enumerate the negative integers leads to a similar error, this time because there is no way to determine the least element:#eval (*...(0 : Int)).toList\nfailed to synthesize instance of type class\n  Std.PRange.Least? Int\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\nUnbounded ranges in finite types indicate that the range extends to the greatest element of the type.\nBecause UInt8 has 256 elements, this range contains 253 elements:#eval ((3 : UInt8)...*).toArray.size\n253\n\n\nRange SyntaxThis range is left-closed, right-open, and indicates Std.Rco:This range is left-closed, right-open, and indicates Std.Rco:This range is left-closed, right-closed, and indicates Std.Rcc:This range is left-closed, right-infinite, and indicates Std.Rci:This range is left-open, right-open, and indicates Std.Roo:This range is left-open, right-open, and indicates Std.Roo:This range is left-open, right-closed, and indicates Std.Roc:This range is left-open, right-infinite, and indicates Std.Roi:This range is left-infinite, right-open, and indicates Std.Rio:This range is left-infinite, right-open, and indicates Std.Ric:This range is left-infinite, right-closed, and indicates Std.Ric:This range is infinite on both sides, and indicates Std.Rii:\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.18. Ranges","id":"/Basic-Types/Ranges/#ranges"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Lookups":{"contents":"Returns the character at the position pos of a string, taking a proof that p is not the\npast-the-end position.This function is overridden with an efficient implementation in runtime code.Examples:* (\"abc\".pos ⟨1⟩ (by decide)).get (by decide) = 'b'* (\"L∃∀N\".pos ⟨1⟩ (by decide)).get (by decide) = '∃'\n\nReturns the character at the position pos of a string, or panics if the position is the\npast-the-end position.This function is overridden with an efficient implementation in runtime code.\n\nReturns the character at the position pos of a string, or none if the position is the\npast-the-end position.This function is overridden with an efficient implementation in runtime code.\n\nReplaces the character at a specified position in a string with a new character.If both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.Examples:* (\"abc\".pos ⟨1⟩ (by decide)).set 'B' (by decide) = \"aBc\"* (\"L∃∀N\".pos ⟨4⟩ (by decide)).set 'X' (by decide) = \"L∃XN\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Positions","header":"20.8.4.4.2. Lookups","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Lookups"}});