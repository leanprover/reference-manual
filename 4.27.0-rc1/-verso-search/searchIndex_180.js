window.docContents[180].resolve({"/Basic-Propositions/Propositional-Equality/#UIP":{"contents":"Because of definitional proof irrelevance, propositional equality proofs are unique: two mathematical objects cannot be equal in different ways.theorem Eq.unique {α : Sort u}\n    (x y : α)\n    (p1 p2 : x = y) :\n    p1 = p2 := by\n  rfl\nStreicher's axiom K is also a consequence of definitional proof irrelevance, as is its computation rule.\nAxiom K is a principle that's logically equivalent to Eq.unique, implemented as an alternative recursor for propositional equality.def K {α : Sort u}\n    {motive : {x : α} → x = x → Sort v}\n    (d : {x : α} → motive (Eq.refl x))\n    (x : α) (z : x = x) :\n    motive z :=\n  d\n\nexample {α : Sort u} {a : α}\n    {motive : {x : α} → x = x → Sort u}\n    {d : {x : α} → motive (Eq.refl x)}\n    {v : motive (Eq.refl a)} :\n    K (motive := motive) d a rfl = d := by\n  rfl\n\n\n","context":"Lean Reference\u0009Basic Propositions\u0009Propositional Equality","header":"19.4.1. Uniqueness of Equality Proofs","id":"/Basic-Propositions/Propositional-Equality/#UIP"},"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Construction":{"contents":"The greatest value of Fin (n+1), namely n.Examples:* Fin.last 4 = (4 : Fin 5)* (Fin.last 0).val = (0 : Nat)\n\nThe successor, with an increased bound.This differs from adding 1, which instead wraps around.Examples:* (2 : Fin 3).succ = (3 : Fin 4)* (2 : Fin 3) + 1 = (0 : Fin 3)\n\nThe predecessor of a non-zero element of Fin (n+1), with the bound decreased.Examples:* (4 : Fin 8).pred (by decide) = (3 : Fin 7)* (1 : Fin 2).pred (by decide) = (0 : Fin 1)\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"20.3.3.1. Construction","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Construction"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Iteration":{"contents":"Returns a finite iterator over the elements of a hash set.\nThe iterator yields the elements of the set in order and then terminates.Termination properties:* Finite instance: always* Productive instance: always\n\nCheck if all elements satisfy the predicate, short-circuiting if a predicate fails.\n\nCheck if any element satisfies the predicate, short-circuiting if a predicate succeeds.\n\nFolds the given function over the elements of the hash set in some order.\n\nMonadically computes a value by folding the given function over the elements in the hash set in some\norder.\n\nSupport for the for loop construct in do blocks.\n\nCarries out a monadic action on each element in the hash set in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"20.19.6.5. Iteration","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Iteration"},"/Basic-Types/Ranges/#ranges":{"contents":"A range represents a series of consecutive elements of some type, from a lower bound to an upper bound.\nThe bounds may be open, in which case the bound value is not part of the range, or closed, in which case the bound value is part of the range.\nEither bound may be omitted, in which case the range extends infinitely in the corresponding direction.\n\nRanges have dedicated syntax that consists of a starting point, ..., and an ending point.\nThe starting point may be either *, which denotes a range that continues infinitely downwards, or a term, which denotes a range with a specific starting value.\nBy default, ranges are left-closed: they contain their starting points.\nA trailing < indicates that the range is left-open and does not contain its starting point.\nThe ending point may be *, in which case the range continues infinitely upwards, or a term, which denotes a range with a specific ending value.\nBy default, ranges are right-open: they do not contain their ending points.\nThe ending point may be prefixed with < to indicate that it is right-open; this is the default and does not change the meaning, but may be easier to read.\nIt may also be prefixed with = to indicate that the range is right-closed and contains its ending point.\n\nRanges of Natural NumbersThe range that contains the numbers 3 through 6 can be written in a variety of ways:#eval (3...7).toList\n[3, 4, 5, 6]\n#eval (3...=6).toList\n[3, 4, 5, 6]\n#eval (2<...=6).toList\n[3, 4, 5, 6]\n\n\nFinite and Infinite RangesThis range cannot be converted to a list, because it is infinite:#eval (3...*).toList\nFiniteness of a left-closed, right-unbounded range is indicated by the presence of an instance of Std.Rxi.IsAlwaysFinite, which does not exist for Nat.\nStd.Rco is the type of these ranges, and the name Std.Rxi.IsAlwaysFinite indicates that it determines finiteness for all right-unbounded ranges.failed to synthesize instance of type class\n  Std.Rxi.IsAlwaysFinite Nat\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\nAttempting to enumerate the negative integers leads to a similar error, this time because there is no way to determine the least element:#eval (*...(0 : Int)).toList\nfailed to synthesize instance of type class\n  Std.PRange.Least? Int\n\nHint: Type class instance resolution failures can be inspected with the `set_option trace.Meta.synthInstance true` command.\nUnbounded ranges in finite types indicate that the range extends to the greatest element of the type.\nBecause UInt8 has 256 elements, this range contains 253 elements:#eval ((3 : UInt8)...*).toArray.size\n253\n\n\nRange SyntaxThis range is left-closed, right-open, and indicates Std.Rco:This range is left-closed, right-open, and indicates Std.Rco:This range is left-closed, right-closed, and indicates Std.Rcc:This range is left-closed, right-infinite, and indicates Std.Rci:This range is left-open, right-open, and indicates Std.Roo:This range is left-open, right-open, and indicates Std.Roo:This range is left-open, right-closed, and indicates Std.Roc:This range is left-open, right-infinite, and indicates Std.Roi:This range is left-infinite, right-open, and indicates Std.Rio:This range is left-infinite, right-open, and indicates Std.Ric:This range is left-infinite, right-closed, and indicates Std.Ric:This range is infinite on both sides, and indicates Std.Rii:\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.18. Ranges","id":"/Basic-Types/Ranges/#ranges"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Lookups":{"contents":"Returns the character at the position pos of a string, taking a proof that p is not the\npast-the-end position.This function is overridden with an efficient implementation in runtime code.Examples:* (\"abc\".pos ⟨1⟩ (by decide)).get (by decide) = 'b'* (\"L∃∀N\".pos ⟨1⟩ (by decide)).get (by decide) = '∃'\n\nReturns the character at the position pos of a string, or panics if the position is the\npast-the-end position.This function is overridden with an efficient implementation in runtime code.\n\nReturns the character at the position pos of a string, or none if the position is the\npast-the-end position.This function is overridden with an efficient implementation in runtime code.\n\nReplaces the character at a specified position in a string with a new character.If both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.Examples:* (\"abc\".pos ⟨1⟩ (by decide)).set 'B' (by decide) = \"aBc\"* (\"L∃∀N\".pos ⟨4⟩ (by decide)).set 'X' (by decide) = \"L∃XN\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Positions","header":"20.8.4.4.2. Lookups","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Lookups"},"/Error-Explanations/About___--inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--About___--inferBinderTypeFailed--Examples":{"contents":"Binder Type Requires New Type Variabledef identity x :=\n  x\nFailed to infer type of binder `x`\ndef identity (x : α) :=\n  x\nIn the code above, the type of x is unconstrained; as this example demonstrates, Lean does not\nautomatically generate fresh type variables for such binders. Instead, the type α of x must be\nspecified explicitly. Note that if automatic implicit parameter insertion is enabled (as it is by\ndefault), a binder for α itself need not be provided; Lean will insert an implicit binder for this\nparameter automatically.\n\nUninferred Binder Type Due to Resulting Type Annotationdef plusTwo x : Nat :=\n  x + 2\nFailed to infer type of binder `x`\n\nNote: Because this declaration's type has been explicitly provided, all parameter types and holes (e.g., `_`) in its header are resolved before its body is processed; information from the declaration body cannot be used to infer what these values should be\ndef plusTwo (x : Nat) : Nat :=\n  x + 2\nEven though x is inferred to have type Nat in the body of plusTwo, this information is not\navailable when elaborating the type of the definition because its resulting type (Nat) has been\nexplicitly specified. Considering only the information in the header, the type of x cannot be\ndetermined, resulting in the shown error. It is therefore necessary to include the type of x in\nits binder.\n\nAttempting to Name an Example Declarationexample trivial_proof : True :=\n  trivial\nFailed to infer type of binder `trivial_proof`\n\nNote: Because this declaration's type has been explicitly provided, all parameter types and holes (e.g., `_`) in its header are resolved before its body is processed; information from the declaration body cannot be used to infer what these values should be\nexample : True :=\n  trivial\nThis code is invalid because it attempts to give a name to an example declaration. Examples cannot\nbe named, and an identifier written where a name would appear in other declaration forms is instead\nelaborated as a binder, whose type cannot be inferred. If a declaration must be named, it should be\ndefined using a declaration form that supports naming, such as def or theorem.\n\nAttempting to Define Multiple Opaque Constants at Onceopaque m n : Nat\nFailed to infer type of binder `n`\n\nNote: Multiple constants cannot be declared in a single declaration. The identifier(s) `n` are being interpreted as parameters `(n : _)`.\nopaque m : Nat\nopaque n : Nat\nThis example incorrectly attempts to define multiple constants with a single opaque declaration.\nSuch a declaration can define only one constant: it is not possible to list multiple identifiers\nafter opaque or def to define them all to have the same type (or value). Such a declaration is\ninstead elaborated as defining a single constant (e.g., m above) with parameters given by the\nsubsequent identifiers (n), whose types are unspecified and cannot be inferred. To define multiple\nglobal constants, it is necessary to declare each separately.\n\nAttempting to Define Multiple Structure Fields on the Same Linestructure Person where\n  givenName familyName : String\n  age : Nat\nFailed to infer type of binder `familyName`\nstructure Person where\n  givenName : String\n  familyName : String\n  age : Nat\nstructure Person where\n  (givenName familyName : String)\n  age : Nat\nThis example incorrectly attempts to define multiple structure fields (givenName and familyName)\nof the same type by listing them consecutively on the same line. Lean instead interprets this as\ndefining a single field, givenName, parametrized by a binder familyName with no specified type.\nThe intended behavior can be achieved by either listing each field on a separate line, or enclosing\nthe line specifying multiple field names in parentheses (see the manual section on\nInductive Types for further details about structure\ndeclarations).\n\n","context":"Lean Reference\u0009Error Explanations\u0009About:  inferBinderTypeFailed","header":"Examples","id":"/Error-Explanations/About___--inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--About___--inferBinderTypeFailed--Examples"},"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-Formal-Statement":{"contents":"To formalize the statement in Lean, we use an inductive type IfExpr:/--\nAn if-expression is either boolean literal, a\nnumbered variable, or an if-then-else expression\nwhere each subexpression is an if-expression.\n-/\ninductive IfExpr\n  | lit : Bool → IfExpr\n  | var : Nat → IfExpr\n  | ite : IfExpr → IfExpr → IfExpr → IfExpr\nderiving DecidableEq\n\n\nand define some inductive predicates and an eval function, so we can state the four desired properties:namespace IfExpr\n\n/--\nAn if-expression has a \"nested if\" if it contains\nan if-then-else where the \"if\" is itself an if-then-else.\n-/\ndef hasNestedIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (ite _ _ _) _ _ => true\n  | ite _ t e => t.hasNestedIf || e.hasNestedIf\n\n/--\nAn if-expression has a \"constant if\" if it contains\nan if-then-else where the \"if\" is itself a literal.\n-/\ndef hasConstantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (lit _) _ _ => true\n  | ite i t e =>\n    i.hasConstantIf || t.hasConstantIf || e.hasConstantIf\n\n/--\nAn if-expression has a \"redundant if\" if\nit contains an if-then-else where\nthe \"then\" and \"else\" clauses are identical.\n-/\ndef hasRedundantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite i t e => t == e || i.hasRedundantIf ||\n      t.hasRedundantIf || e.hasRedundantIf\n\n/--\nAll the variables appearing in an if-expressions,\nread left to right, without removing duplicates.\n-/\ndef vars : IfExpr → List Nat\n  | lit _ => []\n  | var i => [i]\n  | ite i t e => i.vars ++ t.vars ++ e.vars\n\n/--\nA helper function to specify that two lists are disjoint.\n-/\ndef _root_.List.disjoint {α} [DecidableEq α] :\n    List α → List α → Bool\n  | [], _ => true\n  | x::xs, ys => x ∉ ys && xs.disjoint ys\n\n/--\nAn if expression evaluates each variable at most once if\nfor each if-then-else the variables in the \"if\" clause\nare disjoint from the variables in the \"then\" clause\nand the variables in the \"if\" clause\nare disjoint from the variables in the \"else\" clause.\n-/\ndef disjoint : IfExpr → Bool\n  | lit _ => true\n  | var _ => true\n  | ite i t e =>\n      i.vars.disjoint t.vars && i.vars.disjoint e.vars &&\n        i.disjoint && t.disjoint && e.disjoint\n\n/--\nAn if expression is \"normalized\" if it has\nno nested, constant, or redundant ifs,\nand it evaluates each variable at most once.\n-/\ndef normalized (e : IfExpr) : Bool :=\n  !e.hasNestedIf && !e.hasConstantIf &&\n    !e.hasRedundantIf && e.disjoint\n\n/--\nThe evaluation of an if expression\nat some assignment of variables.\n-/\ndef eval (f : Nat → Bool) : IfExpr → Bool\n  | lit b => b\n  | var i => f i\n  | ite i t e => bif i.eval f then t.eval f else e.eval f\n\nend IfExpr\n\n\nUsing these we can state the problem. The challenge is to inhabit the following type (and to do so nicely!):\n\ndef IfNormalization : Type :=\n  { Z : IfExpr → IfExpr // ∀ e, (Z e).normalized ∧ (Z e).eval = e.eval }\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if - then - else  Normalization","header":"17.11.2.2. The Formal Statement","id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-Formal-Statement"}});