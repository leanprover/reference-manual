window.docContents[45].resolve({"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction":{"contents":"\n\nThis section gives a very brief glimpse into the mathematical constructions that underlie termination proofs via well-founded recursion, which may surface occasionally.\nThe elaboration of functions defined by well-founded recursion is based on the WellFounded.fix operator.\n\nA well-founded fixpoint. If satisfying the motive C for all values that are smaller according to a\nwell-founded relation allows it to be satisfied for the current value, then it is satisfied for all\nvalues.This function is used as part of the elaboration of well-founded recursion.\n\nThe type α is instantiated with the function's (varying) parameters, packed into one type using PSigma.\nThe WellFounded relation is constructed from the termination measure via invImage.\n\nThe inverse image of a well-founded relation is well-founded.\n\nThe function's body is passed to WellFounded.fix, with parameters suitably packed and unpacked, and recursive calls are replaced with a call to the value provided by WellFounded.fix.\nThe termination proofs generated by the decreasing_by tactics are inserted in the right place.\n\nFinally, the equational and unfolding theorems for the recursive function are proved from WellFounded.fix_eq.\nThese theorems hide the details of packing and unpacking arguments and describe the function's behavior in terms of the original definition.\n\nIn the case of mutual recursion, an equivalent non-mutual function is constructed by combining the function's arguments using PSum, and pattern-matching on that sum type in the result type and the body.\n\nThe definition of WellFounded builds on the notion of accessible elements of the relation:\n\nA relation r is WellFounded if all elements of α are accessible within r.\nIf a relation is WellFounded, it does not allow for an infinite descent along the relation.If the arguments of the recursive calls in a function definition decrease according to\na well founded relation, then the function terminates.\nWell-founded relations are sometimes called Artinian or said to satisfy the “descending chain condition”.If all elements are accessible via r, then r is well-founded.\n\nAcc is the accessibility predicate. Given some relation r (e.g. <) and a value x,\nAcc r x means that x is accessible through r:x is accessible if there exists no infinite sequence ... < y₂ < y₁ < y₀ < x.A value is accessible if for all y such that r y x, y is also accessible.\nNote that if there exists no y such that r y x, then x is accessible. Such an x is called a\nbase case.\n\nDivision by Iterated Subtraction: Termination ProofThe definition of division by iterated subtraction can be written explicitly using well-founded recursion.noncomputable def div (n k : Nat) : Nat :=\n  (inferInstanceAs (WellFoundedRelation Nat)).wf.fix\n    (fun n r =>\n      if h : k = 0 then 0\n      else if h : k > n then 0\n      else 1 + (r (n - k) <| by\n        show (n - k) < n\n        omega))\n    n\nThe definition must be marked noncomputable because well-founded recursion is not supported by the compiler.\nLike recursors, it is part of Lean's logic.The definition of division should satisfy the following equations:* ∀{n k : Nat}, (k = 0) → div n k = 0* ∀{n k : Nat}, (k > n) → div n k = 0* ∀{n k : Nat}, (k ≠ 0) → (¬ k > n) → div n k = div (n - k) kThis reduction behavior does not hold definitionally:theorem div.eq0 : div n 0 = 0 := by rfl\nTactic `rfl` failed: The left-hand side\n  div n 0\nis not definitionally equal to the right-hand side\n  0\n\nn : Nat\n⊢ div n 0 = 0\nHowever, using WellFounded.fix_eq to unfold the well-founded recursion, the three equations can be proved to hold:theorem div.eq0 : div n 0 = 0 := by\n  unfold div\n  apply WellFounded.fix_eq\n\ntheorem div.eq1 : k > n → div n k = 0 := by\n  intro h\n  unfold div\n  rw [WellFounded.fix_eq]\n  simp only [gt_iff_lt, dite_eq_ite, ite_eq_left_iff, Nat.not_lt]\n  intros; omega\n\ntheorem div.eq2 :\n    ¬ k = 0 → ¬ (k > n) →\n    div n k = 1 + div (n - k) k := by\n  intros\n  unfold div\n  rw [WellFounded.fix_eq]\n  simp_all only [\n    gt_iff_lt, Nat.not_lt,\n    dite_false, dite_eq_ite,\n    ite_false, ite_eq_right_iff\n  ]\n  omega\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","header":"7.6.3.7. Theory and Construction","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Paths":{"contents":"Paths are represented by strings.\nDifferent platforms have different conventions for paths: some use slashes (/) as directory separators, others use backslashes (\\).\nSome are case-sensitive, others are not.\nDifferent Unicode encodings and normal forms may be used to represent filenames, and some platforms consider filenames to be byte sequences rather than strings.\nA string that represents an absolute path on one system may not even be a valid path on another system.\n\nTo write Lean code that is as compatible as possible with multiple systems, it can be helpful to use Lean's path manipulation primitives instead of raw string manipulation.\nHelpers such as System.FilePath.join take platform-specific rules for absolute paths into account, System.FilePath.pathSeparator contains the appropriate path separator for the current platform, and System.FilePath.exeExtension contains any necessary extension for executable files.\nAvoid hard-coding these rules.\n\nThere is an instance of the Div type class for FilePath which allows the slash operator to be used to concatenate paths.\n\nA path on the file system.Paths consist of a sequence of directories followed by the name of a file or directory. They are\ndelimited by a platform-dependent separator character (see System.FilePath.pathSeparator).The string representation of the path.\n\nConstructs a path from a list of file names by interspersing them with the current platform's path\nseparator.\n\nAppends two paths, taking absolute paths into account. This operation is also accessible via the /\noperator.If sub is an absolute path, then p is discarded and sub is returned. If sub is a relative\npath, then it is attached to p with the platform-specific path separator.\n\nNormalizes a path, returning an equivalent path that may better follow platform conventions.In particular:* On Windows, drive letters are made uppercase.* On platforms that support multiple path separators (that is, where\nSystem.FilePath.pathSeparators has length greater than one), alternative path separators are\nreplaced with the preferred path separator.There is no guarantee that two equivalent paths normalize to the same path.\n\nAn absolute path starts at the root directory or a drive letter. Accessing files through an absolute\npath does not depend on the current working directory.\n\nA relative path is one that depends on the current working directory for interpretation. Relative\npaths do not start with the root directory or a drive letter.\n\nReturns the parent directory of a path, if there is one.If the path is that of the root directory or the root of a drive letter, none is returned.\nOtherwise, the path's parent directory is returned.\n\nSplits a path into a list of individual file names at the platform-specific path separator.\n\nExtracts the last element of a path if it is a file or directory name.Returns none if the last entry is a special name (such as . or ..) or if the path is the root\ndirectory.\n\nExtracts the stem (non-extension) part of p.fileName.If the filename contains multiple extensions, then only the last one is removed. Returns none if\nthere is no file name at the end of the path.Examples:* (\"app.exe\" : System.FilePath).fileStem = some \"app\"* (\"file.tar.gz\" : System.FilePath).fileStem = some \"file.tar\"* (\"files/\" : System.FilePath).fileStem = none* (\"files/picture.jpg\" : System.FilePath).fileStem = some \"picture\"\n\nExtracts the extension part of p.fileName.If the filename contains multiple extensions, then only the last one is extracted. Returns none if\nthere is no file name at the end of the path.Examples:* (\"app.exe\" : System.FilePath).extension = some \"exe\"* (\"file.tar.gz\" : System.FilePath).extension = some \"gz\"* (\"files/\" : System.FilePath).extension = none* (\"files/picture.jpg\" : System.FilePath).extension = some \"jpg\"\n\nAppends the extension ext to a path p.ext should not have leading ., as this function adds one. If ext is the empty string, no\n. is added.Unlike System.FilePath.withExtension, this does not remove any existing extension.\n\nReplaces the current extension in a path p with ext, adding it if there is no extension. If the\npath has multiple file extensions, only the last one is replaced. If the path has no filename, or if\next is the empty string, then the filename is returned unmodified.ext should not have a leading ., as this function adds one.Examples:* (\"files/picture.jpeg\" : System.FilePath).withExtension \"jpg\" = ⟨\"files/picture.jpg\"⟩* (\"files/\" : System.FilePath).withExtension \"zip\" = ⟨\"files/\"⟩* (\"files\" : System.FilePath).withExtension \"zip\" = ⟨\"files.zip\"⟩* (\"files/archive.tar.gz\" : System.FilePath).withExtension \"xz\" = ⟨\"files.tar.xz\"⟩\n\nReplaces the file name at the end of the path p with fname, placing fname in the parent\ndirectory of p.If p has no parent directory, then fname is returned unmodified.\n\nThe character that separates directories.On platforms that support multiple separators, System.FilePath.pathSeparator is the “ideal” one expected by users\non the platform. System.FilePath.pathSeparators lists all supported separators.\n\nThe list of all path separator characters supported on the current platform.On platforms that support multiple separators, System.FilePath.pathSeparator is the “ideal” one\nexpected by users on the platform.\n\nThe character that separates file extensions from file names.\n\nThe file extension expected for executable binaries on the current platform, or \"\" if there is no\nsuch extension.\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.3. Paths","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Paths"},"/The--mvcgen--tactic/Verification-Conditions/#The-Lean-Language-Reference--The--mvcgen--tactic--Verification-Conditions":{"contents":"The mvcgen tactic converts a goal that's expressed in terms of SPred and weakest preconditions to a set of invariants and verification conditions that, together, suffice to prove the original goal.\nIn particular, Hoare triples are defined in terms of weakest preconditions, so mvcgen can be used to prove them.\n\nThe verification conditions for a goal are generated as follows:1. A number of simplifications and rewrites are applied.2. The goal should now be of the form P ⊢ₛ wp⟦e⟧ Q (that is, an entailment from some set of stateful assumptions to the weakest precondition that implies a desired postcondition).3. Reducible constants and definitions marked @[spec] in the expression e are unfolded.4. If the expression is an application of an auxiliary matching function or a conditional (ite or dite), then it is first simplified.\n   The discriminant of each matcher is simplified, and the entire term is reduced in an attempt to eliminate the matcher or conditional.\n   If this fails, then a new goal is generated for each branch.5. If the expression is an application of a constant, then the applicable lemmas marked @[spec] are attempted in priority order.\n   Lean includes specification lemmas for constants such as bind, pure, and ForIn.forIn that result from desugaring do-notation.\n   Instantiating the lemma will sometimes discharge its premises, in particular schematic variables due to definitional equalities with the goal.\n   Assumptions of type Invariant are never instantiated this way, however.\n   If the spec lemma's precondition or postcondition do not exactly match those of the goal, then new metavariables are created that prove the necessary entailments.\n   If these cannot be immediately discharged using simple automation that attempts to use local assumptions and decomposes conjunctions in postconditions, then they remain as verification conditions.6. Each remaining goal created by this process is recursively processed for verification conditions if it has the form P ⊢ₛ wp⟦e⟧ Q. If not, it is added to the set of invariants or verification conditions.7. The resulting subgoals for invariants and verification conditions are assigned suitable names in the proof state.8. Depending on the tactic's configuration parameters, mvcgen_trivial and mleave are attempted in each verification condition.\n\nVerification condition generation can be improved by defining appropriate specification lemmas for a library.\nThe presence of good specification lemmas results in fewer generated verification conditions.\nAdditionally, ensuring that the simp normal form of terms is suitable for pattern matching, and that there are sufficient lemmas in the default simp set to reduce every possible term to that normal form, can lead to more conditionals and pattern matches being eliminated.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic","header":"18.3. Verification Conditions","id":"/The--mvcgen--tactic/Verification-Conditions/#The-Lean-Language-Reference--The--mvcgen--tactic--Verification-Conditions"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Other":{"contents":"* #6479 speeds up JSON serialisation by using a lookup table to check\nwhether a string needs to be escaped.* #6519 adds a script to automatically generate release notes using the\nnew changelog-* labels and \"...\" conventions.* #6542 introduces a script that automates checking whether major\ndownstream repositories have been updated for a new toolchain release.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Other","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Other"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Updates-to-the-try___-Tactic":{"contents":"* #6961 adds the auxiliary tactic evalAndSuggest. It will be used to\nrefactor try?.* #6965 re-implements the try? tactic using the new evalAndSuggest\ninfrastructure.* #6967 ensures try? can suggest tactics that need to reference\ninaccessible local names.\nExample:/--\ninfo: Try these:\n• · expose_names; induction as, bs_1 using app.induct <;> grind [= app]\n• · expose_names; induction as, bs_1 using app.induct <;> grind only [app]\n-/\n#guard_msgs (info) in\nexample : app (app as bs) cs = app as (app bs cs) := by\n  have bs := 20 -- shadows `bs` in the target\n  try?\n* #6979 adds support for more complex suggestions in try?.\nExample:example (as : List α) (a : α) : concat as a = as ++ [a] := by\n  try?\nsuggestionTry this: · induction as, a using concat.induct\n  · rfl\n  · simp_all\n* #6980 improves the try? tactic runtime validation and error\nmessages. It also simplifies the implementation, and removes unnecessary\ncode.* #6981 adds new configuration options to try?.* try? -only omits simp only and grind only suggestions* try? +missing enables partial solutions where some subgoals are\n\"solved\" using sorry, and must be manually proved by the user.* try? (max:=<num>) sets the maximum number of suggestions produced\n(default is 8).* #6991 improves how suggestions for the <;> combinator are generated.* #6994 adds the Try.Config.merge flag (true by default) to the\ntry? tactic. When set to true, try? compresses suggestions such\nas:· induction xs, ys using bla.induct\n    · grind only [List.length_reverse]\n    · grind only [bla]\ninto:induction xs, ys using bla.induct <;> grind only [List.length_reverse, bla]\n* #6995 implements support for exact? in the try? tactic.* #7082 makes try? use fun_induction instead of induction … using foo.induct. It uses the argument-free short-hand fun_induction foo if\nthat is unambiguous. Avoids expose_names if not necessary by simply\ntrying without first.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"Updates to the try? Tactic","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Updates-to-the-try___-Tactic"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Pretty-Printing":{"contents":"* #7074 modifies the signature pretty printer to add hover information\nfor parameters in binders. This makes the binders be consistent with the\nhovers in pi types.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Pretty Printing","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Pretty-Printing"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind--Interactive-mode":{"contents":"grind has been extended with an interactive mode grind => …\n(#10607, #10677, ...)\n\nexample (x y : Nat) : x ≥ y + 1 → x > 0 := by\n  grind => skip; lia; done\n\n\nInteractive mode comes with anchors (also known as stable hash codes) for referencing terms occurring in a grind goal\n(#10709).\n\nIn the interactive mode, it is possible to do the following:\n\n* instantiate global and local theorems\n(#10746 and #10841);* Inspect the state with show_splits and show_state (#10709),\nshow_true, show_false, show_asserted, and show_eqcs\n(#10690);* Inspect with filtering; each tactic may optionally have a suffix of the form | filter?\n(#10828);* Make local assertions with have (#10706);* Use tactics (#10731):* focus <grind_tac_seq>* next => <grind_tac_seq>* any_goals <grind_tac_seq>* all_goals <grind_tac_seq>* grind_tac <;> grind_tac* cases <anchor>* tactic => <tac_seq>* Select anchors with cases?\n(#10824 - there's a screenshot in the PR description);* Use grind solvers ac, linarith, lia, ring as actions\n(#10812 & #10834);* Produce, when possible, a concrete grind script that closes the goal, using explicit grind tactic\nsteps, i.e., without any search, with finish? (#10837):/--\ninfo: Try this:\n  [apply] ⏎\n    cases #b0f4\n    next => cases #50fc\n    next => cases #50fc <;> lia\n-/\n#guard_msgs in\nexample (p : Nat → Prop) (x y z w : Int) :\n    (x = 1 ∨ x = 2) →\n    (w = 1 ∨ w = 4) →\n    (y = 1 ∨ (∃ x : Nat, y = 3 - x ∧ p x)) →\n    (z = 1 ∨ z = 0) → x + y ≤ 6 := by\n  grind => finish?\nThe anchors in the generated script are based on stable hash codes.\nMoreover, users can hover over them to see the exact term used in the case split.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights\u0009Grind","header":"Interactive mode","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Grind--Interactive-mode"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Tactics":{"contents":"* #11226 finally removes the old grind framework SearchM. It has been\nreplaced with the new Action framework.* #11244 fixes minor issues in grind. In preparation for adding grind -revert.* #11247 fixes an issue in the grind preprocessor. simp may introduce\nassigned (universe) metavariables (e.g., when performing\nzeta-reduction).* #11248 implements the option revert, which is set to false by\ndefault. To recover the old grind behavior, you should use grind +revert. Previously, grind used the RevSimpIntro idiom, i.e., it\nwould revert all hypotheses and then re-introduce them while simplifying\nand applying eager cases. This idiom created several problems:* Users reported that grind would include unnecessary parameters. See\nhere.* Unnecessary section variables were also being introduced. See the new\ntest contributed by Sebastian Graf.* Finally, it prevented us from supporting arbitrary parameters as we do\nin simp. In simp, I implemented a mechanism that simulates local\nuniverse-polymorphic theorems, but this approach could not be used in\ngrind because there is no mechanism for reverting (and re-introducing)\nlocal universe-polymorphic theorems. Adding such a mechanism would\nrequire substantial work: I would need to modify the local context\nobject. I considered maintaining a substitution from the original\nvariables to the new ones, but this is also tricky, because the mapping\nwould have to be stored in the grind goal objects, and it is not just\na simple mapping. After reverting everything, I would need to keep a\nsequence of original variables that must be added to the mapping as we\nre-introduce them, but eager case splits complicate this quite a bit.\nThe whole approach felt overly messy.* #11265 marks the automatically generated sizeOf theorems as grind\ntheorems.* #11268 implements support for arbitrary grind parameters. The feature\nis similar to the one available in simp, where a proof term is treated\nas a local universe-polymorphic lemma. This feature relies on grind -revert (see #11248). For example, users can now write:def snd (p : α × β) : β := p.2\ntheorem snd_eq (a : α) (b : β) : snd (a, b) = b := rfl\n\n* #11273 fixes a bug during proof construction in grind.* #11295 fixes a bug in the propagation rules for ite and dite used\nin grind. The bug prevented equalities from being propagated to the\nsatellite solvers. Here is an example affected by this issue.* #11315 fixes an issue affecting grind -revert. In this mode, assigned\nmetavariables in hypotheses were not being instantiated. This issue was\naffecting two files in Mathlib.* #11318 fixes a local declaration internalization in grind that was\nexposed when using grind -revert. This bug was affecting a grind\nproof in Mathlib.* #11319 improves the support for Fin n in grind when n is not a\nnumeral.* #11323 introduces a new grind option, funCC (enabled by default),\nwhich extends congruence closure to function-valued equalities. When\nfunCC is enabled, grind tracks equalities of partially applied\nfunctions, allowing reasoning steps such as:a : Nat → Nat\nf : (Nat → Nat) → (Nat → Nat)\nh : f a = a\n⊢ (f a) m = a m\n\n* #11326 ensures that users can provide grind proof parameters whose\ntypes are not forall-quantified. Examples:opaque f : Nat → Nat\naxiom le_f (a : Nat) : a ≤ f a\n\n* #11330 renames the cutsat tactic to lia for better alignment with\nstandard terminology in the theorem proving community.* #11331 adds support for the LawfulOfScientific class in grind.\nExamples:open Lean Grind Std\nvariable [LE α] [LT α] [LawfulOrderLT α] [Field α] [OfScientific α]\n         [LawfulOfScientific α] [IsLinearOrder α] [OrderedRing α]\nexample : (2 / 3 : α) ≤ (0.67 : α) := by  grind\nexample : (1.2 : α) ≤ (1.21 : α) := by grind\nexample : (2 / 3 : α) ≤ (67 / 100 : α) := by grind\nexample : (1.2345 : α) ≤ (1.2346 : α) := by grind\nexample : (2.3 : α) ≤ (4.5 : α) := by grind\nexample : (2.3 : α) ≤ (5/2 : α) := by grind\n* #11332 adds a grind_annotated \"YYYY-MM-DD\" command that marks files\nas manually annotated for grind.* #11334 adds an explicit normalization layer for ring constraints in the\ngrind linarith module. For example, it will be used to clean up\ndenominators when the ring is a field.* #11335 enables the syntax use [ns Foo] and instantiate only [ns Foo] inside a grind tactic block, and has the effect of activating\nall grind patterns scoped to that namespace. We can use this to\nimplement specialized tactics using grind, but only controlled subsets\nof theorems.* #11348 activates the grind_annotated command in\nInit.Data.List.Lemmas by removing the TODO comment and uncommenting\nthe command.* #11350 implements a helper simproc for grind. It is part of the\ninfrastructure used to cleanup denominators in grind linarith.* #11365 enables parallelism in try?. Currently, we replace the\nattempt_all stages (there are two, one for builtin tactics including\ngrind and simp_all, and a second one for all user extensions) with\nparallel versions. We do not (yet?) change the behaviour of first\nbased stages.* #11373 makes the library suggestions extension state available when\nimporting from module files.* #11375 adds support for cleaning up denominators in grind linarith\nwhen the type is a Field.* #11391 implements new kinds of constraints for the grind_pattern\ncommand. These constraints allow users to control theorem instantiation\nin grind.\nIt requires a manual update-stage0 because the change affects the\n.olean format, and the PR fails without it.* #11396 changes set_library_suggestions to create an auxiliary\ndefinition marked with @[library_suggestions], rather than storing\nSyntax directly in the environment extension. This enables better\npersistence and consistency of library suggestions across modules.* #11405 implements the following grind_pattern constraints:grind_pattern fax => f x  where\n  depth x < 2\n\n* #11409 implements support for the grind_pattern constraints\nis_value and is_strict_value.* #11410 fixes a kernel type mismatch error in grind's denominator\ncleanup feature. When generating proofs involving inverse numerals (like\n2⁻¹), the proof context is compacted to only include variables\nactually used. This involves renaming variable indices - e.g., if\noriginal indices were {0: r, 1: 2⁻¹} and only 2⁻¹ is used, it gets\nrenamed to index 0.* #11412 fixes an issue where grind would fail after multiple\nnorm_cast\ncalls with the error \"unexpected metadata found during internalization\".* #11428 implements support for guards in grind_pattern. The new\nfeature provides additional control over theorem instantiation. For\nexample, consider the following monotonicity theorem:opaque f : Nat → Nat\ntheorem fMono : x ≤ y → f x ≤ f y := ...\n* #11429 documents the grind_pattern command for manually selecting\ntheorem instantiation patterns, including multi-patterns and the\nconstraint system (=/=, =?=, size, depth, is_ground,\nis_value, is_strict_value, gen, max_insts, guard, check).* #11462 adds solve_by_elim as a fallback in the try? tactic's simple\ntactics. When rfl and assumption both fail but solve_by_elim\nsucceeds (e.g., for goals requiring hypothesis chaining or\nbacktracking), try? will now suggest solve_by_elim.* #11464 improves the error message when no library suggestions engine is\nregistered to recommend importing Lean.LibrarySuggestions.Default for\nthe built-in engine.* #11466 removes the \"first pass\" behavior where exact? and apply?\nwould try solve_by_elim on the original goal before doing library\nsearch. This simplifies the librarySearch API and focuses these\ntactics on their primary purpose: finding library lemmas.* #11468 adds +suggestions support to solve_by_elim, following the\npattern established by grind +suggestions and simp_all +suggestions.* #11469 adds +grind and +try? options to exact? and apply?\ntactics.* #11471 fixes an incorrect reducibility setting when using grind\ninteractive mode.* #11480 adds the grind option reducible (default: true). When\nenabled, definitional equality tests expand only declarations marked as\n@[reducible].\nUse grind -reducible to allow expansion of non-reducible declarations\nduring definitional equality tests.\nThis option affects only definitional equality; the canonicalizer and\ntheorem pattern internalization always unfold reducible declarations\nregardless of this setting.* #11481 fixes a bug in grind?. The suggestion using the grind\ninteractive mode was dropping the configuration options provided by the\nuser. In the following account, the third suggestion was dropping the\n-reducible option.* #11484 fixes a bug in the grind pattern validation. The bug affected\ntype classes that were propositions.* #11487 adds a heterogeneous version of the constructor injectivity\ntheorems. These theorems are useful for indexed families, and will be\nused in grind.* #11491 implements heterogeneous contructor injectivity in grind.* #11494 re-enables star-indexed lemmas as a fallback for exact? and\napply?.* #11519 marks Nat power and divisibility theorems for grind. We use\nthe new grind_pattern constraints to control theorem instantiation.\nExamples:example {x m n : Nat} (h : x = 4 ^ (m + 1) * n) : x % 4 = 0 := by\n  grind\n\n* #11520 implements the constraint not_value x in the grind_pattern\ncommand. It is the negation of the constraint is_value.* #11522 implements grind propagators for Nat operators that have a\nsimproc associated with them, but do not have any theory solver support.\nExamples:example (a b : Nat) : a = 3 → b = 6 → a &&& b = 2 := by grind\nexample (a b : Nat) : a = 3 → b = 6 → a ||| b = 7 := by grind\nexample (a b : Nat) : a = 3 → b = 6 → a ^^^ b = 5 := by grind\nexample (a b : Nat) : a = 3 → b = 6 → a <<< b = 192 := by grind\nexample (a b : Nat) : a = 1135 → b = 6 → a >>> b = 17 := by grind\n* #11547 ensures the auxiliary definitions created by\nregister_try?_tactic are internal implementation details that should\nnot be visible to user-facing linters.* #11556 adds a +all option to exact? and apply? that collects all\nsuccessful lemmas instead of stopping at the first complete solution.* #11573 fixes grind rejecting dot notation terms, mistaking them for\nlocal hypotheses.* #11579 ensures that ground theorems are properly handled as grind\nparameters. Additionally, grind [(thm)] and grind [thm] should be\nhandled the same way.* #11580 adds a missing Nat.cast missing normalization rule for\ngrind. Example:example (n : Nat) : Nat.cast n = n := by\n  grind\n* #11589 improves indexing for grind patterns. We now include symbols\noccurring in nested ground patterns. This important to minimize the\nnumber of activated E-match theorems.* #11593 fixes an issue where grind did not display deprecation\nwarnings when deprecated lemmas were used in its argument list.* #11594 fixes grind? to include term parameters (like [show P by tac]) in its suggestions. Previously, these were being dropped because\nterm arguments are stored in extraFacts and not tracked via E-matching\nlike named lemmas.* #11604 fixes how theorems without parameters are handled in grind.* #11605 fixes a bug in the internalizer of a^p terms in grind linarith.* #11609 improves the case-split heuristics in grind. In this PR, we do\nnot increment the number of case splits in the first case. The idea is\nto leverage non-chronological backtracking: if the first case is solved\nusing a proof that doesn't depend on the case hypothesis, we backtrack\nand close the original goal directly. In this scenario, the case-split\nwas \"free\", it didn't contribute to the proof. By not counting it, we\nallow deeper exploration when case-splits turn out to be irrelevant.\nThe new heuristic addresses the second example in #11545* #11613 ensures we apply the ring normalizer to equalities being\npropagated from the grind core module to grind lia. It also ensures\nwe use the safe/managed polynomial functions when normalizing.* #11615 adds a normalization rule for Int.subNatNat to grind.* #11628 adds a few * normalization rules for Semirings to grind.* #11629 adds a missing condition in the pattern normalization code used\nin grind. It should ignore support ground terms.* #11635 ensures the pattern normalizer used in grind does violate\nassumptions made by the gadgets Grind.genPattern and\nGrind.getHEqPattern.* #11638 fixes bitvector literal internalization in grind. The fix\nensures theorems indexed by BitVec.ofNat are properly activated.* #11639 adds support for BitVec.ofNat in grind ring. Example:example (x : BitVec 8) : (x - 16#8)*(x + 272#8) = x^2 := by\n  grind\n* #11640 adds support for BitVec.ofNat in grind lia. Example:example (x y : BitVec 8) : y < 254#8 → x > 2#8 + y → x > 1#8 + y := by\n  grind\n* #11653 adds propagation rules corresponding to the Semiring\nnormalization rules introduced in #11628. The new rules apply only to\nnon-commutative semirings, since support for them in grind is limited.\nThe normalization rules introduced unexpected behavior in Mathlib\nbecause they neutralize parameters such as one_mul: any theorem\ninstance associated with such a parameter is reduced to True by the\nnormalizer.* #11656 adds support for Int.sign, Int.fdiv, Int.tdiv, Int.fmod,\nInt.tmod, and Int.bmod to grind. These operations are just\npreprocessed away. We assume that they are not very common in practice.\nExamples:example {x y : Int} : y = 0 → (x.fdiv y) = 0 := by grind\nexample {x y : Int} : y = 0 → (x.tdiv y) = 0 := by grind\nexample {x y : Int} : y = 0 → (x.fmod y) = x := by grind\nexample {x y : Int} : y = 1 → (x.fdiv (2 - y)) = x := by grind\nexample {x : Int} : x > 0 → x.sign = 1 := by grind\nexample {x : Int} : x < 0 → x.sign = -1 := by grind\nexample {x y : Int} : x.sign = 0 → x*y = 0 := by grind\n* #11658 fixes a bug in the internalization of parametric literals in\ngrind. That is, literals whose type is BitVec _ or Fin _.* #11659 adds MessageData.withNamingContext when generating pattern\nsuggestions at @[grind]. It fixes another issue reported during\nItaLean.* #11660 fixes another theorem activation issue in grind.* #11663 fixes the grind pattern validator. It covers the case where an\ninstance is not tagged with the implicit instance binder. This happens\nin declarations such asZeroMemClass.zero_mem {S : Type} {M : outParam Type} {inst1 : Zero M} {inst2 : SetLike S M}\n  [self : @ZeroMemClass S M inst1 inst2] (s : S) : 0 ∈ s\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0-rc1 (2025-12-14)","header":"Tactics","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Tactics"}});