window.docContents[113].resolve({"/Basic-Types/Strings/#string-api-modify":{"contents":"Splits a string at each character for which p returns true.The characters that satisfy p are not included in any of the resulting strings. If multiple\ncharacters in a row satisfy p, then the resulting list will contain empty strings.This is a legacy function. Use String.split instead.Examples:* \"coffee tea water\".split (·.isWhitespace) = [\"coffee\", \"tea\", \"water\"]* \"coffee  tea  water\".split (·.isWhitespace) = [\"coffee\", \"\", \"tea\", \"\", \"water\"]* \"fun x =>\\n  x + 1\\n\".split (· == '\\n') = [\"fun x =>\", \"  x + 1\", \"\"]\n\nSplits a string s on occurrences of the separator string sep. The default separator is \" \".When sep is empty, the result is [s]. When sep occurs in overlapping patterns, the first match\nis taken. There will always be exactly n+1 elements in the returned list if there were n\nnon-overlapping matches of sep in the string. The separators are not included in the returned\nsubstrings.This is a legacy function. Use String.split instead.Examples:* \"here is some text \".splitOn = [\"here\", \"is\", \"some\", \"text\", \"\"]* \"here is some text \".splitOn \"some\" = [\"here is \", \" text \"]* \"here is some text \".splitOn \"\" = [\"here is some text \"]* \"ababacabac\".splitOn \"aba\" = [\"\", \"bac\", \"c\"]\n\nAdds a character to the end of a string.The internal implementation uses dynamic arrays and will perform destructive updates\nif the string is not shared.Examples:* \"abc\".push 'd' = \"abcd\"* \"\".push 'a' = \"a\"\n\nAdds multiple repetitions of a character to the end of a string.Returns s, with n repetitions of c at the end. Internally, the implementation repeatedly calls\nString.push, so the string is modified in-place if there is a unique reference to it.Examples:* \"indeed\".pushn '!' 2 = \"indeed!!\"* \"indeed\".pushn '!' 0 = \"indeed\"* \"\".pushn ' ' 4 = \"    \"\n\nReplaces the first character in s with the result of applying Char.toUpper to it. Returns the\nempty string if the string is empty.Char.toUpper has no effect on characters outside of the range 'a'–'z'.Examples:* \"orange\".capitalize = \"Orange\"* \"ORANGE\".capitalize = \"ORANGE\"* \"\".capitalize = \"\"\n\nReplaces the first character in s with the result of applying Char.toLower to it. Returns the\nempty string if the string is empty.Char.toLower has no effect on characters outside of the range 'A'–'Z'.Examples:* \"Orange\".decapitalize = \"orange\"* \"ORANGE\".decapitalize = \"oRANGE\"* \"\".decapitalize = \"\"\n\nReplaces each character in s with the result of applying Char.toUpper to it.Char.toUpper has no effect on characters outside of the range 'a'–'z'.Examples:* \"orange\".toUpper = \"ORANGE\"* \"abc123\".toUpper = \"ABC123\"\n\nReplaces each character in s with the result of applying Char.toLower to it.Char.toLower has no effect on characters outside of the range 'A'–'Z'.Examples:* \"ORANGE\".toLower = \"orange\"* \"Orange\".toLower = \"orange\"* \"ABc123\".toLower = \"abc123\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"20.8.4.9. Manipulation","id":"/Basic-Types/Strings/#string-api-modify"},"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Implementation-Notes":{"contents":"The implementation of the linear integer arithmetic solver is inspired by Section 4 of .\nCompared to the paper, it includes several enhancements and modifications such as:* extended constraint support (equality and disequality),* an optimized encoding of the Cooper-Left rule using a “big”-disjunction instead of fresh variables, and* decision variable tracking for case splits (disequalities, Cooper-Left, Cooper-Right).The solver procedure builds a model (that is, an assignment of the variables in the term) incrementally, resolving conflicts through constraint generation.\nFor example, given a partial model {x := 1} and constraint 3 ∣ 3 * y + x + 1:* The solver cannot extend the model to y because 3 ∣ 3 * y + 2 is unsatisfiable.* Thus, it resolves the conflict by generating the implied constraint 3 ∣ x + 1.* The new constraint forces the solver to find a new assignment for x.When assigning a variable y, the solver considers:* The best upper and lower bounds (inequalities).* A divisibility constraint.* All disequality constraints where y is the maximal variable.\n\nThe Cooper-Left and Cooper-Right rules handle the combination of inequalities and divisibility.\nFor unsatisfiable disequalities p ≠ 0, the solver generates the case split: p + 1 ≤ 0 ∨ -p + 1 ≤ 0.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.7. Implementation Notes","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Implementation-Notes"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Minimum-and-Maximum-Values":{"contents":"The classes Max and Min provide overloaded operators for choosing the greater or lesser of two values.\nThese should be in agreement with Ord, LT, and LE instances, if they exist, but there is no mechanism to enforce this.\n\nAn overloaded operation to find the lesser of two values of type α.Returns the lesser of its two arguments.\n\nAn overloaded operation to find the greater of two values of type α.Returns the greater of its two arguments.\n\nGiven an LE α instance for which LE.le is decidable, the helpers minOfLe and maxOfLe can be used to create suitable Min α and Max α instances.\nThey can be used as the right-hand side of an instance declaration.Constructs a Min instance from a decidable ≤ operation.Constructs a Max instance from a decidable ≤ operation.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.3. Minimum and Maximum Values","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Minimum-and-Maximum-Values"},"/Type-Classes/Instance-Synthesis/#instance-search":{"contents":"Instance search occurs during the elaboration of (potentially nullary) function applications.\nSome of the implicit parameters' values are forced by others; for instance, an implicit type parameter may be solved using the type of a later value argument that is explicitly provided.\nImplicit parameters may also be solved using information from the expected type at that point in the program.\nThe search for instance implicit arguments may make use of the implicit argument values that have been found, and may additionally solve others.\n\nInstance synthesis begins with the type of the instance-implicit parameter.\nThis type must be the application of a type class to zero or more arguments; these argument values may be known or unknown when search begins.\nIf an argument to a class is unknown, the search process will not instantiate it unless the corresponding parameter is marked as an output parameter, explicitly making it an output of the instance synthesis routine.\n\nSearch may succeed, fail, or get stuck; a stuck search may occur when an unknown argument value becoming known might enable progress to be made.\nStuck searches may be re-invoked when the elaborator has discovered one of the previously-unknown implicit arguments.\nIf this does not occur, stuck searches become failures.\n\nTracing Instance SearchSetting the trace.Meta.synthInstance option to true causes Lean to emit a trace of the process for synthesizing an instance of a type class.\nThis trace can be used to understand how instance synthesis succeeds and why it fails.Here, we can see the steps Lean takes to conclude that there exists an element of the type (Nat ⊕ Empty) (specifically the element Sum.inl 0):\nClicking a ▶ symbol expands that branch of the trace, and clicking the ▼ collapses an expanded branch.set_option pp.explicit true in\nset_option trace.Meta.synthInstance true in\n#synth Nonempty (Nat ⊕ Empty)\n[Meta.synthInstance] ✅️ Nonempty (Sum Nat Empty)\n  [Meta.synthInstance] new goal Nonempty (Sum Nat Empty)\n    [Meta.synthInstance.instances] #[@instNonemptyOfInhabited, @instNonemptyOfMonad, @Sum.nonemptyLeft, @Sum.nonemptyRight]\n  [Meta.synthInstance] ✅️ apply @Sum.nonemptyRight to Nonempty (Sum Nat Empty)\n    [Meta.synthInstance.tryResolve] ✅️ Nonempty (Sum Nat Empty) ≟ Nonempty (Sum Nat Empty)\n    [Meta.synthInstance] new goal Nonempty Empty\n      [Meta.synthInstance.instances] #[@instNonemptyOfInhabited, @instNonemptyOfMonad]\n  [Meta.synthInstance] ❌️ apply @instNonemptyOfMonad to Nonempty Empty\n    [Meta.synthInstance.tryResolve] ❌️ Nonempty Empty ≟ Nonempty (?m.5 ?m.6)\n  [Meta.synthInstance] ✅️ apply @instNonemptyOfInhabited to Nonempty Empty\n    [Meta.synthInstance.tryResolve] ✅️ Nonempty Empty ≟ Nonempty Empty\n    [Meta.synthInstance] new goal Inhabited Empty\n      [Meta.synthInstance.instances] #[@instInhabitedOfMonad, @Lake.inhabitedOfNilTrace, @instInhabitedOfApplicative_manual]\n  [Meta.synthInstance] ❌️ apply @instInhabitedOfApplicative_manual to Inhabited Empty\n    [Meta.synthInstance.tryResolve] ❌️ Inhabited Empty ≟ Inhabited (?m.8 ?m.7)\n  [Meta.synthInstance] ✅️ apply @Lake.inhabitedOfNilTrace to Inhabited Empty\n    [Meta.synthInstance.tryResolve] ✅️ Inhabited Empty ≟ Inhabited Empty\n    [Meta.synthInstance] no instances for Lake.NilTrace Empty\n      [Meta.synthInstance.instances] #[]\n  [Meta.synthInstance] ❌️ apply @instInhabitedOfMonad to Inhabited Empty\n    [Meta.synthInstance.tryResolve] ❌️ Inhabited Empty ≟ Inhabited (?m.8 ?m.7)\n  [Meta.synthInstance] ✅️ apply @Sum.nonemptyLeft to Nonempty (Sum Nat Empty)\n    [Meta.synthInstance.tryResolve] ✅️ Nonempty (Sum Nat Empty) ≟ Nonempty (Sum Nat Empty)\n    [Meta.synthInstance] new goal Nonempty Nat\n      [Meta.synthInstance.instances] #[@instNonemptyOfInhabited, @instNonemptyOfMonad]\n  [Meta.synthInstance] ❌️ apply @instNonemptyOfMonad to Nonempty Nat\n    [Meta.synthInstance.tryResolve] ❌️ Nonempty Nat ≟ Nonempty (?m.5 ?m.6)\n  [Meta.synthInstance] ✅️ apply @instNonemptyOfInhabited to Nonempty Nat\n    [Meta.synthInstance.tryResolve] ✅️ Nonempty Nat ≟ Nonempty Nat\n    [Meta.synthInstance] new goal Inhabited Nat\n      [Meta.synthInstance.instances] #[@instInhabitedOfMonad, @Lake.inhabitedOfNilTrace, @instInhabitedOfApplicative_manual, instInhabitedNat]\n  [Meta.synthInstance] ✅️ apply instInhabitedNat to Inhabited Nat\n    [Meta.synthInstance.tryResolve] ✅️ Inhabited Nat ≟ Inhabited Nat\n    [Meta.synthInstance.answer] ✅️ Inhabited Nat\n  [Meta.synthInstance.resume] propagating Inhabited Nat to subgoal Inhabited Nat of Nonempty Nat\n    [Meta.synthInstance.resume] size: 1\n    [Meta.synthInstance.answer] ✅️ Nonempty Nat\n  [Meta.synthInstance.resume] propagating Nonempty Nat to subgoal Nonempty Nat of Nonempty (Sum Nat Empty)\n    [Meta.synthInstance.resume] size: 2\n    [Meta.synthInstance.answer] ✅️ Nonempty (Sum Nat Empty)\n  [Meta.synthInstance] result @Sum.nonemptyLeft Nat Empty (@instNonemptyOfInhabited Nat instInhabitedNat)\nBy exploring the trace, it is possible to follow the depth-first, backtracking search that Lean uses for type class instance search.\nThis can take a little practice to get used to!\nIn the example above, Lean follows these steps:* Lean considers the first goal, Nonempty (Sum Nat Empty). Lean sees four ways of possibly satisfying this goal:* The Sum.nonemptyRight instance, which would create a sub-goal Nonempty Empty.* The Sum.nonemptyLeft instance, which would create a sub-goal Nonempty Nat.* The instNonemptyOfMonad instance, which would create two sub-goals Monad (Sum Nat) and Nonempty Nat.* The instNonemptyOfInhabited instance, which would create a sub-goal Inhabited (Sum Nat Empty).* The first sub-goal, Nonempty Empty, is considered. Lean sees two ways of possibly satisfying this goal:* The instNonemptyOfMonad instance, which is rejected.\n    It can't be used because the type Empty is not the application of a monad to a type.\n    Lean describes this as a failure of trace.Meta.synthInstance.tryResolve to solve the equation Nonempty Empty ≟ Nonempty (?m.5 ?m.6).* The instNonemptyOfInhabited instance, which would create a sub-goal Inhabited Empty.* The newly-generated sub-goal, Inhabited Empty, is considered.\n  Lean only sees one way of possibly satisfying this goal, instInhabitedOfMonad, which is rejected.\n  As before, this is because the type Empty is not the application of a monad to a type.* At this point, there are no remaining options for achieving the original first sub-goal.\n  The search backtracks to the second original sub-goal, Nonempty Nat.\n  This search eventually succeeds.The third and fourth original sub-goals are never considered.\nOnce the search for Nonempty Nat succeeds, the #synth command finishes and outputs the solution:@Sum.nonemptyLeft Nat Empty (@instNonemptyOfInhabited Nat instInhabitedNat)\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.2. Instance Search Problems","id":"/Type-Classes/Instance-Synthesis/#instance-search"}});