window.docContents[157].resolve({"/Basic-Types/Bitvectors/#BitVec-api":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors","header":"20.5.5. API Reference","id":"/Basic-Types/Bitvectors/#BitVec-api"},"/IO/Files___-File-Handles___-and-Streams/#stdio":{"contents":"On operating systems that are derived from or inspired by Unix, standard input, standard output, and standard error are the names of three streams that are available in each process.\nGenerally, programs are expected to read from standard input, write ordinary output to the standard output, and error messages to the standard error.\nBy default, standard input receives input from the console, while standard output and standard error output to the console, but all three are often redirected to or from pipes or files.\n\nRather than providing direct access to the operating system's standard I/O facilities, Lean wraps them in Streams.\nAdditionally, the IO monad contains special support for replacing or locally overriding them.\nThis extra level of indirection makes it possible to redirect input and output within a Lean program.\n\nReturns the current thread's standard input stream.Use IO.setStdin to replace the current thread's standard input stream.\n\nReading from Standard InputIn this example, IO.getStdin and IO.getStdout are used to get the current standard input and output, respectively.\nThese can be read from and written to.def main : IO Unit := do\n  let stdin ← IO.getStdin\n  let stdout ← IO.getStdout\n  stdout.putStrLn \"Who is it?\"\n  let name ← stdin.getLine\n  stdout.putStr \"Hello, \"\n  stdout.putStrLn name\nWith this standard input:Lean user\nthe standard output is:Who is it?\nHello, Lean user\n\n\nReplaces the standard input stream of the current thread and returns its previous value.Use IO.getStdin to get the current standard input stream.\n\nRuns an action with the specified stream h as standard input, restoring the original standard\ninput stream afterwards.\n\nReturns the current thread's standard output stream.Use IO.setStdout to replace the current thread's standard output stream.\n\nReplaces the standard output stream of the current thread and returns its previous value.Use IO.getStdout to get the current standard output stream.\n\nRuns an action with the specified stream h as standard output, restoring the original standard\noutput stream afterwards.\n\nReturns the current thread's standard error stream.Use IO.setStderr to replace the current thread's standard error stream.\n\nReplaces the standard error stream of the current thread and returns its previous value.Use IO.getStderr to get the current standard error stream.\n\nRuns an action with the specified stream h as standard error, restoring the original standard\nerror stream afterwards.\n\nRuns an action with stdin emptied and stdout and stderr captured into a String. If\nisolateStderr is false, only stdout is captured.\n\nRedirecting Standard I/O to StringsThe countdown function counts down from a specified number, writing its progress to standard output.\nUsing IO.FS.withIsolatedStreams, this output can be redirected to a string.def countdown : Nat → IO Unit\n  | 0 =>\n    IO.println \"Blastoff!\"\n  | n + 1 => do\n    IO.println s!\"{n + 1}\"\n    countdown n\n\ndef runCountdown : IO String := do\n  let (output, ()) ← IO.FS.withIsolatedStreams (countdown 10)\n  return output\n\n#eval runCountdown\nRunning countdown yields a string that contains the output:\"10\\n9\\n8\\n7\\n6\\n5\\n4\\n3\\n2\\n1\\nBlastoff!\\n\"\n\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.5. Standard I/O","id":"/IO/Files___-File-Handles___-and-Streams/#stdio"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Server":{"contents":"* #5835 adds auto-completion for the fields of structure instance notation. Specifically, querying the completions via Ctrl+Space in the whitespace of a structure instance notation will now bring up the full list of fields. Whitespace structure completion can be enabled for custom syntax by wrapping the parser for the list of fields in a structInstFields parser.* #5837 fixes an old auto-completion bug where x. would issue\nnonsensical completions when x. could not be elaborated as a dot\ncompletion.* #5996 avoid max heartbeat error in completion* #6031 fixes a regression with go-to-definition and document highlight\nmisbehaving on tactic blocks.* #6246 fixes a performance issue where the Lean language server would\nwalk the full project file tree every time a file was saved, blocking\nthe processing of all other requests and notifications and significantly\nincreasing overall language server latency after saving.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Server","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Server"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Compiler":{"contents":"* #11082 prevents symbol clashes between (non-@[export]) definitions\nfrom different Lean packages.* #11185 fixes the reduceArity compiler pass to consider\nover-applications to functions that have their arity reduced.\nPreviously, this pass assumed that the amount of arguments to\napplications was always the same as the number of parameters in the\nsignature. This is usually true, since the compiler eagerly introduces\nparameters as long as the return type is a function type, resulting in a\nfunction with a return type that isn't a function type. However, for\ndependent types that sometimes are function types and sometimes not,\nthis assumption is broken, resulting in the additional parameters to be\ndropped.* #11210 fixes a bug in the LCNF simplifier unearthed while working on\n#11078. In some situations caused by unsafeCast, the simplifier would\nrecord incorrect information about cases, leading to further bugs down\nthe line.* #11215 fixes an issue where header nesting levels were properly tracked\nbetween, but not within, moduledocs.* #11217 fixes fallout of the closure allocator changes in #10982. As far\nas we know\nthis bug only meaningfully manifests in non default build configurations\nwithout mimalloc such as:\ncmake --preset release -DUSE_MIMALLOC=OFF* #11310 makes the specializer (correctly) share more cache keys across\ninvocations, causing us to produce less code bloat.* #11340 fixes a miscompilation when encountering projections of non\ntrivial structure types.* #11362 accelerates termination of the ElimDeadBranches compiler pass.* #11366 sorts the declarations fed into ElimDeadBranches in increasing\nsize. This can improve performance when we are dealing with a lot of\niterations.* #11381 fixes a bug where the closed term extraction does not respect\nthe implicit invariant of the\nc emitter to have closed term decls first, other decls second, within an\nSCC. This bug has not yet\nbeen triggered in the wild but was unearthed during work on upcoming\nmodifications of the\nspecializer.* #11383 fixes the compilation of structure projections with unboxed\narguments marked extern, adding missing dec instructions. It led to\nleaking single allocations when such functions were used as closures or\nin the interpreter.* #11388 is a followup of #11381 and enforces the invariants on ordering\nof closed terms and constants required by the EmitC pass properly by\ntoposorting before saving the declarations into the Environment.* #11426 closes #11356.* #11445 slightly improves the types involved in creating boxed\ndeclarations. Previously the type of\nthe vdecl used for the return was always tobj when returning a boxed\nscalar. This is not the most\nprecise annotation we can give.* #11451 adapts the lambda lifter in LCNF to eta contract instead of\nlambda lift if possible. This prevents the creation of a few hundred\nunnecessary lambdas across the code base.* #11517 implements constant folding for Nat.mul* #11525 makes the LCNF simplifier eliminate cases where all alts are\n.unreach to just an .unreach.\nan .unreach* #11530 introduces the new tagged_return attribute. It allows users to\nmark extern declarations to be guaranteed to always return tagged\nreturn values. Unlike with object or tobject the compiler does not\nemit reference counting operations for them. In the future information\nfrom this attribute will be used for a more powerful analysis to remove\nreference counts when possible.* #11576 removes the old ElimDeadBranches pass and shifts the new one\npast lambda lifting.* #11586 allows projections on tagged values in the IR type system.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0-rc1 (2025-12-14)","header":"Compiler","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Compiler"}});