window.docContents[135].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Cosine":{"contents":"Computes the cosine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncos.\n\nComputes the cosine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncosf.\n\nComputes the hyperbolic cosine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncosh.\n\nComputes the hyperbolic cosine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncoshf.\n\nComputes the arc cosine (inverse cosine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacos.\n\nComputes the arc cosine (inverse cosine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacosf.\n\nComputes the hyperbolic arc cosine (inverse cosine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacosh.\n\nComputes the hyperbolic arc cosine (inverse cosine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacoshf.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Trigonometry","header":"20.6.2.9.2. Cosine","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Cosine"},"/Error-Explanations/lean___inductionWithNoAlts/#The-Lean-Language-Reference--Error-Explanations--lean___inductionWithNoAlts":{"contents":"\n\nTactic-based proofs using induction in Lean need to use a pattern-matching-like notation to describe\nindividual cases of the proof. However, the induction' tactic in Mathlib and the specialized\ninduction tactic for natural numbers used in the Natural Number Game follows a different pattern.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.inductionWithNoAlts","id":"/Error-Explanations/lean___inductionWithNoAlts/#The-Lean-Language-Reference--Error-Explanations--lean___inductionWithNoAlts"},"/The--mvcgen--tactic/Overview/#The-Lean-Language-Reference--The--mvcgen--tactic--Overview":{"contents":"The workflow of mvcgen consists of the following:\n\n1. Monadic programs are re-interpreted according to a predicate transformer semantics.\n   An instance of WP determines the monad's interpretation.\n   Each program is interpreted as a mapping from arbitrary postconditions to the weakest precondition that would ensure the postcondition.\n   This step is invisible to most users, but library authors who want to enable their monads to work with mvcgen need to understand it.2. Programs are composed from smaller programs.\n   Each statement in a do-block is associated with a predicate transformer, and there are general-purpose rules for combining these statements with sequencing and control-flow operators.\n   A statement with its pre- and postconditions is called a Hoare triple.\n   In a program, the postcondition of each statement should suffice to prove the precondition of the next one, and loops require a specified loop invariant, which is a statement that must be true at the beginning of the loop and at the end of each iteration.\n   Designated specification lemmas associate functions with Hoare triples that specify them.3. Applying the weakest-precondition semantics of a monadic program to a desired proof goal results in the precondition that must hold in order to prove the goal.\n   Any missing steps such as loop invariants or proofs that a statement's precondition implies its postcondition become new subgoals.\n   These missing steps are called the verification conditions.\n   The mvcgen tactic performs this transformation, replacing the goal with its verification conditions.\n   During this transformation, mvcgen uses specification lemmas to discharge proofs about individual statements.4. After supplying loop invariants, many verification conditions can in practice be discharged automatically.\n   Those that cannot can be proven using either a special proof mode or ordinary Lean tactics, depending on whether they are expressed in the logic of program assertions or as ordinary propositions.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic","header":"18.1. Overview","id":"/The--mvcgen--tactic/Overview/#The-Lean-Language-Reference--The--mvcgen--tactic--Overview"},"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Exceptions":{"contents":"If let mut is the do-equivalent of StateT, then early return is the equivalent of ExceptT.\nWe have seen how the mvcgen copes with StateT; here we will look at the program logic's support for ExceptT.Exceptions are the reason why the type of postconditions PostCond α ps is not simply a single condition of type α → Assertion ps for the success case.\nTo see why, suppose the latter was the case, and suppose that program prog throws an exception in a prestate satisfying P.\nShould we be able to prove ⦃P⦄ prog ⦃⇓ r => Q' r⦄?\n(Recall that ⇓ is grammatically similar to fun.)\nThere is no result r, so it is unclear what this proof means for Q'!So there are two reasonable options, inspired by non-termination in traditional program logics: The total correctness interpretation\n\n⦃P⦄ prog ⦃⇓ r => Q' r⦄ asserts that, given P holds, then prog terminates and Q' holds for the result.\n\n The partial correctness interpretation\n\n⦃P⦄ prog ⦃⇓ r => Q' r⦄ asserts that, given P holds, and if prog terminates then Q' holds for the result.\n\nThe notation ⇓ r => Q' r has the total interpretation, while ⇓? r => Q' r has the partial interpretation.In the running example, ⦃P⦄ prog ⦃⇓ r => Q' r⦄ is unprovable, but ⦃P⦄ prog ⦃⇓? r => Q' r⦄ is trivially provable.\nHowever, the binary choice suggests that there is actually a spectrum of correctness properties to express.\nThe notion of postconditions PostCond in Std.Do supports this spectrum.\n\n\n\nFor example, suppose that our Supply of fresh numbers is bounded and we want to throw an exception if the supply is exhausted.\nThen mkFreshN should throw an exception only if the supply is indeed exhausted, as in this implementation:\n\nstructure Supply where\n  counter : Nat\n  limit : Nat\n  property : counter ≤ limit\n\ndef mkFresh : EStateM String Supply Nat := do\n  let supply ← get\n  if h : supply.counter = supply.limit then\n    throw s!\"Supply exhausted: {supply.counter} = {supply.limit}\"\n  else\n    let n := supply.counter\n    have := supply.property\n    set { supply with counter := n + 1, property := by grind }\n    pure n\n\n\nThe following correctness property expresses this:\n\n@[spec]\ntheorem mkFresh_spec (c : Nat) :\n    ⦃fun state => ⌜state.counter = c⌝⦄\n    mkFresh\n    ⦃post⟨fun r state => ⌜r = c ∧ c < state.counter⌝,\n          fun _ state => ⌜c = state.counter ∧ c = state.limit⌝⟩⦄ := by\n  mvcgen [mkFresh] with grind\n\n\nIn this property, the postcondition has two branches: the first covers successful termination, and the second applies when an exception is thrown.\nThe monad's WP instance determines both how many branches the postcondition may have and the number of parameters in each branch: each exception that might be triggered gives rise to an extra branch, and each state gives an extra parameter.\n\nIn this new monad, mkFreshN's implementation is unchanged, except for the type signature:def mkFreshN (n : Nat) : EStateM String Supply (List Nat) := do\n  let mut acc := #[]\n  for _ in [:n] do\n    acc := acc.push (← mkFresh)\n  pure acc.toList\n\n\nHowever, the specification lemma must account for both successful termination and exceptions being thrown, in both the postcondition and the loop invariant:@[spec]\ntheorem mkFreshN_spec (n : Nat) :\n    ⦃⌜True⌝⦄\n    mkFreshN n\n    ⦃post⟨fun r => ⌜r.Nodup⌝,\n          fun _msg state => ⌜state.counter = state.limit⌝⟩⦄ := by\n  mvcgen [mkFreshN]\n  invariants\n  · post⟨fun ⟨xs, acc⟩ state =>\n           ⌜(∀ n ∈ acc, n < state.counter) ∧ acc.toList.Nodup⌝,\n         fun _msg state => ⌜state.counter = state.limit⌝⟩\n  with grind\n\n\nThe final proof uses the specification lemmas and mvcgen, just as before:theorem mkFreshN_correct (n : Nat) :\n    match (mkFreshN n).run s with\n    | .ok    l _  => l.Nodup\n    | .error _ s' => s'.counter = s'.limit := by\n  generalize h : (mkFreshN n).run s = x\n  apply EStateM.of_wp_run_eq h\n  mvcgen\n\n\n\n\nJust as any StateT σ-like monad transformer gives rise to a PostShape.arg σ layer in the ps that WP maps into, any ExceptT ε-like layer gives rise to a PostShape.except ε layer.Every PostShape.arg σ adds another σ → ... layer to the language of Assertions.\nEvery PostShape.except ε leaves the Assertion language unchanged, but adds another exception\ncondition to the postcondition.\nHence the WP instance for EStateM ε σ maps to the PostShape PostShape.except ε (.arg σ .pure), just\nas for ExceptT ε (StateM σ).\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Tutorial: Verifying Imperative Programs Using  mvcgen","header":"18.6.6. Exceptions","id":"/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Exceptions"},"/The-Simplifier/Rewrite-Rules/#simp-rewrites":{"contents":"The simplifier has three kinds of rewrite rules:\n\n Declarations to unfold\n\nThe simplifier will only unfold reducible definitions by default.\n  However, a rewrite rule can be added for any semireducible or irreducible definition that causes the simplifier to unfold it as well.\n  When the simplifier is running in definitional mode (dsimp and its variants), definition unfolding only replaces the defined name with its value; otherwise, it also uses the equational lemmas produced by the equation compiler.\n\n Equational lemmas\n\nThe simplifier can treat equality proofs as rewrite rules, in which case the left side of the equality will be replaced with the right. These equational lemmas may have any number of parameters. The simplifier instantiates parameters to make the left side of the equality match the goal, and it performs a proof search to instantiate any additional parameters.\n\n Simplification procedures\n\nThe simplifier supports simplification procedures, known as simprocs, that use Lean metaprogramming to perform rewrites that can't be efficiently specified using equations. Lean includes simprocs for the most important operations on built-in types.\n\n\n\n\n\nDue to propositional extensionality, equational lemmas can rewrite propositions to simpler, logically equivalent propositions.\nWhen the simplifier rewrites a proof goal to True, it automatically closes it.\nAs a special case of equational lemmas, propositions other than equality can be tagged as rewrite rules\nThey are preprocessed into rules that rewrite the proposition to True.\n\nRewriting PropositionsWhen asked to simplify an equality of pairs:α β : Type\nw y : α\nx z : β\n⊢ (w, x) = (y, z)\nsimp yields a conjunction of equalities:α β : Type\nw y : α\nx z : β\n⊢ w = y ∧ x = z\nThe default simp set contains Prod.mk.injEq, which shows the equivalence of the two statements:Prod.mk.injEq.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) :\n  ∀ (fst_1 : α) (snd_1 : β),\n    ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 ∧ snd = snd_1)\n\n\nIn addition to rewrite rules, simp has a number of built-in reduction rules, controlled by the config parameter.\nEven when the simp set is empty, simp can replace let-bound variables with their values, reduce match expressions whose discriminants are constructor applications, reduce structure projections applied to constructors, or apply lambdas to their arguments.\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.2. Rewrite Rules","id":"/The-Simplifier/Rewrite-Rules/#simp-rewrites"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Documentation":{"contents":"* #6886 adds recommended spellings for many notations defined in Lean\ncore, using the recommended_spelling command from #6869.* #6950 adds a style guide and a naming convention for the standard\nlibrary.* #6962 improves the doc-string for List.toArray.* #6998 modifies the Prop docstring to point out that every\nproposition is propositionally equal to either True or False. This\nwill help point users toward seeing that Prop is like Bool.* #7026 clarifies the styling of do blocks, and enhanes the naming\nconventions with information about the ext and mono name components\nas well as advice about primed names and naming of simp sets.* #7111 extends the standard library style guide with guidance on\nuniverse variables, notations and Unicode usage, and structure\ndefinitions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Documentation","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Documentation"}});