window.docContents[6].resolve({"/Basic-Types/Fixed-Precision-Integers/#fixed-ints":{"contents":"Lean's standard library includes the usual assortment of fixed-width integer types.\nFrom the perspective of formalization and proofs, these types are wrappers around bitvectors of the appropriate size; the wrappers ensure that the correct implementations of e.g. arithmetic operations are applied.\nIn compiled code, they are represented efficiently: the compiler has special support for them, as it does for other fundamental types.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"20.4. Fixed-Precision Integers","id":"/Basic-Types/Fixed-Precision-Integers/#fixed-ints"},"/Iterators/Iterator-Definitions/#The-Lean-Language-Reference--Iterators--Iterator-Definitions--Loops":{"contents":"IteratorLoop α m provides efficient implementations of loop-based consumers for α-based\niterators. The basis is a ForIn-style loop construct.Its behavior for well-founded loops is fully characterized by the LawfulIteratorLoop type class.This class is experimental and users of the iterator API should not explicitly depend on it.\nThey can, however, assume that consumers that require an instance will work for all iterators\nprovided by the standard library.\n\nThis is the default implementation of the IteratorLoop class.\nIt simply iterates through the iterator using IterM.step. For certain iterators, more efficient\nimplementations are possible and should be used instead.\n\nAsserts that a given IteratorLoop instance is equal to IteratorLoop.defaultImplementation.\n(Even though equal, the given instance might be vastly more efficient.)\n\n","context":"Lean Reference\u0009Iterators\u0009Iterator Definitions","header":"21.2.4. Loops","id":"/Iterators/Iterator-Definitions/#The-Lean-Language-Reference--Iterators--Iterator-Definitions--Loops"},"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-qlia":{"contents":"The solver is complete for linear integer arithmetic.\nHowever, the search can become vast with very few constraints, but the solver was not designed to perform massive case-analysis.\nThe qlia option to grind reduces the search space by instructing the solver to accept rational solutions.\nWith this option, the solver is likely to be faster, but it is incomplete.\n\nRational SolutionsThe following example has a rational solution, but does not have integer solutions:example {x y : Int} :\n    27 ≤ 13 * x + 11 * y →\n    13 * x + 11 * y ≤ 30 →\n    -10 ≤ 9 * x - 7 * y →\n    9 * x - 7 * y > 4 := by\n  grind\nBecause it uses the rational solution, grind fails to refute the negation of the goal when +qlia is specified:example {x y : Int} :\n    27 ≤ 13 * x + 11 * y →\n    13 * x + 11 * y ≤ 30 →\n    -10 ≤ 9 * x - 7 * y →\n    9 * x - 7 * y > 4 := by\n  grind +qlia\n`grind` failed\ncase grind\nx y : Int\nh : -13 * x + -11 * y + 27 ≤ 0\nh_1 : 13 * x + 11 * y + -30 ≤ 0\nh_2 : -9 * x + 7 * y + -10 ≤ 0\nh_3 : 9 * x + -7 * y + -4 ≤ 0\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n  [cutsat] Assignment satisfying linear constraints\n    [assign] x := 62/117\n    [assign] y := 2\nThe rational model constructed by the solver is in the section Assignment satisfying linear constraints in the goal diagnostics.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.1. Rational Solutions","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-qlia"}});