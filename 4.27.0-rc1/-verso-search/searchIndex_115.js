window.docContents[115].resolve({"/Definitions/Recursive-Definitions/#partial-correctness-theorem":{"contents":"For every function defined as a partial fixpoint, Lean proves that the defining equation is satisfied.\nThis enables proofs by rewriting.\nHowever, these equational theorems are not sufficient for reasoning about the behavior of the function on arguments for which the function specification does not terminate.\nCode paths that lead to infinite recursion at runtime would end up as infinite chains of rewrites in a potential proof.\n\nPartial fixpoints in suitable monads, on the other hand, provide additional theorems that map the undefined values from non-termination to suitable values in the monad.\nIn the Option monad, then partial fixpoint equals Option.none on all function inputs for which the defining equation specifies non-termination.\nFrom this fact, Lean proves a partial correctness theorem for the function which allows facts to be concluded when the function's result is Option.some.\n\nPartial Correctness TheoremRecall List.findIndex from an earlier example:def List.findIndex (xs : List α) (p : α → Bool) : Option Nat :=\n  match xs with\n  | [] => none\n  | x::ys =>\n    if p x then\n      some 0\n    else\n      (· + 1) <$> List.findIndex ys p\npartial_fixpoint\nWith this function definition, Lean automatically proves the following partial correctness theorem:List.findIndex.partial_correctness.{u_1} {α : Type u_1}\n  (p : α → Bool)\n  (motive : List α → Nat → Prop)\n  (h :\n    ∀ (findIndex : List α → Option Nat),\n      (∀ (xs : List α) (r : Nat), findIndex xs = some r → motive xs r) →\n        ∀ (xs : List α) (r : Nat),\n          (match xs with\n              | [] => none\n              | x :: ys =>\n                if p x = true then some 0\n                else (fun x => x + 1) <$> findIndex ys) = some r →\n            motive xs r)\n  (xs : List α) (r : Nat) :\n  xs.findIndex p = some r →\n    motive xs r\nHere, the motive is a relation between the parameter and return types of List.findIndex, with the Option removed from the return type.\nIf, when given an arbitrary partial function with a signature that's compatible with List.findIndex, the following hold:* the motive is satisfied for all inputs for which the arbitrary function returns a value (rather than none),* taking one rewriting step with the defining equation, in which the recursive calls are replaced by the arbitrary function, also implies the satisfaction of the motivethen the motive is satsified for all inputs for which the List.findIndex returns some.The partial correctness theorem is a reasoning principle.\nIt can be used to prove that the resulting number is a valid index in the list and that the predicate holds for that index:theorem List.findIndex_implies_pred\n    (xs : List α) (p : α → Bool) :\n    xs.findIndex p = some i →\n    ∃x, xs[i]? = some x ∧ p x := by\n  apply List.findIndex.partial_correctness\n          (motive := fun xs i => ∃ x, xs[i]? = some x ∧ p x)\n  intro findIndex ih xs r hsome\n  split at hsome\n  next => contradiction\n  next x ys =>\n    split at hsome\n    next =>\n      have : r = 0 := by simp_all\n      simp_all\n    next =>\n      simp only [Option.map_eq_map, Option.map_eq_some_iff] at hsome\n      obtain ⟨r', hr, rfl⟩ := hsome\n      specialize ih _ _ hr\n      simpa\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.3. Partial Correctness Theorems","id":"/Definitions/Recursive-Definitions/#partial-correctness-theorem"},"/Error-Explanations/lean___synthInstanceFailed/#The-Lean-Language-Reference--Error-Explanations--lean___synthInstanceFailed":{"contents":"\n\nType classes are the mechanism that Lean and many other\nprogramming languages use to handle overloaded operations. The code that handles a particular\noverloaded operation is an instance of a typeclass; deciding which instance to use for a given\noverloaded operation is called synthesizing an instance.\n\nAs an example, when Lean encounters an expression x + y where x and y both have type Int,\nit is necessary to look up how it should add two integers and also look up what the resulting type\nwill be. This is described as synthesizing an instance of the type class HAdd Int Int t for some\ntype t.\n\nMany failures to synthesize an instance of a type class are the result of using the wrong binary\noperation. Both success and failure are not always straightforward, because some instances are\ndefined in terms of other instances, and Lean must recursively search to find appropriate instances.\nIt's possible to inspect Lean's instance synthesis](https://lean-lang.org/doc/reference/4.27.0-rc1/find/?domain=Verso.Genre.Manual.section&name=instance-search), and this\ncan be helpful for diagnosing tricky failures of type class instance synthesis.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.synthInstanceFailed","id":"/Error-Explanations/lean___synthInstanceFailed/#The-Lean-Language-Reference--Error-Explanations--lean___synthInstanceFailed"},"/The--mvcgen--tactic/#mvcgen-tactic":{"contents":"The mvcgen tactic implements a monadic verification condition generator:\nIt breaks down a goal involving a program written using Lean's imperative do notation into a number of smaller verification conditions (VCs) that are sufficient to prove the goal.\nIn addition to a reference that describes the use of mvcgen, this chapter includes a tutorial that can be read independently of the reference.\n\nIn order to use the mvcgen tactic, Std.Tactic.Do must be imported and the namespace Std.Do must be opened.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"18. The  mvcgen  tactic","id":"/The--mvcgen--tactic/#mvcgen-tactic"},"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Stateful-Values":{"contents":"Just as SPred represents predicate over states, SVal represents a value that is derived from a state.\n\nA value indexed by a curried tuple of states.Example:example : SVal [Nat, Bool] String = (Nat → Bool → String) := rfl\n\n\nGets the top-most state of type σ from an SVal.\n\nA tuple capturing the whole state of an SVal.\n\nCurries a function taking a StateTuple into an SVal.\n\nUncurries an SVal into a function taking a StateTuple.\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Predicate Transformers\u0009Stateful Predicates","header":"18.2.1.4. Stateful Values","id":"/The--mvcgen--tactic/Predicate-Transformers/#The-Lean-Language-Reference--The--mvcgen--tactic--Predicate-Transformers--Stateful-Predicates--Stateful-Values"}});