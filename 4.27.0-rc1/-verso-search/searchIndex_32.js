window.docContents[32].resolve({"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Booleans-and-Propositions":{"contents":"Both Bool and Prop represent notions of truth.\nFrom a purely logical perspective, they are equivalent: propositional extensionality means that there are fundamentally only two propositions, namely True and False.\nHowever, there is an important pragmatic difference: Bool classifies values that can be computed by programs, while Prop classifies statements for which code generation doesn't make sense.\nIn other words, Bool is the notion of truth and falsehood that's appropriate for programs, while Prop is the notion that's appropriate for mathematics.\nBecause proofs are erased from compiled programs, keeping Bool and Prop distinct makes it clear which parts of a Lean file are intended for computation.\n\n\n\nA Bool can be used wherever a Prop is expected.\nThere is a coercion from every Bool b to the proposition b = true.\nBy propext, true = true is equal to True, and false = true is equal to False.\n\nNot every proposition can be used by programs to make run-time decisions.\nOtherwise, a program could branch on whether the Collatz conjecture is true or false!\nMany propositions, however, can be checked algorithmically.\nThese propositions are called decidable propositions, and have instances of the Decidable type class.\nThe function Decidable.decide converts a proof-carrying Decidable result into a Bool.\nThis function is also a coercion from decidable propositions to Bool, so (2 = 2 : Bool) evaluates to true.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans","header":"20.11.2. Booleans and Propositions","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Booleans-and-Propositions"},"/Definitions/Recursive-Definitions/#partial-fixpoint-monadic":{"contents":"Defining a function as a partial fixpoint is more powerful if the function's return type is a monad that is an instance of Lean.Order.MonoBind, such as Option.\nIn this case, recursive call are not restricted to tail-positions, but may also occur inside higher-order monadic functions such as bind and List.mapM.\n\nThe set of higher-order functions for which this works is extensible, so no exhaustive list is given here.\nThe aspiration is that a monadic recursive function definition that is built using abstract monadic operations like bind, but that does not open the abstraction of the monad (e.g. by matching on the Option value), is accepted.\nIn particular, using do-notation should work.\n\nMonadic functionsThe following function implements the Ackermann function in the Option monad, and is accepted without an (explicit or implicit) termination proof:def ack : (n m : Nat) → Option Nat\n  | 0,   y   => some (y+1)\n  | x+1, 0   => ack x 1\n  | x+1, y+1 => do ack x (← ack (x+1) y)\npartial_fixpoint\nRecursive calls may also occur within higher-order functions such as List.mapM, if they are set up appropriately, and do-notation:structure Tree where cs : List Tree\n\ndef Tree.rev (t : Tree) : Option Tree := do\n  Tree.mk (← t.cs.reverse.mapM (Tree.rev ·))\npartial_fixpoint\n\ndef Tree.rev' (t : Tree) : Option Tree := do\n  let mut cs := []\n  for c in t.cs do\n    cs := (← c.rev') :: cs\n  return Tree.mk cs\npartial_fixpoint\nPattern matching on the result of the recursive call will prevent the definition by partial fixpoint from going through:def List.findIndex (xs : List α) (p : α → Bool) : Option Nat :=\n  match xs with\n  | [] => none\n  | x::ys =>\n    if p x then\n      some 0\n    else\n      match List.findIndex ys p with\n      | none => none\n      | some r => some (r + 1)\npartial_fixpoint\nCould not prove 'List.findIndex' to be monotone in its recursive calls:\n  Cannot eliminate recursive call `List.findIndex ys p` enclosed in\n    match ys✝.findIndex p with\n    | none => none\n    | some r => some (r + 1)\nIn this particular case, using Functor.map instead of explicit pattern matching helps:def List.findIndex (xs : List α) (p : α → Bool) : Option Nat :=\n  match xs with\n  | [] => none\n  | x::ys =>\n    if p x then\n      some 0\n    else\n      (· + 1) <$> List.findIndex ys p\npartial_fixpoint\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.2. Monadic functions","id":"/Definitions/Recursive-Definitions/#partial-fixpoint-monadic"},"/Error-Explanations/lean___inductionWithNoAlts/#The-Lean-Language-Reference--Error-Explanations--lean___inductionWithNoAlts--Examples":{"contents":"Adding Explicit Cases to an Induction Prooftheorem zero_mul (m : Nat) : 0 * m = 0 := by\n  induction m with n n_ih\n  rw [Nat.mul_zero]\n  rw [Nat.mul_succ]\n  rw [Nat.add_zero]\n  rw [n_ih]\nunknown tactic\ntheorem zero_mul (m : Nat) : 0 * m = 0 := by\n  induction m with\n  | zero =>\n    rw [Nat.mul_zero]\n  | succ n n_ih =>\n    rw [Nat.mul_succ]\n    rw [Nat.add_zero]\n    rw [n_ih]\nThe broken example has the structure of a correct proof in the Natural Numbers Game, and this\nproof will work if you import Mathlib and replace induction with induction'. Induction tactics\nin basic Lean expect the with keyword to be followed by a series of cases, and the names for\nthe inductive case are provided in the succ case rather than being provided up-front.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.inductionWithNoAlts","header":"Examples","id":"/Error-Explanations/lean___inductionWithNoAlts/#The-Lean-Language-Reference--Error-Explanations--lean___inductionWithNoAlts--Examples"},"/releases/v4.11.0/#release-v4___11___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.11.0 (2024-09-02)","id":"/releases/v4.11.0/#release-v4___11___0"},"/releases/v4.20.0/#release-v4___20___0":{"contents":"For this release, 346 changes landed. In addition to the 108 feature additions and 85 fixes listed below there were 6 refactoring changes, 7 documentation improvements, 8 performance improvements, 4 improvements to the test suite and 126 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.20.0 (2025-06-02)","id":"/releases/v4.20.0/#release-v4___20___0"},"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--DevOps":{"contents":"* #3536 and #3833\nadd a checklist for the release process.* #3600 runs nix-ci more uniformly.* #3612 avoids argument limits when building on Windows.* #3682 builds Lean's .o files in parallel to rest of core.* #3601\nchanges the way Lean is built on Windows (see breaking changes below).\nAs a result, Lake now dynamically links executables with supportInterpreter := true on Windows\nto libleanshared.dll and libInit_shared.dll. Therefore, such executables will not run\nunless those shared libraries are co-located with the executables or part of PATH.\nRunning the executable via lake exe will ensure these libraries are part of PATH.In a related change, the signature of the nativeFacets Lake configuration options has changed\nfrom a static Array to a function (shouldExport : Bool) → Array.\nSee its docstring or Lake's README for further details on the changed option.* #3690 marks \"Build matrix complete\" as canceled if the build is canceled.* #3700, #3702,\n#3701, #3834,\n#3923: fixes and improvements for std and mathlib CI.* #3712 fixes nix build . on macOS.* #3717 replaces shell.nix in devShell with flake.nix.* #3715 and #3790 add test result summaries.* #3971 prevents stage0 changes via the merge queue.* #3979 adds handling for changes-stage0 label.* #3952 adds a script to summarize GitHub issues.* 18a699\nfixes asan linking\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.8.0 (2024-06-05)","header":"DevOps","id":"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--DevOps"}});