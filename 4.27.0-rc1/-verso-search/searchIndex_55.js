window.docContents[55].resolve({"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Task-Results":{"contents":"Blocks the current thread until the given task has finished execution, and then returns the result\nof the task. If the current thread is itself executing a (non-dedicated) task, the maximum\nthreadpool size is temporarily increased by one while waiting so as to ensure the process cannot\nbe deadlocked by threadpool starvation. Note that when the current thread is unblocked, more tasks\nthan the configured threadpool size may temporarily be running at the same time until sufficiently\nmany tasks have finished.Task.map and Task.bind should be preferred over Task.get for setting up task dependencies\nwhere possible as they do not require temporarily growing the threadpool in this way. In\nparticular, calling Task.get in a task continuation with (sync := true) will panic as the\ncontinuation is decidedly not \"cheap\" in this case and deadlocks may otherwise occur. The\nwaited-upon task should instead be returned and unwrapped using Task.bind/IO.bindTask.\n\nWaits for the task to finish, then returns its result.\n\nWaits until any of the tasks in the list has finished, then return its result.\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads","header":"15.11.2. Task Results","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Task-Results"},"/Run-Time-Code/Boxing/#boxing":{"contents":"Lean values may be represented at runtime in two ways:* Boxed values may be pointers to heap values or require shifting and masking.* Unboxed values are immediately available.\n\nBoxed values are either a pointer to an object, in which case the lowest-order bit is 0, or an immediate value, in which case the lowest-order bit is 1 and the value is found by shifting the representation to the right by one bit.\n\nTypes with an unboxed representation, such as UInt8 and enum inductive types, are represented as the corresponding C types in contexts where the compiler can be sure that the value has said type.\nIn some contexts, such as generic container types like Array, otherwise-unboxed values must be boxed prior to storage.\nIn other words, Bool.not is called with and returns unboxed uint8_t values because the enum inductive type Bool has an unboxed representation, but the individual Bool values in an Array Bool are boxed.\nA field of type Bool in an inductive type's constructor is represented unboxed, while Bools stored in polymorphic fields that are instantiated as Bool are boxed.\n\n","context":"Lean Reference\u0009Run-Time Code","header":"23.1. Boxing","id":"/Run-Time-Code/Boxing/#boxing"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Highlights":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0 (2025-12-13)","header":"Highlights","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-_LPAR_2025-12-13_RPAR_--Highlights"},"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Library":{"contents":"* #8406 adds lemmas of the form getElem_swapIfInBounds* and deprecates\ngetElem_swap'.* #9302 modifies Option.instDecidableEq and Option.decidableEqNone\nso that the latter can be made into a global instance without causing\ndiamonds. It also adds Option.decidableNoneEq.* #10204 changes the interface of the ForIn, ForIn', and ForM\ntype classes to not take a Monad m parameter. This is a breaking change\nfor most downstream instances, which will now need to assume\n[Monad m].* #10945 adds Std.Tricho r, a type class for relations which identifies\nthem as trichotomous. This is preferred to Std.Antisymm (¬ r · ·) in\nall cases (which it is equivalent to).* #11038 introduces a new fixpoint combinator,\nWellFounded.extrinsicFix. A termination proof, if provided at all, can\nbe given extrinsically, i.e., looking at the term from the outside, and\nis only required if one intends to formally verify the behavior of the\nfixpoint. The new combinator is then applied to the iterator API.\nConsumers such as toList or ForIn no longer require a proof that the\nunderlying iterator is finite. If one wants to ensure the termination of\nthem intrinsically, there are strictly terminating variants available\nas, for example, it.ensureTermination.toList instead of it.toList.* #11112 adds intersection operation on DHashMap/HashMap/HashSet\nand provides several lemmas about its behaviour.* #11141 provides a polymorphic ForIn instance for slices and an MPL\nspec lemma for the iteration over slices using for ... in. It also\nprovides a version specialized to Subarray.* #11165 provides intersection on DTreeMap/TreeMap/TreeSetand\nprovides several lemmas about it.* #11178 provides more lemmas about Subarray and ListSlice and it\nalso adds support for subslices of these two types of slices.* #11180 redefines String.take and variants to operate on\nString.Slice. While previously functions returning a substring of the\ninput sometimes returned String and sometimes returned\nSubstring.Raw, they now uniformly return String.Slice.* #11212 adds support for difference operation for\nDHashMap/HashMap/HashSet and proves several lemmas about it.* #11218 renames String.offsetOfPos to String.Pos.Raw.offsetOfPos to\nalign with the other String.Pos.Raw operations.* #11222 implements elabToSyntax for creating scoped syntax s : Syntax for an arbitrary elaborator el : Option Expr -> TermElabM Expr\nsuch that elabTerm s = el.* #11223 adds missing lemmas relating emptyWithCapacity/empty and\ntoList/keys/values for DHashMap/HashMap/HashSet.* #11231 adds several lemmas that relate\ngetMin/getMin?/getMin!/getMinD and insertion to the empty\n(D)TreeMap/TreeSet and their extensional variants.* #11232 deprecates String.toSubstring in favor of\nString.toRawSubstring (cf. #11154).* #11235 registers a node kind for Lean.Parser.Term.elabToSyntax in\norder to support the Lean.Elab.Term.elabToSyntax functionality without\nregistering a dedicated parser for user-accessible syntax.* #11237 fixes the error thrown by UInt64.fromJson? and\nUSize.fromJson? to use the missing s!.* #11240 renames String.ValidPos to String.Pos, String.endValidPos\nto String.endPos and String.startValidPos to String.startPos.* #11241 provides intersection operation for\nExtDHashMap/ExtHashMap/ExtHashSet and proves several lemmas about\nit.* #11242 significantly changes the signature of the ToIterator type\nclass. The obtained iterators' state is no longer dependently typed and\nis an outParam instead of being bundled inside the class. Among other\nbenefits, simp can now rewrite inside of Slice.toList and\nSlice.toArray. The downside is that we lose flexibility. For example,\nthe former combinator-based implementation of Subarray's iterators is\nno longer feasible because the states are dependently typed. Therefore,\nthis PR provides a hand-written iterator for Subarray, which does not\nrequire a dependently typed state and is faster than the previous one.* #11243 adds ofArray to DHashMap/HashMap/HashSet and proves a\nsimp lemma allowing to rewrite ofArray to ofList.* #11250 introduces a function String.split which is based on\nString.Slice.split and therefore supports all pattern types and\nreturns a Std.Iter String.Slice.* #11255 reduces the allocations when using string patterns. In\nparticular\nstartsWith, dropPrefix?, endsWith, dropSuffix? are optimized.* #11263 fixes several memory leaks in the new String API.* #11266 adds BEq instance for DHashMap/HashMap/HashSet and their\nextensional variants and proves lemmas relating it to the equivalence of\nhashmaps/equality of extensional variants.* #11267 renames congruence lemmas for union on\nDHashMap/HashMap/HashSet/DTreeMap/TreeMap/TreeSet to fit the\nconvention of being in the Equiv namespace.* #11276 cleans up the API around String.find and moves it uniformly to\nthe new position types String.ValidPos and String.Slice.Pos* #11281 adds a few deprecations for functions that never existed but\nthat are still helpful for people migrating their code post-#11180.* #11282 adds the alias String.Slice.any for String.Slice.contains.* #11285 adds Std.Slice.Pattern instances for p : Char -> Prop as\nlong as DecidablePred p, to allow things like \"hello\".dropWhile (· = 'h').* #11286 adds a function String.Slice.length, with the following\ndeprecation string: There is no constant-time length function on slices.\nUse s.positions.count instead, or isEmpty if you only need to know\nwhether the slice is empty.* #11289 redefines String.foldl, String.isNat to use their\nString.Slice counterparts.* #11290 renames String.replaceStartEnd to String.slice,\nString.replaceStart to String.sliceFrom, and String.replaceEnd to\nString.sliceTo, and similar for the corresponding functions on\nString.Slice.* #11299 add many @[grind] annotations for Fin, and updates the\ntests.* #11308 redefines front and back on String to go through\nString.Slice and adds the new String functions front?, back?,\npositions, chars, revPositions, revChars, byteIterator,\nrevBytes, lines.* #11316 adds grind_pattern Exists.choose_spec => P.choose.* #11317 adds grind_pattern Subtype.property => self.val.* #11321 provides specialized lemmas about Nat ranges, including simp\nannotations and induction principles for proving properties for all\nranges.* #11327 adds two lemmas to prove a / c < b / c.* #11341 adds a coercion from String to String.Slice.* #11343 renames String.bytes to String.toByteArray.* #11354 adds simple lemmas that show that searching from a position in a\nstring returns something that is at least that position.* #11357 updates the foldr, all, any and contains functions on\nString to be defined in terms of their String.Slice counterparts.* #11358 adds String.Slice.toInt? and variants.* #11376 aims to improve the performance of String.contains,\nString.find, etc. when using patterns of type Char or Char -> Bool\nby moving the needle out of the iterator state and thus working around\nmissing unboxing in the compiler.* #11380 renames String.Slice.Pos.ofSlice to String.Pos.ofToSlice to\nadhere with the (yet-to-be documented) naming convention for mapping\npositions to positions. It then adds several new functions so that for\nevery way to construct a slice from a string and slice, there are now\nfunctions for mapping positions forwards and backwards along this\nconstruction.* #11384 adds the necessary instances for grind to reason about\nString.Pos.Raw, String.Pos and String.Slice.Pos.* #11399 adds support for the difference operation for\nExtDHashMap/ExtHashMap/ExtHashSet and proves several lemmas about\nit.* #11404 adds BEq instance for DTreeMap/TreeMap/TreeSet and their\nextensional variants and proves lemmas relating it to the equivalence of\nhashmaps/equality of extensional variants.* #11407 adds the difference operation on DTreeMap/TreeMap/TreeSet\nand proves several lemmas about it.* #11421 adds decidable equality to DHashMap/HashMap/HashSet and\ntheir extensional variants.* #11439 performs minor maintenance on the String API* #11448 moves the Inhabited instances in constant DTreeMap (and\nrelated) queries, such as Const.get!, where the Inhabited instance\ncan be provided before proving a key.* #11452 adds lemmas stating that if a get operation returns a value,\nthen the queried key must be contained in the collection. These lemmas\nare added for HashMap and TreeMap-based collections, with a similar\nlemma also added for Init.getElem.* #11465 fixes various typos across the codebase in documentation and\ncomments.* #11503 marks Char -> Bool patterns as default instances for string\nsearch. This means that things like \" \".find (·.isWhitespace) can now\nbe elaborated without error.* #11521 fixes a segmentation fault that was triggered when initializing\na new timer and a reset was called at the same time.* #11527 adds decidable equality to DTreeMap/TreeMap/TreeSet and\ntheir extensional variants.* #11528 adds lemmas relating minKey? and min? on the keys list for\nall DTreeMap and other containers derived from it.* #11542 removes @[grind =] from List.countP_eq_length_filter and\nArray.countP_eq_size_filter, as users reported this was problematic.* #11548 adds Lean.ToJson and Lean.FromJson instances for\nString.Slice.* #11565 adds lemmas that relate insert/insertIfNew and toList on\nDTreeMap/DHashMap-derived containers.* #11574 adds a lemma that the cast of a natural number into any ordered\nring is non-negative. We can't annotate this directly for grind, but\nwill probably add this to grind's linarith internals.* #11578 refactors the usage of get operation on\nHashMap/TreeMap/ExtHashMap/ExtTreeMap to getElem instance.* #11591 adds missing lemmas about how ReaderT.run, OptionT.run,\nStateT.run, and ExceptT.run interact with MonadControl operations.* #11596 adds @[suggest_for ℤ] on Int and @[suggest_for ℚ] on\nRat, following the pattern established by @[suggest_for ℕ] on Nat\nin #11554.* #11600 adds a few lemmas about EStateM.run on basic operations.* #11625 adds @[expose] to decidable_of_bool so that\nproofs-by-decide elsewhere that reduce to decidable_of_bool continue\nto reduce.* #11654 updates the grind docstring. It was still mentioning cutsat\nwhich has been renamed to lia. This issue was reported during ItaLean.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.27.0-rc1 (2025-12-14)","header":"Library","id":"/releases/v4.27.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___27___0-rc1-_LPAR_2025-12-14_RPAR_--Library"}});