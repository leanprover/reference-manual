window.docContents[210].resolve({"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Size":{"contents":"Returns the number of bytes in the byte array.This is the number of bytes actually in the array, as distinct from its capacity, which is the\namount of memory presently allocated for the array.\n\nRetrieves the size of the array as a platform-specific fixed-width integer.Because USize is big enough to address all memory on every platform that Lean supports,\nthere are in practice no ByteArrays that have more elements that USize can count.\n\nReturns true when s contains zero bytes.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"20.17.1.2. Size","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Size"},"/Error-Explanations/lean___unknownIdentifier/#The-Lean-Language-Reference--Error-Explanations--lean___unknownIdentifier--Examples":{"contents":"Missing Importdef inventory :=\n  Std.HashSet.ofList [(\"apples\", 3), (\"bananas\", 4)]\nUnknown identifier `Std.HashSet.ofList`\npublic import Std.Data.HashSet.Basic\n\npublic section\n\ndef inventory :=\n  Std.HashSet.ofList [(\"apples\", 3), (\"bananas\", 4)]\nThe constant Std.HashSet.ofList is defined in the Std.Data.HashSet.Basic module, which has not\nbeen imported in the original example. This import is suggested by the unknown identifier code\naction; once it is added, this example compiles.\n\nVariable Not in Scopeexample (s : IO.FS.Stream) := do\n  IO.withStdout s do\n    let text := \"Hello\"\n    IO.println text\n  IO.println s!\"Wrote '{text}' to stream\"\nUnknown identifier `text`\nexample (s : IO.FS.Stream) := do\n  let text := \"Hello\"\n  IO.withStdout s do\n    IO.println text\n  IO.println s!\"Wrote '{text}' to stream\"\nAn unknown identifier error occurs on the last line of this example because the variable text is\nnot in scope. The let-binding on the third line is scoped to the inner do block and cannot be\naccessed in the outer do block. Moving this binding to the outer do block—from which it remains\nin scope in the inner block as well—resolves the issue.\n\nMissing Namespaceinductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\ndef red : Color :=\n  rgb 255 0 0\nUnknown identifier `rgb`\ninductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\ndef red : Color :=\n  Color.rgb 255 0 0\ninductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\nopen Color in\ndef red : Color :=\n  rgb 255 0 0\nIn this example, the identifier rgb on the last line does not resolve to the Color constructor\nof that name. This is because the constructor's name is actually Color.rgb: all constructors of an\ninductive type have names in that type's namespace. Because the Color namespace is not open, the\nidentifier rgb cannot be used without its namespace prefix.One way to resolve this error is to provide the fully qualified constructor name Color.rgb; the\ndotted-identifier notation .rgb can also be used, since the expected type of .rgb 255 0 0 is\nColor. Alternatively, one can open the Color namespace and continue to omit the Color prefix\nfrom the identifier.\n\nProtected Constant Name Without Namespace Prefixprotected def A.x := ()\n\nopen A\n\nexample := x\nUnknown identifier `x`\nprotected def A.x := ()\n\nopen A\n\nexample := A.x\nprotected def A.x := ()\n\nopen A (x)\n\nexample := x\nIn this example, because the constant A.x is protected, it cannot be referred to by the suffix\nx even with the namespace A open. Therefore, the identifier x fails to resolve. Instead, to\nrefer to a protected constant, it is necessary to include at least its innermost namespace—in this\ncase, A. Alternatively, the restricted opening syntax—demonstrated in the second corrected\nexample—allows a protected constant to be referred to by its unqualified name, without opening the\nremainder of the namespace in which it occurs (see the manual section on\nNamespaces and Sections for details).\n\nUnresolvable Name Inferred by Dotted-Identifier Notationdef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  .toNat (b₁ || b₂)\nUnknown constant `Nat.toNat`\n\nNote: Inferred this name from the expected resulting type of `.toNat`:\n  Nat\ndef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  (b₁ || b₂).toNat\ndef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  Bool.toNat (b₁ || b₂)\nIn this example, the dotted-identifier notation .toNat causes Lean to infer an unresolvable\nname (Nat.toNat). The namespace used by dotted-identifier notation is always inferred from\nthe expected type of the expression in which it occurs, which—due to the type annotation on\ndisjoinToNat—is Nat in this example. To use the namespace of an argument's type—as the author of\nthis code seemingly intended—use generalized field notation as shown in the first corrected\nexample. Alternatively, the correct namespace can be explicitly specified by writing the fully\nqualified function name.\n\nAuto-bound variablesset_option relaxedAutoImplicit false in\ndef thisBreaks (x : α₁) (y : size₁) := ()\n\nset_option autoImplicit false in\ndef thisAlsoBreaks (x : α₂) (y : size₂) := ()\nset_option relaxedAutoImplicit true in\ndef thisWorks (x : α₁) (y : size₁) := ()\n\nset_option autoImplicit true in\ndef thisAlsoWorks (x : α₂) (y : size₂) := ()\nset_option relaxedAutoImplicit false in\ndef thisWorks {size₁} (x : α₁) (y : size₁) := ()\n\nset_option autoImplicit false in\ndef thisAlsoWorks {α₂ size₂} (x : α₂) (y : size₂) := ()\nLean's default behavior, when it encounters an identifier it can't identify in the type of a\ndefinition, is to add automatic implicit parameters\nfor those unknown identifiers. However, many files or projects disable this feature by setting the\nautoImplicit or relaxedAutoImplicit options to false.Without re-enabling the autoImplicit or relaxedAutoImplicit options, the easiest way to fix\nthis error is to add the unknown identifiers as ordinary implicit parameters\nas shown in the example above.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.unknownIdentifier","header":"Examples","id":"/Error-Explanations/lean___unknownIdentifier/#The-Lean-Language-Reference--Error-Explanations--lean___unknownIdentifier--Examples"},"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Consuming-Monadic-Iterators":{"contents":"Iterates over the whole iterator, applying the monadic effects of each step, discarding all\nemitted values.\n\nFolds a function over an iterator from the left, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in order, using f.It is equivalent to it.toList.foldl.\n\nFolds a monadic function over an iterator from the left, accumulating a value starting with init.\nThe accumulated value is combined with the each element of the list in order, using f.The monadic effects of f are interleaved with potential effects caused by the iterator's step\nfunction. Therefore, it may not be equivalent to (← it.toList).foldlM.\n\nSteps through the whole iterator, counting the number of outputs emitted.Performance:This function's runtime is linear in the number of steps taken by the iterator.\n\nReturns ULift.up true if the pure predicate p returns true for\nany element emitted by the iterator it.O(|it|). Short-circuits upon encountering the first match. The outputs of it are\nexamined in order of iteration.\n\nReturns ULift.up true if the monadic predicate p returns ULift.up true for\nany element emitted by the iterator it.O(|it|). Short-circuits upon encountering the first match. The outputs of it are\nexamined in order of iteration.\n\nReturns ULift.up true if the pure predicate p returns true for\nall elements emitted by the iterator it.O(|it|). Short-circuits upon encountering the first mismatch. The outputs of it are\nexamined in order of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.toListRev always terminates after finitely many steps.\n\nReturns ULift.up true if the monadic predicate p returns ULift.up true for\nall elements emitted by the iterator it.O(|it|). Short-circuits upon encountering the first mismatch. The outputs of it are\nexamined in order of iteration.\n\nReturns the first output of the iterator for which the predicate p returns true, or none if\nno such output is found.O(|it|). Short-circuits upon encountering the first match. The elements in it are examined in\norder of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.find? always terminates after finitely many steps.Examples:* ([7, 6, 5, 8, 1, 2, 6].iterM Id).find? (· < 5) = pure (some 1)* ([7, 6, 5, 8, 1, 2, 6].iterM Id).find? (· < 1) = pure none\n\nReturns the first output of the iterator for which the monadic predicate p returns true, or\nnone if no such element is found.O(|it|). Short-circuits when f returns true. The outputs of it are examined in order of\niteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findM? always terminates after finitely many steps.Example:#eval ([7, 6, 5, 8, 1, 2, 6].iterM IO).findM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 6\nAlmost! 5\nsome 1\n\n\nReturns the first non-none result of applying f to each output of the iterator, in order.\nReturns none if f returns none for all outputs.O(|it|). Short-circuits when f returns some _.The outputs of it are examined in order of\niteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findSome? always terminates after finitely many steps.Examples:* ([7, 6, 5, 8, 1, 2, 6].iterM Id).findSome? (fun x => if x < 5 then some (10 * x) else none) = pure (some 10)* ([7, 6, 5, 8, 1, 2, 6].iterM Id).findSome? (fun x => if x < 1 then some (10 * x) else none) = pure none\n\nReturns the first non-none result of applying the monadic function f to each output\nof the iterator, in order. Returns none if f returns none for all outputs.O(|it|). Short-circuits when f returns some _. The outputs of it are\nexamined in order of iteration.If the iterator is not finite, this function might run forever. The variant\nit.ensureTermination.findSomeM? always terminates after finitely many steps.Example:#eval ([7, 6, 5, 8, 1, 2, 6].iterM IO).findSomeM? fun i => do\n  if i < 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\nAlmost! 6\nAlmost! 5\nsome 10\n\n\nReturns the n-th value emitted by it, or none if it terminates earlier.For monadic iterators, the monadic effects of this operation may differ from manually iterating\nto the n-th value because atIdx? can take shortcuts. By the signature, the return value\nis guaranteed to plausible in the sense of IterM.IsPlausibleNthOutputStep.This function is only available for iterators that explicitly support it by implementing\nthe IteratorAccess typeclass.\n\n","context":"Lean Reference\u0009Iterators\u0009Consuming Iterators","header":"21.3.3. Consuming Monadic Iterators","id":"/Iterators/Consuming-Iterators/#The-Lean-Language-Reference--Iterators--Consuming-Iterators--Consuming-Monadic-Iterators"},"/Source-Files-and-Modules/#module-syntax":{"contents":"Lean's concrete syntax is extensible.\nIn a language like Lean, it's not possible to completely describe the syntax once and for all, because libraries may define syntax in addition to new constants or inductive types.\nRather than completely describing the language here, the overall framework is described, while the syntax of each language construct is documented in the section to which it belongs.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Source Files and Modules","header":"5.2. Concrete Syntax","id":"/Source-Files-and-Modules/#module-syntax"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control":{"contents":"skip does nothing.\n\nTactic to check that a named hypothesis has a given type and/or value.* guard_hyp h : t checks the type up to reducible defeq,* guard_hyp h :~ t checks the type up to default defeq,* guard_hyp h :ₛ t checks the type up to syntactic equality,* guard_hyp h :ₐ t checks the type up to alpha equality.* guard_hyp h := v checks value up to reducible defeq,* guard_hyp h :=~ v checks value up to default defeq,* guard_hyp h :=ₛ v checks value up to syntactic equality,* guard_hyp h :=ₐ v checks the value up to alpha equality.The value v is elaborated using the type of h as the expected type.\n\nTactic to check that the target agrees with a given expression.* guard_target = e checks that the target is defeq at reducible transparency to e.* guard_target =~ e checks that the target is defeq at default transparency to e.* guard_target =ₛ e checks that the target is syntactically equal to e.* guard_target =ₐ e checks that the target is alpha-equivalent to e.The term e is elaborated with the type of the goal as the expected type, which is mostly\nuseful within conv mode.\n\nTactic to check equality of two expressions.* guard_expr e = e' checks that e and e' are defeq at reducible transparency.* guard_expr e =~ e' checks that e and e' are defeq at default transparency.* guard_expr e =ₛ e' checks that e and e' are syntactically equal.* guard_expr e =ₐ e' checks that e and e' are alpha-equivalent.Both e and e' are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using isDefEqGuarded) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n\ndone succeeds iff there are no remaining goals.\n\nThe tactic sleep ms sleeps for ms milliseconds and does nothing.\nIt is used for debugging purposes only.\n\nstop is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as repeat sorry.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.19. Control Flow","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control"}});