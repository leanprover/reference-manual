window.docContents[51].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Resizing":{"contents":"Removes the first i elements of the subarray. If there are i or fewer elements, the resulting\nsubarray is empty.\n\nKeeps only the first i elements of the subarray. If there are i or fewer elements, the resulting\nsubarray is empty.\n\nShrinks the subarray by incrementing its starting index if possible, returning it unchanged if not.Examples:* #[1,2,3].toSubarray.popFront.toArray = #[2, 3]* #[1,2,3].toSubarray.popFront.popFront.toArray = #[3]* #[1,2,3].toSubarray.popFront.popFront.popFront.toArray = #[]* #[1,2,3].toSubarray.popFront.popFront.popFront.popFront.toArray = #[]\n\nSplits a subarray into two parts, the first of which contains the first i elements and the second\nof which contains the remainder.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","header":"20.16.5.3. Resizing","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Resizing"},"/Basic-Types/Maps-and-Sets/#HashMap":{"contents":"The declarations in this section should be imported using import Std.HashMap.\n\nHash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.Data.HashMap.Raw and\nStd.Data.HashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nHashMap over HashMap.Raw.Dependent hash maps, in which keys may occur in their values' types, are available as\nStd.Data.DHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"20.18.2. Hash Maps","id":"/Basic-Types/Maps-and-Sets/#HashMap"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights":{"contents":"\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Highlights","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Library":{"contents":"* #9515 adds a missing lemma for the List API.* #10739 adds two missing NeZero instances for n^0 where n : Nat\nand n : Int.* #10743 renames theorems that use sorted in their name to instead use\npairwise.* #10765 extends the all/any functions from hash sets to hash maps\nand dependent hash maps and verifies them.* #10769 adds a find? consumer in analogy to List.find? and variants\nthereof.* #10776 adds iterators and slices for DTreeMap/TreeMap/TreeSet\nbased on zippers and provides basic lemmas about them.* #10820 shows that the iterators returned by String.Slice.split and\nString.Slice.splitInclusive are finite as long as the forward matcher\niterator for the pattern is finite (which we already know for all of our\npatterns).* #10852 renames String.Range to Lean.Syntax.Range, to reflect that\nit is not part of the standard library.* #10853 renames String.endPos to String.rawEndPos, as in a future\nrelease the name String.endPos will be taken by the function that is\ncurrently called String.endValidPos.* #10854 fixes the IPv4 address encoding from libuv to lean* #10865 makes the spec Std.Do.Spec.forIn'_list and friends more\nuniverse polymorphic.* #10896 adds union operations on DTreeMap/TreeMap/TreeSet and their raw\nvariants and provides lemmas about union operations.* #10933 adds the basic infrastructure to perform termination proofs\nabout String.ValidPos and String.Slice.Pos.* #10941 removes a redundant instance requirement from\nStd.instIrreflLtOfIsPreorderOfLawfulOrderLT.* #10946 adds union operation on ExtDHashMap/ExtHashMap/ExtHashSet nd\nprovides lemmas about union operations.* #10952 replaces Iter(M).size with the Iter(M).count. While the\nformer used a special IteratorSize type class, the latter relies on\nIteratorLoop. The IteratorSize class is deprecated. The PR also\nrenames lemmas about ranges be replacing _Rcc with _rcc, _Rco with\n_roo (and so on) in names, in order to be more consistent with the\nnaming convention.* #10966 fixes some mis-stated lemmas which should have been about the\n.Raw variants of maps.* #10986 defines String.Slice.replace and redefines String.replace to\nuse the Slice version.* #10993 allows grind to work extensionally on extensional maps/sets.* #11006 removes the duplicate lemmas\nStd.Do.SPred.{and_pure,or_pure,imp_pure,entails_pure_intro}.* #11008 inlines several Decidable instances for performance reasons.* #11017 establishes String.ofList and String.toList as the preferred\nmethod for converting between strings and lists of characters and\ndeprecates the alternatives String.mk, List.asString and\nString.data.* #11019 introduces slices of lists that are available via slice notation\n(e.g., xs[1...5]).* #11021 adds more theory about Splits for strings and deduces the\nfirst user-facing String lemma, String.toList_map.* #11058 changes Nat.ble by joining the two Nat.ble Nat.zero _ cases\ninto one, allowing decide (0 <= x) = true and decide (0 < succ x) = true to be solvable by rfl.* #11060 add list min and max operations to complement min? and\nmax? ones in the same vain as head? and head.* #11070 adds union operation on ExtDHashMap/ExtHashMap/ExtHashSet nd\nprovides lemmas about union operations.* #11076 adds getEntry/getEntry?/getEntry!/getEntryD operation on\nDHashMap.* #11100 adds theorem Int.ediv_pow {a b : Int} {n : Nat} (hab : b âˆ£ a) : (a / b) ^ n = a ^ n / b ^ n and related lemmas.* #11102 adds some annotations missing in the Array bootstrapping files.* #11113 adds some small missing lemmas.* #11123 adds theorems about folds over flatMaps, for\nList/Array/Vector.* #11127 removes all uses of String.Iterator from core, preferring\nString.ValidPos instead.* #11138 adds a csimp lemma for faster runtime evaluation of Int.pow\nin terms of Nat.pow.* #11139 replaces #11138, which just added a @[csimp] lemma for\nInt.pow, this time actually replacing the definition. This means we\nnot only get fast runtime behaviour, but take advantage of the special\nkernel support for Nat.pow.* #11150 adds a new, inactive and unused doElem_elab attribute that\nwill allow users to register custom elaborators for doElems in the\nform of the new type DoElab. The old do elaborator is active by\ndefault but can be switched off by disabling the new option\nbackward.do.legacy.* #11152 renames String.Iterator to String.Legacy.Iterator.* #11154 renames Substring  to Substring.Raw.* #11159 adds lemmas about the sizes of ranges of Ints, analogous to the\nNat lemmas in Init.Data.Range.Polymorphic.NatLemmas. See also\nhttps://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/Reasonning.20about.20PRange.20sizes.20.28with.20.60Int.60.29/with/546466339.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0-rc2 (2025-11-21)","header":"Library","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Library"}});