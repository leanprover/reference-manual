window.docContents[41].resolve({"/Basic-Types/Strings/#string-syntax":{"contents":"Lean has three kinds of string literals: ordinary string literals, interpolated string literals, and raw string literals.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings","header":"20.8.3. Syntax","id":"/Basic-Types/Strings/#string-syntax"},"/Definitions/Recursive-Definitions/#partial-fixpoint-tailrec":{"contents":"A recursive function can be defined as a partial fixpoint if the following two conditions hold:1. The function's return type is inhabited (as with functions marked partial) - either a Nonempty or Inhabited instance works.2. All recursive calls are in tail position of the function.An expression is in tail position in the function body if it is:* the function body itself,* the branches of a match expression that is in tail position,* the branches of an if expression that is in tail position, and* the body of a let expression that is in tail position.In particular, the discriminant of a match expression, the condition of an if expression and the arguments of functions are not tail positions.\n\n\n\nLoops are Tail Recursive FunctionsBecause the function body itself is a tail position, the infinitely looping function loop is tail recursive.\nIt can be defined as a partial fixpoint.def loop (x : Nat) : Nat := loop (x + 1)\npartial_fixpoint\n\n\nTail Recursion with BranchingArray.find could also be constructed using well-founded recursion with a termination proof, but may be more convenient to define using partial_fixpoint, where no termination proof is needed.def Array.find (xs : Array α) (p : α → Bool)\n    (i : Nat := 0) : Option α :=\n  if h : i < xs.size then\n    if p xs[i] then\n      some xs[i]\n    else\n      Array.find xs p (i + 1)\n  else\n    none\npartial_fixpoint\nIf the result of the recursive call is not just returned, but passed to another function, it is not in tail position and this definition fails.def List.findIndex (xs : List α) (p : α → Bool) : Int :=\n  match xs with\n  | [] => -1\n  | x::ys =>\n    if p x then\n      0\n    else\n      have r := List.findIndex ys p\n      if r = -1 then -1 else r + 1\npartial_fixpoint\nThe error message on the recursive call is:Could not prove 'List.findIndex' to be monotone in its recursive calls:\n  Cannot eliminate recursive call `List.findIndex ys p` enclosed in\n    if ys✝.findIndex p = -1 then -1 else ys✝.findIndex p + 1\n  Tried to apply 'monotone_ite', but failed.\n  Possible cause: A missing `MonoBind` instance.\n  Use `set_option trace.Elab.Tactic.monotonicity true` to debug.\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.1. Tail-Recursive Functions","id":"/Definitions/Recursive-Definitions/#partial-fixpoint-tailrec"},"/Definitions/Recursive-Definitions/#partial-unsafe":{"contents":"While most Lean functions can be reasoned about in Lean's type theory as well as compiled and run, definitions marked partial or unsafe cannot be meaningfully reasoned about.\nFrom the perspective of the logic, partial functions are opaque constants, and theorems that refer to unsafe definitions are summarily rejected.\nIn exchange for the inability to use these functions for reasoning, there are far fewer requirements placed on them; this can make it possible to write programs that would be impractical or cost-prohibitive to prove anything about, while not giving up formal reasoning for the rest.\nIn essence, the partial subset of Lean is a traditional functional programming language that is nonetheless deeply integrated with the theorem proving features, and the unsafe subset features the ability to break Lean's runtime invariants in certain rare situations, at the cost of less integration with Lean's theorem-proving features.\nAnalogously, noncomputable definitions may use features that don't make sense in programs, but are meaningful in the logic.\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.5. Partial and Unsafe Definitions","id":"/Definitions/Recursive-Definitions/#partial-unsafe"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-associativity-commutativity":{"contents":"ac_nf normalizes equalities up to application of an associative and commutative operator.* ac_nf normalizes all hypotheses and the goal target of the goal.* ac_nf at l normalizes at location(s) l, where l is either * or a\nlist of hypotheses in the local context. In the latter case, a turnstile ⊢ or |-\ncan also be used, to signify the target of the goal.instance : Std.Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Std.Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n\n\nImplementation of ac_nf (the full ac_nf calls trivial afterwards).\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.5. Associativity and Commutativity","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-associativity-commutativity"},"/Terms/Structures-and-Constructors/#The-Lean-Language-Reference--Terms--Structures-and-Constructors":{"contents":"Anonymous constructors and structure instance syntax are described in their respective sections.\n\n","context":"Lean Reference\u0009Terms","header":"10.6. Structures and Constructors","id":"/Terms/Structures-and-Constructors/#The-Lean-Language-Reference--Terms--Structures-and-Constructors"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Compiler___-runtime___-and-FFI":{"contents":"* d85d3d fixes criterion for tail-calls in ownership calculation.* #3963 adds validation of UTF-8 at the C++-to-Lean boundary in the runtime.* #4512 fixes missing unboxing in interpreter when loading initialized value.* #4477 exposes the compiler flags for the bundled C compiler (clang).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"Compiler, runtime, and FFI","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Compiler___-runtime___-and-FFI"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Other":{"contents":"* #10043 allows Lean's parser to run with a final position prior to the\nend of the string, so it can be invoked on a sub-region of the input.* #10217 ensures @[init] declarations such as from initialize are run\nin the order they were declared on import.* #10262 adds a new option maxErrors that limits the number of errors\nprinted from a single lean run, defaulting to 100. Processing is\naborted when the limit is reached, but this is tracked only on a\nper-command level.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Other","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Other"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Tactics":{"contents":"* #10848 fixes an issue where adding a missing case name after the pipe\nin induction would not remove the now-obsolete error message.* #10858 improves the done tactic in grind interactive mode. It now\ndisplays the grind state diagnostics for all unsolved subgoals.* #10859 fixes auto-completion for set_option in grind interactive\nmode.* #10862 implements the show_term combinator in grind interactive\nmode.* #10874 uses the correct context for elaborating the grind state\nfilter.* #10877 fixes theory propagation issue in grind order.* #10881 fixes a proof instability source in grind.* #10887 uses the new TermInfo.isDisplayableTerm when hovering over\ncases tactic anchors in the grind interactive mode.* #10890 adds a +lax configuration option for grind, causing it to\nignore parameters referring to non-existent theorems, or to theorems for\nwhich we can't generate a pattern. This allows throwing large sets of\ntheorems (e.g. from a premise selection enginre) into grind to see\nwhat happens.* #10899 ensures the generated instantiate tactic instantiates the\ntheorems using the same order used by finish?* #10916 implements parameter optimization for the generated\ninstantiate tactics produced by finish?.\nWe use a simple parameter optimizer that takes two sets as input: the\nlower and upper bounds.\nThe lower bound consists of the theorems actually used in the proof\nterm, while the upper bound includes all the theorems instantiated in a\nparticular theorem instantiation step.\nThe lower bound is often sufficient to replay the proof, but in some\ncases, additional theorems must be included because a theorem\ninstantiation may contribute to the proof by providing terms and many\nnot be present in the final proof term.* #10919 implements the have <ident>? : <prop> tactic for the grind\ninteractive mode. The proposition is proved using the default grind\nsearch strategy. This tactic is also useful for inspecting or querying\nthe current grind state.* #10920 adds support for grind +premises, calling the currently\nconfigured premise selection algorithm and including the results as\nparameters to grind. (Recall that there is not currently a default\npremise selector provided by Lean4: you need a downstream premise\nselector to make use of this.)* #10936 fixes issues in grind => finish? that were preventing\ngenerated grind tactic scripts from being successfully replayed.* #10937 fixes a missing counter reset at the cases tactic in grind\ninteractive mode.* #10938 ensures solver grind tactics (e.g., ac, ring, lia, etc)\nprocess pending facts after making progress.* #10939 fixes another instance of the “default parameter value in\nconstructor” footgun, which was affecting the cases tactic in the\ngrind interactive mode.* #10948 ensures that finish? produces partial tactic scripts\ncontaining sorrys.\nWe may add an option to disable this feature in the future.\nIt is enabled by default because it provides a useful way to debug\ngrind failures.* #10949 ensures that solver propagation steps are necessary in the\ngenerated tactic script to close the goal.* #10950 adds the mbtc tactic to the grind interactive mode. It\nimplements model-based theory combination. It also ensures finish? is\ncapable of generating it.* #10951 fixes a bug in the cutsat incremental model construction. The\nmodel was not being reset when new (unsatisfied) equalities were\nasserted.* #10955 fixes a regression in the grind order module introduced by* #10956 fixes a bug in the equality propagation procedure in\ngrind.order. Specifically, it affects the procedure that asserts\nequalities in the grind core state that are implied by (ring)\ninequalities in the grind.order module.* #10960 fixes a bug in the grind linarith model/counterexample\nconstruction.* #10961 adds support for scientific literals for Rat in grind.\ngrind does not yet add support for this kind of literal in arbitrary\nfields.* #10962 fixes a spurious warning message in grind.* #10964 adds a propagator for a^(n+m) and removes its normalizer. This\nchange was motivated by issue #10661* #10965 ensures that model-based theory combination in grind cutsat\nconsiders nonlinear terms. Nonlinear multiplications such as x * y are\ntreated as uninterpreted symbols in cutsat.* #10971 adds a LawfulOfScientific class, providing compatibility with\na Lean.Grind.Field structure.* #10975 adds the combinator  · t_1 ... t_n to the grind interactive\nmode. The finish? tactic now generates scripts using this combinator\nto conform to Mathlib coding standards. The new format is also more\ncompact. Example:/--\ninfo: Try this:\n  [apply] ⏎\n    instantiate only [= mem_indices_of_mem, insert, = getElem_def]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #f590\n    · cases #ffdf\n      · instantiate only\n        instantiate only [= Array.getElem_set]\n      · instantiate only\n        instantiate only [size, = HashMap.mem_insert, = HashMap.getElem_insert, = Array.getElem_push]\n    · instantiate only [= mem_indices_of_mem, = getElem_def]\n      instantiate only [usr getElem_indices_lt]\n      instantiate only [size]\n      cases #ffdf\n      · instantiate only [=_ WF]\n        instantiate only [= getElem?_neg, = getElem?_pos, = Array.getElem_set]\n        instantiate only [WF']\n      · instantiate only\n        instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert, = Array.getElem_push]\n-/\n#guard_msgs in\nexample (m : IndexMap α β) (a a' : α) (b : β) (h : a' ∈ m.insert a b) :\n    (m.insert a b)[a'] = if h' : a' == a then b else m[a'] := by\n  grind => finish?\n* #10978 implements the following grind improvements:1. set_option can now be used to set grind configuration options in\nthe interactive mode.2. Fixes a bug in the repeated theorem instantiation detection.3. Adds the macro use [...] as a shorthand for instantiate only [...].* #10990 adds the set_config tactic for setting grind configuration\noptions. It uses the same syntax used for setting configuration options\nin the grind main tactic.* #10991 renames cutsat in configuration options and trace messages to\nlia.* #10992 ensures that grind +premises silently drops warnings and\nerrors about bad suggestions.* #10997 adds support for configuration options at finish and\nfinish?.* #11003 adds support for specifying anchors to restrict the search space\nin grind when using grind only. Anchors can limit which case splits\nare performed and which local lemmas are instantiated.* #11012 ensures the grind tactics finish and finish? can take\nparameters.* #11026 fixes a nontermination and missing propagation bug in grind order. It also register relevant case-splits for arithmetic.* #11028 ensures that grind? +premises removes +premises from the\n\"Try this\" suggestion.* #11029 changes the terminology used from \"premise selection\" to\n\"library suggestions\". This will be more understandable to users (we\ndon't assume anyone is familiar with the premise selection literature),\nand avoids a conflict with the existing use of \"premise\" in Lean\nterminology (e.g. \"major premise\" in induction, as well as generally the\nsynonym for \"hypothesis\"/\"argument\").* #11030 adds a library suggestion engine for local theorems. To be\nuseful, I still need to write more combinators to re-rank and combine\nsuggestions from multiple engines.* #11032 implements simp? +suggestions, which uses the configured\nlibrary suggestion engine to add relevant theorems to the simp call.\nsimp +suggestions without the ? prints a message requiring adding\nthe ?.* #11034 adds a new suggestion to finish?. It now generates the grind\ntactic script as before, and a finish only tactic. Example:/--\ninfo: Try these:\n  [apply] ⏎\n    instantiate only [findIdx, insert, = mem_indices_of_mem]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #1bba\n    · instantiate only [findIdx]\n    · instantiate only\n      instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert]\n  [apply] finish only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert, #1bba]\n-/\nexample (m : IndexMap α β) (a : α) (b : β) :\n    (m.insert a b).findIdx a = if h : a ∈ m then m.findIdx a else m.size := by\n  grind => finish?\n* #11039 fixes the grind invalid universe level regression reported in\n#11036* #11040 fixes a panic that occurred during the processing of generalized\nE-matching patterns in grind.* #11047 implements (nested term) equality propagation in grind order.\nThat is, it propagates implied equalities from grind order back to the\ngrind core. Examples:open Lean Grind Std\n\n* #11049 implements equality propagation for Nat in grind order.\ngrind order supports offset equalities for rings, but it has an\nadapter for Nat. Example:example (a b : Nat) (f : Nat → Int) : a ≤ b + 1 → b + 1 ≤ a → f (1 + a) = f (1 + b + 1) := by\n  grind -offset -mbtc -lia -linarith (splits := 0)\n* #11050 fixes equality propagation for Nat in grind order.* #11051 removes the grind offset module because it is (now) subsumed\nby grind order.* #11057 implements grind? using the new grind => finish?\ninfrastructure.* #11061 fixes a deep recursion issue in the kernel when type-checking a\nproof term produced by grind.* #11071 ensures that the denote functions used to implement\nproof-by-reflection terms in grind are abbreviations. This change\neliminates the need for the withAbstractAtoms gadget.* #11075 updates simp? +suggestions so that if a name is ambiguous\n(because of namespaces) all alternatives are used, rather than erroring.* #11077 fixes the anchor values produced by grind?* #11080 fixes a panic during equality propagation in the grind ring\nmodule. If the maximum number of steps has been reached, the polynomials\nmay not be fully simplified.* #11084 fixes a stack overflow that occurs when constructing a proof\nterm in grind.* #11087 enables grind to case bash on Sum and PSum.* #11092 ensures that grind ac denotation functions used in proof by\nreflection are marked as abbrev.* #11098 updates the suggestions tactic so the printed message includes\nhoverable type information (and displays scores and flags when\nrelevant).* #11099 improves the support for universe-metavariables in grind.* #11101 fixes an initialization issue for local Function.Injective f\nhypotheses.* #11126 ensures grind does not fail when applying injection to a\nhypothesis that cannot be cleared because of forward dependencies.* #11133 fixes disequality propagation for constructor applications in\ngrind. The equivalence class representatives may be distinct\nconstructor applications, but we must ensure they have the same type.\nExamples that were panic'ing before this PR:example (a b : List Nat)\n    : a ≍ ([] : List Int) → b ≍ ([1] : List Int) → a = b ∨ p → p := by\n  grind\n\n* #11135 ensures that checkExp is used in grind lia (formerly known\nas grind cutsat) and grind ring to prevent stack overflows.* #11136 adds support for try? to use induction; it will only perform\ninduction on inductive types defined in the current namespace and/or\nmodule; so in particular for now it will not induct on built-in\ninductives such as Nat or List.* #11137 fixes a stackoverflow during proof construction in grind.* #11145 fixes a bug in isMatchCondCandidate used in grind. The\nmissing condition was causing a \"not internalized term\" grind internal\nerror.* #11147 refactors the implementation of the symmetric equality\ncongruence rule used in grind.* #11148 addst the cases_next tactic to the grind interactive mode.* #11149 adds a user-extension mechanism for the try? tactic. You can\neither use the @[try_suggestion] attribute on a declaration with\nsignature MVarId -> Try.Info -> MetaM (Array (TSyntax `tactic)) to\nproduce suggestions, or the register_try?_tactic <stx> command with a\nfixed piece of syntax. User-extensions are only tried after the\nbuilt-in try strategies have been tried and failed.* #11157 implements the #grind_lint command, a diagnostic tool for\nanalyzing the behavior of theorems annotated for theorem instantiation.\nThe command helps identify problematic theorems that produce excessive\nor unbounded instance generation during E-matching, which can lead to\nperformance issues.\nThe main entry point is:#grind_lint check\nwhich analyzes all theorems marked with the @[grind] attribute.\nFor each theorem, it creates an artificial goal and runs grind,\ncollecting statistics about the number of instances produced.\nResults are summarized using info messages, and detailed breakdowns are\nshown for lemmas exceeding a configurable threshold.\nAdditional subcommands are provided for targeted inspection and control:* #grind_lint inspect thm: analyzes one or more specific theorems in\ndetail* #grind_lint mute thm: excludes a theorem from instantiation during\nanalysis* #grind_lint skip thm: omits a theorem from being analyzed by\n#grind_lint check* #11166 implements the following improvements to the #grind_lint\ncommand:1. More informative messages when the number of instances exceeds the\nminimum threshold.2. A code action for #grind_lint inspect that inserts\nset_option trace.grind.ematch.instance true whenever the number of\ninstances exceeds\nthe minimum threshold.3. Displaying doc strings for grind configuration options in\n#grind_lint.4. Improve doc strings for #grind_lint inspect and #grind_lint check.* #11167 implements support for #grind_lint check in module <module>.\nMathlib does not use namespaces, so we need to restrict the\n#grind_lint search space using module (prefix) names. Example:/--\ninfo: instantiating `Array.filterMap_some` triggers more than 100 additional `grind` theorem instantiations\n---\ninfo: Array.filterMap_some\n[thm] instances\n  [thm] Array.filterMap_filterMap ↦ 94\n  [thm] Array.size_filterMap_le ↦ 5\n  [thm] Array.filterMap_some ↦ 1\n---\ninfo: instantiating `Array.range_succ` triggers 22 additional `grind` theorem instantiations\n-/\n#guard_msgs in\n#grind_lint check (min := 20) in module Init.Data.Array\n* #11168 changes the default library suggestions (e.g. for grind +suggestions or `simp_all? +suggestions) to include the theorems from\nthe current file in addition to the output of Sine Qua Non.* #11170 adds tactic and term mode macros for ∎ (typed \\qed) which\nexpand to try?. The term mode version captures any produced\nsuggestions and prepends by.* #11171 ensures that tactics using library suggestions set the caller\nfield, so the premise selection engine has access to this. We'll later\nuse this to filter out some modules for grind, which we know have\nalready been fully annotated.* #11172 removes simp_all? +suggestions from try? for now. It's\nreally slow out in Mathlib; too often the suggestions cause simp to\nloop. Until we have the ability for try? to move past a timeing-out\ntactic (or maybe even until we have parallelism), it needs to be\nremoved.* #11174 modifies the try? framework, so each subsidiary tactic runs\nwith a separate maxHeartbeats budget.* #11187 adds syntax for specifying grind_pattern constraints and\nextends the EMatchTheorem object.* #11189 implements grind_pattern constraints. They are useful for\ncontrolling theorem instantiation in grind. As an example, consider\nthe following two theorems:theorem extract_empty {start stop : Nat} :\n    (#[] : Array α).extract start stop = #[] := …\n\n* #11193 uses the new grind_pattern constraints to fix cases where an\nunbounded number of theorem instantiations would be generated for\ncertain theorems in the standard library.* #11194 the redundant grind parameter warning message. It now checks\nthe grind theorem instantiation constraints too.* #11197 implements try? using the new finish? infrastructure. It\nalso removes the old tracing infrastructure, which is now obsolete.\nExample:/--\ninfo: Try these:\n  [apply] grind\n  [apply] grind only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert, #1bba]\n  [apply] grind only [findIdx, insert, = mem_indices_of_mem, = getElem?_neg, = getElem?_pos, = HashMap.mem_insert,\n    = HashMap.getElem_insert]\n  [apply] grind =>\n    instantiate only [findIdx, insert, = mem_indices_of_mem]\n    instantiate only [= getElem?_neg, = getElem?_pos]\n    cases #1bba\n    · instantiate only [findIdx]\n    · instantiate only\n      instantiate only [= HashMap.mem_insert, = HashMap.getElem_insert]\n-/\n#guard_msgs in\nexample (m : IndexMap α β) (a : α) (b : β) :\n    (m.insert a b).findIdx a = if h : a ∈ m then m.findIdx a else m.size := by\n  try?\n* #11203 fixes a few minor issues in the new Action framework used in\ngrind. The goal is to eventually delete the old SearchM\ninfrastructure. The main solve function used by grind is now based\non the Action framework. The PR also deletes dead code in SearchM.* #11204 has #grind_list check produce a \"Try this:\" suggestion with\n#grind_list inspect commands, as this is usually the next step in\ndealing with problematic cases. We also fix the grind pattern for one\ntheorem, as part of testing the workflow. More to follow.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0-rc2 (2025-11-21)","header":"Tactics","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Tactics"}});