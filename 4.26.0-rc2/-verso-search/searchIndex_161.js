window.docContents[161].resolve({"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen--Exceptions":{"contents":"If let mut is the do-equivalent of StateT, then early return is the equivalent of ExceptT.\nWe have seen how the mvcgen copes with StateT; here we will look at the program logic's support for ExceptT.Exceptions are the reason why the type of postconditions PostCond α ps is not simply a single condition of type α → Assertion ps for the success case.\nTo see why, suppose the latter was the case, and suppose that program prog throws an exception in a prestate satisfying P.\nShould we be able to prove ⦃P⦄ prog ⦃⇓ r => Q' r⦄?\n(Recall that ⇓ is grammatically similar to fun.)\nThere is no result r, so it is unclear what this proof means for Q'!So there are two reasonable options, inspired by non-termination in traditional program logics: The total correctness interpretation\n\n⦃P⦄ prog ⦃⇓ r => Q' r⦄ asserts that, given P holds, then prog terminates and Q' holds for the result.\n\n The partial correctness interpretation\n\n⦃P⦄ prog ⦃⇓ r => Q' r⦄ asserts that, given P holds, and if prog terminates then Q' holds for the result.\n\nThe notation ⇓ r => Q' r has the total interpretation, while ⇓? r => Q' r has the partial interpretation.PostconditionsA postcondition expressing total correctness.\nThat is, it expresses that the asserted computation finishes without throwing an exception\nand the result satisfies the given predicate p.A postcondition expressing partial correctness.\nThat is, it expresses that if the asserted computation finishes without throwing an exception\nthen the result satisfies the given predicate p.\nNothing is asserted when the computation throws an exception.So in the running example, ⦃P⦄ prog ⦃⇓ r => Q' r⦄ is unprovable, but ⦃P⦄ prog ⦃⇓? r => Q' r⦄ is trivially provable.\nHowever, the binary choice suggests that there is actually a spectrum of correctness properties to express.\nThe notion of postconditions PostCond in Std.Do supports this spectrum.\n\n\n\nFor example, suppose that our Supply of fresh numbers is bounded and we want to throw an exception if the supply is exhausted.\nThen mkFreshN should throw an exception only if the supply is indeed exhausted, as in this implementation:\n\nstructure Supply where\n  counter : Nat\n  limit : Nat\n  property : counter ≤ limit\n\ndef mkFresh : EStateM String Supply Nat := do\n  let supply ← get\n  if h : supply.counter = supply.limit then\n    throw s!\"Supply exhausted: {supply.counter} = {supply.limit}\"\n  else\n    let n := supply.counter\n    have := supply.property\n    set { supply with counter := n + 1, property := by grind }\n    pure n\n\n\nThe following correctness property expresses this:\n\n@[spec]\ntheorem mkFresh_spec (c : Nat) :\n    ⦃fun state => ⌜state.counter = c⌝⦄\n    mkFresh\n    ⦃post⟨fun r state => ⌜r = c ∧ c < state.counter⌝,\n          fun _ state => ⌜c = state.counter ∧ c = state.limit⌝⟩⦄ := by\n  mvcgen [mkFresh] with grind\n\n\nIn this property, the postcondition has two branches: the first covers successful termination, and the second applies when an exception is thrown.\nThe monad's WP instance determines both how many branches the postcondition may have and the number of parameters in each branch: each exception that might be triggered gives rise to an extra branch, and each state gives an extra parameter.\n\nIn this new monad, mkFreshN's implementation is unchanged, except for the type signature:def mkFreshN (n : Nat) : EStateM String Supply (List Nat) := do\n  let mut acc := #[]\n  for _ in [:n] do\n    acc := acc.push (← mkFresh)\n  pure acc.toList\n\n\nHowever, the specification lemma must account for both successful termination and exceptions being thrown, in both the postcondition and the loop invariant:@[spec]\ntheorem mkFreshN_spec (n : Nat) :\n    ⦃⌜True⌝⦄\n    mkFreshN n\n    ⦃post⟨fun r => ⌜r.Nodup⌝,\n          fun _msg state => ⌜state.counter = state.limit⌝⟩⦄ := by\n  mvcgen [mkFreshN]\n  invariants\n  · post⟨fun ⟨xs, acc⟩ state =>\n           ⌜(∀ n ∈ acc, n < state.counter) ∧ acc.toList.Nodup⌝,\n         fun _msg state => ⌜state.counter = state.limit⌝⟩\n  with grind\n\n\nThe final proof uses the specification lemmas and mvcgen, just as before:theorem mkFreshN_correct (n : Nat) :\n    match (mkFreshN n).run s with\n    | .ok    l _  => l.Nodup\n    | .error _ s' => s'.counter = s'.limit := by\n  generalize h : (mkFreshN n).run s = x\n  apply EStateM.of_wp_run_eq h\n  mvcgen\n\n\n\n\nJust as any StateT σ-like monad transformer gives rise to a PostShape.arg σ layer in the ps that WP maps into, any ExceptT ε-like layer gives rise to a PostShape.except ε layer.Every PostShape.arg σ adds another σ → ... layer to the language of Assertions.\nEvery PostShape.except ε leaves the Assertion language unchanged, but adds another exception\ncondition to the postcondition.\nHence the WP instance for EStateM ε σ maps to the PostShape PostShape.except ε (.arg σ .pure), just\nas for ExceptT ε (StateM σ).\n\n","context":"Lean Reference\u0009The  mvcgen  tactic\u0009Verifying Imperative Programs Using  mvcgen","header":"18.1.6. Exceptions","id":"/The--mvcgen--tactic/#The-Lean-Language-Reference--The--mvcgen--tactic--Verifying-Imperative-Programs-Using--mvcgen--Exceptions"},"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Changes-to-CI":{"contents":"* #5343 allows addition of release-ci label via comment (@thorimur)* #5344 sets check level correctly during workflow (@thorimur)* #5444 Mathlib's lean-pr-testing-NNNN branches should use Batteries' lean-pr-testing-NNNN branches* #5489 commit lake-manifest.json when updating lean-pr-testing branches* #5490 use separate secrets for commenting and branching in pr-release.yml\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.13.0 (2024-11-01)","header":"Changes to CI","id":"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Changes-to-CI"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--Grind":{"contents":"* #7355 fixes a bug in the markNestedProofs preprocessor used in the\ngrind tactic.* #7392 fixes an issue in the grind tactic when case splitting on\nif-then-else expressions.* #7510 ensures that grind can be used as a more powerful\ncontradiction tactic, sparing the user from having to type exfalso; grind or intros; exfalso; grind.* #7512 adds missing normalization rules for Nat div and mod to the\ngrind tactic.* #7514 adds more missing normalization rules for div and mod to\ngrind.* #7532 fixes the procedure for putting new facts into the grind\n\"to-do\" list. It ensures the new facts are preprocessed. also\nremoves some of the clutter in the Nat.sub support.* #7540 adds [grind cases eager] attribute to Subtype. See new test.* #7553 removes a bad normalization rule in grind, and adds a missing\ndsimproc.* #7641 implements basic model-based theory combination in grind.\ngrind can now solve examples such asexample (f : Int → Int) (x : Int)\n    : 0 ≤ x → x ≠ 0 → x ≤ 1 → f x = 2 → f 1 = 2 := by\n  grind\n* #7712 ensures grind always abstract its own proofs into an auxiliary\ndefinition/theorem. This is similar to #5998 but for grind* #7714 fixes an assertion violation in the grind model-based theory\ncombination module.* #7723 adds the configuration options zeta and zetaDelta in\ngrind. Both are set to true by default.* #7724 adds dite_eq_ite normalization rule to grind. This rule is\nimportant to adjust mismatches between a definition and its function\ninduction principle.* #7726 fixes the markNestedProofs procedure used in grind. It was\nmissing the case where the type of a nested proof may contain other\nnested proofs.* #7760 ensures grind is using the default transparency setting when\ncomputing auxiliary congruence lemmas.* #7765 improves how grind normalizes dependent implications during\nintroduction.\nPreviously, grind would introduce a hypothesis h : p for a goal of\nthe form .. ⊢ (h : p) → q h, and then normalize and assert a\nnon-dependent copy of p. As a result, the local context would contain\nboth h : p and a separate h' : p', where p' is the normal form of\np. Moreover, q would still depend on the original h.* #7776 improves the equality proof discharger used by the E-matching\nprocedure in grind.* #7777 fixes the introduction procedure used in grind. It was not\nregistering local instances that are also propositions. See new test.* #7778 adds missing propagation rules for LawfulBEq A to grind.\nThey are needed in a context where the instance DecidableEq A is not\navailable. See new test.* #7781 adds a new propagation rule for Bool disequalities to grind.\nIt now propagates x = true (x = false) from the disequality x = false (x = true). It ensures we don't have to perform case analysis\non x to learn this fact. See tests.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Language","header":"Grind","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language--Grind"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Lake":{"contents":"* #8383 fixes the use of import Lake with precompiled modules, which\nwas previously broken on MacOS.* #8411 fixes a doc bug in the Resolve.lean; in reverse order, B comes\nbefore A* #8528 fixes the heuristic Lake uses to determine whether a lean_lib\ncan be loaded via lean --plugin rather than lean --load-dynlib.\nPreviously, a mismatch between the single root's name and the library's\nname would not be caught and cause loading to fail.* #8529 changes lake lean and lake setup-file to precompile the\nimports of non-workspace files using the the import's whole library.\nThis ensures that additional link objects are linked and available\nduring elaboration.* #8539 changes Lake to use relative path for the Lean messages produced\nby a module build. This makes the message portable across different\nmachines, which is useful for Mathlib's cache.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Lake","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Lake"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Server":{"contents":"* #8105 adds support for server-sided RpcRef reuse and fixes a bug\nwhere trace nodes in the InfoView would close while the file was still\nbeing processed.* #8511 implements signature help support. When typing a function\napplication, editors with support for signature help will now display a\npopup that designates the current (remaining) function type. This\nremoves the need to remember the function signature while typing the\nfunction application, or having to constantly cycle between hovering\nover the function identifier and typing the application. In VS Code, the\nsignature help can be triggered manually using Ctrl+Shift+Space.* #8654 adds server-side support for a new module hierarchy component in\nVS Code that can be used to navigate both the import tree of a module\nand the imported-by tree of a module. Specifically, it implements new\nrequests $/lean/prepareModuleHierarchy,\n$/lean/moduleHierarchy/imports and\n$/lean/moduleHierarchy/importedBy. These requests are not supported by\nstandard LSP. Companion PR at\nleanprover/vscode-lean4#620.* #8699 adds support to the server for the new module setup process by\nchanging how lake setup-file is used.* #8868 ensures that code actions do not have to wait for the full file\nto elaborate. This regression was accidentally introduced in #7665.* #9019 fixes a bug where semantic highlighting would only highlight\nkeywords that started with an alphanumeric character. Now, it uses\nLean.isIdFirst.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Server","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Server"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Server":{"contents":"* #10365 implements the server-side for a new trace search mechanism in\nthe InfoView.* #10442 ensures that unknown identifier code actions are provided on\nauto-implicits.* #10524 adds support for interactivity to the combined \"try this\"\nmessages that were introduced in #9966. In doing so, it moves the link\nto apply a suggestion to a separate [apply] button in front of the\nsuggestion. Hints with diffs remain unchanged, as they did not\npreviously support interacting with terms in the diff, either.* #10538 fixes deadlocking exit calls in the language server.* #10584 causes Verso docstrings to search for a name in the environment\nthat is at least as long as the current name, providing it as a\nsuggestion.* #10609 fixes an LSP-non-compliance in the FileSystemWatcher that was\nintroduced in #925.* #10619 fixes a bug in the unknown identifier code actions where it\nwould yield non-sensical suggestions for nested open declarations like\nopen Foo.Bar.* #10660 adds auto-completion for identifiers after end. It also fixes\na bug where completion in the whitespace after set_option would not\nyield the full option list.* #10662 re-enables semantic tokens for Verso docstrings, after a prior\nchange accidentally disabled them. It also adds a test to prevent this\nfrom happening again.* #10738 fixes a regression introduced by #10307, where hovering the name\nof an inductive type or constructor in its own declaration didn't show\nthe docstring. In the process, a bug in docstring handling for\ncoinductive types was discovered and also fixed. Tests are added to\nprevent the regression from repeating in the future.* #10757 fixes a bug in combination with VS Code where Lean code that\nlooks like CSS color codes would display a color picker decoration.* #10797 fixes a bug in the unknown identifier code actions where the\nidentifiers wouldn't be correctly minimized in nested namespaces. It\nalso fixes a bug where identifiers would sometimes be minimized to\n[anonymous].\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)","header":"Server","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Server"}});