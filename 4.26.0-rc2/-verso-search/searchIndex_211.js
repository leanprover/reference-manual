window.docContents[211].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms":{"contents":"Computes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog.\n\nComputes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlogf.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10f.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2f.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"20.6.2.6. Logarithms","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Substrings--Modifications":{"contents":"Removes the specified number of characters (Unicode code points) from the beginning of a substring\nby advancing its start position.If the substring's end position is reached, the start position is not advanced past it.\n\nRemoves the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position. The start position is moved to the position of\nthe first character for which the predicate returns false, or to the substring's end position if\nthe predicate always returns true.\n\nRemoves the specified number of characters (Unicode code points) from the end of a substring\nby moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRemoves the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position. The end position is moved just after the position\nof the last character for which the predicate returns false, or to the substring's start position\nif the predicate always returns true.\n\nRetains only the specified number of characters (Unicode code points) at the beginning of a\nsubstring, by moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRetains only the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position towards its start position.\n\nRetains only the specified number of characters (Unicode code points) at the end of a substring, by\nmoving its start position towards its end position.If the substring's end position is reached, the start position is not advanced past it.\n\nRetains only the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position towards its end position.\n\nReturns the region of the substring delimited by the provided start and stop positions, as a\nsubstring. The positions are interpreted with respect to the substring's start position, rather than\nthe underlying string.If the resulting substring is empty, then the resulting substring is a substring of the empty string\n\"\". Otherwise, the underlying string is that of the input substring with the beginning and end\npositions adjusted.\n\nRemoves leading and trailing whitespace from a substring by first moving its start position to the\nfirst non-whitespace character, and then moving its end position to the last non-whitespace\ncharacter.If the substring consists only of whitespace, then the resulting substring's start position is moved\nto its end position.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \" red green blue \".toRawSubstring.trim.toString = \"red green blue\"* \" red green blue \".toRawSubstring.trim.startPos = ⟨1⟩* \" red green blue \".toRawSubstring.trim.stopPos = ⟨15⟩* \"     \".toRawSubstring.trim.startPos = ⟨5⟩\n\nRemoves leading whitespace from a substring by moving its start position to the first non-whitespace\ncharacter, or to its end position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nRemoves trailing whitespace from a substring by moving its end position to the last non-whitespace\ncharacter, or to its start position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nSplits a substring s on occurrences of the separator string sep. The default separator is \" \".When sep is empty, the result is [s]. When sep occurs in overlapping patterns, the first match\nis taken. There will always be exactly n+1 elements in the returned list if there were n\nnon-overlapping matches of sep in the string. The separators are not included in the returned\nsubstrings, which are all substrings of s's string.\n\nGiven a Substring, returns another one which has valid endpoints\nand represents the same substring according to Substring.toString.\n(Note, the substring may still be inverted, i.e. beginning greater than end.)\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Raw Substrings","header":"20.8.4.12.7. Modifications","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Raw-Substrings--Modifications"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams":{"contents":"Lean provides a consistent filesystem API on all supported platforms.\nThese are the key concepts:\n\n Files\n\nFiles are an abstraction provided by operating systems that provide random access to persistently-stored data, organized hierarchically into directories.\n\n Directories\n\nDirectories, also known as folders, may contain files or other directories.\n  Fundamentally, a directory maps names to the files and/or directories that it contains.\n\n File Handles\n\nFile handles (Handle) are abstract references to files that have been opened for reading and/or writing.\n  A file handle maintains a mode that determines whether reading and/or writing are allowed, along with a cursor that points at a specific location in the file.\n  Reading from or writing to a file handle advances the cursor.\n  File handles may be buffered, which means that reading from a file handle may not return the current contents of the persistent data, and writing to a file handle may not modify them immediately.\n\n Paths\n\nFiles are primarily accessed via paths (System.FilePath).\n  A path is a sequence of directory names, potentially terminated by a file name.\n  They are represented by strings in which separator characters The current platform's separator characters are listed in System.FilePath.pathSeparators. delimit the names.The details of paths are platform-specific.\n  Absolute paths begin in a root directory; some operating systems have a single root, while others may have multiple root directories.\n  Relative paths do not begin in a root directory and require that some other directory be taken as a starting point.\n  In addition to directories, paths may contain the special directory names ., which refers to the directory in which it is found, and .., which refers to prior directory in the path.Filenames, and thus paths, may end in one or more extensions that identify the file's type.\n  Extensions are delimited by the character System.FilePath.extSeparator.\n  On some platforms, executable files have a special extension (System.FilePath.exeExtension).\n\n Streams\n\nStreams are a higher-level abstraction over files, both providing additional functionality and hiding some details of files.\n  While file handles are essentially a thin wrapper around the operating system's representation, streams are implemented in Lean as a structure called IO.FS.Stream.\n  Because streams are implemented in Lean, user code can create additional streams, which can be used seamlessly together with those provided in the standard library.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.5. Files, File Handles, and Streams","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams"},"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices":{"contents":"Type constructors may take two kinds of arguments: parameters  and indices.\nParameters must be used consistently in the entire definition; all occurrences of the type constructor in each constructor in the declaration must take precisely the same argument.\nIndices may vary among the occurrences of the type constructor.\nAll parameters must precede all indices in the type constructor's signature.\n\nParameters that occur prior to the colon (':') in the type constructor's signature are considered parameters to the entire inductive type declaration.\nThey are always parameters that must be uniform throughout the type's definition.\nGenerally speaking, parameters that occur after the colon are indices that may vary throughout the definition of the type.\nHowever, if the option inductive.autoPromoteIndices is true, then syntactic indices that could have been parameters are made into parameters.\nAn index could have been a parameter if all of its type dependencies are themselves parameters and it is used uniformly as an uninstantiated variable in all occurrences of the inductive type's type constructor in all constructors.\n\nPromote indices to parameters in inductive types whenever possible.\n\nIndices can be seen as defining a family of types.\nEach choice of indices selects a type from the family, which has its own set of available constructors.\nType constructors with indices are said to specify indexed families  of types.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","header":"4.4.1.1. Parameters and Indices","id":"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices"}});