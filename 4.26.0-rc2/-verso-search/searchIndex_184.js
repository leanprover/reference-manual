window.docContents[184].resolve({"/Build-Tools-and-Distribution/Lake/#test-lint-drivers":{"contents":"A test driver is responsible for running the tests for a package.\nTest drivers may be executable targets or Lake scripts, in which case the test command runs them, or they may be libraries, in which case test causes them to be elaborated, with the expectation that test failures are registered as elaboration failures.\n\nSimilarly, a lint driver is responsible for checking the code for stylistic issues.\nLint drivers may be executables or scripts, which are run by lint.\n\nA test or lint driver can be configured by either setting the testDriver or lintDriver package configuration options or by tagging a script, executable, or library with the test_driver or lint_driver attribute in a Lean-format configuration file.\nA definition in a dependency can be used as a test or lint driver by using the <pkg>/<name> syntax for the appropriate configuration option.\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","header":"23.1.1.4. Test and Lint Drivers","id":"/Build-Tools-and-Distribution/Lake/#test-lint-drivers"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-goals":{"contents":"all_goals tac runs tac on each goal, concatenating the resulting goals, if any.\n\nany_goals tac applies the tactic tac to every goal, and succeeds if at\nleast one application succeeds.\n\n* case tag => tac focuses on the goal with case name tag and solves it using tac,\nor else fails.* case tag x₁ ... xₙ => tac additionally renames the n most recent hypotheses\nwith inaccessible names to the given names.* case tag₁ | tag₂ => tac is equivalent to (case tag₁ => tac); (case tag₂ => tac).\n\ncase' is similar to the case tag => tac tactic, but does not ensure the goal\nhas been solved after applying tac, nor admits the goal if tac failed.\nRecall that case closes the goal using sorry when tac fails, and\nthe tactic execution is not interrupted.\n\nnext => tac focuses on the next goal and solves it using tac, or else fails.\nnext x₁ ... xₙ => tac additionally renames the n most recent hypotheses with\ninaccessible names to the given names.\n\nfocus tac focuses on the main goal, suppressing all other goals, and runs tac on it.\nUsually · tac, which enforces that the goal is closed by tac, should be preferred.\n\n· conv focuses on the main conv goal and tries to solve it using s.\n\n· conv focuses on the main conv goal and tries to solve it using s.\n\nfail_if_success t fails if the tactic t succeeds.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.2. Goal Selection","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-goals"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Breaking-changes":{"contents":"* #8751 adds the nondep field of Expr.letE to the C++ data model.Breaking change: Expr.updateLet! is renamed to Expr.updateLetE!.* #8105 adds support for server-sided RpcRef reuse and fixes a bug\nwhere trace nodes in the InfoView would close while the file was still being processed.Breaking change: Since WithRpcRef is now capable of tracking its identity\nto decide which WithRpcRef usage constitutes a reuse, the constructor of\nWithRpcRef has been made private to discourage downstream users from\ncreating WithRpcRef instances with manually-set ids. Instead, WithRpcRef.mk\n(which lives in BaseIO) is now the preferred way to create WithRpcRef instances.* #8654 adds server-side support for a new module hierarchy component in\nVS Code.Breaking change: This PR augments the .ilean format with the direct imports of a file\nin order to implement the $/lean/moduleHierarchy/importedBy request and bumps the .ilean format version.* #8804 implements first-class support for nondependent let expressions\nin the elaborator.Breaking change: Uses of letLambdaTelescope/mkLetFVars need to use generalizeNondepLet := false;\nsee the PR description for more info.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Breaking changes","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Breaking-changes"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Overhaul-of-the-String-Type":{"contents":"* #10304 redefines String to be the type of byte arrays b\nfor which b.IsValidUtf8. This moves the data model of strings much closer to the actual data representation at runtime.* #10457 introduces safe alternatives to String.Pos and Substring\nthat can only represent valid positions/slices. Specifically, the PR* introduces the predicate String.Pos.IsValid;* proves several nontrivial equivalent conditions for String.Pos.IsValid;* introduces String.ValidPos, which is a String.Pos with an IsValid proof;* introduces String.Slice, which is like Substring but made from String.ValidPos instead of Pos;* introduces String.Pos.IsValidForSlice, which is like String.Pos.IsValid but for slices;* introduces String.Slice.Pos, which is like String.ValidPos but for slices;* introduces various functions for converting between the two types of positions.* #10514 defines the new String.Slice API.* #10713 enforces rules around arithmetic of String.Pos.Raw.Breaking Change: The HAdd and HSub instances for String.Pos.Raw are have been removed.\nSee the PR description for more information.* #10735 moves many operations involving String.Pos.Raw to a the\nString.Pos.Raw namespace.Breaking Change: After this PR, String.pos_lt_eq is no longer a simp lemma.\nAdd String.Pos.Raw.lt_iff as a simp lemma if your proofs break.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0 (2025-11-14)\u0009Highlights","header":"Overhaul of the String Type","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-_LPAR_2025-11-14_RPAR_--Highlights--Overhaul-of-the-String-Type"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Documentation":{"contents":"* #11179 removes most cases where an error message explained that it was\n\"probably due to metavariables,\" giving more explanation and a hint.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0-rc2 (2025-11-21)","header":"Documentation","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Documentation"}});