window.docContents[130].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Iteration":{"contents":"Updates the values of the map by applying the given function to all mappings.\n\nFolds the given function over the mappings in the map in ascending order.\n\nFolds the given monadic function over the mappings in the map in ascending order.\n\nSupport for the for loop construct in do blocks. Iteration happens in ascending order.\n\nCarries out a monadic action on each mapping in the tree map in ascending order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"20.18.9.5. Iteration","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Iteration"},"/Basic-Types/Natural-Numbers/#nat-api-bitwise":{"contents":"Shifts the binary representation of a value left by the specified number of bits. Usually accessed\nvia the <<< operator.Examples:* 1 <<< 2 = 4* 1 <<< 3 = 8* 0 <<< 3 = 0* 0xf1 <<< 4 = 0xf10\n\nShifts the binary representation of a value right by the specified number of bits. Usually accessed\nvia the >>> operator.Examples:* 4 >>> 2 = 1* 8 >>> 2 = 2* 8 >>> 3 = 1* 0 >>> 3 = 0* 0xf13a >>> 8 = 0xf1\n\nBitwise exclusive or. Usually accessed via the ^^^ operator.Each bit of the resulting value is set if the corresponding bit is set in exactly one of the inputs.\n\nBitwise or. Usually accessed via the ||| operator.Each bit of the resulting value is set if the corresponding bit is set in at least one of the inputs.\n\nBitwise and. Usually accessed via the &&& operator.Each bit of the resulting value is set if the corresponding bit is set in both of the inputs.\n\nA helper for implementing bitwise operators on Nat.Each bit of the resulting Nat is the result of applying f to the corresponding bits of the input\nNats, up to the position of the highest set bit in either input.\n\nReturns true if the (n+1)th least significant bit is 1, or false if it is 0.\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Arithmetic","header":"20.1.4.1.1. Bitwise Operations","id":"/Basic-Types/Natural-Numbers/#nat-api-bitwise"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Dependencies":{"contents":"Dependencies are specified in the [[require]] field array of a package configuration, which specifies both the name and the source of each package.\nThere are three kinds of sources:\n\n* Reservoir, or an alternative package registry* Git repositories, which may be local paths or URLs* Local paths\n\nA Dependency of a package.\nIt specifies a package which another package depends on.\nThis encodes the information contained in the require DSL syntax.The path and git fields specify an explicit source for a dependency.\nIf neither are provided, then the dependency is fetched from Reservoir, or an alternative registry if one has been configured.\nThe scope field is required when fetching a package from Reservoir.A dependency on the local filesystem, specified by its path.A dependency in a Git repository, specified either by its URL as a string or by a table with the keys:* url: the repository URL* subDir: the subdirectory of the Git repository that contains the package's source codeFor Git or Reservoir dependencies, this field specifies the Git revision, which may be a branch name, a tag name, or a specific hash.\nOn Reservoir, the version field takes precedence over this field.A dependency source, specified as a self-contained table, which is used when neither the git nor the path key is present.\nThe key type should be either the string \"git\" or the string \"path\".\nIf the type is \"path\", then there must be a further key \"path\" whose value is a string that provides the location of the package on disk.\nIf the type is \"git\", then the following keys should be present:* url: the repository URL* rev: the Git revision, which may be a branch name, a tag name, or a specific hash (optional)* subDir: the subdirectory of the Git repository that contains the package's source codeThe target version of the dependency.\nA Git revision can be specified with the syntax git#<rev>.The package name of the dependency.\nThis name must match the one declared in its configuration file,\nas that name is used to index its target data types. For this reason,\nthe package name must also be unique across packages in the dependency graph.An additional qualifier used to distinguish packages of the same\nname in a Lake registry. On Reservoir, this is the package owner.\n\nRequiring Packages from ReservoirThe package example can be required from Reservoir using this TOML configuration:[[require]]\nname = \"example\"\nversion = \"2.12\"\nscope = \"exampleDev\"\n\n\nRequiring Packages from GitThe package example can be required from a Git repository using this TOML configuration:[[require]]\nname = \"example\"\ngit = \"https://git.example.com/example.git\"\nrev = \"main\"\nversion = \"2.12\"\nIn particular, the package will be checked out from the main branch, and the version number specified in the package's configuration should match 2.12.\n\nRequiring Packages from a Git tagThe package example can be required from the tag v2.12 in a Git repository using this TOML configuration:[[require]]\nname = \"example\"\ngit = \"https://git.example.com/example.git\"\nrev = \"v2.12\"\nThe version number specified in the package's configuration is not used.\n\nRequiring Reservoir Packages from a Git tagThe package example, found using Reservoir, can be required from the tag v2.12 in its Git repository using this TOML configuration:[[require]]\nname = \"example\"\nrev = \"v2.12\"\nscope = \"exampleDev\"\nThe version number specified in the package's configuration is not used.\n\nRequiring Packages from PathsThe package example can be required from the local path ../example using this TOML configuration:[[require]]\nname = \"example\"\npath = \"../example\"\nDependencies on local paths are useful when developing multiple packages in a single repository, or when testing whether a change to a dependency fixes a bug in a downstream package.\n\nSources as TablesThe information about the package source can be written in an explicit table.[[require]]\nname = \"example\"\nsource = {type = \"git\", url = \"https://example.com/example.git\"}\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Declarative TOML Format","header":"23.1.3.1.2. Dependencies","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Dependencies"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-transformers":{"contents":"A monad transformer is a function that, when provided with a monad, gives back a new monad.\nTypically, this new monad has all the effects of the original monad along with some additional ones.\n\n\n\nA monad transformer consists of the following:\n\n* A function T that constructs the new monad's type from an existing monad* A run function that adapts a T m α into some variant of m, often requiring additional parameters and returning a more specific type under m* An instance of [Monad m] → Monad (T m) that allows the transformed monad to be used as a monad* An instance of MonadLift that allows the original monad's code to be used in the transformed monad* If possible, an instance of MonadControl m (T m) that allows actions from the transformed monad to be used in the original monad\n\nTypically, a monad transformer also provides instances of one or more type classes that describe the effects that it introduces.\nThe transformer's Monad and MonadLift instances make it practical to write code in the transformed monad, while the type class instances allow the transformed monad to be used with polymorphic functions.\n\nThe Identity Monad Transformer The identity monad transformer neither adds nor removes capabilities to the transformed monad.\nIts definition is the identity function, suitably specialized:def IdT (m : Type u → Type v) : Type u → Type v := m\nSimilarly, the run function requires no additional arguments and just returns an m α:def IdT.run (act : IdT m α) : m α := act\nThe monad instance relies on the monad instance for the transformed monad, selecting it via type ascriptions:instance [Monad m] : Monad (IdT m) where\n  pure x := (pure x : m _)\n  bind x f := (x >>= f : m _)\nBecause IdT m is definitionally equal to m, the MonadLift m (IdT m) instance doesn't need to modify the action being lifted:instance : MonadLift m (IdT m) where\n  monadLift x := x\nThe MonadControl instance is similarly simple.instance [Monad m] : MonadControl m (IdT m) where\n  stM α := α\n  liftWith f := f (fun x => Id.run <| pure x)\n  restoreM v := v\n\n\nThe Lean standard library provides transformer versions of many different monads, including ReaderT, ExceptT, and StateT, along with variants using other representations such as StateCpsT, StateRefT, and ExceptCpsT.\nAdditionally, the EStateM monad is equivalent to combining ExceptT and StateT, but it can use a more specialized representation to improve performance.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.2. Monad Transformers","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-transformers"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-requirements":{"contents":"The inductive types declared in a mutual block are considered as a group; they must collectively satisfy generalized versions of the well-formedness criteria for non-mutually-recursive inductive types.\nThis is true even if they could be defined without the mutual block, because they are not in fact mutually recursive.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","header":"4.4.5.1. Requirements","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-requirements"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Documentation":{"contents":"* #6450 adds a docstring to the @[app_delab] attribute.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Documentation","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Documentation"},"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Language":{"contents":"* #10763 improves match compilation: Branch on variables in the order\nsuggested by the first remaining alternative, and do not branch when the\nfirst remaining alternative does not require it. This fixes\nhttps://github.com/leanprover/lean4/issues/10749. With set_option backwards.match.rowMajor false the old behavior can be turned on.* #10823 lets the match compilation procedure use sparse case analysis\nwhen the patterns only match on some but not all constructors of an\ninductive type. This way, less code is produce. Before, code handling\neach of the other cases was then optimized and commoned-up by later\ncompilation pipeline, but that is wasteful to do.* #10826 fixes the location of the “deprecated constant” and similar\nerror messages on field notation (e.f, (e).f, e |>. f). Fixes\n#10821.* #10851 lets match compilation use exfalso as soon as no alternatives\nare left. This way, the compiler does not have to look at subsequent\ncase splits.* #10865 makes the spec Std.Do.Spec.forIn'_list and friends more\nuniverse polymorphic.* #10872 improves the performance of mvcgen by an optimized\nimplementation for try (mpure_intro; trivial). This tactic sequence is\nused to eagerly discharge VCs and in the process instantiates schematic\nvariables.* #10926 topologically sorts abstracted vars in\nMeta.Closure.mkValueTypeClosure if MVars are being abstracted.\nFixes #10705* #10931 strips the Expr.mdata that WF.Fix uses to associate goal\nwith recursive calls from the goal presented to the tactics.\nFixes #10895.* #10944 runs enableRealizationsForConst on sizeOf declarations. Fixes\n#10573.* #10980 tries to preserve names of pattern variables in match\nalternatives in decreasing_by, by telescoping into the concrete\nalternative rather than the type of the matcher's alt. Fixes #10976.* #11011 extracts some refactorings from #10763, including dropping dead\ncode and not failing in inaccessibleAsCtor, which leadas to (slightly)\nbetter error messages, and also on the grounds that the failing\nalternative may actually be unreachable.* #11024 lets Bool have .ctorIdx like any other inductive.* #11068 removes the verifyEnum functions from the bv_decide frontend.\nThese functions looked at the implementation of matchers to see if they\nreally do the matching that they claim to do. This breaks that\nabstraction barrier, and should not be necessary, as only functions with\na MatcherInfo env entry are considered here, which should all play\nnicely.* #11072 adds “sparse casesOn” constructions. They are similar to\n.casesOn, but have arms only for some constructors and a catch-all\n(providing t.ctorIdx ≠ 42 assumptions). The compiler has native\nsupport for these constructors and now (because of the similarity) also\nthe per-constructor elimination principles.* #11094 makes workspaceSymbol benchmarks modules, so that they are\nless sensitive to additions of private symbols in the standard library.* #11095 makes use of hasIndepIndices. That function was unused since\ncommit 54f6517ca36b237b40e02aac62ea36dbd4179758, but it seems it should\nbe used.* #11107 tests the missing cases error.* #11122 fixes a problem for structures with diamond inheritance: rather\nthan copying doc-strings (which are not available unless .server.olean\nis loaded), we link to them. Adds tests.* #11125 adds a filter for premise selectors to ensure deprecated\ntheorems are not returned.* #11132 adds support for grind +suggestions and simp_all? +suggestions in try?. It outputs grind only [X, Y, Z] or simp_all only [X, Y, Z] suggestions (rather than just +suggestions).* #11146 fixes a bug in #11125. Added a test this time ...* #11150 adds a new, inactive and unused doElem_elab attribute that\nwill allow users to register custom elaborators for doElems in the\nform of the new type DoElab. The old do elaborator is active by\ndefault but can be switched off by disabling the new option\nbackward.do.legacy.* #11161 adds getEntry/getEntry?/getEntry!/getEntryD operation on\nDTreeMap.* #11184 modifies the error message that is returned when more than one\nsynthetic metavariable can't be resolved.* #11190 avoids running into an “unknown free variable” when printing the\n“Failed to compile pattern matching” error. Fixes #11186.* #11191 makes sure that inside a realizeConst the maxHeartbeat\noption is effective.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.26.0-rc2 (2025-11-21)","header":"Language","id":"/releases/v4.26.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___26___0-rc2-_LPAR_2025-11-21_RPAR_--Language"}});