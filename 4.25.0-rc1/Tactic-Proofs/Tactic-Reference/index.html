<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Tactic Reference</title><link rel="stylesheet" href="book.css">
    <link rel="stylesheet" href="verso-vars.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-search/elasticlunr.min.js"></script>
    <script src="-verso-search/fuzzysort.js"></script>
    <script src="-verso-search/searchIndex.js"></script>
    <script type="module" src="-verso-search/search-init.js"></script>
    <link rel="stylesheet" href="-verso-search/search-box.css">
    <link rel="stylesheet" href="-verso-search/search-highlight.css">
    <link rel="stylesheet" href="-verso-search/domain-display.css">
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.min.js"></script>
    <script src="-verso-data/tippy-bundle.umd.min.js"></script>
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
  position: relative;
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
.live-link {
  font-family: var(--verso-structure-font-family);
  position: absolute;
  bottom: 0px;
  right: 0px;
  padding: 0.5rem;
  border-top: 1px solid #98B2C0;
  border-left: 1px solid #98B2C0;
  border-top-left-radius: 0.5rem;
}
.live-link a {
  text-decoration: none;
  color: var(--lean-blue);
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
  .error-explanation-metadata {
    margin-bottom: 2rem; /* Double the paragraph margin */
  }

  .error-explanation-metadatum:not(:last-child):after {
    content: '|';
    margin: 0 10px;
  }
  .error-explanation-removed-warning {
    border: 1px solid var(--verso-warning-color);
    border-radius: 0.5rem;
    padding-left: var(--verso--box-padding);
    padding-right: var(--verso--box-padding);
  }
  </style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
  font-size: inherit;
}

.hl.lean .keyword {
  color: var(--verso-code-keyword-color,);
  font-weight: var(--verso-code-keyword-weight, bold);
  font-style: var(--verso-code-keyword-style, normal);
  font-family: var(--verso-code-keyword-font-family,);
}

.hl.lean .const {
  color: var(--verso-code-const-color,);
  font-weight: var(--verso-code-const-weight, normal);
  font-style: var(--verso-code-const-style, normal);
  font-family: var(--verso-code-const-font-family,);
}

.hl.lean .var {
  color: var(--verso-code-var-color,);
  font-weight: var(--verso-code-var-weight, normal);
  font-style: var(--verso-code-var-style, italic);
  font-family: var(--verso-code-var-font-family,);

  position: relative;
}

.hl.lean .literal, .hl.lean .unknown {
  color: var(--verso-code-color,);
  font-weight: normal;
  font-style: normal;
  font-family: var(--verso-code-font-family,);
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
  background: none;
  color: black;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean {
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean * {
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
  text-decoration-skip-ink: none;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error .verso-message, .error .verso-message .token, .error .verso-message label {
  color: var(--verso-error-color);
}

.error .verso-message .case-label:has(input[type="checkbox"])::before {
  background-color: var(--verso-error-color) !important;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-indicator-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.lean-output {
  border-left: 0.2em solid transparent;
  padding: 0 0 0 0.5em;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.lean-output.error {
  border-color: var(--verso-error-indicator-color);
}

.lean-output.information {
  border-color: var(--verso-info-indicator-color);
}

.lean-output.warning {
  border-color: var(--verso-warning-indicator-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.information :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-info-indicator-color, blue);
}

@media (hover: hover) {
  .hl.lean .has-info.information:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.information {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.information {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: var(--verso-text-font-family, sans-serif);
  white-space: normal;
  max-width: calc(min(40rem, 90vw));
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: var(--verso-code-font-family);
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline;
  vertical-align: top;
  /* Without these, mobile Safari will start making font sizes inconsistent when its text size adjustment feature is triggered.*/
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

.hl.lean .tactic:has(.tactic-toggle:checked) {
  display: inline-grid;
  grid-template-columns: 1fr;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
  display: inline;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  /* These need to be em, not rem, to scale with the font */
  border-radius: 1em;
  height: 0.25em;
  vertical-align: middle;
  width: 0.6em;
  margin-left: 0.1em;
  margin-right: 0.1em;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5em;
}

/*
Some CSS frameworks customize details/summary in ways not compatible with Verso's output.
*/

.hl.lean details {
  display: block !important;
  margin: 0;
}

.hl.lean details summary {
  display: list-item !important;
  margin: 0;
}

.hl.lean details summary:focus {
  outline: none;
  outline-offset: none;
  color: inherit;
}

.hl.lean ul > li {
  margin-bottom: 0;
}

.hl.lean details summary::marker {
  display: inline !important;
}

.hl.lean details > summary:first-of-type {
  list-style-type: disclosure-closed;
  list-style-position: inside;
}

.hl.lean details[open] > summary:first-of-type {
  list-style-type: disclosure-open;
}

.hl.lean details summary::before, .hl.lean details summary::after {
  content: "" !important;
  background: none;
  display: none;
}

.hl.lean .tactic-state summary {
  /* These need to be em, not rem, to scale with the font */
  margin-left: -0.5em;
}

.hl.lean .tactic-state details {
  /* These need to be em, not rem, to scale with the font */
  padding-left: 0.5em;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7em;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6em;
  height: 0.6em;
  vertical-align: middle;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  /* These need to be em, not rem, to scale with the font */
  margin-left: 0.5em;
  margin-top: 0.1em;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .goal-name {
  font-style: italic;
  font-family: var(--verso-code-font-family);
  color: inherit;
}

.hl.lean .hypotheses {
  display: table;
}

.hl.lean .hypothesis {
  display: table-row;
}

.hl.lean .hypothesis > * {
  display: table-cell;
}


.hl.lean .hypotheses .colon {
  text-align: center;
  /* This needs to be em, not rem, to scale with the font */
  min-width: 1em;
}

.hl.lean .hypotheses .name {
  text-align: right;
}

.hl.lean .hypotheses .name,
.hl.lean .hypotheses .type,
.hl.lean .conclusion .type {
  font-family: var(--verso-code-font-family);
}

.tippy-box {
  /* Without these, mobile Safari will start making font sizes inconsistent when its text size adjustment feature is triggered.*/
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;

}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}

.verso-message .trace {
  display: block;
}

.verso-message .trace > summary::marker {
  color: var(--verso-text-color);
}

.verso-message .trace-children {
  margin: 0;
  padding: 0;
}

.verso-message .trace-children > li {
  list-style-type: none;
  margin-left: 1.5em;
}

.verso-message .trace-children > li:not(:has(.trace)) {
  margin-left: 0;
}

.verso-message .trace-class {
  color: color-mix(in srgb, currentColor 70%, transparent);
  font-weight: bold;
  margin: 0;
  padding: 0;
}

.verso-message .text {
  white-space: pre-wrap;
}

</style><style>.error-explanation-short-name { hyphenate-character: ''; }</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}
/* Highlight the clicked term */
.def-technical-term:target {
  background-color: var(--verso-selected-color);
  outline: auto;
}
</style><style>
.error-example-container:not(:last-child) {
  border-bottom: 1px solid gray;
  padding-bottom: var(--verso--box-padding);
}
.error-example-tab-list [role="tab"] {
  position: relative;
  z-index: 1;
  background: white;
  border: 0;
  padding: 0.2em;
  cursor: pointer;
}
.error-example-tab-list [role="tab"]:not(:last-child) {
  margin-right: 1rem;
}
.error-example-tab-list [role="tab"][aria-selected="true"] {
  border-bottom: 1px solid gray;
}
/* this rule and the following ensure that all tabs are the same height */
.error-example-tab-view {
  display: flex;
}
.error-example-tabpanel {
  margin-right: -100%;
  width: 100%;
  display: block;
}
.error-example-tabpanel.error-example-tabpanel-hidden {
  visibility: hidden;
}
.error-example-tabpanel .hl.lean .token {
  /* unset transition to avoid lag when switching panels */
  transition: visibility 0s;
}
  </style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.addEventListener('DOMContentLoaded', () => {
  const tabLists = document.querySelectorAll('.error-example-tab-list')
  tabLists.forEach(tabList => {
    const tabs = tabList.querySelectorAll(':scope > [role="tab"]')

    const setActiveTab = (e) => {
      for (const tab of tabs) {
        const controllee = document.getElementById(tab.getAttribute('aria-controls'))
        if (tab === e.target) {
          tab.setAttribute('aria-selected', true)
          controllee.classList.remove('error-example-tabpanel-hidden')
        } else {
          tab.setAttribute('aria-selected', false)
          controllee.classList.add('error-example-tabpanel-hidden')
        }
      }
    }

    tabs.forEach(tab => {
      tab.addEventListener('click', setActiveTab)
    })

    let focusedIdx = 0
    tabList.addEventListener('keydown', e => {
      if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
        tabs[focusedIdx].setAttribute('tabindex', -1)
        focusedIdx =
          e.key === 'ArrowRight'
          ? (focusedIdx + 1) % tabs.length
          : (focusedIdx - 1 + tabs.length) % tabs.length
        tabs[focusedIdx].setAttribute('tabindex', 0)
        tabs[focusedIdx].focus()
      }
    })
  })
})
  </script>
    <script>
      function openDetailsForHashTarget() {
  // Get the current hash from the URL
  const hash = window.location.hash;

  // Exit early if no hash is present
  if (!hash) return;

  // Remove the # to get the actual ID
  const targetId = hash.substring(1);

  // Find the target element
  const targetElement = document.getElementById(targetId);

  // Exit if target element doesn't exist
  if (!targetElement) return;

  // Find the closest details element that contains the target
  const detailsElement = targetElement.closest('details');

  // If the target is inside a details element, open it
  if (detailsElement) {
    detailsElement.open = true;
  }
}

// Run the function when the page loads
document.addEventListener('DOMContentLoaded', openDetailsForHashTarget);

// Also run when the hash changes (for single-page applications)
window.addEventListener('hashchange', openDetailsForHashTarget);

// Run immediately in case the script loads after DOMContentLoaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', openDetailsForHashTarget);
} else {
  openDetailsForHashTarget();
}
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let docsJson = "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.information').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    <script defer="defer" data-domain="lean-lang.org" src="https://plausible.io/js/script.outbound-links.js"></script>
    <script src="static/print.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <script src="-verso-search/search-highlight.js" defer="defer"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="current numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="The--grind--tactic/#grind-tactic">The <code>grind</code> tactic</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">22.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Error-Explanations/#The-Lean-Language-Reference--Error-Explanations">Error Explanations</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="The-Module-System/#module-system">The Module System</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="platforms/#platforms">Supported Platforms</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-tactics" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-tactics" checked="checked"></label><span class="number">13.</span> <span class=""><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></span></div>
              <table><tr class="numbered"><td class="num">13.1.</td><td><a href="Tactic-Proofs/Running-Tactics/#by">Running Tactics</a></td></tr><tr class="numbered"><td class="num">13.2.</td><td><a href="Tactic-Proofs/Reading-Proof-States/#proof-states">Reading Proof States</a></td></tr><tr class="numbered"><td class="num">13.3.</td><td><a href="Tactic-Proofs/The-Tactic-Language/#tactic-language">The Tactic Language</a></td></tr><tr class="numbered"><td class="num">13.4.</td><td><a href="Tactic-Proofs/Options/#tactic-language-options">Options</a></td></tr><tr class="current numbered"><td class="num">13.5.</td><td><a href="Tactic-Proofs/Tactic-Reference/#tactic-ref">Tactic Reference</a></td></tr><tr class="numbered"><td class="num">13.6.</td><td><a href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv">Targeted Rewriting with <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="0">conv</span></a></code></a></td></tr><tr class="numbered"><td class="num">13.7.</td><td><a href="Tactic-Proofs/Naming-Bound-Variables/#bound-variable-name-hints">Naming Bound Variables</a></td></tr><tr class="numbered"><td class="num">13.8.</td><td><a href="Tactic-Proofs/Custom-Tactics/#custom-tactics">Custom Tactics</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-tactic-ref" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-tactic-ref" checked="checked"></label><span class="number">13.5.</span> <span class="current"><a href="Tactic-Proofs/Tactic-Reference/#tactic-ref">Tactic Reference</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-classical">Classical Logic</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#classical"><code class="tactic-name">classical</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-assumptions">Assumptions</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#assumption"><code class="tactic-name">assumption</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_assumption"><code class="tactic-name">apply_assumption</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers">Quantifiers</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exists"><code class="tactic-name">exists</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#intro"><code class="tactic-name">intro</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#intros"><code class="tactic-name">intros</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#intro-___-_________-____GT_-_________-___-_________-____GT_-_________"><code class="tactic-name">intro | ... =&gt; ... | ... =&gt; ...</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rintro"><code class="tactic-name">rintro</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-relations">Relations</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rfl"><code class="tactic-name">rfl</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rfl___"><code class="tactic-name">rfl'</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_rfl"><code class="tactic-name">apply_rfl</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next"><span class="syntax"><span class="keyword">refl</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#symm"><code class="tactic-name">symm</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#symm_saturate"><code class="tactic-name">symm_saturate</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">symm</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#calc"><code class="tactic-name">calc</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Trans___mk"><code>Trans</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-equality">Equality</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#subst"><code class="tactic-name">subst</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#subst_eqs"><code class="tactic-name">subst_eqs</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#subst_vars"><code class="tactic-name">subst_vars</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#congr"><code class="tactic-name">congr</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#eq_refl"><code class="tactic-name">eq_refl</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ac_rfl"><code class="tactic-name">ac_rfl</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-associativity-commutativity">Associativity and Commutativity</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ac_nf"><code class="tactic-name">ac_nf</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ac_nf0"><code class="tactic-name">ac_nf0</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">6.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-lemmas">Lemmas</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exact"><code class="tactic-name">exact</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply"><code class="tactic-name">apply</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#refine"><code class="tactic-name">refine</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#refine___"><code class="tactic-name">refine'</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim"><code class="tactic-name">solve_by_elim</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_rules"><code class="tactic-name">apply_rules</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#as_aux_lemma"><code class="tactic-name">as_aux_lemma</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">7.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-false">Falsehood</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exfalso"><code class="tactic-name">exfalso</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#contradiction"><code class="tactic-name">contradiction</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#false_or_by_contra"><code class="tactic-name">false_or_by_contra</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">8.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-goals">Goal Management</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#suffices"><code class="tactic-name">suffices</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#change"><code class="tactic-name">change</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________"><code class="tactic-name">change ... with ...</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#generalize"><code class="tactic-name">generalize</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#specialize"><code class="tactic-name">specialize</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#obtain"><code class="tactic-name">obtain</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#show"><code class="tactic-name">show</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#show_term"><code class="tactic-name">show_term</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">9.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-casts">Cast Management</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#norm_cast"><code class="tactic-name">norm_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#push_cast"><code class="tactic-name">push_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast"><code class="tactic-name">exact_mod_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast"><code class="tactic-name">apply_mod_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rw_mod_cast"><code class="tactic-name">rw_mod_cast</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast"><code class="tactic-name">assumption_mod_cast</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">10.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-ext">Extensionality</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ext"><code class="tactic-name">ext</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#ext1"><code class="tactic-name">ext1</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply_ext_theorem"><code class="tactic-name">apply_ext_theorem</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#funext-next"><code class="tactic-name">funext</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">11.</span> <a href="Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--SMT-Inspired-Automation">SMT-Inspired Automation</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#grind"><code class="tactic-name">grind</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">12.</span> <a href="Tactic-Proofs/Tactic-Reference/#simp-tactics">Simplification</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp"><code class="tactic-name">simp</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp___"><code class="tactic-name">simp!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp___-next"><code class="tactic-name">simp?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp______"><code class="tactic-name">simp?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_arith"><code class="tactic-name">simp_arith</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_arith___"><code class="tactic-name">simp_arith!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp"><code class="tactic-name">dsimp</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp___"><code class="tactic-name">dsimp!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp___-next"><code class="tactic-name">dsimp?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dsimp______"><code class="tactic-name">dsimp?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all"><code class="tactic-name">simp_all</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all___"><code class="tactic-name">simp_all!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all___-next"><code class="tactic-name">simp_all?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all______"><code class="tactic-name">simp_all?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith"><code class="tactic-name">simp_all_arith</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith___"><code class="tactic-name">simp_all_arith!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa"><code class="tactic-name">simpa</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa___"><code class="tactic-name">simpa!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa___-next"><code class="tactic-name">simpa?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simpa______"><code class="tactic-name">simpa?!</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#simp_wf"><code class="tactic-name">simp_wf</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">13.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-rw">Rewriting</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rw"><code class="tactic-name">rw</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rewrite"><code class="tactic-name">rewrite</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#erw"><code class="tactic-name">erw</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rwa"><code class="tactic-name">rwa</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___Config___mk"><code>Config</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all"><code>Occurrences</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all"><code>TransparencyMode</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___NewGoals"><code>NewGoals</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#unfold"><code class="tactic-name">unfold</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#replace"><code class="tactic-name">replace</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#delta"><code class="tactic-name">delta</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">14.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive">Inductive Types</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">14.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-intro">Introduction</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#constructor"><code class="tactic-name">constructor</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#injection"><code class="tactic-name">injection</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#injections"><code class="tactic-name">injections</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#left"><code class="tactic-name">left</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#right"><code class="tactic-name">right</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">14.2.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-elim">Elimination</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">induction_eliminator</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">cases_eliminator</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#cases"><code class="tactic-name">cases</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rcases"><code class="tactic-name">rcases</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#fun_cases"><code class="tactic-name">fun_cases</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#induction"><code class="tactic-name">induction</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#fun_induction"><code class="tactic-name">fun_induction</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#nofun"><code class="tactic-name">nofun</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#nomatch"><code class="tactic-name">nomatch</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">15.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-search">Library Search</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#exact___"><code class="tactic-name">exact?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#apply___"><code class="tactic-name">apply?</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#rw___"><code class="tactic-name">rw?</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">16.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-cases">Case Analysis</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#split"><code class="tactic-name">split</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#by_cases"><code class="tactic-name">by_cases</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">17.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-decision">Decision Procedures</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#decide"><code class="tactic-name">decide</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#native_decide"><code class="tactic-name">native_decide</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#omega"><code class="tactic-name">omega</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_omega"><code class="tactic-name">bv_omega</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">17.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-sat">SAT Solver Integration</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_decide"><code class="tactic-name">bv_decide</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_normalize"><code class="tactic-name">bv_normalize</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_check"><code class="tactic-name">bv_check</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#bv_decide___"><code class="tactic-name">bv_decide?</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">18.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-reducibility">Controlling Reduction</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#with_reducible-next"><code class="tactic-name">with_reducible</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#with_reducible_and_instances-next"><code class="tactic-name">with_reducible_and_instances</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#with_unfolding_all-next"><code class="tactic-name">with_unfolding_all</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">19.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-control">Control Flow</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#skip"><code class="tactic-name">skip</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#guard_hyp"><code class="tactic-name">guard_hyp</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#guard_target"><code class="tactic-name">guard_target</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#guard_expr"><code class="tactic-name">guard_expr</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#done"><code class="tactic-name">done</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#sleep"><code class="tactic-name">sleep</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#stop"><code class="tactic-name">stop</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">20.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-term-helpers">Term Elaboration Backends</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#decreasing_with"><code class="tactic-name">decreasing_with</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic"><code class="tactic-name">get_elem_tactic</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial"><code class="tactic-name">get_elem_tactic_trivial</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">21.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-debug">Debugging Utilities</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#sorry"><code class="tactic-name">sorry</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#admit"><code class="tactic-name">admit</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#dbg_trace"><code class="tactic-name">dbg_trace</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#trace_state"><code class="tactic-name">trace_state</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#trace"><code class="tactic-name">trace</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">22.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-other">Other</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#trivial"><code class="tactic-name">trivial</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#solve"><code class="tactic-name">solve</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#and_intros"><code class="tactic-name">and_intros</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#infer_instance"><code class="tactic-name">infer_instance</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#expose_names"><code class="tactic-name">expose_names</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#unhygienic"><code class="tactic-name">unhygienic</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#run_tac"><code class="tactic-name">run_tac</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">23.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-mvcgen">Verification Condition Generation</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mvcgen"><code class="tactic-name">mvcgen</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">23.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#tactic-ref-spred">Tactics for Stateful Goals in <code>Std.Do.SPred</code></a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">23.1.1.</span> <a href="Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Starting-and-Stopping-the-Proof-Mode">Starting and Stopping the Proof Mode</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mstart"><code class="tactic-name">mstart</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mstop"><code class="tactic-name">mstop</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mleave"><code class="tactic-name">mleave</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">23.1.2.</span> <a href="Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Proving-a-Stateful-Goal">Proving a Stateful Goal</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mspec"><code class="tactic-name">mspec</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mintro"><code class="tactic-name">mintro</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mexact"><code class="tactic-name">mexact</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#massumption"><code class="tactic-name">massumption</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mrefine"><code class="tactic-name">mrefine</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mconstructor"><code class="tactic-name">mconstructor</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mleft"><code class="tactic-name">mleft</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mright"><code class="tactic-name">mright</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mexists"><code class="tactic-name">mexists</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mpure_intro"><code class="tactic-name">mpure_intro</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mexfalso"><code class="tactic-name">mexfalso</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">23.1.3.</span> <a href="Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Manipulating-Stateful-Hypotheses">Manipulating Stateful Hypotheses</a></span></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mclear"><code class="tactic-name">mclear</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mdup"><code class="tactic-name">mdup</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mhave"><code class="tactic-name">mhave</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mreplace"><code class="tactic-name">mreplace</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mspecialize"><code class="tactic-name">mspecialize</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mspecialize_pure"><code class="tactic-name">mspecialize_pure</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mcases"><code class="tactic-name">mcases</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mrename_i"><code class="tactic-name">mrename_i</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mpure"><code class="tactic-name">mpure</code></a></li>
                <li>
                  <a href="Tactic-Proofs/Tactic-Reference/#mframe"><code class="tactic-name">mframe</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Tactic-Proofs/Options/#tactic-language-options" rel="prev" title="13.4. Options"><span class="arrow">←</span><span class="where">13.4. Options</span></a><a class="local-button active" href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv" rel="next" title="13.6. Targeted Rewriting with conv"><span class="where">13.6. Targeted Rewriting with conv</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              13.5. Tactic Reference<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref" title="Permalink">🔗</a></span></h1>
            <section>
              <h2 id="tactic-ref-classical">
                13.5.1. Classical Logic<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-classical" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="classical">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.classical" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#classical" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2461">classical</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">classical</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> in a scope where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Classical.propDecidable" data-verso-hover="2462">Classical.propDecidable</span></code> is a low priority
local instance.</p>
                  <p>
                    Note that <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#classical" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2461">classical</span></a></code> is a scoping tactic: it adds the instance only within the
scope of the tactic.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-assumptions">
                13.5.2. Assumptions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-assumptions" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="assumption">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.assumption" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1180">assumption</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">‹</span><span class="unknown token" data-binding="">t</span><span class="unknown token" data-binding="">›</span></code> term notation, which is a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-0">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.208" data-verso-hover="334">t</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic'-7">by</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-10" data-verso-hover="1180">assumption</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_assumption">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.applyAssumption" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2463">apply_assumption</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2463">apply_assumption</span></a></code> looks for an assumption of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">head</span></code>
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">head</span></code> matches the current goal.</p>
                  <p>
                    You can specify additional rules to apply using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_assumption</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code>.
By default <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2463">apply_assumption</span></a></code> will also try <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2464">trivial</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun" title="Documentation for congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1555">congrFun</span></a></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg" title="Documentation for congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="927">congrArg</span></a></code>.
If you don't want these, or don't want to use all hypotheses, use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_assumption</span><span class="inter-text"> </span><span class="unknown token" data-binding="">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code>.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2463">apply_assumption</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code> to omit a local hypothesis.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_assumption</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">a₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> to use all lemmas which have been labelled
with the attributes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aᵢ</span></code> (these attributes must be created using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">register_label_attr</span></code>).</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2463">apply_assumption</span></a></code> will use consequences of local hypotheses obtained via <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2465">symm</span></a></code>.</p>
                  <p>
                    If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2463">apply_assumption</span></a></code> fails, it will call <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2466">exfalso</span></a></code> and try again.
Thus if there is an assumption of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.407" data-verso-hover="2467">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="338">Q</span></code>, the new tactic state
will have two goals, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.407" data-verso-hover="2467">P</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.421" data-verso-hover="338">Q</span></code>.</p>
                  <p>
                    You can pass a further configuration via the syntax <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">lemmas</span></code>.
The options supported are the same as for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code> (and include all the options for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code>).</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-quantifiers">
                13.5.3. Quantifiers<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-quantifiers" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="exists">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.«tacticExists_,,»" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exists" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2469">exists</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">exists</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">refine</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">e₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">try</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">trivial</span></code>.
It is useful for existential goals.</p>
                  </div>
                </div>
              <div class="namedocs" id="intro">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.intro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="811">intro</span></a></pre><div class="text">
                  <p>
                    Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> or function type.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.1245" data-verso-hover="72">intro</span></code> by itself introduces one anonymous hypothesis, which can be accessed
by e.g. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code>. It is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span></code> introduces two hypotheses and names them. Individual hypotheses
can be anonymized via <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>, given a type ascription, or matched against a pattern:</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
-- ..., a : α, b : β ⊢ ...</span></code></li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span></code> is short for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">subst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code>, if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> is an equality where the left-hand or right-hand side
is a variable.</p>
                      </li>
                    <li>
                      <p>
                        Alternatively, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.1245" data-verso-hover="72">intro</span></code> can be combined with pattern matching much like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun</span></code>:</p>
                      <pre>intro
| n + 1, 0 =&gt; tac
| ...
</pre></li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="intros">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.intros" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="515">intros</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a></code> repeatedly applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a></code> to introduce zero or more hypotheses
until the goal is no longer a <em>binding expression</em>
(i.e., a universal quantifier, function type, implication, or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>/<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code>),
without performing any definitional reductions (no unfolding, beta, eta, etc.).
The introduced hypotheses receive inaccessible (hygienic) names.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z</span></code> and exists only for historical reasons.
The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a></code> tactic should be preferred in this case.</p>
                  <p>
                    <strong>Properties and relations</strong></p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a></code> succeeds even when it introduces no hypotheses.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#repeat" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRepeat_-0" data-verso-hover="2430">repeat</span></a><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-7" data-verso-hover="811">intro</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a></code>, but it performs definitional reductions
to expose binders, and as such it may introduce more hypotheses than <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a></code> is equivalent to <code>intro _ _ … _</code>,
with the fewest trailing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code> placeholders needed so that the goal is no longer a binding expression.
The trailing introductions do not perform any definitional reductions.</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Examples</strong></p>
                  <p>
                    Implications:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-10461240317908829081-40-42-709"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-40" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10461240317908829081-40-42-709"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-8518593116464421501-45-51-711"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-45" data-verso-hover="515">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8518593116464421501-45-51-711"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1990">a✝¹</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="2439">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"></span></span></span></span></span></span><span class="inter-text">
  /- Tactic state
     a✝¹ : p
     a✝ : q
     ⊢ p      -/
  </span><span class="tactic"><label for="tactic-state-7-121-131-713"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-121" data-verso-hover="1180">assumption</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-121-131-713"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    Let-bindings:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-10" data-verso-hover="116">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-22" data-verso-hover="116">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-3462310036921371484-47-49-714"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-47" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3462310036921371484-47-49-714"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="keyword token" data-binding="">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.193" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">;</span><span class="inter-text">
</span><span class="keyword token" data-binding="">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.194" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">;</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.193" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.194" data-verso-hover="9">k</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7498190146227016683-52-58-716"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-52" data-verso-hover="515">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7498190146227016683-52-58-716"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.178" data-verso-hover="9">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.179" data-verso-hover="9">k✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.178" data-verso-hover="9">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.179" data-verso-hover="9">k✝</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></span><span class="inter-text">
  /- n✝ : Nat := 1
     k✝ : Nat := 2
     ⊢ n✝ + k✝ = 3 -/
  </span><span class="tactic"><label for="tactic-state-7-131-134-718"><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-131" data-verso-hover="18">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-131-134-718"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    Does not unfold definitions:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-AllEven" data-verso-hover="2470">AllEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">%</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text">

</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="verso-message warning"><span class="text"></span><span class="text">declaration uses '</span><span class="highlighted"><span class="inter-text"></span><span class="unknown token" data-binding="">sorry</span><span class="inter-text"></span></span><span class="text">'</span></code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-53">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-AllEven" data-verso-hover="2470">AllEven</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-AllEven" data-verso-hover="2470">AllEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-109">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.100" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-17806486755297416900-132-134-719"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-132" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17806486755297416900-132-134-719"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.175" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="const token" data-binding="const-AllEven" data-verso-hover="2470">AllEven</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.175" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-AllEven" data-verso-hover="2470">AllEven</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.177" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.175" data-verso-hover="1053">f</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.177" data-verso-hover="9">k</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-12973560170164919490-137-143-721"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-137" data-verso-hover="515">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12973560170164919490-137-143-721"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1053">f✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.163" data-verso-hover="2471">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-AllEven" data-verso-hover="2470">AllEven</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1053">f✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-AllEven" data-verso-hover="2470">AllEven</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.174" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.162" data-verso-hover="1053">f✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.174" data-verso-hover="9">k</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a></span></span></span></span></span><span class="inter-text">
  /- Tactic state
     f✝ : Nat → Nat
     a✝ : AllEven f✝
     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/
  </span><span class="tactic"><label for="tactic-state-7-255-260-723"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-255" data-verso-hover="13">sorry</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-255-260-723"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="intro-___-_________-____GT_-_________-___-_________-____GT_-_________">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.introMatch" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#intro-___-_________-____GT_-_________-___-_________-____GT_-_________" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2472">intro | ... =&gt; ... | ... =&gt; ...</span></a></pre><div class="text">
                  <p>
                    The tactic</p>
                  <pre>intro
| pat1 =&gt; tac1
| pat2 =&gt; tac2
</pre><p>
                    is the same as:</p>
                  <pre>intro x
match x with
| pat1 =&gt; tac1
| pat2 =&gt; tac2
</pre><p>
                    That is, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a></code> can be followed by match arms and it introduces the values while
doing a pattern match. This is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun</span></code> with match arms in term mode.</p>
                  </div>
                </div>
              <div class="namedocs" id="rintro">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rintro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rintro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2433">rintro</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2433">rintro</span></a></code> tactic is a combination of the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a></code> tactic with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> to
allow for destructuring patterns while introducing variables. See <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> for
a description of supported patterns. For example, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rintro-0" data-verso-hover="2433">rintro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">d</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">⟩</span></code>
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> and the other with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code>.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2433">rintro</span></a></code>, unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code>, also supports the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ty</span><span class="unknown token" data-binding="">)</span></code> for introducing
and type-ascripting multiple variables at once, similar to binders.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-relations">
                13.5.4. Relations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-relations" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="rfl">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticRfl" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="18">rfl</span></a></pre><div class="text">
                  <p>
                    This tactic applies to a goal whose target has the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">~</span></code> is equality, heterogeneous equality or any relation that
has a reflexivity lemma tagged with the attribute @[refl].</p>
                  </div>
                </div>
              <div class="namedocs" id="rfl___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticRfl'" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rfl___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2474">rfl'</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rfl___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl'-0" data-verso-hover="2474">rfl'</span></a></code> is similar to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_rfl">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.applyRfl" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_rfl" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2475">apply_rfl</span></a></pre><div class="text">
                  <p>
                    The same as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, but without trying <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#eq_refl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.eqRefl-0" data-verso-hover="2476">eq_refl</span></a></code> at the end.</p>
                  </div>
                </div>
              <div class="namedocs" id="attr-next-next-next-next-next-next-next-next">
                <span class="label">attribute</span><span class="title">Reflexive Relations</span><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2477">refl</span></code> attribute marks a lemma as a proof of reflexivity for some relation.
These lemmas are used by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="18">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#rfl___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2474">rfl'</span></a></code>, and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rfl" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2475">apply_rfl</span></a></code> tactics.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">refl</span><span class="from-nonterminal" data-kind="null"></span></pre></div>
                </div>
              <div class="namedocs" id="symm">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.symm" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2465">symm</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2465">symm</span></a></code> applies to a goal whose target has the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u</span></code> where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">~</span></code> is a symmetric relation,
that is, a relation which has a symmetry lemma tagged with the attribute [symm].
It replaces the target with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">u</span><span class="inter-text"> </span><span class="unknown token" data-binding="">~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2465">symm</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-5" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> will rewrite a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u</span><span class="inter-text"> </span><span class="unknown token" data-binding="">~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="symm_saturate">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.symmSaturate" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#symm_saturate" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2478">symm_saturate</span></a></pre><div class="text">
                  <p>
                    For every hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> where a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">symm</span><span class="unknown token" data-binding="">]</span></code> lemma is available,
add a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h_symm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="attr-next-next-next-next-next-next-next-next-next">
                <span class="label">attribute</span><span class="title">Symmetric Relations</span><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2479">symm</span></code> attribute marks a lemma as a proof that a relation is symmetric.
These lemmas are used by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2465">symm</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#symm_saturate" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2478">symm_saturate</span></a></code> tactics.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">symm</span><span class="from-nonterminal" data-kind="null"></span></pre></div>
                </div>
              <div class="namedocs" id="calc">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.calcTactic" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#calc" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2480">calc</span></a></pre><div class="text">
                  <p>
                    Step-wise reasoning over transitive relations.</p>
                  <pre>calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
</pre><p>
                    proves <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4901" data-verso-hover="107">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4911" data-verso-hover="107">z</span></code> from the given step-wise proofs. <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> can be replaced with any
relation implementing the typeclass <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#Trans___mk" title="Documentation for Trans"><span class="const token" data-binding="const-Trans" data-verso-hover="2481">Trans</span></a></code>. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>.</p>
                  <pre>calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
</pre><p>
                    It is also possible to write the <em>first</em> relation as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">lhs</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">\</span><span class="unknown token" data-binding="">n</span><span class="inter-text">  </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">rhs</span><span class="unknown token" data-binding="">&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">proof</span><span class="unknown token" data-binding="">&gt;</span></code>. This is useful for aligning relation symbols, especially on longer:
identifiers:</p>
                  <pre>calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
</pre><p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#calc" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2480">calc</span></a></code> works as a term, as a tactic or as a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.conv" data-verso-hover="2482">conv</span></code> tactic.</p>
                  <p>
                    See <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs">Theorem Proving in Lean 4</a> for more information.</p>
                  </div>
                </div>
              <div class="namedocs" id="Trans___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Trans.mk" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Trans.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_1,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_2,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_3}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8227" data-verso-hover="135">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u_1</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8228" data-verso-hover="334">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u_2</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8229" data-verso-hover="320">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u_3</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8233" data-verso-hover="2483">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8227" data-verso-hover="135">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8228" data-verso-hover="334">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8237" data-verso-hover="2484">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8228" data-verso-hover="334">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8229" data-verso-hover="320">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort v</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8241" data-verso-hover="2485">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1721">outParam</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8227" data-verso-hover="135">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8229" data-verso-hover="320">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort w</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Trans.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_1,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_2,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_3}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8227" data-verso-hover="135">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u_1</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8228" data-verso-hover="334">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u_2</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8229" data-verso-hover="320">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u_3</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8233" data-verso-hover="2483">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8227" data-verso-hover="135">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8228" data-verso-hover="334">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort u</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8237" data-verso-hover="2484">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8228" data-verso-hover="334">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8229" data-verso-hover="320">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort v</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8241" data-verso-hover="2485">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1721">outParam</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8227" data-verso-hover="135">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8229" data-verso-hover="320">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort w</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort
    (max
        (max
            (max
                (max (max (max 1 u) u_1)
                    u_2)
                u_3)
            v)
        w)</span></div></pre><div class="text">
                  <p>
                    Transitive chaining of proofs, used e.g. by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#calc" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2480">calc</span></a></code>.</p>
                  <p>
                    It takes two relations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5186" data-verso-hover="2483">r</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5187" data-verso-hover="2484">s</span></code> as "input", and produces an "output"
relation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5188" data-verso-hover="2485">t</span></code>, with the property that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5186" data-verso-hover="2483">r</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5201" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5210" data-verso-hover="317">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5187" data-verso-hover="2484">s</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5210" data-verso-hover="317">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5220" data-verso-hover="1148">c</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5188" data-verso-hover="2485">t</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5201" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5220" data-verso-hover="1148">c</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#calc" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2480">calc</span></a></code> tactic uses this so that when it sees a chain with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5201" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5210" data-verso-hover="317">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5210" data-verso-hover="317">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5220" data-verso-hover="1148">c</span></code>
it knows that this should be a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5201" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5220" data-verso-hover="1148">c</span></code> because there is an instance
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Trans</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">≤</span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  <h1>
                    Instance Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Tactic-Proofs/Tactic-Reference/#Trans___mk" title="Documentation for Trans.mk"><span class="const token" data-binding="const-Trans.mk" data-verso-hover="2486">Trans.mk</span></a><span class="unknown token" data-binding="">.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_1,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_2,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_3}</span></pre><div class="docs"></div>
                    </section>
                  <h1>
                    Methods</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Trans.trans" data-verso-hover="2487">trans</span> : <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8167" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8152" data-verso-hover="135">α</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8173" data-verso-hover="317">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8153" data-verso-hover="334">β</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8178" data-verso-hover="1148">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8154" data-verso-hover="320">γ</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8155" data-verso-hover="2483">r</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8167" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8173" data-verso-hover="317">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8156" data-verso-hover="2484">s</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8173" data-verso-hover="317">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8178" data-verso-hover="1148">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8157" data-verso-hover="2485">t</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8167" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8178" data-verso-hover="1148">c</span></pre><div class="docs">
                      <p>
                        Compose two proofs by transitivity, generalized over the relations involved.</p>
                      </div>
                    </section>
                  </div>
                </div>
              <section>
                <h3 id="tactic-ref-equality">
                  13.5.4.1. Equality<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-equality" title="Permalink">🔗</a></span></h3>
                <div class="namedocs" id="subst">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.subst" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#subst" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2453">subst</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">subst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">...</span></code> substitutes each hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> with a definition found in the local context,
then eliminates the hypothesis.</p>
                    <ul>
                      <li>
                        <p>
                          If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9029" data-verso-hover="72">x</span></code> is a local definition, then its definition is used.</p>
                        </li>
                      <li>
                        <p>
                          Otherwise, if there is a hypothesis of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9029" data-verso-hover="107">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9039" data-verso-hover="107">e</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9039" data-verso-hover="2488">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9029" data-verso-hover="2488">x</span></code>,
then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9039" data-verso-hover="2488">e</span></code> is used for the definition of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9029" data-verso-hover="2488">x</span></code>.</p>
                        </li>
                      </ul>
                    <p>
                      If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9062" data-verso-hover="2489">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="799">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9055" data-verso-hover="799">b</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#subst" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.subst-0" data-verso-hover="2453">subst</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> may be used if either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="799">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9055" data-verso-hover="799">b</span></code> unfolds to a local hypothesis.
This is similar to the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> tactic.</p>
                    <p>
                      See also: <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#subst_vars" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.substVars-0" data-verso-hover="2490">subst_vars</span></a></code> for substituting all local hypotheses that have a defining equation.</p>
                    </div>
                  </div>
                <div class="namedocs" id="subst_eqs">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.substEqs" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#subst_eqs" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2491">subst_eqs</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">subst_eq</span></code> repeatedly substitutes according to the equality proof hypotheses in the context,
replacing the left side of the equality with the right, until no more progress can be made.</p>
                    </div>
                  </div>
                <div class="namedocs" id="subst_vars">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.substVars" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#subst_vars" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2490">subst_vars</span></a></pre><div class="text">
                    <p>
                      Applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#subst" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2453">subst</span></a></code> to all hypotheses of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9526" data-verso-hover="2492">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9502" data-verso-hover="110">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9513" data-verso-hover="110">t</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="congr">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.congr" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#congr" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2493">congr</span></a></pre><div class="text">
                    <p>
                      Apply congruence (recursively) to goals of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">as</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">bs</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">as</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≍</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">bs</span></code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congr-next" title="Documentation for congr"><span class="const token" data-binding="const-congr" data-verso-hover="2494">congr</span></a></code> is too aggressive in breaking down the goal.
For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congr-next" title="Documentation for congr"><span class="const token" data-binding="const-congr" data-verso-hover="2494">congr</span></a></code> produces the goals <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code>,
while <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#congr" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.congr-0" data-verso-hover="2493">congr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></code> produces the intended <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="eq_refl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.eqRefl" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#eq_refl" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2476">eq_refl</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#eq_refl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.eqRefl-0" data-verso-hover="2476">eq_refl</span></a></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span></code>, but has a few optimizations.</p>
                    </div>
                  </div>
                <div class="namedocs" id="ac_rfl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.acRfl" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ac_rfl" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2495">ac_rfl</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.acRfl-0" data-verso-hover="2495">ac_rfl</span></a></code> proves equalities up to application of an associative and commutative operator.</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-0">instance</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Associative" data-verso-hover="2496">Std.Associative</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-Std.Associative.mk" data-verso-hover="2497">⟨</span><span class="const token" data-binding="const-Nat.add_assoc" data-verso-hover="2498">Nat.add_assoc</span><span class="unknown token" data-binding="const-Std.Associative.mk" data-verso-hover="2497">⟩</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-68">instance</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Commutative" data-verso-hover="2499">Std.Commutative</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-Std.Commutative.mk" data-verso-hover="2500">⟨</span><span class="const token" data-binding="const-Nat.add_comm" data-verso-hover="2501">Nat.add_comm</span><span class="unknown token" data-binding="const-Std.Commutative.mk" data-verso-hover="2500">⟩</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-136">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-17861912073398755636-197-199-724"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-197" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17861912073398755636-197-199-724"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-200-206-726"><a href="Tactic-Proofs/Tactic-Reference/#ac_rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.acRfl-200" data-verso-hover="2495">ac_rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-200-206-726"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-ref-associativity-commutativity">
                13.5.5. Associativity and Commutativity<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-associativity-commutativity" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="ac_nf">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticAc_nf_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2502">ac_nf</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2502">ac_nf</span></a></code> normalizes equalities up to application of an associative and commutative operator.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2502">ac_nf</span></a></code> normalizes all hypotheses and the goal target of the goal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2502">ac_nf</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-6" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">l</span></code> normalizes at location(s) <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code> is either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">*</span></code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">|</span><span class="unknown token" data-binding="">-</span></code>
can also be used, to signify the target of the goal.</p>
                      </li>
                    </ul>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-0">instance</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Associative" data-verso-hover="2496">Std.Associative</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-Std.Associative.mk" data-verso-hover="2497">⟨</span><span class="const token" data-binding="const-Nat.add_assoc" data-verso-hover="2498">Nat.add_assoc</span><span class="unknown token" data-binding="const-Std.Associative.mk" data-verso-hover="2497">⟩</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-68">instance</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Commutative" data-verso-hover="2499">Std.Commutative</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-Std.Commutative.mk" data-verso-hover="2500">⟨</span><span class="const token" data-binding="const-Nat.add_comm" data-verso-hover="2501">Nat.add_comm</span><span class="unknown token" data-binding="const-Std.Commutative.mk" data-verso-hover="2500">⟩</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-136">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-17861912073398755636-197-199-727"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-197" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17861912073398755636-197-199-727"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.133" data-verso-hover="9">d</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.129" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="9">c</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="9">a</span></span></span></span></span></span><span class="inter-text">
 </span><span class="tactic"><label for="tactic-state-7-201-206-729"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-201" data-verso-hover="2502">ac_nf</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-201-206-729"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
 -- goal: a + (b + (c + d)) = a + (b + (c + d))
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="ac_nf0">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.acNf0" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf0" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2503">ac_nf0</span></a></pre><div class="text">
                  <p>
                    Implementation of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2502">ac_nf</span></a></code> (the full <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ac_nf" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAc_nf_-0" data-verso-hover="2502">ac_nf</span></a></code> calls <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2464">trivial</span></code> afterwards).</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-lemmas">
                13.5.6. Lemmas<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-lemmas" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="exact">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.exact" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="914">exact</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> closes the main goal if its target type matches that of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.apply" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-0" data-verso-hover="841">apply</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> tries to match the current goal against the conclusion of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p>
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code> tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.</p>
                  </div>
                </div>
              <div class="namedocs" id="refine">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.refine" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#refine" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2413">refine</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.refine-0" data-verso-hover="2413">refine</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> behaves like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code>, except that named (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">x</span></code>) or unnamed (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">_</span></code>)
holes in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> that are not solved by unification with the main goal's target type
are converted into new goals, using the hole's name, if any, as the goal case name.</p>
                  </div>
                </div>
              <div class="namedocs" id="refine___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.refine'" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#refine___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2446">refine'</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.refine'-0" data-verso-hover="2446">refine'</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> behaves like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.refine-0" data-verso-hover="2413">refine</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code>, except that unsolved placeholders (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>)
and implicit parameters are also converted into new goals.</p>
                  </div>
                </div>
              <div class="namedocs" id="solve_by_elim">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.solveByElim" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2468">solve_by_elim</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code> calls <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code> on the main goal to find an assumption whose head matches
and then repeatedly calls <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code> on the generated subgoals until no subgoals remain,
performing at most <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">maxDepth</span></code> (defaults to 6) recursive steps.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code> discharges the current goal or fails.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code> performs backtracking if subgoals can not be solved.</p>
                  <p>
                    By default, the assumptions passed to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code> are the local context, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2464">trivial</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun" title="Documentation for congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1555">congrFun</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg" title="Documentation for congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="927">congrArg</span></a></code>.</p>
                  <p>
                    The assumptions can be modified with similar syntax as for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hᵣ</span><span class="unknown token" data-binding="">]</span></code> also applies the given expressions.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hᵣ</span><span class="unknown token" data-binding="">]</span></code> does not include the local context,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2464">trivial</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun" title="Documentation for congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1555">congrFun</span></a></code>, or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg" title="Documentation for congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="927">congrArg</span></a></code> unless they are explicitly included.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">hₙ</span><span class="unknown token" data-binding="">]</span></code> removes the given local hypotheses.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">a₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> uses all lemmas which have been labelled
with the attributes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aᵢ</span></code> (these attributes must be created using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">register_label_attr</span></code>).</p>
                      </li>
                    </ul>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a><span class="unknown token" data-binding="">*</span></code> tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.
(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)</p>
                  <p>
                    Optional arguments passed via a configuration argument as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">solve_by_elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code></p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">maxDepth</span></code>: number of attempts at discharging generated subgoals</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2465">symm</span></a></code>: adds all hypotheses derived by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2465">symm</span></a></code> (defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="43">true</span></a></code>).</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2466">exfalso</span></a></code>: allow calling <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2466">exfalso</span></a></code> and trying again if <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code> fails
(defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="43">true</span></a></code>).</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">transparency</span></code>: change the transparency mode when calling <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code>. Defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.default</span></code>,
but it is often useful to change to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.reducible</span></code>,
so semireducible definitions will not be unfolded when trying to apply a lemma.</p>
                      </li>
                    </ul>
                  <p>
                    See also the doc-comment for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Meta.Tactic.Backtrack.BacktrackConfig" data-verso-hover="2504">Lean.Meta.Tactic.Backtrack.BacktrackConfig</span></code> for the options
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">proc</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">suspend</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">discharge</span></code> which allow further customization of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code>.
Both <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyAssumption-0" data-verso-hover="2463">apply_assumption</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a></code> are implemented via these hooks.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_rules">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.applyRules" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2505">apply_rules</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">l₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">l₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> tries to solve the main goal by iteratively
applying the list of lemmas <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">l₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">l₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> or by applying a local hypothesis.
If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code> generates new goals, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a></code> iteratively tries to solve those goals.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code> to omit a local hypothesis.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a></code> will also use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2464">trivial</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrFun" title="Documentation for congrFun"><span class="const token" data-binding="const-congrFun" data-verso-hover="1555">congrFun</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#congrArg" title="Documentation for congrArg"><span class="const token" data-binding="const-congrArg" data-verso-hover="927">congrArg</span></a></code>.
These can be disabled, as can local hypotheses, by using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span><span class="inter-text"> </span><span class="unknown token" data-binding="">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code>.</p>
                  <p>
                    You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">a₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> to use all lemmas which have been labelled
with the attributes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aᵢ</span></code> (these attributes must be created using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">register_label_attr</span></code>).</p>
                  <p>
                    You can pass a further configuration via the syntax <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply_rules</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code>.
The options supported are the same as for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code> (and include all the options for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code>).</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a></code> will try calling <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#symm" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.symm-0" data-verso-hover="2465">symm</span></a></code> on hypotheses and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2466">exfalso</span></a></code> on the goal as needed.
This can be disabled with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">symm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">exfalso</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  <p>
                    You can bound the iteration depth using the syntax <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">config</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">maxDepth</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  <p>
                    Unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_rules" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.applyRules-0" data-verso-hover="2505">apply_rules</span></a></code> does not perform backtracking, and greedily applies
a lemma from the list until it gets stuck.</p>
                  </div>
                </div>
              <div class="namedocs" id="as_aux_lemma">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.as_aux_lemma" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#as_aux_lemma" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2506">as_aux_lemma</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">as_aux_lemma</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> does the same as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code>, except that it wraps the resulting expression
into an auxiliary lemma. In some cases, this significantly reduces the size of expressions
because the proof term is not duplicated.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-false">
                13.5.7. Falsehood<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-false" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="exfalso">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticExfalso" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exfalso" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2466">exfalso</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2466">exfalso</span></a></code> converts a goal <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tgt</span></code> into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">False</span></code> by applying <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False___elim" title="Documentation for False.elim"><span class="const token" data-binding="const-False.elim" data-verso-hover="1539">False.elim</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="contradiction">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.contradiction" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1329">contradiction</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-0" data-verso-hover="1329">contradiction</span></a></code> closes the main goal if its hypotheses are "trivially contradictory".</p>
                  <ul>
                    <li>
                      <p>
                        Inductive type/family with no applicable constructors</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="563">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="135">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-15772364970733650827-27-29-730"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15772364970733650827-27-29-730"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="2507">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort ?u.9</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="563">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="2507">p</span><span class="inter-text"></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-30-43-732"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-30" data-verso-hover="1329">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-30-43-732"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Injectivity of constructors</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.72" data-verso-hover="2508">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="50">none</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="49">some</span></a><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="43">true</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="135">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-6350168296144633595-38-40-733"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-38" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6350168296144633595-38-40-733"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.77" data-verso-hover="2509">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort ?u.73</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.72" data-verso-hover="2508">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="50">none</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="49">some</span></a><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="43">true</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.77" data-verso-hover="2509">p</span><span class="inter-text"></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-41-54-735"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-41" data-verso-hover="1329">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-41-54-735"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">  --
</span><span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Decidable false proposition</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.180" data-verso-hover="2510">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="135">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7629240804079509855-31-33-736"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-31" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7629240804079509855-31-33-736"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.273" data-verso-hover="2511">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort ?u.181</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.180" data-verso-hover="2510">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.273" data-verso-hover="2511">p</span><span class="inter-text"></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-34-47-738"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-34" data-verso-hover="1329">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-34-47-738"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Contradictory hypotheses</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="1990">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1989">h'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="135">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-3645137184017334541-35-37-739"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3645137184017334541-35-37-739"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.23" data-verso-hover="338">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.24" data-verso-hover="2512">q</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort ?u.17</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14" data-verso-hover="1990">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="338">p</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1989">h'</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Logical-Connectives/#Not" title="Documentation for Not"><span class="const token" data-binding="const-Not" data-verso-hover="784">¬</span></a><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="338">p</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="2512">q</span><span class="inter-text"></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-38-51-741"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-38" data-verso-hover="1329">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-38-51-741"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></li>
                    <li>
                      <p>
                        Other simple contradictions such as</p>
                      <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="2513">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">x</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="135">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-2783459511696467918-39-41-742"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-39" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2783459511696467918-39-41-742"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.22" data-verso-hover="2512">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort ?u.17</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="2513">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ne" data-verso-hover="653">≠</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="9">x</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="2512">p</span><span class="inter-text"></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-42-55-744"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-42" data-verso-hover="1329">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-42-55-744"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="false_or_by_contra">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.falseOrByContra" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#false_or_by_contra" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2514">false_or_by_contra</span></a></pre><div class="text">
                  <p>
                    Changes the goal to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a></code>, retaining as much information as possible:</p>
                  <ul>
                    <li>
                      <p>
                        If the goal is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a></code>, do nothing.</p>
                      </li>
                    <li>
                      <p>
                        If the goal is an implication or a function type, introduce the argument and restart.
(In particular, if the goal is <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14002" data-verso-hover="799">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14012" data-verso-hover="799">y</span></code>, introduce <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14002" data-verso-hover="110">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14012" data-verso-hover="110">y</span></code>.)</p>
                      </li>
                    <li>
                      <p>
                        Otherwise, for a propositional goal <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14031" data-verso-hover="2035">P</span></code>, replace it with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">¬</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14031" data-verso-hover="338">P</span></code>
(attempting to find a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a></code> instance, but otherwise falling back to working classically)
and introduce <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">¬</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14031" data-verso-hover="338">P</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        For a non-propositional goal use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Truth/#False___elim" title="Documentation for False.elim"><span class="const token" data-binding="const-False.elim" data-verso-hover="1539">False.elim</span></a></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-goals">
                13.5.8. Goal Management<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-goals" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="suffices">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticSuffices_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#suffices" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="917">suffices</span></a></pre><div class="text">
                  <p>
                    Given a main goal <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ctx</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#suffices" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSuffices_-0" data-verso-hover="917">suffices</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t'</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-16">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> replaces the main goal with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ctx</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊢</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t'</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> must have type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code> in the context <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ctx</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t'</span></code>.</p>
                  <p>
                    The variant <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">suffices</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t'</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">by</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> is a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">suffices</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t'</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">from</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">by</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code>.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span></code> is omitted, the name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> is used.</p>
                  </div>
                </div>
              <div class="namedocs" id="change">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.change" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#change" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2515">change</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.change-0" data-verso-hover="2515">change</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">tgt'</span></code> will change the goal from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tgt</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tgt'</span></code>,
assuming these are definitionally equal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.change-0" data-verso-hover="2515">change</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">t'</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> will change hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14623" data-verso-hover="2414">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14601" data-verso-hover="2516">t</span></code> to have type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t'</span></code>, assuming
assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14601" data-verso-hover="2516">t</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t'</span></code> are definitionally equal.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="change-_________-with-_________">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.changeWith" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2517">change ... with ...</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2517">change</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2517">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> will change occurrences of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> in the goal,
assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> are definitionally equal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2517">change</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#change-_________-with-_________" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.changeWith-0" data-verso-hover="2517">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-16" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> similarly changes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> in the type of hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="generalize">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.generalize" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#generalize" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2518">generalize</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">generalize</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,+</span></code> replaces all occurrences <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15183" data-verso-hover="72">e</span></code>s in the main goal
with a fresh hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15206" data-verso-hover="1978">x</span></code>s. If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15222" data-verso-hover="2035">h</span></code> is given, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15222" data-verso-hover="2519">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15183" data-verso-hover="799">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15206" data-verso-hover="799">x</span></code> is introduced as well.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#generalize" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.generalize-0" data-verso-hover="2518">generalize</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-17" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hₙ</span></code> also generalizes occurrences of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15183" data-verso-hover="799">e</span></code>
inside <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h₁</span></code>, ..., <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hₙ</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#generalize" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.generalize-0" data-verso-hover="2518">generalize</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-17" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span></code> will generalize occurrences of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15183" data-verso-hover="799">e</span></code> everywhere.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="specialize">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.specialize" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#specialize" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1342">specialize</span></a></pre><div class="text">
                  <p>
                    The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#specialize" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.specialize-0" data-verso-hover="1342">specialize</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">aₙ</span></code> works on local hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.
The premises of this hypothesis, either universal quantifications or
non-dependent implications, are instantiated by concrete terms coming
from arguments <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a₁</span></code> ... <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">aₙ</span></code>.
The tactic adds a new hypothesis with the same name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">aₙ</span></code>
and tries to clear the previous one.</p>
                  </div>
                </div>
              <div class="namedocs" id="obtain">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.obtain" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#obtain" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1339">obtain</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#obtain" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-0" data-verso-hover="1339">obtain</span></a></code> tactic is a combination of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code>. See <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> for
a description of supported patterns.</p>
                  <pre>obtain ⟨patt⟩ : type := proof
</pre><p>
                    is equivalent to</p>
                  <pre>have h : type := proof
rcases h with ⟨patt⟩
</pre><p>
                    If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">patt</span><span class="unknown token" data-binding="">⟩</span></code> is omitted, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> will try to infer the pattern.</p>
                  <p>
                    If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">type</span></code> is omitted, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">proof</span></code> is required.</p>
                  </div>
                </div>
              <div class="namedocs" id="show">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.show" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#show" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1281">show</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#show" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.show-0" data-verso-hover="1281">show</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> finds the first goal whose target unifies with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="show_term">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.showTerm" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#show_term" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2520">show_term</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.showTermElab-0" data-verso-hover="2521">show_term</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16054" data-verso-hover="72">tac</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16054" data-verso-hover="72">tac</span></code>, then prints the generated term in the form
"exact X Y Z" or "refine X ?_ Z" (prefixed by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#expose_names" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exposeNames-0" data-verso-hover="2522">expose_names</span></a></code> if necessary)
if there are remaining subgoals.</p>
                  <p>
                    (For some tactics, the printed term will not be human readable.)</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-casts">
                13.5.9. Cast Management<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-casts" title="Permalink">🔗</a></span></h2>
              <p>
                The tactics in this section make it easier avoid getting stuck on <span id="--tech-term-casts" class="def-technical-term"><em>casts</em></span>, which are functions that coerce data from one type to another, such as converting a natural number to the corresponding integer.
They are described in more detail by Lewis and Madelaine (2020)<span class="marginalia"><span class="note"><span class="citation">Robert Y. Lewis and Paul-Nicolas Madelaine, 2020. <a href="https://arxiv.org/abs/2001.10594">“Simplifying Casts and Coercions”</a>. arXiv:2001.10594</span></span></span>.</p>
              <div class="namedocs" id="norm_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticNorm_cast__" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2229">norm_cast</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> family of tactics is used to normalize certain coercions (<em>casts</em>) in expressions.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> normalizes casts in the target.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> normalizes casts in hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    The tactic is basically a version of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code> with a specific set of lemmas to move casts
upwards in the expression.
Therefore even in situations where non-terminal <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code> calls are discouraged (because of fragility),
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> is considered to be safe.
It also has special handling of numerals.</p>
                  <p>
                    For instance, given an assumption</p>
                  <pre>a b : ℤ
h : ↑a + ↑b &lt; (10 : ℚ)
</pre><p>
                    writing <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> will turn <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> into</p>
                  <pre>h : a + b &lt; 10
</pre><p>
                    There are also variants of basic tactics that use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> to normalize expressions during
their operation, to make them more flexible about the expressions they accept
(we say that it is a tactic <em>modulo</em> the effects of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code>):</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2523">exact_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="914">exact</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2524">apply_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code>.
Writing <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExact_mod_cast_-0" data-verso-hover="2523">exact_mod_cast</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticApply_mod_cast_-0" data-verso-hover="2524">apply_mod_cast</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> will normalize casts
in the goal and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> before using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-0" data-verso-hover="841">apply</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2525">rw_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1285">rw</span></a></code>. It applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> between rewrites.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAssumption_mod_cast_-0" data-verso-hover="2526">assumption_mod_cast</span></a></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code>.
This is effectively <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">norm_cast</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">assumption</span></code>, but more efficient.
It normalizes casts in the goal and, for every hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> in the context,
it will try to normalize casts in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> and use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    See also <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2527">push_cast</span></a></code>, which moves casts inwards rather than lifting them outwards.</p>
                  </div>
                </div>
              <div class="namedocs" id="push_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.pushCast" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2527">push_cast</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2527">push_cast</span></a></code> rewrites the goal to move certain coercions (<em>casts</em>) inward, toward the leaf nodes.
This uses <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> lemmas in the forward direction.
For example, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">↑</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span></code> will be written to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">↑</span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↑</span><span class="unknown token" data-binding="">b</span></code>.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2527">push_cast</span></a></code> moves casts inward in the goal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2527">push_cast</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> moves casts inward in the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.
It can be used with extra simp lemmas with, for example, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-0" data-verso-hover="2527">push_cast</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Int.add_zero</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Example:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="2528">h1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">10</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.200" data-verso-hover="2529">h2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">10</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">10</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-910144766026444896-136-138-745"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-136" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-910144766026444896-136-138-745"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.82" data-verso-hover="2528">h1</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.200" data-verso-hover="2529">h2</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">↑</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span></span></span><span class="inter-text">
  /-
  h1 : ↑(a + b) = 10
  h2 : ↑(a + b + 0) = 10
  ⊢ ↑(a + b) = 10
  -/
  </span><span class="tactic"><label for="tactic-state-10572882187133259922-223-232-747"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-223" data-verso-hover="2527">push_cast</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10572882187133259922-223-232-747"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.82" data-verso-hover="2528">h1</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.200" data-verso-hover="2529">h2</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span></span></span><span class="inter-text">
  /- Now
  ⊢ ↑a + ↑b = 10
  -/
  </span><span class="tactic"><label for="tactic-state-11428354520886299146-272-287-749"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-272" data-verso-hover="2527">push_cast</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-282" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="2528">h1</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11428354520886299146-272-287-749"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.82" data-verso-hover="2530">h1</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.200" data-verso-hover="2529">h2</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-15852052108257878001-290-320-751"><a href="Tactic-Proofs/Tactic-Reference/#push_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.pushCast-290" data-verso-hover="2527">push_cast</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Int.add_zero" data-verso-hover="2531">Int.add_zero</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-315" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.200" data-verso-hover="2529">h2</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15852052108257878001-290-320-751"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.82" data-verso-hover="2530">h1</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.363" data-verso-hover="2530">h2</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↑</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="9">b</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">10</span></span></span></span></span></span><span class="inter-text">
  /- Now
  h1 h2 : ↑a + ↑b = 10
  -/
  </span><span class="tactic"><label for="tactic-state-7-364-372-753"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-364" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="2530">h1</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-364-372-753"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    See also <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="exact_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticExact_mod_cast_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exact_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2523">exact_mod_cast</span></a></pre><div class="text">
                  <p>
                    Normalize casts in the goal and the given expression, then close the goal with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="914">exact</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticApply_mod_cast_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2524">apply_mod_cast</span></a></pre><div class="text">
                  <p>
                    Normalize casts in the goal and the given expression, then <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code> the expression to the goal.</p>
                  </div>
                </div>
              <div class="namedocs" id="rw_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticRw_mod_cast___" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rw_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2525">rw_mod_cast</span></a></pre><div class="text">
                  <p>
                    Rewrites with the given rules, normalizing casts prior to each step.</p>
                  </div>
                </div>
              <div class="namedocs" id="assumption_mod_cast">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticAssumption_mod_cast_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2526">assumption_mod_cast</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption_mod_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAssumption_mod_cast_-0" data-verso-hover="2526">assumption_mod_cast</span></a></code> is a variant of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code> that solves the goal
using a hypothesis. Unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code>, it first pre-processes the goal and
each hypothesis to move casts as far outwards as possible, so it can be used
in more situations.</p>
                  <p>
                    Concretely, it runs <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> on the goal. For each local hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>, it also
normalizes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#norm_cast" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNorm_cast__-0" data-verso-hover="2229">norm_cast</span></a></code> and tries to use that to close the goal.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-ext">
                13.5.10. Extensionality<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-ext" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="ext">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Elab.Tactic.Ext.ext" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ext" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="300">ext</span></a></pre><div class="text">
                  <p>
                    Applies extensionality lemmas that are registered with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.ext-2" data-verso-hover="2532">ext</span><span class="unknown token" data-binding="">]</span></code> attribute.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> applies extensionality theorems as much as possible,
using the patterns <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> to introduce the variables in extensionality theorems using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2433">rintro</span></a></code>.
For example, the patterns are used to name the variables introduced by lemmas such as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext" title="Documentation for funext"><span class="const token" data-binding="const-funext" data-verso-hover="299">funext</span></a></code>.</p>
                      </li>
                    <li>
                      <p>
                        Without patterns,<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#ext" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Elab.Tactic.Ext.ext-0" data-verso-hover="300">ext</span></a></code> applies extensionality lemmas as much
as possible but introduces anonymous hypotheses whenever needed.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code> applies ext theorems only up to depth <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> tactic is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> except that it only applies a single extensionality theorem.</p>
                  <p>
                    Unused patterns will generate warning.
Patterns that don't match the variables will typically result in the introduction of anonymous hypotheses.</p>
                  </div>
                </div>
              <div class="namedocs" id="ext1">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Elab.Tactic.Ext.tacticExt1___" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#ext1" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2533">ext1</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">ext</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> except that it only applies a single extensionality theorem rather
than recursively applying as many extensionality theorems as possible.</p>
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">*</span></code> patterns are processed using the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2433">rintro</span></a></code> tactic.
If no patterns are supplied, then variables are introduced anonymously using the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-0" data-verso-hover="515">intros</span></a></code> tactic.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply_ext_theorem">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Elab.Tactic.Ext.applyExtTheorem" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply_ext_theorem" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2534">apply_ext_theorem</span></a></pre><div class="text">
                  <p>
                    Apply a single extensionality theorem to the current goal.</p>
                  </div>
                </div>
              <div class="namedocs" id="funext-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=tacticFunext___" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#funext-next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="119">funext</span></a></pre><div class="text">
                  <p>
                    Apply function extensionality and introduce new hypotheses.
The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#funext-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-tacticFunext___-0" data-verso-hover="119">funext</span></a></code> will keep applying the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext" title="Documentation for funext"><span class="const token" data-binding="const-funext" data-verso-hover="299">funext</span></a></code> lemma until the goal target is not reducible to</p>
                  <pre>  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))
</pre><p>
                    The variant <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#funext-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-tacticFunext___-0" data-verso-hover="119">funext</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hₙ</span></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext" title="Documentation for funext"><span class="const token" data-binding="const-funext" data-verso-hover="299">funext</span></a></code> <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> times, and uses the given identifiers to name the new hypotheses.
Patterns can be used like in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a></code> tactic. Example, given a goal</p>
                  <pre>  |-  ((fun x : Nat × Bool =&gt; ...) = (fun x =&gt; ...))
</pre><p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#funext-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-tacticFunext___-0" data-verso-hover="119">funext</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Functions/#funext" title="Documentation for funext"><span class="const token" data-binding="const-funext" data-verso-hover="299">funext</span></a></code> once and performs pattern matching on the newly introduced pair.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--SMT-Inspired-Automation">
                13.5.11. SMT-Inspired Automation</h2>
              <div class="namedocs" id="grind">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.grind" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1">grind</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> is a tactic inspired by modern SMT solvers. <strong>Picture a virtual whiteboard</strong>:
every time grind discovers a new equality, inequality, or logical fact,
it writes it on the board, groups together terms known to be equal,
and lets each reasoning engine read from and contribute to the shared workspace.
These engines work together to handle equality reasoning, apply known theorems,
propagate new facts, perform case analysis, and run specialized solvers
for domains like linear arithmetic and commutative rings.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> is <em>not</em> designed for goals whose search space explodes combinatorially,
think large pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards,
or a 200‑variable Sudoku encoded as Boolean constraints.  Such encodings require
thousands (or millions) of case‑splits that overwhelm <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code>’s branching search.</p>
                  <p>
                    For <strong>bit‑level or combinatorial problems</strong>, consider using <strong><code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code></strong>.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code> calls a state‑of‑the‑art SAT solver (CaDiCaL) and then returns a
<em>compact, machine‑checkable certificate</em>.</p>
                  <p>
                    <strong>Equality reasoning</strong></p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> uses <strong>congruence closure</strong> to track equalities between terms.
When two terms are known to be equal, congruence closure automatically deduces
equalities between more complex expressions built from them.
For example, if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.19715" data-verso-hover="2488">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19728" data-verso-hover="2488">b</span></code>, then congruence closure will also conclude that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span></code> = <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code>
for any function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.19740" data-verso-hover="2035">f</span></code>. This forms the foundation for efficient equality reasoning in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code>.
Here is an example:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="2489">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="9">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="9">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">a</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-10316847347229064147-61-63-754"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-61" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10316847347229064147-61-63-754"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="9">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.33" data-verso-hover="9">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="2489">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="9">a</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="9">b</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="9">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1053">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="9">a</span><span class="unknown token" data-binding="">)</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-66-71-756"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-66" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-66-71-756"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    <strong>Applying theorems using E-matching</strong></p>
                  <p>
                    To apply existing theorems, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> uses a technique called <strong>E-matching</strong>,
which finds matches for known theorem patterns while taking equalities into account.
Combined with congruence closure, E-matching helps <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> discover
non-obvious consequences of theorems and equalities automatically.</p>
                  <p>
                    Consider the following functions and theorems:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-f" data-verso-hover="2535">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-g" data-verso-hover="2536">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text">

</span><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-70" data-verso-hover="2537">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-79">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-gf" data-verso-hover="2538">gf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-g" data-verso-hover="2536">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-f" data-verso-hover="2535">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="9">x</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-10781167334723028126-117-119-757"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-117" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10781167334723028126-117-119-757"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.188" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-g" data-verso-hover="2536">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-f" data-verso-hover="2535">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="9">x</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="9">x</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-122-133-759"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-122" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-f" data-verso-hover="2535">f</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-g" data-verso-hover="2536">g</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-122-133-759"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    The theorem <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">gf</span></code> asserts that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19937" data-verso-hover="2539">x</span></code> for all natural numbers <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.19937" data-verso-hover="2539">x</span></code>.
The attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-1" data-verso-hover="2537">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">]</span></code> instructs <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> to use the left-hand side of the equation,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span></code>, as a pattern for E-matching.
Suppose we now have a goal involving:</p>
                  <pre>example {a b} (h : f b = a) : g a = b := by
  grind
</pre><p>
                    Although <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span></code> is not an instance of the pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span></code>,
it becomes one modulo the equation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20371" data-verso-hover="2540">a</span></code>. By substituting <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.20371" data-verso-hover="2540">a</span></code>
with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span></code>, we obtain the term <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span></code>,
which matches the pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span></code> with the assignment <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code>.
Thus, the theorem <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">gf</span></code> is instantiated with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code>,
and the new equality <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20844" data-verso-hover="2541">b</span></code> is asserted.
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> then uses congruence closure to derive the implied equality
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">)</span></code> and completes the proof.</p>
                  <p>
                    The pattern used to instantiate theorems affects the effectiveness of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code>.
For example, the pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">)</span></code> is too restrictive in the following case:
the theorem <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">gf</span></code> will not be instantiated because the goal does not even
contain the function symbol <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.21495" data-verso-hover="72">g</span></code>.</p>
                  <pre>example (h₁ : f b = a) (h₂ : f c = a) : b = c := by
  grind
</pre><p>
                    You can use the command <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind_pattern</span></code> to manually select a pattern for a given theorem.
In the following example, we instruct <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> to use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code> as the pattern,
allowing it to solve the goal automatically:</p>
                  <pre>grind_pattern gf =&gt; f x

example {a b c} (h₁ : f b = a) (h₂ : f c = a) : b = c := by
  grind
</pre><p>
                    You can enable the option <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The--grind--tactic/E___matching/#trace___grind___ematch___instance" title="Documentation for option trace.grind.ematch.instance"><span class="option token" data-binding="option-trace.grind.ematch.instance" data-verso-hover="2542">trace.grind.ematch.instance</span></a></code> to make <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> print a
trace message for each theorem instance it generates.</p>
                  <p>
                    You can also specify a <strong>multi-pattern</strong> to control when <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> should apply a theorem.
A multi-pattern requires that all specified patterns are matched in the current context
before the theorem is applied. This is useful for theorems such as transitivity rules,
where multiple premises must be simultaneously present for the rule to apply.
The following example demonstrates this feature using a transitivity axiom for a binary relation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span></code>:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.opaque-0">opaque</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text">
</span><a href="Axioms/#Lean___Parser___Command___axiom-next" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.axiom-32">axiom</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Rtrans" data-verso-hover="2544">Rtrans</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="163">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="163">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="163">z</span><span class="inter-text">

</span><a href="The--grind--tactic/E___matching/#Lean___Parser___Command___grindPattern" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.grindPattern-88">grind_pattern</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Rtrans" data-verso-hover="2544">Rtrans</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="163">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.105" data-verso-hover="163">z</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-126">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.125" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">d</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.125" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.125" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7118131277542949687-185-187-760"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-185" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7118131277542949687-185-187-760"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.119" data-verso-hover="163">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="163">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.125" data-verso-hover="163">c</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">d</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.125" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.125" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">d</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-190-195-762"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-190" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-190-195-762"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    By specifying the multi-pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z</span></code>, we instruct <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> to
instantiate <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Rtrans</span></code> only when both <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z</span></code> are available in the context.
In the example, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Rtrans</span></code> to derive <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span></code> from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span></code>,
and can then repeat the same reasoning to deduce <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span></code> from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span></code>.</p>
                  <p>
                    Instead of using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind_pattern</span></code> to explicitly specify a pattern,
you can use the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-2" data-verso-hover="2537">grind</span><span class="unknown token" data-binding="">]</span></code> attribute or one of its variants, which will use a heuristic to
generate a (multi-)pattern. The complete list is available in the reference manual. The main ones are:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-2" data-verso-hover="2537">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="unknown token" data-binding="">]</span></code> will select a multi-pattern from the hypotheses of the theorem (i.e. it will use the theorem for forwards reasoning).
In more detail, it will traverse the hypotheses of the theorem from left-to-right, and each time it encounters a minimal indexable
(i.e. has a constant as its head) subexpression which "covers" (i.e. fixes the value of) an argument which was not
previously covered, it will add that subexpression as a pattern, until all arguments have been covered.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-2" data-verso-hover="2537">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="unknown token" data-binding="">]</span></code> will select a multi-pattern from the conclusion of theorem (i.e. it will use the theorem for backwards reasoning).
This may fail if not all the arguments to the theorem appear in the conclusion.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-2" data-verso-hover="2537">grind</span><span class="unknown token" data-binding="">]</span></code> will traverse the conclusion and then the hypotheses left-to-right, adding patterns as they increase the coverage,
stopping when all arguments are covered.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-2" data-verso-hover="2537">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">]</span></code> checks that the conclusion of the theorem is an equality, and then uses the left-hand-side of the equality as a pattern.
This may fail if not all of the arguments appear in the left-hand-side.</p>
                      </li>
                    </ul>
                  <p>
                    Here is the previous example again but using the attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-1" data-verso-hover="2537">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="unknown token" data-binding="">]</span></code></p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.opaque-0">opaque</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text">
</span><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-34" data-verso-hover="2537">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><a href="Axioms/#Lean___Parser___Command___axiom-next" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.axiom-45">axiom</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Rtrans" data-verso-hover="2544">Rtrans</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="163">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="163">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="163">z</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-101">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="163">d</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="163">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="163">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-12521892397946165597-160-162-763"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-160" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12521892397946165597-160-162-763"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.131" data-verso-hover="163">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.134" data-verso-hover="163">c</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.137" data-verso-hover="163">d</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="163">c</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="163">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The--grind--tactic/Bigger-Examples/#R" title="Definition of example"><span class="const token" data-binding="const-R" data-verso-hover="2543">R</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="163">d</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-165-170-765"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-165" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-165-170-765"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    To control theorem instantiation and avoid generating an unbounded number of instances,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> uses a generation counter. Terms in the original goal are assigned generation zero.
When <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> applies a theorem using terms of generation <code>≤ n</code>, any new terms it creates
are assigned generation <code>n + 1</code>. This limits how far the tactic explores when applying
theorems and helps prevent an excessive number of instantiations.</p>
                  <p>
                    <strong>Key options:</strong></p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">ematch</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">num</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">)</span></code> controls the number of E-matching rounds.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">name</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> instructs <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> to use the declaration <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.InlineLean.name" data-verso-hover="2545">name</span></code> during E-matching.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">name</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">name</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">]</span></code> but does not use theorems tagged with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.grind-2" data-verso-hover="2537">grind</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">gen</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">num</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">)</span></code> sets the maximum generation.</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Linear integer arithmetic (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cutsat-0" data-verso-hover="2546">cutsat</span></code>)</strong></p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> can solve goals that reduce to <strong>linear integer arithmetic (LIA)</strong> using an
integrated decision procedure called <strong><code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cutsat-0" data-verso-hover="2546">cutsat</span></code></strong>.  It understands</p>
                  <ul>
                    <li>
                      <p>
                        equalities   <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22241" data-verso-hover="9">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span></code></p>
                      </li>
                    <li>
                      <p>
                        inequalities  <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22241" data-verso-hover="9">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span></code></p>
                      </li>
                    <li>
                      <p>
                        disequalities <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22241" data-verso-hover="9">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span></code></p>
                      </li>
                    <li>
                      <p>
                        divisibility  <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22336" data-verso-hover="9">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22241" data-verso-hover="9">p</span></code></p>
                      </li>
                    </ul>
                  <p>
                    The solver incrementally assigns integer values to variables; when a partial
assignment violates a constraint it adds a new, implied constraint and retries.
This <em>model-based</em> search is <strong>complete for LIA</strong>.</p>
                  <p>
                    <strong>Key options:</strong></p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">cutsat</span></code> disable the solver (useful for debugging)</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">qlia</span></code> accept rational models (shrinks the search space but is incomplete for ℤ)</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Examples:</strong></p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-29">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-5393021039961654212-74-76-766"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-74" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5393021039961654212-74-76-766"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="163">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="163">y</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="163">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">4</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ne" data-verso-hover="653">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-79-84-768"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-79" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-79-84-768"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

-- Mixing equalities and inequalities.
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-125">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="typed token" data-binding="" data-verso-hover="163">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-1890563644989569532-194-196-769"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-194" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1890563644989569532-194-196-769"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.190" data-verso-hover="163">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.192" data-verso-hover="163">y</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="163">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="163">y</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="163">y</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-199-204-771"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-199" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-199-204-771"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

-- Reasoning with divisibility.
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-238">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.579" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="typed token" data-binding="" data-verso-hover="163">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.579" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.579" data-verso-hover="163">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-13851606457160420050-318-320-772"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-318" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13851606457160420050-318-320-772"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.579" data-verso-hover="163">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Dvd___mk" title="Documentation for Dvd.dvd"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="513">∣</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Dvd___mk" title="Documentation for Dvd.dvd"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="513">∣</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.579" data-verso-hover="163">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Not" title="Documentation for Not"><span class="const token" data-binding="const-Not" data-verso-hover="784">¬</span></a><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Dvd___mk" title="Documentation for Dvd.dvd"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="513">∣</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.579" data-verso-hover="163">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.577" data-verso-hover="163">a</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-323-328-774"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-323" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-323-328-774"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-330">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="typed token" data-binding="" data-verso-hover="163">27</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">11</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">13</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="typed token" data-binding="" data-verso-hover="163">11</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">13</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">45</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="163">10</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">7</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">9</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="typed token" data-binding="" data-verso-hover="163">7</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">9</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="163">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7981121057751076532-465-467-775"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-465" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7981121057751076532-465-467-775"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">27</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">11</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">13</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">11</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">13</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">45</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">10</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">7</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">9</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">7</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.950" data-verso-hover="163">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">9</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.952" data-verso-hover="163">y</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-470-475-777"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-470" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-470-475-777"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

-- Types that implement the `ToInt` type-class.
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-525">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="620">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1750" data-verso-hover="620">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1752" data-verso-hover="620">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="602">UInt64</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="620">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="620">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1750" data-verso-hover="620">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="620">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1752" data-verso-hover="620">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="620">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1750" data-verso-hover="620">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="620">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1752" data-verso-hover="620">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="620">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-5389443533472740849-609-611-778"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-609" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5389443533472740849-609-611-778"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="620">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="602">UInt64</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1750" data-verso-hover="620">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="602">UInt64</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1752" data-verso-hover="620">c</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="602">UInt64</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="620">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1750" data-verso-hover="620">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1752" data-verso-hover="620">c</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="620">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1750" data-verso-hover="620">b</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1752" data-verso-hover="620">c</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-614-619-780"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-614" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-614-619-780"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    <strong>Algebraic solver (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ring</span></code>)</strong></p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> ships with an algebraic solver nick-named <strong><code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ring</span></code></strong> for goals that can
be phrased as polynomial equations (or disequations) over commutative rings,
semirings, or fields.</p>
                  <p>
                    <em>Works out of the box</em>
All core numeric types and relevant Mathlib types already provide the required
type-class instances, so the solver is ready to use in most developments.</p>
                  <p>
                    What it can decide:</p>
                  <ul>
                    <li>
                      <p>
                        equalities of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22453" data-verso-hover="107">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22463" data-verso-hover="107">q</span></code></p>
                      </li>
                    <li>
                      <p>
                        disequalities <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22453" data-verso-hover="2488">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22463" data-verso-hover="2488">q</span></code></p>
                      </li>
                    <li>
                      <p>
                        basic reasoning under field inverses (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">/</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">⁻¹</span></code>)</p>
                      </li>
                    <li>
                      <p>
                        goals that mix ring facts with other <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> engines</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Key options:</strong></p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">ring</span></code> turn the solver off (useful when debugging)</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">ringSteps</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span></code> cap the number of steps performed by this procedure.</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Examples</strong></p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="127">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Lean</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Grind</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-17">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___CommRing___mk" title="Documentation for Lean.Grind.CommRing"><span class="const token" data-binding="const-Lean.Grind.CommRing" data-verso-hover="2548">CommRing</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="46">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="46">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4463914328686347134-81-83-781"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-81" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4463914328686347134-81-83-781"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.576" data-verso-hover="46">α</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type u_1</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.577" data-verso-hover="2549">inst✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___CommRing___mk" title="Documentation for Lean.Grind.CommRing"><span class="const token" data-binding="const-Lean.Grind.CommRing" data-verso-hover="2548">CommRing</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.576" data-verso-hover="46">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.576" data-verso-hover="46">α</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">(</span></a><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="48">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-86-91-783"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-86" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-86-91-783"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

-- Characteristic 256 means 16 * 16 = 0.
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-134">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___CommRing___mk" title="Documentation for Lean.Grind.CommRing"><span class="const token" data-binding="const-Lean.Grind.CommRing" data-verso-hover="2548">CommRing</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.880" data-verso-hover="46">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___IsCharP___mk" title="Documentation for Lean.Grind.IsCharP"><span class="const token" data-binding="const-Lean.Grind.IsCharP" data-verso-hover="2551">IsCharP</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.880" data-verso-hover="46">α</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">256</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.880" data-verso-hover="46">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">16</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">16</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4214666980785937655-217-219-784"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-217" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4214666980785937655-217-219-784"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1324" data-verso-hover="46">α</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type u_1</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1325" data-verso-hover="2549">inst✝¹</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___CommRing___mk" title="Documentation for Lean.Grind.CommRing"><span class="const token" data-binding="const-Lean.Grind.CommRing" data-verso-hover="2548">CommRing</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1324" data-verso-hover="46">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1326" data-verso-hover="2552">inst✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___IsCharP___mk" title="Documentation for Lean.Grind.IsCharP"><span class="const token" data-binding="const-Lean.Grind.IsCharP" data-verso-hover="2551">IsCharP</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1324" data-verso-hover="46">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">256</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.1324" data-verso-hover="46">α</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">16</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">(</span></a><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">16</span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.910" data-verso-hover="48">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-222-227-786"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-222" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-222-227-786"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

-- Works on built-in rings such as `UInt8`.
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-273">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt8___ofBitVec" title="Documentation for UInt8"><span class="const token" data-binding="const-UInt8" data-verso-hover="261">UInt8</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="2553">16</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="2553">16</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-17440865434508094419-324-326-787"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-324" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17440865434508094419-324-326-787"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Fixed-Precision-Integers/#UInt8___ofBitVec" title="Documentation for UInt8"><span class="const token" data-binding="const-UInt8" data-verso-hover="261">UInt8</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">16</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">(</span></a><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">16</span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="2553">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-329-334-789"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-329" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-329-334-789"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-336">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___CommRing___mk" title="Documentation for Lean.Grind.CommRing"><span class="const token" data-binding="const-Lean.Grind.CommRing" data-verso-hover="2548">CommRing</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2385" data-verso-hover="46">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2385" data-verso-hover="46">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">7</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">9</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="unknown token" data-binding="">^</span><span class="typed token" data-binding="" data-verso-hover="9">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-1063722440212029183-478-480-790"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-478" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1063722440212029183-478-480-790"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9493" data-verso-hover="46">α</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type u_1</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9494" data-verso-hover="2549">inst✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___CommRing___mk" title="Documentation for Lean.Grind.CommRing"><span class="const token" data-binding="const-Lean.Grind.CommRing" data-verso-hover="2548">CommRing</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9493" data-verso-hover="46">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.9493" data-verso-hover="46">α</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.9493" data-verso-hover="46">α</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.9493" data-verso-hover="46">α</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">7</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2390" data-verso-hover="48">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">4</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2392" data-verso-hover="48">b</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">4</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">9</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2394" data-verso-hover="48">c</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HPow___mk" title="Documentation for HPow.hPow"><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="2550">^</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">4</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-483-488-792"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-483" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-483-488-792"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-490">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___Field___mk" title="Documentation for Lean.Grind.Field"><span class="const token" data-binding="const-Lean.Grind.Field" data-verso-hover="2554">Field</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9912" data-verso-hover="46">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___NoNatZeroDivisors___mk" title="Documentation for Lean.Grind.NoNatZeroDivisors"><span class="const token" data-binding="const-Lean.Grind.NoNatZeroDivisors" data-verso-hover="2555">NoNatZeroDivisors</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9912" data-verso-hover="46">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9912" data-verso-hover="46">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="typed token" data-binding="" data-verso-hover="48">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">/</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">/</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="48">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="48">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">/</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="48">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-12318682732334939157-584-586-793"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-584" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12318682732334939157-584-586-793"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10349" data-verso-hover="46">α</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type u_1</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10350" data-verso-hover="2556">inst✝¹</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___Field___mk" title="Documentation for Lean.Grind.Field"><span class="const token" data-binding="const-Lean.Grind.Field" data-verso-hover="2554">Field</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10349" data-verso-hover="46">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10351" data-verso-hover="2557">inst✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#Lean___Grind___NoNatZeroDivisors___mk" title="Documentation for Lean.Grind.NoNatZeroDivisors"><span class="const token" data-binding="const-Lean.Grind.NoNatZeroDivisors" data-verso-hover="2555">NoNatZeroDivisors</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10349" data-verso-hover="46">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.10349" data-verso-hover="46">α</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HDiv___mk" title="Documentation for HDiv.hDiv"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1194">/</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HDiv___mk" title="Documentation for HDiv.hDiv"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1194">/</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">(</span></a><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HDiv___mk" title="Documentation for HDiv.hDiv"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1194">/</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">(</span></a><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">*</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9946" data-verso-hover="48">a</span><a href="Type-Classes/Basic-Classes/#HMul___mk" title="Documentation for HMul.hMul"><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="2547">)</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-589-594-795"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-589" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-589-594-795"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    <strong>Other options</strong></p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">grind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">splits</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="unknown token" data-binding="">num</span><span class="unknown token" data-binding="">&gt;</span><span class="unknown token" data-binding="">)</span></code> caps the <em>depth</em> of the search tree.  Once a branch performs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">num</span></code> splits
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> stops splitting further in that branch.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">splitIte</span></code> disables case splitting on if-then-else expressions.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">splitMatch</span></code> disables case splitting on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code> expressions.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">splitImp</span></code> instructs <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a></code> to split on any hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22495" data-verso-hover="2558">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22518" data-verso-hover="2559">B</span></code> whose antecedent <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22495" data-verso-hover="2558">A</span></code> is <strong>propositional</strong>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-0" data-verso-hover="1">grind</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">linarith</span></code> disables the linear arithmetic solver for (ordered) modules and rings.</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Additional Examples</strong></p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="48">b</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="54">as</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="54">bs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="45">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">α</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="54">as</span><span class="inter-text"> </span><span class="unknown token" data-binding="">++</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="54">bs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">++</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="48">b</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___getLastD" title="Documentation for List.getLastD"><span class="const token" data-binding="const-List.getLastD" data-verso-hover="2560">getLastD</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="48">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="48">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-10083769093955757206-70-72-796"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-70" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10083769093955757206-70-72-796"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.467" data-verso-hover="46">α</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type u_1</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14" data-verso-hover="48">a</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.467" data-verso-hover="46">α</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.17" data-verso-hover="48">b</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.467" data-verso-hover="46">α</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="54">as</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="45">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.467" data-verso-hover="46">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.23" data-verso-hover="54">bs</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="45">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.467" data-verso-hover="46">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Type-Classes/Basic-Classes/#HAppend___mk" title="Documentation for HAppend.hAppend"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="2168">(</span></a><span class="var token" data-binding="var-_uniq.20" data-verso-hover="54">as</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAppend___mk" title="Documentation for HAppend.hAppend"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="2168">++</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="54">bs</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAppend___mk" title="Documentation for HAppend.hAppend"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="2168">++</span></a><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="108">[</span></a><span class="var token" data-binding="var-_uniq.17" data-verso-hover="48">b</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="108">]</span></a><a href="Type-Classes/Basic-Classes/#HAppend___mk" title="Documentation for HAppend.hAppend"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="2168">)</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___getLastD" title="Documentation for List.getLastD"><span class="const token" data-binding="const-List.getLastD" data-verso-hover="2560">getLastD</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="48">a</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="48">b</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-75-80-798"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-75" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-75-80-798"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-82">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1236" data-verso-hover="9">w</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Bitvectors/#BitVec___cons" title="Documentation for BitVec.cons"><span class="const token" data-binding="const-BitVec.cons" data-verso-hover="2562">BitVec.cons</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Bitvectors/#BitVec___msb" title="Documentation for BitVec.msb"><span class="const token" data-binding="const-BitVec.msb" data-verso-hover="2563">msb</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Bitvectors/#BitVec___setWidth" title="Documentation for BitVec.setWidth"><span class="const token" data-binding="const-BitVec.setWidth" data-verso-hover="2564">setWidth</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1236" data-verso-hover="9">w</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-14345590011054115318-153-155-799"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-153" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14345590011054115318-153-155-799"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1305" data-verso-hover="9">w</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">(</span></a><span class="var token" data-binding="var-_uniq.1305" data-verso-hover="9">w</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Bitvectors/#BitVec___cons" title="Documentation for BitVec.cons"><span class="const token" data-binding="const-BitVec.cons" data-verso-hover="2562">BitVec.cons</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Bitvectors/#BitVec___msb" title="Documentation for BitVec.msb"><span class="const token" data-binding="const-BitVec.msb" data-verso-hover="2563">msb</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Bitvectors/#BitVec___setWidth" title="Documentation for BitVec.setWidth"><span class="const token" data-binding="const-BitVec.setWidth" data-verso-hover="2564">BitVec.setWidth</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1305" data-verso-hover="9">w</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1284" data-verso-hover="2561">x</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-158-163-801"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-158" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-158-163-801"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-165">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2119" data-verso-hover="442">as</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="291">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2116" data-verso-hover="46">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2121" data-verso-hover="9">lo</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2123" data-verso-hover="9">hi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2121" data-verso-hover="9">lo</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2123" data-verso-hover="9">hi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2119" data-verso-hover="442">as</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size" title="Documentation for Array.size"><span class="const token" data-binding="const-Array.size" data-verso-hover="293">size</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Min___mk" title="Documentation for Min.min"><span class="const token" data-binding="const-Min.min" data-verso-hover="2565">min</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2121" data-verso-hover="9">lo</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2119" data-verso-hover="442">as</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size" title="Documentation for Array.size"><span class="const token" data-binding="const-Array.size" data-verso-hover="293">size</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-1990981949196740904-295-297-802"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-295" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1990981949196740904-295-297-802"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2231" data-verso-hover="46">α</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type u_1</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2119" data-verso-hover="442">as</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="291">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2231" data-verso-hover="46">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2121" data-verso-hover="9">lo</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2123" data-verso-hover="9">hi</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2121" data-verso-hover="9">lo</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2123" data-verso-hover="9">hi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2127" data-verso-hover="9">j</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2119" data-verso-hover="442">as</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size" title="Documentation for Array.size"><span class="const token" data-binding="const-Array.size" data-verso-hover="293">size</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Min___mk" title="Documentation for Min.min"><span class="const token" data-binding="const-Min.min" data-verso-hover="2565">min</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2121" data-verso-hover="9">lo</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">(</span></a><span class="var token" data-binding="var-_uniq.2119" data-verso-hover="442">as</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size" title="Documentation for Array.size"><span class="const token" data-binding="const-Array.size" data-verso-hover="293">size</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">-</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HSub___mk" title="Documentation for HSub.hSub"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="766">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="512">≤</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2125" data-verso-hover="9">i</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-300-305-804"><a href="Tactic-Proofs/Tactic-Reference/#grind" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.grind-300" data-verso-hover="1">grind</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-300-305-804"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              </section>
            <section>
              <h2 id="simp-tactics">
                13.5.12. Simplification<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=simp-tactics" title="Permalink">🔗</a></span></h2>
              <p>
                The simplifier is described in greater detail in <a href="The-Simplifier/#the-simplifier">its dedicated chapter</a>.</p>
              <div class="namedocs" id="simp">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simp" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="" data-verso-hover="38">simp</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code> tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code> simplifies the main goal target using lemmas tagged with the attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1988">simp</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hₙ</span><span class="unknown token" data-binding="">]</span></code> simplifies the main goal target using the lemmas tagged
with the attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1988">simp</span><span class="unknown token" data-binding="">]</span></code> and the given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hᵢ</span></code>'s, where the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hᵢ</span></code>'s are expressions.-</p>
                      </li>
                    <li>
                      <p>
                        If an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hᵢ</span></code> is a defined constant <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is unfolded. If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> has equational lemmas associated
with it (and is not a projection or a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">reducible</span></code> definition), these are used to rewrite with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></code> simplifies the main goal target using the lemmas tagged with the
attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1988">simp</span><span class="unknown token" data-binding="">]</span></code> and all hypotheses.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hₙ</span><span class="unknown token" data-binding="">]</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hₙ</span><span class="unknown token" data-binding="">]</span></code> but does not use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1988">simp</span><span class="unknown token" data-binding="">]</span></code> lemmas.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">simp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">id₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">idₙ</span><span class="unknown token" data-binding="">]</span></code> simplifies the main goal target using the lemmas tagged
with the attribute <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1" data-verso-hover="1988">simp</span><span class="unknown token" data-binding="">]</span></code>, but removes the ones named <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">idᵢ</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-5" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hₙ</span></code> simplifies the hypotheses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.192" data-verso-hover="2566">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.110" data-verso-hover="2567">T₁</span></code> ... <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.358" data-verso-hover="2568">hₙ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.275" data-verso-hover="2569">Tₙ</span></code>. If
the target or another hypothesis depends on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hᵢ</span></code>, a new simplified hypothesis
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hᵢ</span></code> is introduced, but the old one remains in the local context.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-5" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span></code> simplifies all the hypotheses and the target.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-9" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span></code> simplifies target and all (propositional) hypotheses using the
other hypotheses.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simp___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpAutoUnfold" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2570">simp!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAutoUnfold-0" data-verso-hover="2570">simp!</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">autoUnfold</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">true</span></code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpTrace" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2571">simp?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2571">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">if</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-13323152133442143402-59-61-805"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13323152133442143402-59-61-805"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="779">(</span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="const token" data-binding="const-ite" data-verso-hover="779">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="has-info information"><span class="hover-container"><span class="hover-info messages"><code class="verso-message information"><span class="text"></span><span class="text">Try this:</span><span class="text"></span><span class="text"></span><span class="text">
  </span><span class="text"></span><span class="text">[apply]</span><span class="text"> </span><span class="text"></span><span class="text">simp only [↓reduceIte, Nat.add_left_cancel_iff]</span><span class="text"></span></code></span></span><span class="tactic"><label for="tactic-state-7-64-69-807"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2571">simp?</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69-807"><span class="tactic-state">All goals completed! 🐙</span></span></span><span class="inter-text"> -- prints "Try this: simp only [ite_true]"
</span><span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticSimp?!_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp______" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2571">simp?!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2571">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">if</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-13323152133442143402-59-61-808"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13323152133442143402-59-61-808"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="779">(</span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="const token" data-binding="const-ite" data-verso-hover="779">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="has-info information"><span class="hover-container"><span class="hover-info messages"><code class="verso-message information"><span class="text"></span><span class="text">Try this:</span><span class="text"></span><span class="text"></span><span class="text">
  </span><span class="text"></span><span class="text">[apply]</span><span class="text"> </span><span class="text"></span><span class="text">simp only [↓reduceIte, Nat.add_left_cancel_iff]</span><span class="text"></span></code></span></span><span class="tactic"><label for="tactic-state-7-64-69-810"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2571">simp?</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69-810"><span class="tactic-state">All goals completed! 🐙</span></span></span><span class="inter-text"> -- prints "Try this: simp only [ite_true]"
</span><span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_arith">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpArith" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="872">simp_arith</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpArith-0" data-verso-hover="872">simp_arith</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_arith___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpArithBang" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2572">simp_arith!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpArithBang-0" data-verso-hover="2572">simp_arith!</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAutoUnfold-0" data-verso-hover="2570">simp!</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.dsimp" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="924">dsimp</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code> tactic is the definitional simplifier. It is similar to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code> but only
applies theorems that hold by reflexivity. Thus, the result is guaranteed to be
definitionally equal to the input.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.dsimpAutoUnfold" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2573">dsimp!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimpAutoUnfold-0" data-verso-hover="2573">dsimp!</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">autoUnfold</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">true</span></code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.dsimpTrace" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2571">dsimp?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2571">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">if</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-13323152133442143402-59-61-811"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13323152133442143402-59-61-811"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="779">(</span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="const token" data-binding="const-ite" data-verso-hover="779">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="has-info information"><span class="hover-container"><span class="hover-info messages"><code class="verso-message information"><span class="text"></span><span class="text">Try this:</span><span class="text"></span><span class="text"></span><span class="text">
  </span><span class="text"></span><span class="text">[apply]</span><span class="text"> </span><span class="text"></span><span class="text">simp only [↓reduceIte, Nat.add_left_cancel_iff]</span><span class="text"></span></code></span></span><span class="tactic"><label for="tactic-state-7-64-69-813"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2571">simp?</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69-813"><span class="tactic-state">All goals completed! 🐙</span></span></span><span class="inter-text"> -- prints "Try this: simp only [ite_true]"
</span><span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="dsimp______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticDsimp?!_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dsimp______" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2571">dsimp?!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2571">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">if</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-13323152133442143402-59-61-814"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13323152133442143402-59-61-814"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="779">(</span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="const token" data-binding="const-ite" data-verso-hover="779">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="has-info information"><span class="hover-container"><span class="hover-info messages"><code class="verso-message information"><span class="text"></span><span class="text">Try this:</span><span class="text"></span><span class="text"></span><span class="text">
  </span><span class="text"></span><span class="text">[apply]</span><span class="text"> </span><span class="text"></span><span class="text">simp only [↓reduceIte, Nat.add_left_cancel_iff]</span><span class="text"></span></code></span></span><span class="tactic"><label for="tactic-state-7-64-69-816"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2571">simp?</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69-816"><span class="tactic-state">All goals completed! 🐙</span></span></span><span class="inter-text"> -- prints "Try this: simp only [ite_true]"
</span><span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpAll" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="815">simp_all</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> is a stronger version of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-9" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span></code> where the hypotheses and target
are simplified multiple times until no simplification is applicable.
Only non-dependent propositional hypotheses are considered.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpAllAutoUnfold" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2574">simp_all!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllAutoUnfold-0" data-verso-hover="2574">simp_all!</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">autoUnfold</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">true</span></code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpAllTrace" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___-next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2571">simp_all?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2571">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">if</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-13323152133442143402-59-61-817"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13323152133442143402-59-61-817"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="779">(</span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="const token" data-binding="const-ite" data-verso-hover="779">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="has-info information"><span class="hover-container"><span class="hover-info messages"><code class="verso-message information"><span class="text"></span><span class="text">Try this:</span><span class="text"></span><span class="text"></span><span class="text">
  </span><span class="text"></span><span class="text">[apply]</span><span class="text"> </span><span class="text"></span><span class="text">simp only [↓reduceIte, Nat.add_left_cancel_iff]</span><span class="text"></span></code></span></span><span class="tactic"><label for="tactic-state-7-64-69-819"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2571">simp?</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69-819"><span class="tactic-state">All goals completed! 🐙</span></span></span><span class="inter-text"> -- prints "Try this: simp only [ite_true]"
</span><span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticSimp_all?!_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all______" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2571">simp_all?!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-0" data-verso-hover="2571">simp?</span></a></code> takes the same arguments as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>, but reports an equivalent call to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5">only</span></code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">if</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-21" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-13323152133442143402-59-61-820"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-59" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13323152133442143402-59-61-820"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="779">(</span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="const token" data-binding="const-ite" data-verso-hover="779">)</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
  </span><span class="has-info information"><span class="hover-container"><span class="hover-info messages"><code class="verso-message information"><span class="text"></span><span class="text">Try this:</span><span class="text"></span><span class="text"></span><span class="text">
  </span><span class="text"></span><span class="text">[apply]</span><span class="text"> </span><span class="text"></span><span class="text">simp only [↓reduceIte, Nat.add_left_cancel_iff]</span><span class="text"></span></code></span></span><span class="tactic"><label for="tactic-state-7-64-69-822"><a href="Tactic-Proofs/Tactic-Reference/#simp___-next" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpTrace-64" data-verso-hover="2571">simp?</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-64-69-822"><span class="tactic-state">All goals completed! 🐙</span></span></span><span class="inter-text"> -- prints "Try this: simp only [ite_true]"
</span><span class="unknown token" data-binding=""></span></code><p>
                    This command can also be used in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all_arith">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpAllArith" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2575">simp_all_arith</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllArith-0" data-verso-hover="2575">simp_all_arith</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-0" data-verso-hover="815">simp_all</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="simp_all_arith___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpAllArithBang" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2576">simp_all_arith!</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all_arith___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllArithBang-0" data-verso-hover="2576">simp_all_arith!</span></a></code> has been deprecated. It was a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_all___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAllAutoUnfold-0" data-verso-hover="2574">simp_all!</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">arith</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">decide</span></code>.
Note that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">decide</span></code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p>
                  </div>
                </div>
              <div class="namedocs" id="simpa">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.simpa" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1344">simpa</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-19">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simpa___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticSimpa!_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1344">simpa!</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-19">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simpa___-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticSimpa?_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa___-next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1344">simpa?</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-19">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simpa______">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticSimpa?!_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simpa______" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1344">simpa?!</span></a></pre><div class="text">
                  <p>
                    This is a "finishing" tactic modification of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>. It has two forms.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-19">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> will simplify the goal and the type of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rules</span></code>, then try to close the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Simplifying the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simpa" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-0" data-verso-hover="1344">simpa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">]</span></code> will simplify the goal and the type of a
hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> if present in the context, then try to close the goal using
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code> tactic.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="simp_wf">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=tacticSimp_wf" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#simp_wf" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2577">simp_wf</span></a></pre><div class="text">
                  <p>
                    Unfold definitions commonly used in well founded relation definitions.</p>
                  <p>
                    Since Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the
user, and this tactic should no longer be necessary. Calls to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_wf" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-tacticSimp_wf-0" data-verso-hover="2577">simp_wf</span></a></code> can be removed or replaced
by plain calls to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-rw">
                13.5.13. Rewriting<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-rw" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="rw">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rwSeq" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1285">rw</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1285">rw</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1713">rewrite</span></a></code>, but also tries to close the goal by "cheap" (reducible) <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code> afterwards.</p>
                  </div>
                </div>
              <div class="namedocs" id="rewrite">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rewriteSeq" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rewrite" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1713">rewrite</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewriteSeq-0" data-verso-hover="1713">rewrite</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">]</span></code> applies identity <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> as a rewrite rule to the target of the main goal.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is preceded by left arrow (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">←</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;-</span></code>), the rewrite is applied in the reverse direction.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is a defined constant, then the equational theorems associated with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> are used.
This provides a convenient way to unfold <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">rewrite</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">e₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">eₙ</span><span class="unknown token" data-binding="">]</span></code> applies the given rules sequentially.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewriteSeq-0" data-verso-hover="1713">rewrite</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-12" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">l</span></code> rewrites <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> at location(s) <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">l</span></code> is either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">*</span></code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⊢</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">|</span><span class="unknown token" data-binding="">-</span></code>
can also be used, to signify the target of the goal.</p>
                      </li>
                    </ul>
                  <p>
                    Using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1285">rw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">occs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">L</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">]</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.30122" data-verso-hover="1172">L</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="45">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code>, you can control which "occurrences" are rewritten.
(This option applies to each rule, so usually this will only be used with a single rule.)
Occurrences count from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="9">1</span></code>.
At each allowed occurrence, arguments of the rewrite rule <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> may be instantiated,
restricting which later rewrites can be found.
(Disallowed occurrences do not result in instantiation.)
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">occs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">neg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">L</span><span class="unknown token" data-binding="">)</span></code> allows skipping specified occurrences.</p>
                  </div>
                </div>
              <div class="namedocs" id="erw">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticErw___" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#erw" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2578">erw</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#erw" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticErw___-0" data-verso-hover="2578">erw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">]</span></code> is a shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1285">rw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">transparency</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.default</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">rules</span><span class="unknown token" data-binding="">]</span></code>.
This does rewriting up to unfolding of regular definitions (by comparison to regular <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1285">rw</span></a></code>
which only unfolds <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> definitions).</p>
                  </div>
                </div>
              <div class="namedocs" id="rwa">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticRwa__" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rwa" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2579">rwa</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rwa" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2579">rwa</span></a></code> is short-hand for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">rw</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">assumption</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___Rewrite___Config___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Meta.Rewrite.Config" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Meta.Rewrite.Config</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Meta.Rewrite.Config</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div></pre><div class="text">
                  <p>
                    Configures the behavior of the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rewrite" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1713">rewrite</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1285">rw</span></a></code> tactics.</p>
                  <h1>
                    Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___Config___mk" title="Documentation for Lean.Meta.Rewrite.Config.mk"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.mk" data-verso-hover="2580">Lean.Meta.Rewrite.Config.mk</span></a></pre><div class="docs"></div>
                    </section>
                  <h1>
                    Fields</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.transparency" data-verso-hover="2581">transparency</span> : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all" title="Documentation for Lean.Meta.TransparencyMode"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2582">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        The transparency mode to use for unfolding</p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.offsetCnstrs" data-verso-hover="2583">offsetCnstrs</span> : <a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="189">Bool</span></a></pre><div class="docs">
                      <p>
                        Whether to support offset constraints such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=?=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code></p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.occs" data-verso-hover="2584">occs</span> : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all" title="Documentation for Lean.Meta.Occurrences"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2585">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        Which occurrences to rewrite</p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Meta.Rewrite.Config.newGoals" data-verso-hover="2586">newGoals</span> : <a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Rewrite___NewGoals" title="Documentation for Lean.Meta.Rewrite.NewGoals"><span class="const token" data-binding="const-Lean.Meta.Rewrite.NewGoals" data-verso-hover="2587">Lean.Meta.Rewrite.NewGoals</span></a></pre><div class="docs">
                      <p>
                        How to convert the resulting metavariables into  new goals</p>
                      </div>
                    </section>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___Occurrences___all">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Meta.Occurrences" title="Permalink">🔗</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Meta.Occurrences</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Meta.Occurrences</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div></pre><div class="text">
                  <p>
                    Configuration for which occurrences that match an expression should be rewritten.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">all</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all" title="Documentation for Lean.Meta.Occurrences"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2585">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        All occurrences should be rewritten.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31140" data-verso-hover="1172">idxs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="45">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all" title="Documentation for Lean.Meta.Occurrences"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2585">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        A list of indices for which occurrences should be rewritten.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">neg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31141" data-verso-hover="1172">idxs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="45">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___Occurrences___all" title="Documentation for Lean.Meta.Occurrences"><span class="const token" data-binding="const-Lean.Meta.Occurrences" data-verso-hover="2585">Lean.Meta.Occurrences</span></a></pre><div class="docs">
                      <p>
                        A list of indices for which occurrences should not be rewritten.</p>
                      </div>
                    </div>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___TransparencyMode___all">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Meta.TransparencyMode" title="Permalink">🔗</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Meta.TransparencyMode</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Meta.TransparencyMode</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div></pre><div class="text">
                  <p>
                    Which constants should be unfolded?</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">all</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all" title="Documentation for Lean.Meta.TransparencyMode"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2582">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds all constants, even those tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">default</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all" title="Documentation for Lean.Meta.TransparencyMode"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2582">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds all constants except those tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">irreducible</span><span class="unknown token" data-binding="">]</span></code>.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">reducible</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all" title="Documentation for Lean.Meta.TransparencyMode"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2582">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds only constants tagged with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> attribute.</p>
                      </div>
                    </div>
                  <div class="constructor">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">instances</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#Lean___Meta___TransparencyMode___all" title="Documentation for Lean.Meta.TransparencyMode"><span class="const token" data-binding="const-Lean.Meta.TransparencyMode" data-verso-hover="2582">Lean.Meta.TransparencyMode</span></a></pre><div class="docs">
                      <p>
                        Unfolds reducible constants and constants tagged with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><a href="Type-Classes/Instance-Declarations/#Lean___Parser___Attr___instance" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.instance-2">instance</span></a><span class="unknown token" data-binding="">]</span></code> attribute.</p>
                      </div>
                    </div>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Meta___Rewrite___NewGoals">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Meta.Rewrite.NewGoals" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Meta.Rewrite.NewGoals</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Meta.Rewrite.NewGoals</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="52">Type</span></div></pre><div class="text">
                  <p>
                    Controls which new mvars are turned in to goals by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code> tactic.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">nonDependentFirst</span></code>  mvars that don't depend on other goals appear first in the goal list.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">nonDependentOnly</span></code> only mvars that don't depend on other goals are added to goal list.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">all</span></code> all unassigned mvars are added to the goal list.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="unfold">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.unfold" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#unfold" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="920">unfold</span></a></pre><div class="text">
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#unfold" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-0" data-verso-hover="920">unfold</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">id</span></code> unfolds all occurrences of definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-id" data-verso-hover="336">id</span></code> in the target.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">unfold</span><span class="inter-text"> </span><span class="unknown token" data-binding="">id1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">id2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">unfold</span><span class="inter-text"> </span><span class="unknown token" data-binding="">id1</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">unfold</span><span class="inter-text"> </span><span class="unknown token" data-binding="">id2</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#unfold" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-0" data-verso-hover="920">unfold</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">id</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-10" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> unfolds at the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    Definitions can be either global or local definitions.</p>
                  <p>
                    For non-recursive global definitions, this tactic is identical to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#delta" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2588">delta</span></a></code>.
For recursive global definitions, it uses the "unfolding lemma" <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-id.eq_def" data-verso-hover="2589">id.eq_def</span></code>,
which is generated for each recursive definition, to unfold according to the recursive definition given by the user.
Only one level of unfolding is performed, in contrast to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">id</span><span class="unknown token" data-binding="">]</span></code>, which unfolds definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-id" data-verso-hover="336">id</span></code> recursively.</p>
                  <p>
                    Implemented by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Tactic.evalUnfold" data-verso-hover="2590">Lean.Elab.Tactic.evalUnfold</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="replace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.replace" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#replace" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2591">replace</span></a></pre><div class="text">
                  <p>
                    Acts like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>, but removes a hypothesis with the same name as
this one if possible. For example, if the state is:</p>
                  <pre>f : α → β
h : α
⊢ goal
</pre><p>
                    Then after <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#replace" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.replace-0" data-verso-hover="2591">replace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> the state will be:</p>
                  <pre>f : α → β
h : β
⊢ goal
</pre><p>
                    whereas <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> would result in:</p>
                  <pre>f : α → β
h† : α
h : β
⊢ goal
</pre><p>
                    This can be used to simulate the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.specialize-0">specialize</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">apply</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">at</span></code> tactics of Coq.</p>
                  </div>
                </div>
              <div class="namedocs" id="delta">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.delta" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#delta" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2588">delta</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">delta</span><span class="inter-text"> </span><span class="unknown token" data-binding="">id1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">id2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span></code> delta-expands the definitions <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">id1</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">id2</span></code>, ....
This is a low-level tactic, it will expose how recursive definitions have been
compiled by Lean.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-inductive">
                13.5.14. Inductive Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-inductive" title="Permalink">🔗</a></span></h2>
              <section>
                <h3 id="tactic-ref-inductive-intro">
                  13.5.14.1. Introduction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-inductive-intro" title="Permalink">🔗</a></span></h3>
                <div class="namedocs" id="constructor">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.constructor" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#constructor" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2592">constructor</span></a></pre><div class="text">
                    <p>
                      If the main goal's target type is an inductive type, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#constructor" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.constructor-0" data-verso-hover="2592">constructor</span></a></code> solves it with
the first matching constructor, or else fails.</p>
                    </div>
                  </div>
                <div class="namedocs" id="injection">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.injection" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#injection" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2593">injection</span></a></pre><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2593">injection</span></a></code> tactic is based on the fact that constructors of inductive data
types are injections.
That means that if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32428" data-verso-hover="72">c</span></code> is a constructor of an inductive datatype, and if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t₁</span><span class="unknown token" data-binding="">)</span></code>
and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t₂</span><span class="unknown token" data-binding="">)</span></code> are two terms that are equal then  <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32593" data-verso-hover="1978">t₁</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32747" data-verso-hover="2035">t₂</span></code> are equal too.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">q</span></code> is a proof of a statement of conclusion <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32593" data-verso-hover="2594">t₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32747" data-verso-hover="2594">t₂</span></code>, then injection applies
injectivity to derive the equality of all arguments of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32593" data-verso-hover="2594">t₁</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32747" data-verso-hover="2594">t₂</span></code> placed in
the same positions. For example, from <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.32930" data-verso-hover="2595">a</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.33112" data-verso-hover="2596">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.32428" data-verso-hover="2595">c</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.33295" data-verso-hover="2596">d</span><span class="unknown token" data-binding="">)</span></code> we derive <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32930" data-verso-hover="2597">a</span><span class="unknown token" data-binding="">=</span><span class="var token" data-binding="var-_uniq.32428" data-verso-hover="2597">c</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.33112" data-verso-hover="2598">b</span><span class="unknown token" data-binding="">=</span><span class="var token" data-binding="var-_uniq.33295" data-verso-hover="2598">d</span></code>.
To use this tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32593" data-verso-hover="2594">t₁</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32747" data-verso-hover="2594">t₂</span></code> should be constructor applications of the same constructor.
Given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.33484" data-verso-hover="2599">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32930" data-verso-hover="2597">a</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.33112" data-verso-hover="2598">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32428" data-verso-hover="2597">c</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.33295" data-verso-hover="2598">d</span></code>, the tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.injection-0" data-verso-hover="2593">injection</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> adds two new hypothesis with types
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32930" data-verso-hover="2600">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32428" data-verso-hover="2600">c</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.33112" data-verso-hover="2601">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33295" data-verso-hover="2601">d</span></code> to the main goal.
The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.injection-0" data-verso-hover="2593">injection</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span></code> uses the names <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h₁</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h₂</span></code> to name the new hypotheses.</p>
                    </div>
                  </div>
                <div class="namedocs" id="injections">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.injections" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#injections" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2602">injections</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injections" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.injections-0" data-verso-hover="2602">injections</span></a></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2593">injection</span></a></code> to all hypotheses recursively
(since <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#injection" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2593">injection</span></a></code> can produce new hypotheses). Useful for destructing nested
constructor equalities like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34596" data-verso-hover="2603">a</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.34667" data-verso-hover="2603">b</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.34738" data-verso-hover="2604">c</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34810" data-verso-hover="2603">d</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.34885" data-verso-hover="2603">e</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.34960" data-verso-hover="2604">f</span><span class="unknown token" data-binding="">)</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="left">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.left" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#left" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2605">left</span></a></pre><div class="text">
                    <p>
                      Applies the first constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7470099516948367559-28-30-823"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-28" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7470099516948367559-28-30-823"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="514">∨</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-5556380497930058863-33-37-825"><a href="Tactic-Proofs/Tactic-Reference/#left" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.left-33" data-verso-hover="2605">left</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5556380497930058863-33-37-825"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-826" checked="checked"><span for="--verso-unique-826" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"></span></span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-40-47-827"><a href="Tactic-Proofs/Tactic-Reference/#trivial" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-40" data-verso-hover="395">trivial</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-40-47-827"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </div>
                <div class="namedocs" id="right">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.right" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#right" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2606">right</span></a></pre><div class="text">
                    <p>
                      Applies the second constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2439">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-1829239870474072007-42-44-828"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-42" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1829239870474072007-42-44-828"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2439">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="514">∨</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-5097355461737644669-47-52-830"><a href="Tactic-Proofs/Tactic-Reference/#right" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.right-47" data-verso-hover="2606">right</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5097355461737644669-47-52-830"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-831" checked="checked"><span for="--verso-unique-831" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="338">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="26">Prop</span><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2439">h</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="338">q</span><span class="inter-text"></span></span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-55-62-832"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-55" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2439">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-55-62-832"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </div>
                </section>
              <section>
                <h3 id="tactic-ref-inductive-elim">
                  13.5.14.2. Elimination<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-inductive-elim" title="Permalink">🔗</a></span></h3>
                <p>
                  Elimination tactics use <a href="The-Type-System/Inductive-Types/#recursors">recursors</a> and the automatically-derived <a href="The-Type-System/Inductive-Types/#recursor-elaboration-helpers"><code>casesOn</code> helper</a> to implement induction and case splitting.
The <a class="technical-term" href="Tactic-Proofs/#--tech-term-subgoals">subgoals</a> that result from these tactics are determined by the types of the minor premises of the eliminators, and using different eliminators with the <code class="plain-keyword">using</code> option results in different subgoals.</p>
                <details class="example"><summary class="description">Choosing Eliminators</summary><div class="example-content">
                    <p>
                    <p>
                      When attempting to prove that <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35898" data-verso-hover="2607">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35846" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="2607">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35898" data-verso-hover="2607">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35898" data-verso-hover="2607">i</span></code>, after introducing the hypotheses the tactic <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-10845342479113535755-5226-5237-833"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-5226" data-verso-hover="869">induction</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35987" data-verso-hover="2607">i</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10845342479113535755-5226-5237-833"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-834" checked="checked"><span for="--verso-unique-834" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.35984" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36005" data-verso-hover="2608">isLt✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35984" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟨</span></a><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">,</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36005" data-verso-hover="2608">isLt✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟩</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟨</span></a><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">,</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36005" data-verso-hover="2608">isLt✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟩</span></a></span></span></span></span></span></span></code> results in:</p>
                    <div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-835" checked="checked"><span for="--verso-unique-835" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.35984" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36005" data-verso-hover="2608">isLt✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35984" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟨</span></a><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">,</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36005" data-verso-hover="2608">isLt✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟩</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟨</span></a><span class="var token" data-binding="var-_uniq.36004" data-verso-hover="9">val✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">,</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36005" data-verso-hover="2608">isLt✝</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="608">⟩</span></a></span></span></span></span></div>
                      </div>
                    <p>
                      This is because <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a></code> is a <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Structures">structure</a> with a single non-recursive constructor.
Its recursor has a single minor premise for this constructor:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Fin.rec" data-verso-hover="2609">Fin.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2610">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="59">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="2611">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="2612">isLt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2610">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-Fin.mk" data-verso-hover="608">⟨</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">val</span><span class="unknown token" data-binding="const-Fin.mk" data-verso-hover="608">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="2612">isLt</span><span class="unknown token" data-binding="const-Fin.mk" data-verso-hover="608">⟩</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1004">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="2610">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1004">t</span></code><p>
                    <p>
                      Using the tactic <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-17451011565651025735-5877-5908-836"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-5877" data-verso-hover="869">induction</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36166" data-verso-hover="2607">i</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5889">using</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___induction" title="Documentation for Fin.induction"><span class="const token" data-binding="const-Fin.induction" data-verso-hover="2613">Fin.induction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17451011565651025735-5877-5908-836"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-837" checked="checked"><span for="--verso-unique-837" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36163" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-838"><span for="--verso-unique-838" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36163" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36163" data-verso-hover="9">n</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36188" data-verso-hover="2614">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc" title="Documentation for Fin.castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2615">castSucc</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc" title="Documentation for Fin.castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2615">castSucc</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ" title="Documentation for Fin.succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2616">succ</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ" title="Documentation for Fin.succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2616">succ</span></a></span></span></span></span></span></span></code> instead results in:</p>
                    <div class="hl lean tactic-view">
                      <div class="tactic-state">
                        <span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-839" checked="checked"><span for="--verso-unique-839" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36163" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-840" checked="checked"><span for="--verso-unique-840" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36163" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36163" data-verso-hover="9">n</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36188" data-verso-hover="2614">a✝</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc" title="Documentation for Fin.castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2615">castSucc</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc" title="Documentation for Fin.castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2615">castSucc</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ" title="Documentation for Fin.succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2616">succ</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36187" data-verso-hover="1004">i✝</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ" title="Documentation for Fin.succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2616">succ</span></a></span></span></span></span></div>
                      </div>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___induction" title="Documentation for Fin.induction"><span class="const token" data-binding="const-Fin.induction" data-verso-hover="2613">Fin.induction</span></a></code> is an alternative eliminator that implements induction on the underlying <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___induction" title="Documentation for Fin.induction"><span class="const token" data-binding="const-Fin.induction" data-verso-hover="2613">Fin.induction</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="2617">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="302">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="59">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.81" data-verso-hover="2618">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="2617">motive</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="2607">0</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="2619">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.84" data-verso-hover="1004">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="2617">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84" data-verso-hover="1004">i</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___castSucc" title="Documentation for Fin.castSucc"><span class="const token" data-binding="const-Fin.castSucc" data-verso-hover="2615">castSucc</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="2617">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84" data-verso-hover="1004">i</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___succ" title="Documentation for Fin.succ"><span class="const token" data-binding="const-Fin.succ" data-verso-hover="2616">succ</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.144" data-verso-hover="2607">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="609">Fin</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="2617">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.144" data-verso-hover="2607">i</span></code></div>
                  </details><p>
                  <span id="--tech-term-Custom-eliminators" class="def-technical-term">Custom eliminators</span> can be registered using the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2620">induction_eliminator</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2621">cases_eliminator</span></code> attributes.
The eliminator is registered for its explicit targets (i.e. those that are explicit, rather than implicit, parameters to the eliminator function) and will be applied when <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="869">induction</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></code> is used on targets of those types.
When present, custom eliminators take precedence over recursors.
Setting <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Options/#tactic___customEliminators" title="Documentation for option tactic.customEliminators"><span class="option token" data-binding="option-tactic.customEliminators" data-verso-hover="2622">tactic.customEliminators</span></a></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="42">false</span></a></code> disables the use of custom eliminators.</p>
                <div class="namedocs" id="attr-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">attribute</span><span class="title">Custom Eliminators</span><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2620">induction_eliminator</span></code> attribute registers an eliminator for use by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="869">induction</span></a></code> tactic.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">induction_eliminator</span><span class="from-nonterminal" data-kind="null"></span></pre><p>
                      The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="2620">induction_eliminator</span></code> attribute registers an eliminator for use by the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></code> tactic.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___simple-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="keyword">cases_eliminator</span><span class="from-nonterminal" data-kind="null"></span></pre></div>
                  </div>
                <div class="namedocs" id="cases">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.cases" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></pre><div class="text">
                    <p>
                      Assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> is a variable in the local context with an inductive type,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code> splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></code> detects unreachable cases and closes them automatically.</p>
                    <p>
                      For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.38586" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code> and a goal with a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code> produces one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></code>,
and one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code>.
Here the name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is chosen automatically and is not accessible.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">with</span></code> to provide the variables names for each constructor.</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is an expression instead of a variable, generalizes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> in the goal,
and then cases on the resulting variable.</p>
                        </li>
                      <li>
                        <p>
                          Given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.39034" data-verso-hover="54">as</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="45">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39011" data-verso-hover="2623">α</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">as</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">as'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₂</span></code>,
uses tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac₁</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">nil</span></code> case, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac₂</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">cons</span></code> case,
and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">as'</span></code> are used as names for the new variables introduced.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-0" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is a variable or an expression,
performs cases on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> as above, but also adds a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span></code> to each hypothesis,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">...</span></code> is the constructor instance for that particular case.</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="rcases">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rcases" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2473">rcases</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> is a tactic that will perform <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></code> recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.39833" data-verso-hover="2624">h1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39781" data-verso-hover="338">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39794" data-verso-hover="338">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39807" data-verso-hover="338">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39820" data-verso-hover="338">d</span></code> or
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∃</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">trans_rel</span><span class="inter-text"> </span><span class="unknown token" data-binding="">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span></code>. Usual usage might be <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h1</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">ha</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hb</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hc</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hd</span></code> or
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h2</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">z</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hxz</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hzy</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">⟩</span></code> for these examples.</p>
                    <p>
                      Each element of an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> pattern is matched against a particular local hypothesis (most of which
are generated during the execution of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> and represent individual elements destructured from
the input expression). An <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> pattern has the following grammar:</p>
                    <ul>
                      <li>
                        <p>
                          A name like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>, which names the active hypothesis as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>.</p>
                        </li>
                      <li>
                        <p>
                          A blank <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code>, which does nothing (letting the automatic naming system used by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></code> name the
hypothesis).</p>
                        </li>
                      <li>
                        <p>
                          A hyphen <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">-</span></code>, which clears the active hypothesis and any dependents.</p>
                        </li>
                      <li>
                        <p>
                          The keyword <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, which expects the hypothesis to be <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40082" data-verso-hover="2489">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40012" data-verso-hover="2625">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40046" data-verso-hover="2625">b</span></code>, and calls <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#subst" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2453">subst</span></a></code> on the
hypothesis (which has the effect of replacing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40046" data-verso-hover="2625">b</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40012" data-verso-hover="2625">a</span></code> everywhere or vice versa).</p>
                        </li>
                      <li>
                        <p>
                          A type ascription <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40174" data-verso-hover="2626">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40128" data-verso-hover="2627">ty</span></code>, which sets the type of the hypothesis to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40128" data-verso-hover="2627">ty</span></code> and then matches it
against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40174" data-verso-hover="2626">p</span></code>. (Of course, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40128" data-verso-hover="2627">ty</span></code> must unify with the actual type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40082" data-verso-hover="2489">h</span></code> for this to work.)</p>
                        </li>
                      <li>
                        <p>
                          A tuple pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">p1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p3</span><span class="unknown token" data-binding="">⟩</span></code>, which matches a constructor with many arguments, or a series
of nested conjunctions or existentials. For example if the active hypothesis is <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40012" data-verso-hover="338">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40046" data-verso-hover="338">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40232" data-verso-hover="338">c</span></code>,
then the conjunction will be destructured, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">p1</span></code> will be matched against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40012" data-verso-hover="338">a</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">p2</span></code> against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40046" data-verso-hover="338">b</span></code>
and so on.</p>
                        </li>
                      <li>
                        <p>
                          A <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@</span></code> before a tuple pattern as in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@</span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">p1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p3</span><span class="unknown token" data-binding="">⟩</span></code> will bind all arguments in the constructor,
while leaving the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@</span></code> off will only use the patterns on the explicit arguments.</p>
                        </li>
                      <li>
                        <p>
                          An alternation pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">p1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p3</span></code>, which matches an inductive type with multiple constructors,
or a nested disjunction like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40012" data-verso-hover="338">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40046" data-verso-hover="338">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40232" data-verso-hover="338">c</span></code>.</p>
                        </li>
                      </ul>
                    <p>
                      A pattern like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">d</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">⟩</span></code> will do a split over the inductive datatype,
naming the first three parameters of the first constructor as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">c</span></code> and the
first two of the second constructor <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">d</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">e</span></code>. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span></code> then these will cause more case splits as necessary.
If there are too many arguments, such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">⟩</span></code> for splitting on
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∃</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40436" data-verso-hover="2628">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∃</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40441" data-verso-hover="2629">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code>, then it will be treated as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">b</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">⟩</span></code>, splitting the last
parameter as necessary.</p>
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code> also has special support for quotient types: quotient induction into Prop works like
matching on the constructor <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">quot.mk</span></code>.</p>
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-13">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">PAT</span></code> will do the same as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-9">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">PAT</span></code> with the exception that an
assumption <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.40504" data-verso-hover="2630">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40492" data-verso-hover="799">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40497" data-verso-hover="799">PAT</span></code> will be added to the context.</p>
                    </div>
                  </div>
                <div class="namedocs" id="fun_cases">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.funCases" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#fun_cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2631">fun_cases</span></a></pre><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.fun_cases" data-verso-hover="2632">fun_cases</span></code> tactic is a convenience wrapper of the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></code> tactic when using a functional
cases principle.</p>
                    <p>
                      The tactic invocation</p>
                    <pre>fun_cases f x ... y ...`
</pre><p>
                      is equivalent to</p>
                    <pre>cases y, ... using f.fun_cases_unfolding x ...
</pre><p>
                      where the arguments of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> are used as arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.fun_cases_unfolding</span></code> or targets of the case
analysis, as appropriate.</p>
                    <p>
                      The form</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.fun_cases" data-verso-hover="2632">fun_cases</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41730" data-verso-hover="338">f</span></code><p>
                      (with no arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>) searches the goal for a unique eligible application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>, and uses
these arguments. An application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p>
                    <p>
                      The form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">case1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">case2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ih</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₂</span></code> works like with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="519">cases</span></a></code>.</p>
                    <p>
                      Under <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tactic.fun_induction.unfolding</span><span class="inter-text"> </span><span class="unknown token" data-binding="">true</span></code> (the default), <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#fun_induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1032">fun_induction</span></a></code> uses the
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.fun_cases_unfolding</span></code> theorem, which will try to automatically unfold the call to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> in
the goal. With <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tactic.fun_induction.unfolding</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false</span></code>, it uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.fun_cases</span></code> instead.</p>
                    </div>
                  </div>
                <div class="namedocs" id="induction">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.induction" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="869">induction</span></a></pre><div class="text">
                    <p>
                      Assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> is a variable in the local context with an inductive type,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="869">induction</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code> applies induction on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.</p>
                    <p>
                      For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.42230" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code> and a goal with a hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="869">induction</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code> produces one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></code>,
and one goal with hypotheses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ih₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="unknown token" data-binding="">)</span></code>.
Here the names <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.42571" data-verso-hover="1001">ih₁</span></code> are chosen automatically and are not accessible.
You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">with</span></code> to provide the variables names for each constructor.</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="869">induction</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is an expression instead of a variable,
generalizes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> in the goal, and then performs induction on the resulting variable.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="869">induction</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span></code> allows the user to specify the principle of induction that should be used.
Here <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">r</span></code> should be a term whose result type must be of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">C</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.43037" data-verso-hover="72">C</span></code> is a bound variable and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code> is a (possibly empty) sequence of bound variables</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="869">induction</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12">generalizing</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">zₙ</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.43142" data-verso-hover="2633">z₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.43246" data-verso-hover="2633">zₙ</span></code> are variables in the local context,
generalizes over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.43142" data-verso-hover="2633">z₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.43246" data-verso-hover="2633">zₙ</span></code> before applying the induction but then introduces them in each goal.
In other words, the net effect is that each inductive hypothesis is generalized.</p>
                        </li>
                      <li>
                        <p>
                          Given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.43351" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ih</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₂</span></code>
uses tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac₁</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">zero</span></code> case, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac₂</span></code> for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">succ</span></code> case.</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="fun_induction">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.funInduction" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#fun_induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1032">fun_induction</span></a></pre><div class="text">
                    <p>
                      The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#fun_induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1032">fun_induction</span></a></code> tactic is a convenience wrapper around the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="869">induction</span></a></code> tactic to use the the
functional induction principle.</p>
                    <p>
                      The tactic invocation</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">fun_induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xₙ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">yₘ</span></code><p>
                      where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is a function defined by non-mutual structural or well-founded recursion, is equivalent to</p>
                    <pre>induction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ
</pre><p>
                      where the arguments of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> are used as arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.induct_unfolding</span></code> or targets of the
induction, as appropriate.</p>
                    <p>
                      The form</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">fun_induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span></code><p>
                      (with no arguments to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>) searches the goal for a unique eligible application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code>, and uses
these arguments. An application of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p>
                    <p>
                      The forms <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#fun_induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.funInduction-0" data-verso-hover="1032">fun_induction</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20">generalizing</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">zₙ</span></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">fun_induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">case1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">case2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ih</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₂</span></code> work like with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-0" data-verso-hover="869">induction</span></a><span class="unknown token" data-binding="">.</span></code></p>
                    <p>
                      Under <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tactic.fun_induction.unfolding</span><span class="inter-text"> </span><span class="unknown token" data-binding="">true</span></code> (the default), <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#fun_induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1032">fun_induction</span></a></code> uses the
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.induct_unfolding</span></code> induction principle, which will try to automatically unfold the call to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> in
the goal. With <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tactic.fun_induction.unfolding</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false</span></code>, it uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f.induct</span></code> instead.</p>
                    </div>
                  </div>
                <div class="namedocs" id="nofun">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticNofun" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#nofun" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2634">nofun</span></a></pre><div class="text">
                    <p>
                      The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#nofun" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticNofun-0" data-verso-hover="2634">nofun</span></a></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nofun" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.nofun-6">nofun</span></a></code>: it introduces the assumptions, then performs an
empty pattern match, closing the goal if the introduced pattern is impossible.</p>
                    </div>
                  </div>
                <div class="namedocs" id="nomatch">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.«tacticNomatch_,,»" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#nomatch" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2635">nomatch</span></a></pre><div class="text">
                    <p>
                      The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#nomatch" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.«tacticNomatch_,,»-0" data-verso-hover="2635">nomatch</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> is shorthand for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___nomatch" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.nomatch-6" data-verso-hover="1709">nomatch</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code>.</p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-ref-search">
                13.5.15. Library Search<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-search" title="Permalink">🔗</a></span></h2>
              <p>
                The library search tactics are intended for interactive use.
When run, they search the Lean library for lemmas or rewrite rules that could be applicable in the current situation, and suggests a new tactic.
These tactics should not be left in a proof; rather, their suggestions should be incorporated.</p>
              <div class="namedocs" id="exact___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.exact?" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#exact___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2636">exact?</span></a></pre><div class="text">
                  <p>
                    Searches environment for definitions or theorems that can solve the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="914">exact</span></a></code>
with conditions resolved by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code>.</p>
                  <p>
                    The optional <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">using</span></code> clause provides identifiers in the local context that must be
used by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact?-0" data-verso-hover="2636">exact?</span></a></code> when closing the goal.  This is most useful if there are multiple
ways to resolve the goal, and one wants to guide which lemma is used.</p>
                  </div>
                </div>
              <div class="namedocs" id="apply___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.apply?" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#apply___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2637">apply?</span></a></pre><div class="text">
                  <p>
                    Searches environment for definitions or theorems that can refine the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code>
with conditions resolved when possible with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#solve_by_elim" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.solveByElim-0" data-verso-hover="2468">solve_by_elim</span></a></code>.</p>
                  <p>
                    The optional <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">using</span></code> clause provides identifiers in the local context that must be
used when closing the goal.</p>
                  </div>
                </div>
              <p>
              <p>
                In this proof state:</p>
              <div class="hl lean tactic-view">
                <div class="tactic-state">
                  <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.45346" data-verso-hover="9">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.45349" data-verso-hover="9">j</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.45352" data-verso-hover="9">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.45355" data-verso-hover="1209">h1</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.45346" data-verso-hover="9">i</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45349" data-verso-hover="9">j</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.45358" data-verso-hover="2405">h2</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.45349" data-verso-hover="9">j</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45352" data-verso-hover="9">k</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.45346" data-verso-hover="9">i</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45352" data-verso-hover="9">k</span></span></span></span></div>
                </div>
              <p>
                invoking <code class="hl lean inline" data-lean-context="examples"><span class="has-info information"><span class="hover-container"><span class="hover-info messages"><code class="verso-message information"><span class="text"></span><span class="text">Try this:</span><span class="text"></span><span class="text"></span><span class="text">
  </span><span class="text"></span><span class="text">[apply]</span><span class="text"> </span><span class="text"></span><span class="text">exact </span><span class="highlighted"><span class="unknown token" data-binding="">Nat.lt_trans</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45355" data-verso-hover="1209">h1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.45358" data-verso-hover="2405">h2</span></span><span class="text"></span></code></span></span><span class="tactic"><label for="tactic-state-7-8077-8083-842"><a href="Tactic-Proofs/Tactic-Reference/#apply___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply?-8077" data-verso-hover="2637">apply?</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-8077-8083-842"><span class="tactic-state">All goals completed! 🐙</span></span></span></code> suggests:</p>
              <pre class="hl lean lean-output information"><span class="verso-message"><span class="text">Try this:
  [apply] exact Nat.lt_trans h1 h2
</span></span></pre><div class="namedocs" id="rw___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rewrites?" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#rw___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2638">rw?</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2638">rw?</span></a></code> tries to find a lemma which can rewrite the goal.</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2638">rw?</span></a></code> should not be left in proofs; it is a search tool, like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply?-0" data-verso-hover="2637">apply?</span></a></code>.</p>
                  <p>
                    Suggestions are printed as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1285">rw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-0" data-verso-hover="1285">rw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">]</span></code>.</p>
                  <p>
                    You can use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2638">rw?</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">my_lemma</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">my_theorem</span><span class="unknown token" data-binding="">]</span></code> to prevent <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rewrites?-0" data-verso-hover="2638">rw?</span></a></code> using the named lemmas.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-cases">
                13.5.16. Case Analysis<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-cases" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="split">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.split" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#split" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="781">split</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="781">split</span></a></code> tactic is useful for breaking nested if-then-else and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code> expressions into separate cases.
For a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code> expression with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> cases, the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="781">split</span></a></code> tactic generates at most <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> subgoals.</p>
                  <p>
                    For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.47408" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code>, and a target <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="146">if</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.47408" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.47465" data-verso-hover="2103">Q</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.47514" data-verso-hover="2103">R</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="781">split</span></a></code> will generate
one goal with hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.47408" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.47465" data-verso-hover="2103">Q</span></code>, and a second goal with hypothesis
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.47408" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span></code> and target <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.47514" data-verso-hover="2103">R</span></code>.  Note that the introduced hypothesis is unnamed, and is commonly
renamed using the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#case" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2373">case</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1328">next</span></a></code> tactics.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="781">split</span></a></code> will split the goal (target).</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#split" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-0" data-verso-hover="781">split</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-6" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> will split the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="by_cases">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=«tacticBy_cases_:_»" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#by_cases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1563">by_cases</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span></code> splits the main goal into two cases, assuming <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.48060" data-verso-hover="1990">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48056" data-verso-hover="2639">p</span></code> in the first branch, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span></code> in the second branch.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-decision">
                13.5.17. Decision Procedures<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-decision" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="decide">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.decide" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="396">decide</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide" title="Documentation for Decidable.decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1993">decide</span></a></code> attempts to prove the main goal (with target type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.48277" data-verso-hover="72">p</span></code>) by synthesizing an instance of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48277" data-verso-hover="338">p</span></code>
and then reducing that instance to evaluate the truth value of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.48277" data-verso-hover="338">p</span></code>.
If it reduces to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable.isTrue"><span class="const token" data-binding="const-Decidable.isTrue" data-verso-hover="1808">isTrue</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48285" data-verso-hover="1978">h</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.48285" data-verso-hover="1978">h</span></code> is a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.48277" data-verso-hover="338">p</span></code> that closes the goal.</p>
                  <p>
                    The target is not allowed to contain local variables or metavariables.
If there are local variables, you can first try using the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#revert" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2435">revert</span></a></code> tactic with these local variables to move them into the target,
or you can use the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="keyword token" data-binding="kw-occ-null-0">revert</span></code> option, described below.</p>
                  <p>
                    Options:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="396">decide</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">revert</span></code> begins by reverting local variables that the target depends on,
after cleaning up the local context of irrelevant variables.
A variable is <em>relevant</em> if it appears in the target, if it appears in a relevant variable,
or if it is a proposition that refers to a relevant variable.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="396">decide</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">kernel</span></code> uses kernel for reduction instead of the elaborator.
It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,
and (2) it reduces the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a></code> instance only once instead of twice.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="396">decide</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">native</span></code> uses the native code compiler (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#eval</span></code>) to evaluate the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a></code> instance,
admitting the result via the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.ofReduceBool" data-verso-hover="1570">Lean.ofReduceBool</span></code> axiom.
This can be significantly more efficient than using reduction, but it is at the cost of increasing the size
of the trusted code base.
Namely, it depends on the correctness of the Lean compiler and all definitions with an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">implemented_by</span><span class="unknown token" data-binding="">]</span></code> attribute.
Like with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">kernel</span></code>, the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a></code> instance is evaluated only once.</p>
                      </li>
                    </ul>
                  <p>
                    Limitation: In the default mode or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">kernel</span></code> mode, since <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide" title="Documentation for Decidable.decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1993">decide</span></a></code> uses reduction to evaluate the term,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a></code> instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.
Reduction can also get stuck on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a></code> instances with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Eq.rec" data-verso-hover="579">Eq.rec</span></code> terms.
These can appear in instances defined using tactics (such as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rw" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1285">rw</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>).
To avoid this, create such instances using definitions such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-decidable_of_iff" data-verso-hover="2640">decidable_of_iff</span></code> instead.</p>
                  <p>
                    <strong>Examples</strong></p>
                  <p>
                    Proving inequalities:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-3607473444182389444-25-27-843"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-25" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3607473444182389444-25-27-843"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ne" data-verso-hover="653">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-28-34-845"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-28" data-verso-hover="396">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-28-34-845"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    Trying to prove a false proposition:</p>
                  <pre>example : 1 ≠ 1 := by decide
/-
tactic 'decide' proved that the proposition
  1 ≠ 1
is false
-/
</pre><p>
                    Trying to prove a proposition whose <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a></code> instance fails to reduce</p>
                  <pre>opaque unknownProp : Prop

open scoped Classical in
example : unknownProp := by decide
/-
tactic 'decide' failed for proposition
  unknownProp
since its 'Decidable' instance reduced to
  Classical.choice ⋯
rather than to the 'isTrue' constructor.
-/
</pre><p>
                    <strong>Properties and relations</strong></p>
                  <p>
                    For equality goals for types with decidable equality, usually <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code> can be used in place of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide" title="Documentation for Decidable.decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1993">decide</span></a></code>.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-6362818113747663240-23-25-846"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-23" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6362818113747663240-23-25-846"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-26-32-848"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-26" data-verso-hover="396">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-26-32-848"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-33">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-6362818113747663240-56-58-849"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-56" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6362818113747663240-56-58-849"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-59-62-851"><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-59" data-verso-hover="18">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-59-62-851"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="native_decide">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.nativeDecide" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#native_decide" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1575">native_decide</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#native_decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.nativeDecide-0" data-verso-hover="1575">native_decide</span></a></code> is a synonym for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-0" data-verso-hover="396">decide</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">native</span></code>.
It will attempt to prove a goal of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.49332" data-verso-hover="72">p</span></code> by synthesizing an instance
of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="606">Decidable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.49332" data-verso-hover="338">p</span></code> and then evaluating it to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable.isTrue"><span class="const token" data-binding="const-Decidable.isTrue" data-verso-hover="1808">isTrue</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">..</span></code>. Unlike <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide" title="Documentation for Decidable.decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1993">decide</span></a></code>, this
uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#eval</span></code> to evaluate the decidability instance.</p>
                  <p>
                    This should be used with care because it adds the entire lean compiler to the trusted
part, and the axiom <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.ofReduceBool" data-verso-hover="1570">Lean.ofReduceBool</span></code> will show up in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#print</span><span class="inter-text"> </span><span class="unknown token" data-binding="">axioms</span></code> for theorems using
this method or anything that transitively depends on them. Nevertheless, because it is
compiled, this can be significantly more efficient than using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Decidable___decide" title="Documentation for Decidable.decide"><span class="const token" data-binding="const-Decidable.decide" data-verso-hover="1993">decide</span></a></code>, and for very
large computations this is one way to run external programs and trust the result.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___range" title="Documentation for List.range"><span class="const token" data-binding="const-List.range" data-verso-hover="249">List.range</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1000</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___length" title="Documentation for List.length"><span class="const token" data-binding="const-List.length" data-verso-hover="715">length</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1000</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7901813818786060160-45-47-852"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-45" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7901813818786060160-45-47-852"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___range" title="Documentation for List.range"><span class="const token" data-binding="const-List.range" data-verso-hover="249">List.range</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1000</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___length" title="Documentation for List.length"><span class="const token" data-binding="const-List.length" data-verso-hover="715">length</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1000</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-48-61-854"><a href="Tactic-Proofs/Tactic-Reference/#native_decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.nativeDecide-48" data-verso-hover="1575">native_decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-48-61-854"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="omega">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.omega" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#omega" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="522">omega</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#omega" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-0" data-verso-hover="522">omega</span></a></code> tactic, for resolving integer and natural linear arithmetic problems.</p>
                  <p>
                    It is not yet a full decision procedure (no "dark" or "grey" shadows),
but should be effective on many problems.</p>
                  <p>
                    We handle hypotheses of the form <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.49689" data-verso-hover="799">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.49699" data-verso-hover="799">y</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span></code> in <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a></code>
(and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.50812" data-verso-hover="2035">k</span></code> a literal), along with negations of these statements.</p>
                  <p>
                    We decompose the sides of the inequalities as linear combinations of atoms.</p>
                  <p>
                    If we encounter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">/</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">%</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span></code> for literal integers <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.52179" data-verso-hover="2597">k</span></code> we introduce new auxiliary variables
and the relevant inequalities.</p>
                  <p>
                    On the first pass, we do not perform case splits on natural subtraction.
If <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#omega" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-0" data-verso-hover="522">omega</span></a></code> fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.</p>
                  <p>
                    The options</p>
                  <pre>omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
</pre><p>
                    can be used to:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitDisjunctions</span></code>: split any disjunctions found in the context,
if the problem is not otherwise solvable.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitNatSub</span></code>: for each appearance of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53808" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="190">Int</span></a><span class="unknown token" data-binding="">)</span></code>, split on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53808" data-verso-hover="9">b</span></code> if necessary.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitNatAbs</span></code>: for each appearance of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Integers/#Int___natAbs" title="Documentation for Int.natAbs"><span class="const token" data-binding="const-Int.natAbs" data-verso-hover="2641">Int.natAbs</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span></code>, split on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span></code> if necessary.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">splitMinMax</span></code>: for each occurrence of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Min___mk" title="Documentation for Min.min"><span class="const token" data-binding="const-Min.min" data-verso-hover="2565">min</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53808" data-verso-hover="9">b</span></code>, split on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Min___mk" title="Documentation for Min.min"><span class="const token" data-binding="const-Min.min" data-verso-hover="2565">min</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53808" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Min___mk" title="Documentation for Min.min"><span class="const token" data-binding="const-Min.min" data-verso-hover="2565">min</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53719" data-verso-hover="9">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53808" data-verso-hover="9">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53808" data-verso-hover="9">b</span></code>
Currently, all of these are on by default.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="bv_omega">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticBv_omega" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_omega" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2642">bv_omega</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#bv_omega" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticBv_omega-0" data-verso-hover="2642">bv_omega</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#omega" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-0" data-verso-hover="522">omega</span></a></code> with an additional preprocessor that turns statements about <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a></code> into statements about <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></code>.
Currently the preprocessor is implemented as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#try" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTry_-0" data-verso-hover="2411">try</span></a><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-4" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-9">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">bitvec_to_nat</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-30" data-verso-hover="844">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span></code>.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">bitvec_to_nat</span></code> is a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-2" data-verso-hover="1988">simp</span><span class="unknown token" data-binding="">]</span></code> attribute that you can (cautiously) add to more theorems.</p>
                  </div>
                </div>
              <section>
                <h3 id="tactic-ref-sat">
                  13.5.17.1. SAT Solver Integration<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-sat" title="Permalink">🔗</a></span></h3>
                <div class="namedocs" id="bv_decide">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.bvDecideMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="117">bv_decide</span></a></pre><div class="text">
                    <p>
                      Close fixed-width <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="189">Bool</span></a></code> goals by obtaining a proof from an external SAT solver and
verifying it inside Lean. The solvable goals are currently limited to</p>
                    <ul>
                      <li>
                        <p>
                          the Lean equivalent of <a href="https://smt-lib.org/logics-all.shtml#QF_BV"><code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">QF_BV</span></code></a></p>
                        </li>
                      <li>
                        <p>
                          automatically splitting up <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">structure</span></code>s that contain information about <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="189">Bool</span></a></code></p>
                        </li>
                      </ul>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="2643">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="2643">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">64</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="2643">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&&&</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="2643">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="2643">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^^^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="2643">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="2643">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|||</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="2643">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4077703269690396730-68-70-855"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-68" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4077703269690396730-68-70-855"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.428" data-verso-hover="2643">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.429" data-verso-hover="2643">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">64</span><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAnd___mk" title="Documentation for HAnd.hAnd"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2644">(</span></a><span class="var token" data-binding="var-_uniq.428" data-verso-hover="2643">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAnd___mk" title="Documentation for HAnd.hAnd"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2644">&&&</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.429" data-verso-hover="2643">b</span><a href="Type-Classes/Basic-Classes/#HAnd___mk" title="Documentation for HAnd.hAnd"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2644">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HXor___mk" title="Documentation for HXor.hXor"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="121">(</span></a><span class="var token" data-binding="var-_uniq.428" data-verso-hover="2643">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HXor___mk" title="Documentation for HXor.hXor"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="121">^^^</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.429" data-verso-hover="2643">b</span><a href="Type-Classes/Basic-Classes/#HXor___mk" title="Documentation for HXor.hXor"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="121">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.428" data-verso-hover="2643">a</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HOr___mk" title="Documentation for HOr.hOr"><span class="const token" data-binding="const-HOr.hOr" data-verso-hover="2645">|||</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.429" data-verso-hover="2643">b</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-9161347230623986888-73-79-857"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-73" data-verso-hover="515">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9161347230623986888-73-79-857"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.136" data-verso-hover="2643">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">64</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.137" data-verso-hover="2643">b✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">64</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Type-Classes/Basic-Classes/#HAnd___mk" title="Documentation for HAnd.hAnd"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2644">(</span></a><span class="var token" data-binding="var-_uniq.136" data-verso-hover="2643">a✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAnd___mk" title="Documentation for HAnd.hAnd"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2644">&&&</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="2643">b✝</span><a href="Type-Classes/Basic-Classes/#HAnd___mk" title="Documentation for HAnd.hAnd"><span class="const token" data-binding="const-HAnd.hAnd" data-verso-hover="2644">)</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HXor___mk" title="Documentation for HXor.hXor"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="121">(</span></a><span class="var token" data-binding="var-_uniq.136" data-verso-hover="2643">a✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HXor___mk" title="Documentation for HXor.hXor"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="121">^^^</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="2643">b✝</span><a href="Type-Classes/Basic-Classes/#HXor___mk" title="Documentation for HXor.hXor"><span class="const token" data-binding="const-HXor.hXor" data-verso-hover="121">)</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.136" data-verso-hover="2643">a✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HOr___mk" title="Documentation for HOr.hOr"><span class="const token" data-binding="const-HOr.hOr" data-verso-hover="2645">|||</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="2643">b✝</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-7-82-91-859"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-82" data-verso-hover="117">bv_decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-82-91-859"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code> encounters an unknown definition it will be treated like an unconstrained <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a></code>
variable. Sometimes this enables solving goals despite not understanding the definition because
the precise properties of the definition do not matter in the specific proof.</p>
                    <p>
                      If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code> fails to close a goal it provides a counter-example, containing assignments for all
terms that were considered as variables.</p>
                    <p>
                      In order to avoid calling a SAT solver every time, the proof can be cached with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvTrace-0" data-verso-hover="2646">bv_decide?</span></code>.</p>
                    <p>
                      If solving your problem relies inherently on using associativity or commutativity, consider enabling
the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">bv.ac_nf</span></code> option.</p>
                    <p>
                      Note: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ofReduceBool</span></code> and thus trusts the correctness of the code generator.</p>
                    <p>
                      Note: include <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">import</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Std.Tactic.BVDecide</span></code></p>
                    </div>
                  </div>
                <div class="namedocs" id="bv_normalize">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.bvNormalizeMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_normalize" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2647">bv_normalize</span></a></pre><div class="text">
                    <p>
                      Run the normalization procedure of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code> only. Sometimes this is enough to solve basic
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Bitvectors/#BitVec___ofFin" title="Documentation for BitVec"><span class="const token" data-binding="const-BitVec" data-verso-hover="114">BitVec</span></a></code> goals already.</p>
                    <p>
                      Note: include <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">import</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Std.Tactic.BVDecide</span></code></p>
                    </div>
                  </div>
                <div class="namedocs" id="bv_check">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.bvCheck" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_check" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2648">bv_check</span></a></pre><div class="text">
                    <p>
                      This tactic works just like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code> but skips calling a SAT solver by using a proof that is
already stored on disk. It is called with the name of an LRAT file in the same directory as the
current Lean file:</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">bv_check</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2649">"proof.lrat"</span></code></div>
                  </div>
                <div class="namedocs" id="bv_decide___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.bvTraceMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#bv_decide___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2646">bv_decide?</span></a></pre><div class="text">
                    <p>
                      Suggest a proof script for a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.bvDecide-0" data-verso-hover="117">bv_decide</span></code> tactic call. Useful for caching LRAT proofs.</p>
                    <p>
                      Note: include <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">import</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Std.Tactic.BVDecide</span></code></p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-reducibility">
                13.5.18. Controlling Reduction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-reducibility" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="with_reducible-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.withReducible" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1261">with_reducible</span></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_reducible</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the reducible transparency setting.
In this setting only definitions tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> are unfolded.</p>
                  </div>
                </div>
              <div class="namedocs" id="with_reducible_and_instances-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.withReducibleAndInstances" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1527">with_reducible_and_instances</span></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_reducible_and_instances</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.instances</span></code> transparency setting.
In this setting only definitions tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> or type class instances are unfolded.</p>
                  </div>
                </div>
              <div class="namedocs" id="with_unfolding_all-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.withUnfoldingAll" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1528">with_unfolding_all</span></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_unfolding_all</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.all</span></code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-control">
                13.5.19. Control Flow<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-control" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="skip">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.skip" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#skip" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1162">skip</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#skip" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-0" data-verso-hover="1162">skip</span></a></code> does nothing.</p>
                  </div>
                </div>
              <div class="namedocs" id="guard_hyp">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.guardHyp" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2650">guard_hyp</span></a></pre><div class="text">
                  <p>
                    Tactic to check that a named hypothesis has a given type and/or value.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> checks the type up to reducible defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> checks the type up to default defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:ₛ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> checks the type up to syntactic equality,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:ₐ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> checks the type up to alpha equality.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span></code> checks value up to reducible defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span></code> checks value up to default defeq,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=ₛ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span></code> checks value up to syntactic equality,</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_hyp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardHyp-0" data-verso-hover="2650">guard_hyp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=ₐ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span></code> checks the value up to alpha equality.</p>
                      </li>
                    </ul>
                  <p>
                    The value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">v</span></code> is elaborated using the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> as the expected type.</p>
                  </div>
                </div>
              <div class="namedocs" id="guard_target">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.guardTarget" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#guard_target" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1152">guard_target</span></a></pre><div class="text">
                  <p>
                    Tactic to check that the target agrees with a given expression.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="1152">guard_target</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> checks that the target is defeq at reducible transparency to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="1152">guard_target</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> checks that the target is defeq at default transparency to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="1152">guard_target</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=ₛ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> checks that the target is syntactically equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_target" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-0" data-verso-hover="1152">guard_target</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=ₐ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> checks that the target is alpha-equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    The term <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> is elaborated with the type of the goal as the expected type, which is mostly
useful within <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.conv" data-verso-hover="2482">conv</span></code> mode.</p>
                  </div>
                </div>
              <div class="namedocs" id="guard_expr">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.guardExpr" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2651">guard_expr</span></a></pre><div class="text">
                  <p>
                    Tactic to check equality of two expressions.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2651">guard_expr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are defeq at reducible transparency.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2651">guard_expr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=~</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are defeq at default transparency.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2651">guard_expr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=ₛ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are syntactically equal.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#guard_expr" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardExpr-0" data-verso-hover="2651">guard_expr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=ₐ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e'</span></code> checks that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are alpha-equivalent.</p>
                      </li>
                    </ul>
                  <p>
                    Both <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">e'</span></code> are elaborated then have their metavariables instantiated before the equality
check. Their types are unified (using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">isDefEqGuarded</span></code>) before synthetic metavariables are
processed, which helps with default instance handling.</p>
                  </div>
                </div>
              <div class="namedocs" id="done">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.done" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#done" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1262">done</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#done" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-0" data-verso-hover="1262">done</span></a></code> succeeds iff there are no remaining goals.</p>
                  </div>
                </div>
              <div class="namedocs" id="sleep">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.sleep" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#sleep" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2652">sleep</span></a></pre><div class="text">
                  <p>
                    The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">sleep</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ms</span></code> sleeps for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ms</span></code> milliseconds and does nothing.
It is used for debugging purposes only.</p>
                  </div>
                </div>
              <div class="namedocs" id="stop">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticStop_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#stop" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2653">stop</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#stop" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2653">stop</span></a></code> is a helper tactic for "discarding" the rest of a proof:
it is defined as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#repeat" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRepeat_-0" data-verso-hover="2430">repeat</span></a><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-7" data-verso-hover="13">sorry</span></a></code>.
It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-term-helpers">
                13.5.20. Term Elaboration Backends<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-term-helpers" title="Permalink">🔗</a></span></h2>
              <p>
                These tactics are used during elaboration of terms to satisfy obligations that arise.</p>
              <div class="namedocs" id="decreasing_with">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=tacticDecreasing_with_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#decreasing_with" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2654">decreasing_with</span></a></pre><div class="text">
                  <p>
                    Constructs a proof of decreasing along a well founded relation, by simplifying, then applying
lexicographic order lemmas and finally using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ts</span></code> to solve the base case. If it fails,
it prints a message to help the user diagnose an ill-founded recursive definition.</p>
                  </div>
                </div>
              <div class="namedocs" id="get_elem_tactic">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=tacticGet_elem_tactic" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2096">get_elem_tactic</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic-0" data-verso-hover="2096">get_elem_tactic</span></a></code> is the tactic automatically called by the notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">arr</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">i</span><span class="unknown token" data-binding="">]</span></code>
to prove any side conditions that arise when constructing the term
(e.g. the index is in bounds of the array). It just delegates to
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic_extensible-0" data-verso-hover="2098">get_elem_tactic_extensible</span></code> and gives a diagnostic error message otherwise;
users are encouraged to extend <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic_extensible-0" data-verso-hover="2098">get_elem_tactic_extensible</span></code> instead of this tactic.</p>
                  </div>
                </div>
              <div class="namedocs" id="get_elem_tactic_trivial">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=tacticGet_elem_tactic_trivial" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2655">get_elem_tactic_trivial</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#get_elem_tactic_trivial" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic_trivial-0" data-verso-hover="2655">get_elem_tactic_trivial</span></a></code> has been deprecated in favour of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-tacticGet_elem_tactic_extensible-0" data-verso-hover="2098">get_elem_tactic_extensible</span></code>.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-debug">
                13.5.21. Debugging Utilities<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-debug" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="sorry">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticSorry" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="13">sorry</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="13">sorry</span></a></code> tactic is a temporary placeholder for an incomplete tactic proof,
closing the main goal using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-6" data-verso-hover="77">sorry</span></code>.</p>
                  <p>
                    This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.
Lean will give a warning whenever a proof uses <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="13">sorry</span></a></code>, so you aren't likely to miss it,
but you can double check if a theorem depends on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="13">sorry</span></a></code> by looking for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-sorryAx" data-verso-hover="1567">sorryAx</span></code> in the output
of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">#print</span><span class="inter-text"> </span><span class="unknown token" data-binding="">axioms</span><span class="inter-text"> </span><span class="unknown token" data-binding="">my_thm</span></code> command, the axiom used by the implementation of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="13">sorry</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="admit">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticAdmit" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#admit" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2656">admit</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#admit" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAdmit-0" data-verso-hover="2656">admit</span></a></code> is a synonym for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="13">sorry</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="dbg_trace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.dbgTrace" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#dbg_trace" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2657">dbg_trace</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dbg_trace" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dbgTrace-0" data-verso-hover="2657">dbg_trace</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2658">"foo"</span></code> prints <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> when elaborated.
Useful for debugging tactic control flow:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-1406496372790713778-28-30-860"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-28" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1406496372790713778-28-30-860"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="514">∨</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a></span></span></span></span></span><span class="inter-text">
  </span><a href="Tactic-Proofs/The-Tactic-Language/#first" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.first-33" data-verso-hover="2408">first</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4489682950533027124-43-55-862"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-43" data-verso-hover="841">apply</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl"><span class="const token" data-binding="const-Or.inl" data-verso-hover="574">Or.inl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4489682950533027124-43-55-862"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-863" checked="checked"><span for="--verso-unique-863" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="inter-text"></span></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4489682950533027124-57-64-864"><a href="Tactic-Proofs/Tactic-Reference/#trivial" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-57" data-verso-hover="395">trivial</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4489682950533027124-57-64-864"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-865" checked="checked"><span for="--verso-unique-865" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="11">False</span></a><span class="inter-text"></span></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#dbg_trace" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dbgTrace-66" data-verso-hover="2657">dbg_trace</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2659">"left"</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-5556380497930058863-87-99-866"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-87" data-verso-hover="841">apply</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr"><span class="const token" data-binding="const-Or.inr" data-verso-hover="576">Or.inr</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5556380497930058863-87-99-866"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-867" checked="checked"><span for="--verso-unique-867" class="goal-name">h</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="397">True</span></a><span class="inter-text"></span></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-101-108-868"><a href="Tactic-Proofs/Tactic-Reference/#trivial" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-101" data-verso-hover="395">trivial</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-101-108-868"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#dbg_trace" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dbgTrace-110" data-verso-hover="2657">dbg_trace</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2660">"right"</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="trace_state">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.traceState" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#trace_state" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2661">trace_state</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#trace_state" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.traceState-0" data-verso-hover="2661">trace_state</span></a></code> displays the current state in the info view.</p>
                  </div>
                </div>
              <div class="namedocs" id="trace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.traceMessage" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#trace" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="136">trace</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">trace</span><span class="inter-text"> </span><span class="unknown token" data-binding="">msg</span></code> displays <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">msg</span></code> in the info view.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-other">
                13.5.22. Other<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-other" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="trivial">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticTrivial" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#trivial" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="395">trivial</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-trivial" data-verso-hover="2464">trivial</span></code> tries different simple tactics (e.g., <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Propositional-Equality/#rfl-next" title="Documentation for rfl"><span class="const token" data-binding="const-rfl" data-verso-hover="288">rfl</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#contradiction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-0" data-verso-hover="1329">contradiction</span></a></code>, ...)
to close the current goal.
You can use the command <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">macro_rules</span></code> to extend the set of tactics used. Example:</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-0">macro_rules</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(tactic|</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#trivial" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticTrivial-24" data-verso-hover="395">trivial</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(tactic|</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-46" data-verso-hover="38">simp</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="solve">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.solveTactic" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#solve" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2662">solve</span></a></pre><div class="text">
                  <p>
                    Similar to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#first" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2408">first</span></a></code>, but succeeds only if one the given tactics solves the current goal.</p>
                  </div>
                </div>
              <div class="namedocs" id="and_intros">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticAnd_intros" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#and_intros" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2663">and_intros</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#and_intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticAnd_intros-0" data-verso-hover="2663">and_intros</span></a></code> applies <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro"><span class="const token" data-binding="const-And.intro" data-verso-hover="569">And.intro</span></a></code> until it does not make progress.</p>
                  </div>
                </div>
              <div class="namedocs" id="infer_instance">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticInfer_instance" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#infer_instance" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2664">infer_instance</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#infer_instance" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticInfer_instance-0" data-verso-hover="2664">infer_instance</span></a></code> is an abbreviation for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-0" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">inferInstance</span></code>.
It synthesizes a value of any target type by typeclass inference.</p>
                  </div>
                </div>
              <div class="namedocs" id="expose_names">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.exposeNames" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#expose_names" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2522">expose_names</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#expose_names" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exposeNames-0" data-verso-hover="2522">expose_names</span></a></code> renames all inaccessible variables with accessible names, making them available
for reference in generated tactics. However, this renaming introduces machine-generated names
that are not fully under user control. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#expose_names" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exposeNames-0" data-verso-hover="2522">expose_names</span></a></code> is primarily intended as a preamble for
auto-generated end-game tactic scripts. It is also useful as an alternative to
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tactic.hygienic</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false</span></code>. If explicit control over renaming is needed in the
middle of a tactic script, consider using structured tactic scripts with
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span><span class="inter-text"> </span><span class="unknown token" data-binding="">..</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">with</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">..</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">with</span></code>, or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a></code> with explicit user-defined names,
as well as tactics such as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1328">next</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#case" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2373">case</span></a></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#rename_i" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2391">rename_i</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="unhygienic">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticUnhygienic_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#unhygienic" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2665">unhygienic</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">unhygienic</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> with name hygiene disabled.
This means that tactics that would normally create inaccessible names will instead
make regular variables. <strong>Warning</strong>: Tactics may change their variable naming
strategies at any time, so code that depends on autogenerated names is brittle.
Users should try not to use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.67813" data-verso-hover="72">unhygienic</span></code> if possible.</p>
                  <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-620790695178620064-32-34-869"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-32" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-620790695178620064-32-34-869"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="9">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="9">x</span></span></span></span></span></span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#unhygienic" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticUnhygienic_-35" data-verso-hover="2665">unhygienic</span></a><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-13274805172297836312-48-53-871"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-48" data-verso-hover="811">intro</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13274805172297836312-48-53-871"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">x</span></span></span></span></span></span><span class="inter-text">            -- x would normally be intro'd as inaccessible
  </span><span class="tactic"><label for="tactic-state-7-114-129-873"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-114" data-verso-hover="914">exact</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq.refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="578">Eq.refl</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="9">x</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-114-129-873"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">  -- refer to x
</span><span class="unknown token" data-binding=""></span></code></div>
                </div>
              <div class="namedocs" id="run_tac">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.runTac" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#run_tac" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2666">run_tac</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#run_tac" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.runTac-0" data-verso-hover="2666">run_tac</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">doSeq</span></code> tactic executes code in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TacticM</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Unit</span></code>.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-ref-mvcgen">
                13.5.23. Verification Condition Generation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-mvcgen" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="mvcgen">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mvcgenMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mvcgen" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2667">mvcgen</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> will break down a Hoare triple proof goal like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">P</span><span class="unknown token" data-binding="">⦄</span><span class="inter-text"> </span><span class="unknown token" data-binding="">prog</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">Q</span><span class="unknown token" data-binding="">⦄</span></code> into verification conditions,
provided that all functions used in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">prog</span></code> have specifications registered with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.spec-2" data-verso-hover="2668">spec</span><span class="unknown token" data-binding="">]</span></code>.</p>
                  <p>
                    <strong>Verification Conditions and specifications</strong></p>
                  <p>
                    A verification condition is an entailment in the stateful logic of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code>
in which the original program <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.68323" data-verso-hover="72">prog</span></code> no longer occurs.
Verification conditions are introduced by the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> tactic; see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> tactic for what they
look like.
When there's no applicable <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> spec, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> will try and rewrite an application
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.68323" data-verso-hover="2010">prog</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">c</span></code> with the simp set registered via <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.spec-2" data-verso-hover="2668">spec</span><span class="unknown token" data-binding="">]</span></code>.</p>
                  <p>
                    <strong>Features</strong></p>
                  <p>
                    When used like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">noLetElim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">foo_spec</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">bar_def</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">instBEqFloat</span><span class="unknown token" data-binding="">]</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> will additionally</p>
                  <ul>
                    <li>
                      <p>
                        add a Hoare triple specification <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo_spec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">P</span><span class="unknown token" data-binding="">⦄</span><span class="inter-text"> </span><span class="unknown token" data-binding="">foo</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">Q</span><span class="unknown token" data-binding="">⦄</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.spec-0" data-verso-hover="2668">spec</span></code> set for a
function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> occurring in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">prog</span></code>,</p>
                      </li>
                    <li>
                      <p>
                        unfold a definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">def</span><span class="inter-text"> </span><span class="unknown token" data-binding="">bar_def</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span></code> in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">prog</span></code>,</p>
                      </li>
                    <li>
                      <p>
                        unfold any method of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-instBEqFloat" data-verso-hover="2671">instBEqFloat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#BEq___mk" title="Documentation for BEq"><span class="const token" data-binding="const-BEq" data-verso-hover="1502">BEq</span></a><span class="inter-text"> </span><a href="Basic-Types/Floating-Point-Numbers/#Float-next" title="Documentation for Float"><span class="const token" data-binding="const-Float" data-verso-hover="478">Float</span></a></code> instance in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">prog</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        it will no longer substitute away <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code>-expressions that occur at most once in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">P</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Q</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">prog</span></code>.</p>
                      </li>
                    </ul>
                  <p>
                    <strong>Config options</strong></p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">noLetElim</span></code> is just one config option of many. Check out <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Elab.Tactic.Do.VCGen.Config" data-verso-hover="2672">Lean.Elab.Tactic.Do.VCGen.Config</span></code> for all
options. Of particular note is <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.68539" data-verso-hover="2673">stepLimit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="49">some</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">42</span></code>, which is useful for bisecting bugs in
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> and tracing its execution.</p>
                  <p>
                    <strong>Extended syntax</strong></p>
                  <p>
                    Often, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> will be used like this:</p>
                  <pre>mvcgen [...]
case inv1 =&gt; by exact I1
case inv2 =&gt; by exact I2
all_goals (mleave; try grind)
</pre><p>
                    There is special syntax for this:</p>
                  <pre>mvcgen [...] invariants
· I1
· I2
with grind
</pre><p>
                    When <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">I1</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">I2</span></code> need to refer to inaccessibles (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> will introduce a lot of them for program
variables), you can use case label syntax:</p>
                  <pre>mvcgen [...] invariants
| inv1 _ acc _ =&gt; I1 acc
| _ =&gt; I2
with grind
</pre><p>
                    This is more convenient than the equivalent <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">rename_i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">acc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">I1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">acc</span></code>.</p>
                  <p>
                    <strong>Invariant suggestions</strong></p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> will suggest invariants for you if you use the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">invariants?</span></code> keyword.</p>
                  <pre>mvcgen [...] invariants?
</pre><p>
                    This is useful if you do not recall the exact syntax to construct invariants.
Furthermore, it will suggest a concrete invariant encoding "this holds at the start of the loop and
this must hold at the end of the loop" by looking at the corresponding VCs.
Although the suggested invariant is a good starting point, it is too strong and requires users to
interpolate it such that the inductive step can be proved. Example:</p>
                  <pre>def mySum (l : List Nat) : Nat := Id.run do
  let mut acc := 0
  for x in l do
    acc := acc + x
  return acc

/--
info: Try this:
  invariants
    · ⇓⟨xs, letMuts⟩ =&gt; ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝
-/
#guard_msgs (info) in
theorem mySum_suggest_invariant (l : List Nat) : mySum l = l.sum := by
  generalize h : mySum l = r
  apply Id.of_wp_run_eq h
  mvcgen invariants?
  all_goals admit
</pre></div>
                </div>
              <section>
                <h3 id="tactic-ref-spred">
                  13.5.23.1. Tactics for Stateful Goals in <code>Std.Do.SPred</code><span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-ref-spred" title="Permalink">🔗</a></span></h3>
                <section>
                  <h4 id="The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Starting-and-Stopping-the-Proof-Mode">
                    13.5.23.1.1. Starting and Stopping the Proof Mode</h4>
                  <div class="namedocs" id="mstart">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mstartMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mstart" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2674">mstart</span></a></pre><div class="text">
                      <p>
                        Start the stateful proof mode of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code>.
This will transform a stateful goal of the form <code>H ⊢ₛ T</code> into <code>⊢ₛ H → T</code>
upon which <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mintro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintroMacro-0" data-verso-hover="2675">mintro</span></a></code> can be used to re-introduce <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">H</span></code> and give it a name.
It is often more convenient to use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mintro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintroMacro-0" data-verso-hover="2675">mintro</span></a></code> directly, which will
try <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mstart-0" data-verso-hover="2674">mstart</span></code> automatically if necessary.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="mstop">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mstopMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mstop" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2676">mstop</span></a></pre><div class="text">
                      <p>
                        Stops the stateful proof mode of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code>.
This will simply forget all the names given to stateful hypotheses and pretty-print
a bit differently.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="mleave">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mleaveMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mleave" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2677">mleave</span></a></pre><div class="text">
                      <p>
                        Leaves the stateful proof mode of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code>, tries to eta-expand through all definitions
related to the logic of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> and gently simplifies the resulting pure Lean
proposition. This is often the right thing to do after <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mvcgen-0" data-verso-hover="2667">mvcgen</span></code> in order for automation to prove
the goal.</p>
                      </div>
                    </div>
                  </section>
                <section>
                  <h4 id="The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Proving-a-Stateful-Goal">
                    13.5.23.1.2. Proving a Stateful Goal</h4>
                  <div class="namedocs" id="mspec">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mspecMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mspec" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2670">mspec</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> is an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#apply" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="841">apply</span></a></code>-like tactic that applies a Hoare triple specification to the target of the
stateful goal.</p>
                      <p>
                        Given a stateful goal <code>H ⊢ₛ wp⟦prog⟧ Q'</code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">foo_spec</span></code> will instantiate
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo_spec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">P</span><span class="unknown token" data-binding="">⦄</span><span class="inter-text"> </span><span class="unknown token" data-binding="">foo</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">Q</span><span class="unknown token" data-binding="">⦄</span></code>, match <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">prog</span></code> and produce subgoals for
the verification conditions <code>?pre : H ⊢ₛ P</code> and <code>?post : Q ⊢ₚ Q'</code>.</p>
                      <ul>
                        <li>
                          <p>
                            If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">prog</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;&gt;=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Specs.bind</span></code> is tried first so that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> is matched against <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.70586" data-verso-hover="2678">x</span></code>
instead. Tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspecNoBind-0" data-verso-hover="2679">mspec_no_bind</span></code> does not attempt to do this decomposition.</p>
                          </li>
                        <li>
                          <p>
                            If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">pre</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">post</span></code> follow by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.</span><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-1" data-verso-hover="18">rfl</span></a></code>, then they are discharged automatically.</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">post</span></code> is automatically simplified into constituent <code>⊢ₛ</code> entailments on
success and failure continuations.</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">pre</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">post</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">*</span></code> goals introduce their stateful hypothesis under an inaccessible name.
You can give it a name with the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mrename_i" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mrenameIMacro-0" data-verso-hover="2680">mrename_i</span></a></code> tactic.</p>
                          </li>
                        <li>
                          <p>
                            Any uninstantiated MVar arising from instantiation of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo_spec</span></code> becomes a new subgoal.</p>
                          </li>
                        <li>
                          <p>
                            If the target of the stateful goal looks like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-0">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75605" data-verso-hover="2540">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code> then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> will first <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintro-0" data-verso-hover="2675">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">s</span></code>.</p>
                          </li>
                        <li>
                          <p>
                            If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">P</span></code> has schematic variables that can be instantiated by doing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintro-0" data-verso-hover="2675">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">s</span></code>, for example
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo_spec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="keyword token" data-binding="kw-occ-null-0">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⌜</span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s</span><span class="unknown token" data-binding="">⌝</span><span class="unknown token" data-binding="">⦄</span><span class="inter-text"> </span><span class="unknown token" data-binding="">foo</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">Q</span><span class="unknown token" data-binding="">⦄</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> will do <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintro-0" data-verso-hover="2675">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">s</span></code> first to
instantiate <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.71841" data-verso-hover="2681">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.72785" data-verso-hover="2681">s</span></code>.</p>
                          </li>
                        <li>
                          <p>
                            Right before applying the spec, the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mframe-0" data-verso-hover="2682">mframe</span></code> tactic is used, which has the following effect:
Any hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Hᵢ</span></code> in the goal <code>h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T</code> that is
pure (i.e., equivalent to some <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⌜</span><span class="unknown token" data-binding="">φᵢ</span><span class="unknown token" data-binding="">⌝</span></code>) will be moved into the pure context as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.74691" data-verso-hover="2683">hᵢ</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.73738" data-verso-hover="2684">φᵢ</span></code>.</p>
                          </li>
                        </ul>
                      <p>
                        Additionally, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> can be used without arguments or with a term argument:</p>
                      <ul>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> without argument will try and look up a spec for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> registered with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.spec-2" data-verso-hover="2668">spec</span><span class="unknown token" data-binding="">]</span></code>.</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">foo_spec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">blah</span><span class="inter-text"> </span><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">bleh</span><span class="unknown token" data-binding="">)</span></code> will elaborate its argument as a term with expected type
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">P</span><span class="unknown token" data-binding="">⦄</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⦃</span><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">Q</span><span class="unknown token" data-binding="">⦄</span></code> and introduce <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">bleh</span></code> as a subgoal.
This is useful to pass an invariant to e.g., <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Specs.forIn_list</span></code> and leave the inductive step
as a hole.</p>
                          </li>
                        </ul>
                      </div>
                    </div>
                  <div class="namedocs" id="mintro">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mintroMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mintro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2675">mintro</span></a></pre><div class="text">
                      <p>
                        Like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a></code>, but introducing stateful hypotheses into the stateful context of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code>
proof mode.
That is, given a stateful goal <code>(hᵢ : Hᵢ)* ⊢ₛ P → T</code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintro-0" data-verso-hover="2675">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> transforms
into <code>(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T</code>.</p>
                      <p>
                        Furthermore, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintro-0" data-verso-hover="2675">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">s</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-0" data-verso-hover="811">intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">s</span></code>, but preserves the stateful goal.
That is, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintro-0" data-verso-hover="2675">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">s</span></code> brings the topmost state variable <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.76681" data-verso-hover="2685">s</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.76677" data-verso-hover="2686">σ</span></code> in scope and transforms
<code>(hᵢ : Hᵢ)* ⊢ₛ T</code> (where the entailment is in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.76677" data-verso-hover="46">σ</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.76694" data-verso-hover="2687">σs</span><span class="unknown token" data-binding="">)</span></code>) into
<code>(hᵢ : Hᵢ s)* ⊢ₛ T s</code> (where the entailment is in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76694" data-verso-hover="2687">σs</span></code>).</p>
                      <p>
                        Beyond that, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mintro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mintroMacro-0" data-verso-hover="2675">mintro</span></a></code> supports the full syntax of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mcasesMacro-0" data-verso-hover="2688">mcases</span></a></code> patterns
(<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-null-0">mintro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">mcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span></code>), and can perform multiple
introductions in sequence.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="mexact">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mexactMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mexact" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2689">mexact</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mexact" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mexactMacro-0" data-verso-hover="2689">mexact</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exact" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="914">exact</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (Q : SPred σs) : Q ⊢ₛ Q := by
  mstart
  mintro HQ
  mexact HQ
</pre></div>
                    </div>
                  <div class="namedocs" id="massumption">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.massumptionMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#massumption" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2690">massumption</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.massumption-0" data-verso-hover="2690">massumption</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-0" data-verso-hover="1180">assumption</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (P Q : SPred σs) : Q ⊢ₛ P → Q := by
  mintro _ _
  massumption
</pre></div>
                    </div>
                  <div class="namedocs" id="mrefine">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mrefineMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mrefine" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2691">mrefine</span></a></pre><div class="text">
                      <p>
                        Like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2413">refine</span></a></code>, but operating on stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goals.</p>
                      <pre>example (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by
  mintro ⟨HP, HQ, HR⟩
  mrefine ⟨HP, HR⟩

example (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  mintro H
  mrefine ⟨⌜42⌝, H⟩
</pre></div>
                    </div>
                  <div class="namedocs" id="mconstructor">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mconstructorMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mconstructor" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2692">mconstructor</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mconstructor-0" data-verso-hover="2692">mconstructor</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#constructor" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.constructor-0" data-verso-hover="2592">constructor</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by
  mintro HQ
  mconstructor &lt;;&gt; mexact HQ
</pre></div>
                    </div>
                  <div class="namedocs" id="mleft">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mleftMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mleft" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2693">mleft</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mleft-0" data-verso-hover="2693">mleft</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#left" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.left-0" data-verso-hover="2605">left</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by
  mintro HP
  mleft
  mexact HP
</pre></div>
                    </div>
                  <div class="namedocs" id="mright">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mrightMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mright" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2694">mright</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mright-0" data-verso-hover="2694">mright</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#right" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.right-0" data-verso-hover="2606">right</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by
  mintro HP
  mright
  mexact HP
</pre></div>
                    </div>
                  <div class="namedocs" id="mexists">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mexistsMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mexists" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2695">mexists</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mexists" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mexistsMacro-0" data-verso-hover="2695">mexists</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exists" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2469">exists</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  mintro H
  mexists 42
</pre></div>
                    </div>
                  <div class="namedocs" id="mpure_intro">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mpureIntroMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mpure_intro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2696">mpure_intro</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mpureIntro-0" data-verso-hover="2696">mpure_intro</span></code> operates on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal of the form <code>P ⊢ₛ ⌜φ⌝</code>.
It leaves the stateful proof mode (thereby discarding <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">P</span></code>), leaving the regular goal <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">φ</span></code>.</p>
                      <pre>theorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by
  mpure_intro
  exact True.intro
</pre></div>
                    </div>
                  <div class="namedocs" id="mexfalso">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mexfalsoMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mexfalso" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2697">mexfalso</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mexfalso-0" data-verso-hover="2697">mexfalso</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#exfalso" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticExfalso-0" data-verso-hover="2466">exfalso</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by
  mintro HP
  mexfalso
  mexact HP
</pre></div>
                    </div>
                  </section>
                <section>
                  <h4 id="The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Manipulating-Stateful-Hypotheses">
                    13.5.23.1.3. Manipulating Stateful Hypotheses</h4>
                  <div class="namedocs" id="mclear">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mclearMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mclear" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2698">mclear</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mclear" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mclearMacro-0" data-verso-hover="2698">mclear</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#clear" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2436">clear</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (P Q : SPred σs) : P ⊢ₛ Q → Q := by
  mintro HP
  mintro HQ
  mclear HP
  mexact HQ
</pre></div>
                    </div>
                  <div class="namedocs" id="mdup">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mdup" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mdup" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2699">mdup</span></a></pre><div class="text">
                      <p>
                        Duplicate a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> hypothesis.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="mhave">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mhaveMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mhave" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2700">mhave</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mhave" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mhaveMacro-0" data-verso-hover="2700">mhave</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  mintro HP HPQ
  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ
  mexact HQ
</pre></div>
                    </div>
                  <div class="namedocs" id="mreplace">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mreplaceMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mreplace" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2701">mreplace</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mreplace" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mreplaceMacro-0" data-verso-hover="2701">mreplace</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#replace" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2591">replace</span></a></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      <pre>example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  mintro HP HPQ
  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ
  mexact HPQ
</pre></div>
                    </div>
                  <div class="namedocs" id="mspecialize">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mspecializeMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mspecialize" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2702">mspecialize</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mspecialize" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspecializeMacro-0" data-verso-hover="2702">mspecialize</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.specialize-0">specialize</span></code>, but operating on a stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.
It specializes a hypothesis from the stateful context with hypotheses from either the pure
or stateful context or pure terms.</p>
                      <pre>example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  mintro HP HPQ
  mspecialize HPQ HP
  mexact HPQ

example (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by
  mintro HQ HΨ
  mspecialize HΨ (y + 1) hP HQ
  mexact HΨ
</pre></div>
                    </div>
                  <div class="namedocs" id="mspecialize_pure">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mspecializePureMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mspecialize_pure" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2703">mspecialize_pure</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mspecialize_pure" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspecializePureMacro-0" data-verso-hover="2703">mspecialize_pure</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mspecialize" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspecializeMacro-0" data-verso-hover="2702">mspecialize</span></a></code>, but it specializes a hypothesis from the
<em>pure</em> context with hypotheses from either the pure or stateful context or pure terms.</p>
                      <pre>example (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by
  mintro HQ
  mspecialize_pure (hΨ (y + 1)) hP HQ =&gt; HΨ
  mexact HΨ
</pre></div>
                    </div>
                  <div class="namedocs" id="mcases">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mcasesMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mcases" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2688">mcases</span></a></pre><div class="text">
                      <p>
                        Like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#rcases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-0" data-verso-hover="2473">rcases</span></a></code>, but operating on stateful <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goals.
Example: Given a goal <code>h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R</code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mcases-0" data-verso-hover="2688">mcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mcases-0" data-verso-hover="2688">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hqr</span><span class="unknown token" data-binding="">⟩</span></code> will yield two goals:
<code>(hq : Q, hqr : Q → R) ⊢ₛ R</code> and <code>(hr : R) ⊢ₛ R</code>.</p>
                      <p>
                        That is, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mcases-0" data-verso-hover="2688">mcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mcases-0" data-verso-hover="2688">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span></code> has the following semantics, based on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span></code>:</p>
                      <ul>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">□</span><span class="unknown token" data-binding="">h'</span></code> renames <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.78582" data-verso-hover="1978">h'</span></code> in the stateful context, regardless of whether <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> is pure</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">⌜</span><span class="unknown token" data-binding="">h'</span><span class="unknown token" data-binding="">⌝</span></code> introduces <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.78582" data-verso-hover="2704">h'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78551" data-verso-hover="2705">φ</span></code>  to the pure local context if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⌜</span><span class="unknown token" data-binding="">φ</span><span class="unknown token" data-binding="">⌝</span></code>
(c.f. <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Lean.Elab.Tactic.Do.ProofMode.IsPure</span></code>)</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.78619" data-verso-hover="2704">pat</span><span class="unknown token" data-binding="">=</span><span class="var token" data-binding="var-_uniq.78582" data-verso-hover="2704">h'</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">⌜</span><span class="unknown token" data-binding="">h'</span><span class="unknown token" data-binding="">⌝</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> is pure
(c.f. <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Lean.Elab.Tactic.Do.ProofMode.IsPure</span></code>), otherwise it is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">□</span><span class="unknown token" data-binding="">h'</span></code>.</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.78619" data-verso-hover="2704">pat</span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">_</span></code> renames <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code> to an inaccessible name</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat</span><span class="unknown token" data-binding="">=</span><span class="unknown token" data-binding="">-</span></code> discards <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span></code></p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">pat₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat₂</span><span class="unknown token" data-binding="">⟩</span></code> matches on conjunctions and existential quantifiers and recurses via
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat₁</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat₂</span></code>.</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">pat₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat₂</span><span class="unknown token" data-binding="">⟩</span></code> matches on disjunctions, matching the left alternative via <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat₁</span></code> and the right
alternative via <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">pat₂</span></code>.</p>
                          </li>
                        </ul>
                      </div>
                    </div>
                  <div class="namedocs" id="mrename_i">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mrenameIMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mrename_i" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2680">mrename_i</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mrename_i" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mrenameIMacro-0" data-verso-hover="2680">mrename_i</span></a></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#rename_i" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2391">rename_i</span></a></code>, but names inaccessible stateful hypotheses in a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred" data-verso-hover="2669">Std.Do.SPred</span></code> goal.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="mpure">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mpureMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mpure" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2706">mpure</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#mpure" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mpureMacro-0" data-verso-hover="2706">mpure</span></a></code> moves a pure hypothesis from the stateful context into the pure context.</p>
                      <pre>example (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by
  mintro Hφ
  mpure Hφ
  mexact (ψ Hφ)
</pre></div>
                    </div>
                  <div class="namedocs" id="mframe">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.mframeMacro" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/Tactic-Reference/#mframe" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2682">mframe</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mframe-0" data-verso-hover="2682">mframe</span></code> infers which hypotheses from the stateful context can be moved into the pure context.
This is useful because pure hypotheses "survive" the next application of modus ponens
(<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred.mp" data-verso-hover="2707">Std.Do.SPred.mp</span></code>) and transitivity (<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Std.Do.SPred.entails.trans" data-verso-hover="2708">Std.Do.SPred.entails.trans</span></code>).</p>
                      <p>
                        It is used as part of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.mspec-0" data-verso-hover="2670">mspec</span></code> tactic.</p>
                      <pre>example (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by
  mintro _
  mframe
  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/
  mcases h with hP
  mexact h
</pre></div>
                    </div>
                  </section>
                </section>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Tactic-Proofs/Options/#tactic-language-options" rel="prev" title="13.4. Options"><span class="arrow">←</span><span class="where">13.4. Options</span></a><a class="local-button active" href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv" rel="next" title="13.6. Targeted Rewriting with conv"><span class="where">13.6. Targeted Rewriting with conv</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

