<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>The Tactic Language</title><link rel="stylesheet" href="book.css">
    <link rel="stylesheet" href="verso-vars.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-search/elasticlunr.min.js"></script>
    <script src="-verso-search/fuzzysort.js"></script>
    <script src="-verso-search/searchIndex.js"></script>
    <script type="module" src="-verso-search/search-init.js"></script>
    <link rel="stylesheet" href="-verso-search/search-box.css">
    <link rel="stylesheet" href="-verso-search/search-highlight.css">
    <link rel="stylesheet" href="-verso-search/domain-display.css">
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.min.js"></script>
    <script src="-verso-data/tippy-bundle.umd.min.js"></script>
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
  position: relative;
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
.live-link {
  font-family: var(--verso-structure-font-family);
  position: absolute;
  bottom: 0px;
  right: 0px;
  padding: 0.5rem;
  border-top: 1px solid #98B2C0;
  border-left: 1px solid #98B2C0;
  border-top-left-radius: 0.5rem;
}
.live-link a {
  text-decoration: none;
  color: var(--lean-blue);
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
  .error-explanation-metadata {
    margin-bottom: 2rem; /* Double the paragraph margin */
  }

  .error-explanation-metadatum:not(:last-child):after {
    content: '|';
    margin: 0 10px;
  }
  .error-explanation-removed-warning {
    border: 1px solid var(--verso-warning-color);
    border-radius: 0.5rem;
    padding-left: var(--verso--box-padding);
    padding-right: var(--verso--box-padding);
  }
  </style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
  font-size: inherit;
}

.hl.lean .keyword {
  color: var(--verso-code-keyword-color,);
  font-weight: var(--verso-code-keyword-weight, bold);
  font-style: var(--verso-code-keyword-style, normal);
  font-family: var(--verso-code-keyword-font-family,);
}

.hl.lean .const {
  color: var(--verso-code-const-color,);
  font-weight: var(--verso-code-const-weight, normal);
  font-style: var(--verso-code-const-style, normal);
  font-family: var(--verso-code-const-font-family,);
}

.hl.lean .var {
  color: var(--verso-code-var-color,);
  font-weight: var(--verso-code-var-weight, normal);
  font-style: var(--verso-code-var-style, italic);
  font-family: var(--verso-code-var-font-family,);

  position: relative;
}

.hl.lean .literal, .hl.lean .unknown {
  color: var(--verso-code-color,);
  font-weight: normal;
  font-style: normal;
  font-family: var(--verso-code-font-family,);
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
  background: none;
  color: black;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean {
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean * {
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
  text-decoration-skip-ink: none;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error .verso-message, .error .verso-message .token, .error .verso-message label {
  color: var(--verso-error-color);
}

.error .verso-message .case-label:has(input[type="checkbox"])::before {
  background-color: var(--verso-error-color) !important;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-indicator-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.lean-output {
  border-left: 0.2em solid transparent;
  padding: 0 0 0 0.5em;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.lean-output.error {
  border-color: var(--verso-error-indicator-color);
}

.lean-output.information {
  border-color: var(--verso-info-indicator-color);
}

.lean-output.warning {
  border-color: var(--verso-warning-indicator-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.information :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-info-indicator-color, blue);
}

@media (hover: hover) {
  .hl.lean .has-info.information:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.information {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.information {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: var(--verso-text-font-family, sans-serif);
  white-space: normal;
  max-width: calc(min(40rem, 90vw));
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: var(--verso-code-font-family);
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline;
  vertical-align: top;
  /* Without these, mobile Safari will start making font sizes inconsistent when its text size adjustment feature is triggered.*/
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

.hl.lean .tactic:has(.tactic-toggle:checked) {
  display: inline-grid;
  grid-template-columns: 1fr;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
  display: inline;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  /* These need to be em, not rem, to scale with the font */
  border-radius: 1em;
  height: 0.25em;
  vertical-align: middle;
  width: 0.6em;
  margin-left: 0.1em;
  margin-right: 0.1em;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5em;
}

/*
Some CSS frameworks customize details/summary in ways not compatible with Verso's output.
*/

.hl.lean details {
  display: block !important;
  margin: 0;
}

.hl.lean details summary {
  display: list-item !important;
  margin: 0;
}

.hl.lean details summary:focus {
  outline: none;
  outline-offset: none;
  color: inherit;
}

.hl.lean ul > li {
  margin-bottom: 0;
}

.hl.lean details summary::marker {
  display: inline !important;
}

.hl.lean details > summary:first-of-type {
  list-style-type: disclosure-closed;
  list-style-position: inside;
}

.hl.lean details[open] > summary:first-of-type {
  list-style-type: disclosure-open;
}

.hl.lean details summary::before, .hl.lean details summary::after {
  content: "" !important;
  background: none;
  display: none;
}

.hl.lean .tactic-state summary {
  /* These need to be em, not rem, to scale with the font */
  margin-left: -0.5em;
}

.hl.lean .tactic-state details {
  /* These need to be em, not rem, to scale with the font */
  padding-left: 0.5em;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7em;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6em;
  height: 0.6em;
  vertical-align: middle;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  /* These need to be em, not rem, to scale with the font */
  margin-left: 0.5em;
  margin-top: 0.1em;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .goal-name {
  font-style: italic;
  font-family: var(--verso-code-font-family);
  color: inherit;
}

.hl.lean .hypotheses {
  display: table;
}

.hl.lean .hypothesis {
  display: table-row;
}

.hl.lean .hypothesis > * {
  display: table-cell;
}


.hl.lean .hypotheses .colon {
  text-align: center;
  /* This needs to be em, not rem, to scale with the font */
  min-width: 1em;
}

.hl.lean .hypotheses .name {
  text-align: right;
}

.hl.lean .hypotheses .name,
.hl.lean .hypotheses .type,
.hl.lean .conclusion .type {
  font-family: var(--verso-code-font-family);
}

.tippy-box {
  /* Without these, mobile Safari will start making font sizes inconsistent when its text size adjustment feature is triggered.*/
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;

}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}

.verso-message .trace {
  display: block;
}

.verso-message .trace > summary::marker {
  color: var(--verso-text-color);
}

.verso-message .trace-children {
  margin: 0;
  padding: 0;
}

.verso-message .trace-children > li {
  list-style-type: none;
  margin-left: 1.5em;
}

.verso-message .trace-children > li:not(:has(.trace)) {
  margin-left: 0;
}

.verso-message .trace-class {
  color: color-mix(in srgb, currentColor 70%, transparent);
  font-weight: bold;
  margin: 0;
  padding: 0;
}

.verso-message .text {
  white-space: pre-wrap;
}

</style><style>.error-explanation-short-name { hyphenate-character: ''; }</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}
/* Highlight the clicked term */
.def-technical-term:target {
  background-color: var(--verso-selected-color);
  outline: auto;
}
</style><style>
.error-example-container:not(:last-child) {
  border-bottom: 1px solid gray;
  padding-bottom: var(--verso--box-padding);
}
.error-example-tab-list [role="tab"] {
  position: relative;
  z-index: 1;
  background: white;
  border: 0;
  padding: 0.2em;
  cursor: pointer;
}
.error-example-tab-list [role="tab"]:not(:last-child) {
  margin-right: 1rem;
}
.error-example-tab-list [role="tab"][aria-selected="true"] {
  border-bottom: 1px solid gray;
}
/* this rule and the following ensure that all tabs are the same height */
.error-example-tab-view {
  display: flex;
}
.error-example-tabpanel {
  margin-right: -100%;
  width: 100%;
  display: block;
}
.error-example-tabpanel.error-example-tabpanel-hidden {
  visibility: hidden;
}
.error-example-tabpanel .hl.lean .token {
  /* unset transition to avoid lag when switching panels */
  transition: visibility 0s;
}
  </style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.addEventListener('DOMContentLoaded', () => {
  const tabLists = document.querySelectorAll('.error-example-tab-list')
  tabLists.forEach(tabList => {
    const tabs = tabList.querySelectorAll(':scope > [role="tab"]')

    const setActiveTab = (e) => {
      for (const tab of tabs) {
        const controllee = document.getElementById(tab.getAttribute('aria-controls'))
        if (tab === e.target) {
          tab.setAttribute('aria-selected', true)
          controllee.classList.remove('error-example-tabpanel-hidden')
        } else {
          tab.setAttribute('aria-selected', false)
          controllee.classList.add('error-example-tabpanel-hidden')
        }
      }
    }

    tabs.forEach(tab => {
      tab.addEventListener('click', setActiveTab)
    })

    let focusedIdx = 0
    tabList.addEventListener('keydown', e => {
      if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
        tabs[focusedIdx].setAttribute('tabindex', -1)
        focusedIdx =
          e.key === 'ArrowRight'
          ? (focusedIdx + 1) % tabs.length
          : (focusedIdx - 1 + tabs.length) % tabs.length
        tabs[focusedIdx].setAttribute('tabindex', 0)
        tabs[focusedIdx].focus()
      }
    })
  })
})
  </script>
    <script>
      function openDetailsForHashTarget() {
  // Get the current hash from the URL
  const hash = window.location.hash;

  // Exit early if no hash is present
  if (!hash) return;

  // Remove the # to get the actual ID
  const targetId = hash.substring(1);

  // Find the target element
  const targetElement = document.getElementById(targetId);

  // Exit if target element doesn't exist
  if (!targetElement) return;

  // Find the closest details element that contains the target
  const detailsElement = targetElement.closest('details');

  // If the target is inside a details element, open it
  if (detailsElement) {
    detailsElement.open = true;
  }
}

// Run the function when the page loads
document.addEventListener('DOMContentLoaded', openDetailsForHashTarget);

// Also run when the hash changes (for single-page applications)
window.addEventListener('hashchange', openDetailsForHashTarget);

// Run immediately in case the script loads after DOMContentLoaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', openDetailsForHashTarget);
} else {
  openDetailsForHashTarget();
}
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let docsJson = "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.information').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    <script defer="defer" data-domain="lean-lang.org" src="https://plausible.io/js/script.outbound-links.js"></script>
    <script src="static/print.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <script src="-verso-search/search-highlight.js" defer="defer"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="current numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="The--grind--tactic/#grind-tactic">The <code>grind</code> tactic</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">22.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Error-Explanations/#The-Lean-Language-Reference--Error-Explanations">Error Explanations</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="The-Module-System/#module-system">The Module System</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="platforms/#platforms">Supported Platforms</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-tactics" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-tactics" checked="checked"></label><span class="number">13.</span> <span class=""><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></span></div>
              <table><tr class="numbered"><td class="num">13.1.</td><td><a href="Tactic-Proofs/Running-Tactics/#by">Running Tactics</a></td></tr><tr class="numbered"><td class="num">13.2.</td><td><a href="Tactic-Proofs/Reading-Proof-States/#proof-states">Reading Proof States</a></td></tr><tr class="current numbered"><td class="num">13.3.</td><td><a href="Tactic-Proofs/The-Tactic-Language/#tactic-language">The Tactic Language</a></td></tr><tr class="numbered"><td class="num">13.4.</td><td><a href="Tactic-Proofs/Options/#tactic-language-options">Options</a></td></tr><tr class="numbered"><td class="num">13.5.</td><td><a href="Tactic-Proofs/Tactic-Reference/#tactic-ref">Tactic Reference</a></td></tr><tr class="numbered"><td class="num">13.6.</td><td><a href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv">Targeted Rewriting with <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="0">conv</span></a></code></a></td></tr><tr class="numbered"><td class="num">13.7.</td><td><a href="Tactic-Proofs/Naming-Bound-Variables/#bound-variable-name-hints">Naming Bound Variables</a></td></tr><tr class="numbered"><td class="num">13.8.</td><td><a href="Tactic-Proofs/Custom-Tactics/#custom-tactics">Custom Tactics</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-tactic-language" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-tactic-language" checked="checked"></label><span class="number">13.3.</span> <span class="current"><a href="Tactic-Proofs/The-Tactic-Language/#tactic-language">The Tactic Language</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-control">Control Structures</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-success-failure">Success and Failure</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#fail"><code class="tactic-name">fail</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#fail_if_success"><code class="tactic-name">fail_if_success</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#try"><code class="tactic-name">try</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#first"><code class="tactic-name">first</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-branching">Branching</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><code class="tactic-name">if ... then ... else ...</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________"><code class="tactic-name">if h : ... then ... else ...</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#match"><code class="tactic-name">match</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-goal-selection">Goal Selection</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#case"><code class="tactic-name">case</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#case___"><code class="tactic-name">case'</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#rotate_left"><code class="tactic-name">rotate_left</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#rotate_right"><code class="tactic-name">rotate_right</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">1.3.1.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-sequencing">Sequencing</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#_LT__SEMI__GT_"><code class="tactic-name">&lt;;&gt;</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">1.3.2.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-multiple-goals">Working on Multiple Goals</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#all_goals"><code class="tactic-name">all_goals</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#any_goals"><code class="tactic-name">any_goals</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.4.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-focusing">Focusing</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#___"><code class="tactic-name">·</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#next"><code class="tactic-name">next</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#focus"><code class="tactic-name">focus</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.5.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-iteration">Repetition and Iteration</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#iterate"><code class="tactic-name">iterate</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#repeat"><code class="tactic-name">repeat</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#repeat___"><code class="tactic-name">repeat'</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#repeat1___"><code class="tactic-name">repeat1'</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-hygiene">Names and Hygiene</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#tactic___hygienic"><code>tactic.hygienic</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-assumptions">Accessing Assumptions</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#rename_i"><code class="tactic-name">rename_i</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-assumption-management">Assumption Management</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#rename"><code class="tactic-name">rename</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#revert"><code class="tactic-name">revert</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#clear"><code class="tactic-name">clear</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-local-defs">Local Definitions and Proofs</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#have"><code class="tactic-name">have</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#have-next"><code class="tactic-name">have</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#have___"><code class="tactic-name">have'</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#let"><code class="tactic-name">let</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#let-rec"><code class="tactic-name">let rec</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#letI"><code class="tactic-name">letI</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#let___"><code class="tactic-name">let'</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-config">Configuration</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#Lean___Parser___Tactic___configItem-next"><span class="syntax"><span class="keyword">+</span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#Lean___Parser___Tactic___configItem-next-next"><span class="syntax"><span class="keyword">-</span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#Lean___Parser___Tactic___configItem-next-next-next"><span class="syntax"><span class="keyword">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#Lean___Parser___Tactic___configItem-next-next-next-next"><span class="syntax"><span class="keyword">(</span><span class="literalIdent">config</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">)</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">6.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-namespaces-options">Namespace and Option Management</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#set_option"><code class="tactic-name">set_option</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#open"><code class="tactic-name">open</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.1.</span> <a href="Tactic-Proofs/The-Tactic-Language/#tactic-language-unfolding">Controlling Unfolding</a></span></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#with_reducible_and_instances"><code class="tactic-name">with_reducible_and_instances</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#with_reducible"><code class="tactic-name">with_reducible</code></a></li>
                <li>
                  <a href="Tactic-Proofs/The-Tactic-Language/#with_unfolding_all"><code class="tactic-name">with_unfolding_all</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Tactic-Proofs/Reading-Proof-States/#proof-states" rel="prev" title="13.2. Reading Proof States"><span class="arrow">←</span><span class="where">13.2. Reading Proof States</span></a><a class="local-button active" href="Tactic-Proofs/Options/#tactic-language-options" rel="next" title="13.4. Options"><span class="where">13.4. Options</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              13.3. The Tactic Language<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language" title="Permalink">🔗</a></span></h1>
            <p>
              A tactic script consists of a sequence of tactics, separated either by semicolons or newlines.
When separated by newlines, tactics must be indented to the same level.
Explicit curly braces and semicolons may be used instead of indentation.
Tactic sequences may be grouped by parentheses.
This allows a sequence of tactics to be used in a position where a single tactic would otherwise be grammatically expected.</p>
            <p>
              Generally, execution proceeds from top to bottom, with each tactic running in the proof state left behind by the prior tactic.
The tactic language contains a number of control structures that can modify this flow.</p>
            <p>
              Each tactic is a syntax extension in the <code>tactic</code> category.
This means that tactics are free to define their own concrete syntax and parsing rules.
However, with a few exceptions, the majority of tactics can be identified by a leading keyword; the exceptions are typically frequently-used built-in control structures such as <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#_LT__SEMI__GT_" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2372">&lt;;&gt;</span></a></code>.</p>
            <section>
              <h2 id="tactic-language-control">
                13.3.1. Control Structures<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-control" title="Permalink">🔗</a></span></h2>
              <p>
                Strictly speaking, there is no fundamental distinction between control structures and other tactics.
Any tactic is free to take others as arguments and arrange for their execution in any context that it sees fit.
Even if a distinction is arbitrary, however, it can still be useful.
The tactics in this section are those that resemble traditional control structures from programming, or those that <em>only</em> recombine other tactics rather than making progress themselves.</p>
              <section>
                <h3 id="tactic-language-success-failure">
                  13.3.1.1. Success and Failure<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-success-failure" title="Permalink">🔗</a></span></h3>
                <p>
                  When run in a proof state, every tactic either succeeds or fails.
Tactic failure is akin to exceptions: failures typically "bubble up" until handled.
Unlike exceptions, there is no operator to distinguish between reasons for failure; <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#first" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2408">first</span></a></code> simply takes the first branch that succeeds.</p>
                <div class="namedocs" id="fail">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.fail" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#fail" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2409">fail</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">fail</span><span class="inter-text"> </span><span class="unknown token" data-binding="">msg</span></code> is a tactic that always fails, and produces an error using the given message.</p>
                    </div>
                  </div>
                <div class="namedocs" id="fail_if_success">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.failIfSuccess" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#fail_if_success" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2410">fail_if_success</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">fail_if_success</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> fails if the tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code> succeeds.</p>
                    </div>
                  </div>
                <div class="namedocs" id="try">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticTry_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#try" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2411">try</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.termTry-0">try</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> and succeeds even if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> failed.</p>
                    </div>
                  </div>
                <div class="namedocs" id="first">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.first" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#first" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2408">first</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">first</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span></code> runs each <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> until one succeeds, or else fails.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="tactic-language-branching">
                  13.3.1.2. Branching<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-branching" title="Permalink">🔗</a></span></h3>
                <p>
                  Tactic proofs may use pattern matching and conditionals.
However, their meaning is not quite the same as it is in terms.
While terms are expected to be executed once the values of their variables are known, proofs are executed with their variables left abstract and should consider <em>all</em> cases simultaneously.
Thus, when <code class="plain-keyword">if</code> and <code class="plain-keyword">match</code> are used in tactics, their meaning is reasoning by cases rather than selection of a concrete branch.
All of their branches are executed, and the condition or pattern match is used to refine the main goal with more information in each branch, rather than to select a single branch.</p>
                <div class="namedocs" id="if-_________-then-_________-else-_________">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacIfThenElse" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1216">if ... then ... else ...</span></a></pre><div class="text">
                    <p>
                      In tactic mode, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="146">if</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11260" data-verso-hover="338">t</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11281" data-verso-hover="2412">tac1</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-0" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11300" data-verso-hover="2412">tac2</span></code> is alternative syntax for:</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text">
</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac1</span><span class="inter-text">
</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac2</span></code><p>
                      It performs case distinction on <code>h† : t</code> or <code>h† : ¬t</code>, where <code>h†</code> is an anonymous
hypothesis, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac1</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac2</span></code> are the subproofs. (It doesn't actually use
nondependent <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">if</span></code>, since this wouldn't add anything to the context and hence would be
useless for proving theorems. To actually insert an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-ite" data-verso-hover="779">ite</span></code> application use
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.refine-0" data-verso-hover="2413">refine</span></a><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7" data-verso-hover="146">if</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">_</span></code>.)</p>
                    </div>
                  </div>
                <div class="namedocs" id="if-h-___-_________-then-_________-else-_________">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacDepIfThenElse" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1217">if h : ... then ... else ...</span></a></pre><div class="text">
                    <p>
                      In tactic mode, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Terms/Conditionals/#termDepIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-0" data-verso-hover="1159">if</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11809" data-verso-hover="2414">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11670" data-verso-hover="338">t</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termDepIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-0" data-verso-hover="1159">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11707" data-verso-hover="1928">tac1</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termDepIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-0" data-verso-hover="1159">else</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11752" data-verso-hover="1928">tac2</span></code> can be used as alternative syntax for:</p>
                    <pre>by_cases h : t
· tac1
· tac2
</pre><p>
                      It performs case distinction on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.11827" data-verso-hover="2414">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11823" data-verso-hover="2415">t</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">t</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac1</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac2</span></code> are the subproofs.</p>
                    <p>
                      You can use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">_</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code> for either subproof to delay the goal to after the tactic, but
if a tactic sequence is provided for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac1</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac2</span></code> then it will require the goal to be closed
by the end of the block.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Reasoning by cases with <code>if</code></summary><div class="example-content">
                    <p>
                      In each branch of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Tactic.tacIfThenElse : tactic</code><span class="sep"></span><code class="docstring">In tactic mode, `if t then tac1 else tac2` is alternative syntax for:
```
by_cases t
· tac1
· tac2
```
It performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous
hypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use
nondependent `if`, since this wouldn't add anything to the context and hence would be
useless for proving theorems. To actually insert an `ite` application use
`refine if t then ?_ else ?_`.)
</code></code><a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><code class="kw">if</code></a></span>, an assumption is added that reflects whether <code>n = 0</code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-18658">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-18678" data-verso-hover="146">if</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-18678" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-18678" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7128376579246098990-18712-18714-656"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-18712" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7128376579246098990-18712-18714-656"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1280">&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text">
  </span><a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-18717" data-verso-hover="1216">if</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-8855579560541843794-18726-18730-658"><a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-18717" data-verso-hover="1216">then</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8855579560541843794-18726-18730-658"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.143" data-verso-hover="2416">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1280">&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-7-18735-18743-660"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-18735" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-18735-18743-660"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-3644381491911614564-18746-18750-661"><a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-18717" data-verso-hover="1216">else</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3644381491911614564-18746-18750-661"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.150" data-verso-hover="2417">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Logical-Connectives/#Not" title="Documentation for Not"><span class="const token" data-binding="const-Not" data-verso-hover="784">¬</span></a><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1280">&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-12009684471937149932-18755-18793-663"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-18755" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-18760">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">↓</span><span class="const token" data-binding="const-reduceIte" data-verso-hover="2418">reduceIte</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-gt_iff_lt" data-verso-hover="1287">gt_iff_lt</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12009684471937149932-18755-18793-663"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.150" data-verso-hover="2417">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Propositions/Logical-Connectives/#Not" title="Documentation for Not"><span class="const token" data-binding="const-Not" data-verso-hover="784">¬</span></a><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-7-18798-18803-665"><a href="Tactic-Proofs/Tactic-Reference/#omega" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-18798" data-verso-hover="522">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-18798-18803-665"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><div class="namedocs" id="match">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.match" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2419">match</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code> performs case analysis on one or more expressions.
See <a href="https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html">Induction and Recursion</a>.
The syntax for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code> tactic is the same as term-mode <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">match</span></code>, except that
the match arms are tactics instead of expressions.</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-0">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7306847916526903045-29-31-666"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-29" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7306847916526903045-29-31-666"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span></span></span></span></span><span class="inter-text">
  </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-34" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-34" data-verso-hover="2419">with</span></a><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-12848116897899266360-49-55-668"><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12848116897899266360-49-55-668"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-56-59-670"><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-56" data-verso-hover="18">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-56-59-670"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-17439872189573959381-62-70-671"><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="9">i</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17439872189573959381-62-70-671"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.91" data-verso-hover="9">i</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="9">i</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="9">i</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-71-75-673"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-71" data-verso-hover="38">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-71-75-673"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      When pattern matching, instances of the scrutinee in the goal are replaced with the patterns that match them in each branch.
Each branch must then prove the refined goal.
Compared to the <code>cases</code> tactic, using <code>match</code> can allow a greater degree of flexibility in the cases analysis being performed, but the requirement that each branch solve its goal completely makes it more difficult to incorporate into larger automation scripts.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Reasoning by cases with <code>match</code></summary><div class="example-content">
                    <p>
                      In each branch of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Tactic.match : tactic</code><span class="sep"></span><code class="docstring">`match` performs case analysis on one or more expressions.
See [Induction and Recursion][tpil4].
The syntax for the `match` tactic is the same as term-mode `match`, except that
the match arms are tactics instead of expressions.
```
example (n : Nat) : n = n := by
  match n with
  | 0 =&gt; rfl
  | i+1 =&gt; simp
```

[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html
</code></code><a href="Tactic-Proofs/The-Tactic-Language/#match"><code class="kw">match</code></a></span>, the scrutinee <code>n</code> has been replaced by either <code>0</code> or <code>k + 1</code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19486">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19506" data-verso-hover="146">if</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19506" data-verso-hover="146">then</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-19506" data-verso-hover="146">else</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7128376579246098990-19540-19542-674"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-19540" data-verso-hover="12">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7128376579246098990-19540-19542-674"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1280">&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text">
  </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-19545" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-19545" data-verso-hover="2419">with</span></a><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-3108202533874362779-19560-19566-676"><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3108202533874362779-19560-19566-676"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1280">&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-7-19571-19575-678"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-19571" data-verso-hover="38">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19571-19575-678"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-4038326497523255110-19578-19588-679"><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.164" data-verso-hover="9">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4038326497523255110-19578-19588-679"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.164" data-verso-hover="9">k</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ite" data-verso-hover="779">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.164" data-verso-hover="9">k</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.164" data-verso-hover="9">k</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-ite" data-verso-hover="779">else</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.164" data-verso-hover="9">k</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1280">&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-7-19593-19597-681"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-19593" data-verso-hover="38">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19593-19597-681"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="tactic-language-goal-selection">
                  13.3.1.3. Goal Selection<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-goal-selection" title="Permalink">🔗</a></span></h3>
                <p>
                  Most tactics affect the <a class="technical-term" href="Tactic-Proofs/#--tech-term-main-goal">main goal</a>.
Goal selection tactics provide a way to treat a different goal as the main one, rearranging the sequence of goals in the proof state.</p>
                <div class="namedocs" id="case">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.case" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#case" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2373">case</span></a></pre><div class="text">
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">case</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tag</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> focuses on the goal with case name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tag</span></code> and solves it using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code>,
or else fails.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">case</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tag</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xₙ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> additionally renames the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> most recent hypotheses
with inaccessible names to the given names.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">case</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tag₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tag₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-null-0">case</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tag₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-null-0">case</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tag₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span><span class="unknown token" data-binding="">)</span></code>.</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="case___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.case'" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#case___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2380">case'</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#case___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2380">case'</span></a></code> is similar to the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">case</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tag</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> tactic, but does not ensure the goal
has been solved after applying <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code>, nor admits the goal if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> failed.
Recall that <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#case" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2373">case</span></a></code> closes the goal using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#sorry" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-0" data-verso-hover="13">sorry</span></a></code> when <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> fails, and
the tactic execution is not interrupted.</p>
                    </div>
                  </div>
                <div class="namedocs" id="rotate_left">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rotateLeft" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#rotate_left" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2420">rotate_left</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rotate_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span></code> rotates goals to the left by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code>. That is, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#rotate_left" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rotateLeft-0" data-verso-hover="2420">rotate_left</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></code>
takes the main goal and puts it to the back of the subgoal list.
If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> is omitted, it defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="9">1</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="rotate_right">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rotateRight" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#rotate_right" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2421">rotate_right</span></a></pre><div class="text">
                    <p>
                      Rotate the goals to the right by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code>. That is, take the goal at the back
and push it to the front <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> times. If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> is omitted, it defaults to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="9">1</span></code>.</p>
                    </div>
                  </div>
                <section>
                  <h4 id="tactic-language-sequencing">
                    13.3.1.3.1. Sequencing<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-sequencing" title="Permalink">🔗</a></span></h4>
                  <p>
                    In addition to running tactics one after the other, each being used to solve the main goal, the tactic language supports sequencing tactics according to the way in which goals are produced.
The <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#_LT__SEMI__GT_" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2372">&lt;;&gt;</span></a></code> tactic combinator allows a tactic to be applied to <em>every</em> <a class="technical-term" href="Tactic-Proofs/#--tech-term-subgoals">subgoal</a> produced by some other tactic.
If no new goals are produced, then the second tactic is not run.</p>
                  <div class="namedocs" id="_LT__SEMI__GT_">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.«tactic_<;>_»" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#_LT__SEMI__GT_" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2372">&lt;;&gt;</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;;&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac'</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> on the main goal and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac'</span></code> on each produced goal,
concatenating all goals produced by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac'</span></code>.</p>
                      <p>
                        If the tactic fails on any of the <a class="technical-term" href="Tactic-Proofs/#--tech-term-subgoals">subgoals</a>, then the whole <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#_LT__SEMI__GT_" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2372">&lt;;&gt;</span></a></code> tactic fails.</p>
                      </div>
                    </div>
                  <details class="example"><summary class="description">Subgoal Sequencing</summary><div class="example-content">
                      <p>
                      <p>
                        In this proof state:</p>
                      <div class="hl lean tactic-view">
                        <div class="tactic-state">
                          <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14554" data-verso-hover="2422">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="514">∨</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></div>
                        </div>
                      <p>
                        the tactic <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-11017553120788835100-20737-20744-683"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-20737" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14554" data-verso-hover="2422">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11017553120788835100-20737-20744-683"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-684" checked="checked"><span for="--verso-unique-684" class="goal-name">inl</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14652" data-verso-hover="2423">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-685"><span for="--verso-unique-685" class="goal-name">inr</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14665" data-verso-hover="2424">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></span></span></code> yields the following two goals:</p>
                      <div class="hl lean tactic-view">
                        <div class="tactic-state">
                          <span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-686" checked="checked"><span for="--verso-unique-686" class="goal-name">inl</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14652" data-verso-hover="2423">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-687" checked="checked"><span for="--verso-unique-687" class="goal-name">inr</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14665" data-verso-hover="2424">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.14551" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></div>
                        </div>
                      <p>
                      <p>
                        Running <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-9066129895469227059-21044-21051-688"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-21044" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14789" data-verso-hover="2422">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9066129895469227059-21044-21051-688"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-689" checked="checked"><span for="--verso-unique-689" class="goal-name">inl</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14887" data-verso-hover="2423">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-690"><span for="--verso-unique-690" class="goal-name">inr</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14900" data-verso-hover="2424">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-14396077663765933714-21054-21062-691"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-21054" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14396077663765933714-21054-21062-691"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-692" checked="checked"><span for="--verso-unique-692" class="goal-name">inr</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14900" data-verso-hover="2424">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></span></span></code> causes <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="" data-verso-hover="38">simp</span></a></code> to solve the first goal, leaving the second behind:</p>
                      <div class="hl lean tactic-view">
                        <div class="tactic-state">
                          <span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-693" checked="checked"><span for="--verso-unique-693" class="goal-name">inr</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.14900" data-verso-hover="2424">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.14786" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></div>
                        </div>
                      <p>
                      <p>
                        Replacing the <code>;</code> with <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#_LT__SEMI__GT_" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2372">&lt;;&gt;</span></a></code> and running <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-2863074244145309066-21405-21412-694"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-21405" data-verso-hover="519">cases</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15150" data-verso-hover="2422">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2863074244145309066-21405-21412-694"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-695" checked="checked"><span for="--verso-unique-695" class="goal-name">inl</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15248" data-verso-hover="2423">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-696"><span for="--verso-unique-696" class="goal-name">inr</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15261" data-verso-hover="2424">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-2863074244145309066-21413-21416-697"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2863074244145309066-21413-21416-697"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-698" checked="checked"><span for="--verso-unique-698" class="goal-name">inl</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15248" data-verso-hover="2423">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-699"><span for="--verso-unique-699" class="goal-name">inr</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15261" data-verso-hover="2424">h✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.15147" data-verso-hover="9">x</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LT___mk" title="Documentation for LT.lt"><span class="const token" data-binding="const-LT.lt" data-verso-hover="294">&lt;</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-21417-21425-700"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-21417" data-verso-hover="38">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-21417-21425-700"><span class="tactic-state">All goals completed! 🐙</span></span></code> solves <strong>both</strong> of the new goals with <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="" data-verso-hover="38">simp</span></a></code>:</p>
                      <div class="hl lean tactic-view">
                        <div class="tactic-state">
                          All goals completed! 🐙</div>
                        </div>
                      </div>
                    </details></section>
                <section>
                  <h4 id="tactic-language-multiple-goals">
                    13.3.1.3.2. Working on Multiple Goals<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-multiple-goals" title="Permalink">🔗</a></span></h4>
                  <p>
                    The tactics <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#all_goals" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="521">all_goals</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#any_goals" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2425">any_goals</span></a></code> allow a tactic to be applied to every goal in the proof state.
The difference between them is that if the tactic fails for in any of the goals, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#all_goals" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="521">all_goals</span></a></code> itself fails, while <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#any_goals" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2425">any_goals</span></a></code> fails only if the tactic fails in all of the goals.</p>
                  <div class="namedocs" id="all_goals">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.allGoals" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#all_goals" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="521">all_goals</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">all_goals</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> on each goal, concatenating the resulting goals.
If the tactic fails on any goal, the entire <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16954" data-verso-hover="72">all_goals</span></code> tactic fails.</p>
                      <p>
                        See also <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">any_goals</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="any_goals">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.anyGoals" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#any_goals" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2425">any_goals</span></a></pre><div class="text">
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">any_goals</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> applies the tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> to every goal,
concatenating the resulting goals for successful tactic applications.
If the tactic fails on all of the goals, the entire <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17202" data-verso-hover="72">any_goals</span></code> tactic fails.</p>
                      <p>
                        This tactic is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">all_goals</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.termTry-10">try</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> except that it fails if none of the applications of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> succeeds.</p>
                      </div>
                    </div>
                  </section>
                </section>
              <section>
                <h3 id="tactic-language-focusing">
                  13.3.1.4. Focusing<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-focusing" title="Permalink">🔗</a></span></h3>
                <p>
                  Focusing tactics remove some subset of the proof goals (typically leaving only the main goal) from the consideration of some further tactics.
In addition to the tactics described here, the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#case" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2373">case</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#case___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2380">case'</span></a></code> tactics focus on the selected goal.</p>
                <div class="namedocs" id="___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.cdot" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2426">·</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> focuses on the main goal and tries to solve it using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code>, or else fails.</p>
                    <p>
                      It is generally considered good Lean style to use bullets whenever a tactic line results in more than one new subgoal.
This makes it easier to read and maintain proofs, because the connections between steps of reasoning are more clear and any change in the number of subgoals while editing the proof will have a localized effect.</p>
                    </div>
                  </div>
                <div class="namedocs" id="next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.«tacticNext_=>_»" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1328">next</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">next</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> focuses on the next goal and solves it using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code>, or else fails.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">next</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xₙ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> additionally renames the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> most recent hypotheses with
inaccessible names to the given names.</p>
                    </div>
                  </div>
                <div class="namedocs" id="focus">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.focus" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#focus" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2427">focus</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Elab.Tactic.focus" data-verso-hover="2428">focus</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17875" data-verso-hover="2429">tac</span></code> focuses on the main goal, suppressing all other goals, and runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17875" data-verso-hover="2429">tac</span></code> on it.
Usually <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code>, which enforces that the goal is closed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17875" data-verso-hover="2429">tac</span></code>, should be preferred.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="tactic-language-iteration">
                  13.3.1.5. Repetition and Iteration<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-iteration" title="Permalink">🔗</a></span></h3>
                <div class="namedocs" id="iterate">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticIterate____" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#iterate" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2393">iterate</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">iterate</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> exactly <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> times.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">iterate</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> runs <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> repeatedly until failure.</p>
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#iterate" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2393">iterate</span></a></code>'s argument is a tactic sequence,
so multiple tactics can be run using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">iterate</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">tac₁</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac₂</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⋯</span><span class="unknown token" data-binding="">)</span></code> or</p>
                    <code class="hl lean block" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">iterate</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">tac₁</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">tac₂</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">⋯</span></code></div>
                  </div>
                <div class="namedocs" id="repeat">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticRepeat_" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#repeat" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2430">repeat</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">repeat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> repeatedly applies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> so long as it succeeds.
The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> may be a tactic sequence, and if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> fails at any point in its execution,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#repeat" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2430">repeat</span></a></code> will revert any partial changes that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> made to the tactic state.</p>
                    <p>
                      The tactic <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> should eventually fail, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">repeat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> will run indefinitely.</p>
                    <p>
                      See also:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.termTry-0">try</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">repeat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> but will apply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> at most once.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> recursively applies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> to each goal.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">first</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac2</span></code> implements the backtracking used by <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#repeat" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2430">repeat</span></a></code></p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="repeat___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.repeat'" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#repeat___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="518">repeat'</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> recursively applies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> on all of the goals so long as it succeeds.
That is to say, if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> produces multiple subgoals, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> is applied to each of them.</p>
                    <p>
                      See also:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">repeat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> simply repeatedly applies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code>.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat1'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> but requires that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> succeed for some goal at least once.</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                <div class="namedocs" id="repeat1___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.repeat1'" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#repeat1___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2431">repeat1'</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat1'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> recursively applies to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> on all of the goals so long as it succeeds,
but <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat1'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> fails if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> succeeds on none of the initial goals.</p>
                    <p>
                      See also:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">repeat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> simply applies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> repeatedly.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> is like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">repeat1'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tac</span></code> but it does not require that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tac</span></code> succeed at least once.</p>
                        </li>
                      </ul>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-language-hygiene">
                13.3.2. Names and Hygiene<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-hygiene" title="Permalink">🔗</a></span></h2>
              <p>
                Behind the scenes, tactics generate proof terms.
These proof terms exist in a local context, because assumptions in proof states correspond to local binders in terms.
Uses of assumptions correspond to variable references.
It is very important that the naming of assumptions be predictable; otherwise, small changes to the internal implementation of a tactic could either lead to variable capture or to a broken reference if they cause different names to be selected.</p>
              <p>
                Lean's tactic language is <em>hygienic</em>. <span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>
This means that the tactic language respects lexical scope: names that occur in a tactic refer to the enclosing binding in the source code, rather than being determined by the generated code, and the tactic framework is responsible for maintaining this property.
Variable references in tactic scripts refer either to names that were in scope at the beginning of the script or to bindings that were explicitly introduced as part of the tactics, rather than to the names chosen for use in the proof term behind the scenes.</p>
              <p>
                A consequence of hygienic tactics is that the only way to refer to an assumption is to explicitly name it.
Tactics cannot assign assumption names themselves, but must rather accept names from users; users are correspondingly obligated to provide names for assumptions that they wish to refer to.
When an assumption does not have a user-provided name, it is shown in the proof state with a dagger (<code>'†', DAGGER	0x2020</code>).
The dagger indicates that the name is <em>inaccessible</em> and cannot be explicitly referred to.</p>
              <p>
                Hygiene can be disabled by setting the option <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#tactic___hygienic" title="Documentation for option tactic.hygienic"><span class="option token" data-binding="option-tactic.hygienic" data-verso-hover="2432">tactic.hygienic</span></a></code> to <code>false</code>.
This is not recommended, as many tactics rely on the hygiene system to prevent capture and thus do not incur the overhead of careful manual name selection.</p>
              <div class="namedocs" id="tactic___hygienic">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&amp;name=tactic.hygienic" title="Permalink">🔗</a></span><span class="label">option</span><pre class="signature hl lean block">tactic.hygienic</pre><div class="text">
                  <p>
                    Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="43">true</span></a></code></p>
                  <p>
                    make sure tactics are hygienic</p>
                  </div>
                </div>
              <details class="example"><summary class="description">Tactic hygiene: inaccessible assumptions</summary><div class="example-content">
                  <p>
                    When proving that <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20502" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20502" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20502" data-verso-hover="9">n</span></code>, the initial proof state is:</p>
                  <div class="hl lean tactic-view">
                    <div class="tactic-state">
                      <span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n</span></span></span></span></div>
                    </div>
                  <p>
                    The tactic <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-4897241420467710-25017-25022-702"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-25017" data-verso-hover="811">intro</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4897241420467710-25017-25022-702"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n✝</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n✝</span></span></span></span></span></span></code> results in a proof state with an inaccessible assumption:</p>
                  <div class="hl lean tactic-view">
                    <div class="tactic-state">
                      <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n✝</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20562" data-verso-hover="9">n✝</span></span></span></span></div>
                    </div>
                  </div>
                </details><details class="example"><summary class="description">Tactic hygiene: accessible assumptions</summary><div class="example-content">
                  <p>
                    When proving that <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20869" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20869" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20869" data-verso-hover="9">n</span></code>, the initial proof state is:</p>
                  <div class="hl lean tactic-view">
                    <div class="tactic-state">
                      <span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span></span></span></span></div>
                    </div>
                  <p>
                    The tactic <code class="hl lean inline" data-lean-context="examples"><span class="tactic"><label for="tactic-state-16150147583271819889-25371-25378-706"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-25371" data-verso-hover="811">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16150147583271819889-25371-25378-706"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span></span></span></span></span></span></code>, with the explicit name <code>n</code>, results in a proof state with an accessibly-named assumption:</p>
                  <div class="hl lean tactic-view">
                    <div class="tactic-state">
                      <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="17">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="19">+</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="20">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20929" data-verso-hover="9">n</span></span></span></span></div>
                    </div>
                  </div>
                </details><section>
                <h3 id="tactic-language-assumptions">
                  13.3.2.1. Accessing Assumptions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-assumptions" title="Permalink">🔗</a></span></h3>
                <p>
                  Many tactics provide a means of specifying names for the assumptions that they introduce.
For example, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="811">intro</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="515">intros</span></a></code> take assumption names as arguments, and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="869">induction</span></a></code>'s <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Tactic.induction : tactic</code><span class="sep"></span><code class="docstring">Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ih₁` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,
  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`
  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.
</code></code><a href="Tactic-Proofs/Tactic-Reference/#induction"><code class="kw">with</code></a></span>-form allows simultaneous case selection, assumption naming, and focusing.
When an assumption does not have a name, one can be assigned using <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#next" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="1328">next</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#case" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2373">case</span></a></code>, or <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#rename_i" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2391">rename_i</span></a></code>.</p>
                <div class="namedocs" id="rename_i">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.renameI" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#rename_i" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2391">rename_i</span></a></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">rename_i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">...</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x_n</span></code> renames the last <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">n</span></code> inaccessible names using the given names.</p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="tactic-language-assumption-management">
                13.3.3. Assumption Management<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-assumption-management" title="Permalink">🔗</a></span></h2>
              <p>
                Larger proofs can benefit from management of proof states, removing irrelevant assumptions and making their names easier to understand.
Along with these operators, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#rename_i" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2391">rename_i</span></a></code> allows inaccessible assumptions to be renamed, and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="811">intro</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="515">intros</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#rintro" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2433">rintro</span></a></code> convert goals that are implications or universal quantification into goals with additional assumptions.</p>
              <div class="namedocs" id="rename">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.rename" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#rename" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2434">rename</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#rename" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rename-0" data-verso-hover="2434">rename</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span></code> renames the most recent hypothesis whose type matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code>
(which may contain placeholders) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code>, or fails if no such hypothesis could be found.</p>
                  </div>
                </div>
              <div class="namedocs" id="revert">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.revert" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#revert" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2435">revert</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">revert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">...</span></code> is the inverse of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">...</span></code>: it moves the given hypotheses
into the main goal's target type.</p>
                  </div>
                </div>
              <div class="namedocs" id="clear">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.clear" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#clear" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2436">clear</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">clear</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">...</span></code> removes the given hypotheses, or fails if there are remaining
references to a hypothesis.</p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-language-local-defs">
                13.3.4. Local Definitions and Proofs<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-local-defs" title="Permalink">🔗</a></span></h2>
              <p>
                <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> both create local assumptions.
Generally speaking, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> should be used when proving an intermediate lemma; <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> should be reserved for local definitions.</p>
              <div class="namedocs" id="have">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticHave__" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> tactic.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> adds the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22419" data-verso-hover="2414">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22415" data-verso-hover="2438">t</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.23226" data-verso-hover="2412">e</span></code> is a term of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22415" data-verso-hover="2438">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> uses the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.23226" data-verso-hover="2412">e</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22415" data-verso-hover="2438">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> for the name of the hypothesis.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> for a pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.23379" data-verso-hover="2103">pat</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code> stands for the tactics that follow this one.
It is convenient for types that have only one applicable constructor.
For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₃</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> produces the
hypotheses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22718" data-verso-hover="1990">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22463" data-verso-hover="338">p</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22886" data-verso-hover="2439">h₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22507" data-verso-hover="338">q</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.23055" data-verso-hover="2440">h₃</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22551" data-verso-hover="338">r</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        The syntax <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.letOptEq-5" data-verso-hover="2441">eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>,
which adds the equation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span></code> to the local context.</p>
                      </li>
                    </ul>
                  <p>
                    The tactic supports all the same syntax variants and options as the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> term.</p>
                  <p>
                    <strong>Properties and relations</strong></p>
                  <ul>
                    <li>
                      <p>
                        It is not possible to unfold a variable introduced using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>, since the definition's value is forgotten.
The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> tactic introduces definitions that can be unfolded.</p>
                      </li>
                    <li>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> is like doing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-0" data-verso-hover="116">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23709" data-verso-hover="2414">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23637" data-verso-hover="2442">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23648" data-verso-hover="2414">e</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">clear_value</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> tactic is preferred for propositions, and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> is preferred for non-propositions.</p>
                      </li>
                    <li>
                      <p>
                        Sometimes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.
Consider using the equivalent <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">nondep</span></code> to indicate the intent.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="have-next">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticHave__" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> tactic.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> adds the hypothesis <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.24674" data-verso-hover="2414">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24670" data-verso-hover="2443">t</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.25481" data-verso-hover="2412">e</span></code> is a term of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.24670" data-verso-hover="2443">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> uses the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.25481" data-verso-hover="2412">e</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.24670" data-verso-hover="2443">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> for the name of the hypothesis.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> for a pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.25634" data-verso-hover="2103">pat</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code> stands for the tactics that follow this one.
It is convenient for types that have only one applicable constructor.
For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">h₁</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₂</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h₃</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code> produces the
hypotheses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.24973" data-verso-hover="1990">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24718" data-verso-hover="338">p</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.25141" data-verso-hover="2439">h₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24762" data-verso-hover="338">q</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.25310" data-verso-hover="2440">h₃</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24806" data-verso-hover="338">r</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        The syntax <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.letOptEq-5" data-verso-hover="2441">eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>,
which adds the equation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span></code> to the local context.</p>
                      </li>
                    </ul>
                  <p>
                    The tactic supports all the same syntax variants and options as the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> term.</p>
                  <p>
                    <strong>Properties and relations</strong></p>
                  <ul>
                    <li>
                      <p>
                        It is not possible to unfold a variable introduced using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>, since the definition's value is forgotten.
The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> tactic introduces definitions that can be unfolded.</p>
                      </li>
                    <li>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-0" data-verso-hover="1251">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> is like doing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-0" data-verso-hover="116">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25964" data-verso-hover="2414">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25892" data-verso-hover="2444">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25903" data-verso-hover="2414">e</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">clear_value</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> tactic is preferred for propositions, and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> is preferred for non-propositions.</p>
                      </li>
                    <li>
                      <p>
                        Sometimes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.
Consider using the equivalent <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">nondep</span></code> to indicate the intent.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="have___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticHave'" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#have___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2445">have'</span></a></pre><div class="text">
                  <p>
                    Similar to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>, but using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2446">refine'</span></a></code></p>
                  </div>
                </div>
              <div class="namedocs" id="let">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticLet__" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>.</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-0" data-verso-hover="2437">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> adds the definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27535" data-verso-hover="2403">e</span></code> is a term of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-0" data-verso-hover="2437">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> uses the type of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27535" data-verso-hover="2403">e</span></code> for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-0" data-verso-hover="2437">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-0" data-verso-hover="2437">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">this</span></code> for the name of the hypothesis.</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-0" data-verso-hover="2437">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> for a pattern <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27589" data-verso-hover="2412">pat</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>,
where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">_</span></code> stands for the tactics that follow this one.
It is convenient for types that let only one applicable constructor.
For example, given <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27256" data-verso-hover="2447">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27061" data-verso-hover="2448">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27126" data-verso-hover="2449">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27191" data-verso-hover="2450">γ</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-0" data-verso-hover="2437">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span></code> produces the
local variables <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27324" data-verso-hover="48">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27061" data-verso-hover="2448">α</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27393" data-verso-hover="317">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27126" data-verso-hover="2449">β</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27463" data-verso-hover="1148">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27191" data-verso-hover="2450">γ</span></code>.</p>
                      </li>
                    <li>
                      <p>
                        The syntax <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-0" data-verso-hover="2437">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.letOptEq-4" data-verso-hover="2441">eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">match</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#match" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.match-0" data-verso-hover="2419">with</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>,
which adds the equation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.27636" data-verso-hover="2451">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27535" data-verso-hover="2452">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27589" data-verso-hover="2452">pat</span></code> to the local context.</p>
                      </li>
                    </ul>
                  <p>
                    The tactic supports all the same syntax variants and options as the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> term.</p>
                  <p>
                    <strong>Properties and relations</strong></p>
                  <ul>
                    <li>
                      <p>
                        Unlike <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code>, it is possible to unfold definitions introduced using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code>, using tactics
such as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;short&quot;:&quot;doc&quot;},{&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;short&quot;:&quot;doc&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="38">simp</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#dsimp" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-0" data-verso-hover="924">dsimp</span></a></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#unfold" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="920">unfold</span></a></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#subst" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2453">subst</span></a></code>.</p>
                      </li>
                    <li>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="2454">clear_value</span></code> tactic turns a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> definition into a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> definition after the fact.
The tactic might fail if the local context depends on the value of the variable.</p>
                      </li>
                    <li>
                      <p>
                        The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> tactic is preferred for data (non-propositions).</p>
                      </li>
                    <li>
                      <p>
                        Sometimes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="" data-verso-hover="1251">have</span></code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.</p>
                      </li>
                    </ul>
                  </div>
                </div>
              <div class="namedocs" id="let-rec">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.letrec" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#let-rec" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2455">let rec</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let-rec" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.letrec-0" data-verso-hover="2455">let</span></a><span class="inter-text"> </span><a href="Tactic-Proofs/The-Tactic-Language/#let-rec" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.letrec-0" data-verso-hover="2455">rec</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span></code> adds a recursive definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> to the current goal.
The syntax is the same as term-mode <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rec</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="letI">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticLetI__" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#letI" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2456">letI</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#letI" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2456">letI</span></a></code> behaves like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code>, but inlines the value instead of producing a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code> term.</p>
                  </div>
                </div>
              <div class="namedocs" id="let___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.tacticLet'__" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#let___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2457">let'</span></a></pre><div class="text">
                  <p>
                    Similar to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#let" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2437">let</span></a></code>, but using <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#refine___" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2446">refine'</span></a></code></p>
                  </div>
                </div>
              </section>
            <section>
              <h2 id="tactic-config">
                13.3.5. Configuration<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-config" title="Permalink">🔗</a></span></h2>
              <p>
                Many tactics are configurable.<span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>
By convention, tactics share a configuration syntax, described using <code class="grammar"><span class="nonterminal" data-kind="optConfig">optConfig</span></code>.
The specific options available to each tactic are described in the tactic's documentation.</p>
              <div class="namedocs" id="Lean___Parser___Tactic___optConfig">
                <span class="label">syntax</span><span class="title">Tactic Configuration</span><div class="text">
                  <p>
                    A tactic configuration consists of zero or more <span id="--tech-term-configuration-items" class="def-technical-term">configuration items</span>:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Tactic___optConfig-next"><a href="Tactic-Proofs/The-Tactic-Language/#Lean___Parser___Tactic___optConfig-next"><span class="nonterminal documented" data-kind="Lean.Parser.Tactic.optConfig"><code class="hover-info"><code class="docstring">Configuration options for tactics. </code></code>optConfig</span></a> <span class="bnf">::=</span>
    <span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.optConfig"><code class="hover-info"><code class="docstring">Configuration options for tactics. </code></code><span class="from-nonterminal" data-kind="null"><span class="nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code>configItem</span><span class="bnf">*</span></span></span></pre></div>
                </div>
              <div class="namedocs" id="Lean___Parser___Tactic___configItem">
                <span class="label">syntax</span><span class="title">Tactic Configuration Items</span><div class="text">
                  <p>
                    Each configuration item has a name that corresponds to an underlying tactic option.
Boolean options may be enabled or disabled using prefix <code>+</code> and <code>-</code>:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Tactic___configItem-next"><span class="nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code>configItem</span> <span class="bnf">::=</span>
    <span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code><span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.posConfigItem"><code class="hover-info"><code class="docstring">`+opt` is short for `(opt := true)`. It sets the `opt` configuration option to `true`.
</code></code><span class="keyword">+</span><span class="nonterminal" data-kind="ident">ident</span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Tactic___configItem-next-next"><span class="nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code>configItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code><span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.negConfigItem"><code class="hover-info"><code class="docstring">`-opt` is short for `(opt := false)`. It sets the `opt` configuration option to `false`.
</code></code><span class="keyword">-</span><span class="nonterminal" data-kind="ident">ident</span></span></span></pre><p>
                    Options may be assigned specific values using a syntax similar to that for named function arguments:</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Tactic___configItem-next-next-next"><span class="nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code>configItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code><span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.valConfigItem"><code class="hover-info"><code class="docstring">`(opt := val)` sets the `opt` configuration option to `val`.

As a special case, `(config := ...)` sets the entire configuration.
</code></code><span class="keyword">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span><span class="keyword">)</span></span></span></pre><p>
                    Finally, the name <code>config</code> is reserved; it is used to pass an entire set of options as a data structure.
The specific type expected depends on the tactic.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Tactic___configItem-next-next-next-next"><span class="nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code>configItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.configItem"><code class="hover-info"><code class="docstring">A configuration item for a tactic configuration. </code></code><span class="from-nonterminal documented" data-kind="Lean.Parser.Tactic.valConfigItem"><code class="hover-info"><code class="docstring">`(opt := val)` sets the `opt` configuration option to `val`.

As a special case, `(config := ...)` sets the entire configuration.
</code></code><span class="keyword">(</span><span class="literal-ident">config</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span><span class="keyword">)</span></span></span></pre></div>
                </div>
              </section>
            <section>
              <h2 id="tactic-language-namespaces-options">
                13.3.6. Namespace and Option Management<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-namespaces-options" title="Permalink">🔗</a></span></h2>
              <p>
                Namespaces and options can be adjusted in tactic scripts using the same syntax as in terms.</p>
              <div class="namedocs" id="set_option">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.set_option" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#set_option" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2458">set_option</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">opt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">val</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> (the tactic) acts like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">set_option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">opt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">val</span></code> at the command level,
but it sets the option only within the tactics <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="open">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.open" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Tactic-Proofs/The-Tactic-Language/#open" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="2459">open</span></a></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-0" data-verso-hover="2460">open</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Foo</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-0" data-verso-hover="2460">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> (the tactic) acts like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">open</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Foo</span></code> at command level,
but it opens a namespace only within the tactics <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="tactic-language-unfolding">
                  13.3.6.1. Controlling Unfolding<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=tactic-language-unfolding" title="Permalink">🔗</a></span></h3>
                <p>
                  By default, only definitions marked reducible are unfolded, except when checking definitional equality.
These operators allow this default to be adjusted for some part of a tactic script.</p>
                <div class="namedocs" id="with_reducible_and_instances">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.withReducibleAndInstances" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1527">with_reducible_and_instances</span></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_reducible_and_instances</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.instances</span></code> transparency setting.
In this setting only definitions tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> or type class instances are unfolded.</p>
                    </div>
                  </div>
                <div class="namedocs" id="with_reducible">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.withReducible" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1261">with_reducible</span></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_reducible</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the reducible transparency setting.
In this setting only definitions tagged as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">reducible</span><span class="unknown token" data-binding="">]</span></code> are unfolded.</p>
                    </div>
                  </div>
                <div class="namedocs" id="with_unfolding_all">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&amp;name=Lean.Parser.Tactic.withUnfoldingAll" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><span class="keyword token" data-binding="" data-verso-hover="1528">with_unfolding_all</span></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">with_unfolding_all</span><span class="inter-text"> </span><span class="unknown token" data-binding="">tacs</span></code> executes <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">tacs</span></code> using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.all</span></code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p>
                    </div>
                  </div>
                </section>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Tactic-Proofs/Reading-Proof-States/#proof-states" rel="prev" title="13.2. Reading Proof States"><span class="arrow">←</span><span class="where">13.2. Reading Proof States</span></a><a class="local-button active" href="Tactic-Proofs/Options/#tactic-language-options" rel="next" title="13.4. Options"><span class="where">13.4. Options</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

