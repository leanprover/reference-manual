window.docContents[113].resolve({"/Basic-Types/Strings/#string-api-modify":{"contents":"Splits a string at each character for which p returns true.The characters that satisfy p are not included in any of the resulting strings. If multiple\ncharacters in a row satisfy p, then the resulting list will contain empty strings.Examples:* \"coffee tea water\".split (·.isWhitespace) = [\"coffee\", \"tea\", \"water\"]* \"coffee  tea  water\".split (·.isWhitespace) = [\"coffee\", \"\", \"tea\", \"\", \"water\"]* \"fun x =>\\n  x + 1\\n\".split (· == '\\n') = [\"fun x =>\", \"  x + 1\", \"\"]\n\nSplits a string s on occurrences of the separator string sep. The default separator is \" \".When sep is empty, the result is [s]. When sep occurs in overlapping patterns, the first match\nis taken. There will always be exactly n+1 elements in the returned list if there were n\nnon-overlapping matches of sep in the string. The separators are not included in the returned\nsubstrings.Examples:* \"here is some text \".splitOn = [\"here\", \"is\", \"some\", \"text\", \"\"]* \"here is some text \".splitOn \"some\" = [\"here is \", \" text \"]* \"here is some text \".splitOn \"\" = [\"here is some text \"]* \"ababacabac\".splitOn \"aba\" = [\"\", \"bac\", \"c\"]\n\nAdds a character to the end of a string.The internal implementation uses dynamic arrays and will perform destructive updates\nif the string is not shared.Examples:* \"abc\".push 'd' = \"abcd\"* \"\".push 'a' = \"a\"\n\nAdds multiple repetitions of a character to the end of a string.Returns s, with n repetitions of c at the end. Internally, the implementation repeatedly calls\nString.push, so the string is modified in-place if there is a unique reference to it.Examples:* \"indeed\".pushn '!' 2 = \"indeed!!\"* \"indeed\".pushn '!' 0 = \"indeed\"* \"\".pushn ' ' 4 = \"    \"\n\nReplaces the first character in s with the result of applying Char.toUpper to it. Returns the\nempty string if the string is empty.Char.toUpper has no effect on characters outside of the range 'a'–'z'.Examples:* \"orange\".capitalize = \"Orange\"* \"ORANGE\".capitalize = \"ORANGE\"* \"\".capitalize = \"\"\n\nReplaces the first character in s with the result of applying Char.toLower to it. Returns the\nempty string if the string is empty.Char.toLower has no effect on characters outside of the range 'A'–'Z'.Examples:* \"Orange\".decapitalize = \"orange\"* \"ORANGE\".decapitalize = \"oRANGE\"* \"\".decapitalize = \"\"\n\nReplaces each character in s with the result of applying Char.toUpper to it.Char.toUpper has no effect on characters outside of the range 'a'–'z'.Examples:* \"orange\".toUpper = \"ORANGE\"* \"abc123\".toUpper = \"ABC123\"\n\nReplaces each character in s with the result of applying Char.toLower to it.Char.toLower has no effect on characters outside of the range 'A'–'Z'.Examples:* \"ORANGE\".toLower = \"orange\"* \"Orange\".toLower = \"orange\"* \"ABc123\".toLower = \"abc123\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.9. Manipulation","id":"/Basic-Types/Strings/#string-api-modify"},"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Implementation-Notes":{"contents":"The implementation of cutsat is inspired by Section 4 of .\nCompared to the paper, it includes several enhancements and modifications such as:* extended constraint support (equality and disequality),* an optimized encoding of the Cooper-Left rule using a “big”-disjunction instead of fresh variables, and* decision variable tracking for case splits (disequalities, Cooper-Left, Cooper-Right).The cutsat procedure builds a model (that is, an assignment of the variables in the term) incrementally, resolving conflicts through constraint generation.\nFor example, given a partial model {x := 1} and constraint 3 ∣ 3 * y + x + 1:* The solver cannot extend the model to y because 3 ∣ 3 * y + 2 is unsatisfiable.* Thus, it resolves the conflict by generating the implied constraint 3 ∣ x + 1.* The new constraint forces the solver to find a new assignment for x.When assigning a variable y, the solver considers:* The best upper and lower bounds (inequalities).* A divisibility constraint.* All disequality constraints where y is the maximal variable.\n\nThe Cooper-Left and Cooper-Right rules handle the combination of inequalities and divisibility.\nFor unsatisfiable disequalities p ≠ 0, the solver generates the case split: p + 1 ≤ 0 ∨ -p + 1 ≤ 0.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.7. Implementation Notes","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Implementation-Notes"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Minimum-and-Maximum-Values":{"contents":"The classes Max and Min provide overloaded operators for choosing the greater or lesser of two values.\nThese should be in agreement with Ord, LT, and LE instances, if they exist, but there is no mechanism to enforce this.\n\nAn overloaded operation to find the lesser of two values of type α.Returns the lesser of its two arguments.\n\nAn overloaded operation to find the greater of two values of type α.Returns the greater of its two arguments.\n\nGiven an LE α instance for which LE.le is decidable, the helpers minOfLe and maxOfLe can be used to create suitable Min α and Max α instances.\nThey can be used as the right-hand side of an instance declaration.Constructs a Min instance from a decidable ≤ operation.Constructs a Max instance from a decidable ≤ operation.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.3. Minimum and Maximum Values","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Minimum-and-Maximum-Values"}});