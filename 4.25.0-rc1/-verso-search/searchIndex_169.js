window.docContents[169].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Comparisons":{"contents":"Unsigned less-than-or-equal-to for bitvectors.SMT-LIB name: bvule.\n\nSigned less-than-or-equal-to for bitvectors.SMT-LIB name: bvsle.\n\nUnsigned less-than for bitvectors.SMT-LIB name: bvult.\n\nSigned less-than for bitvectors.SMT-LIB name: bvslt.Examples:* BitVec.slt 6#4 7 = true* BitVec.slt 7#4 8 = false\n\nBitvectors have decidable equality.This should be used via the instance DecidableEq (BitVec w).\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"19.5.5.4. Comparisons","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Comparisons"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.\nIf the returned Bool is true, then the returned map is unaltered. If the Bool is false,\nthen the returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the map for which the given function returns false.\n\nUpdates the values of the map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nInserts multiple mappings into the tree map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for TreeMap, DTreeMap, TreeMap.Raw and DTreeMap.Raw.\nThe insertMany function on TreeSet and TreeSet.Raw behaves differently: it will prefer the first\nappearance.\n\nPartitions a tree map into two tree maps based on a predicate.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"19.18.9.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Modification"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-term-helpers":{"contents":"These tactics are used during elaboration of terms to satisfy obligations that arise.\n\nConstructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using ts to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition.\n\nget_elem_tactic is the tactic automatically called by the notation arr[i]\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\nget_elem_tactic_extensible and gives a diagnostic error message otherwise;\nusers are encouraged to extend get_elem_tactic_extensible instead of this tactic.\n\nget_elem_tactic_trivial has been deprecated in favour of get_elem_tactic_extensible.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.20. Term Elaboration Backends","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-term-helpers"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-debug":{"contents":"trace_state prints the current goal state.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.6. Debugging Utilities","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-debug"},"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Discriminant-Refinement":{"contents":"When matching on an indexed family, the indices must also be discriminants.\nOtherwise, the pattern would not be well typed: it is a type error if an index is just a variable but the type of a constructor requires a more specific value.\nHowever, a process called discriminant refinement automatically adds indices as additional discriminants.\n\nDiscriminant RefinementIn the definition of f, the equality proof is the only discriminant.\nHowever, equality is an indexed family, and the match is only valid when n is an additional discriminant.def f (n : Nat) (p : n = 3) : String :=\n  match p with\n  | rfl => \"ok\"\nUsing #print demonstrates that the additional discriminant was added automatically.#print f\ndef f : (n : Nat) → n = 3 → String :=\nfun n p =>\n  match 3, p with\n  | .(n), ⋯ => \"ok\"\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching\u0009Types","header":"10.8.1.3. Discriminant Refinement","id":"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Discriminant-Refinement"}});