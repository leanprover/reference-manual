window.docContents[240].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Creation":{"contents":"Creates a new empty hash map. The optional parameter capacity can be supplied to presize the\nmap so that it can hold the given number of mappings without reallocating. It is also possible to\nuse the empty collection notations ∅ and {} to create an empty hash map with the default\ncapacity.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","header":"19.18.3.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Creation"},"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Case-Distinction":{"contents":"Checks whether a sum is the left injection inl.\n\nChecks whether a sum is the right injection inr.\n\n","context":"Lean Reference\u0009Basic Types\u0009Sum Types\u0009API Reference","header":"19.14.2.1. Case Distinction","id":"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Case-Distinction"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Local-Mutable-State":{"contents":"Local mutable state is mutable state that cannot escape the do block in which it is defined.\nThe let mut binder introduces a locally-mutable binding.\n\nLocal MutabilityMutable bindings may be initialized either with pure computations or with monadic computations:Similarly, they can be mutated either with pure values or the results of monad computations:\n\nThese locally-mutable bindings are less powerful than a state monad because they are not mutable outside their lexical scope; this also makes them easier to reason about.\nWhen do blocks contain mutable bindings, the do elaborator transforms the expression similarly to the way that StateT would, constructing a new monad and initializing it with the correct values.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.3. Local Mutable State","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Local-Mutable-State"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#state-monads":{"contents":"State monads provide access to a mutable value.\nThe underlying implementation may use a tuple to simulate mutability, or it may use something like ST.Ref to ensure mutation.\nEven those implementations that use a tuple may in fact use mutation at run-time due to Lean's use of mutation when there are unique references to values, but this requires a programming style that prefers modify and modifyGet over get and set.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.4. State","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#state-monads"},"/The-Type-System/Quotients/#quotient-intro":{"contents":"The type Quotient expects an instance of Setoid as an ordinary parameter, rather than as an instance implicit parameter.\nThis helps ensure that the quotient uses the intended equivalence relation.\nThe instance can be provided either by naming the instance or by using inferInstance.\n\nA value in the quotient is a value from the setoid's underlying type, wrapped in Quotient.mk.\n\nPlaces an element of a type into the quotient that equates terms according to an equivalence\nrelation.The setoid instance is provided explicitly. Quotient.mk' uses instance synthesis instead.Given v : α, Quotient.mk s v : Quotient s is like v, except all observations of v's value\nmust respect s.r. Quotient.lift allows values in a quotient to be mapped to other types, so long\nas the mapping respects s.r.\n\nPlaces an element of a type into the quotient that equates terms according to an equivalence\nrelation.The equivalence relation is found by synthesizing a Setoid instance. Quotient.mk instead expects\nthe instance to be provided explicitly.Given v : α, Quotient.mk' v : Quotient s is like v, except all observations of v's value\nmust respect s.r. Quotient.lift allows values in a quotient to be mapped to other types, so long\nas the mapping respects s.r.\n\nThe Integers as a Quotient TypeThe integers, defined as pairs of natural numbers where the represented integer is the difference of the two numbers, can be represented via a quotient type.\nThis representation is not unique: both (4, 7) and (1, 4) represent -3.Two encoded integers should be considered equal when they are related by Z.eq:def Z' : Type := Nat × Nat\n\ndef Z.eq (n k : Z') : Prop :=\n  n.1 + k.2 = n.2 + k.1\nThis relation is an equivalence relation:def Z.eq.eqv : Equivalence Z.eq where\n  refl := by\n    intro (x, y)\n    simp +arith [eq]\n  symm := by\n    intro (x, y) (x', y') heq\n    simp_all only [eq]\n    omega\n  trans := by\n    intro (x, y) (x', y') (x'', y'')\n    intro heq1 heq2\n    simp_all only [eq]\n    omega\nThus, it can be used as a Setoid:instance Z.instSetoid : Setoid Z' where\n  r := Z.eq\n  iseqv := Z.eq.eqv\nThe type Z of integers is then the quotient of Z' by the Setoid instance:def Z : Type := Quotient Z.instSetoid\nThe helper Z.mk makes it simpler to create integers without worrying about the choice of Setoid instance:def Z.mk (n : Z') : Z := Quotient.mk _ n\nHowever, numeric literals are even more convenient.\nAn OfNat instance allows numeric literals to be used for integers:instance : OfNat Z n where\n  ofNat := Z.mk (n, 0)\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Quotient API","header":"4.5.4.1. Introducing Quotients","id":"/The-Type-System/Quotients/#quotient-intro"},"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Language-server___-widgets___-and-IDE-extensions":{"contents":"* #4066 fixes features like \"Find References\" when browsing core Lean sources.* #4254 allows embedding user widgets in structured messages.\nCompanion PR is vscode-lean4#449.* #4445 makes watchdog more resilient against badly behaving clients.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.9.0 (2024-07-01)","header":"Language server, widgets, and IDE extensions","id":"/releases/v4.9.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___9___0-_LPAR_2024-07-01_RPAR_--Language-server___-widgets___-and-IDE-extensions"}});