window.docContents[120].resolve({"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Control":{"contents":"Option can be thought of as describing a computation that may fail to return a value.\nThe Monad Option instance, along with Alternative Option, is based on this understanding.\nReturning none can also be thought of as throwing an exception that contains no interesting information, which is captured in the MonadExcept Unit Option instance.\n\nReturns none if a value doesn't satisfy a Boolean predicate, or the value itself otherwise.From the perspective of Option as computations that might fail, this function is a run-time\nassertion operator in the Option monad.Examples:* Option.guard (· > 2) 1 = none* Option.guard (· > 2) 5 = some 5\n\nSequencing of Option computations.From the perspective of Option as computations that might fail, this function sequences\npotentially-failing computations, failing if either fails. From the perspective of Option as a\ncollection with at most one element, the function is applied to the element if present, and the\nfinal result is empty if either the initial or the resulting collections are empty.This function is often accessed via the >>= operator from the Bind (Option α) instance, or\nimplicitly via do-notation, but it is also idiomatic to call it using generalized field\nnotation.Examples:* none.bind (fun x => some x) = none* (some 4).bind (fun x => some x) = some 4* none.bind (Option.guard (· > 2)) = none* (some 2).bind (Option.guard (· > 2)) = none* (some 4).bind (Option.guard (· > 2)) = some 4\n\nRuns the monadic action f on o's value, if any, and returns the result, or  none if there is\nno value.From the perspective of Option as a collection with at most one element, the monadic the function\nis applied to the element if present, and the final result is empty if either the initial or the\nresulting collections are empty.\n\nFlattens nested optional values, preserving any value found.This is analogous to List.flatten.Examples:* none.join = none* (some none).join = none* (some (some v)).join = some v\n\nConverts an optional monadic computation into a monadic computation of an optional value.This function only requires m to be an applicative functor.Example:#eval show IO (Option String) from\n  Option.sequence <| some do\n    IO.println \"hello\"\n    return \"world\"\nhello\nsome \"world\"\n\n\nRecover from failing Option computations with a handler function.This function is usually accessed through the MonadExceptOf Unit Option instance.Examples:* Option.tryCatch none (fun () => some \"handled\") = some \"handled\"* Option.tryCatch (some \"succeeded\") (fun () => some \"handled\") = some \"succeeded\"\n\nReturns the first of its arguments that is some, or none if neither is some.This is similar to the <|> operator, also known as OrElse.orElse, but both arguments are always\nevaluated without short-circuiting.\n\nImplementation of OrElse's <|> syntax for Option. If the first argument is some a, returns\nsome a, otherwise evaluates and returns the second argument.See also or for a version that is strict in the second argument.\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.4. Control","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Control"},"/Basic-Types/Strings/#string-api-valid-pos":{"contents":"A ValidPos s is a byte offset in s together with a proof that this position is at a UTF-8\ncharacter boundary.The underlying byte offset of the ValidPos.The proof that offset is valid for the string s.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.4. Positions","id":"/Basic-Types/Strings/#string-api-valid-pos"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Development-Tools--Language-Server":{"contents":"\n\nRuns the Lean language server in the workspace's root project with the package configuration's moreServerArgs field and args.This command is typically invoked by editors or other tooling, rather than manually.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface\u0009Development Tools","header":"22.1.2.7.3. Language Server","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Development-Tools--Language-Server"},"/The--grind--tactic/Bigger-Examples/#grind-if-then-else-norm":{"contents":"\n\nThis example is a showcase for the “out of the box” power of grind.\nLater examples will explore adding @[grind] annotations as part of the development process, to make grind more effective in a new domain.\nThis example does not rely on any of the algebra extensions to grind, we're just using:\n\n* instantiation of annotated theorems from the library,* congruence closure, and* case splitting.\n\nThe solution here builds on an earlier formalization by Chris Hughes, but with some notable improvements:\n\n* the verification is separate from the code,* the proof is now a one-liner combining fun_induction and grind,* the proof is robust to changes in the code (e.g. swapping out HashMap for TreeMap) as well as changes to the precise verification conditions.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples","header":"17.10.2. if - then - else  Normalization","id":"/The--grind--tactic/Bigger-Examples/#grind-if-then-else-norm"},"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism":{"contents":"Lean supports universe polymorphism,   which means that constants defined in the Lean environment can take universe parameters.\nThese parameters can then be instantiated with universe levels when the constant is used.\nUniverse parameters are written in curly braces following a dot after a constant name.\n\nUniverse-polymorphic identity functionWhen fully explicit, the identity function takes a universe parameter u. Its signature is:id.{u} {α : Sort u} (x : α) : α\n\n\nUniverse variables may additionally occur in universe level expressions, which provide specific universe levels in definitions.\nWhen the polymorphic definition is instantiated with concrete levels, these universe level expressions are also evaluated to yield concrete levels.\n\nUniverse level expressionsIn this example, Codec is in a universe that is one greater than the universe of the type it contains:structure Codec.{u} : Type (u + 1) where\n  type : Type u\n  encode : Array UInt32 → type → Array UInt32\n  decode : Array UInt32 → Nat → Option (type × Nat)\nLean automatically infers most level parameters.\nIn the following example, it is not necessary to annotate the type as Codec.{0}, because Char's type is Type 0, so u must be 0:def Codec.char : Codec where\n  type := Char\n  encode buf ch := buf.push ch.val\n  decode buf i := do\n    let v ← buf[i]?\n    if h : v.isValidChar then\n      let ch : Char := ⟨v, h⟩\n      return (ch, i + 1)\n    else\n      failure\n\n\nUniverse-polymorphic definitions in fact create a schematic definition that can be instantiated at a variety of levels, and different instantiations of universes create incompatible values.\n\nUniverse polymorphism and definitional equalityThis can be seen in the following example, in which T is a gratuitously-universe-polymorphic function that always returns true.\nBecause it is marked opaque, Lean can't check equality by unfolding the definitions.\nBoth instantiations of T have the parameters and the same type, but their differing universe instantiations make them incompatible.opaque T.{u} (_ : Nat) : Bool :=\n  (fun (α : Sort u) => true) PUnit.{u}\n\nset_option pp.universes true\n\ndef test.{u, v} : T.{u} 0 = T.{v} 0 := rfl\nType mismatch\n  rfl.{?u.46}\nhas type\n  Eq.{?u.46} ?m.48 ?m.48\nbut is expected to have type\n  Eq.{1} (T.{u} 0) (T.{v} 0)\n\n\nAuto-bound implicit arguments are as universe-polymorphic as possible.\nDefining the identity function as follows:\n\ndef id' (x : α) := x\n\n\nresults in the signature:\n\nid'.{u} {α : Sort u} (x : α) : α\n\n\nUniverse monomorphism in auto-bound implicit parametersOn the other hand, because Nat is in universe Type 0, this function automatically ends up with a concrete universe level for α, because m is applied to both Nat and α, so both must have the same type and thus be in the same universe:partial def count [Monad m] (p : α → Bool) (act : m α) : m Nat := do\n  if p (← act) then\n    return 1 + (← count p act)\n  else\n    return 0\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Universes","header":"4.3.2. Polymorphism","id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism"}});