window.docContents[116].resolve({"/Basic-Types/Sum-Types/#sum-syntax":{"contents":"The names Sum and PSum are rarely written explicitly.\nMost code uses the corresponding infix operators.\n\n\n\nSum Typesα ⊕ β is notation for Sum α β.\n\n\n\n\n\nPotentially-Propositional Sum Typesα ⊕' β is notation for PSum α β.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Sum Types","header":"19.14.1. Syntax","id":"/Basic-Types/Sum-Types/#sum-syntax"},"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References--State-Transformers--Reading-and-Writing":{"contents":"Reads the value of a mutable reference.\n\nReplaces the value of a mutable reference.\n\nData races with get and setdef main : IO Unit := do\n  let balance ← IO.mkRef (100 : Int)\n\n  let mut orders := #[]\n  IO.println \"Sending out orders...\"\n  for _ in [0:100] do\n    let o ← IO.asTask (prio := .dedicated) do\n      let cost ← IO.rand 1 100\n      IO.sleep (← IO.rand 10 100).toUInt32\n      if cost < (← balance.get) then\n        IO.sleep (← IO.rand 10 100).toUInt32\n        balance.set ((← balance.get) - cost)\n    orders := orders.push o\n\n  -- Wait until all orders are completed\n  for o in orders do\n    match o.get with\n    | .ok () => pure ()\n    | .error e => throw e\n\n  if (← balance.get) < 0 then\n    IO.eprintln \"Final balance is negative!\"\n  else\n    IO.println \"Final balance is zero or positive.\"\nSending out orders...\nFinal balance is negative!\n\n\nAtomically modifies a mutable reference cell by replacing its contents with the result of a function\ncall.\n\nAvoiding data races with modifyThis program launches 100 threads.\nEach thread simulates a purchase attempt: it generates a random price, and if the account balance is sufficient, it decrements it by the price.\nThe balance check and the computation of the new value occur in an atomic call to ST.Ref.modify.def main : IO Unit := do\n  let balance ← IO.mkRef (100 : Int)\n\n  let mut orders := #[]\n  IO.println \"Sending out orders...\"\n  for _ in [0:100] do\n    let o ← IO.asTask (prio := .dedicated) do\n      let cost ← IO.rand 1 100\n      IO.sleep (← IO.rand 10 100).toUInt32\n      balance.modify fun b =>\n        if cost < b then\n          b - cost\n        else b\n    orders := orders.push o\n\n  -- Wait until all orders are completed\n  for o in orders do\n    match o.get with\n    | .ok () => pure ()\n    | .error e => throw e\n\n  if (← balance.get) < 0 then\n    IO.eprintln \"Final balance negative!\"\n  else\n    IO.println \"Final balance is zero or positive.\"\nSending out orders...\nFinal balance is zero or positive.\n\n\n\nAtomically modifies a mutable reference cell by replacing its contents with the result of a function\ncall that simultaneously computes a value to return.\n\nAtomically swaps the value of a mutable reference cell with another value. The reference cell's\noriginal value is returned.\n\n","context":"Lean Reference\u0009IO\u0009Mutable References\u0009State Transformers","header":"15.4.1.1. Reading and Writing","id":"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References--State-Transformers--Reading-and-Writing"},"/Interacting-with-Lean/#format-empty":{"contents":"The empty string does not have a single unique representative in Std.Format.\nAll of the following represent the empty string:* .nil* .text \"\"* .text \"\" ++ .nil* .nil ++ .text \"\"Use Std.Format.isEmpty to check whether a document contains zero characters, and Std.Format.isNil to specifically check whether it is the constructor Std.Format.nil.\n\nChecks whether the given format contains no characters.\n\nChecks whether a Format is the constructor Format.nil.This does not check whether the resulting rendered strings are always empty. To do that, use\nFormat.isEmpty.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.2. Empty Documents","id":"/Interacting-with-Lean/#format-empty"}});