window.docContents[139].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Modification":{"contents":"Adds an element to the end of an array. The resulting array's size is one greater than the input\narray. If there are no other references to the array, then it is modified in-place.This takes amortized O(1) time because Array α is represented by a dynamic array.Examples:* #[].push \"apple\" = #[\"apple\"]* #[\"apple\"].push \"orange\" = #[\"apple\", \"orange\"]\n\nRemoves the last element of an array. If the array is empty, then it is returned unmodified. The\nmodification is performed in-place when the reference to the array is unique.Examples:* #[1, 2, 3].pop = #[1, 2]* #[\"orange\", \"yellow\"].pop = #[\"orange\"]* (#[] : Array String).pop = #[]\n\nRemoves all the elements that satisfy a predicate from the end of an array.The longest contiguous sequence of elements that all satisfy the predicate is removed.Examples:* #[0, 1, 2, 3, 4].popWhile (· > 2) = #[0, 1, 2]* #[3, 2, 3, 4].popWhile (· > 2) = #[3, 2]* (#[] : Array Nat).popWhile (· > 2) = #[]\n\nRemoves the first occurrence of a specified element from an array, or does nothing if it is not\npresent.This function takes worst-case O(n) time because it back-shifts all later elements.Examples:* #[1, 2, 3].erase 2 = #[1, 3]* #[1, 2, 3].erase 5 = #[1, 2, 3]* #[1, 2, 3, 2, 1].erase 2 = #[1, 3, 2, 1]* (#[] : List Nat).erase 2 = #[]\n\nRemoves the first element that satisfies the predicate p. If no element satisfies p, the array\nis returned unmodified.This function takes worst-case O(n) time because it back-shifts all later elements.Examples:* #[\"red\", \"green\", \"\", \"blue\"].eraseP (·.isEmpty) = #[\"red\", \"green\", \"blue\"]* #[\"red\", \"green\", \"\", \"blue\", \"\"].eraseP (·.isEmpty) = #[\"red\", \"green\", \"blue\", \"\"]* #[\"red\", \"green\", \"blue\"].eraseP (·.length % 2 == 0) = #[\"red\", \"green\"]* #[\"red\", \"green\", \"blue\"].eraseP (fun _ => true) = #[\"green\", \"blue\"]* (#[] : Array String).eraseP (fun _ => true) = #[]\n\nRemoves the element at a given index from an array without a run-time bounds check.This function takes worst-case O(n) time because it back-shifts all elements at positions\ngreater than i.Examples:* #[\"apple\", \"pear\", \"orange\"].eraseIdx 0 = #[\"pear\", \"orange\"]* #[\"apple\", \"pear\", \"orange\"].eraseIdx 1 = #[\"apple\", \"orange\"]* #[\"apple\", \"pear\", \"orange\"].eraseIdx 2 = #[\"apple\", \"pear\"]\n\nRemoves the element at a given index from an array. Panics if the index is out of bounds.This function takes worst-case O(n) time because it back-shifts all elements at positions\ngreater than i.\n\nRemoves the element at a given index from an array. Does nothing if the index is out of bounds.This function takes worst-case O(n) time because it back-shifts all elements at positions greater\nthan i.Examples:* #[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 0 = #[\"pear\", \"orange\"]* #[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 1 = #[\"apple\", \"orange\"]* #[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 2 = #[\"apple\", \"pear\"]* #[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 3 = #[\"apple\", \"pear\", \"orange\"]* #[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 5 = #[\"apple\", \"pear\", \"orange\"]\n\nErases repeated elements, keeping the first element of each run.O(|as|).Example:* #[1, 3, 2, 2, 2, 3, 3, 5].eraseReps = #[1, 3, 2, 3, 5]\n\nSwaps two elements of an array. The modification is performed in-place when the reference to the\narray is unique.Examples:* #[\"red\", \"green\", \"blue\", \"brown\"].swap 0 3 = #[\"brown\", \"green\", \"blue\", \"red\"]* #[\"red\", \"green\", \"blue\", \"brown\"].swap 0 2 = #[\"blue\", \"green\", \"red\", \"brown\"]* #[\"red\", \"green\", \"blue\", \"brown\"].swap 1 2 = #[\"red\", \"blue\", \"green\", \"brown\"]* #[\"red\", \"green\", \"blue\", \"brown\"].swap 3 0 = #[\"brown\", \"green\", \"blue\", \"red\"]\n\nSwaps two elements of an array, returning the array unchanged if either index is out of bounds. The\nmodification is performed in-place when the reference to the array is unique.Examples:* #[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 3 = #[\"brown\", \"green\", \"blue\", \"red\"]* #[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 2 = #[\"blue\", \"green\", \"red\", \"brown\"]* #[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 1 2 = #[\"red\", \"blue\", \"green\", \"brown\"]* #[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 4 = #[\"red\", \"green\", \"blue\", \"brown\"]* #[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 9 2 = #[\"red\", \"green\", \"blue\", \"brown\"]\n\nSwaps a new element with the element at the given index.Returns the value formerly found at i, paired with an array in which the value at i has been\nreplaced with v.Examples:* #[\"spinach\", \"broccoli\", \"carrot\"].swapAt 1 \"pepper\" = (\"broccoli\", #[\"spinach\", \"pepper\", \"carrot\"])* #[\"spinach\", \"broccoli\", \"carrot\"].swapAt 2 \"pepper\" = (\"carrot\", #[\"spinach\", \"broccoli\", \"pepper\"])\n\nSwaps a new element with the element at the given index. Panics if the index is out of bounds.Returns the value formerly found at i, paired with an array in which the value at i has been\nreplaced with v.Examples:* #[\"spinach\", \"broccoli\", \"carrot\"].swapAt! 1 \"pepper\" = (#[\"spinach\", \"pepper\", \"carrot\"], \"broccoli\")* #[\"spinach\", \"broccoli\", \"carrot\"].swapAt! 2 \"pepper\" = (#[\"spinach\", \"broccoli\", \"pepper\"], \"carrot\")\n\nReplaces the first occurrence of a with b in an array. The modification is performed in-place\nwhen the reference to the array is unique. Returns the array unmodified when a is not present.Examples:* #[1, 2, 3, 2, 1].replace 2 5 = #[1, 5, 3, 2, 1]* #[1, 2, 3, 2, 1].replace 0 5 = #[1, 2, 3, 2, 1]* #[].replace 2 5 = #[]\n\nReplaces the element at a given index in an array.No bounds check is performed, but the function requires a proof that the index is in bounds. This\nproof can usually be omitted, and will be synthesized automatically.The array is modified in-place if there are no other references to it.Examples:* #[0, 1, 2].set 1 5 = #[0, 5, 2]* #[\"orange\", \"apple\"].set 1 \"grape\" = #[\"orange\", \"grape\"]\n\nSet an element in an array, or panic if the index is out of bounds.This will perform the update destructively provided that a has a reference\ncount of 1 when called.\n\nReplaces the element at the provided index in an array. The array is returned unmodified if the\nindex is out of bounds.The array is modified in-place if there are no other references to it.Examples:* #[0, 1, 2].setIfInBounds 1 5 = #[0, 5, 2]* #[\"orange\", \"apple\"].setIfInBounds 1 \"grape\" = #[\"orange\", \"grape\"]* #[\"orange\", \"apple\"].setIfInBounds 5 \"grape\" = #[\"orange\", \"apple\"]\n\nLow-level modification operator which is as fast as a C array write. The modification is performed\nin-place when the reference to the array is unique.This avoids overhead due to unboxing a Nat used as an index.\n\nReplaces the element at the given index, if it exists, with the result of applying f to it. If the\nindex is invalid, the array is returned unmodified.Examples:* #[1, 2, 3].modify 0 (· * 10) = #[10, 2, 3]* #[1, 2, 3].modify 2 (· * 10) = #[1, 2, 30]* #[1, 2, 3].modify 3 (· * 10) = #[1, 2, 3]\n\nReplaces the element at the given index, if it exists, with the result of applying the monadic\nfunction f to it. If the index is invalid, the array is returned unmodified and f is not called.Examples:#eval #[1, 2, 3, 4].modifyM 2 fun x => do\n  IO.println s!\"It was {x}\"\n  return x * 10\nIt was 3\n#[1, 2, 30, 4]\n#eval #[1, 2, 3, 4].modifyM 6 fun x => do\n  IO.println s!\"It was {x}\"\n  return x * 10\n#[1, 2, 3, 4]\n\n\nReplaces the element at the given index, if it exists, with the result of applying f to it. If the\nindex is invalid, the array is returned unmodified.Examples:* #[1, 2, 3].modifyOp 0 (· * 10) = #[10, 2, 3]* #[1, 2, 3].modifyOp 2 (· * 10) = #[1, 2, 30]* #[1, 2, 3].modifyOp 3 (· * 10) = #[1, 2, 3]\n\nInserts an element into an array at the specified index. If the index is greater than the size of\nthe array, then the array is returned unmodified.In other words, the new element is inserted into the array as after the first i elements of\nas.This function takes worst case O(n) time because it has to swap the inserted element into place.Examples:* #[\"tues\", \"thur\", \"sat\"].insertIdx 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]* #[\"tues\", \"thur\", \"sat\"].insertIdx 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]* #[\"tues\", \"thur\", \"sat\"].insertIdx 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]\n\nInserts an element into an array at the specified index. Panics if the index is greater than the\nsize of the array.In other words, the new element is inserted into the array as after the first i elements of\nas.This function takes worst case O(n) time because it has to swap the inserted element into place.\nArray.insertIdx and Array.insertIdxIfInBounds are safer alternatives.Examples:* #[\"tues\", \"thur\", \"sat\"].insertIdx! 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]* #[\"tues\", \"thur\", \"sat\"].insertIdx! 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]* #[\"tues\", \"thur\", \"sat\"].insertIdx! 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]\n\nInserts an element into an array at the specified index. The array is returned unmodified if the\nindex is greater than the size of the array.In other words, the new element is inserted into the array as after the first i elements of\nas.This function takes worst case O(n) time because it has to swap the inserted element into place.Examples:* #[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]* #[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]* #[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]* #[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 4 \"wed\" = #[\"tues\", \"thur\", \"sat\"]\n\nReverses an array by repeatedly swapping elements.The original array is modified in place if there are no other references to it.Examples:* (#[] : Array Nat).reverse = #[]* #[0, 1].reverse = #[1, 0]* #[0, 1, 2].reverse = #[2, 1, 0]\n\nReturns a new array that contains the first i elements of xs. If xs has fewer than i\nelements, the new array contains all the elements of xs.The returned array is always a new array, even if it contains the same elements as the input array.Examples:* #[\"red\", \"green\", \"blue\"].take 1 = #[\"red\"]* #[\"red\", \"green\", \"blue\"].take 2 = #[\"red\", \"green\"]* #[\"red\", \"green\", \"blue\"].take 5 = #[\"red\", \"green\", \"blue\"]\n\nReturns a new array that contains the longest prefix of elements that satisfy the predicate p from\nan array.Examples:* #[0, 1, 2, 3, 2, 1].takeWhile (· < 2) = #[0, 1]* #[0, 1, 2, 3, 2, 1].takeWhile (· < 20) = #[0, 1, 2, 3, 2, 1]* #[0, 1, 2, 3, 2, 1].takeWhile (· < 0) = #[]\n\nRemoves the first i elements of xs. If xs has fewer than i elements, the new array is empty.The returned array is always a new array, even if it contains the same elements as the input array.Examples:* #[\"red\", \"green\", \"blue\"].drop 1 = #[\"green\", \"blue\"]* #[\"red\", \"green\", \"blue\"].drop 2 = #[\"blue\"]* #[\"red\", \"green\", \"blue\"].drop 5 = #[]\n\nReturns the first n elements of an array. The resulting array is produced by repeatedly calling\nArray.pop. If n is greater than the size of the array, it is returned unmodified.If the reference to the array is unique, then this function uses in-place modification.Examples:* #[0, 1, 2, 3, 4].shrink 2 = #[0, 1]* #[0, 1, 2, 3, 4].shrink 0 = #[]* #[0, 1, 2, 3, 4].shrink 10 = #[0, 1, 2, 3, 4]\n\nAppends the contents of array of arrays into a single array. The resulting array contains the same\nelements as the nested arrays in the same order.Examples:* #[#[5], #[4], #[3, 2]].flatten = #[5, 4, 3, 2]* #[#[0, 1], #[], #[2], #[1, 0, 1]].flatten = #[0, 1, 2, 1, 0, 1]* (#[] : Array Nat).flatten = #[]\n\nReturns a new array that contains the elements at even indices in as, starting with the element at\nindex 0.Examples:* #[0, 1, 2, 3, 4].getEvenElems = #[0, 2, 4]* #[1, 2, 3, 4].getEvenElems = #[1, 3]* #[\"red\", \"green\", \"blue\"].getEvenElems = #[\"red\", \"blue\"]* (#[] : Array String).getEvenElems = #[]\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.6. Modification","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Modification"},"/Error-Explanations/lean___projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--lean___projNonPropFromProp":{"contents":"\n\nThis error occurs when attempting to project a piece of data from a proof of a proposition using an\nindex projection. For example, if h is a proof of an existential proposition, attempting to\nextract the witness h.1 is an example of this error. Such projections are disallowed because they\nmay violate Lean's prohibition of large elimination from Prop (refer to the\nPropositions manual section for further details).\n\nInstead of an index projection, consider using a pattern-matching let, match expression, or a\ndestructuring tactic like cases to eliminate from one propositional type to another. Note that\nsuch elimination is only valid if the resulting value is also in Prop; if it is not, the error\nlean.propRecLargeElim will be raised.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.projNonPropFromProp","id":"/Error-Explanations/lean___projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--lean___projNonPropFromProp"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Channels":{"contents":"The types and functions in this section are available after importing Std.Sync.Channel.\n\nA multi-producer multi-consumer FIFO channel that offers both bounded and unbounded buffering\nand an asynchronous API. To switch into synchronous mode use Channel.sync.If a channel needs to be closed to indicate some sort of completion event use Std.CloseableChannel\ninstead. Note that Std.CloseableChannel introduces a need for error handling in some cases, thus\nStd.Channel is usually easier to use if applicable.\n\nCreate a new channel. If:* capacity is none it will be unbounded (the default)* capacity is some 0 it will always force a rendezvous between sender and receiver* capacity is some n with n > 0 it will use a buffer of size n and begin blocking once it\nis filled\n\nSend a value through the channel, returning a task that will resolve once the transmission could be\ncompleted.\n\nReceive a value from the channel, returning a task that will resolve once the transmission could be\ncompleted. Note that the task may resolve to none if the channel was closed before it could be\ncompleted.\n\nch.forAsync f calls f for every message received on ch.Note that if this function is called twice, each message will only arrive at exactly one invocation.\n\nThis function is a no-op and just a convenient way to expose the synchronous API of the channel.\n\nA multi-producer multi-consumer FIFO channel that offers both bounded and unbounded buffering\nand a synchronous API. This type acts as a convenient layer to use a channel in a blocking fashion\nand is not actually different from the original channel.If a channel needs to be closed to indicate some sort of completion event use\nStd.CloseableChannel.Sync instead. Note that Std.CloseableChannel.Sync introduces a need for error\nhandling in some cases, thus Std.Channel.Sync is usually easier to use if applicable.\n\nA multi-producer multi-consumer FIFO channel that offers both bounded and unbounded buffering\nand an asynchronous API, to switch into synchronous mode use CloseableChannel.sync.Additionally Std.CloseableChannel can be closed if necessary, unlike Std.Channel.\nThis introduces a need for error handling in some cases, thus it is usually easier to use\nStd.Channel if applicable.\n\nCreate a new channel. If:* capacity is none it will be unbounded (the default)* capacity is some 0 it will always force a rendezvous between sender and receiver* capacity is some n with n > 0 it will use a buffer of size n and begin blocking once it\nis filled\n\nSynchronous channels can also be read using for loops.\nIn particular, there is an instance of type ForIn m (Std.Channel.Sync α) α for every monad m with a MonadLiftT BaseIO m instance and α with an Inhabited α instance.\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads\u0009Communication Between Tasks","header":"15.11.6.1. Channels","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Channels"},"/Source-Files-and-Modules/#files":{"contents":"The smallest unit of compilation in Lean is a single module.\nModules correspond to source files, and are imported into other modules based on their filenames.\nIn other words, the names and folder structures of files are significant in Lean code.\n\nEvery Lean file defines a module.\nA module's name is derived from a combination of its filename and the way in which Lean was invoked: Lean has a root directory in which it expects to find code, and the module's name is the names of the directories from the root to the filename, with dots (.) interspersed and .lean removed.\nFor example, if Lean is invoked with Projects/MyLib/src as its root, the file Projects/MyLib/src/Literature/Novel/SciFi.lean would contain a module named Literature.Novel.SciFi.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"5. Source Files and Modules","id":"/Source-Files-and-Modules/#files"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-rw":{"contents":"change t' replaces the target t with t',\nassuming t and t' are definitionally equal.\n\nrw [thm] rewrites the target using thm. See the rw tactic for more information.\n\nrw [rules] applies the given list of rewrite rules to the target.\nSee the rw tactic for more information.\n\nerw [rules] is a shorthand for rw (transparency := .default) [rules].\nThis does rewriting up to unfolding of regular definitions (by comparison to regular rw\nwhich only unfolds @[reducible] definitions).\n\nThe apply thm conv tactic is the same as apply thm the tactic.\nThere are no restrictions on thm, but strange results may occur if thm\ncannot be reasonably interpreted as proving one equality from a list of others.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv\u0009Changing the Goal","header":"13.6.4.3. Rewriting","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-rw"},"/Type-Classes/Instance-Declarations/#class-inductive-instances":{"contents":"Many instances have function types: any instance that itself recursively invokes instance search is a function, as is any instance with implicit parameters.\nWhile most instances only project method implementations from their own instance parameters, instances of class inductive types typically pattern-match one or more of their arguments, allowing the instance to select the appropriate constructor.\nThis is done using ordinary Lean function syntax.\nJust as with other instances, the function in question is not available for instance synthesis in its own definition.\n\nAn instance for a sum classBecause DecidableEq α is an abbreviation for (a b : α) → Decidable (Eq a b), its arguments can be used directly, as in this example:inductive ThreeChoices where\n  | yes | no | maybe\n\ninstance : DecidableEq ThreeChoices\n  | .yes,   .yes   =>\n    .isTrue rfl\n  | .no,    .no    =>\n    .isTrue rfl\n  | .maybe, .maybe =>\n    .isTrue rfl\n  | .yes,   .maybe | .yes,   .no\n  | .maybe, .yes   | .maybe, .no\n  | .no,    .yes   | .no,    .maybe =>\n    .isFalse nofun\n\n\n\nA recursive instance for a sum classThe type StringList represents monomorphic lists of strings:inductive StringList where\n  | nil\n  | cons (hd : String) (tl : StringList)\nIn the following attempt at defining a DecidableEq instance, instance synthesis invoked while elaborating the inner if fails because the instance is not available for instance synthesis in its own definition:instance : DecidableEq StringList\n  | .nil, .nil => .isTrue rfl\n  | .cons h1 t1, .cons h2 t2 =>\n    if h : h1 = h2 then\n      if h' : t1 = t2 then\n        .isTrue (by simp [*])\n      else\n        .isFalse (by intro hEq; cases hEq; trivial)\n    else\n      .isFalse (by intro hEq; cases hEq; trivial)\n  | .nil, .cons _ _ | .cons _ _, .nil => .isFalse nofun\nfailed to synthesize\n  Decidable (t1 = t2)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nHowever, because it is an ordinary Lean function, it can recursively refer to its own explicitly-provided name:instance instDecidableEqStringList : DecidableEq StringList\n  | .nil, .nil => .isTrue rfl\n  | .cons h1 t1, .cons h2 t2 =>\n    let _ : Decidable (t1 = t2) :=\n      instDecidableEqStringList t1 t2\n    if h : h1 = h2 then\n      if h' : t1 = t2 then\n        .isTrue (by simp [*])\n      else\n        .isFalse (by intro hEq; cases hEq; trivial)\n    else\n      .isFalse (by intro hEq; cases hEq; trivial)\n  | .nil, .cons _ _ | .cons _ _, .nil => .isFalse nofun\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Declarations","header":"11.2.2. Instances of  class inductive s","id":"/Type-Classes/Instance-Declarations/#class-inductive-instances"}});