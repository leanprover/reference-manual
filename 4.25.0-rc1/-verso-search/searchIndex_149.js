window.docContents[149].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--In-Strings":{"contents":"The start position of s, as an s.ValidPos.\n\nThe past-the-end position of s, as an s.ValidPos.\n\nConstructs a valid position on s from a position and a proof that it is valid.\n\nConstructs a valid position on s from a position, returning none if the position is not valid.\n\nConstructs a valid position s from a position, panicking if the position is not valid.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Positions","header":"19.8.4.4.1. In Strings","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--In-Strings"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-toolchain-config":{"contents":"Elan associates toolchains with directories, and uses the toolchain of the most recent parent directory of the current working directory that has a configured toolchain.\nA directory's toolchain may result from a toolchain file or from an override configured with elan override.\n\nThe current toolchain is determined by first searching for a configured toolchain for the current directory, walking up through parent directories until a toolchain version is found or there are no more parents.\nA directory has a configured toolchain if there is a configured toolchain override for the directory or if it contains a lean-toolchain file.\nMore recent parents take precedence over their ancestors, and if a directory has both an override and a toolchain file, then the override takes precedence.\nIf no directory toolchain is found, then Elan's configured default toolchain is used as a fallback.\n\nThe most common way to configure a Lean toolchain is with a toolchain file.\nThe toolchain file is a text file named lean-toolchain that contains a single line with a valid toolchain identifier.\nThis file is typically located in the root directory of a project and checked in to version control with the code, ensuring that everyone working on the project uses the same version.\nUpdating to a new Lean toolchain requires only editing this file, and the new version is automatically downloaded and run the next time a Lean file is opened or built.\n\nIn certain advanced use cases where more flexibility is required, a toolchain override can be configured.\nLike toolchain files, overrides associate a toolchain version with a directory and its children.\nUnlike toolchain files, overrides are stored in Elan's configuration rather than in a local file.\nThey are typically used when a specific local configuration is required that does not make sense for other developers, such as testing a project with a locally-built Lean compiler.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Selecting Toolchains","header":"22.2.1.2. Determining the Current Toolchain","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-toolchain-config"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-local-defs":{"contents":"have and let both create local assumptions.\nGenerally speaking, have should be used when proving an intermediate lemma; let should be reserved for local definitions.\n\nThe have tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the let tactic.* have h : t := e adds the hypothesis h : t if e is a term of type t.* have h := e uses the type of e for t.* have : t := e and have := e use this for the name of the hypothesis.* have pat := e for a pattern pat is equivalent to match e with | pat => _,\nwhere _ stands for the tactics that follow this one.\nIt is convenient for types that have only one applicable constructor.\nFor example, given h : p ∧ q ∧ r, have ⟨h₁, h₂, h₃⟩ := h produces the\nhypotheses h₁ : p, h₂ : q, and h₃ : r.* The syntax have (eq := h) pat := e is equivalent to match h : e with | pat => _,\nwhich adds the equation h : e = pat to the local context.The tactic supports all the same syntax variants and options as the have term.Properties and relations* It is not possible to unfold a variable introduced using have, since the definition's value is forgotten.\nThe let tactic introduces definitions that can be unfolded.* The have h : t := e is like doing let h : t := e; clear_value h.* The have tactic is preferred for propositions, and let is preferred for non-propositions.* Sometimes have is used for non-propositions to ensure that the variable is never unfolded,\nwhich may be important for performance reasons.\nConsider using the equivalent let +nondep to indicate the intent.\n\nThe have tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the let tactic.* have h : t := e adds the hypothesis h : t if e is a term of type t.* have h := e uses the type of e for t.* have : t := e and have := e use this for the name of the hypothesis.* have pat := e for a pattern pat is equivalent to match e with | pat => _,\nwhere _ stands for the tactics that follow this one.\nIt is convenient for types that have only one applicable constructor.\nFor example, given h : p ∧ q ∧ r, have ⟨h₁, h₂, h₃⟩ := h produces the\nhypotheses h₁ : p, h₂ : q, and h₃ : r.* The syntax have (eq := h) pat := e is equivalent to match h : e with | pat => _,\nwhich adds the equation h : e = pat to the local context.The tactic supports all the same syntax variants and options as the have term.Properties and relations* It is not possible to unfold a variable introduced using have, since the definition's value is forgotten.\nThe let tactic introduces definitions that can be unfolded.* The have h : t := e is like doing let h : t := e; clear_value h.* The have tactic is preferred for propositions, and let is preferred for non-propositions.* Sometimes have is used for non-propositions to ensure that the variable is never unfolded,\nwhich may be important for performance reasons.\nConsider using the equivalent let +nondep to indicate the intent.\n\nSimilar to have, but using refine'\n\nThe let tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by have.* let x : t := e adds the definition x : t := e if e is a term of type t.* let x := e uses the type of e for t.* let : t := e and let := e use this for the name of the hypothesis.* let pat := e for a pattern pat is equivalent to match e with | pat => _,\nwhere _ stands for the tactics that follow this one.\nIt is convenient for types that let only one applicable constructor.\nFor example, given p : α × β × γ, let ⟨x, y, z⟩ := p produces the\nlocal variables x : α, y : β, and z : γ.* The syntax let (eq := h) pat := e is equivalent to match h : e with | pat => _,\nwhich adds the equation h : e = pat to the local context.The tactic supports all the same syntax variants and options as the let term.Properties and relations* Unlike have, it is possible to unfold definitions introduced using let, using tactics\nsuch as simp, dsimp, unfold, and subst.* The clear_value tactic turns a let definition into a have definition after the fact.\nThe tactic might fail if the local context depends on the value of the variable.* The let tactic is preferred for data (non-propositions).* Sometimes have is used for non-propositions to ensure that the variable is never unfolded,\nwhich may be important for performance reasons.\n\nlet rec f : t := e adds a recursive definition f to the current goal.\nThe syntax is the same as term-mode let rec.\n\nletI behaves like let, but inlines the value instead of producing a let term.\n\nSimilar to let, but using refine'\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","header":"13.3.4. Local Definitions and Proofs","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-local-defs"}});