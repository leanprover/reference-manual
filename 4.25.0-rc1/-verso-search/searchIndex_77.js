window.docContents[77].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Sizes":{"contents":"Each fixed-width integer has a size, which is the number of distinct values that can be represented by the type.\nThis is not equivalent to C's sizeof operator, which instead determines how many bytes the type occupies.\n\nThe number of distinct values representable by USize, that is, 2^System.Platform.numBits.\n\nThe number of distinct values representable by ISize, that is, 2^System.Platform.numBits.\n\nThe number of distinct values representable by UInt8, that is, 2^8 = 256.\n\nThe number of distinct values representable by Int8, that is, 2^8 = 256.\n\nThe number of distinct values representable by UInt16, that is, 2^16 = 65536.\n\nThe number of distinct values representable by Int16, that is, 2^16 = 65536.\n\nThe number of distinct values representable by UInt32, that is, 2^32 = 4294967296.\n\nThe number of distinct values representable by Int32, that is, 2^32 = 4294967296.\n\nThe number of distinct values representable by UInt64, that is, 2^64 = 18446744073709551616.\n\nThe number of distinct values representable by Int64, that is, 2^64 = 18446744073709551616.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference","header":"19.4.4.1. Sizes","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Sizes"},"/Basic-Types/Maps-and-Sets/#TreeSet":{"contents":"Tree sets.A tree set stores elements of a certain type in a certain order. It depends on a comparator function\nthat defines an ordering on the keys and provides efficient order-dependent queries, such as\nretrieval of the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one of them\nbe contained in a single tree set at the same time.To avoid expensive copies, users should make sure that the tree set is used linearly.Internally, the tree sets are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.For use in proofs, the type Std.ExtTreeSet of extensional tree sets should be preferred. This\ntype comes with several extensionality lemmas and provides the same functions but requires a\nTransCmp instance to work with.These tree sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.TreeSet.Raw and\nStd.TreeSet.Raw.WF unbundle the invariant from the tree set. When in doubt, prefer\nTreeSet over TreeSet.Raw.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.18.10. Tree-Based Sets","id":"/Basic-Types/Maps-and-Sets/#TreeSet"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Extracting-Values":{"contents":"Extracts the value from an option that can be proven to be some.\n\nExtracts the value from an Option, panicking on none.\n\nGets an optional value, returning a given default on none.This function is @[macro_inline], so dflt will not be evaluated unless opt turns out to be\nnone.Examples:* (some \"hello\").getD \"goodbye\" = \"hello\"* none.getD \"goodbye\" = \"goodbye\"\n\nGets the value in an option, monadically computing a default value on none.This is the monadic analogue of Option.getD.\n\nLifts an optional value to any Alternative, sending none to failure.\n\nA case analysis function for Option.Given a value for none and a function to apply to the contents of some, Option.elim checks\nwhich constructor a given Option consists of, and uses the appropriate argument.Option.elim is an elimination principle for Option. In particular, it is a non-dependent version\nof Option.recOn. It can also be seen as a combination of Option.map and Option.getD.Examples:* (some \"hello\").elim 0 String.length = 5* none.elim 0 String.length = 0\n\nA monadic case analysis function for Option.Given a fallback computation for none and a monadic operation to apply to the contents of some,\nOption.elimM checks which constructor a given Option consists of, and uses the appropriate\nargument.Option.elimM can also be seen as a combination of Option.mapM and Option.getDM. It is a\nmonadic analogue of Option.elim.\n\nApplies a function to a two optional values if both are present. Otherwise, if one value is present,\nit is returned and the function is not used.The value is some (fn a b) if the inputs are some a and some b. Otherwise, the behavior is\nequivalent to Option.orElse: if only one input is some x, then the value is some x, and if\nboth are none, then the value is none.Examples:* Option.merge (· + ·) none (some 3) = some 3* Option.merge (· + ·) (some 2) (some 3) = some 5* Option.merge (· + ·) (some 2) none = some 2* Option.merge (· + ·) none none = none\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.1. Extracting Values","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Extracting-Values"},"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-ToInt":{"contents":"The cutsat solver can also process linear constraints that contain natural numbers.\nIt converts them into integer constraints using Int.ofNat.\n\nNatural Numbers with cutsatexample (x y z : Nat) :\n    x < y + z →\n    y + 1 < z →\n    z + x < 3 * z := by\n  grind\n\n\nThere is an extensible mechanism via the Lean.Grind.ToInt type class to tell cutsat that a type embeds in the integers.\nUsing this, we can solve goals such as:\n\nexample (a b c : Fin 11) : a ≤ 2 → b ≤ 3 → c = a + b → c ≤ 5 := by\n  grind\n\nexample (a : Fin 2) : a ≠ 0 → a ≠ 1 → False := by\n  grind\n\nexample (a b c : UInt64) : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n\n\nToInt α I asserts that α can be embedded faithfully into an interval I in the integers.The embedding function.The embedding function is injective.The embedding function lands in the interval.\n\nAn interval in the integers (either finite, half-infinite, or infinite).The finite interval [lo, hi).The half-infinite interval [lo, ∞).The half-infinite interval (-∞, hi).The infinite interval (-∞, ∞).\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.6. Other Types","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#cutsat-ToInt"}});