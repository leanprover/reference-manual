window.docContents[25].resolve({"/Tactic-Proofs/Tactic-Reference/#tactic-ref-sat":{"contents":"Close fixed-width BitVec and Bool goals by obtaining a proof from an external SAT solver and\nverifying it inside Lean. The solvable goals are currently limited to* the Lean equivalent of QF_BV* automatically splitting up structures that contain information about BitVec or Boolexample : ∀ (a b : BitVec 64), (a &&& b) + (a ^^^ b) = a ||| b := by\n  intros\n  bv_decide\nIf bv_decide encounters an unknown definition it will be treated like an unconstrained BitVec\nvariable. Sometimes this enables solving goals despite not understanding the definition because\nthe precise properties of the definition do not matter in the specific proof.If bv_decide fails to close a goal it provides a counter-example, containing assignments for all\nterms that were considered as variables.In order to avoid calling a SAT solver every time, the proof can be cached with bv_decide?.If solving your problem relies inherently on using associativity or commutativity, consider enabling\nthe bv.ac_nf option.Note: bv_decide uses ofReduceBool and thus trusts the correctness of the code generator.Note: include import Std.Tactic.BVDecide\n\nRun the normalization procedure of bv_decide only. Sometimes this is enough to solve basic\nBitVec goals already.Note: include import Std.Tactic.BVDecide\n\nThis tactic works just like bv_decide but skips calling a SAT solver by using a proof that is\nalready stored on disk. It is called with the name of an LRAT file in the same directory as the\ncurrent Lean file:bv_check \"proof.lrat\"\n\n\nSuggest a proof script for a bv_decide tactic call. Useful for caching LRAT proofs.Note: include import Std.Tactic.BVDecide\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Decision Procedures","header":"13.5.17.1. SAT Solver Integration","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-sat"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-focusing":{"contents":"Focusing tactics remove some subset of the proof goals (typically leaving only the main goal) from the consideration of some further tactics.\nIn addition to the tactics described here, the case and case' tactics focus on the selected goal.\n\n· tac focuses on the main goal and tries to solve it using tac, or else fails.It is generally considered good Lean style to use bullets whenever a tactic line results in more than one new subgoal.\nThis makes it easier to read and maintain proofs, because the connections between steps of reasoning are more clear and any change in the number of subgoals while editing the proof will have a localized effect.\n\nnext => tac focuses on the next goal and solves it using tac, or else fails.\nnext x₁ ... xₙ => tac additionally renames the n most recent hypotheses with\ninaccessible names to the given names.\n\nfocus tac focuses on the main goal, suppressing all other goals, and runs tac on it.\nUsually · tac, which enforces that the goal is closed by tac, should be preferred.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures","header":"13.3.1.4. Focusing","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-focusing"},"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Strings":{"contents":"String literals are described in the chapter on strings.\n\n","context":"Lean Reference\u0009Terms\u0009Numeric Literals","header":"10.5.3. Strings","id":"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Strings"},"/The-Type-System/Quotients/#setoids":{"contents":"Quotient types are built on setoids.\nA setoid is a type paired with a distinguished equivalence relation.\nUnlike a quotient type, the abstraction barrier is not enforced, and proof automation designed around equality cannot be used with the setoid's equivalence relation.\nSetoids are useful on their own, in addition to being a building block for quotient types.\n\nA setoid is a type with a distinguished equivalence relation, denoted ≈.The Quotient type constructor requires a Setoid instance.x ≈ y is the distinguished equivalence relation of a setoid.The relation x ≈ y is an equivalence relation.\n\nA setoid's equivalence relation is reflexive.\n\nA setoid's equivalence relation is symmetric.\n\nA setoid's equivalence relation is transitive.\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.2. Setoids","id":"/The-Type-System/Quotients/#setoids"}});