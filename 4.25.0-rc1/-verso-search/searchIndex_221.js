window.docContents[221].resolve({"/Axioms/#print-axioms":{"contents":"The command #print axioms, followed by a defined identifier, displays all the axioms that a definition transitively relies on.\nIn other words, if a proof uses another proof, which itself uses an axiom, then the axiom is reported by #print axioms for both.\n\nThis can be used to audit the assumptions made by a proof, for instance detecting that a proof transitively depends on the sorry tactic.def lazy : 4 == 2 + 1 + 1 := by sorry\n#print axioms lazy\n'lazy' depends on axioms: [sorryAx]\nPrinting Axioms of Simple DefinitionsConsider the following three constants:def addThree (n : Nat) : Nat := 1 + n + 2\ntheorem excludedMiddle (P : Prop) : P ∨ ¬ P := Classical.em P\ntheorem simpleEquality (P : Prop) : (P ∨ False) = P := or_false P\nRegular functions like addThree that we might want to actually evaluation typically do not depend on any axioms:#print axioms addThree\n'addThree' does not depend on any axioms\nThe excluded middle theorem is only true if we use classical reasoning, so the foundation for classical reasoning shows up alongside other axioms:#print axioms excludedMiddle\n'excludedMiddle' depends on axioms: [propext, Classical.choice, Quot.sound]\nFinally, the idea that two equivalent propositions are equal directly relies on propositional extensionality.#print axioms simpleEquality\n'simpleEquality' depends on axioms: [propext]\nUsing #print axioms with #guard_msgsYou can use #print axioms together with #guard_msgs to ensure that updates to libraries from other projects cannot silently introduce unwanted dependencies on axioms.Perhaps you are worried that some future update to or_false in the previous example's simpleEquality proof might quietly introduce a new axiom dependency.\nYou can guard against this by writing a command that will fail if simpleEquality uses any axioms besides propext:/--\ninfo: 'simpleEquality' depends on axioms: [propext]\n-/\n#guard_msgs in\n#print axioms simpleEquality\n\n\n","context":"Lean Reference\u0009Axioms","header":"8.5. Displaying Axiom Dependencies","id":"/Axioms/#print-axioms"},"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Hashing":{"contents":"Computes a hash of a bitvector, combining 64-bit words using mixHash.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"19.5.5.5. Hashing","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Hashing"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans","header":"19.11.4. API Reference","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays","header":"19.17.1. API Reference","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Sorting":{"contents":"A stable merge sort.This function is a simplified implementation that's designed to be easy to reason about, rather than\nfor efficiency. In particular, it uses the non-tail-recursive List.merge function and traverses\nlists unnecessarily.It is replaced at runtime by an efficient implementation that has been proven to be equivalent.\n\nMerges two lists, using le to select the first element of the resulting list if both are\nnon-empty.If both input lists are sorted according to le, then the resulting list is also sorted according\nto le. O(|xs| + |ys|).This implementation is not tail-recursive, but it is replaced at runtime by a proven-equivalent\ntail-recursive merge.\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.9. Sorting","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Sorting"},"/Definitions/Recursive-Definitions/#mutual-partial-fixpoint":{"contents":"Lean supports the definition of mutually recursive functions using partial fixpoint.\nMutual recursion may be introduced using a mutual block, but it also results from let rec expressions and where blocks.\nThe rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the elaboration steps for mutual groups.\n\nIf all functions in the mutual group have the partial_fixpoint clause, then this strategy is used.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.4. Mutual Recursion with Partial Fixpoints","id":"/Definitions/Recursive-Definitions/#mutual-partial-fixpoint"},"/Introduction/#typographical-conventions":{"contents":"This document makes use of a number of typographical and layout conventions to indicate various aspects of the information being presented.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Introduction","header":"1.2. Typographical Conventions","id":"/Introduction/#typographical-conventions"},"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Observing-Uniqueness":{"contents":"Ensuring that arrays and strings are uniquely referenced is key to writing fast code in Lean.\nThe primitive dbgTraceIfShared can be used to check whether a data structure is aliased.\nWhen called, it returns its argument unchanged, printing the provided trace message if the argument's reference count is greater than one.\n\nDisplay the given message if a is shared, that is, RC(a) > 1\n\nDue to the specifics of how #eval is implemented, using dbgTraceIfShared with #eval can be misleading.\nInstead, it should be used in code that's explicitly compiled and run.\n\nObserving UniquenessThis program reads a line of input from the user, printing it after replacing its first character with a space.\nReplacing characters in a string uses an in-place update if the string is not shared and the characters are both contained in the 7-bit ASCII subset of Unicode.\nThe dbgTraceIfShared call does nothing, indicating that the string will indeed be updated in place rather than copied.def process (str : String) (h : str.startValidPos ≠ str.endValidPos) : IO Unit := do\n  IO.println ((dbgTraceIfShared \"String update\" str).startValidPos.set ' ' h)\n\ndef main : IO Unit := do\n  let line := (← (← IO.getStdin).getLine).trim\n  if h : line.startValidPos ≠ line.endValidPos then\n    process line h\nWhen run with this input:Here is input.\nthe program emits: ere is input.\nwith an empty standard error output:\nThis version of the program retains a reference to the original string, which necessitates copying the string in the call to String.set.\nThis fact is visible in its standard error output.def process (str : String) (h : str.startValidPos ≠ str.endValidPos) : IO Unit := do\n  IO.println ((dbgTraceIfShared \"String update\" str).startValidPos.set ' ' h)\n\ndef main : IO Unit := do\n  let line := (← (← IO.getStdin).getLine).trim\n  if h : line.startValidPos ≠ line.endValidPos then\n    process line h\n  IO.println \"Original input:\"\n  IO.println line\nWhen run with this input:Here is input.\nthe program emits: ere is input.\nOriginal input:\nHere is input.\nIn its standard error, the message passed to dbgTraceIfShared is visible.shared RC String update\n\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Reference Counting","header":"21.2.1. Observing Uniqueness","id":"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Observing-Uniqueness"}});