window.docContents[251].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries":{"contents":"Returns true if a, or an element equal to a according to the comparator cmp, is contained\nin the set. There is also a Prop-valued version of this: a ∈ t is equivalent to\nt.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for equality checks, while for tree sets, both use the given comparator cmp.\n\nRetrieves the key from the set that matches a. Ensures that such a key exists by requiring a proof\nof a ∈ m. The result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if given key is contained and returns the key if it is, otherwise fallback.\nIf they key is contained the result is guaranteed to be pointer equal to the key in the set.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","header":"19.18.10.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Positions":{"contents":"Checks whether a position in a substring is precisely equal to its ending position.The position is understood relative to the substring's starting position, rather than the underlying\nstring's starting position.\n\nReturns the substring-relative position of the first occurrence of c in s, or s.bsize if c\ndoesn't occur.\n\nReturns the next position in a substring after the given position. If the position is at the end of\nthe substring, it is returned unmodified.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\nReturns the position that's the specified number of characters forward from the given position in a\nsubstring. If the end position of the substring is reached, it is returned.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\nReturns the previous position in a substring, just prior to the given position. If the position is\nat the beginning of the substring, it is returned unmodified.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\nReturns the position that's the specified number of characters prior to the given position in a\nsubstring. If the start position of the substring is reached, it is returned.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Substrings","header":"19.8.4.11.2. Positions","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Positions"},"/Type-Classes/#type-classes":{"contents":"An operation is polymorphic if it can be used with multiple types.\nIn Lean, polymorphism comes in three varieties:\n\n1. universe polymorphism, where the sorts in a definition can be instantiated in various ways,2. functions that take types as (potentially implicit) parameters, allowing a single body of code to work with any type, and3. ad-hoc polymorphism, implemented with type classes, in which operations to be overloaded may have different implementations for different types.\n\nBecause Lean does not allow case analysis of types, polymorphic functions implement operations that are uniform for any choice of type argument; for example, List.map does not suddenly compute differently depending on whether the input list contains Strings or Nats.\nAd-hoc polymorphic operations are useful when there is no “uniform” way to implement an operation; the canonical use case is for overloading arithmetic operators so that they work with Nat, Int, Float, and any other type that has a sensible notion of addition.\nAd-hoc polymorphism may also involve multiple types; looking up a value at a given index in a collection involves the collection type, the index type, and the type of member elements to be extracted.\nA type classType classes were first described in  describes a collection of overloaded operations (called methods) together with the involved types.\n\nType classes are very flexible.\nOverloading may involve multiple types; operations like indexing into a data structure can be overloaded for a specific choice of data structure, index type, element type, and even a predicate that asserts the presence of the key in the structure.\nDue to Lean's expressive type system, overloading operations is not restricted only to types; type classes may be parameterized by ordinary values, by families of types, and even by predicates or propositions.\nAll of these possibilities are used in practice:\n\n Natural number literals\n\nThe OfNat type class is used to interpret natural number literals.\n  Instances may depend not only on the type being instantiated, but also on the number literal itself.\n\n Computational effects\n\nType classes such as Monad, whose parameter is a function from one type to another, are used to provide special syntax for programs with side effects.\n  The “type” for which operations are overloaded is actually a type-level function, such as Option, IO, or Except.\n\n Predicates and propositions\n\nThe Decidable type class allows a decision procedure for a proposition to be found automatically by Lean.\n  This is used as the basis for if-expressions, which may branch on any decidable proposition.\n\n\n\nWhile ordinary polymorphic definitions simply expect instantiation with arbitrary parameters, the operators overloaded with type classes are to be instantiated with instances that define the overloaded operation for some specific set of parameters.\nThese instance-implicit parameters are indicated in square brackets.\nAt invocation sites, Lean either synthesizes   a suitable instance from the available candidates or signals an error.\nBecause instances may themselves have instance parameters, this search process may be recursive and result in a final composite instance value that combines code from a variety of instances.\nThus, type class instance synthesis is also a means of constructing programs in a type-directed manner.\n\nHere are some typical use cases for type classes:\n\n* Type classes may represent overloaded operators, such as arithmetic that can be used with a variety of types of numbers or a membership predicate that can be used for a variety of data structures. There is often a single canonical choice of operator for a given type—after all, there is no sensible alternative definition of addition for Nat—but this is not an essential property, and libraries may provide alternative instances if needed.* Type classes can represent an algebraic structure, providing both the extra structure and the axioms required by the structure. For example, a type class that represents an Abelian group may contain methods for a binary operator, a unary inverse operator, an identity element, as well as proofs that the binary operator is associative and commutative, that the identity is an identity, and that the inverse operator yields the identity element on both sides of the operator. Here, there may not be a canonical choice of structure, and a library may provide many ways to instantiate a given set of axioms; there are two equally canonical monoid structures over the integers.* A type class can represent a relation between two types that allows them to be used together in some novel way by a library.\n   The Coe class represents automatically-inserted coercions from one type to another, and MonadLift represents a way to run operations with one kind of effect in a context that expects another kind.* Type classes can represent a framework of type-driven code generation, where instances for polymorphic types each contribute some portion of a final program.\n    The Repr class defines a canonical pretty printer for a type, and polymorphic types end up with polymorphic Repr instances.\n    When pretty printing is finally invoked on an expression with a known concrete type, such as List (Nat × (String ⊕ Int)), the resulting pretty printer contains code assembled from the Repr instances for List, Prod, Nat, Sum, String, and Int.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"11. Type Classes","id":"/Type-Classes/#type-classes"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Library":{"contents":"* #4904 introduces date and time functionality to the Lean 4 Std.* #5616 is a follow-up to https://github.com/leanprover/lean4/pull/5609,\nwhere we add lemmas characterizing smtUDiv and smtSDiv's behavior\nwhen the denominator is zero.* #5866 verifies the keys function on Std.HashMap.* #5885 add Int16/Int32/Int64* #5926 add Option.or_some'* #5927 List.pmap_eq_self* #5937 upstream lemmas about Fin.foldX* #5938 upstream List.ofFn and relate to Array.ofFn* #5941 List.mapFinIdx, lemmas, relate to Array version* #5949 consolidate decide_True and decide_true_eq_true* #5950 relate Array.takeWhile with List.takeWhile* #5951 remove @[simp] from BitVec.ofFin_sub and sub_ofFin* #5952 relate Array.eraseIdx with List.eraseIdx* #5961 define ISize and basic operations on it* #5969 upstream List.insertIdx from Batteries, lemmas from Mathlib, and revise lemmas* #5970 deprecate Array.split in favour of identical Array.partition* #5971 relate Array.isPrefixOf with List.isPrefixOf* #5972 relate Array.zipWith/zip/unzip with List versions* #5974 add another List.find?_eq_some lemma* #5981 names the default SizeOf instance instSizeOfDefault* #5982 minor lemmas about List.ofFn* #5984 adds lemmas for List for the interactions between {foldl,\nfoldr, foldlM, foldlrM} and {filter, filterMap}.* #5985 relates the operations findSomeM?, findM?, findSome?, and\nfind? on Array with the corresponding operations on List, and also\nprovides simp lemmas for the Array operations findSomeRevM?,\nfindRevM?, findSomeRev?, findRev? (in terms of reverse and the\nusual forward find operations).* #5987 BitVec.getMsbD in bv_decide* #5988 changes the signature of Array.set to take a Nat, and a\ntactic-provided bound, rather than a Fin.* #5995 BitVec.sshiftRight' in bv_decide* #6007 List.modifyTailIdx naming fix* #6008 missing @[ext] attribute on monad transformer ext lemmas* #6023 variants of List.forIn_eq_foldlM* #6025 deprecate duplicated Fin.size_pos* #6032 changes the signature of Array.get to take a Nat and a proof,\nrather than a Fin, for consistency with the rest of the (planned)\nArray API. Note that because of bootstrapping issues we can't provide\nget_elem_tactic as an autoparameter for the proof. As users will\nmostly use the xs[i] notation provided by GetElem, this hopefully\nisn't a problem.* #6041 modifies the order of arguments for higher-order Array\nfunctions, preferring to put the Array last (besides positional\narguments with defaults). This is more consistent with the List API,\nand is more flexible, as dot notation allows two different partially\napplied versions.* #6049 adds a primitive for accessing the current thread ID* #6052 adds Array.pmap, as well as a @[csimp] lemma in terms of the\nno-copy Array.attachWith.* #6055 adds lemmas about for loops over Array, following the existing\nlemmas for List.* #6056 upstream some NameMap functions* #6060 implements conversion functions from Bool to all UIntX and\nIntX types.* #6070 adds the Lean.RArray data structure.* #6074 allow Sort u in Squash* #6094 adds raw transmutation of floating-point numbers to and from\nUInt64. Floats and UInts share the same endianness across all\nsupported platforms. The IEEE 754 standard precisely specifies the bit\nlayout of floats. Note that Float.toBits is distinct from\nFloat.toUInt64, which attempts to preserve the numeric value rather\nthan the bitwise value.* #6095 generalize List.get_mem* #6097 naming convention and NaN normalization* #6102 moves IO.rand and IO.setRandSeed to be in the BaseIO\nmonad.* #6106 fix naming of left/right injectivity lemmas* #6111 fills in the API for Array.findSome? and Array.find?,\ntransferring proofs from the corresponding List statements.* #6120 adds theorems BitVec.(getMsbD, msb)_(rotateLeft, rotateRight).* #6126 adds lemmas for extracting a given bit of a BitVec obtained\nvia sub/neg/sshiftRight'/abs.* #6130 adds Lean.loadPlugin which exposes functionality similar to\nthe lean executable's --plugin option to Lean code.* #6132 duplicates the verification API for\nList.attach/attachWith/pmap over to Array.* #6133 replaces Array.feraseIdx and Array.insertAt with\nArray.eraseIdx and Array.insertIdx, both of which take a Nat\nargument and a tactic-provided proof that it is in bounds. We also have\neraseIdxIfInBounds and insertIdxIfInBounds which are noops if the\nindex is out of bounds. We also provide a Fin valued version of\nArray.findIdx?. Together, these quite ergonomically improve the array\nindexing safety at a number of places in the compiler/elaborator.* #6136 fixes the run-time evaluation of (default : Float).* #6139 modifies the signature of the functions Nat.fold,\nNat.foldRev, Nat.any, Nat.all, so that the function is passed the\nupper bound. This allows us to change runtime array bounds checks to\ncompile time checks in many places.* #6148 adds a primitive for creating temporary directories, akin to the\nexisting functionality for creating temporary files.* #6149 completes the elementwise accessors for ofNatLt, allOnes,\nand not by adding their implementations of getMsbD.* #6151 completes the toInt interface for BitVec bitwise operations.* #6154 implements BitVec.toInt_abs.* #6155 adds toNat theorems for BitVec.signExtend.* #6157 adds toInt theorems for BitVec.signExtend.* #6160 adds theorem mod_eq_sub, makes theorem\nsub_mul_eq_mod_of_lt_of_le not private anymore and moves its location\nwithin the rotate* section to use it in other proofs.* #6184 uses Array.findFinIdx? in preference to Array.findIdx? where\nit allows converting a runtime bounds check to a compile time bounds\ncheck.* #6188 completes the toNat theorems for the bitwise operations\n(and, or, xor, shiftLeft, shiftRight) of the UInt types and\nadds toBitVec theorems as well. It also renames and_toNat to\ntoNat_and to fit with the current naming convention.* #6190 adds the builtin simproc USize.reduceToNat which reduces the\nUSize.toNat operation on literals less than UInt32.size (i.e.,\n4294967296).* #6191 adds Array.zipWithAll, and the basic lemmas relating it to\nList.zipWithAll.* #6192 adds deprecations for Lean.HashMap functions which did not\nreceive deprecation attributes initially.* #6193 completes the TODO in Init.Data.Array.BinSearch, removing the\npartial keyword and converting runtime bounds checks to compile time\nbounds checks.* #6194 changes the signature of Array.swap, so it takes Nat\narguments with tactic provided bounds checking. It also renames\nArray.swap! to Array.swapIfInBounds.* #6195 renames Array.setD to Array.setIfInBounds.* #6197 upstreams the definition of Vector from Batteries, along with\nthe basic functions.* #6200 upstreams Nat.lt_pow_self and Nat.lt_two_pow from Mathlib\nand uses them to prove the simp theorem Nat.mod_two_pow.* #6202 makes USize.toUInt64 a regular non-opaque definition.* #6203 adds the theorems le_usize_size and usize_size_le, which\nmake proving inequalities about USize.size easier.* #6205 upstreams some UInt theorems from Batteries and adds more\ntoNat-related theorems. It also adds the missing UInt8 and UInt16\nto/from USize conversions so that the the interface is uniform across\nthe UInt types.* #6207 ensures the Fin.foldl and Fin.foldr are semireducible.\nWithout this the defeq example (f : Fin 3 → ℕ) : List.ofFn f = [f 0, f 1, f 2] := rfl was failing.* #6208 fix Vector.indexOf?* #6217 adds simp lemmas about List's == operation.* #6221 fixes:* Problems in other linux distributions that the default tzdata\ndirectory is not the same as previously defined by ensuring it with a\nfallback behavior when directory is missing.* Trim unnecessary characters from local time identifier.* #6222 changes the definition of HashSet.insertMany and\nHashSet.Raw.insertMany so that it is equivalent to repeatedly calling\nHashSet.insert/HashSet.Raw.insert. It also clarifies the docstrings\nof all the insert and insertMany functions.* #6230 copies some lemmas about List.foldX to Array.* #6233 upstreams lemmas about Vector from Batteries.* #6234 upstreams the definition and basic lemmas about List.finRange\nfrom Batteries.* #6235 relates that operations Nat.fold/foldRev/any/all to the\ncorresponding List operations over List.finRange.* #6241 refactors Array.qsort to remove runtime array bounds checks,\nand avoids the use of partial. We use the Vector API, along with\nauto_params, to avoid having to write any proofs. The new code\nbenchmarks indistinguishably from the old.* #6242 deprecates Fin.ofNat in favour of Fin.ofNat' (which takes an\n[NeZero] instance, rather than returning an element of Fin (n+1)).* #6247 adds the theorems numBits_pos, le_numBits, numBits_le ,\nwhich make proving inequalities about System.Platform.numBits easier.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Library","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Library"}});