window.docContents[225].resolve({"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Comparisons":{"contents":"Equality and inequality tests on Int are typically performed using the decidability of its equality and ordering relations or using the BEq Int and Ord Int instances.\n\n\n\nNon-strict inequality of integers, usually accessed via the ≤ operator.a ≤ b is defined as b - a ≥ 0, using Int.NonNeg.\n\nStrict inequality of integers, usually accessed via the < operator.a < b when a + 1 ≤ b.\n\nDecides whether two integers are equal. Usually accessed via the DecidableEq Int instance.This function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.Examples:* show (7 : Int) = (3 : Int) + (4 : Int) by decide* if (6 : Int) = (3 : Int) * (2 : Int) then \"yes\" else \"no\" = \"yes\"* (¬ (6 : Int) = (3 : Int)) = true\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","header":"19.2.4.5. Comparisons","id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Comparisons"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion":{"contents":"Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence.\n\nTransforms the hash map into an array of mappings in some order.\n\nTransforms the hash map into a list of mappings in some order.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","header":"19.18.3.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion"},"/The-Type-System/Inductive-Types/#structure-params":{"contents":"Just like ordinary inductive type declarations, the header of the structure declaration contains a signature that may specify both parameters and a resulting universe.\nStructures may not define indexed families.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Structure Declarations","header":"4.4.2.1. Structure Parameters","id":"/The-Type-System/Inductive-Types/#structure-params"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Linear-Integer-Normalization-in-simp-___arith":{"contents":"* #7000 adds helper theorems for justifying the linear integer\nnormalizer.* #7002 implements the normalizer for linear integer arithmetic\nexpressions. It is not connect to simp +arith yet because of some\nspurious [simp] attributes.* #7011 adds simp +arith for integers. It uses the new grind\nnormalizer for linear integer arithmetic. We still need to implement\nsupport for dividing the coefficients by their GCD. It also fixes\nseveral bugs in the normalizer.* #7015 makes sure simp +arith normalizes coefficients in linear\ninteger polynomials. There is still one todo: tightening the bound of\ninequalities.* #7030 adds completes the linear integer inequality normalizer for\ngrind. The missing normalization step replaces a linear inequality of\nthe form a_1*x_1 + ... + a_n*x_n + b <= 0 with a_1/k * x_1 + ... + a_n/k * x_n + ceil(b/k) <= 0 where k = gcd(a_1, ..., a_n).\nceil(b/k) is implemented using the helper cdiv b k.* #7040 ensures that terms such as f (2*x + y) and f (y + x + x)\nhave the same normal form when using simp +arith* #7043 deprecates the tactics simp_arith, simp_arith!,\nsimp_all_arith and simp_all_arith!. Users can just use the +arith\noption.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)\u0009Language","header":"Linear Integer Normalization in simp +arith","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Language--Linear-Integer-Normalization-in-simp-___arith"}});