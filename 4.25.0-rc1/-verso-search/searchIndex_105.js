window.docContents[105].resolve({"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-cli":{"contents":"In addition to the proxies that automatically select, install, and invoke the correct versions of Lean tools, Elan provides a command-line interface for querying and configuring its settings.\nThis tool is called elan.\nLike Lake, its command-line interface is structured around subcommands.\n\nElan can be invoked with following flags:\n\n --help or -h\n\nDescribes the current subcommand in detail.\n\n --verbose or -v\n\nEnables verbose output.\n\n --version or -V\n\nDisplays the Elan version.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan","header":"22.2.3. Command-Line Interface","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-cli"},"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--System-Randomness":{"contents":"Reads bytes from a system entropy source. It is not guaranteed to be cryptographically secure.If nBytes is 0, returns immediately with an empty buffer.\n\n","context":"Lean Reference\u0009IO\u0009Random Numbers","header":"15.10.2. System Randomness","id":"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--System-Randomness"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks--Priorities":{"contents":"Task priorities are used by the thread scheduler to assign tasks to threads.\nWithin the priority range default–max, higher-priority tasks always take precedence over lower-priority tasks.\nTasks spawned with priority dedicated are assigned their own dedicated threads and do not contend with other tasks for the threads in the thread pool.\n\nTask priority.Tasks with higher priority will always be scheduled before tasks with lower priority. Tasks with a\npriority greater than Task.Priority.max are scheduled on dedicated threads.\n\nThe default priority for spawned tasks, also the lowest priority: 0.\n\nThe highest regular priority for spawned tasks: 8.Spawning a task with a priority higher than Task.Priority.max is not an error but will spawn a\ndedicated worker for the task. This is indicated using Task.Priority.dedicated. Regular priority\ntasks are placed in a thread pool and worked on according to their priority order.\n\nIndicates that a task should be scheduled on a dedicated thread.Any priority higher than Task.Priority.max will result in the task being scheduled\nimmediately on a dedicated thread. This is particularly useful for long-running and/or\nI/O-bound tasks since Lean will, by default, allocate no more non-dedicated workers\nthan the number of cores to reduce context switches.\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads\u0009Creating Tasks","header":"15.11.1.3. Priorities","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks--Priorities"},"/The-Type-System/Inductive-Types/#strict-positivity":{"contents":"All occurrences of the type being defined in the types of the parameters of the constructors must be in strictly positive positions.\nA position is strictly positive if it is not in a function's argument type (no matter how many function types are nested around it) and it is not an argument of any expression other than type constructors of inductive types.\nThis restriction rules out unsound inductive type definitions, at the cost of also ruling out some unproblematic ones.\n\nNon-strictly-positive inductive typesThe type Bad would make Lean inconsistent if it were not rejected:inductive Bad where\n  | bad : (Bad → Bad) → Bad\n(kernel) arg #1 of 'Bad.bad' has a non positive occurrence of the datatypes being declared\nThis is because it would be possible to write a circular argument that proves False under the assumption Bad.\nBad.bad is rejected because the constructor's parameter has type Bad → Bad, which is a function type in which Bad occurs as an argument type.This declaration of a fixed point operator is rejected, because Fix occurs as an argument to f:inductive Fix (f : Type u → Type u) where\n  | fix : f (Fix f) → Fix f\n(kernel) arg #2 of 'Fix.fix' contains a non valid occurrence of the datatypes being declared\nFix.fix is rejected because f is not a type constructor of an inductive type, but Fix itself occurs as an argument to it.\nIn this case, Fix is also sufficient to construct a type equivalent to Bad:def Bad : Type := Fix fun t => t → t\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Well-Formedness Requirements","header":"4.4.3.2.2. Strict Positivity","id":"/The-Type-System/Inductive-Types/#strict-positivity"},"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Compiler":{"contents":"* #8691 ensures that the state is reverted when compilation using the\nnew compiler fails. This is especially important for noncomputable\nsections where the compiler might generate half-compiled functions which\nmay then be erroneously used while compiling other functions.* #9134 changes ToIR to call lowerEnumToScalarType? with\nConstructorVal.induct rather than the name of the constructor itself.\nThis was an oversight in some refactoring of code in the new compiler\nbefore landing it. It should not affect runtime of compiled code (due to\nthe extra tagging/untagging being optimized by LLVM), but it does make\nIR for the interpreter slightly more efficient.* #9144 adds support for representing more inductive as enums,\nsummarized up as extending support to those that fail to be enums\nbecause of parameters or irrelevant fields. While this is nice to have,\nit is actually motivated by correctness of a future desired\noptimization. The existing type representation is unsound if we\nimplement object/tobject distinction between values guaranteed to be\nan object pointer and those that may also be a tagged scalar. In\nparticular, types like the ones added in this PR's tests would have all\nof their constructors encoded via tagged values, but under the natural\nextension of the existing rules of type representation they would be\nconsidered object rather than tobject.* #9154 tightens the IR typing rules around applications of closures.\nWhen re-reading some code, I realized that the code in mkPartialApp\nhas a clear typo—.object and type should be swapped. However, it\ndoesn't matter, because later IR passes smooth out the mismatch here. It\nmakes more sense to be strict up-front and require applications of\nclosures to always return an .object.* #9159 enforces the non-inlining of _override impls in the base phase\nof LCNF compilation. The current situation allows for constructor/cases\nmismatches to be exposed to the simplifier, which triggers an assertion\nfailure. The reason this didn't show up sooner for Expr is that Expr has\na custom extern implementation of its computed field getter.* #9177 makes the pullInstances pass avoid pulling any instance\nexpressions containing erased propositions, because we don't correctly\nrepresent the dependencies that remain after erasure.* #9198 changes the compiler's specialization analysis to consider\nhigher-order params that are rebundled in a way that only changes their\nProp arguments to be fixed. This means that they get specialized with\na mere @[specialize], rather than the compiler having to opt-in to\nmore aggressive parameter-specific specialization.* #9207 makes the offending declaration clickable in the error message\nproduced when something should be marked noncomputable.* #9209 changes the getLiteral helper function of elimDeadBranches\nto correctly handle inductives with constructors. This function is not\nused as often as it could be, which makes this issue rare to hit outside\nof targeted test cases.* #9218 makes the LCNF elimDeadBranches pass handle unsafe decls a bit\nmore carefully. Now the result of an unsafe decl will only become ⊤ if\nthere is value flow from a recursive call.* #9221 removes code that has the false assumption that LCNF local vars\ncan occur in types. There are other comments in ElimDead.lean\nasserting that this is not possible, so this must have been a change\nearly in the development of the new compiler.* #9224 changes the toMono pass to consider the type of an application\nand erase all arguments corresponding to erased params. This enables a\nlightweight form of relevance analysis by changing the mono type of a\ndecl. I would have liked to unify this with the behavior for\nconstructors, but my attempt to give constructors the same behavior in\n#9222 (which was in preparation for this PR) had a minor performance\nregression that is really incidental to the change. Still, I decided to\nhold off on it for the time being. In the future, we can hopefully\nextend this to constructors, extern decls, etc.* #9266 adds support for .mdata in LCNF mono types (and then drops it\nat the IR type level instead). This better matches the behavior of\nextern decls in the C++ code of the old compiler, which is still being\nused to create extern decls at the moment and will soon be replaced.* #9268 moves the implementation of lean_add_extern/addExtern from\nC++ into Lean. I believe is the last C++ helper function from the\nlibrary/compiler directory being relied upon by the new compiler. I put\nit into its own file and duplicated some code because this function\nneeds to execute in CoreM, whereas the other IR functions live in their\nown monad stack. After the C++ compiler is removed, we can move the IR\nfunctions into CoreM.* #9275 removes the old compiler written in C++.* #9279 fixes the compiler.extract_closed option after migrating it to\nLean (and adds a test so it would be caught in the future).* #9310 fixes IR constructor argument lowering to correctly handle an\nirrelevant argument being passed for a relevant parameter in all cases.\nThis happened because constructor argument lowering (incompletely)\nreimplemented general LCNF-to-IR argument lowering, and the fix is to\njust adopt the generic helper functions. This is probably due to an\nincomplete refactoring when the new compiler was still on a branch.* #9336 changes the implementation of trace.Compiler.result to use the\ndecls as they are provided rather than looking them up in the LCNF mono\nenvironment extension, which was seemingly done to save the trouble of\nre-normalizing fvar IDs before printing the decl. This means that the\n._closed decls created by the extractClosed pass will now be\nincluded in the output, which was definitely confusing before if you\ndidn't know what was happening.* #9344 correctly populates the xType field of the IR.FnBody.case\nconstructor. It turns out that there is no obvious consequence for this\nbeing incorrect, because it is conservatively recomputed by the Boxing\npass.* #9393 fixes an unsafe trick where a sentinel for a hash table of Exprs\n(keyed by pointer) is created by constructing a value whose runtime\nrepresentation can never be a valid Expr. The value chosen for this\npurpose was Unit.unit, which violates the inference that Expr has no\nscalar constructors. Instead, we change this to a freshly allocated Unit\n× Unit value.* #9411 adds support for compilation of casesOn for subsingletons. We\nrely on the elaborator's type checking to restrict this to inductives in\nProp that can actually eliminate into Type n. This does not yet\ncover other recursors of these types (or of inductives not in Prop for\nthat matter).* #9703 changes the LCNF elimDeadBranches pass so that it considers\nall non-Nat literal types to be ⊤. It turns out that fixing this to\ncorrectly handle all of these types with the current abstract value\nrepresentation is surprisingly nontrivial, and it's better to just land\nthe fix first.* #9720 removes an error which implicitly assumes that the sort of type\ndependency between erased types present in the test being added can not\noccur. It would be difficult to refine the error using only the\ninformation present in LCNF types, and it is of very little ongoing\nvalue (I don't recall it ever finding an actual problem), so it makes\nmore sense to delete it.* #9827 changes the lowering of Quot.lcInv (the compiler-internal form\nof Quot.lift) in toMono to support overapplication.* #9847 adds a check for reursive decls in this bespoke inlining path,\nwhich fixes a regression from the old compiler.* #9864 adds new variants of Array.getInternal and\nArray.get!Internal that return their argument borrowed, i.e. without a\nreference count increment. These are intended for use by the compiler in\ncases where it can determine that the array will continue to hold a\nvalid reference to the element for the returned value's lifetime.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.23.0 (2025-09-15)","header":"Compiler","id":"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Compiler"}});