window.docContents[117].resolve({"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Extracting-Values":{"contents":"Case analysis for sums that applies the appropriate function f or g after checking which\nconstructor is present.\n\nRetrieves the contents from a sum known to be inl.\n\nChecks whether a sum is the left injection inl and, if so, retrieves its contents.\n\nRetrieves the contents from a sum known to be inr.\n\nChecks whether a sum is the right injection inr and, if so, retrieves its contents.\n\n","context":"Lean Reference\u0009Basic Types\u0009Sum Types\u0009API Reference","header":"19.14.2.2. Extracting Values","id":"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Extracting-Values"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Workspace":{"contents":"Monads that provide access to information about the current Lake workspace have MonadWorkspace instances.\nIn particular, there are instances for ScriptM and LakeM.\n\n\n\nA monad equipped with a (read-only) Lake Workspace.Gets the current Lake workspace.\n\nGet the root package of the context's workspace.\n\nTry to find a package within the workspace with the given name.\n\nLocate the named, buildable, importable, local module in the workspace.\n\nTry to find a Lean executable in the workspace with the given name.\n\nTry to find a Lean library in the workspace with the given name.\n\nTry to find an external library in the workspace with the given name.\n\nGet the paths added to LEAN_PATH by the context's workspace.\n\nGet the paths added to LEAN_SRC_PATH by the context's workspace.\n\nGet the paths added to the shared library path by the context's workspace.\n\nGet the augmented LEAN_PATH set by the context's workspace.\n\nGet the augmented LEAN_SRC_PATH set by the context's workspace.\n\nGet the augmented shared library path set by the context's workspace.\n\nGet the augmented environment variables set by the context's workspace.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference","header":"22.1.4.2. Accessing the Workspace","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Workspace"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv":{"contents":"The conv, or conversion, tactic allows targeted rewriting within a goal.\nThe argument to conv is written in a separate language that interoperates with the main tactic language; it features commands to navigate to specific subterms within the goal along with commands that allow these subterms to be rewritten.\nconv is useful when rewrites should only be applied in part of a goal (e.g. only on one side of an equality), rather than across the board, or when rewrites should be applied underneath a binder that prevents tactics like rw from accessing the term.\n\nThe conversion tactic language is very similar to the main tactic language: it uses the same proof states, tactics work primarily on the main goal and may either fail or succeed with a sequence of new goals, and macro expansion is interleaved with tactic execution.\nUnlike the main tactic language, in which tactics are intended to eventually solve goals, the conv tactic is used to change a goal so that it becomes amenable to further processing in the main tactic language.\nGoals that are intended to be rewritten with conv are shown with a vertical bar instead of a turnstile.\n\nconv => ... allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.See https://lean-lang.org/theorem_proving_in_lean4/conv.html for more details.Basic forms:* conv => cs will rewrite the goal with conv tactics cs.* conv at h => cs will rewrite hypothesis h.* conv in pat => cs will rewrite the first subexpression matching pat (see pattern).\n\nNavigation and Rewriting with convIn this example, there are multiple instances of addition, and rw would by default rewrite the first instance that it encounters.\nUsing conv to navigate to the specific subterm before rewriting leaves rw no choice but to rewrite the correct term.example (x y z : Nat) : x + (y + z) = (x + z) + y := by\n  conv =>\n    lhs\n    arg 2\n    rw [Nat.add_comm]\n  rw [Nat.add_assoc]\n\n\nRewriting Under Binders with convIn this example, addition occurs under binders, so rw can't be used.\nHowever, after using conv to navigate to the function body, it succeeds.\nThe nested use of conv causes control to return to the current position in the term after performing further conversions on one of its subterms.\nBecause the goal is a reflexive equation after rewriting, conv automatically closes it.example :\n    (fun (x y z : Nat) =>\n      x + (y + z))\n    =\n    (fun x y z =>\n      (z + x) + y)\n  := by\n  conv =>\n    lhs\n    intro x y z\n    conv =>\n      arg 2\n      rw [Nat.add_comm]\n    rw [‚Üê Nat.add_assoc]\n    arg 1\n    rw [Nat.add_comm]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.6. Targeted Rewriting with  conv","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv"}});