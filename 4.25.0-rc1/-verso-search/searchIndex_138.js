window.docContents[138].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Searching":{"contents":"Checks whether a slice has a match of the pattern pat anywhere.This function is generic over all currently supported patterns.Examples:* \"coffee tea water\".toSlice.contains Char.isWhitespace = true* \"tea\".toSlice.contains (fun (c : Char) => c == 'X') = false* \"coffee tea water\".toSlice.contains \"tea\" = true\n\nChecks whether the slice (s) begins with the pattern (pat).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.startsWith \"red\" = true* \"red green blue\".toSlice.startsWith \"green\" = false* \"red green blue\".toSlice.startsWith \"\" = true* \"red green blue\".toSlice.startsWith 'r' = true* \"red green blue\".toSlice.startsWith Char.isLower = true\n\nChecks whether the slice (s) ends with the pattern (pat).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.endsWith \"blue\" = true* \"red green blue\".toSlice.endsWith \"green\" = false* \"red green blue\".toSlice.endsWith \"\" = true* \"red green blue\".toSlice.endsWith 'e' = true* \"red green blue\".toSlice.endsWith Char.isLower = true\n\nChecks whether a slice only consists of matches of the pattern pat anywhere.Short-circuits at the first pattern mis-match.This function is generic over all currently supported patterns.Examples:* \"brown\".toSlice.all Char.isLower = true* \"brown and orange\".toSlice.all Char.isLower = false* \"aaaaaa\".toSlice.all 'a' = true* \"aaaaaa\".toSlice.all \"aa\" = true\n\nFinds the position of the first match of the pattern pat in a slice true. If there\nis no match none is returned.This function is generic over all currently supported patterns.Examples:* (\"coffee tea water\".toSlice.find? Char.isWhitespace).map (·.get!) == some ' '* \"tea\".toSlice.find? (fun (c : Char) => c == 'X') == none* (\"coffee tea water\".toSlice.find? \"tea\").map (·.get!) == some 't'\n\nFinds the position of the first match of the pattern pat in a slice true, starting\nfrom the end of the slice and traversing towards the start. If there is no match none is\nreturned.This function is generic over all currently supported patterns except\nString/String.Slice.Examples:* (\"coffee tea water\".toSlice.find? Char.isWhitespace).map (·.get!) == some ' '* \"tea\".toSlice.find? (fun (c : Char) => c == 'X') == none* (\"coffee tea water\".toSlice.find? \"tea\").map (·.get!) == some 't'\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.7. Searching","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Searching"},"/Elaboration-and-Compilation/#parser":{"contents":"Lean's parser is a recursive-descent parser that uses dynamic tables based on Pratt parsing to resolve operator precedence and associativity.\nWhen grammars are unambiguous, the parser does not need to backtrack; in the case of ambiguous grammars, a memoization table similar to that used in Packrat parsing avoids exponential blowup.\nParsers are highly extensible: users may define new syntax in any command, and that syntax becomes available in the next command.\nThe open namespaces in the current section scope also influence which parsing rules are used, because parser extensions may be set to be active only when a given namespace is open.\n\nWhen ambiguity is encountered, the longest matching parse is selected.\nIf there is no unique longest match, then both matching parses are saved in the syntax tree in a choice node to be resolved later by the elaborator.\nWhen the parser fails, it returns a Syntax.missing node, allowing for error recovery.\n\nWhen successful, the parser saves sufficient information to reconstruct the original source file.\nUnsuccessful parses may miss some information for the regions of the file that cannot be parsed.\nThe SourceInfo record type records information about the origin of a piece of syntax, including its source location and the surrounding whitespace.\nBased on the SourceInfo field, there are three relationships that Syntax can have to a source file:\n\n* SourceInfo.original indicates that the syntax value was produced directly by the parser.* SourceInfo.synthetic indicates that the syntax value was produced programmatically, e.g. by the macro expander. Synthetic syntax may nonetheless be marked canonical, in which case the Lean user interface treats it as if the user had written it. Synthetic syntax is annotated with positions in the original file, but does not include leading or trailing whitespace.* SourceInfo.none indicates no relationship to a file.\n\nThe parser maintains a token table that tracks the reserved words that are currently part of the language.\nDefining new syntax or opening namespaces can cause a formerly-valid identifier to become a keyword.\n\nEach production in Lean's grammar is named.\nThe name of a production is called its kind.\nThese syntax kinds are important, because they are the key used to look up the interpretation of the syntax in the elaborator's tables.\n\nSyntax extensions are described in more detail in a dedicated chapter.\n\n","context":"Lean Reference\u0009Elaboration and Compilation","header":"2.1. Parsing","id":"/Elaboration-and-Compilation/#parser"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Early-Return":{"contents":"Early return terminates a computation immediately with a given value.\nThe value is returned from the closest containing do block; however, this may not be the closest do keyword.\nThe rules for determining the extent of a do block are described in their own section.\n\nEarly Return\n\nNot all monads include early return.\nThus, when a do block contains return, the code needs to be rewritten to simulate the effect.\nA program that uses early return to compute a value of type α in a monad m can be thought of as a program in the monad ExceptT α m α: early-returned values take the exception pathway, while ordinary returns do not.\nThen, an outer handler can return the value from either code paths.\nInternally, the do elaborator performs a translation very much like this one.\n\nOn its own, return is short for return​ ​().\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.2. Early Return","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Early-Return"},"/Notations-and-Macros/Defining-New-Syntax/#syntax-categories":{"contents":"Lean's parser contains a table of syntax categories, which correspond to nonterminals in a context-free grammar.\nSome of the most important categories are terms, commands, universe levels, priorities, precedences, and the categories that represent tokens such as literals.\nTypically, each syntax kind corresponds to a category.\nNew categories can be declared using declare_syntax_cat.\n\nDeclaring Syntactic CategoriesDeclares a new syntactic category.\n\nThe leading identifier behavior is an advanced feature that usually does not need to be modified.\nIt controls the behavior of the parser when it encounters an identifier, and can sometimes cause the identifier to be treated as a non-reserved keyword instead.\nThis is used to avoid turning the name of every tactic into a reserved keyword.\n\nSpecifies how the parsing table lookup function behaves for identifiers.The function Lean.Parser.prattParser uses two tables: one each for leading and trailing parsers.\nThese tables map tokens to parsers. Because keyword tokens are distinct from identifier tokens,\nkeywords and identifiers cannot be confused, even when they are syntactically identical.\nSpecifying an alternative leading identifier behavior allows greater flexibility and makes it\npossible to avoid reserved keywords in some situations.When the leading token is syntactically an identifier, the current syntax category's\nLeadingIdentBehavior specifies how the parsing table lookup function behaves, and allows\ncontrolled “punning” between identifiers and keywords. This feature is used to avoid creating a\nreserved symbol for each built-in tactic (e.g., apply or assumption). As a result, tactic names\ncan be used as identifiers.If the leading token is an identifier, then the parser just executes the parsers associated\nwith the auxiliary token “ident”, which parses identifiers.If the leading token is an identifier <foo>, and there are parsers P associated with the token\n<foo>, then the parser executes P. Otherwise, it executes only the parsers associated with the\nauxiliary token “ident”, which parses identifiers.If the leading token is an identifier <foo>, then it executes the parsers associated with token\n<foo> and parsers associated with the auxiliary token “ident”, which parses identifiers.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.10. Syntax Categories","id":"/Notations-and-Macros/Defining-New-Syntax/#syntax-categories"},"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax":{"contents":"Syntax may additionally be annotated with a type that specifies which syntax category it belongs to.\n\nThe TSyntax structure contains a type-level list of syntax categories along with a syntax tree.\nThe list of syntax categories typically contains precisely one element, in which case the list structure itself is not shown.\n\nTyped syntax, which tracks the potential kinds of the Syntax it contains.While syntax quotations produce or expect TSyntax values of the correct kinds, this is not\notherwise enforced; it can easily be circumvented by direct use of the constructor.The underlying Syntax value.\n\nSyntaxNodeKinds is a set of SyntaxNodeKind, implemented as a list.Singleton SyntaxNodeKinds are extremely common. They are written as name literals, rather than as\nlists; list syntax is required only for empty or non-singleton sets of kinds.\n\nQuasiquotations prevent the substitution of typed syntax that does not come from the correct syntactic category.\nFor many of Lean's built-in syntactic categories, there is a set of coercions that appropriately wrap one kind of syntax for another category, such as a coercion from the syntax of string literals to the syntax of terms.\nAdditionally, many helper functions that are only valid on some syntactic categories are defined for the appropriate typed syntax only.\n\n\n\nThe constructor of TSyntax is public, and nothing prevents users from constructing values that break internal invariants.\nThe use of TSyntax should be seen as a way to reduce common mistakes, rather than rule them out entirely.\n\nIn addition to TSyntax, there are types that represent arrays of syntax, with or without separators.\nThese correspond to  repeated elements in syntax declarations or antiquotations.\n\nAn array of syntaxes of kind ks.\n\nAn array of syntax elements that alternate with the given separator. Each syntax element has a kind\ndrawn from ks.Separator arrays result from repetition operators such as ,*.\nCoercions to and from Array (TSyntax ks) insert or remove\nseparators as required. The untyped equivalent is Lean.Syntax.SepArray.The array of elements and separators, ordered like\n#[el1, sep1, el2, sep2, el3].\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.7. Typed Syntax","id":"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-iteration":{"contents":"iterate n tac runs tac exactly n times.\niterate tac runs tac repeatedly until failure.iterate's argument is a tactic sequence,\nso multiple tactics can be run using iterate n (tac₁; tac₂; ⋯) oriterate n\n  tac₁\n  tac₂\n  ⋯\n\n\nrepeat tac repeatedly applies tac so long as it succeeds.\nThe tactic tac may be a tactic sequence, and if tac fails at any point in its execution,\nrepeat will revert any partial changes that tac made to the tactic state.The tactic tac should eventually fail, otherwise repeat tac will run indefinitely.See also:* try tac is like repeat tac but will apply tac at most once.* repeat' tac recursively applies tac to each goal.* first | tac1 | tac2 implements the backtracking used by repeat\n\nrepeat' tac recursively applies tac on all of the goals so long as it succeeds.\nThat is to say, if tac produces multiple subgoals, then repeat' tac is applied to each of them.See also:* repeat tac simply repeatedly applies tac.* repeat1' tac is repeat' tac but requires that tac succeed for some goal at least once.\n\nrepeat1' tac recursively applies to tac on all of the goals so long as it succeeds,\nbut repeat1' tac fails if tac succeeds on none of the initial goals.See also:* repeat tac simply applies tac repeatedly.* repeat' tac is like repeat1' tac but it does not require that tac succeed at least once.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures","header":"13.3.1.5. Repetition and Iteration","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-iteration"}});