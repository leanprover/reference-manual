window.docContents[170].resolve({"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax-helpers":{"contents":"For literals, Lean's parser produces a singleton node that contains an atom.\nThe inner atom contains a string with source information, while the node's kind specifies how the atom is to be interpreted.\nThis may involve decoding string escape sequences or interpreting base-16 numeric literals.\nThe helpers in this section perform the correct interpretation.\n\nExtracts the parsed name from the syntax of an identifier.Returns Name.anonymous if the syntax is malformed.\n\nDecodes a quoted name literal, returning the name.Returns Lean.Name.anonymous if the syntax is malformed.\n\nInterprets a numeric literal as a natural number.Returns 0 if the syntax is malformed.\n\nExtracts the components of a scientific numeric literal.Returns a triple (n, sign, e) : Nat × Bool × Nat; the number's value is given by:if sign then n * 10 ^ (-e) else n * 10 ^ e\nReturns (0, false, 0) if the syntax is malformed.\n\nDecodes a string literal, removing quotation marks and unescaping escaped characters.Returns \"\" if the syntax is malformed.\n\nDecodes a character literal.Returns (default : Char) if the syntax is malformed.\n\nDecodes macro hygiene information.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.9. Helpers for Typed Syntax","id":"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax-helpers"},"/Notations-and-Macros/Macros/#quotation":{"contents":"Quotation marks code for representation as data of type Syntax.\nQuoted code is parsed, but not elaborated—while it must be syntactically correct, it need not make sense.\nQuotation makes it much easier to programmatically generate code: rather than reverse-engineering the specific nesting of node values that Lean's parser would produce, the parser can be directly invoked to create them.\nThis is also more robust in the face of refactoring of the grammar that may change the internals of the parse tree without affecting the user-visible concrete syntax.\nQuotation in Lean is surrounded by `( and ).\n\nThe syntactic category or parser being quoted may be indicated by placing its name after the opening backtick and parenthesis, followed by a vertical bar (|).\nAs a special case, the name tactic may be used to parse either tactics or sequences of tactics.\nIf no syntactic category or parser is provided, Lean attempts to parse the quotation both as a term and as a non-empty sequence of commands.\nTerm quotations have higher priority than command quotations, so in cases of ambiguity, the interpretation as a term is chosen; this can be overridden by explicitly indicating that the quotation is of a command sequence.\n\nTerm vs Command Quotation SyntaxIn the following example, the contents of the quotation could either be a function application or a sequence of commands.\nBoth match the same region of the file, so the local longest-match rule is not relevant.\nTerm quotation has a higher priority than command quotation, so the quotation is interpreted as a term.\nTerms expect their antiquotations to have type TSyntax `term rather than TSyntax `command.example (cmd1 cmd2 : TSyntax `command) : MacroM (TSyntax `command) :=\n  `($cmd1 $cmd2)\nThe result is two type errors like the following:Application type mismatch: The argument\n  cmd1\nhas type\n  TSyntax `command\nbut is expected to have type\n  TSyntax `term\nin the application\n  cmd1.raw\nThe type of the quotation (MacroM (TSyntax `command)) is not used to select a result because syntax priorities are applied prior to elaboration.\nIn this case, specifying that the antiquotations are commands resolves the ambiguity because function application would require terms in these positions:example (cmd1 cmd2 : TSyntax `command) : MacroM (TSyntax `command) :=\n  `($cmd1:command $cmd2:command)\nSimilarly, inserting a command into the quotation eliminates the possibility that it could be a term:example (cmd1 cmd2 : TSyntax `command) : MacroM (TSyntax `command) :=\n  `($cmd1 $cmd2 #eval \"hello!\")\n\n\n\n\nQuotationsLean's syntax includes quotations for terms, commands, tactics, and sequences of tactics, as well as a general quotation syntax that allows any input that Lean can parse to be quoted.\nTerm quotations have the highest priority, followed by tactic quotations, general quotations, and finally command quotations.\n\n\n\nRather than having type Syntax, quotations are monadic actions with type m Syntax.\nQuotation is monadic because it implements hygiene by adding macro scopes and pre-resolving identifiers, as described in the section on hygiene.\nThe specific monad to be used is an implicit parameter to the quotation, and any monad for which there is an instance of the MonadQuotation type class is suitable.\nMonadQuotation extends MonadRef, which gives the quotation access to the source location of the syntax that the macro expander or elaborator is currently processing. MonadQuotation additionally includes the ability to add macro scopes to identifiers and use a fresh macro scope for a sub-task.\nMonads that support quotation include MacroM, TermElabM, CommandElabM, and TacticM.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros","header":"20.5.3. Quotation","id":"/Notations-and-Macros/Macros/#quotation"},"/The-Type-System/Inductive-Types/#inductive-declarations-deriving-instances":{"contents":"The optional deriving clause of an inductive type declaration can be used to derive instances of type classes.\nPlease refer to the section on instance deriving for more information.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","header":"4.4.1.4. Deriving Instances","id":"/The-Type-System/Inductive-Types/#inductive-declarations-deriving-instances"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Lake":{"contents":"* #6829 changes the error message for Lake configuration failure to\nreflect that issues do not always arise from an invalid lakefile, but\nsometimes arise from other issues like network errors. The new error\nmessage encompasses all of these possibilities.* #6929 passes the shared library of the previous stage's Lake as a\nplugin to the next stage's Lake in the CMake build. This enables Lake to\nuse its own builtin elaborators / initializers at build time.* #7001 adds support for plugins to Lake. Precompiled modules are now\nloaded as plugins rather than via --load-dynlib.* #7024 documents how to use Elan's + option with lake new|init. It\nalso provides an more informative error message if a + option leaks\ninto Lake (e.g., if a user provides the option to a Lake run without\nElan).* #7157 changes lake setup-file to now use Lake as a plugin for files\nwhich import Lake (or one of its submodules). Thus, the server will now\nload Lake as a plugin when editing a Lake configuration written in Lean.\nThis further enables the use of builtin language extensions in Lake.* #7171 changes the Lake DSL to use builtin elaborators, macros, and\ninitializers.* #7182 makes lake setup-file succeed on an invalid Lean configuration\nfile.* #7209 fixes broken Lake tests on Windows' new MSYS2. As of MSYS2\n0.0.20250221, OSTYPE is now reported as cygwin instead of msys,\nwhich must be accounted for in a few Lake tests.* #7211 changes the job monitor to perform run job computation itself as\na separate job. Now progress will be reported eagerly, even before all\noutstanding jobs have been discovered. Thus, the total job number\nreported can now grow while jobs are still being computed (e.g., the Y\nin [X/Y[ may increase).* #7233 uses the Lake plugin when Lake is built with Lake via\nUSE_LAKE.* #7291 changes the Lake job monitor to display the last (i.e., newest)\nrunning/unfinished job rather than the first. This avoids the monitor\nfocusing too long on any one job (e.g., \"Running job computation\").* #7399 reverts the new builtin initializers, elaborators, and macros in\nLake back to non-builtin.* #7608 removes the use of the Lake plugin in the Lake build and in\nconfiguration files.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Lake","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Lake"}});