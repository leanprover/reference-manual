window.docContents[198].resolve({"/Attributes/#The-Lean-Language-Reference--Attributes--The--attribute--Command":{"contents":"The attribute command can be used to modify a declaration's attributes.\nSome example uses include:\n\n* registering a pre-existing declaration as an instance in the local scope by adding instance,* marking a pre-existing theorem as a simp lemma or an extensionality lemma, using simp or ext, and* temporarily removing a simp lemma from the default simp set.\n\nAttribute ModificationThe attribute command adds or removes attributes from an existing declaration.\nThe identifier is the name whose attributes are being modified.\n\nIn addition to attribute instances that add an attribute to an existing declaration, some attributes can be removed; this is called erasing the attribute.\nAttributes can be erased by preceding their name with -.\nNot all attributes support erasure, however.\n\nErasing AttributesAttributes are erased by preceding their name with a -.\n\n","context":"Lean Reference\u0009Attributes","header":"9.2. The  attribute  Command","id":"/Attributes/#The-Lean-Language-Reference--Attributes--The--attribute--Command"},"/Basic-Types/Natural-Numbers/#nat-api-comparison":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"19.1.4.5. Comparisons","id":"/Basic-Types/Natural-Numbers/#nat-api-comparison"},"/Terms/Identifiers/#The-Lean-Language-Reference--Terms--Identifiers--Leading--___":{"contents":"When an identifier begins with a dot (.), the type that the elaborator expects for the expression is used to resolve it, rather than the current namespace and set of open namespaces.\nGeneralized field notation is related: leading dot notation uses the expected type of the identifier to resolve it to a name, while field notation uses the inferred type of the term immediately prior to the dot.\n\nIdentifiers with a leading . are to be looked up in the expected type's namespace.\nIf the type expected for a term is a constant applied to zero or more arguments, then its namespace is the constant's name.\nIf the type is not an application of a constant (e.g., a function, a metavariable, or a universe) then it doesn't have a namespace.\n\nIf the name is not found in the expected type's namespace, but the constant can be unfolded to yield another constant, then its namespace is consulted.\nThis process is repeated until something other than an application of a constant is encountered, or until the constant can't be unfolded.\n\nLeading .The expected type for .replicate is List Unit.\nThis type's namespace is List, so .replicate resolves to List.replicate.#eval show List Unit from .replicate 3 ()\n[(), (), ()]\nLeading . and Unfolding DefinitionsThe expected type for .replicate is MyList Unit.\nThis type's namespace is MyList, but there is no definition MyList.replicate.\nUnfolding MyList Unit yields List Unit, so .replicate resolves to List.replicate.def MyList α := List α\n#eval show MyList Unit from .replicate 3 ()\n[(), (), ()]\n\n\n","context":"Lean Reference\u0009Terms\u0009Identifiers","header":"10.1.1. Leading  .","id":"/Terms/Identifiers/#The-Lean-Language-Reference--Terms--Identifiers--Leading--___"},"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Predicativity":{"contents":"Each universe contains dependent function types, which additionally represent universal quantification and implication.\nA function type's universe is determined by the universes of its argument and return types.\nThe specific rules depend on whether the return type of the function is a proposition.\n\nPredicates, which are functions that return propositions (that is, where the result of the function is some type in Prop) may have argument types in any universe whatsoever, but the function type itself remains in Prop.\nIn other words, propositions feature impredicative  quantification, because propositions can themselves be statements about all propositions (and all other types).\n\nImpredicativityProof irrelevance can be written as a proposition that quantifies over all propositions:example : Prop := ∀ (P : Prop) (p1 p2 : P), p1 = p2\nA proposition may also quantify over all types, at any given level:example : Prop := ∀ (α : Type), ∀ (x : α), x = x\nexample : Prop := ∀ (α : Type 5), ∀ (x : α), x = x\n\n\nFor universes at level 1 and higher (that is, the Type u hierarchy), quantification is predicative. \nFor these universes, the universe of a function type is the least upper bound of the argument and return types' universes.\n\nUniverse levels of function typesBoth of these types are in Type 2:example (α : Type 1) (β : Type 2) : Type 2 := α → β\nexample (α : Type 2) (β : Type 1) : Type 2 := α → β\n\n\nPredicativity of TypeThis example is not accepted, because α's level is greater than 1. In other words, the annotated universe is smaller than the function type's universe:example (α : Type 2) (β : Type 1) : Type 1 := α → β\nType mismatch\n  α → β\nhas type\n  Type 2\nof sort `Type 3` but is expected to have type\n  Type 1\nof sort `Type 2`\n\n\nLean's universes are not cumulative; a type in Type u is not automatically also in Type (u + 1).\nEach type inhabits precisely one universe.\n\nNo cumulativityThis example is not accepted because the annotated universe is larger than the function type's universe:example (α : Type 2) (β : Type 1) : Type 3 := α → β\nType mismatch\n  α → β\nhas type\n  Type 2\nof sort `Type 3` but is expected to have type\n  Type 3\nof sort `Type 4`\n\n\n","context":"Lean Reference\u0009Type System\u0009Universes","header":"4.3.1. Predicativity","id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Predicativity"},"/releases/v4.5.0/#release-v4___5___0":{"contents":"* Modify the lexical syntax of string literals to have string gaps, which are escape sequences of the form \"\\\" newline whitespace*.\nThese have the interpretation of an empty string and allow a string to flow across multiple lines without introducing additional whitespace.\nThe following is equivalent to \"this is a string\".\"this is \\\n   a string\"\nPR #2821 and RFC #2838.* Add raw string literal syntax. For example, r\"\\n\" is equivalent to \"\\\\n\", with no escape processing.\nTo include double quote characters in a raw string one can add sufficiently many # characters before and after\nthe bounding \"s, as in r#\"the \"the\" is in quotes\"# for \"the \\\"the\\\" is in quotes\".\nPR #2929 and issue #1422.* The low-level termination_by' clause is no longer supported.Migration guide: Use termination_by instead, e.g.:-termination_by' measure (fun ⟨i, _⟩ => as.size - i)\n+termination_by i _ => as.size - i\nIf the well-founded relation you want to use is not the one that the\nWellFoundedRelation type class would infer for your termination argument,\nyou can use WellFounded.wrap from the std library to explicitly give one:-termination_by' ⟨r, hwf⟩\n+termination_by x => hwf.wrap x\n* Support snippet edits in LSP TextEdits. See Lean.Lsp.SnippetString for more details.* Deprecations and changes in the widget API.* Widget.UserWidgetDefinition is deprecated in favour of Widget.Module. The annotation @[widget] is deprecated in favour of @[widget_module]. To migrate a definition of type UserWidgetDefinition, remove the name field and replace the type with Widget.Module. Removing the name results in a title bar no longer being drawn above your panel widget. To add it back, draw it as part of the component using <details open=true><summary class='mv2 pointer'>{name}</summary>{rest_of_widget}</details>. See an example migration here.* The new command show_panel_widgets allows displaying always-on and locally-on panel widgets.* RpcEncodable widget props can now be stored in the infotree.* See RFC 2963 for more details and motivation.* If no usable lexicographic order can be found automatically for a termination proof, explain why.\nSee feat: GuessLex: if no measure is found, explain why.* Option to print inferred termination argument.\nWith set_option showInferredTerminationBy true you will get messages likeInferred termination argument:\ntermination_by\nackermann n m => (sizeOf n, sizeOf m)\nfor automatically generated termination_by clauses.* More detailed error messages for invalid mutual blocks.* Multiple improvements to the output of simp? and simp_all?.* Tactics with withLocation * no longer fail if they close the main goal.* Implementation of a test_extern command for writing tests for @[extern] and @[implemented_by] functions.\nUsage isimport Lean.Util.TestExtern\n\ntest_extern Nat.add 17 37\nThe head symbol must be the constant with the @[extern] or @[implemented_by] attribute. The return type must have a DecidableEq instance.\n\nBug fixes for\n#2853, #2953, #2966,\n#2971, #2990, #3094.\n\nBug fix for eager evaluation of default value in Option.getD.\nAvoid panic in leanPosToLspPos when file source is unavailable.\nImprove short-circuiting behavior for List.all and List.any.\n\nSeveral Lake bug fixes: #3036, #3064, #3069.\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.5.0 (2024-02-01)","id":"/releases/v4.5.0/#release-v4___5___0"}});