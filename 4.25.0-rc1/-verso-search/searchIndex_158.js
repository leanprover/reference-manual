window.docContents[158].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Logical-Model":{"contents":"Array α is the type of dynamic arrays with elements\nfrom α. This type has special support in the runtime.Arrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed destructively. This results in performance comparable to mutable\narrays in imperative programming languages.An array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\nArray.size, but the capacity is not observable from Lean code. Array.emptyWithCapacity n creates\nan array which is equal to #[], but internally allocates an array of capacity n. When the size\nexceeds the capacity, allocation is required to grow the array.From the point of view of proofs, Array α is just a wrapper around List α.Converts a List α into an Array α.The function List.toArray is preferred.At runtime, this constructor is overridden by List.toArrayImpl and is O(n) in the length of\nthe list.Converts an Array α into a List α that contains the same elements in the same order.At runtime, this is implemented by Array.toListImpl and is O(n) in the length of the\narray.\n\nThe logical model of arrays is a structure that contains a single field, which is a list of elements.\nThis is convenient when specifying and proving properties of array-processing functions at a low level.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays","header":"19.16.1. Logical Model","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Logical-Model"},"/Basic-Types/Integers/#int-model":{"contents":"Integers are represented either as a natural number or as the negation of the successor of a natural number.\n\nThe integers.This type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for Int that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\nGMP). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).A natural number is an integer.This constructor covers the non-negative integers (from 0 to ∞).The negation of the successor of a natural number is an integer.This constructor covers the negative integers (from -1 to -∞).\n\nThis representation of the integers has a number of useful properties.\nIt is relatively simple to use and to understand.\nUnlike a pair of a sign and a Nat, there is a unique representation for 0, which simplifies reasoning about equality.\nIntegers can also be represented as a pair of natural numbers in which one is subtracted from the other, but this requires a quotient type to be well-behaved, and quotient types can be laborious to work with due to the need to prove that functions respect the equivalence relation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers","header":"19.2.1. Logical Model","id":"/Basic-Types/Integers/#int-model"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#exception-monads":{"contents":"Exception monads describe computations that terminate early (fail).\nFailing computations provide their caller with an exception value that describes why they failed.\nIn other words, computations either return a value or an exception.\nThe inductive type Except captures this pattern, and is itself a monad.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.7. Exceptions","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#exception-monads"},"/The-Type-System/Functions/#function-extensionality":{"contents":"Definitional equality of functions in Lean is intensional.\nThis means that definitional equality is defined syntactically, modulo renaming of bound variables and reduction.\nTo a first approximation, this means that two functions are definitionally equal if they implement the same algorithm, rather than the usual mathematical notion of equality that states that two functions are equal if they map equal elements of the domain to equal elements of the codomain.\n\nDefinitional equality is used by the type checker, so it's important that it be predictable.\nThe syntactic character of intensional equality means that the algorithm to check it can be feasibly specified.\nChecking extensional equality involves proving essentially arbitrary theorems about equality of functions, and there is no clear specification for an algorithm to check it.\nThis makes extensional equality a poor choice for a type checker.\nFunction extensionality is instead made available as a reasoning principle that can be invoked when proving the proposition that two functions are equal.\n\nIn addition to reduction and renaming of bound variables, definitional equality does support one limited form of extensionality, called η-equivalence, in which functions are equal to abstractions whose bodies apply them to the argument.\nGiven f with type (x : α) → β x, f is definitionally equal to fun x => f x.\n\nWhen reasoning about functions, the theorem funextUnlike some intensional type theories, funext is a theorem in Lean. It can be proved using quotient types. or the corresponding tactics funext or ext can be used to prove that two functions are equal if they map equal inputs to equal outputs.\n\nFunction extensionality. If two functions return equal results for all possible arguments, then\nthey are equal.It is called “extensionality” because it provides a way to prove two objects equal based on the\nproperties of the underlying mathematical functions, rather than based on the syntax used to denote\nthem. Function extensionality is a theorem that can be proved using quotient\ntypes.\n\n","context":"Lean Reference\u0009Type System\u0009Functions","header":"4.1.3. Extensionality","id":"/The-Type-System/Functions/#function-extensionality"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Lake":{"contents":"* #4384 deprecates inputFile and replaces it with inputBinFile and inputTextFile. Unlike inputBinFile (and inputFile), inputTextFile normalizes line endings, which helps ensure text file traces are platform-independent.* #4371 simplifies dependency resolution code.* #4439 touches up the Lake configuration DSL and makes other improvements:\nstring literals can now be used instead of identifiers for names,\navoids using French quotes in lake new and lake init templates,\nchanges the exe template to use Main for the main module,\nimproves the math template error if lean-toolchain fails to download,\nand downgrades unknown configuration fields from an error to a warning to improve cross-version compatibility.* #4496 tweaks require syntax and updates docs. Now require in TOML for a package name such as doc-gen4 does not need French quotes.* #4485 fixes a bug where package versions in indirect dependencies would take precedence over direct dependencies.* #4478 fixes a bug where Lake incorrectly included the module dynamic library in a platform-independent trace.* #4529 fixes some issues with bad import errors.\nA bad import in an executable no longer prevents the executable's root\nmodule from being built. This also fixes a problem where the location\nof a transitive bad import would not been shown.\nThe root module of the executable now respects nativeFacets.* #4564 fixes a bug where non-identifier script names could not be entered on the CLI without French quotes.* #4566 addresses a few issues with precompiled libraries.* Fixes a bug where Lake would always precompile the package of a module.* If a module is precompiled, it now precompiles its imports. Previously, it would only do this if imported.* #4495, #4692, #4849\nadd a new type of require that fetches package metadata from a\nregistry API endpoint (e.g. Reservoir) and then clones a Git package\nusing the information provided. To require such a dependency, the new\nsyntax is:require <scope> / <pkg-name> [@ git <rev>]\n-- Examples:\nrequire \"leanprover\" / \"doc-gen4\"\nrequire \"leanprover-community\" / \"proofwidgets\" @ git \"v0.0.39\"\nOr in TOML:[[require]]\nname = \"<pkg-name>\"\nscope = \"<scope>\"\nrev = \"<rev>\"\nUnlike with Git dependencies, Lake can make use of the richer\ninformation provided by the registry to determine the default branch of\nthe package. This means for repositories of packages like doc-gen4\nwhich have a default branch that is not master, Lake will now use said\ndefault branch (e.g., in doc-gen4's case, main).Lake also supports configuring the registry endpoint via an environment\nvariable: RESERVIOR_API_URL. Thus, any server providing a similar\ninterface to Reservoir can be used as the registry. Further\nconfiguration options paralleling those of Cargo's Alternative Registries\nand Source Replacement\nwill come in the future.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"Lake","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Lake"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Lean-internals":{"contents":"* #4391 makes getBitVecValue? recognize BitVec.ofNatLt.* #4410 adjusts instantiateMVars algorithm to zeta reduce let expressions while beta reducing instantiated metavariables.* #4420 fixes occurs check for metavariable assignments to also take metavariable types into account.* #4425 fixes forEachModuleInDir to iterate over each Lean file exactly once.* #3886 adds support to build Lean core oleans using Lake.* Defeq and WHNF algorithms* #4387 improves performance of isDefEq by eta reducing lambda-abstracted terms during metavariable assignments, since these are beta reduced during metavariable instantiation anyway.* #4388 removes redundant code in isDefEqQuickOther.* Typeclass inference* #4530 fixes handling of metavariables when caching results at synthInstance?.* Elaboration* #4426 makes feature where the \"don't know how to synthesize implicit argument\" error reports the name of the argument more reliable.* #4497 fixes a name resolution bug for generalized field notation (dot notation).* #4536 blocks the implicit lambda feature for (e :) notation.* #4562 makes it be an error for there to be two functions with the same name in a where/let rec block.* Recursion principles* #4549 refactors findRecArg, extracting withRecArgInfo.\nErrors are now reported in parameter order rather than the order they are tried (non-indices are tried first).\nFor every argument, it will say why it wasn't tried, even if the reason is obvious (e.g. a fixed prefix or is Prop-typed, etc.).* Porting core C++ to Lean* #4474 takes a step to refactor constructions toward a future port to Lean.* #4498 ports mk_definition_inferring_unsafe to Lean.* #4516 ports recOn construction to Lean.* #4517, #4653, and #4651 port below and brecOn construction to Lean.* Documentation* #4501 adds a more-detailed docstring for PersistentEnvExtension.* Other fixes or improvements* #4382 removes @[inline] attribute from NameMap.find?, which caused respecialization at each call site.* 5f9ded improves output of trace.Elab.snapshotTree.* #4424 removes \"you might need to open '{dir}' in your editor\" message that is now handled by Lake and the VS Code extension.* #4451 improves the performance of CollectMVars and FindMVar.* #4479 adds missing DecidableEq and Repr instances for intermediate structures used by the BitVec and Fin simprocs.* #4492 adds tests for a previous isDefEq issue.* 9096d6 removes PersistentHashMap.size.* #4508 fixes @[implemented_by] for functions defined by well-founded recursion.* #4509 adds additional tests for apply? tactic.* d6eab3 fixes a benchmark.* #4563 adds a workaround for a bug in IndPredBelow.mkBelowMatcher.* Cleanup: #4380, #4431, #4494, e8f768, de2690, d3a756, #4404, #4537.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"Lean internals","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Lean-internals"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Lake":{"contents":"* #7796 moves Lean's shared library path before the workspace's in\nLake's augmented environment (e.g., lake env).* #7809 fixes the order of libraries when loading them via\n--load-dynlib or --plugin in lean and when linking them into a\nshared library or executable. A Dynlib now tracks its dependencies and\nthey are topologically sorted before being passed to either linking or\nloading.* #7822 changes Lake to use normalized absolute paths for its various\nfiles and directories.* #7860 restores the use of builtins (e.g., initializer, elaborators,\nand macros) for DSL features and the use of the Lake plugin in the\nserver.* #7906 changes Lake build traces to track their mixed inputs. The\ntracked inputs are saved as part of the .trace file, which can\nsignificantly assist in debugging trace issues. In addition, this PR\ntweaks some existing Lake traces. Most significant, module olean traces\nno longer incorporate their module's source trace.* #7909 adds Lake support for building modules given their source file\npath. This is made use of in both the CLI and the sever.* #7963 adds helper functions to convert between Lake.EStateT and\nEStateM.* #7967 adds a bootstrap option to Lake which is used to identify the\ncore Lean package. This enables Lake to use the current stage's include\ndirectory rather than the Lean toolchains when compiling Lean with Lean\nin core.* #7987 fixes a bug in #7967 that broke external library linking.* #8026 fixes bugs in #7809 and #7909 that were not caught partially\nbecause the badImport test had been disabled.* #8048 moves the Lake DSL syntax into a dedicated module with minimal\nimports.* #8152 fixes a regression where non-precompiled module builds would\n--load-dynlib package extern_lib targets.* #8183 makes Lake tests much more verbose in output. It also fixes some\nbugs that had been missed due to disabled tests. Most significantly, the\ntarget specifier @pkg (e.g., in lake build) is now always\ninterpreted as a package. It was previously ambiguously interpreted due\nto changes in #7909.* #8190 adds documentation for native library options (e.g., dynlibs,\nplugins, moreLinkObjs, moreLinkLibs) and needs to the Lake\nREADME. It is also includes information about specifying targets on the\nLake CLI and in Lean and TOML configuration files.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Lake","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Lake"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Server":{"contents":"* #9966 adjusts the \"try this\" widget to be rendered as a widget message\nunder 'Messages', not a separate widget under a 'Suggestions' section.\nThe main benefit of this is that the message of the widget is not\nduplicated between 'Messages' and 'Suggestions'.* #10047 ensures that hovering over match displays the type of the\nmatch.* #10052 fixes a bug that caused the Lean server process tree to survive\nthe closing of VS Code.* #10249 speeds up auto-completion by a factor of ~3.5x through various\nperformance improvements in the language server. On one machine, with\nimport Mathlib, completing i used to take 3200ms and now instead\nyields a result in 920ms.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Server","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Server"}});