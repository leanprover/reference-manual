window.docContents[200].resolve({"/releases/v4.6.0/#release-v4___6___0":{"contents":"* Add custom simplification procedures (aka simprocs) to simp. Simprocs can be triggered by the simplifier on a specified term-pattern. Here is an small example:import Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat\n\ndef foo (x : Nat) : Nat :=\n  x + 10\n\n/--\nThe `simproc` `reduceFoo` is invoked on terms that match the pattern `foo _`.\n-/\nsimproc reduceFoo (foo _) :=\n  /- A term of type `Expr → SimpM Step -/\n  fun e => do\n    /-\n    The `Step` type has three constructors: `.done`, `.visit`, `.continue`.\n    * The constructor `.done` instructs `simp` that the result does\n      not need to be simplified further.\n    * The constructor `.visit` instructs `simp` to visit the resulting expression.\n    * The constructor `.continue` instructs `simp` to try other simplification procedures.\n\n    All three constructors take a `Result`. The `.continue` constructor may also take `none`.\n    `Result` has two fields `expr` (the new expression), and `proof?` (an optional proof).\n     If the new expression is definitionally equal to the input one, then `proof?` can be omitted or set to `none`.\n    -/\n    /- `simp` uses matching modulo reducibility. So, we ensure the term is a `foo`-application. -/\n    unless e.isAppOfArity ``foo 1 do\n      return .continue\n    /- `Nat.fromExpr?` tries to convert an expression into a `Nat` value -/\n    let some n ← Nat.fromExpr? e.appArg!\n      | return .continue\n    return .done { expr := Lean.mkNatLit (n+10) }\nWe disable simprocs support by using the command set_option simprocs false. This command is particularly useful when porting files to v4.6.0.\nSimprocs can be scoped, manually added to simp commands, and suppressed using -. They are also supported by simp?. simp only does not execute any simproc. Here are some examples for the simproc defined above.example : x + foo 2 = 12 + x := by\n  set_option simprocs false in\n    /- This `simp` command does not make progress since `simproc`s are disabled. -/\n    fail_if_success simp\n  simp_arith\n\nexample : x + foo 2 = 12 + x := by\n  /- `simp only` must not use the default simproc set. -/\n  fail_if_success simp only\n  simp_arith\n\nexample : x + foo 2 = 12 + x := by\n  /-\n  `simp only` does not use the default simproc set,\n  but we can provide simprocs as arguments. -/\n  simp only [reduceFoo]\n  simp_arith\n\nexample : x + foo 2 = 12 + x := by\n  /- We can use `-` to disable `simproc`s. -/\n  fail_if_success simp [-reduceFoo]\n  simp_arith\nThe command register_simp_attr <id> now creates a simp and a simproc set with the name <id>. The following command instructs Lean to insert the reduceFoo simplification procedure into the set my_simp. If no set is specified, Lean uses the default simp set.simproc [my_simp] reduceFoo (foo _) := ...\n* The syntax of the termination_by and decreasing_by termination hints is overhauled:* They are now placed directly after the function they apply to, instead of\nafter the whole mutual block.* Therefore, the function name no longer has to be mentioned in the hint.* If the function has a where clause, the termination_by and\ndecreasing_by for that function come before the where. The\nfunctions in the where clause can have their own termination hints, each\nfollowing the corresponding definition.* The termination_by clause can only bind “extra parameters”, that are not\nalready bound by the function header, but are bound in a lambda (:= fun x y z =>) or in patterns (| x, n + 1 => …). These extra parameters used to\nbe understood as a suffix of the function parameters; now it is a prefix.Migration guide: In simple cases just remove the function name, and any\nvariables already bound at the header. def foo : Nat → Nat → Nat := …\n-termination_by foo a b => a - b\n+termination_by a b => a - b\nor def foo : Nat → Nat → Nat := …\n-termination_by _ a b => a - b\n+termination_by a b => a - b\nIf the parameters are bound in the function header (before the :), remove them as well: def foo (a b : Nat) : Nat := …\n-termination_by foo a b => a - b\n+termination_by a - b\nElse, if there are multiple extra parameters, make sure to refer to the right\nones; the bound variables are interpreted from left to right, no longer from\nright to left: def foo : Nat → Nat → Nat → Nat\n   | a, b, c => …\n-termination_by foo b c => b\n+termination_by a b => b\nIn the case of a mutual block, place the termination arguments (without the\nfunction name) next to the function definition:-mutual\n-def foo : Nat → Nat → Nat := …\n-def bar : Nat → Nat := …\n-end\n-termination_by\n-  foo a b => a - b\n-  bar a => a\n+mutual\n+def foo : Nat → Nat → Nat := …\n+termination_by a b => a - b\n+def bar : Nat → Nat := …\n+termination_by a => a\n+end\nSimilarly, if you have (mutual) recursion through where or let rec, the\ntermination hints are now placed directly after the function they apply to:-def foo (a b : Nat) : Nat := …\n-  where bar (x : Nat) : Nat := …\n-termination_by\n-  foo a b => a - b\n-  bar x => x\n+def foo (a b : Nat) : Nat := …\n+termination_by a - b\n+  where\n+    bar (x : Nat) : Nat := …\n+    termination_by x\n\n-def foo (a b : Nat) : Nat :=\n-  let rec bar (x : Nat) :  Nat := …\n-  …\n-termination_by\n-  foo a b => a - b\n-  bar x => x\n+def foo (a b : Nat) : Nat :=\n+  let rec bar (x : Nat) : Nat := …\n+    termination_by x\n+  …\n+termination_by a - b\nIn cases where a single decreasing_by clause applied to multiple mutually\nrecursive functions before, the tactic now has to be duplicated.* The semantics of decreasing_by changed; the tactic is applied to all\ntermination proof goals together, not individually.This helps when writing termination proofs interactively, as one can focus\neach subgoal individually, for example using ·. Previously, the given\ntactic script had to work for all goals, and one had to resort to tactic\ncombinators like first: def foo (n : Nat) := … foo e1 … foo e2 …\n-decreasing_by\n-simp_wf\n-first | apply something_about_e1; …\n-      | apply something_about_e2; …\n+decreasing_by\n+all_goals simp_wf\n+· apply something_about_e1; …\n+· apply something_about_e2; …\nTo obtain the old behaviour of applying a tactic to each goal individually,\nuse all_goals: def foo (n : Nat) := …\n-decreasing_by some_tactic\n+decreasing_by all_goals some_tactic\nIn the case of mutual recursion each decreasing_by now applies to just its\nfunction. If some functions in a recursive group do not have their own\ndecreasing_by, the default decreasing_tactic is used. If the same tactic\nought to be applied to multiple functions, the decreasing_by clause has to\nbe repeated at each of these functions.* Modify InfoTree.context to facilitate augmenting it with partial contexts while elaborating a command. This breaks backwards compatibility with all downstream projects that traverse the InfoTree manually instead of going through the functions in InfoUtils.lean, as well as those manually creating and saving InfoTrees. See PR #3159 for how to migrate your code.* Add language server support for call hierarchy requests (PR #3082). The change to the .ilean format in this PR means that projects must be fully rebuilt once in order to generate .ilean files with the new format before features like \"find references\" work correctly again.* Structure instances with multiple sources (for example {a, b, c with x := 0}) now have their fields filled from these sources\nin strict left-to-right order. Furthermore, the structure instance elaborator now aggressively use sources to fill in subobject\nfields, which prevents unnecessary eta expansion of the sources,\nand hence greatly reduces the reliance on costly structure eta reduction. This has a large impact on mathlib,\nreducing total CPU instructions by 3% and enabling impactful refactors like leanprover-community/mathlib4#8386\nwhich reduces the build time by almost 20%.\nSee PR #2478 and RFC #2451.* Add pretty printer settings to omit deeply nested terms (pp.deepTerms false and pp.deepTerms.threshold) (PR #3201)* Add pretty printer options pp.numeralTypes and pp.natLit.\nWhen pp.numeralTypes is true, then natural number literals, integer literals, and rational number literals\nare pretty printed with type ascriptions, such as (2 : Rat), (-2 : Rat), and (-2 / 3 : Rat).\nWhen pp.natLit is true, then raw natural number literals are pretty printed as nat_lit 2.\nPR #2933 and RFC #3021.\n\nLake updates:\n\n* improved platform information & control #3226* lake update from unsupported manifest versions #3149\n\nOther improvements:\n\n* make intro be aware of let_fun #3115* produce simpler proof terms in rw #3121* fuse nested mkCongrArg calls in proofs generated by simp #3203* induction using followed by a general term #3188* allow generalization in let #3060, fixing #3065* reducing out-of-bounds swap! should return a, not `default`` #3197, fixing #3196* derive BEq on structure with Prop-fields #3191, fixing #3140* refine through more casesOnApp/matcherApp #3176, fixing #3175* do not strip dotted components from lean module names #2994, fixing #2999* fix deriving only deriving the first declaration for some handlers #3058, fixing #3057* do not instantiate metavariables in kabstract/rw for disallowed occurrences #2539, fixing #2538* hover info for cases h : ... #3084\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.6.0 (2024-02-29)","id":"/releases/v4.6.0/#release-v4___6___0"}});