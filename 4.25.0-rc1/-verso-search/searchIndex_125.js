window.docContents[125].resolve({"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-channels":{"contents":"Toolchains are specified by providing a toolchain identifier that is either a channel, which identifies a particular type of Lean release, and optionally an origin, or a custom toolchain name established by toolchain link.\nChannels may be:\n\n stable\n\nThe latest stable Lean release. Elan automatically tracks stable releases and offers to upgrade when a new one is released.\n\n beta\n\nThe latest release candidate. Release candidates are builds of Lean that are intended to become the next stable release. They are made available for widespread user testing.\n\n nightly\n\nThe latest nightly build. Nightly builds are useful for experimenting with new Lean features to provide feedback to the developers.\n\n A version number or specific nightly release\n\nEach Lean version number identifies a channel that contains only that release.\n    The version number may optionally be preceded with a v, so v4.17.0 and 4.17.0 are equivalent.\n    Similarly, nightly-YYYY-MM-DD specifies the nightly release from the specified date.\n    A project's toolchain file should typically contain a specific version of Lean, rather than a general channel, to make it easier to coordinate between developers and to build and test older versions of the project.\n    An archive of Lean releases and nightly builds is maintained.\n\n A custom local toolchain\n\nThe command toolchain link can be used to establish a custom toolchain name in Elan for a local build of Lean.\n    This is especially useful when working on the Lean compiler itself.\n\n\n\nSpecifying an origin instructs Elan to install Lean toolchains from a particular source.\nBy default, this is the official project repository on GitHub, identified as leanprover/lean4.\nIf specified, an origin should precede the channel, with a colon, so stable is equivalent to leanprover/lean4:stable.\nWhen installing nightly releases, -nightly is appended to the origin, so leanprover/lean4:nightly-2025-03-25 consults the leanprover/lean4-nightly repository to download releases.\nOrigins are not used for custom toolchain names.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Selecting Toolchains","header":"22.2.1.1. Toolchain Identifiers","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-channels"},"/Notations-and-Macros/Elaborators/#elaborators":{"contents":"While macros allow Lean to be extended by translating new syntax into existing syntax, elaborators allow the new syntax to be processed directly.\nElaborators have access to everything that Lean itself uses to implement each feature of the language.\nDefining a new elaborator allows a language extension to be just as powerful as any built-in feature of Lean.\n\nElaborators come in two varieties:* Command elaborators are used to add new commands to Lean.\n   Commands are implemented as side effects: they may add new constants to the global environment, extend compile-time tables such as the one that tracks instances, they can provide feedback in the form of information, warnings, or errors, and they have full access to the IO monad.\n   Command elaborators are associated with the syntax kinds that they can handle.* Term elaborators are used to implement new terms by translating the syntax into Lean's core type theory.\n   They can do everything that command elaborators can do, and they additionally have access to the local context in which the term is being elaborated.\n   Term elaborators can look up bound variables, bind new variables, unify two terms, and much more.\n   A term elaborator must return a value of type Lean.Expr, which is the AST of the core type theory.\n\nThis section provides an overview and a few examples of elaborators.\nBecause Lean's own elaborator uses the same tools, the source code of the elaborator is a good source of further examples.\nJust like macros, multiple elaborators may be associated with a syntax kind; they are tried in order, and elaborators may delegate to the next elaborator in the table by throwing the unsupportedSyntax exception.\n\nElaboration RulesThe elab_rules command takes a sequence of elaboration rules, specified as syntax pattern matches, and adds each as an elaborator.\nThe rules are attempted in order, before previously-defined elaborators, and later elaborators may add further options.\n\nCommands, terms, and tactics each maintain a table that maps syntax kinds to elaborators.\nThe syntax category for which the elaborator should be used is specified after the colon, and must be term, command, or tactic.\nThe <= binds the provided identifier to the current expected type in the context in which a term is being elaborated; it may only be used for term elaborators, and if present, then term is implied as the syntax category.\n\nElaborator AttributeElaborators can be directly associated with syntax kinds by applying the appropriate attributes.\nEach takes the name of a syntax kind and associates the definition with the kind.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros","header":"20.6. Elaborators","id":"/Notations-and-Macros/Elaborators/#elaborators"},"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Candidate-Instances":{"contents":"Instance synthesis uses both local and global instances in its search.\nLocal instances are those available in the local context; they may be either parameters to a function or locally defined with let. \nLocal instances do not need to be indicated specially; any local variable whose type is a type class is a candidate for instance synthesis.\nGlobal instances are those available in the global environment; every global instance is a defined name with the instance attribute applied.instance declarations automatically apply the instance attribute.\n\nLocal InstancesIn this example, addPairs contains a locally-defined instance of Add NatPair:structure NatPair where\n  x : Nat\n  y : Nat\n\ndef addPairs (p1 p2 : NatPair) : NatPair :=\n  let _ : Add NatPair :=\n    ⟨fun ⟨x1, y1⟩ ⟨x2, y2⟩ => ⟨x1 + x2, y1 + y2⟩⟩\n  p1 + p2\nThe local instance is used for the addition, having been found by instance synthesis.\n\nLocal Instances Have PriorityHere, addPairs contains a locally-defined instance of Add NatPair, even though there is a global instance:structure NatPair where\n  x : Nat\n  y : Nat\n\ninstance : Add NatPair where\n  add\n    | ⟨x1, y1⟩, ⟨x2, y2⟩ => ⟨x1 + x2, y1 + y2⟩\n\ndef addPairs (p1 p2 : NatPair) : NatPair :=\n  let _ : Add NatPair :=\n    ⟨fun _ _ => ⟨0, 0⟩⟩\n  p1 + p2\nThe local instance is selected instead of the global one:#eval addPairs ⟨1, 2⟩ ⟨5, 2⟩\n{ x := 0, y := 0 }\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.3. Candidate Instances","id":"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--Candidate-Instances"},"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Documentation":{"contents":"* #5617 fixes MSYS2 build instructions.* #5725 points out that OfScientific is called with raw literals (@eric-wieser).* #5794 adds a stub for application ellipsis notation (@eric-wieser).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.14.0 (2024-12-02)","header":"Documentation","id":"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Documentation"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc1-_LPAR_2025-10-20_RPAR_--Language":{"contents":"* #7844 adds a simple implementation of MePo, from \"Lightweight\nrelevance filtering for machine-generated resolution problems\" by Meng\nand Paulson.* #10158 adds information about definitions blocked from unfolding via\nthe module system to type defeq errors.* #10268 adds an alternative implementation of DerivingBEq based on\ncomparing .ctorIdx and using a dedicated matcher for comparing same\nconstructors (added in #10152), to avoid the quadratic overhead of the\ndefault match implementation. The new option\nderiving.beq.linear_construction_threshold sets the constructor count\nthreshold (10 by default) for using the new construction. Such instances\nalso allow deriving ReflBEq, LawfulBeq, although these proofs for\nthese properties are still quadratic.* #10270 adds an alternative implementation of Deriving Ord based on\ncomparing .ctorIdx and using a dedicated matcher for comparing same\nconstructors (added in #10152). The new option\nderiving.ord.linear_construction_threshold sets the constructor count\nthreshold (10 by default) for using the new construction.* #10302 introduces the @[specs] attribute. It can be applied to\n(certain) type class instances and define “specification theorems” for\nthe class’ operations, by taking the equational theorems of the\nimplementation function mentioned in the type class instance and\nrephrasing them in terms of the overloaded operations. Fixes #5295.* #10333 introduces a coinductive keyword, that can be used to define\ncoinductive predicates via a syntax identical to the one for inductive\nkeyword. The machinery relies on the implementation of elaboration of\ninductive types and extracts an endomap on the appropriate space of the\npredicates from the definition that is then fed to the\nPartialFixpoint. Upon elaborating definitions, all the constructors\nare declared through automatically generated lemmas.* #10346 lets deriving BEq and deriving Ord use @[method_specs]\nfrom #10302 when applicable (i.e. when not using partial).* #10351 adds the ability to do deriving ReflBEq, LawfulBEq. Both\nclasses have to listed in the deriving clause. For ReflBEq, a simple\nsimp-based proof is used. For LawfulBEq, a dedicated,\nsyntax-directed tactic is used that should work for derived BEq\ninstances. This is meant to work with deriving BEq (but you can try to\nuse it on hand-rolled @[methods_specs] instance : BEq… instances).\nDoes not support mutual or nested inductives.* #10375 adds support for non-commutative ring normalization in grind.\nThe new normalizer also accounts for the IsCharP type class. Examples:open Lean Grind\n\nvariable (R : Type u) [Ring R]\nexample (a b : R) : (a + 2 * b)^2 = a^2 + 2 * a * b + 2 * b * a + 4 * b^2 := by grind\nexample (a b : R) : (a + 2 * b)^2 = a^2 + 2 * a * b + -b * (-4) * a - 2*b*a + 4 * b^2 := by grind\n\nvariable [IsCharP R 4]\nexample (a b : R) : (a - b)^2 = a^2 - a * b - b * 5 * a + b^2 := by grind\nexample (a b : R) : (a - b)^2 = 13*a^2 - a * b - b * 5 * a + b*3*b*3 := by grind\n* #10377 fixes an issue where the \"eta feature\" in the app elaborator,\nwhich is invoked when positional arguments are skipped due to named\narguments, results in variables that can be captured by those named\narguments. Now the temporary local variables that implement this feature\nget fresh names. The names used for the closed lambda expression still\nuse the original parameter names.* #10378 enables using notation items in\ninfix/infixl/infixr/prefix/postfix. The motivation for this is\nto enable being able to use pp.unicode-aware parsers. A followup PR\ncan combine core parsers as such:infixr:30 unicode(\" ∨ \", \" \\\\/ \") => Or\n* #10379 modifies the syntax for tactic configurations. Previously just\n(ident would commit to tactic configuration item parsing, but now it\nneeds to be (ident :=. This enables reliably using tactic\nconfigurations before the term category. For example, given syntax \"my_tac\" optConfig term : tactic, it used to be that my_tac (x + y)\nwould have an error on + with \"expected :=\", but now it parses the\nterm.* #10380 implements sanity checks in the grind ring module to ensure\nthe instances synthesized by type class resolution are definitionally\nequal to the corresponding ones in the grind core classes. The\ndefinitional equality test is performed with reduction restricted to\nreducible definitions and instances.* #10382 makes the builtin Verso docstring elaborators bootstrap\ncorrectly, adds the ability to postpone checks (which is necessary for\nresolving forward references and bootstrapping issues), and fixes a\nminor parser bug.* #10388 fixes a bug where definitions with nested proofs that contain\nsorry might not report \"warning: declaration uses 'sorry'\" if the\nproof has the same type as another nested proof from a previous\ndeclaration. The bug only affected log messages; #print axioms would\nstill correctly report uses of sorryAx.* #10391 gives anonymous constructor notation (⟨x,y⟩) an error recovery\nmechanism where if there are not enough arguments then synthetic sorries\nare inserted for the missing arguments and an error is logged, rather\nthan outright failing.* #10392 fixes an issue with the if tactic where errors were not placed\nat the correct source ranges. It also adds some error recovery to avoid\nadditional errors about unsolved goals on the if token when the tactic\nhas incomplete syntax.* #10394 adds the reduceBEq and reduceOrd simprocs. They rewrite\noccurrences of _ == _ resp. Ord.compare _ _ if both arguments are\nconstructors and the corresponding instance has been marked with\n@[method_specs] (introduced in #10302), which now by default is the\ncase for derived instances.* #10406 improves upon #10302 to properly make the method spec theorems\nprivate if the implementation function is not exposed.* #10415 changes the order of steps tried when proving equational\ntheorems for structural recursion. In order to avoid goals that split\ncannot handle, avoid unfolding the LHS of the equation to .brecOn and\n.rec until after the RHS has been split into its final cases.* #10417 changes the automation in deriving_LawfulEq_tactic_step to use\nwith_reducible when asserting the shape of the goal using change, so\nthat we do not accidentally unfold x == x' calls here. Fixes #10416.* #10419 adds the helper theorem eq_normS_nc for normalizing\nnon-commutative semirings. We will use this theorem to justify\nnormalization steps in the grind ring module.* #10421 adds a normalizer for non-commutative semirings to grind.\nExamples:open Lean.Grind\nvariable (R : Type u) [Semiring R]\n\nexample (a b c : R) : a * (b + c) = a * c + a * b := by grind\nexample (a b : R) : (a + 2 * b)^2 = a^2 + 2 * a * b + 2 * b * a + 4 * b^2 := by grind\nexample (a b : R) : b^2 + (a + 2 * b)^2 = a^2 + 2 * a * b + b * (1+1) * a * 1 + 5 * b^2 := by grind\nexample (a b : R) : a^3 + a^2*b + a*b*a + b*a^2 + a*b^2 + b*a*b + b^2*a + b^3 = (a+b)^3 := by grind\n* #10422 implements the new E-matching pattern inference heuristic for\ngrind. It is not enabled yet. You can activate the new behavior using\nset_option backward.grind.inferPattern false. Here is a summary of the\nnew behavior.* #10425 lets the split tactic generalize discriminants that are not\nfree variables and proofs using generalize. If the only\nnon-fvar-discriminants are proofs, then this avoids the more elaborate\ngeneralization strategy of split, which can fail with dependent\nmotives, thus mitigating issue #10424.* #10428 makes explicit missing grind modifiers, and ensures grind\nuses \"minIndexable\" for local theorems.* #10430 ensures users can select the \"minimal indexable subexpression\"\ncondition in grind parameters. Example, they can now write grind [! -> thmName]. grind? will include the ! modifier whenever users had\nused @[grind!]. also fixes a missing case in the new pattern\ninference procedure.\nIt also adjusts some grind annotations and tests in preparation for\nsetting the new pattern inference heuristic as the new default.* #10432 enables the new E-matching pattern inference heuristic for\ngrind, implemented in PR #10422.\nImportant: Users can still use the old pattern inference heuristic\nby setting:set_option backward.grind.inferPattern true\n* #10434 adds reprove N by T, which effectively elaborates example type_of% N := by T. It supports multiple identifiers. This is useful\nfor testing tactics.* #10438 fixes an issue where notations and other overloadings would\nsignal kernel errors even though there exists a successful\ninterpretation.* #10440 adds the reduceCtorIdx simproc which recognizes and reduces\nctorIdx applications. This is not on by default yet because it does\nnot use the discrimination tree (yet).* #10453 makes mvcgen reduce through lets, so that it progresses over\n(have t := 42; fun _ => foo t) 23 by reduction to have t := 42; foo t and then introducing t.* #10456 implements mvcgen invariants? for providing initial invariant\nskeletons for the user to flesh out. When the loop body has an early\nreturn, it will helpfully suggest Invariant.withEarlyReturn ... as a\nskeleton.* #10479 implements module docstrings in Verso syntax, as well as adding\na number of improvements and fixes to Verso docstrings in general. In\nparticular, they now have language server support and are parsed at\nparse time rather than elaboration time, so the snapshot's syntax tree\nincludes the parsed documentation.* #10506 annotates the shadowing main definitions of bv_decide,\nmvcgen and similar tactics in Std with the semantically richer\ntactic_alt attribute so that verso will not warn about overloads.* #10507 makes the missing docs linter aware of tactic_alt.* #10508 allows .congr_simp theorems to be created not just for\ndefinitoins, but any constant. This is important to make the machinery\nwork across module boundaries.* #10512 adds some helper functions for the premise selection API, to\nassist implementers.* #10533 adds a docstring role for module names, called module. It also\nimproves the suggestions provided for code elements, making them more\nrelevant and proposing lit.* #10535 ensures that #guard can be called under the module system\nwithout issues.* #10536 fixes simp in -zeta -zetaUnused mode from producing\nincorrect proofs if in a have telescope a variable occurrs in the\ntype of the body only transitively. Fixes #10353.* #10543 lets #print T.rec show more information about a recursor, in\nparticular it's reduction rules.* #10560 adds highlighted Lean code to Verso docstrings and fixes smaller\nquality-of-life issues.* #10563 moves some ReduceEval instances about basic types up from the\nquote4 library.* #10566 improves mvcgen invariants? to suggest concrete invariants\nbased on how invariants are used in VCs.\nThese suggestions are intentionally simplistic and boil down to \"this\nholds at the start of the loop and this must hold at the end of the\nloop\":def mySum (l : List Nat) : Nat := Id.run do\n  let mut acc := 0\n  for x in l do\n    acc := acc + x\n  return acc\n\n/--\ninfo: Try this:\n  invariants\n    · ⇓⟨xs, letMuts⟩ => ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝\n-/\n#guard_msgs (info) in\ntheorem mySum_suggest_invariant (l : List Nat) : mySum l = l.sum := by\n  generalize h : mySum l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants?\n  all_goals admit\n* #10567 fixes argument index calculation in Lean.Expr.getArg!'.* #10570 adds support for case label like syntax in mvcgen invariants\nin order to refer to inaccessible names. Example:def copy (l : List Nat) : Id (Array Nat) := do\n  let mut acc := #[]\n  for x in l do\n    acc := acc.push x\n  return acc\n\ntheorem copy_labelled_invariants (l : List Nat) : ⦃⌜True⌝⦄ copy l ⦃⇓ r => ⌜r = l.toArray⌝⦄ := by\n  mvcgen [copy] invariants\n  | inv1 acc => ⇓ ⟨xs, letMuts⟩ => ⌜acc = l.toArray⌝\n  with admit\n* #10571 ensures that SPred proof mode tactics such as mspec,\nmintro, etc. immediately replace the main goal when entering the proof\nmode. This prevents No goals to be solved errors.* #10612 fixes an issue reported on\nZulip\nwhere abstractMVars (which is used in typeclass inference and simp\nargument elaboration) was not instantiating metavariables in the types\nof metavariables, causing it to abstract already-assigned metavariables.* #10618 removes superfluous Monad instances from the spec lemmas of\nthe MonadExceptOf lifting framework.* #10638 disables the \"experimental\" warning for mvcgen by changing its\ndefault.* #10639 fixes hygiene of the local context for all goals generated by\nmvcgen, not just those that get a fresh MVar as in #9781.* #10641 ensures that the mspec and mvcgen tactics no longer\nspuriously instantiate loop invariants by rfl.* #10644 explicitly tries to synthesize synthetic MVars in mspec. Doing\nso resolves a bug triggered by use of the loop invariant lemma for\nStd.PRange.* #10650 improves the error message for mstart when the goal is not a\nProp.* #10654 avoid reducing at transparency all in equational theorem\ngeneration. Fixes #10651.* #10663 disables {name} suggestions for .anonymous and adds syntax\nsuggestions.* #10682 changes the instance name for deriving ToExpr to be consistent\nwith other derived instance since #10271. Fixes #10678.* #10697 lets induction print a warning if a variable occurring in the\nusing clause is generalized. Fixes #10683.* #10712 lets MVarId.cleanup chase local declarations (a bit as if they\nwere equalities). Fixes #10710.* #10714 removes support for reducible well-founded recursion, a Breaking\nChange. Using @[semireducible] on a definition by well-founded\nrecursion prints a warning that this is no longer effective.* #10716 adds a new helper parser for implementing parsers that contain\nhexadecimal numbers. We are going to use it to implement anchors in the\ngrind interactive mode.* #10720 re-enables the \"experimental\" warning for mvcgen by changing\nits default. The official release has been postponed to justify small\nbreaking changes in the semantic foundations in the near future.* #10722 changes where errors are displayed when trying to use\ncoinductive keyword when targeting things that do not live in Prop.\nInstead of displaying the error above the first element of the mutual\nblock, it is displayed above the erroneous definition.* #10733 unfolds auxillary theorems more aggressively during termination\nchecking. This fixes #10721.* #10734 follows upon #10606 and creates equational theorems uniformly\nfrom the unfold theorem, there is only one handler registered in\nregisterGetEqnsFn.* #10780 improves the error message when decide +kernel fails in the\nkernel, but not the elaborator. Fixes #10766.* #10782 implements a hint tactic mvcgen?, expanding to mvcgen invariants?* #10783 ensures that error messages such as “redundant alternative” have\nthe right error location even if the arms share their RHS. Fixes #10781.* #10793 fixes #10792.* #10796 changes match compilation to reject some pattern matches that\nwere previously accepted due to inaccessible patterns sometimes treated\nlike accessible ones. Fixes #10794.* #10807 introduces the backward.privateInPublic option to aid in\nporting projects to the module system by temporarily allowing access to\nprivate declarations from the public scope, even across modules. A\nwarning will be generated by such accesses unless\nbackward.privateInPublic.warn is disabled.* #10839 exposes the optionValue parser used to implement the\nset_option notation.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc1 (2025-10-20)","header":"Language","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc1-_LPAR_2025-10-20_RPAR_--Language"}});