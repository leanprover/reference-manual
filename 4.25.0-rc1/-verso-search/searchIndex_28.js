window.docContents[28].resolve({"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Concepts-and-Terminology--Artifact-Caches--Configuration":{"contents":"LAKECACHEKEY                authentication key for requests\n  LAKECACHEARTIFACTENDPOINT  base URL for artifact uploads\n  LAKECACHEREVISIONENDPOINT  base URL for the mapping upload\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology\u0009Artifact Caches","header":"22.1.1.6.3. Configuration","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Concepts-and-Terminology--Artifact-Caches--Configuration"},"/Source-Files-and-Modules/#module-structure":{"contents":"ModulesA module consists of a module header followed by a sequence of commands.\n\n\n\n\n\n","context":"Lean Reference\u0009Source Files and Modules","header":"5.3. Structure","id":"/Source-Files-and-Modules/#module-structure"},"/The-Type-System/Inductive-Types/#nested-inductive-types":{"contents":"Nested inductive types are inductive types in which recursive occurrences of the type being defined are parameters to other inductive type constructors.\nThese recursive occurrences are “nested” underneath the other type constructors.\nNested inductive types that satisfy certain requirements can be translated into mutual inductive types; this translation demonstrates that they are sound.\nInternally, the kernel performs this translation; if it succeeds, then the original nested inductive type is accepted.\nThis avoids performance and usability issues that would arise from details of the translation surfacing.\n\nNested recursive occurrences must satisfy the following requirements:* They must be nested directly under an inductive type's type constructor.\n  Terms that reduce to such nested occurrences are not accepted.* Local variables such as the constructor's parameters may not occur in the arguments to the nested occurrence.* The nested occurrences must occur strictly positively. They must occur strictly positively in the position in which they are nested, and the type constructor in which they are nested must itself occur in a strictly positive position.* Constructor parameters whose types include nested occurrences may not be used in ways that rely on the specific choice of outer type constructor. The translated version will not be usable in those contexts.* Nested occurrences may not be used as parameters to the outer type constructor that occur in the types of the outer type's indices.\n\nNested Inductive TypesInstead of using two constructors, the natural numbers can be defined using Option:inductive ONat : Type where\n  | mk (pred : Option ONat)\nArbitrarily-branching trees, also known as rose trees, are nested inductive types:inductive RTree (α : Type u) : Type u where\n  | empty\n  | node (val : α) (children : List (RTree α))\n\n\nInvalid Nested Inductive TypesThis declaration of arbitrarily-branching rose trees declares an alias for List, rather than using List directly:abbrev Children := List\n\ninductive RTree (α : Type u) : Type u where\n  | empty\n  | node (val : α) (children : Children (RTree α))\n(kernel) arg #3 of 'RTree.node' contains a non valid occurrence of the datatypes being declared\nThis declaration of arbitrarily-branching rose trees tracks the depth of the tree using an index.\nThe constructor DRTree.node has an automatic implicit parameter n that represents the depths of all sub-trees.\nHowever, local variables such as constructor parameters are not permitted as arguments to nested occurrences:inductive DRTree (α : Type u) : Nat → Type u where\n  | empty : DRTree α 0\n  | node (val : α) (children : List (DRTree α n)) : DRTree α (n + 1)\nThis declaration includes a non-strictly-positive occurrence of the inductive type, nested under an Option:inductive WithCheck where\n  | done\n  | check (f : Option WithCheck → Bool)\n(kernel) arg #1 of 'WithCheck.check' has a non positive occurrence of the datatypes being declared\nThis rose tree has a branching factor that's limited by its parameter:inductive BRTree (branches : Nat) (α : Type u) : Type u where\n  | mk :\n    (children : List (BRTree branches α)) →\n    children.length < branches →\n    BRTree branches α\nOnly nested inductive types that can be translated to mutual inductive types are allowed.\nHowever, translating this type would require a translation of List.length to the translated types, but function definitions may not occur in mutual blocks with inductive types.\nThe resulting error message shows that the function was not translated, but was applied to a term of the translated type:(kernel) application type mismatch\n  List.length children\nargument has type\n  @_nested.List_1 branches α\nbut function has type\n  List (@BRTree branches α) → Nat\nIt is acceptable to use the parameter with the nested occurrence with fully polymorphic functions, such as id:inductive RTree'' (α : Type u) : Type u where\n  | mk :\n    (children : List (BRTree branches α)) →\n    id children = children →\n    BRTree branches α\nIn this case, the function applies equally well to the translated version as it does to the original.A palindrome is a list that is the same when reversed:inductive Palindrome (α : Type) : List α → Prop where\n  | nil : Palindrome α []\n  | single : Palindrome α [x]\n  | cons (x : α) (p : Palindrome α xs) : Palindrome α (x :: xs ++ [x])\nIn this predicate, the list is an index whose type depends on the parameter, which is explicit for clarity.\nThis means it cannot be used\n\nThe translation from nested inductive types to mutual inductive types proceeds as follows:\n\n Nested occurrences become inductive types\n\nNested occurrences of the inductive type are translated into new inductive types in the same mutual group, which replace the original nested occurrences.\n  These new inductive types have the same constructors as the outer inductive type, except the original parameters are instantiated by the translated version of the type.\n  The original inductive type becomes an alias for the version in which the nested occurrences have been rewritten.\n  This process is repeated if the resulting type is also a nested inductive type (e.g. a type nested under Array becomes a type nested under List, because Array's constructor takes a List).\n\n Conversions to and from the nested types\n\nConversions between the outer inductive type applied to the new alias and the generated auxiliary types are generated.\n  These conversions are then proved to be mutual inverses.\n\n Constructor reconstruction\n\nEach constructor of the original type is defined as a function that returns the constructor of the translated type, after applying the appropriate conversions.\n\n Recursor reconstruction\n\nThe recursor for the nested inductive type is constructed from the recursor for the translated type.\n  In the translation, the motives for the nested occurrences are composed with the conversion functions and the minor premises use them as needed.\n  The proofs that the conversion functions are mutually inverse are needed because the encoded constructors convert in one direction, but end up applied to the result of the conversion in the other direction.\n\n\n\nTranslating Nested Inductive TypesThis nested inductive type represents the natural numbers:inductive ONat where\n  | mk (pred : Option ONat) : ONat\n\n#check ONat.rec\nThe first step in the internal translation is to replace the nested occurrences with auxiliary inductive types that “inline” the resulting type.\nIn this case, the nested occurrence is under Option; thus, the auxiliary type has the constructors of Option, with ONat' substituted for the type parameter:mutual\ninductive ONat' where\n  | mk (pred : OptONat) : ONat'\n\ninductive OptONat where\n  | none\n  | some : ONat' → OptONat\nend\nONat' is the encoding of ONat:def ONat := ONat'\nThe next step is to define conversion functions that translate the original nested type to and from the auxiliary type:def OptONat.ofOption : Option ONat → OptONat\n  | Option.none => OptONat.none\n  | Option.some o => OptONat.some o\ndef OptONat.toOption : OptONat → Option ONat\n  | OptONat.none => Option.none\n  | OptONat.some o => Option.some o\nThese conversion functions are mutually inverse:def OptONat.to_of_eq_id o :\n    OptONat.toOption (ofOption o) = o := by\n  cases o <;> rfl\ndef OptONat.of_to_eq_id o :\n    OptONat.ofOption (OptONat.toOption o) = o := by\n  cases o <;> rfl\nThe original constructor is translated to an application of the translation's corresponding constructor, with the appropriate conversion applied for the nested occurrence:def ONat.mk (pred : Option ONat) : ONat :=\n  ONat'.mk (.ofOption pred)\nFinally, the original type's recursor can be translated.\nThe translated recursor uses the translated type's recursor.\nThe original nested occurrences are translated using the conversions, and the proofs that the conversions are mutually inverse are used to rewrite types as needed.noncomputable def ONat.rec\n    {motive1 : ONat → Sort u}\n    {motive2 : Option ONat → Sort u}\n    (h1 :\n      (pred : Option ONat) → motive2 pred →\n      motive1 (ONat.mk pred))\n    (h2 : motive2 none)\n    (h3 : (o : ONat) → motive1 o → motive2 (some o)) :\n    (t : ONat) → motive1 t :=\n  @ONat'.rec motive1 (motive2 ∘ OptONat.toOption)\n    (fun pred ih =>\n      OptONat.of_to_eq_id pred ▸ h1 pred.toOption ih)\n    h2\n    h3\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","header":"4.4.5.4. Nested Inductive Types","id":"/The-Type-System/Inductive-Types/#nested-inductive-types"}});