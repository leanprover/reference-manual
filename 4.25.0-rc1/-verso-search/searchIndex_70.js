window.docContents[70].resolve({"/Basic-Types/Characters/#char-syntax":{"contents":"Character literals consist of a single character or an escape sequence enclosed in single quotes (', Unicode 'APOSTROPHE' (U+0027)).\nBetween these single quotes, the character literal may contain character other that ', including newlines, which are included literally (with the caveat that all newlines in a Lean source file are interpreted as '\\n', regardless of file encoding and platform).\nSpecial characters may be escaped with a backslash, so '\\'' is a character literal that contains a single quote.\nThe following forms of escape sequences are accepted:\n\n \\r, \\n, \\t, \\\\, \\\", \\'\n\nThese escape sequences have the usual meaning, mapping to CR, LF, tab, backslash, double quote, and single quote, respectively.\n\n \\xNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the two-digit hexadecimal code.\n\n \\uNNNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the four-digit hexadecimal code.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters","header":"19.7.3. Syntax","id":"/Basic-Types/Characters/#char-syntax"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration":{"contents":"Option can be thought of as a collection that contains at most one value.\nFrom this perspective, iteration operators can be understood as performing some operation on the contained value, if present, or doing nothing if not.\n\nChecks whether an optional value either satisfies a Boolean predicate or is none.Examples:* `(some 33).all (· % 2 == 0) = false* `(some 22).all (· % 2 == 0) = true* `none.all (fun x : Nat => x % 2 == 0) = true\n\nChecks whether an optional value is not none and satisfies a Boolean predicate.Examples:* `(some 33).any (· % 2 == 0) = false* `(some 22).any (· % 2 == 0) = true* `none.any (fun x : Nat => true) = false\n\nKeeps an optional value only if it satisfies a Boolean predicate.If Option is thought of as a collection that contains at most one element, then Option.filter is\nanalogous to List.filter or Array.filter.Examples:* (some 5).filter (· % 2 == 0) = none* (some 4).filter (· % 2 == 0) = some 4* none.filter (fun x : Nat => x % 2 == 0) = none* none.filter (fun x : Nat => true) = none\n\nKeeps an optional value only if it satisfies a monadic Boolean predicate.If Option is thought of as a collection that contains at most one element, then Option.filterM\nis analogous to List.filterM.\n\nExecutes a monadic action on an optional value if it is present, or does nothing if there is no\nvalue.Examples:#eval ((some 5).forM set : StateM Nat Unit).run 0\n((), 5)\n#eval (none.forM (fun x : Nat => set x) : StateM Nat Unit).run 0\n((), 0)\n\n\nApply a function to an optional value, if present.From the perspective of Option as a container with at most one value, this is analogous to\nList.map. It can also be accessed via the Functor Option instance.Examples:* (none : Option Nat).map (· + 1) = none* (some 3).map (· + 1) = some 4\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.This is an alias for Option.mapM, which already works for applicative functors.\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.Runs a monadic function f on an optional value, returning the result. If the optional value is\nnone, the function is not called and the result is also none.From the perspective of Option as a container with at most one element, this is analogous to\nList.mapM, returning the result of running the monadic function on all elements of the container.This function only requires m to be an applicative functor. An alias Option.mapA is provided.\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.5. Iteration","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration"},"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch--Examples":{"contents":"Typo in resulting typeinductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Treee α\n<invalid output>inductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Tree α\n\n\nMissing resulting type after constructor parameterinductive Credential where\n  | pin      : Nat\n  | password : String\n<invalid output>inductive Credential where\n  | pin      : Nat → Credential\n  | password : String → Credential\ninductive Credential where\n  | pin (num : Nat)\n  | password (str : String)\nIf the type of a constructor is annotated, the full type—including the resulting type—must be\nprovided. Alternatively, constructor parameters can be written using named binders; this allows the\nomission of the constructor's resulting type because it contains no indices.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.ctorResultingTypeMismatch","header":"Examples","id":"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch--Examples"},"/Error-Explanations/lean___propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--lean___propRecLargeElim--Examples":{"contents":"Defining an intermediate data value within a proofexample {α : Type} [inst : Nonempty α] (p : α → Prop) :\n    ∃ x, p x ∨ ¬ p x :=\n  let val :=\n    match inst with\n    | .intro x => x\n  ⟨val, Classical.em (p val)⟩\n<invalid output>example {α : Type} [inst : Nonempty α] (p : α → Prop) :\n    ∃ x, p x ∨ ¬ p x :=\n  match inst with\n  | .intro x => ⟨x, Classical.em (p x)⟩\nEven though the example being defined has a propositional type, the body of val does not; it has\ntype α : Type. Thus, pattern-matching on the proof of Nonempty α (a proposition) to produce\nval requires eliminating that proof into a non-propositional type and is disallowed. Instead, the\nmatch expression must be moved to the top level of the example, where the result is a\nProp-valued proof of the existential claim stated in the example's header. This restructuring\ncould also be done using a pattern-matching let binding.\n\nExtracting the witness from an existential proofdef getWitness {α : Type u} {p : α → Prop} (h : ∃ x, p x) : α :=\n  match h with\n  | .intro x _ => x\n<invalid output>-- This is `Exists.elim`\ntheorem useWitness {α : Type u} {p : α → Prop} {q : Prop}\n    (h : ∃ x, p x) (hq : (x : α) → p x → q) : q :=\n  match h with\n  | .intro x hx => hq x hx\ndef getWitness {α : Type u} {p : α → Prop}\n    (h : (x : α) ×' p x) : α :=\n  match h with\n  | .mk x _ => x\nIn this example, simply relocating the pattern-match is insufficient; the attempted definition\ngetWitness is fundamentally unsound. (Consider the case where p is fun (n : Nat) => n > 0: if\nh and h' are proofs of ∃ x, x > 0, with h using witness 1 and h' witness 2, then since\nh = h' by proof irrelevance, it follows that getWitness h = getWitness h'—i.e., 1 = 2.)Instead, getWitness must be rewritten: either the resulting type of the function must be a\nproposition (the first fixed example above), or h must not be a proposition (the second).In the first corrected example, the resulting type of useWitness is now a proposition q. This\nallows us to pattern-match on h—since we are eliminating into a propositional type—and pass the\nunpacked values to hq. From a programmatic perspective, one can view useWitness as rewriting\ngetWitness in continuation-passing style, restricting subsequent computations to use its result\nonly to construct values in Prop, as required by the prohibition on propositional large\nelimination. Note that useWitness is the existential elimination principle Exists.elim.The second corrected example changes the type of h from an existential proposition to a\nType-valued dependent pair (corresponding to the PSigma type constructor). Since this type is\nnot propositional, eliminating into α : Type u is no longer invalid, and the previously attempted\npattern match now type-checks.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.propRecLargeElim","header":"Examples","id":"/Error-Explanations/lean___propRecLargeElim/#The-Lean-Language-Reference--Error-Explanations--lean___propRecLargeElim--Examples"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors":{"contents":"Mutual inductive types are provided with primitive recursors, just like non-mutually-defined inductive types.\nThese recursors take into account that they must process the other types in the group, and thus will have a motive for each inductive type.\nBecause all inductive types in the mutual group are required to have identical parameters, the recursors still take the parameters first, abstracting them over the motives and the rest of the recursor.\nAdditionally, because the recursor must process the group's other types, it will require cases for each constructor of each of the types in the group.\nThe actual dependency structure between the types is not taken into account; even if an additional motive or constructor case is not really required due to there being fewer mutual dependencies than there could be, the generated recursor still requires them.\n\nEven and oddmutual\n  inductive Even : Nat → Prop where\n    | zero : Even 0\n    | succ : Odd n → Even (n + 1)\n  inductive Odd : Nat → Prop where\n    | succ : Even n → Odd (n + 1)\nend\nEven.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : {n : Nat} → (a : Odd n) → motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) →\n  ∀ {a : Nat} (t : Even a), motive_1 a t\nOdd.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) → ∀ {a : Nat} (t : Odd a), motive_2 a t\n\n\nSpuriously mutual typesThe types Two and Three are defined in a mutual block, even though they do not refer to each other:mutual\n  inductive Two (α : Type) where\n    | mk : α → α → Two α\n  inductive Three (α : Type) where\n    | mk : α → α → α → Three α\nend\nTwo's recursor, Two.rec, nonetheless requires a motive and a case for Three:Two.rec.{u} {α : Type}\n  {motive_1 : Two α → Sort u}\n  {motive_2 : Three α → Sort u}\n  (mk : (a a_1 : α) → motive_1 (Two.mk a a_1)) :\n  ((a a_1 a_2 : α) → motive_2 (Three.mk a a_1 a_2)) → (t : Two α) → motive_1 t\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","header":"4.4.5.2. Recursors","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors"}});