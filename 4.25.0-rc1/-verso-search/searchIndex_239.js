window.docContents[239].resolve({"/Attributes/#attributes":{"contents":"Attributes are an extensible set of compile-time annotations on declarations.\nThey can be added as a declaration modifier or using the attribute command.\n\nAttributes can associate information with declarations in compile-time tables (including custom simp sets, macros, and instances), impose additional requirements on definitions (e.g. rejecting them if their type is not a type class), or generate additional code.\nAs with macros and custom elaborators for terms, commands, and tactics, the syntax category attr of attributes is designed to be extended, and there is a table that maps each extension to a compile-time program that interprets it.\n\nAttributes are applied as attribute instances that pair a scope indicator with an attribute.\nThese may occur either in attributes as declaration modifiers or the stand-alone attribute command.\n\nAttribute InstancesAn attrKind is the optional attribute scope keywords local or scoped.\nThese control the visibility of the attribute's effects.\nThe attribute itself is anything from the extensible syntax category attr.\n\nThe attribute system is very powerful: attributes can associate arbitrary information with declarations and generate any number of helpers.\nThis imposes some design trade-offs: storing this information takes space, and retrieving it takes time.\nAs a result, some attributes can only be applied to a declaration in the module where the declaration is defined.\nThis allows lookups to be much faster in large projects, because they don't need to examine data for all modules.\nEach attribute determines how to store its own metadata and what the appropriate tradeoff between flexibility and performance is for a given use case.\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"9. Attributes","id":"/Attributes/#attributes"},"/Axioms/#axiom-consistency":{"contents":"Using axioms is risky.\nBecause they introduce a new constant of any type, and an inhabitant of a type that is a proposition counts as a proof of the proposition, axioms can be used to prove even false propositions.\nAny proof that relies on an axiom can be trusted only to the extent that the axiom is both true and consistent with the other axioms used.\nBy their very nature, Lean cannot check whether new axioms are consistent; please exercise care when adding axioms.\n\nInconsistencies From AxiomsAxioms may introduce inconsistency, either alone or in combination with other axioms.Assuming a false statement allows any statement at all to be proved:axiom false_is_true : False\n\ntheorem two_eq_five : 2 = 5 := false_is_true.elim\nInconsistency may also arise from axioms that are incompatible with other properties of Lean.\nFor example, parametricity is a powerful reasoning technique when used in languages that support it, but it is not compatible with Lean's standard axioms.\nIf parametricity held, then the “free theorem” from the introduction to Wadler's Theorems for Free (1989), which describes a technique for using parametricity to derive theorems about polymorphic functions, would be true.\nAs an axiom, it reads:axiom List.free_theorem {α β}\n  (f : {α : _} → List α → List α) (g : α → β) :\n  f ∘ (List.map g) = (List.map g) ∘ f\nHowever, a consequence of excluded middle is that all propositions are decidable; this means that a function can check whether they are true or false.\nThis function can't be compiled, but it still exists.\nThis can be used to define polymorphic functions that are not parametric:open Classical in\nnoncomputable def nonParametric\n    {α : _} (xs : List α) :\n    List α :=\n  if α = Nat then [] else xs\nThe existence of this function contradicts the “free theorem”:theorem unit_not_nat : Unit ≠ Nat := by\n  intro eq\n  have ⟨allEq⟩ := eq ▸ inferInstanceAs (Subsingleton Unit)\n  specialize allEq 0 1\n  contradiction\n\nexample : False := by\n  have := List.free_theorem nonParametric (fun () => 42)\n\n  unfold nonParametric at this\n  simp [unit_not_nat] at this\n\n  have := congrFun this [()]\n  contradiction\n\n\n","context":"Lean Reference\u0009Axioms","header":"8.2. Consistency","id":"/Axioms/#axiom-consistency"},"/Basic-Types/Lazy-Computations/#Thunk-model":{"contents":"Thunks are modeled as a single-field structure that contains a function from Unit.\nThe structure's field is private, so the function itself cannot be directly accessed.\nInstead, Thunk.get should be used.\nFrom the perspective of the logic, they are equivalent; Thunk.get exists to be overridden in the compiler by the platform primitive that implements lazy evaluation.\n\nDelays evaluation. The delayed code is evaluated at most once.A thunk is code that constructs a value when it is requested via Thunk.get, Thunk.map, or\nThunk.bind. The resulting value is cached, so the code is executed at most once. This is also\nknown as lazy or call-by-need evaluation.The Lean runtime has special support for the Thunk type in order to implement the caching\nbehavior.Constructs a new thunk from a function Unit → α that will be called when the thunk is first\nforced.The result is cached. It is re-used when the thunk is forced again.Extract the getter function out of a thunk. Use Thunk.get instead.\n\n","context":"Lean Reference\u0009Basic Types\u0009Lazy Computations","header":"19.20.1. Logical Model","id":"/Basic-Types/Lazy-Computations/#Thunk-model"},"/Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation--Macro-Expansion-and-Elaboration--Info-Trees":{"contents":"When interacting with Lean code, much more information is needed than when simply importing it as a dependency.\nFor example, Lean's interactive environment can be used to view the types of selected expressions, to step through all the intermediate states of a proof, to view documentation, and highlight all occurrences of a bound variable.\nThe information necessary to use Lean interactively is stored in a side table called the  info trees during elaboration.\n\n\n\nInfo trees relate metadata to the user's original syntax.\nTheir tree structure corresponds closely to the tree structure of the syntax, although a given node in the syntax tree may have many corresponding info tree nodes that document different aspects of it.\nThis metadata includes the elaborator's output in Lean's core language, the proof state active at a given point, suggestions for interactive identifier completion, and much more.\nThe metadata can also be arbitrarily extended; the constructor Info.ofCustomInfo accepts a Dynamic type.\nThis can be used to add information to be used by custom code actions or other user interface extensions.\n\n","context":"Lean Reference\u0009Elaboration and Compilation\u0009Macro Expansion and Elaboration","header":"2.2.1. Info Trees","id":"/Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation--Macro-Expansion-and-Elaboration--Info-Trees"},"/Namespaces-and-Sections/#scope-commands":{"contents":"The section command creates a new section scope, but does not modify the current namespace, opened namespaces, or section variables.\nChanges made to the section scope are reverted when the section ends.\nSections may optionally be named; the end command that closes a named section must use the same name.\nIf section names have multiple components (that is, if they contain .-separated names), then multiple nested sections are introduced.\nSection names have no other effect, and are a readability aid.\n\nSectionsThe section command creates a section scope that lasts either until an end command or the end of the file.\n\nNamed SectionThe name english is defined in the Greetings namespace.def Greetings.english := \"Hello\"\nOutside its namespace, it cannot be evaluated.#eval english\nUnknown identifier `english`\nOpening a section allows modifications to the global scope to be contained.\nThis section is named Greetings.section Greetings\nEven though the section name matches the definition's namespace, the name is not in scope because section names are purely for readability and ease of refactoring.#eval english\nUnknown identifier `english`\nOpening the namespace Greetings brings Greetings.english as english:open Greetings\n\n#eval english\n\"Hello\"\nThe section's name must be used to close it.end\nMissing name after `end`: Expected the current scope name `Greetings`\n\nHint: To end the current scope `Greetings`, specify its name:\n  end ̲G̲r̲e̲e̲t̲i̲n̲g̲s̲\nend Greetings\nWhen the section is closed, the effects of the open command are reverted.#eval english\nUnknown identifier `english`\n\n\nThe namespace command creates a new section scope.\nWithin this section scope, the current namespace is the name provided in the command, interpreted relative to the current namespace in the surrounding section scope.\nLike sections, changes made to the section scope are reverted when the namespace's scope ends.\n\nTo close a namespace, the end command requires a suffix of the current namespace, which is removed.\nAll section scopes introduced by the namespace command that introduced part of that suffix are closed.\n\nNamespace DeclarationsThe namespace command modifies the current namespace by appending the provided identifier.creates a section scope that lasts either until an end command or the end of the file.\n\nSection and Namespace TerminatorsWithout an identifier, end closes the most recently opened section, which must be anonymous.With an identifier, it closes the most recently opened section section or namespace.\nIf it is a section, the identifier must be a suffix of the concatenated names of the sections opened since the most recent namespace command.\nIf it is a namespace, then the identifier must be a suffix of the current namespace's extensions since the most recent section that is still open; afterwards, the current namespace will have had this suffix removed.\n\nThe end that closes a mutual block is part of the syntax of mutual, rather than the end command.\n\nNesting Namespaces and SectionsNamespaces and sections may be nested.\nA single end command may close one or more namespaces or one or more sections, but not a mix of the two.After setting the current namespace to A.B.C with two separate commands, B.C may be removed with a single end:namespace A.B\nnamespace C\nend B.C\nAt this point, the current namespace is A.Next, an anonymous section and the namespace D.E are opened:section\nnamespace D.E\nAt this point, the current namespace is A.D.E.\nAn end command cannot close all three due to the intervening section:end A.D.E\nInvalid name after `end`: Expected `D.E`, but found `A.D.E`\nInstead, namespaces and sections must be ended separately.end D.E\nend\nend A\n\n\nRather than opening a section for a single command, the in combinator can be used to create single-command section scope.\nThe in combinator is right-associative, allowing multiple scope modifications to be stacked.\n\nLocal Section ScopesThe in command combinator introduces a section scope for a single command.\n\nUsing in for Local ScopesThe contents of a namespace can be made available for a single command using in.def Dessert.cupcake := \"delicious\"\n\nopen Dessert in\n#eval cupcake\nAfter the single command, the effects of open are reverted.#eval cupcake\nUnknown identifier `cupcake`\n\n\n","context":"Lean Reference\u0009Namespaces and Sections\u0009Section Scopes","header":"6.2.1. Controlling Section Scopes","id":"/Namespaces-and-Sections/#scope-commands"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-casts":{"contents":"The tactics in this section make it easier avoid getting stuck on casts, which are functions that coerce data from one type to another, such as converting a natural number to the corresponding integer.\nThey are described in more detail by .\n\nThe norm_cast family of tactics is used to normalize certain coercions (casts) in expressions.* norm_cast normalizes casts in the target.* norm_cast at h normalizes casts in hypothesis h.The tactic is basically a version of simp with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal simp calls are discouraged (because of fragility),\nnorm_cast is considered to be safe.\nIt also has special handling of numerals.For instance, given an assumptiona b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\nwriting norm_cast at h will turn h intoh : a + b < 10\nThere are also variants of basic tactics that use norm_cast to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic modulo the effects of norm_cast):* exact_mod_cast for exact and apply_mod_cast for apply.\nWriting exact_mod_cast h and apply_mod_cast h will normalize casts\nin the goal and h before using exact h or apply h.* rw_mod_cast for rw. It applies norm_cast between rewrites.* assumption_mod_cast for assumption.\nThis is effectively norm_cast at *; assumption, but more efficient.\nIt normalizes casts in the goal and, for every hypothesis h in the context,\nit will try to normalize casts in h and use exact h.See also push_cast, which moves casts inwards rather than lifting them outwards.\n\npush_cast rewrites the goal to move certain coercions (casts) inward, toward the leaf nodes.\nThis uses norm_cast lemmas in the forward direction.\nFor example, ↑(a + b) will be written to ↑a + ↑b.* push_cast moves casts inward in the goal.* push_cast at h moves casts inward in the hypothesis h.\nIt can be used with extra simp lemmas with, for example, push_cast [Int.add_zero].Example:example (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\nSee also norm_cast.\n\nNormalize casts in the goal and the given expression, then close the goal with exact.\n\nNormalize casts in the goal and the given expression, then apply the expression to the goal.\n\nRewrites with the given rules, normalizing casts prior to each step.\n\nassumption_mod_cast is a variant of assumption that solves the goal\nusing a hypothesis. Unlike assumption, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.Concretely, it runs norm_cast on the goal. For each local hypothesis h, it also\nnormalizes h with norm_cast and tries to use that to close the goal.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.9. Cast Management","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-casts"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-spred":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Verification Condition Generation","header":"13.5.23.1. Tactics for Stateful Goals in  Std.Do.SPred","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-spred"},"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_--Solver-Type-Classes--Ring-Characteristics":{"contents":"\n\nA ring α has characteristic p if OfNat.ofNat x = 0 iff x % p = 0.Note that for p = 0, we have x % p = x, so this says that OfNat.ofNat is injective from Nat to α.In the case of a semiring, we take the stronger condition that\nOfNat.ofNat x = OfNat.ofNat y iff x % p = y % p.Two numerals in a semiring are equal iff they are congruent module p in the natural numbers.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Algebraic Solver (Commutative Rings, Fields)\u0009Solver Type Classes","header":"17.8.1.2. Ring Characteristics","id":"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_--Solver-Type-Classes--Ring-Characteristics"},"/The-Type-System/Inductive-Types/#anonymous-constructor-syntax":{"contents":"If an inductive type has just one constructor, then this constructor is eligible for anonymous constructor syntax.\nInstead of writing the constructor's name applied to its arguments, the explicit arguments can be enclosed in angle brackets ('⟨' and '⟩', Unicode MATHEMATICAL LEFT ANGLE BRACKET\u0009(U+0x27e8) and MATHEMATICAL RIGHT ANGLE BRACKET\u0009(U+0x27e9)) and separated with commas.\nThis works in both pattern and expression contexts.\nProviding arguments by name or converting all implicit parameters to explicit parameters with @ requires using the ordinary constructor syntax.\n\nAnonymous ConstructorsConstructors can be invoked anonymously by enclosing their explicit arguments in angle brackets, separated by commas.\n\nAnonymous constructorsThe type AtLeastOne α is similar to List α, except there's always at least one element present:inductive AtLeastOne (α : Type u) : Type u where\n  | mk : α → Option (AtLeastOne α) → AtLeastOne α\nAnonymous constructor syntax can be used to construct them:def oneTwoThree : AtLeastOne Nat :=\n  ⟨1, some ⟨2, some ⟨3, none⟩⟩⟩\nand to match against them:def AtLeastOne.head : AtLeastOne α → α\n  | ⟨x, _⟩ => x\nEquivalently, traditional constructor syntax could have been used:def oneTwoThree' : AtLeastOne Nat :=\n  .mk 1 (some (.mk 2 (some (.mk 3 none))))\n\ndef AtLeastOne.head' : AtLeastOne α → α\n  | .mk x _ => x\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","header":"4.4.1.3. Anonymous Constructor Syntax","id":"/The-Type-System/Inductive-Types/#anonymous-constructor-syntax"},"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Pretty-printing":{"contents":"* #3797 fixes the hovers over binders so that they show their types.* #3640 and #3735: Adds attribute @[pp_using_anonymous_constructor] to make structures pretty print as ⟨x, y, z⟩\nrather than as {a := x, b := y, c := z}.\nThis attribute is applied to Sigma, PSigma, PProd, Subtype, And, and Fin.* #3749\nNow structure instances pretty print with parent structures' fields inlined.\nThat is, if B extends A, then { toA := { x := 1 }, y := 2 } now pretty prints as { x := 1, y := 2 }.\nSetting option pp.structureInstances.flatten to false turns this off.* #3737, #3744\nand #3750:\nOption pp.structureProjections is renamed to pp.fieldNotation, and there is now a suboption pp.fieldNotation.generalized\nto enable pretty printing function applications using generalized field notation (defaults to true).\nField notation can be disabled on a function-by-function basis using the @[pp_nodot] attribute.\nThe notation is not used for theorems.* #4071 fixes interaction between app unexpanders and pp.fieldNotation.generalized* #3625 makes delabConstWithSignature (used by #check) have the ability to put arguments \"after the colon\"\nto avoid printing inaccessible names.* #3798,\n#3978,\n#3798:\nAdds options pp.mvars (default: true) and pp.mvars.withType (default: false).\nWhen pp.mvars is false, expression metavariables pretty print as ?_ and universe metavariables pretty print as _.\nWhen pp.mvars.withType is true, expression metavariables pretty print with a type ascription.\nThese can be set when using #guard_msgs to make tests not depend on the particular names of metavariables.* #3917 makes binders hoverable and gives them docstrings.* #4034 makes hovers for RHS terms in match expressions in the Infoview reliably show the correct term.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.8.0 (2024-06-05)","header":"Pretty printing","id":"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Pretty-printing"}});