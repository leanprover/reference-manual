window.docContents[69].resolve({"/Basic-Types/Arrays/#Array":{"contents":"The Array type represents sequences of elements, addressable by their position in the sequence.\nArrays are specially supported by Lean:\n\n* They have a logical model that specifies their behavior in terms of lists of elements, which specifies the meaning of each operation on arrays.* They have an optimized run-time representation in compiled code as dynamic arrays, and the Lean runtime specially optimizes array operations.* There is array literal syntax for writing arrays.\n\nArrays can be vastly more efficient than lists or other sequences in compiled code.\nIn part, this is because they offer good locality: because all the elements of the sequence are next to each other in memory, the processor's caches can be used efficiently.\nEven more importantly, if there is only a single reference to an array, operations that might otherwise copy or allocate a data structure can be implemented via mutation.\nLean code that uses an array in such a way that there's only ever one unique reference (that is, uses it linearly) avoids the performance overhead of persistent data structures while still being as convenient to write, read, and prove things about as ordinary pure functional programs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.16. Arrays","id":"/Basic-Types/Arrays/#Array"},"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--Random-Generators":{"contents":"Interface for random number generators.range returns the range of values returned by\nthe generator.next operation returns a natural number that is uniformly distributed\nthe range returned by range (including both end points),\nand a new generator.The 'split' operation allows one to obtain two distinct random number\ngenerators. This is very useful in functional programs (for example, when\npassing a random number generator down to recursive calls).\n\n\"Standard\" random number generator.\n\nThe range of values returned by StdGen\n\nThe next value from a StdGen, paired with an updated generator state.\n\nSplits a StdGen into two separate states.\n\nReturns a standard number generator.\n\n","context":"Lean Reference\u0009IO\u0009Random Numbers","header":"15.10.1. Random Generators","id":"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--Random-Generators"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-dependencies":{"contents":"Each type constructor's signature must be able to be elaborated without reference to the other inductive types in the mutual group.\nIn other words, the inductive types in the mutual group may not take each other as arguments.\nThe constructors of each inductive type may mention the other type constructors in the group in their parameter types, with restrictions that are a generalization of those for recursive occurrences in non-mutual inductive types.\n\nMutual inductive type constructors may not mention each otherThese inductive types are not accepted by Lean:mutual\n  inductive FreshList (α : Type) (r : α → α → Prop) : Type where\n    | nil : FreshList α r\n    | cons (x : α) (xs : FreshList α r) (fresh : Fresh r x xs)\n  inductive Fresh\n      (r : α → FreshList α → Prop) :\n      α → FreshList α r → Prop where\n    | nil : Fresh r x .nil\n    | cons : r x y → (f : Fresh r x ys) → Fresh r x (.cons y ys f)\nend\nThe type constructors may not refer to the other type constructors in the mutual group, so FreshList is not in scope in the type constructor of Fresh:Unknown identifier `FreshList`\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types\u0009Requirements","header":"4.4.5.1.1. Mutual Dependencies","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-dependencies"},"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Language-server___-widgets___-and-IDE-extensions":{"contents":"* #4727 makes it so that responses to info view requests come as soon as the relevant tactic has finished execution.* #4580 makes it so that whitespace changes do not invalidate imports, and so starting to type the first declaration after imports should no longer cause them to reload.* #4780 fixes an issue where hovering over unimported builtin names could result in a panic.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.11.0 (2024-09-02)","header":"Language server, widgets, and IDE extensions","id":"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Language-server___-widgets___-and-IDE-extensions"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Breaking-changes":{"contents":"* LibUV is now required to build Lean. This change only affects developers who compile Lean themselves instead of obtaining toolchains via elan. We have updated the official build instructions with information on how to obtain LibUV on our supported platforms. (#4963)* Recursive definitions with a decreasing_by clause that begins with simp_wf may break. Try removing simp_wf or replacing it with simp. (#5016)* The behavior of rw [f] where f is a non-recursive function defined by pattern matching changed.For example, preciously, rw [Option.map] would rewrite Option.map f o to match o with … . Now this rewrite fails because it will use the equational lemmas, and these require constructors – just like for List.map.Remedies:* Split on o before rewriting.* Use rw [Option.map.eq_def], which rewrites any (saturated) application of Option.map.* Use set_option backward.eqns.nonrecursive false when defining the function in question.\n(#4154)* The unified handling of equation lemmas for recursive and non-recursive functions can break existing code, as there now can be extra equational lemmas:* Explicit uses of f.eq_2 might have to be adjusted if the numbering changed.* Uses of rw [f] or simp [f] may no longer apply if they previously matched (and introduced a match statement), when the equational lemmas got more fine-grained.In this case either case analysis on the parameters before rewriting helps, or setting the option backward.eqns.deepRecursiveSplit false while defining the function.(#5129, #5207)* The reduceCtorEq simproc is now optional, and it might need to be included in lists of simp lemmas, like simp only [reduceCtorEq]. This simproc is responsible for reducing equalities of constructors. (#5167)* Nat.strongInductionOn is now Nat.strongRecOn and Nat.caseStrongInductionOn to Nat.caseStrongRecOn. (#5147)* The parameters to Membership.mem have been swapped, which affects all Membership instances. (#5020)* The meanings of List.getElem_drop and List.getElem_drop' have been reversed and the first is now a simp lemma. (#5210)* The Parsec library has moved from Lean.Data.Parsec to Std.Internal.Parsec. The Parsec type is now more general with a parameter for an iterable. Users parsing strings can migrate to Parser in the Std.Internal.Parsec.String namespace, which also includes string-focused parsing combinators. (#4774)* The Lean module has switched from Lean.HashMap and Lean.HashSet to Std.HashMap and Std.HashSet (#4943). Lean.HashMap and Lean.HashSet are now deprecated (#4954) and will be removed in a future release. Users of Lean APIs that interact with hash maps, for example Lean.Environment.const2ModIdx, might encounter minor breakage due to the following changes from Lean.HashMap to Std.HashMap:* query functions use the term get instead of find, (#4943)* the notation map[key] no longer returns an optional value but instead expects a proof that the key is present in the map. The previous behavior is available via the map[key]? notation.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Breaking changes","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Breaking-changes"},"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Language-server___-widgets___-and-IDE-extensions":{"contents":"* #5224 fixes WorkspaceClientCapabilities to make applyEdit optional, in accordance with the LSP specification (@pzread).* #5340 fixes a server deadlock when shutting down the language server and a desync between client and language server after a file worker crash.* #5560 makes initialize and builtin_initialize participate in the call hierarchy and other requests.* #5650 makes references in attributes participate in the call hierarchy and other requests.* #5666 add auto-completion in tactic blocks without having to type the first character of the tactic, and adds tactic completion docs to tactic auto-completion items.* #5677 fixes several cases where goal states were not displayed in certain text cursor positions.* #5707 indicates deprecations in auto-completion items.* #5736, #5752, #5763, #5802, and #5805 fix various performance issues in the language server.* #5801 distinguishes theorem auto-completions from non-theorem auto-completions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.14.0 (2024-12-02)","header":"Language server, widgets, and IDE extensions","id":"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Language-server___-widgets___-and-IDE-extensions"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Language":{"contents":"* #6325 ensures that environments can be loaded, repeatedly, without\nexecuting arbitrary code* #6432 implements tactics called extract_lets and lift_lets that\nmanipulate let/let_fun expressions. The extract_lets tactic\ncreates new local declarations extracted from any let and let_fun\nexpressions in the main goal. For top-level lets in the target, it is\nlike the intros tactic, but in general it can extract lets from deeper\nsubexpressions as well. The lift_lets tactic moves let and let_fun\nexpressions as far out of an expression as possible, but it does not\nextract any new local declarations. The option extract_lets +lift\ncombines these behaviors.* #7474 updates rw?, show_term, and other tactic-suggesting tactics\nto suggest expose_names when necessary and validate tactics prior to\nsuggesting them, as exact? already did, and it also ensures all such\ntactics produce hover info in the messages showing tactic suggestions.* #7797 adds a monolithic CommRing class, for internal use by grind,\nand includes instances for Int/BitVec/IntX/UIntX.* #7803 adds normalization rules for function composition to grind.* #7806 modifies the syntaxes of the ext, intro and enter conv\ntactics to accept _. The introduced binder is an inaccessible name.* #7808 adds missing forall normalization rules to grind.* #7816 fixes an issue where x.f.g wouldn't work but (x.f).g would\nwhen x.f is generalized field notation. The problem was that x.f.g\nwould assume x : T should be the first explicit argument to T.f. Now\nit uses consistent argument insertion rules. Closes #6400.* #7825 improves support for Nat in the cutsat procedure used in\ngrind:* cutsat no longer pollutes the local context with facts of the form\n-1 * NatCast.natCast x <= 0 for each x : Nat. These facts are now\nstored internally in the cutsat state.* A single context is now used for all Nat terms.* #7829 fixes an issue in the cutsat counterexamples. It removes the\noptimization (Cutsat.State.terms) that was used to avoid the new\ntheorem eq_def. In the two new tests, prior to this PR, cutsat\nproduced a bogus counterexample with b := 2.* #7830 modifies the syntax of induction, cases, and other tactics\nthat use Lean.Parser.Tactic.inductionAlts. If a case omits => ...\nthen it is assumed to be => ?_. Example:example (p : Nat × Nat) : p.1 = p.1 := by\n  cases p with | _ p1 p2\n  /-\n  case mk\n  p1 p2 : Nat\n  ⊢ (p1, p2).fst = (p1, p2).fst\n  -/\nThis works with multiple cases as well. Example:example (n : Nat) : n + 1 = 1 + n := by\n  induction n with | zero | succ n ih\n  /-\n  case zero\n  ⊢ 0 + 1 = 1 + 0\n\n  case succ\n  n : Nat\n  ih : n + 1 = 1 + n\n  ⊢ n + 1 + 1 = 1 + (n + 1)\n  -/\nThe induction n with | zero | succ n ih is short for induction n with | zero | succ n ih => ?_, which is short for induction n with | zero => ?_ | succ n ih => ?_. Note that a consequence of parsing is that\nonly the last alternative can omit =>. Any =>-free alternatives\nbefore an alternative with => will be a part of that alternative.* #7831 adds extensibility to the evalAndSuggest procedure used to\nimplement try?. Users can now implement their own handlers for any\ntactic. The new test demonstrates how this feature works.* #7859 allows the LRAT parser to accept any proof that derives the\nempty clause at somepoint, not necessarily in the last line. Some tools\nlike lrat-trim occasionally include deletions after the derivation of\nthe empty clause but the proof is sound as long as it soundly derives\nthe empty clause somewhere.* #7861 fixes an issue that prevented theorems from being activated in\ngrind.* #7862 improves the normalization of Bool terms in grind. Recall\nthat grind currently does not case split on Boolean terms to reduce\nthe size of the search space.* #7864 adds support to grind for case splitting on implications of\nthe form p -> q and (h : p) -> q h. See the new option (splitImp := true).* #7865 adds a missing propagation rule for implication in grind. It\nalso avoids unnecessary case-splits on implications.* #7870 adds a mixin typeclass for Lean.Grind.CommRing recording the\ncharacteristic of the ring, and constructs instances for Int, IntX,\nUIntX, and BitVec.* #7885 fixes the counterexamples produced by the cutsat procedure in\ngrind for examples containing Nat terms.* #7892 improves the support for funext in grind. We will push\nanother PR to minimize the number of case-splits later.* #7902 introduces a dedicated option for checking whether elaborators\nare running in the language server.* #7905 fixes an issue introduced bug #6125 where an inductive or\nstructure with an autoimplicit parameter with a type that has a\nmetavariable would lead to a panic. Closes #7788.* #7907 fixes two bugs in grind.1. Model-based theory combination was creating type incorrect terms.2. Nat.cast vs NatCast.natCast issue during normalization.* #7914 adds a function hook PersistentEnvExtension.saveEntriesFn that\ncan be used to store server-only metadata such as position information\nand docstrings that should not affect (re)builds.* #7920 introduces a fast path based on comparing the (cached) hash\nvalue to the DecidableEq instance of the core expression data type in\nbv_decide's bitblaster.* #7926 fixes two issues that were preventing grind to solve\ngetElem?_eq_some_iff.1. Missing propagation rule for Exists p = False2. Missing conditions at isCongrToPrevSplit a filter for discarding\nunnecessary case-splits.* #7937 implements a lookahead feature to reduce the size of the search\nspace in grind. It is currently effective only for arithmetic atoms.* #7949 adds the attribute [grind ext]. It is used to select which\n[ext] theorems should be used by grind. The option grind +extAll\ninstructs grind to use all [ext] theorems available in the\nenvironment.\nAfter update stage0, we need to add the builtin [grind ext]\nannotations to key theorems such as funext.* #7950 modifies all_goals so that in recovery mode it commits changes\nto the state only for those goals for which the tactic succeeds (while\npreserving the new message log state). Before, we were trusting that\nfailing tactics left things in a reasonable state, but now we roll back\nand admit the goal. The changes also fixes a bug where we were rolling\nback only the metacontext state and not the tactic state, leading to an\ninconsistent state (a goal list with metavariables not in the\nmetacontext). Closes #7883* #7952 makes two improvements to the local context when there are\nautobound implicits in variables. First, the local context no longer\nhas two copies of every variable (the local context is rebuilt if the\ntypes of autobound implicits have metavariables). Second, these\nmetavariables get names using the same algorithm used by binders that\nappear in declarations (with mkForallFVars' instead of\nmkForallFVars).* #7957 ensures that mkAppM can be used to construct terms that are\nonly type-correct at at default transparency, even if we are in\nwithReducible (e.g. in simp), so that simp does not stumble over\nsimplifying let expression with simplifiable type.reliable.* #7961 fixes a bug in bv_decide where if it was presented with a match\non an enum with as many arms as constructors but the last arm being a\ndefault match it would (wrongly) give up on the match.* #7975 reduces the priority of the parent projections of\nLean.Grind.CommRing, to avoid these being used in typeclass inference\nin Mathlib.* #7976 ensure that bv_decide can handle the simp normal form of a\nshift.* #7978 adds a repro for a non-determinism problem in grind.* #7980 adds a simple type for representing monomials in a CommRing.\nThis is going to be used in grind.* #7986 implements reverse lexicographical and graded reverse\nlexicographical orders for CommRing monomials.* #7989 adds functions and theorems for CommRing multivariate\npolynomials.* #7992 add a function for converting CommRing expressions into\nmultivariate polynomials.* #7997 removes all type annotations (optional paramters, auto\nparameters, out params, semi-out params, not just optional parameters as\nbefore) from the type of functional induction principles.* #8011 adds IsCharP support to the multivariate‑polynomial library in\nCommRing.* #8012 adds the option debug.terminalTacticsAsSorry. When enabled,\nterminal tactics such as grind and omega are replaced with sorry.\nUseful for debugging and fixing bootstrapping issues.* #8014 makes RArray universe polymorphic.* #8016 fixes several issues in the CommRing multivariate polynomial\nlibrary:1. Replaces the previous array type with the universe polymorphic\nRArray.2. Properly eliminates cancelled monomials.3. Sorts monomials in decreasing order.4. Marks the parameter p of the IsCharP class as an output\nparameter.5. Adds LawfulBEq instances for the types Power, Mon, and Poly.* #8025 simplifies the CommRing monomials, and adds1. Monomial lcm2. Monomial division3. S-polynomials* #8029 implements basic support for CommRing in grind. Terms are\nalready being reified and normalized. We still need to process the\nequations, but grind can already prove simple examples such as:open Lean.Grind in\nexample [CommRing α] (x : α) : (x + 1)*(x - 1) = x^2 - 1 := by\n  grind +ring\n\n* #8032 adds support to grind for detecting unsatisfiable commutative\nring equations when the ring characteristic is known. Examples:example (x : Int) : (x + 1)*(x - 1) = x^2 → False := by\n  grind +ring\n\n* #8033 adds functions for converting CommRing reified terms back into\nLean expressions.* #8036 fixes a linearity issue in bv_decide's bitblaster, caused by\nthe fact that the higher order combinators AIG.RefVec.zip and\nAIG.RefVec.fold were not being properly specialised.* #8042 makes IntCast a field of Lean.Grind.CommRing, along with\nadditional axioms relating it to negation of OfNat. This allows use to\nuse existing instances which are not definitionally equal to the\npreviously given construction.* #8043 adds NullCert type for representing Nullstellensatz\ncertificates that will be produced by the new commutative ring procedure\nin grind.* #8050 fixes missing trace messages when produced inside realizeConst* #8055 adds an implementation of an async IO multiplexing framework as\nwell as an implementation of it for the Timer API in order to\ndemonstrate it.* #8064 adds a failing grind test, showing a bug where grind is trying\nto assign a metavariable incorrectly.* #8065 adds a (failing) test case for an obstacle I've been running\ninto setting up grind for HashMap.* #8068 ensures that for modules opted into the experimental module\nsystem, we do not import module docstrings or declaration ranges.* #8076 fixes simp?!, simp_all?! and dsimp?! to do auto-unfolding.* #8077 adds simprocs to simplify appends of non-overlapping Bitvector\nadds. We add a simproc instead of just a simp lemma to ensure that we\ncorrectly rewrite bitvector appends. Since bitvector appends lead to\ncomputation at the bitvector width level, it seems to be more stable to\nwrite a simproc.* #8083 fixes #8081.* #8086 makes sure that the functional induction priciples for mutually\nrecursive structural functions with extra parameters are split deeply,\nas expected.* #8088 adds the “unfolding” variant of the functional induction and\nfunctional cases principles, under the name foo.induct_unfolding resp.\nfoo.fun_cases_unfolding. These theorems combine induction over the\nstructure of a recursive function with the unfolding of that function,\nand should be more reliable, easier to use and more efficient than just\ncase-splitting and then rewriting with equational theorems.* #8090 adjusts the experimental module system to elide theorem bodies\n(i.e. proofs) from being imported into other modules.* #8094 fixes the generation of functional induction principles for\nfunctions with nested nested well-founded recursion and late fixed\nparameters. This is a follow-up for #7166. Fixes #8093.* #8096 lets induction accept eliminator where the motive application\nin the conclusion has complex arguments; these are abstracted over using\nkabstract if possible. This feature will go well with unfolding\ninduction principles (#8088).* #8097 adds support for inductive and coinductive predicates defined\nusing lattice theoretic structures on Prop. These are syntactically\ndefined using greatest_fixpoint or least_fixpoint termination\nclauses for recursive Prop-valued functions. The functionality relies\non partial_fixpoint machinery and requires function definitions to be\nmonotone. For non-mutually recursive predicates, an appropriate\n(co)induction proof principle (given by Park induction) is generated.* #8101 fixes a parallelism regression where linters that e.g. check for\nerrors in the command would no longer find such messages.* #8102 allows ASCII <- in if let clauses, for consistency with\nbind, where both are allowed. Fixes #8098.* #8111 adds the helper type class NoZeroNatDivisors for the\ncommutative ring procedure in grind. Core only implements it for\nInt. It can be instantiated in Mathlib for any type A that\nimplements NoZeroSMulDivisors Nat A.\nSee findSimp? and PolyDerivation for details on how this instance\nimpacts the commutative ring procedure.* #8122 implements the generation of compact proof terms for\nNullstellensatz certificates in the new commutative ring procedure in\ngrind. Some examples:example [CommRing α] (x y : α) : x = 1 → y = 2 → 2*x + y = 4 := by\n  grind +ring\n\n* #8126 implements the main loop of the new commutative ring procedure\nin grind. In the main loop, for each polynomial p in the todo queue,\nthe procedure:* Simplifies it using the current basis.* Computes critical pairs with polynomials already in the basis and adds\nthem to the queue.* #8128 implements equality propagation in the new commutative ring\nprocedure in grind. The idea is to propagate implied equalities back\nto the grind core module that does congruence closure. In the\nfollowing example, the equalities: x^2*y = 1 and x*y^2 - y = 0 imply\nthat y*x is equal to y*x*y, which implies by congruence that f (y*x) = f (y*x*y).example [CommRing α] (x y : α) (f : α → Nat) : x^2*y = 1 → x*y^2 - y = 0 → f (y*x) = f (y*x*y) := by\n  grind +ring\n* #8129 updates the If-Normalization example, to separately give an\nimplementation and subsequently prove the spec (using fun_induction),\ninstead of previously building a term in the subtype directly. At the\nsame time, adds a (failing) grind test case illustrating a problem\nwith unused match witnesses.* #8131 adds a configuration option that controls the maximum number of\nsteps the commutative-ring procedure in grind performs.* #8133 fixes the monomial order used by the commutative ring procedure\nin grind. The following new test now terminates quickly.example [CommRing α] (a b c : α)\n  : a + b + c = 3 →\n    a^2 + b^2 + c^2 = 5 →\n    a^3 + b^3 + c^3 = 7 →\n    a^4 + b^4 + c^4 = 9 := by\n  grind +ring\n* #8134 ensures that set_option grind.debug true works properly when\nusing grind +ring. It also adds the helper functions mkPropEq and\nmkExpectedPropHint.* #8137 improves equality propagation (also known as theory combination)\nand polynomial simplification for rings that do not implement the\nNoZeroNatDivisors class. With these fixes, grind can now solve:example [CommRing α] (a b c : α) (f : α → Nat)\n  : a + b + c = 3 →\n    a^2 + b^2 + c^2 = 5 →\n    a^3 + b^3 + c^3 = 7 →\n    f (a^4 + b^4) + f (9 - c^4) ≠ 1 := by\n  grind +ring\nThis example uses the commutative ring procedure, the linear integer\narithmetic solver, and congruence closure.\nFor rings that implement NoZeroNatDivisors, a polynomial is now also\ndivided by the greatest common divisor (gcd) of its coefficients when it\nis inserted into the basis.* #8157 fixes an incompatibility of replayConst as used by e.g.\naesop with native_decide-using tactics such as bv_decide* #8158 fixes the grind +splitImp and the arrow propagator. Given p : Prop, the propagator was incorrectly assuming A was always a\nproposition in an arrow A -> p. also adds a missing\nnormalization rule to grind.* #8159 adds support for the following import variants to the\nexperimental module system:* private import: Makes the imported constants available only in\nnon-exported contexts such as proofs. In particular, the import will not\nbe loaded, or required to exist at all, when the current module is\nimported into other modules.* import all: Makes non-exported information such as proofs of the\nimported module available in non-exported contexts in the current\nmodule. Main purpose is to allow for reasoning about imported\ndefinitions when they would otherwise be opaque. TODO: adjust name\nresolution so that imported private decls are accessible through\nsyntax.* #8161 changes Lean.Grind.CommRing to inline the NatCast instance\n(i.e. to be provided by the user) rather than constructing one from the\nexisting data. Without this change we can't construct instances in\nMathlib that grind can use.* #8163 adds some currently failing tests for grind +ring, resulting\nin either kernel type mismatches (bugs) or a kernel deep recursion\n(perhaps just a too-large problem).* #8167 improves the heuristics used to compute the basis and simplify\npolynomials in the commutative procedure used in grind.* #8168 fixes a bug when constructing the proof term for a\nNullstellensatz certificate produced by the new commutative ring\nprocedure in grind. The kernel was rejecting the proof term.* #8170 adds the infrastructure for creating stepwise proof terms in the\ncommutative procedure used in grind.* #8189 implements stepwise proof terms in the commutative ring\nprocedure used by grind. These terms serve as an alternative\nrepresentation to the traditional Nullstellensatz certificates, aiming\nto address the exponential worst-case complexity often associated\nwith certificate construction.* #8231 changes the behaviour of apply? so that the sorry it uses to\nclose the goal is non-synthetic. (Recall that correct use of synthetic\nsorries requires that the tactic also generates an error message, which\nwe don't want to do in this situation.) Either this PR or #8230 are\nsufficient to defend against the problem reported in #8212.* #8254 fixes unintended inlining of ToJson, FromJson, and Repr\ninstances, which was causing exponential compilation times in deriving\nclauses for large structures.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Language","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Language"}});