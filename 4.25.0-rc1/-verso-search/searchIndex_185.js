window.docContents[185].resolve({"/Error-Explanations/lean___redundantMatchAlt/#The-Lean-Language-Reference--Error-Explanations--lean___redundantMatchAlt":{"contents":"\n\nThis error occurs when an alternative in a pattern match can never be reached: any values that would\nmatch the provided patterns would also match some preceding alternative. Refer to the\nPattern Matching manual section for additional details\nabout pattern matching.\n\nThis error may appear in any pattern matching expression, including match expressions, equational\nfunction definitions, if let bindings, and monadic let bindings with fallback clauses.\n\nIn pattern-matches with multiple arms, this error may occur if a less-specific pattern precedes a\nmore-specific one that it subsumes. Bear in mind that expressions are matched against patterns from\ntop to bottom, so specific patterns should precede generic ones.\n\nIn if let bindings and monadic let bindings with fallback clauses, in which only one pattern is\nspecified, this error indicates that the specified pattern will always be matched. In this case, the\nbinding in question can be replaced with a standard pattern-matching let.\n\nOne common cause of this error is that a pattern that was intended to match a constructor was\ninstead interpreted as a variable binding. This occurs, for instance, if a constructor\nname (e.g., cons) is written without its prefix (List) outside of that type's namespace. The\nconstructor-name-as-variable linter, enabled by default, will display a warning on any variable\npatterns that resemble constructor names.\n\nThis error nearly always indicates an issue with the code where it appears. If needed, however,\nset_option match.ignoreUnusedAlts true will disable the check for this error and allow pattern\nmatches with redundant alternatives to be compiled by discarding the unused arms.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.redundantMatchAlt","id":"/Error-Explanations/lean___redundantMatchAlt/#The-Lean-Language-Reference--Error-Explanations--lean___redundantMatchAlt"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Kleisli-Composition":{"contents":"Kleisli composition is the composition of monadic functions, analogous to Function.comp for ordinary functions.\n\nLeft-to-right composition of Kleisli arrows.Conventions for notations in identifiers:* The recommended spelling of >=> in identifiers is kleisliRight.\n\nRight-to-left composition of Kleisli arrows.Conventions for notations in identifiers:* The recommended spelling of <=< in identifiers is kleisliLeft.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009API Reference","header":"14.4.4. Kleisli Composition","id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Kleisli-Composition"},"/Interacting-with-Lean/#ReprAtom":{"contents":"When the elements of a list are sufficiently small, it can be both difficult to read and wasteful of space to render the list with one element per line.\nTo improve readability, List has two Repr instances: one that uses Std.Format.bracket for its contents, and one that uses Std.Format.bracketFill.\nThe latter is defined after the former and is thus selected when possible; however, it requires an instance of the empty type class ReprAtom.\n\nIf the Repr instance for a type never generates spaces or newlines, then it should have a ReprAtom instance.\nLean has ReprAtom instances for types such as String, UInt8, Nat, Char, and Bool.\n\n\n\nAuxiliary class for marking types that should be considered atomic by Repr methods.\nWe use it at Repr (List α) to decide whether bracketFill should be used or not.\n\nAtomic Types and ReprAll constructors of the inductive type ABC are without parameters:inductive ABC where\n  | a\n  | b\n  | c\nderiving Repr\nThe derived Repr ABC instance is used to display lists:def abc : List ABC := [.a, .b, .c]\n\ndef abcs : List ABC := abc ++ abc ++ abc\n\n#eval IO.println ((repr abcs).pretty (width := 14))\nBecause of the narrow width, line breaks are inserted:[ABC.a,\n ABC.b,\n ABC.c,\n ABC.a,\n ABC.b,\n ABC.c,\n ABC.a,\n ABC.b,\n ABC.c]\nHowever, converting the list to a List Nat leads to a differently-formatted result.def ABC.toNat : ABC → Nat\n  | .a => 0\n  | .b => 1\n  | .c => 2\n\n#eval IO.print ((repr (abcs.map ABC.toNat)).pretty (width := 14))\nThere are far fewer line breaks:[0, 1, 2, 0,\n 1, 2, 0, 1,\n 2]\nThis is because of the existence of a ReprAtom Nat instance.\nAdding one for ABC leads to similar behavior:instance : ReprAtom ABC := ⟨⟩\n\n#eval IO.println ((repr abcs).pretty (width := 14))\n[ABC.a, ABC.b,\n ABC.c, ABC.a,\n ABC.b, ABC.c,\n ABC.a, ABC.b,\n ABC.c]\n\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Repr","header":"3.7.2.2. Atomic Types","id":"/Interacting-with-Lean/#ReprAtom"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Syntax-Node-Kinds":{"contents":"Syntax node kinds typically identify the parser that produced the node.\nThis is one place where the names given to operators or notations (or their automatically-generated internal names) occur.\nWhile only nodes contain a field that identifies their kind, identifiers have the kind identKind by convention, while atoms have their internal string as their kind by convention.\nLean's parser wraps each keyword atom KW in a singleton node whose kind is `token.KW.\nThe kind of a syntax value can be extracted using Syntax.getKind.\n\nSpecifies the interpretation of a Syntax.node value. An abbreviation for Name.Node kinds may be any name, and do not need to refer to declarations in the environment.\nConventionally, however, a node's kind corresponds to the Parser or ParserDesc declaration that\nproduces it. There are also a number of built-in node kinds that are used by the parsing\ninfrastructure, such as nullKind and choiceKind; these do not correspond to parser declarations.\n\nChecks whether syntax has the given kind or pseudo-kind.“Pseudo-kinds” are kinds that are assigned by convention to non-Syntax.node values:\nidentKind for Syntax.ident, `missing for Syntax.missing, and the atom's string literal\nfor atoms.\n\nGets the kind of a Syntax.node value, or the pseudo-kind of any other Syntax value.“Pseudo-kinds” are kinds that are assigned by convention to non-Syntax.node values:\nidentKind for Syntax.ident, `missing for Syntax.missing, and the atom's string literal\nfor atoms.\n\nChanges the kind at the root of a Syntax.node to k.Returns all other Syntax values unchanged.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.2. Syntax Node Kinds","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Syntax-Node-Kinds"},"/Notations-and-Macros/Macros/#splices":{"contents":"In addition to including other syntax via antiquotations, quasiquotations can include splices.\nSplices indicate that the elements of an array are to be inserted in order.\nThe repeated elements may include separators, such as the commas between list or array elements.\nSplices may consist of an ordinary antiquotation with a splice suffix, or they may be extended splices that provide additional repeated structure.\n\nSplice suffixes consist of either an asterisk or a valid atom followed by an asterisk (*).\nSuffixes may follow any identifier or term antiquotation.\nAn antiquotation with the splice suffix * corresponds to a use of many or many1; both the * and + suffixes in syntax rules correspond to the * splice suffix.\nAn antiquotation with a splice suffix that includes an atom prior to the asterisk corresponds to a use of sepBy or sepBy1.\nThe splice suffix ? corresponds to a use of optional or the ? suffix in a syntax rule.\nBecause ? is a valid identifier character, identifiers must be parenthesized to use it as a suffix.\n\nWhile there is overlap between repetition specifiers for syntax and antiquotation suffixes, they have distinct syntaxes.\nWhen defining syntax, the suffixes *, +, ,*, ,+, ,*,?, and ,+,? are built in to Lean.\nThere is no shorter way to specify separators other than ,.\nAntiquotation suffixes are either just * or whatever atom was provided to sepBy or sepBy1 followed by *.\nThe syntax repetitions + and * correspond to the splice suffix *; the repetitions ,*, ,+, ,*,?, and ,+,? correspond to ,*.\nThe optional suffix ? in syntax and splices correspond with each other.\n\n* Syntax Repetition* Splice Suffix* + ** ** ,* ,+ ,*,? ,+,?* ,** sepBy(_, \"S\") sepBy1(_, \"S\")* S** ?* ?\n\nSuffixed SplicesThis example requires that m is a monad that can perform quotation.variable {m : Type → Type} [Monad m] [MonadQuotation m]\nBy default, the antiquotation $e is expected to be an array of terms separated by commas, as is expected in the body of a list:def ex1 (xs) := show m _ from `(#[$xs,*])\n#check ex1\nex1 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Syntax.TSepArray `term \",\") : m (TSyntax `term)\nHowever, Lean includes a collection of coercions between various representations of arrays that will automatically insert or remove separators, so an ordinary array of terms is also acceptable:def ex2 (xs : Array (TSyntax `term)) :=\n  show m _ from `(#[$xs,*])\n#check ex2\nex2 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Array (TSyntax `term)) : m (TSyntax `term)\nRepetition annotations may also be used with term antiquotations and syntax category annotations.\nThis example is in CommandElabM so the result can be conveniently logged.def ex3 (size : Nat) := show CommandElabM _ from do\n  let mut nums : Array Nat := #[]\n  for i in [0:size] do\n    nums := nums.push i\n  let stx ← `(#[$(nums.map (Syntax.mkNumLit ∘ toString)):num,*])\n  -- Using logInfo here causes the syntax to be rendered via\n  -- the pretty printer.\n  logInfo stx\n\n#eval ex3 4\n#[0, 1, 2, 3]\n\n\nNon-Comma SeparatorsThe following unconventional syntax for lists separates numeric elements by either em dashes or double asterisks, rather than by commas.syntax \"⟦\" sepBy1(num, \" — \") \"⟧\": term\nsyntax \"⟦\" sepBy1(num, \" ** \") \"⟧\": term\nThis means that —* and *** are valid splice suffixes between the ⟦ and ⟧ atoms.\nIn the case of ***, the first two asterisks are the atom in the syntax rule, while the third is the repetition suffix.macro_rules\n  | `(⟦$n:num—*⟧) => `(⟦$n***⟧)\n  | `(⟦$n:num***⟧) => `([$n,*])\n#eval ⟦1 — 2 — 3⟧\n[1, 2, 3]\n\n\nOptional SplicesThe following syntax declaration optionally matches a term between two tokens.\nThe parentheses around the nested term are needed because term? is a valid identifier.syntax \"⟨| \" (term)? \" |⟩\": term\nThe ? splice suffix for a term expects an Option Term:def mkStx [Monad m] [MonadQuotation m]\n    (e : Option Term) : m Term :=\n  `(⟨| $(e)? |⟩)\n#check mkStx\nmkStx {m : Type → Type} [Monad m] [MonadQuotation m] (e : Option Term) : m Term\nSupplying some results in the optional term being present.#eval do logInfo (← mkStx (some (quote 5)))\n⟨| 5 |⟩\nSupplying none results in the optional term being absent.#eval do logInfo (← mkStx none)\n⟨| |⟩\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009Quotation","header":"20.5.3.2. Splices","id":"/Notations-and-Macros/Macros/#splices"}});