window.docContents[167].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Creation":{"contents":"Creates a new empty hash map. The optional parameter capacity can be supplied to presize the\nmap so that it can hold the given number of mappings without reallocating. It is also possible to\nuse the empty collection notations ∅ and {} to create an empty hash map with the default\ncapacity.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Dependent Hash Maps","header":"19.18.5.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Creation"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Packaging-and-Distribution":{"contents":"\n\nPacks the root package's buildDir into a tar.gz archive using tar and then uploads the asset to the pre-existing GitHub release tag using gh.\nOther hosts are not yet supported.\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"22.1.2.9. Packaging and Distribution","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Packaging-and-Distribution"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--Tuple-Based-State-Monads":{"contents":"\n\nThe tuple-based state monads represent a computation with states that have type σ yielding values of type α as functions that take a starting state and yield a value paired with a final state, e.g. σ → α × σ.\nThe Monad operations thread the state correctly through the computation.\n\nA tuple-based state monad.Actions in StateM σ are functions that take an initial state and return a value paired with a\nfinal state.\n\nAdds a mutable state of type σ to a monad.Actions in the resulting monad are functions that take an initial state and return, in m, a tuple\nof a value and a state.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value paired with the final state.\n\nRetrieves the current value of the monad's mutable state.This increments the reference count of the state, which may inhibit in-place updates.\n\nReplaces the mutable state with a new value.\n\nRecovers from errors. The state is rolled back on error recovery. Typically used via the <|>\noperator.\n\nFails with a recoverable error. The state is rolled back on error recovery.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value, discarding the final state.\n\nSequences two actions. Typically used via the >>= operator.\n\nApplies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.It is equivalent to do let (a, s) := f (← StateT.get); StateT.set s; pure a. However, using\nStateT.modifyGet may lead to better performance because it doesn't add a new reference to the\nstate value, and additional references can inhibit in-place updates of data.\n\nRuns an action from the underlying monad in the monad with state. The state is not modified.This function is typically implicitly accessed via a MonadLiftT instance as part of automatic\nlifting.\n\nModifies the value returned by a computation. Typically used via the <$> operator.\n\nReturns the given value without modifying the state. Typically used via Pure.pure.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009State","header":"14.5.4.2. Tuple-Based State Monads","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--Tuple-Based-State-Monads"},"/Notations-and-Macros/Custom-Operators/#operators":{"contents":"Lean supports custom infix, prefix, and postfix operators.\nNew operators can be added by any Lean library, and the new operators have equal status to those that are part of the language.\nEach new operator is assigned an interpretation as a function, after which uses of the operator are translated into uses of the function.\nThe operator's translation into a function call is referred to as its expansion.\nIf this function is a type class method, then the resulting operator can be overloaded by defining instances of the class.\n\nAll operators have a precedence.\nOperator precedence determines the order of operations for unparenthesized expressions: because multiplication has a higher precedence than addition, 2 + 3 * 4 is equivalent to 2 + (3 * 4), and 2 * 3 + 4 is equivalent to (2 * 3) + 4.\nInfix operators additionally have an associativity that determines the meaning of a chain of operators that have the same precedence:\n\n Left-associative\n\nThese operators nest to the left.\n  Addition is left- associative, so 2 + 3 + 4 + 5 is equivalent to ((2 + 3) + 4) + 5.\n\n Right-associative\n\nThese operators nest to the right.\n  The product type is right-associative, so Nat × String × Unit × Option Int is equivalent to Nat × (String × (Unit × Option Int)).\n\n Non-associative\n\nChaining these operators is a syntax error.\n  Explicit parenthesization is required.\n  Equality is non-associative, so the following is an error:1 + 2 = 3 = 2 + 1\nThe parser error is:<example>:1:10-1:11: expected end of input\n\n\n\n\nPrecedence for Prefix and Infix OperatorsThe proposition ¬A ∧ B is equivalent to (¬A) ∧ B, because ¬ has a higher precedence than ∧.\nBecause ∧ has higher precedence than = and is right-associative, ¬A ∧ B = (¬A) ∧ B is equivalent to ¬A ∧ ((B = ¬A) ∧ B).\n\nLean provides commands for defining new operators:\n\nOperator DeclarationsNon-associative infix operators are defined using infix:Left-associative infix operators are defined using infixl:Right-associative infix operators are defined using infixr:Prefix operators are defined using prefix:Postfix operators are defined using postfix:\n\nEach of these commands may be preceded by documentation comments and attributes.\nThe documentation comment is shown when the user hovers their mouse over the operator, and attributes may invoke arbitrary metaprograms, just as for any other declaration.\nThe attribute inherit_doc causes the documentation of the function that implements the operator to be re-used for the operator itself.\n\nOperators interact with section scopes in the same manner as attributes.\nBy default, operators are available in any module that transitively imports the one in which they are established, but they may be declared scoped or local to restrict their availability either to contexts in which the current namespace has been opened or to the current section scope, respectively.\n\nCustom operators require a precedence specifier, following a colon.\nThere is no default precedence to fall back to for custom operators.\n\nOperators may be explicitly named.\nThis name denotes the extension to Lean's syntax, and is primarily used for metaprogramming.\nIf no name is explicitly provided, then Lean generates one based on the operator.\nThe specifics of the assignment of this name should not be relied upon, both because the internal name assignment algorithm may change and because the introduction of similar operators in upstream dependencies may lead to a clash, in which case Lean will modify the assigned name until it is unique.\n\nAssigned Operator NamesGiven this infix operator:infix:90 \" ⤴ \" => Option.getD\nthe internal name «term_⤴_» is assigned to the resulting parser extension.\n\nProvided Operator NamesGiven this infix operator:infix:90 (name := getDOp) \" ⤴ \" => Option.getD\nthe resulting parser extension is named getDOp.\n\nInheriting DocumentationGiven this infix operator:@[inherit_doc]\ninfix:90 \" ⤴ \" => Option.getD\nthe resulting parser extension has the same documentation as Option.getD.\n\nWhen multiple operators are defined that share the same syntax, Lean's parser attempts all of them.\nIf more than one succeed, the one that used the most input is selected—this is called the local longest-match rule.\nIn some cases, parsing multiple operators may succeed, all of them covering the same range of the input.\nIn these cases, the operator's priority is used to select the appropriate result.\nFinally, if multiple operators with the same priority tie for the longest match, the parser saves all of the results, and the elaborator attempts each in turn, failing if elaboration does not succeed on exactly one of them.\n\nAmbiguous Operators and PrioritiesDefining an alternative implementation of + as Or requires only an infix operator declaration.infix:65  \" + \" => Or\nWith this declaration, Lean attempts to elaborate addition both using the built-in syntax for HAdd.hAdd and the new syntax for Or:#check True + False\nTrue + False : Prop\n#check 2 + 2\n2 + 2 : Nat\nHowever, because the new operator is not associative, the local longest-match rule means that only HAdd.hAdd applies to an unparenthesized three-argument version:#check True + False + True\nfailed to synthesize\n  HAdd Prop Prop ?m.38\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nIf the infix operator is declared with high priority, then Lean does not try the built-in HAdd.hAdd operator in ambiguous cases:infix:65 (priority := high)  \" + \" => Or\n#check True + False\nTrue + False : Prop\n#check 2 + 2\nfailed to synthesize\n  OfNat Prop 2\nnumerals are polymorphic in Lean, but the numeral `2` cannot be used in a context where the expected type is\n  Prop\ndue to the absence of the instance above\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nThe new operator is not associative, so the local longest-match rule means that only HAdd.hAdd applies to the three-argument version:#check True + False + True\nfailed to synthesize\n  HAdd Prop Prop ?m.20\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\n\n\nThe actual operator is provided as a string literal.\nThe new operator must satisfy the following requirements:\n\n* It must contain at least one character.* The first character may not be a single or double quote (' or \"), unless the operator is ''.* It may not begin with a backtick (`) followed by a character that would be a valid prefix of a quoted name.* It may not begin with a digit.* It may not include internal whitespace.\n\nThe operator string literal may begin or end with a space.\nThese are not part of the operator's syntax, and their presence does not require spaces around uses of the operator.\nHowever, the presence of spaces cause Lean to insert spaces when showing the operator to the user.\nOmitting them causes the operator's arguments to be displayed immediately next to the operator itself.\n\n\n\nFinally, the operator's meaning is provided, separated from the operator by =>.\nThis may be any Lean term.\nUses of the operator are desugared into function applications, with the provided term in the function position.\nPrefix and postfix operators apply the term to their single argument as an explicit argument.\nInfix operators apply the term to the left and right arguments, in that order.\nOther than its ability to accept arguments at each call site, there are no specific requirements imposed on the term.\nOperators may construct functions, so the term may expect more parameters than the operator.\nImplicit and instance-implicit parameters are resolved at each application site, which allows the operator to be defined by a type class method.\n\n\n\nIf the term consists either of a name from the global environment or of an application of such a name to one or more arguments, then Lean automatically generates an unexpander for the operator.\nThis means that the operator will be displayed in proof states, error messages, and other output from Lean when the function term otherwise would have been displayed.\nLean does not track whether the operator was used in the original term; it is inserted at every opportunity.\n\nCustom Operators in Lean's OutputThe function perhapsFactorial computes a factorial for a number if it's not too large.def fact : Nat → Nat\n  | 0 => 1\n  | n+1 => (n + 1) * fact n\n\ndef perhapsFactorial (n : Nat) : Option Nat :=\n  if n < 8 then some (fact n) else none\nThe postfix interrobang operator can be used to represent it.postfix:90 \"‽\" => perhapsFactorial\nWhen attempting to prove that ∀ n, n ≥ 8 → (perhapsFactorial n).isNone, the initial proof state uses the new operator, even though the theorem as written does not:⊢ ∀ (n : Nat), n ≥ 8 → n‽.isNone = true\n\n","context":"Lean Reference\u0009Notations and Macros","header":"20.1. Custom Operators","id":"/Notations-and-Macros/Custom-Operators/#operators"},"/The--grind--tactic/Case-Analysis/#The-Lean-Language-Reference--The--grind--tactic--Case-Analysis--Performance":{"contents":"Case analysis is powerful, but computationally expensive: each level of case splitting multiplies the search space.\nIt's important to be judicious and not perform unnecessary splits.\nIn particular:\n\n* Increase splits only when the goal genuinely needs deeper branching; each extra level multiplies the search space.* Disable splitMatch when large pattern‑matching definitions explode the tree; this can be observed by setting the trace.grind.split.* Flags can be combined, e.g. by grind -splitMatch (splits := 10) +splitImp.* The grind cases attribute is scoped.\n  The modifiers local and scoped restrict extra splitting to a section or namespace.\n\nenable/disable tracing for the given module and submodules\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Case Analysis","header":"17.5.2. Performance","id":"/The--grind--tactic/Case-Analysis/#The-Lean-Language-Reference--The--grind--tactic--Case-Analysis--Performance"},"/Type-Classes/Deriving-Instances/#deriving-instances":{"contents":"Lean can automatically generate instances for many classes, a process known as deriving instances.\nInstance deriving can be invoked either when defining a type or as a stand-alone command.\n\nInstance Deriving (Optional)As part of a command that creates a new inductive type, a deriving clause specifies a comma-separated list of class names for which instances should be generated:\n\nStand-Alone Deriving of InstancesThe stand-alone deriving command specifies a number of class names and subject names.\nEach of the specified classes are derived for each of the specified subjects.\n\nDeriving Multiple ClassesAfter specifying multiple classes to derive for multiple types, as in this code:structure A where\nstructure B where\n\nderiving instance BEq, Repr for A, B\nall the instances exist for all the types, so all four #synth commands succeed:#synth BEq A\n#synth BEq B\n#synth Repr A\n#synth Repr B\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"11.4. Deriving Instances","id":"/Type-Classes/Deriving-Instances/#deriving-instances"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Lake":{"contents":"* #7738 makes memoization of built-in facets toggleable through a\nmemoize option on the facet configuration. Built-in facets which are\nessentially aliases (e.g., default, o) have had memoization\ndisabled.* #8447 makes use of lean --setup in Lake builds of Lean modules and\nadds Lake support for the new .olean artifacts produced by the module\nsystem.* #8613 changes the Lake version syntax (to 5.0.0-src+<commit>) to\nensure it is a well-formed SemVer,* #8656 enables auto-implicits in the Lake math template. This resolves\nan issue where new users sometimes set up a new project for math\nformalization and then quickly realize that none of the code samples in\nour official books and docs that use auto-implicits work in their\nprojects. With the introduction of inlay hints for\nauto-implicits, we\nconsider the auto-implicit UX to be sufficiently usable that they can be\nenabled by default in the math template.\nNotably, this change does not affect Mathlib itself, which will proceed\nto disable auto-implicits.* #8701 exports LeanOption in the Lean namespace from the Lake\nnamespace. LeanOption was moved from Lean to Lake in #8447, which\ncan cause unnecessary breakage without this.* #8736 partially reverts #8024 which introduced a significant Lake\nperformance regression during builds. Once the cause is discovered and\nfixed, a similar PR will be made to revert this.* #8846 reintroduces the basics of lean --setup integration into Lake\nwithout the module computation which is still undergoing performance\ndebugging in #8787.* #8866 upgrades the math template for lake init and lake new to\nconfigures the new project to meet rigorous Mathlib maintenance\nstandards. In comparison with the previous version (now available as\nlake new ... math-lax), this automatically provides:* Strict linting options matching Mathlib.* GitHub workflow for automatic upgrades to newer Lean and Mathlib\nreleases.* Automatic release tagging for toolchain upgrades.* API documentation generated by\ndoc-gen4 and hosted on\ngithub.io.* README with some GitHub-specific instructions.* #8922 introduces a local artifact cache for Lake. When enabled, Lake\nwill shared build artifacts (built files) across different instances of\nthe same package using an input- and content-addressed cache.* #8981 removes Lake's usage of lean -R and moduleNameOfFileName to\npass module names to Lean. For workspace names, it now relies on\ndirectly passing the module name through lean --setup. For\nnon-workspace modules passed to lake lean or lake setup-file, it\nuses a fixed module name of _unknown.* #9068 fixes some bugs with the local Lake artifact cache and cleans up\nthe surrounding API. It also adds the ability to opt-in to the cache on\npackages without enableArtifactCache set using the\nLAKE_ARTIFACT_CACHE environment variable.* #9081 fixes a bug with Lake where the job monitor would sit on a\ntop-level build (e.g., mathlib/Mathlib:default) instead of reporting\nmodule build progress.* #9101 fixes a bug introduce by #9081 where the source file was dropped\nfrom the module input trace and some entries were dropped from the\nmodule job log.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Lake","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Lake"}});