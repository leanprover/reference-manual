window.docContents[83].resolve({"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Reducibility-and-Tactics":{"contents":"The tactics with_reducible, with_reducible_and_instances, and with_unfolding_all control which definitions are unfolded by most tactics.\n\nReducibility and TacticsThe functions plus, sum, and tally are all synonyms for Nat.add that are respectively reducible, semireducible, and irreducible:abbrev plus := Nat.add\n\ndef sum := Nat.add\n\n@[irreducible]\ndef tally := Nat.add\nThe reducible synonym is unfolded by simp:theorem plus_eq_add : plus x y = x + y := by simp\nThe semireducible synonym is not, however, unfolded by simp:theorem sum_eq_add : sum x y = x + y := by simp\nNonetheless, the definitional equality check induced by rfl unfolds the sum:theorem sum_eq_add : sum x y = x + y := by rfl\nThe irreducible tally, however, is not reduced by definitional equality.theorem tally_eq_add : tally x y = x + y := by rfl\nThe simp tactic can unfold any definition, even irreducible ones, when they are explicitly provided:theorem tally_eq_add : tally x y = x + y := by simp [tally]\nSimilarly, part of a proof can be instructed to ignore irreducibility by placing it in a with_unfolding_all block:theorem tally_eq_add : tally x y = x + y := by with_unfolding_all rfl\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Controlling Reduction","header":"7.6.6.1. Reducibility and Tactics","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Reducibility-and-Tactics"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language":{"contents":"* #5182 makes functions defined by well-founded recursion use an\nopaque well-founded proof by default; see highlights section for details.* #5998 lets omega always abstract its own proofs into an auxiliary\ndefinition. The size of the olean of Vector.Extract goes down from 20MB\nto 5MB with this, overall stdlib olean size and build instruction count\ngo down 5%.* #6325 ensures that environments can be loaded, repeatedly, without\nexecuting arbitrary code* #7075 ensures that names suggested by tactics like simp? are not\nshadowed by auxiliary declarations in the local context and that names\nof let rec and where declarations are correctly resolved in tactic\nblocks.* #7166 extends the notion of “fixed parameter” of a recursive function\nalso to parameters that come after varying function; see highlights section for details.* #7256 introduces the assert! variant debug_assert! that is\nactivated when compiled with buildType debug.* #7304 fixes an issue where nested let rec declarations within\nmatch expressions or tactic blocks failed to compile if they were\nnested within, and recursively called, a let rec that referenced a\nvariable bound by a containing declaration.* #7324 changes the internal construction of well-founded recursion, to\nnot change the type of fix’s induction hypothesis in non-defeq ways.* #7333 allows aux decls (like generated by match) to be generated by\ndecreasing_by tactics.* #7335 modifies elabTerminationByHints in a way that the type of the\nrecursive function used for elaboration of the termination measure is\nstriped of from optional parameters. It prevents introducing\ndependencies between the default values for arguments, that can cause\nthe termination checker to fail.* #7353 changes abstractNestedProofs so that it also visits the\nsubterms in the head of an application.* #7362 allows simp dischargers to add aux decls to the environment.\nThis enables tactics like native_decide to be used here, and unblocks\nimprovements to omega in #5998.* #7387 uses -implicitDefEqProofs in bv_omega to ensure it is not\naffected by the change in #7386.* #7397 ensures that Poly.mul p 0 always returns Poly.num 0.* #7409 allows the use of dsimp during preprocessing of well-founded\ndefinitions. This fixes regressions when using if-then-else without\ngiving a name to the condition, but where the condition is needed for\nthe termination proof, in cases where that subexpression is reachable\nonly by dsimp, but not by simp (e.g. inside a dependent let)* #7431 changes the syntax of location modifiers for tactics like simp\nand rw (e.g., simp at h ⊢) to allow the turnstile ⊢ to appear\nanywhere in the sequence of locations.* #7509 disables the implicitDefEqProofs simp option in the\npreprocessor of bv_decide in order to account for regressions caused\nby #7387.* #7511 fixes two bugs in simp +arith that were preventing specific\nsubterms from being normalized.* #7515 fixes another bug in simp +arith. This bug was affecting\ngrind. See new test for an example.* #7551 changes isNatCmp to ignore optional arguments annotations,\nwhen checking for <-like comparison between elements of Nat. That\npreviously caused guessLex to fail when checking termination of a\nfunction, whose signature involved an optional argument of the type\nNat.* #7560 ensures that we use the same ordering to normalize linear Int\nterms and relations. This change affects simp +arith and grind\nnormalizer.* #7622 fixes fun_induction when used on structurally recursive\nfunctions where there are targets occurring before fixed parameters.* #7630 fixes a performance issue in the whnfCore procedure.* #7728 fixes an issue in abstractNestedProofs.\nWe should abstract proofs occurring in the inferred proposition too.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)","header":"Language","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Language"}});