window.docContents[201].resolve({"/Coercions/Coercion-Insertion/#coercion-insertion":{"contents":"The process of searching for a coercion from one type to another is called coercion insertion.\nCoercion insertion is attempted in the following situations where an error would otherwise occur:* The expected type for a term is not equal to the type found for the term.* A type or proposition is expected, but the term's type is not a universe.* A term is applied as though it were a function, but its type is not a function type.Coercions are also inserted when they are explicitly requested.\nEach situation in which coercions may be inserted has a corresponding prefix operator that triggers the appropriate insertion.\n\n\n\nBecause coercions are inserted automatically, nested type ascriptions provide a way to precisely control the types involved in a coercion.\nIf α and β are not the same type, ((e : α) : β) arranges for e to have type α and then inserts a coercion from α to β.\n\n\n\nWhen a coercion is discovered, the instances used to find it are unfolded and removed from the resulting term.\nTo the extent possible, calls to Coe.coe and related functions do not occur in the final term.\nThis process of unfolding makes terms more readable.\nEven more importantly, it means that coercions can control the evaluation of the coerced terms by wrapping them in functions.\n\nControlling Evaluation with CoercionsThe structure Later represents a term that can be evaluated in the future, by calling the contained function.structure Later (α : Type u) where\n  get : Unit → α\nA coercion from any value to a later value is performed by creating a function that wraps it.instance : CoeTail α (Later α) where\n  coe x := { get := fun () => x }\nHowever, if coercion insertion resulted in an application of CoeTail.coe, then this coercion would not have the desired effect at runtime, because the coerced value would be evaluated and then saved in the function's closure.\nBecause coercion implementations are unfolded, this instance is nonetheless useful.def tomorrow : Later String :=\n  (Nat.fold 10000\n    (init := \"\")\n    (fun _ _ s => s ++ \"tomorrow\") : String)\nPrinting the resulting definition shows that the computation is inside the function's body:#print tomorrow\ndef tomorrow : Later String :=\n{ get := fun x => Nat.fold 10000 (fun x x_1 s => s ++ \"tomorrow\") \"\" }\n\n\n\n\nDuplicate Evaluation in CoercionsBecause the contents of Coe instances are unfolded during coercion insertion, coercions that use their argument more than once should be careful to ensure that evaluation occurs just once.\nThis can be done by using a helper function that is not part of the instance, or by using let to evaluate the coerced term and then re-use its resulting value.The structure Twice requires that both fields have the same value:structure Twice (α : Type u) where\n  first : α\n  second : α\n  first_eq_second : first = second\nOne way to define a coercion from α to Twice α is with a helper function twice.\nThe coe attribute marks it as a coercion so it can be shown correctly in proof goals and error messages.@[coe]\ndef twice (x : α) : Twice α where\n  first := x\n  second := x\n  first_eq_second := rfl\n\ninstance : Coe α (Twice α) := ⟨twice⟩\nWhen the Coe instance is unfolded, the call to twice remains, which causes its argument to be evaluated before the body of the function is executed.\nAs a result, the dbg_trace is included in the resulting term just once:#eval ((dbg_trace \"hello\"; 5 : Nat) : Twice Nat)\nThis is used to demonstrate the effect:hello\nInlining the helper into the Coe instance results in a term that duplicates the dbg_trace:instance : Coe α (Twice α) where\n  coe x := ⟨x, x, rfl⟩\n\n#eval ((dbg_trace \"hello\"; 5 : Nat) : Twice Nat)\nhello\nhello\nIntroducing an intermediate name for the result of the evaluation prevents the duplication of dbg_trace:instance : Coe α (Twice α) where\n  coe x := let y := x; ⟨y, y, rfl⟩\n\n#eval ((dbg_trace \"hello\"; 5 : Nat) : Twice Nat)\nhello\n\n\n\n\n","context":"Lean Reference\u0009Coercions","header":"12.1. Coercion Insertion","id":"/Coercions/Coercion-Insertion/#coercion-insertion"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-success-failure":{"contents":"When run in a proof state, every tactic either succeeds or fails.\nTactic failure is akin to exceptions: failures typically \"bubble up\" until handled.\nUnlike exceptions, there is no operator to distinguish between reasons for failure; first simply takes the first branch that succeeds.\n\nfail msg is a tactic that always fails, and produces an error using the given message.\n\nfail_if_success t fails if the tactic t succeeds.\n\ntry tac runs tac and succeeds even if tac failed.\n\nfirst | tac | ... runs each tac until one succeeds, or else fails.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures","header":"13.3.1.1. Success and Failure","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-success-failure"},"/Terms/Function-Application/#function-application":{"contents":"Ordinarily, function application is written using juxtaposition: the argument is placed after the function, with at least one space between them.\nIn Lean's type theory, all functions take exactly one argument and produce exactly one value.\nAll function applications combine a single function with a single argument.\nMultiple arguments are represented via currying.\n\nThe high-level term language treats a function together with one or more arguments as a single unit, and supports additional features such as implicit, optional, and by-name arguments along with ordinary positional arguments.\nThe elaborator converts these to the simpler model of the core type theory.\n\nFunction ApplicationA function application consists of a term followed by one or more arguments, or by zero or more arguments and a final ellipsis.\n\n\n\nArgumentsFunction arguments are either terms or named arguments.\n\nThe function's core-language type determines the placement of the arguments in the final expression.\nFunction types include names for their expected parameters.\nIn Lean's core language, non-dependent function types are encoded as dependent function types in which the parameter name does not occur in the body.\nFurthermore, they are chosen internally such that they cannot be written as the name of a named argument; this is important to prevent accidental capture.\n\nEach parameter expected by the function has a name.\nRecurring over the function's argument types, arguments are selected from the sequence of arguments as follows:\n\n* If the parameter's name matches the name provided for a named argument, then that argument is selected.* If the parameter is implicit, a fresh metavariable is created with the parameter's type and selected.* If the parameter is instance implicit, a fresh instance metavariable is created with the parameter's type and inserted. Instance metavariables are scheduled for later synthesis.* If the parameter is a strict implicit parameter and there are any named or positional arguments that have not yet been selected, a fresh metavariable is created with the parameter's type and selected.* If the parameter is explicit, then the next positional argument is selected and elaborated. If there are no positional arguments:* If the parameter is declared as an optional parameter, then its default value is selected as the argument.* If the parameter is an automatic parameter then its associated tactic script is executed to construct the argument.* If the parameter is neither optional nor automatic, and no ellipsis is present, then a fresh variable is selected as the argument. If there is an ellipsis, a fresh metavariable is selected as if the argument were implicit.\n\nAs a special case, when the function application occurs in a pattern and there is an ellipsis, optional and automatic arguments become universal patterns (_) instead of being inserted.\n\nIt is an error if the type is not a function type and arguments remain.\nAfter all arguments have been inserted and there is an ellipsis, then the missing arguments are all set to fresh metavariables, just as if they were implicit arguments.\nIf any fresh variables were created for missing explicit positional arguments, the entire application is wrapped in a fun term that binds them.\nFinally, instance synthesis is invoked and as many metavariables as possible are solved:\n\n1. A type is inferred for the entire function application. This may cause some metavariables to be solved due to unification that occurs during type inference.2. The instance metavariables are synthesized. Default instances are only used if the inferred type is a metavariable that is the output parameter of one of the instances.3. If there is an expected type, it is unified with the inferred type; however, errors resulting from this unification are discarded. If the expected and inferred types can be equal, unification can solve leftover implicit argument metavariables. If they can't be equal, an error is not thrown because a surrounding elaborator may be able to insert coercions or monad lifts.\n\nNamed ArgumentsThe #check command can be used to inspect the arguments that were inserted for a function call.The function sum3 takes three explicit Nat parameters, named x, y, and z.def sum3 (x y z : Nat) : Nat := x + y + z\nAll three arguments can be provided positionally.#check sum3 1 3 8\nsum3 1 3 8 : Nat\nThey can also be provided by name.#check sum3 (x := 1) (y := 3) (z := 8)\nsum3 1 3 8 : Nat\nWhen arguments are provided by name, it can be in any order.#check sum3 (y := 3) (z := 8) (x := 1)\nsum3 1 3 8 : Nat\nNamed and positional arguments may be freely intermixed.#check sum3 1 (z := 8) (y := 3)\nsum3 1 3 8 : Nat\nNamed and positional arguments may be freely intermixed.\nIf an argument is provided by name, it is used, even if it occurs after a positional argument that could have been used.#check sum3 1 (x := 8) (y := 3)\nsum3 8 3 1 : Nat\nIf a named argument is to be inserted after arguments that aren't provided, a function is created in which the provided argument is filled out.#check sum3 (z := 8)\nfun x y => sum3 x y 8 : Nat → Nat → Nat\nBehind the scenes, the names of the arguments are preserved in the function type.\nThis means that the remaining arguments can again be passed by name.#check (sum3 (z := 8)) (y := 1)\nfun x => (fun x y => sum3 x y 8) x 1 : Nat → Nat\nParameter names are taken from the function's type, and the names used for function parameters don't need to match the names used in the type.\nThis means that local bindings that conflict with a parameter's name don't prevent the use of named parameters, because Lean avoids this conflicts by renaming the function's parameter while leaving the name intact in the type.#check let x := 15; sum3 (z := x)\nHere, the x that named sum3's first argument has been replaced, so as to not conflict with the surrounding let:let x := 15;\nfun x_1 y => sum3 x_1 y x : Nat → Nat → Nat\nEven though x was renamed, it can still be passed by name:#check (let x := 15; sum3 (z := x)) (x := 4)\n(let x := 15;\n  fun x_1 y => sum3 x_1 y x)\n  4 : Nat → Nat\nThis is because the name x is still used in the type.\nEnabling the option pp.piBinderNames shows the parameter names in the type:set_option pp.piBinderNames true in\n#check let x := 15; sum3 (z := x)\nlet x := 15;\nfun x_1 y => sum3 x_1 y x : (x y : Nat) → Nat\n\n\nOptional and automatic parameters are not part of Lean's core type theory.\nThey are encoded using the optParam and autoParam gadgets.\n\nGadget for optional parameter support.A binder like (x : α := default) in a declaration is syntax sugar for\nx : optParam α default, and triggers the elaborator to attempt to use\ndefault to supply the argument if it is not supplied.\n\nGadget for automatic parameter support. This is similar to the optParam gadget, but it uses\nthe given tactic.\nLike optParam, this gadget only affects elaboration.\nFor example, the tactic will not be invoked during type class resolution.\n\n\n\n\n\n","context":"Lean Reference\u0009Terms","header":"10.4. Function Application","id":"/Terms/Function-Application/#function-application"}});