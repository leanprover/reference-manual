window.docContents[7].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design--Suitable-Operators-for-Uniqueness":{"contents":"Care should be taken when working with data structures to ensure that as many references are unique as possible, which enables Lean to use destructive mutation behind the scenes while maintaining a pure functional interface.\nThe map and set library provides operators that can be used to maintain uniqueness of references.\nIn particular, when possible, operations such as alter or modify should be preferred over explicitly retrieving a value, modifying it, and reinserting it.\nThese operations avoid creating a second reference to the value during modification.\n\nModifying Values in Mapsopen Std\nThe function addAlias is used to track aliases of a string in some data set.\nOne way to add an alias is to first look up the existing aliases, defaulting to the empty array, then insert the new alias, and finally save the resulting array in the map:def addAlias (aliases : HashMap String (Array String))\n    (key value : String) :\n    HashMap String (Array String) :=\n  let prior := aliases.getD key #[]\n  aliases.insert key (prior.push value)\nThis implementation has poor performance characteristics.\nBecause the map retains a reference to the prior values, the array must be copied rather than mutated.\nA better implementation explicitly erases the prior value from the map before modifying it:def addAlias' (aliases : HashMap String (Array String))\n    (key value : String) :\n    HashMap String (Array String) :=\n  let prior := aliases.getD key #[]\n  let aliases := aliases.erase key\n  aliases.insert key (prior.push value)\nUsing HashMap.alter is even better.\nIt removes the need to explicitly delete and re-insert the value:def addAlias'' (aliases : HashMap String (Array String))\n    (key value : String) :\n    HashMap String (Array String) :=\n  aliases.alter key fun prior? =>\n    some ((prior?.getD #[]).push value)\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Library Design","header":"19.18.1.3. Suitable Operators for Uniqueness","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design--Suitable-Operators-for-Uniqueness"},"/Basic-Types/Sum-Types/#sum-api":{"contents":"Sum types are primarily used with pattern matching rather than explicit function calls from an API.\nAs such, their primary API is the constructors inl and inr.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Sum Types","header":"19.14.2. API Reference","id":"/Basic-Types/Sum-Types/#sum-api"},"/Source-Files-and-Modules/#module-headers":{"contents":"Module headers list the modules that should be elaborated prior to the current module.\nTheir declarations are visible in the current module.\n\nModule HeadersThe module header consists of a sequence of import statements:The optional prelude keyword should only be used in Lean's source code:\n\nIf present, the prelude keyword indicates that the module is part of the implementation of the Lean prelude, which is the code that is available without explicitly importing any modules—it should not be used outside of Lean's implementation.\n\nPrelude Modules\n\nImportsImports the module.\nImporting a module makes its contents available in the current module, as well as those from modules transitively imported by its imports.Modules do not necessarily correspond to namespaces.\nModules may add names to any namespace, and importing a module has no effect on the set of currently open namespaces.The imported module name is translated to a filename by replacing dots ('.') in its name with directory separators and appending .lean or .olean.\nLean searches its include path for the corresponding intermediate build product or importable module file.\n\n","context":"Lean Reference\u0009Source Files and Modules\u0009Structure","header":"5.3.1. Module Headers","id":"/Source-Files-and-Modules/#module-headers"},"/Terms/Pattern-Matching/#match-generalization":{"contents":"The pattern match elaborator automatically determines the motive by finding occurrences of the discriminants in the expected type, generalizing them in the types of subsequent discriminants so that the appropriate pattern can be substituted.\nAdditionally, occurrences of the discriminants in the types of variables in the context are generalized and substituted by default.\nThis latter behavior can be turned off by passing the (generalizing := false) flag to match.\n\nMatching, With and Without GeneralizationIn this definition of boolCases, the assumption b is generalized in the type of h and then replaced with the actual pattern.\nThis means that ifTrue and ifFalse have the types true = true → α and false = false → α in their respective cases, but h's type mentions the original discriminant.def boolCases (b : Bool)\n    (ifTrue : b = true → α)\n    (ifFalse : b = false → α) :\n    α :=\n  match h : b with\n  | true  => ifTrue h\n  | false => ifFalse h\nThe error for the first case is typical of both:Application type mismatch: The argument\n  h\nhas type\n  b = true\nbut is expected to have type\n  true = true\nin the application\n  ifTrue h\nTurning off generalization allows type checking to succeed, because b remains in the types of ifTrue and ifFalse.def boolCases (b : Bool)\n    (ifTrue : b = true → α)\n    (ifFalse : b = false → α) :\n    α :=\n  match (generalizing := false) h : b with\n  | true  => ifTrue h\n  | false => ifFalse h\nIn the generalized version, rfl could have been used as the proof arguments as an alternative.\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching\u0009Types","header":"10.8.1.4. Generalization","id":"/Terms/Pattern-Matching/#match-generalization"}});