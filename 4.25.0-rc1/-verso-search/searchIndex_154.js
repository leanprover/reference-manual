window.docContents[154].resolve({"/Attributes/#scoped-attributes":{"contents":"Many attributes can be applied in a particular scope.\nThis determines whether the attribute's effect is visible only in the current section scope, in namespaces that open the current namespace, or everywhere.\nThese scope indications are also used to control syntax extensions and type class instances.\nEach attribute is responsible for defining precisely what these terms mean for its particular effect.\n\nAttribute ScopesGlobally-scoped declarations (the default) are in effect whenever the module in which they're established is transitively imported.\nThey are indicated by the absence of another scope modifier.Locally-scoped declarations are in effect only for the extent of the section scope in which they are established.Scoped declarations are in effect whenever the namespace in which they are established is opened.\n\n","context":"Lean Reference\u0009Attributes","header":"9.3. Scoped Attributes","id":"/Attributes/#scoped-attributes"},"/Basic-Types/Byte-Arrays/#ByteArray":{"contents":"Byte arrays are a specialized array type that can only contain elements of type UInt8.\nDue to this restriction, they can use a much more efficient representation, with no pointer indirections.\nLike other arrays, byte arrays are represented in compiled code as dynamic arrays, and the Lean runtime specially optimizes array operations.\nThe operations that modify byte arrays first check the array's reference count, and if there are no other references to the array, it is modified in place.\n\nThere is no literal syntax for byte arrays.\nList.toByteArray can be used to construct an array from a list literal.\n\nByteArray is like Array UInt8, but with an efficient run-time representation as a packed\nbyte buffer.Packs an array of bytes into a ByteArray.Converting between Array and ByteArray takes linear time.The data contained in the byte array.Converting between Array and ByteArray takes linear time.\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.17. Byte Arrays","id":"/Basic-Types/Byte-Arrays/#ByteArray"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Constructing-Byte-Arrays":{"contents":"Constructs a new empty byte array with initial capacity 0.Use ByteArray.emptyWithCapacity to create an array with a greater initial capacity.\n\nConstructs a new empty byte array with initial capacity c.\n\nAppends two byte arrays.In compiled code, calls to ByteArray.append are replaced with the much more efficient\nByteArray.fastAppend.\n\n\n\nCopies the slice at [srcOff, srcOff + len) in src to [destOff, destOff + len) in\ndest, growing dest if necessary. If exact is false, the capacity\nwill be doubled when grown.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.1. Constructing Byte Arrays","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Constructing-Byte-Arrays"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Slices":{"contents":"Returns a byte slice of a byte array, with the given bounds.If start or stop are not valid bounds for a byte slice, then they are clamped to byte array's size.\nAdditionally, the starting index is clamped to the ending index.\n\nA region of some underlying byte array.A byte slice contains a byte array together with the start and end indices of a region of interest.\nByte slices can be used to avoid copying or allocating space, while being more convenient than\ntracking the bounds by hand. The region of interest consists of every index that is both greater\nthan or equal to start and strictly less than stop.\n\nComparison function\n\nThe underlying byte array.\n\nChecks if the byte slice contains a specific byte value.Returns true if any byte in the slice equals the given value, false otherwise.\n\nThe empty byte slice.This empty byte slice is backed by an empty byte array.\n\nFolds an operation from right to left over the bytes in a byte slice.An accumulator of type β is constructed by starting with init and combining each byte of the\nbyte slice with the current accumulator value in turn, moving from the end to the start.Examples:* (ByteArray.mk #[1, 2, 3]).toByteSlice.foldr (·.toNat + ·) 0 = 6* (ByteArray.mk #[1, 2, 3]).toByteSlice.popFront.foldr (·.toNat + ·) 0 = 5\n\nFolds a monadic operation from right to left over the bytes in a byte slice.An accumulator of type β is constructed by starting with init and monadically combining each\nbyte of the byte slice with the current accumulator value in turn, moving from the end to the\nstart. The monad in question may permit early termination or repetition.Examples:#eval (ByteArray.mk #[1, 2, 3]).toByteSlice.foldrM (init := 0) fun x acc =>\n  some x.toNat + acc\nsome 6\n\n\nRuns a monadic action on each byte of a byte slice.The bytes are processed starting at the lowest index and moving up.\n\nExtracts a byte from the byte slice.The index is relative to the start of the byte slice, rather than the underlying byte array.\n\nExtracts a byte from the byte slice, or returns a default value when the index is out of bounds.The index is relative to the start and end of the byte slice, rather than the underlying byte array. The\ndefault value is 0.\n\nExtracts a byte from the byte slice, or returns a default value v₀ when the index is out of\nbounds.The index is relative to the start and end of the byte slice, rather than the underlying byte array.\n\nCreates a new ByteSlice of a ByteArray\n\nComputes the size of the byte slice.\n\nCreates a sub-slice of the byte slice with the given bounds.If start or stop are not valid bounds for a sub-slice, then they are clamped to the slice's size.\nAdditionally, the starting index is clamped to the ending index.The indices are relative to the current slice, not the underlying byte array.\n\nThe starting index of the region of interest (inclusive).\n\nThe ending index of the region of interest (exclusive).\n\nConverts a byte slice back to a byte array by copying the relevant portion.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.8. Slices","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Slices"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Queries":{"contents":"Returns true if the given key is present in the set. There is also a Prop-valued version of\nthis: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains use\n== for comparisons, while for hash sets, both use ==.\n\nRetrieves the key from the set that matches a. Ensures that such a key exists by requiring a proof\nof a ∈ m. The result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise fallback.\nIf they key is contained the result is guaranteed to be pointer equal to the key in the set.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Sets","header":"19.18.7.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Queries"},"/Error-Explanations/lean___dependsOnNoncomputable/#The-Lean-Language-Reference--Error-Explanations--lean___dependsOnNoncomputable--Examples":{"contents":"Necessarily noncomputable function not appropriately markedaxiom transform : Nat → Nat\n\ndef transformIfZero : Nat → Nat\n  | 0 => transform 0\n  | n => n\n<invalid output>axiom transform : Nat → Nat\n\nnoncomputable def transformIfZero : Nat → Nat\n  | 0 => transform 0\n  | n => n\nIn this example, transformIfZero depends on the axiom transform. Because transform is an\naxiom, it does not contain any executable code; although the value transform 0 has type Nat,\nthere is no way to compute its value. Thus, transformIfZero must be marked noncomputable because\nits execution would depend on this axiom.\n\nNoncomputable dependency can be made computablenoncomputable def getOrDefault [Nonempty α] : Option α → α\n  | some x => x\n  | none => Classical.ofNonempty\n\ndef endsOrDefault (ns : List Nat) : Nat × Nat :=\n  let head := getOrDefault ns.head?\n  let tail := getOrDefault ns.getLast?\n  (head, tail)\n<invalid output>def getOrDefault [Inhabited α] : Option α → α\n  | some x => x\n  | none => default\n\ndef endsOrDefault (ns : List Nat) : Nat × Nat :=\n  let head := getOrDefault ns.head?\n  let tail := getOrDefault ns.getLast?\n  (head, tail)\nThe original definition of getOrDefault is noncomputable due to its use of Classical.choice.\nUnlike in the preceding example, however, it is possible to implement a similar but computable\nversion of getOrDefault (using the Inhabited type class), allowing endsOrDefault to be\ncomputable. (The differences between Inhabited and Nonempty are described in the documentation\nof inhabited types in the manual section on Basic Classes.)\n\nNoncomputable instance in namespaceopen Classical in\n/--\nReturns `y` if it is in the image of `f`,\nor an element of the image of `f` otherwise.\n-/\ndef fromImage (f : Nat → Nat) (y : Nat) :=\n  if ∃ x, f x = y then\n    y\n  else\n    f 0\n<invalid output>open Classical in\n/--\nReturns `y` if it is in the image of `f`,\nor an element of the image of `f` otherwise.\n-/\nnoncomputable def fromImage (f : Nat → Nat) (y : Nat) :=\n  if ∃ x, f x = y then\n    y\n  else\n    f 0\nThe Classical namespace contains Decidable instances that are not computable. These are a common\nsource of noncomputable dependencies that do not explicitly appear in the source code of a\ndefinition. In the above example, for instance, a Decidable instance for the proposition\n∃ x, f x = y is synthesized using a Classical decidability instance; therefore, fromImage must\nbe marked noncomputable.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.dependsOnNoncomputable","header":"Examples","id":"/Error-Explanations/lean___dependsOnNoncomputable/#The-Lean-Language-Reference--Error-Explanations--lean___dependsOnNoncomputable--Examples"}});