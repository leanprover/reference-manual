window.docContents[210].resolve({"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Size":{"contents":"Returns the number of bytes in the byte array.This is the number of bytes actually in the array, as distinct from its capacity, which is the\namount of memory presently allocated for the array.\n\nRetrieves the size of the array as a platform-specific fixed-width integer.Because USize is big enough to address all memory on every platform that Lean supports,\nthere are in practice no ByteArrays that have more elements that USize can count.\n\nReturns true when s contains zero bytes.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.2. Size","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Size"},"/Error-Explanations/lean___unknownIdentifier/#The-Lean-Language-Reference--Error-Explanations--lean___unknownIdentifier--Examples":{"contents":"Missing importdef inventory :=\n  Std.HashSet.ofList [(\"apples\", 3), (\"bananas\", 4)]\n<invalid output>public import Std.Data.HashSet.Basic\n\npublic section\n\ndef inventory :=\n  Std.HashSet.ofList [(\"apples\", 3), (\"bananas\", 4)]\nThe constant Std.HashSet.ofList is defined in the Std.Data.HashSet.Basic module, which has not\nbeen imported in the original example. This import is suggested by the unknown identifier code\naction; once it is added, this example compiles.\n\nVariable not in scopeexample (s : IO.FS.Stream) := do\n  IO.withStdout s do\n    let text := \"Hello\"\n    IO.println text\n  IO.println s!\"Wrote '{text}' to stream\"\n<invalid output>example (s : IO.FS.Stream) := do\n  let text := \"Hello\"\n  IO.withStdout s do\n    IO.println text\n  IO.println s!\"Wrote '{text}' to stream\"\nAn unknown identifier error occurs on the last line of this example because the variable text is\nnot in scope. The let-binding on the third line is scoped to the inner do block and cannot be\naccessed in the outer do block. Moving this binding to the outer do block—from which it remains\nin scope in the inner block as well—resolves the issue.\n\nMissing namespaceinductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\ndef red : Color :=\n  rgb 255 0 0\n<invalid output>inductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\ndef red : Color :=\n  Color.rgb 255 0 0\ninductive Color where\n  | rgb (r g b : Nat)\n  | grayscale (k : Nat)\n\nopen Color in\ndef red : Color :=\n  rgb 255 0 0\nIn this example, the identifier rgb on the last line does not resolve to the Color constructor\nof that name. This is because the constructor's name is actually Color.rgb: all constructors of an\ninductive type have names in that type's namespace. Because the Color namespace is not open, the\nidentifier rgb cannot be used without its namespace prefix.One way to resolve this error is to provide the fully qualified constructor name Color.rgb; the\ndotted-identifier notation .rgb can also be used, since the expected type of .rgb 255 0 0 is\nColor. Alternatively, one can open the Color namespace and continue to omit the Color prefix\nfrom the identifier.\n\nProtected constant name without namespace prefixprotected def A.x := ()\n\nopen A\n\nexample := x\n<invalid output>protected def A.x := ()\n\nopen A\n\nexample := A.x\nprotected def A.x := ()\n\nopen A (x)\n\nexample := x\nIn this example, because the constant A.x is protected, it cannot be referred to by the suffix\nx even with the namespace A open. Therefore, the identifier x fails to resolve. Instead, to\nrefer to a protected constant, it is necessary to include at least its innermost namespace—in this\ncase, A. Alternatively, the restricted opening syntax—demonstrated in the second corrected\nexample—allows a protected constant to be referred to by its unqualified name, without opening the\nremainder of the namespace in which it occurs (see the manual section on\nNamespaces and Sections for details).\n\nUnresolvable name inferred by dotted-identifier notationdef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  .toNat (b₁ || b₂)\n<invalid output>def disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  (b₁ || b₂).toNat\ndef disjoinToNat (b₁ b₂ : Bool) : Nat :=\n  Bool.toNat (b₁ || b₂)\nIn this example, the dotted-identifier notation .toNat causes Lean to infer an unresolvable\nname (Nat.toNat). The namespace used by dotted-identifier notation is always inferred from\nthe expected type of the expression in which it occurs, which—due to the type annotation on\ndisjoinToNat—is Nat in this example. To use the namespace of an argument's type—as the author of\nthis code seemingly intended—use generalized field notation as shown in the first corrected\nexample. Alternatively, the correct namespace can be explicitly specified by writing the fully\nqualified function name.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.unknownIdentifier","header":"Examples","id":"/Error-Explanations/lean___unknownIdentifier/#The-Lean-Language-Reference--Error-Explanations--lean___unknownIdentifier--Examples"},"/Source-Files-and-Modules/#module-syntax":{"contents":"Lean's concrete syntax is extensible.\nIn a language like Lean, it's not possible to completely describe the syntax once and for all, because libraries may define syntax in addition to new constants or inductive types.\nRather than completely describing the language here, the overall framework is described, while the syntax of each language construct is documented in the section to which it belongs.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Source Files and Modules","header":"5.2. Concrete Syntax","id":"/Source-Files-and-Modules/#module-syntax"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control":{"contents":"skip does nothing.\n\nTactic to check that a named hypothesis has a given type and/or value.* guard_hyp h : t checks the type up to reducible defeq,* guard_hyp h :~ t checks the type up to default defeq,* guard_hyp h :ₛ t checks the type up to syntactic equality,* guard_hyp h :ₐ t checks the type up to alpha equality.* guard_hyp h := v checks value up to reducible defeq,* guard_hyp h :=~ v checks value up to default defeq,* guard_hyp h :=ₛ v checks value up to syntactic equality,* guard_hyp h :=ₐ v checks the value up to alpha equality.The value v is elaborated using the type of h as the expected type.\n\nTactic to check that the target agrees with a given expression.* guard_target = e checks that the target is defeq at reducible transparency to e.* guard_target =~ e checks that the target is defeq at default transparency to e.* guard_target =ₛ e checks that the target is syntactically equal to e.* guard_target =ₐ e checks that the target is alpha-equivalent to e.The term e is elaborated with the type of the goal as the expected type, which is mostly\nuseful within conv mode.\n\nTactic to check equality of two expressions.* guard_expr e = e' checks that e and e' are defeq at reducible transparency.* guard_expr e =~ e' checks that e and e' are defeq at default transparency.* guard_expr e =ₛ e' checks that e and e' are syntactically equal.* guard_expr e =ₐ e' checks that e and e' are alpha-equivalent.Both e and e' are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using isDefEqGuarded) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n\ndone succeeds iff there are no remaining goals.\n\nThe tactic sleep ms sleeps for ms milliseconds and does nothing.\nIt is used for debugging purposes only.\n\nstop is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as repeat sorry.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.19. Control Flow","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control"}});