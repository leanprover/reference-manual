window.docContents[108].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Sequence-Operations--Bit-Extraction":{"contents":"Returns the most significant bit in a bitvector.\n\nReturns the ith most significant bit, or false if i ≥ w.\n\nReturns the ith most significant bit.\n\nReturns the ith most significant bit or none if i ≥ w.\n\nReturns the ith least significant bit or false if i ≥ w.\n\nReturns the ith least significant bit.\n\nReturns the ith least significant bit, or none if i ≥ w.\n\nExtracts the bits from hi down to lo (both inclusive) from a bitvector, which is implicitly\nzero-extended if necessary.The resulting bitvector has size hi - lo + 1.SMT-LIB name: extract.\n\nExtracts the bits start to start + len - 1 from a bitvector of size n to yield a\nnew bitvector of size len. If start + len > n, then the bitvector is zero-extended.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference\u0009Sequence Operations","header":"19.5.5.6.1. Bit Extraction","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Sequence-Operations--Bit-Extraction"},"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Other-Pattern-Matching-Operators":{"contents":"In addition to match and if let, there are a few other operators that perform pattern matching.\n\nThe matches OperatorThe matches operator returns true if the term on the left matches the pattern on the right.\n\nWhen branching on the result of matches, it's usually better to use if let, which can bind pattern variables in addition to checking whether a pattern matches.\n\n\n\nIf there are no constructor patterns that could match a discriminant or sequence of discriminants, then the code in question is unreachable, as there must be a false assumption in the local context.\nThe nomatch expression is a match with zero cases that can have any type whatsoever, so long as there are no possible cases that could match the discriminants.\n\nCaseless Pattern Matches\n\nInconsistent IndicesThere are no constructor patterns that can match both proofs in this example:example (p1 : x = \"Hello\") (p2 : x = \"world\") : False :=\n  nomatch p1, p2\nThis is because they separately refine the value of x to unequal strings.\nThus, the nomatch operator allows the example's body to prove False (or any other proposition or type).\n\nWhen the expected type is a function type, nofun is shorthand for a function that takes as many parameters as the type indicates in which the body is nomatch applied to all of the parameters.\n\nCaseless Functions\n\nImpossible FunctionsInstead of introducing arguments for both equality proofs and then using both in a nomatch, it is possible to use nofun.example : x = \"Hello\" → x = \"world\" → False := nofun\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching","header":"10.8.4. Other Pattern Matching Operators","id":"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Other-Pattern-Matching-Operators"},"/The-Type-System/Inductive-Types/#inductive-types":{"contents":"Inductive types are the primary means of introducing new types to Lean.\nWhile universes, functions, and quotient types are built-in primitives that could not be added by users, every other type in Lean is either an inductive type or defined in terms of universes, functions, and inductive types.\nInductive types are specified by their type constructors  and their constructors;  their other properties are derived from these.\nEach inductive type has a single type constructor, which may take both universe parameters and ordinary parameters.\nInductive types may have any number of constructors; these constructors introduce new values whose types are headed by the inductive type's type constructor.\n\nBased on the type constructor and the constructors for an inductive type, Lean derives a recursor.\nLogically, recursors represent induction principles or elimination rules; computationally, they represent primitive recursive computations.\nThe termination of recursive functions is justified by translating them into uses of the recursors, so Lean's kernel only needs to perform type checking of recursor applications, rather than including a separate termination analysis.\nLean additionally produces a number of helper constructions based on the recursor,The term recursor is always used, even for non-recursive types. which are used elsewhere in the system.\n\nStructures are a special case of inductive types that have exactly one constructor.\nWhen a structure is declared, Lean generates helpers that enable additional language features to be used with the new structure.\n\nThis section describes the specific details of the syntax used to specify both inductive types and structures, the new constants and definitions in the environment that result from inductive type declarations, and the run-time representation of inductive types' values in compiled code.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System","header":"4.4. Inductive Types","id":"/The-Type-System/Inductive-Types/#inductive-types"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Library-Updates":{"contents":"* Developments in the async machinery;* Standardization of the integer division API;* Conversions between finite types;* API expansion of BitVec and tree maps;* Proofs of Bitwuzla rewrite rules;* Improvements to List/Array/Vector, as well as HashMap and Int/Nat.\n\nSee the Library section below for details.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Highlights","header":"Library Updates","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights--Library-Updates"}});