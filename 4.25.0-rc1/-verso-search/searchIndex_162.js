window.docContents[162].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Lookups":{"contents":"Returns the slice of as from indices start to stop (exclusive). The resulting array has size\n(min stop as.size) - start.If start is greater or equal to stop, the result is empty. If stop is greater than the size of\nas, the size is used instead.Examples:* #[0, 1, 2, 3, 4].extract 1 3 = #[1, 2]* #[0, 1, 2, 3, 4].extract 1 30 = #[1, 2, 3, 4]* #[0, 1, 2, 3, 4].extract 0 0 = #[]* #[0, 1, 2, 3, 4].extract 2 1 = #[]* #[0, 1, 2, 3, 4].extract 2 2 = #[]* #[0, 1, 2, 3, 4].extract 2 3 = #[2]* #[0, 1, 2, 3, 4].extract 2 4 = #[2, 3]\n\nReturns the element at the provided index, counting from 0. Returns the fallback value v₀ if the\nindex is out of bounds.To return an Option depending on whether the index is in bounds, use a[i]?. To panic if the\nindex is out of bounds, use a[i]!.Examples:* #[\"spring\", \"summer\", \"fall\", \"winter\"].getD 2 \"never\" = \"fall\"* #[\"spring\", \"summer\", \"fall\", \"winter\"].getD 0 \"never\" = \"spring\"* #[\"spring\", \"summer\", \"fall\", \"winter\"].getD 4 \"never\" = \"never\"\n\nLow-level indexing operator which is as fast as a C array read.This avoids overhead due to unboxing a Nat used as an index.\n\nReturns the last element of an array, given a proof that the array is not empty.See Array.back! for the version that panics if the array is empty, or Array.back? for the\nversion that returns an option.\n\nReturns the last element of an array, or none if the array is empty.See Array.back! for the version that panics if the array is empty, or Array.back for the version\nthat requires a proof the array is non-empty.\n\nReturns the last element of an array, or panics if the array is empty.Safer alternatives include Array.back, which requires a proof the array is non-empty, and\nArray.back?, which returns an Option.\n\nReturns the largest element of the array, as determined by the comparison lt, or none if\nthe array is empty.Examples:* (#[] : Array Nat).getMax? (· < ·) = none* #[\"red\", \"green\", \"blue\"].getMax? (·.length < ·.length) = some \"green\"* #[\"red\", \"green\", \"blue\"].getMax? (· < ·) = some \"red\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.3. Lookups","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Lookups"},"/Basic-Types/Maps-and-Sets/#raw-data":{"contents":"Both hash-based and tree-based maps rely on certain internal well-formedness invariants, such as that trees are balanced and ordered.\nIn Lean's standard library, these data structures are represented as a pair of the underlying data with a proof that it is well formed.\nThis fact is mostly an internal implementation detail; however, it is relevant to users in one situation: this representation prevents them from being used in nested inductive types.\n\nTo enable their use in nested inductive types, the standard library provides “raw” variants of each container along with separate “unbundled” versions of their invariants.\nThese use the following naming convention:\n\n* T.Raw is the version of type T without its invariants. For example, Std.HashMap.Raw is a version of Std.HashMap without the embedded proofs.* T.Raw.WF is the corresponding well-formedness predicate. For example, Std.HashMap.Raw.WF asserts that a Std.HashMap.Raw is well-formed.* Each operation on T, called T.f, has a corresponding operation on T.Raw called T.Raw.f. For example, Std.HashMap.Raw.insert is the version of Std.HashMap.insert to be used with raw hash maps.* Each operation T.Raw.f has an associated well-formedness lemma T.Raw.WF.f. For example, Std.HashMap.Raw.WF.insert asserts that inserting a new key-value pair into a well-formed raw hash map results in a well-formed raw hash map.\n\nBecause the vast majority of use cases do not require them, not all lemmas about raw types are imported by default with the data structures.\nIt is usually necessary to import Std.Data.T.RawLemmas (where T is the data structure in question).\n\nA nested inductive type that occurs inside a map or set should be defined in three stages:\n\n1. First, define a raw version of the nested inductive type that uses the raw version of the map or set type. Define any necessary operations.2. Next, define an inductive predicate that asserts that all maps or sets in the raw nested type are well formed. Show that the operations on the raw type preserve well-formedness.3. Construct an appropriate interface to the nested inductive type by defining an API that proves well-formedness properties as needed, hiding them from users.\n\nNested Inductive Types with Std.HashMapThis example requires that Std.Data.HashMap.RawLemmas is imported.\nTo keep the code shorter, the Std namespace is opened:open Std\nThe map of an adventure game may consist of a series of rooms, connected by passages.\nEach room has a description, and each passage faces in a particular direction.\nThis can be represented as a recursive structure.structure Maze where\n  description : String\n  passages : HashMap String Maze\nThis definition is rejected:(kernel) application type mismatch\n  DHashMap.Raw.WF inner\nargument has type\n  _nested.Std.DHashMap.Raw_3\nbut function has type\n  (DHashMap.Raw String fun x => Maze) → Prop\nMaking this work requires separating the well-formedness predicates from the structure.\nThe first step is to redefine the type without embedded hash map invariants:structure RawMaze where\n  description : String\n  passages : Std.HashMap.Raw String RawMaze\nThe most basic raw maze has no passages:def RawMaze.base (description : String) : RawMaze where\n  description := description\n  passages := ∅\nA passage to a further maze can be added to a raw maze using RawMaze.insert:def RawMaze.insert (maze : RawMaze)\n    (direction : String) (next : RawMaze) : RawMaze :=\n  { maze with\n    passages := maze.passages.insert direction next\n  }\nThe second step is to define a well-formedness predicate for RawMaze that ensures that each included hash map is well-formed.\nIf the passages field itself is well-formed, and all raw mazes included in it are well-formed, then a raw maze is well-formed.inductive RawMaze.WF : RawMaze → Prop\n  | mk {description passages} :\n    (∀ (dir : String) v, passages[dir]? = some v → WF v) →\n    passages.WF →\n    WF { description, passages := passages }\nBase mazes are well-formed, and inserting a passage to a well-formed maze into some other well-formed maze produces a well-formed maze:theorem RawMaze.base_wf (description : String) :\n    RawMaze.WF (.base description) := by\n  constructor\n  . intro v h h'\n    simp [Std.HashMap.Raw.getElem?_empty] at *\n  . exact HashMap.Raw.WF.empty\n\ndef RawMaze.insert_wf (maze : RawMaze) :\n    WF maze → WF next → WF (maze.insert dir next) := by\n  let ⟨desc, passages⟩ := maze\n  intro ⟨wfMore, wfPassages⟩ wfNext\n  constructor\n  . intro dir' v\n    rw [HashMap.Raw.getElem?_insert wfPassages]\n    split <;> intros <;> simp_all [wfMore dir']\n  . simp_all [HashMap.Raw.WF.insert]\nFinally, a more friendly interface can be defined that frees users from worrying about well-formedness.\nA Maze bundles up a RawMaze with a proof that it is well-formed:structure Maze where\n  raw : RawMaze\n  wf : raw.WF\nThe base and insert operators take care of the well-formedness proof obligations:def Maze.base (description : String) : Maze where\n  raw := .base description\n  wf := by apply RawMaze.base_wf\n\ndef Maze.insert (maze : Maze)\n    (dir : String) (next : Maze) : Maze where\n  raw := maze.raw.insert dir next.raw\n  wf := RawMaze.insert_wf maze.raw maze.wf next.wf\nUsers of the Maze API may either check the description of the current maze or attempt to go in a direction to a new maze:def Maze.description (maze : Maze) : String :=\n  maze.raw.description\n\ndef Maze.go? (maze : Maze) (dir : String) : Option Maze :=\n  match h : maze.raw.passages[dir]? with\n  | none => none\n  | some m' =>\n    Maze.mk m' <| by\n      let ⟨r, wf⟩ := maze\n      let ⟨wfAll, _⟩ := wf\n      apply wfAll dir\n      apply h\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Library Design","header":"19.18.1.2. Raw Data and Invariants","id":"/Basic-Types/Maps-and-Sets/#raw-data"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-relations":{"contents":"This tactic applies to a goal whose target has the form x ~ x,\nwhere ~ is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n\nrfl' is similar to rfl, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n\nThe same as rfl, but without trying eq_refl at the end.\n\nReflexive RelationsThe refl attribute marks a lemma as a proof of reflexivity for some relation.\nThese lemmas are used by the rfl, rfl', and apply_rfl tactics.\n\n* symm applies to a goal whose target has the form t ~ u where ~ is a symmetric relation,\nthat is, a relation which has a symmetry lemma tagged with the attribute [symm].\nIt replaces the target with u ~ t.* symm at h will rewrite a hypothesis h : t ~ u to h : u ~ t.\n\nFor every hypothesis h : a ~ b where a @[symm] lemma is available,\nadd a hypothesis h_symm : b ~ a.\n\nSymmetric RelationsThe symm attribute marks a lemma as a proof that a relation is symmetric.\nThese lemmas are used by the symm and symm_saturate tactics.\n\nStep-wise reasoning over transitive relations.calc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\nproves a = z from the given step-wise proofs. = can be replaced with any\nrelation implementing the typeclass Trans. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with _.calc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\nIt is also possible to write the first relation as <lhs>\\n  _ = <rhs> := <proof>. This is useful for aligning relation symbols, especially on longer:\nidentifiers:calc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\ncalc works as a term, as a tactic or as a conv tactic.See Theorem Proving in Lean 4 for more information.\n\nTransitive chaining of proofs, used e.g. by calc.It takes two relations r and s as \"input\", and produces an \"output\"\nrelation t, with the property that r a b and s b c implies t a c.\nThe calc tactic uses this so that when it sees a chain with a ≤ b and b < c\nit knows that this should be a proof of a < c because there is an instance\nTrans (·≤·) (·<·) (·<·).Compose two proofs by transitivity, generalized over the relations involved.\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.4. Relations","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-relations"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-same-universe":{"contents":"The universe levels of each inductive type in a mutual group must obey the same requirements as non-mutually-recursive inductive types.\nAdditionally, all the inductive types in a mutual group must be in the same universe, which implies that their constructors are similarly limited with respect to their parameters' universes.\n\nUniverse mismatchThese mutually-inductive types are a somewhat complicated way to represent run-length encoding of a list:mutual\n  inductive RLE : List α → Type where\n  | nil : RLE []\n  | run (x : α) (n : Nat) :\n    n ≠ 0 → PrefixRunOf n x xs ys → RLE ys → RLE xs\n\n  inductive PrefixRunOf : Nat → α → List α → List α → Type where\n  | zero\n    (noMore : ¬∃zs, xs = x :: zs := by simp) :\n    PrefixRunOf 0 x xs xs\n  | succ :\n    PrefixRunOf n x xs ys →\n    PrefixRunOf (n + 1) x (x :: xs) ys\nend\n\nexample : RLE [1, 1, 2, 2, 3, 1, 1, 1] :=\n  .run 1 2 (by decide) (.succ (.succ .zero)) <|\n  .run 2 2 (by decide) (.succ (.succ .zero)) <|\n  .run 3 1 (by decide) (.succ .zero) <|\n  .run 1 3 (by decide) (.succ (.succ (.succ (.zero)))) <|\n  .nil\nSpecifying PrefixRunOf as a Prop would be sensible, but it cannot be done because the types would be in different universes:mutual\n  inductive RLE : List α → Type where\n  | nil : RLE []\n  | run\n    (x : α) (n : Nat) :\n    n ≠ 0 → PrefixRunOf n x xs ys → RLE ys →\n    RLE xs\n\n  inductive PrefixRunOf : Nat → α → List α → List α → Prop where\n  | zero\n    (noMore : ¬∃zs, xs = x :: zs := by simp) :\n    PrefixRunOf 0 x xs xs\n  | succ :\n    PrefixRunOf n x xs ys →\n    PrefixRunOf (n + 1) x (x :: xs) ys\nend\nInvalid mutually inductive types: The resulting type of this declaration\n  Prop\ndiffers from a preceding one\n  Type\n\nNote: All inductive types declared in the same `mutual` block must belong to the same type universe\nThis particular property can be expressed by separately defining the well-formedness condition and using a subtype:def RunLengths α := List (α × Nat)\ndef NoRepeats : RunLengths α → Prop\n  | [] => True\n  | [_] => True\n  | (x, _) :: ((y, n) :: xs) =>\n    x ≠ y ∧ NoRepeats ((y, n) :: xs)\ndef RunsMatch : RunLengths α → List α → Prop\n  | [], [] => True\n  | (x, n) :: xs, ys =>\n    ys.take n = List.replicate n x ∧\n    RunsMatch xs (ys.drop n)\n  | _, _ => False\ndef NonZero : RunLengths α → Prop\n  | [] => True\n  | (_, n) :: xs => n ≠ 0 ∧ NonZero xs\nstructure RLE (xs : List α) where\n  rle : RunLengths α\n  noRepeats : NoRepeats rle\n  runsMatch : RunsMatch rle xs\n  nonZero : NonZero rle\n\nexample : RLE [1, 1, 2, 2, 3, 1, 1, 1] where\n  rle := [(1, 2), (2, 2), (3, 1), (1, 3)]\n  noRepeats := by simp [NoRepeats]\n  runsMatch := by simp [RunsMatch]\n  nonZero := by simp [NonZero]\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types\u0009Requirements","header":"4.4.5.1.3. Universe Levels","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-same-universe"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Server":{"contents":"* #6597 fixes the indentation of nested traces nodes in the info view.* #6794 fixes a significant auto-completion performance regression that\nwas introduced in #5666, i.e. v4.14.0.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Server","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Server"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--BitVec-API":{"contents":"* #7104 adds BitVec.[toNat|toFin|toInt]_[sshiftRight|sshiftRight']\nplus variants with of_msb_*. While at it, we also add\ntoInt_zero_length and toInt_of_zero_length. In support of our main\ntheorem we add toInt_shiftRight_lt and le_toInt_shiftRight, which\nmake the main theorem automatically derivable via omega.* #7225 contains BitVec.(toInt, toFin)_twoPow theorems, completing the\nAPI for BitVec.*_twoPow. It also expands the toNat_twoPow API with\ntoNat_twoPow_of_le, toNat_twoPow_of_lt, as well as\ntoNat_twoPow_eq_if and moves msb_twoPow up, as it is used in the\ntoInt_msb proof.* #7415 adds a few lemmas about the interactions of BitVec with Fin\nand Nat.* #7420 generalizes BitVec.toInt_[lt|le]' to not require 0 < w.* #7465 adds the theorem:theorem lt_allOnes_iff {x : BitVec w} : x < allOnes w ↔ x ≠ allOnes w\nto simplify comparisons against -1#w. This is a corollary of the\nexisting lemma:theorem allOnes_le_iff {x : BitVec w} : allOnes w ≤ x ↔ x = allOnes w\n* #7599 adds SMT-LIB operators to detect overflow BitVec.(usubOverflow, ssubOverflow), according to the SMTLIB\nstandard,\nand the theorems proving equivalence of such definition with the\nBitVec library functions BittVec.(usubOverflow_eq, ssubOverflow_eq).* #7604 adds bitvector theorems that to push negation into other\noperations, following Hacker's Delight: Ch2.1.* #7605 adds theorems BitVec.[(toInt, toFin)_(extractLsb, extractLsb')], completing the API for BitVec.(extractLsb, extractLsb').* #7616 introduces BitVec.(toInt, toFin)_rotate(Left, Right),\ncompleting the API for BitVec.rotate(Left, Right)* #7658 introduces BitVec.(toFin_signExtend_of_le, toFin_signExtend),\ncompleting the API for BitVec.signExtend.* #7661 adds theorems BitVec.[(toFin, toInt)_setWidth', msb_setWidth'_of_lt, toNat_lt_twoPow_of_le, toInt_setWidth'_of_lt],\ncompleting the API for BitVec.setWidth'.* #7699 adds the BitVec.toInt_srem lemma, relating BitVec.srem with\nInt.tmod.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Library","header":"BitVec API","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--BitVec-API"}});