window.docContents[145].resolve({"/Basic-Types/Integers/#int-runtime":{"contents":"Like natural numbers, sufficiently-small integers are represented without pointers: the lowest-order bit in an object pointer is used to indicate that the value is not, in fact, a pointer.\nIf an integer is too large to fit in the remaining bits, it is instead allocated as an ordinary Lean object that consists of an object header and an arbitrary-precision integer.\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers","header":"19.2.2. Run-Time Representation","id":"/Basic-Types/Integers/#int-runtime"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map, and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.If the returned Bool is true, then the returned map is unaltered. If the Bool is false, then\nthe returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the hash map for which the given function returns false.\n\nUpdates the values of the hash map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.Note: this replacement behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insert function on HashSet and HashSet.Raw behaves differently: it will return the set\nunchanged if a matching key is already present.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nInserts multiple mappings into the hash map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insertMany function on HashSet and HashSet.Raw behaves differently: it will prefer the first\nappearance.\n\nPartition a hash map into two hash map based on a predicate.\n\nComputes the union of the given hash maps. If a key appears in both maps, the entry contains in\nthe second argument will appear in the result.This function always merges the smaller map into the larger map, so the expected runtime is\nO(min(m₁.size, m₂.size)).\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","header":"19.18.3.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Modification"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Size":{"contents":"Checks whether a slice is empty.Empty slices have utf8ByteSize 0.Examples:* \"\".toSlice.isEmpty = true* \" \".toSlice.isEmpty = false\n\nThe number of bytes of the UTF-8 encoding of the string slice.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.2. Size","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Size"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-override":{"contents":"Directory-specific toolchain overrides are a local configuration that takes precedence over lean-toolchain files.\nThe elan override commands manage overrides.\n\n\n\nLists all the currently configured directory overrides in two columns.\nThe left column contains the directories in which the Lean version is overridden, and the right column lists the toolchain version.\n\nSets toolchain as an override for the current directory.\n\nIf --nonexistent flag is provided, all overrides that are configured for directories that don't currently exist are removed.\nIf --path is provided, then the override set for path is removed.\nOtherwise, the override for the current directory is removed.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Command-Line Interface","header":"22.2.3.4. Managing Directory Overrides","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-override"},"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent":{"contents":"\n\nThis error indicates that dotted identifier notation was used in an invalid or unsupported context.\nDotted identifier notation allows an identifier's namespace to be omitted, provided that it can be\ninferred by Lean based on type information. Details about this notation can be found in the manual\nsection on identifiers.\n\nThis notation can only be used in a term whose type Lean is able to infer. If there is insufficient\ntype information for Lean to do so, this error will be raised. The inferred type must not be a type\nuniverse (e.g., Prop or Type), as dotted-identifier notation is not supported on these types.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.invalidDottedIdent","id":"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent"},"/IO/Console-Output/#The-Lean-Language-Reference--IO--Console-Output":{"contents":"Lean includes convenience functions for writing to standard output and standard error.\nAll make use of ToString instances, and the varieties whose names end in -ln add a newline after the output.\nThese convenience functions only expose a part of the functionality available using the standard I/O streams.\nIn particular, to read a line from standard input, use a combination of IO.getStdin and IO.FS.Stream.getLine.\n\nConverts s to a string using its ToString α instance, and prints it to the current standard\noutput (as determined by IO.getStdout).\n\nConverts s to a string using its ToString α instance, and prints it with a trailing newline to\nthe current standard output (as determined by IO.getStdout).\n\nConverts s to a string using its ToString α instance, and prints it to the current standard\nerror (as determined by IO.getStderr).\n\nConverts s to a string using its ToString α instance, and prints it with a trailing newline to\nthe current standard error (as determined by IO.getStderr).\n\nPrintingThis program demonstrates all four convenience functions for console I/O.def main : IO Unit := do\n  IO.print \"This is the \"\n  IO.print \"Lean\"\n  IO.println \" language reference.\"\n  IO.println \"Thank you for reading it!\"\n  IO.eprint \"Please report any \"\n  IO.eprint \"errors\"\n  IO.eprintln \" so they can be corrected.\"\nIt outputs the following to the standard output:This is the Lean language reference.\nThank you for reading it!\nand the following to the standard error:Please report any errors so they can be corrected.\n\n\n","context":"Lean Reference\u0009IO","header":"15.3. Console Output","id":"/IO/Console-Output/#The-Lean-Language-Reference--IO--Console-Output"},"/The--grind--tactic/E___matching/#grind-limits":{"contents":"E-matching can generate an unbounded number of theorem instances.\nFor the sake of both efficiency and termination, grind limits the number of times that E-matching can run using two mechanisms:\n\n Generations\n\nEach term is assigned a generation, and terms produced by E-matching have a generation that is one greater than the maximal generation of all the terms used to instantiate the theorem.\n  E-matching only considers terms whose generation is beneath a configurable threshold.\n  The gen option to grind controls the generation threshold.\n\n Round Limits\n\nEach invocation of the E-matching engine is referred to as a round.\n  Only a limited number of rounds of E-matching are performed.\n  The ematch option to grind controls the round limit.\n\n\n\nToo Many InstancesE-matching can generate too many theorem instances.\nSome patterns may even generate an unbounded number of instances.In this example, s_eq is added to the index with the pattern s x:def s (x : Nat) := 0\n\n@[grind? =] theorem s_eq (x : Nat) : s x = s (x + 1) :=\n  rfl\ns_eq: [s #0]\nAttempting to use this theorem results in many facts about s applied to concrete values being generated.\nIn particular, s_eq is instantiated with a new Nat in each of the five rounds.\nFirst, grind instantiates s_eq with x := 0, which generates the term s 1.\nThis matches the pattern s x, and is thus used to instantiate s_eq with x := 1, which generates the term s 2,\nand so on until the round limit is reached.example : s 0 > 0 := by\n  grind\n`grind` failed\ncase grind\nh : s 0 = 0\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n    [prop] s 0 = 0\n    [prop] s 0 = s 1\n    [prop] s 1 = s 2\n    [prop] s 2 = s 3\n    [prop] s 3 = s 4\n    [prop] s 4 = s 5\n  [eqc] Equivalence classes\n  [ematch] E-matching patterns\n    [thm] s_eq: [s #0]\n  [cutsat] Assignment satisfying linear constraints\n  [limits] Thresholds reached\n    [limit] maximum number of E-matching rounds has been reached, threshold: `(ematch := 5)`\n\n[grind] Diagnostics\nIncreasing the round limit to 20 causes E-matching to terminate due to the default generation limit of 8:example : s 0 > 0 := by\n  grind (ematch := 20)\n`grind` failed\ncase grind\nh : s 0 = 0\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n    [prop] s 0 = 0\n    [prop] s 0 = s 1\n    [prop] s 1 = s 2\n    [prop] s 2 = s 3\n    [prop] s 3 = s 4\n    [prop] s 4 = s 5\n    [prop] s 5 = s 6\n    [prop] s 6 = s 7\n    [prop] s 7 = s 8\n  [eqc] Equivalence classes\n  [ematch] E-matching patterns\n    [thm] s_eq: [s #0]\n  [cutsat] Assignment satisfying linear constraints\n  [limits] Thresholds reached\n    [limit] maximum term generation has been reached, threshold: `(gen := 8)`\n\n[grind] Diagnostics\n\n\nIncreasing E-matching Limitsiota returns the list of all numbers strictly less than its argument, and the theorem iota_succ describes its behavior on Nat.succ:def iota : Nat → List Nat\n  | 0 => []\n  | n + 1 => n :: iota n\n\n@[grind =] theorem iota_succ : iota (n + 1) = n :: iota n :=\n  rfl\nThe fact that (iota 20).length > 10 can be proven by repeatedly instantiating iota_succ and List.length_cons.\nHowever, grind does not succeed:example : (iota 20).length > 10 := by\n  grind\n`grind` failed\ncase grind\nh : (iota 20).length ≤ 10\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n    [prop] (iota 20).length ≤ 10\n    [prop] iota 20 = 19 :: iota 19\n    [prop] iota 19 = 18 :: iota 18\n    [prop] (19 :: iota 19).length = (iota 19).length + 1\n    [prop] iota 18 = 17 :: iota 17\n    [prop] (18 :: iota 18).length = (iota 18).length + 1\n    [prop] iota 17 = 16 :: iota 16\n    [prop] (17 :: iota 17).length = (iota 17).length + 1\n    [prop] iota 16 = 15 :: iota 15\n    [prop] (16 :: iota 16).length = (iota 16).length + 1\n  [eqc] True propositions\n  [eqc] Equivalence classes\n  [ematch] E-matching patterns\n  [cutsat] Assignment satisfying linear constraints\n  [ring] Ring `Lean.Grind.Ring.OfSemiring.Q Nat`\n  [limits] Thresholds reached\n    [limit] maximum number of E-matching rounds has been reached, threshold: `(ematch := 5)`\n\n[grind] Diagnostics\nDue to the limited number of E-matching rounds, the chain of instantiations is not completed.\nIncreasing these limits allows grind to succeed:example : (iota 20).length > 10 := by\n  grind (gen := 20) (ematch := 20)\nWhen the option diagnostics is set to true, grind displays the number of instances that it generates for each theorem.\nThis is useful to detect theorems that contain patterns that are triggering too many instances.\nIn this case, the diagnostics show that iota_succ is instantiated 14 times:set_option diagnostics true in\nexample : (iota 20).length > 10 := by\n  grind (gen := 20) (ematch := 20)\n[grind] Diagnostics\n  [thm] E-Matching instances\n    [thm] iota_succ ↦ 14\n    [thm] List.length_cons ↦ 11\n  [app] Applications\n\n\nBy default, grind uses automatically generated equations for match-expressions as E-matching theorems.\nThis can be disabled by setting the matchEqs flag to false.\n\nE-matching and Pattern MatchingEnabling diagnostics shows that grind uses one of the equations of the auxiliary matching function during E-matching:theorem gt1 (x y : Nat) :\n    x = y + 1 →\n    0 < match x with\n        | 0 => 0\n        | _ + 1 => 1 := by\n  set_option diagnostics true in\n  grind\n[grind] Diagnostics\n  [thm] E-Matching instances\n    [thm] gt1.match_1.congr_eq_2 ↦ 1\n  [app] Applications\nThe theorem has this type:#check gt1.match_1.congr_eq_2\ngt1.match_1.congr_eq_2.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive 0)\n  (h_2 : (n : Nat) → motive n.succ) (n✝ : Nat) (heq_1 : x✝ = n✝.succ) :\n  (match x✝ with\n    | 0 => h_1 ()\n    | n.succ => h_2 n) ≍\n    h_2 n✝\nDisabling the use of matcher function equations causes the proof to fail:example (x y : Nat)\n    : x = y + 1 →\n      0 < match x with\n          | 0 => 0\n          | _+1 => 1 := by\n  grind -matchEqs\n`grind` failed\ncase grind.2\nx y : Nat\nh : x = y + 1\nh_1 : (match x with\n  | 0 => 0\n  | n.succ => 1) =\n  0\nn : Nat\nh_2 : x = n + 1\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] Equivalence classes\n  [cases] Case analyses\n  [cutsat] Assignment satisfying linear constraints\n  [ring] Ring `Lean.Grind.Ring.OfSemiring.Q Nat`\n\n\nenable/disable tracing for the given module and submodules\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009E‑matching","header":"17.6.3. Resource Limits","id":"/The--grind--tactic/E___matching/#grind-limits"},"/The-Type-System/Inductive-Types/#recursor-elaboration-helpers":{"contents":"In addition to the type constructor, constructors, and recursors that Lean's core type theory prescribes for inductive types, Lean constructs a number of useful helpers.\nFirst, the equation compiler (which translates recursive functions with pattern matching in to applications of recursors) makes use of these additional constructs:\n\n* recOn is a version of the recursor in which the major premise is prior to the minor premise for each constructor.* casesOn is a version of the recursor in which the major premise is prior to the minor premise for each constructor, and recursive arguments do not yield induction hypotheses. It expresses case analysis rather than primitive recursion.* below computes a type that, for some motive, expresses that all inhabitants of the inductive type that are subtrees of the major premise satisfy the motive. It transforms a motive for induction or primitive recursion into a motive for strong recursion or strong induction.* brecOn is a version of the recursor in which below is used to provide access to all subtrees, rather than just immediate recursive parameters. It represents strong induction.* noConfusion is a general statement from which injectivity and disjointness of constructors can be derived.* noConfusionType is the motive used for noConfusion that determines what the consequences of two constructors being equal would be. For separate constructors, this is False; if both constructors are the same, then the consequence is the equality of their respective parameters.\n\nThese constructions follow the description in .\n\nFor well-founded recursion, it is frequently useful to have a generic notion of size available.\nThis is captured in the SizeOf class.\n\nSizeOf is a typeclass automatically derived for every inductive type,\nwhich equips the type with a \"size\" function to Nat.\nThe default instance defines each constructor to be 1 plus the sum of the\nsizes of all the constructor fields.This is used for proofs by well-founded induction, since every field of the\nconstructor has a smaller size than the constructor itself,\nand in many cases this will suffice to do the proof that a recursive function\nis only called on smaller values.\nIf the default proof strategy fails, it is recommended to supply a custom\nsize measure using the termination_by argument on the function definition.The \"size\" of an element, a natural number which decreases on fields of\neach inductive type.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model","header":"4.4.3.3. Constructions for Termination Checking","id":"/The-Type-System/Inductive-Types/#recursor-elaboration-helpers"},"/The-Type-System/Quotients/#quotient-reduction":{"contents":"\n\nIn addition to the above constants, Lean's kernel contains a reduction rule for Quot.lift that causes it to reduce when used with Quot.mk, analogous to ι-reduction for inductive types.\nGiven a relation r over α, a function f from α to β, and a proof resp that f respects r, the term Quot.lift f resp (Quot.mk r x) is definitionally equal to f x.\n\n\n\n\n\nvariable\n  (r : α → α → Prop)\n  (f : α → β)\n  (ok : ∀ x y, r x y → f x = f y)\n  (x : α)\n\nexample : Quot.lift f ok (Quot.mk r x) = f x := rfl\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Logical Model","header":"4.5.5.1. Quotient Reduction","id":"/The-Type-System/Quotients/#quotient-reduction"}});