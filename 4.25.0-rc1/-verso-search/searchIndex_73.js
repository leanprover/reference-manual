window.docContents[73].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Proof-Automation--Bit-Blasting":{"contents":"The standard library contains a number of helper implementations that are useful to implement bit blasting, which is the technique used by bv_decide to encode propositions as Boolean satisfiability problems for external solvers.\n\nBitwise addition implemented via a ripple carry adder.\n\nCarry function for bitwise addition.\n\ncarry i x y c returns true if the i carry bit is true when computing x + y + c.\n\nA recurrence that describes multiplication as repeated addition.This function is useful for bit blasting multiplication.\n\nA recursive definition of division for bit blasting, in terms of a shift-subtraction circuit.\n\nOne round of the division algorithm. It tries to perform a subtract shift.This should only be called when r.msb = false, so it will not overflow.\n\nShifts x to the left by the first n bits of y.The theorem BitVec.shiftLeft_eq_shiftLeftRec proves the equivalence of (x <<< y) and\nBitVec.shiftLeftRec x y.Together with equations BitVec.shiftLeftRec_zero and BitVec.shiftLeftRec_succ, this allows\nBitVec.shiftLeft to be unfolded into a circuit for bit blasting.\n\nShifts x arithmetically (signed) to the right by the first n bits of y.The theorem BitVec.sshiftRight_eq_sshiftRightRec proves the equivalence of (x.sshiftRight y) and\nBitVec.sshiftRightRec x y. Together with equations BitVec.sshiftRightRec_zero, and\nBitVec.sshiftRightRec_succ, this allows BitVec.sshiftRight to be unfolded into a circuit for\nbit blasting.\n\nShifts x logically to the right by the first n bits of y.The theorem BitVec.shiftRight_eq_ushiftRightRec proves the equivalence\nof (x >>> y) and BitVec.ushiftRightRec.Together with equations BitVec.ushiftRightRec_zero and BitVec.ushiftRightRec_succ,\nthis allows BitVec.ushiftRight to be unfolded into a circuit for bit blasting.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference\u0009Proof Automation","header":"19.5.5.10.1. Bit Blasting","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Proof-Automation--Bit-Blasting"},"/Functors___-Monads-and--do--Notation/Syntax/#monad-iteration-syntax":{"contents":"Within a do block, for​…​in loops allow iteration over a data structure.\nThe body of the loop is part of the containing do block, so local effects such as early return and mutable variables may be used.\n\nIteration over Collections\n\nA for​…​in loop requires at least one clause that specifies the iteration to be performed, which consists of an optional membership proof name followed by a colon (:), a pattern to bind, the keyword in, and a collection term.\nThe pattern, which may just be an identifier, must match any element of the collection; patterns in this position cannot be used as implicit filters.\nFurther clauses may be provided by separating them with commas.\nEach collection is iterated over at the same time, and iteration stops when any of the collections runs out of elements.\n\nIteration Over Multiple CollectionsWhen iterating over multiple collections, iteration stops when any of the collections runs out of elements.#eval Id.run do\n  let mut v := #[]\n  for x in [0:43], y in ['a', 'b'] do\n    v := v.push (x, y)\n  return v\n#[(0, 'a'), (1, 'b')]\n\n\nIteration over Array Indices with forWhen iterating over the valid indices for an array with for, naming the membership proof allows the tactic that searches for proofs that array indices are in bounds to succeed.def satisfyingIndices\n    (p : α → Prop) [DecidablePred p]\n    (xs : Array α) : Array Nat := Id.run do\n  let mut out := #[]\n  for h : i in [0:xs.size] do\n    if p xs[i] then out := out.push i\n  return out\nOmitting the hypothesis name causes the array lookup to fail, because no proof is available in the context that the iteration variable is within the specified range.\n\nIteration with for-loops is translated into uses of ForIn.forIn, which is an analogue of ForM.forM with added support for local mutations and early termination.\nForIn.forIn receives an initial value for the local mutable state and a monadic action as parameters, along with the collection being iterated over.\nThe monadic action passed to ForIn.forIn takes a current state as a parameter and, after carrying out actions in the monad m, returns either ForInStep.yield to indicate that iteration should continue with an updated set of local mutable values, or ForInStep.done to indicate that break or return was executed.\nWhen iteration is complete, ForIn.forIn returns the final values of the local mutable values.The specific desugaring of a loop depends on how state and early termination are used in its body.\nHere are some examples:* do Item* Desugaring\n* do\nlet mut b := …\nfor x in xs do\n  b ← f x b\nes\n* do\nlet b := …\nlet b ← ForIn.forIn xs b fun x b => do\n  let b ← f x b\n  return ForInStep.yield b\nes\n* do\nlet mut b := …\nfor x in xs do\n  b ← f x b\n  break\nes\n* do\nlet b := …\nlet b ← ForIn.forIn xs b fun x b => do\n  let b ← f x b\n  return ForInStep.done b\nes\n* do\nlet mut b := …\nfor h : x in xs do\n  b ← f' x h b\nes\n* do\nlet b := …\nlet b ← ForIn'.forIn' xs b fun x h b => do\n  let b ← f' x h b\n  return ForInStep.yield b\nes\n* do\nlet mut b := …\nfor h : x in xs do\n  b ← f' x h b\n  break\nes\n* do\nlet b := …\nlet b ← ForIn'.forIn' xs b fun x h b => do\n  let b ← f' x h b\n  return ForInStep.done b\nes\n\n\nThe body of a while loop is repeated while the condition remains true.\nIt is possible to write infinite loops using them in functions that are not marked partial.\nThis is because the partial modifier only applies to non-termination or infinite regress induced by the function being defined, and not by those that it calls.\nThe translation of while loops relies on a separate helper.\n\nConditional Loops\n\nThe body of a repeat-until loop is always executed at least once.\nAfter each iteration, the condition is checked, and the loop is repeated when the condition is false.\nWhen the condition becomes true, iteration stops.\n\nPost-Tested Loops\n\nThe body of a repeat loop is repeated until a break statement is executed.\nJust like while loops, these loops can be used in functions that are not marked partial.\n\nUnconditional Loops\n\nThe continue statement skips the rest of the body of the closest enclosing repeat, while, or for loop, moving on to the next iteration.\nThe break statement terminates the closest enclosing repeat, while, or for loop, stopping iteration.\n\nLoop Control Statements\n\nIn addition to break, loops can always be terminated by effects in the current monad.\nThrowing an exception from a loop terminates the loop.\n\nTerminating Loops in the Option MonadThe failure method from the Alternative class can be used to terminate an otherwise-infinite loop in the Option monad.#eval show Option Nat from do\n  let mut i := 0\n  repeat\n    if i > 1000 then failure\n    else i := 2 * (i + 1)\n  return i\nnone\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.5. Iteration","id":"/Functors___-Monads-and--do--Notation/Syntax/#monad-iteration-syntax"}});