window.docContents[123].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Boundaries--Adjustment":{"contents":"Given a slice and a valid position within the slice, obtain a new slice on the same underlying\nstring by replacing the start of the slice with the given position.\n\nGiven a slice and two valid positions within the slice, obtain a new slice on the same underlying\nstring formed by the new bounds.\n\nGiven a slice and two valid positions within the slice, obtain a new slice on the same underlying\nstring formed by the new bounds, or panic if the given end is strictly less than the given start.\n\nRemoves the specified number of characters (Unicode code points) from the start of the slice.If n is greater than the amount of characters in s, returns an empty slice.Examples:* \"red green blue\".toSlice.drop 4 == \"green blue\".toSlice* \"red green blue\".toSlice.drop 10 == \"blue\".toSlice* \"red green blue\".toSlice.drop 50 == \"\".toSlice\n\nRemoves the specified number of characters (Unicode code points) from the end of the slice.If n is greater than the amount of characters in s, returns an empty slice.Examples:* \"red green blue\".toSlice.dropEnd 5 == \"red green\".toSlice* \"red green blue\".toSlice.dropEnd 11 == \"red\".toSlice* \"red green blue\".toSlice.dropEnd 50 == \"\".toSlice\n\nCreates a new slice that contains the longest suffix of s for which pat matched\n(potentially repeatedly).Examples:* \"red green blue\".toSlice.dropEndWhile Char.isLower == \"red green \".toSlice* \"red green blue\".toSlice.dropEndWhile 'e' == \"red green blu\".toSlice* \"red green blue\".toSlice.dropEndWhile (fun (_ : Char) => true) == \"\".toSlice\n\nIf pat matches a prefix of s, returns the remainder. Returns s unmodified\notherwise.Use String.Slice.dropPrefix? to return none when pat does not match a prefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropPrefix \"red \" == \"green blue\".toSlice* \"red green blue\".toSlice.dropPrefix \"reed \" == \"red green blue\".toSlice* \"red green blue\".toSlice.dropPrefix 'r' == \"ed green blue\".toSlice* \"red green blue\".toSlice.dropPrefix Char.isLower == \"ed green blue\".toSlice\n\nIf pat matches a prefix of s, returns the remainder. Returns none otherwise.Use String.Slice.dropPrefix to return the slice\nunchanged when pat does not match a prefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropPrefix? \"red \" == some \"green blue\".toSlice* \"red green blue\".toSlice.dropPrefix? \"reed \" == none* \"red green blue\".toSlice.dropPrefix? 'r' == some \"ed green blue\".toSlice* \"red green blue\".toSlice.dropPrefix? Char.isLower == some \"ed green blue\".toSlice\n\nIf pat matches a suffix of s, returns the remainder. Returns s unmodified\notherwise.Use String.Slice.dropSuffix? to return none when pat does not match a\nprefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropSuffix \" blue\" == \"red green\".toSlice* \"red green blue\".toSlice.dropSuffix \"bluu \" == \"red green blue\".toSlice* \"red green blue\".toSlice.dropSuffix 'e' == \"red green blu\".toSlice* \"red green blue\".toSlice.dropSuffix Char.isLower == \"red green blu\".toSlice\n\nIf pat matches a suffix of s, returns the remainder. Returns none otherwise.Use String.Slice.dropSuffix to return the slice\nunchanged when pat does not match a prefix.This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.dropSuffix? \" blue\" == some \"red green\".toSlice* \"red green blue\".toSlice.dropSuffix? \"bluu \" == none* \"red green blue\".toSlice.dropSuffix? 'e' == some \"red green blu\".toSlice* \"red green blue\".toSlice.dropSuffix? Char.isLower == some \"red green blu\".toSlice\n\nCreates a new slice that contains the longest prefix of s for which pat matched\n(potentially repeatedly).Examples:* \"red green blue\".toSlice.dropWhile Char.isLower == \" green blue\".toSlice* \"red green blue\".toSlice.dropWhile 'r' == \"ed green blue\".toSlice* \"red red green blue\".toSlice.dropWhile \"red \" == \"green blue\".toSlice* \"red green blue\".toSlice.dropWhile (fun (_ : Char) => true) == \"\".toSlice\n\nCreates a new slice that contains the first n characters (Unicode code points) of s.If n is greater than the amount of characters in s, returns s.Examples:* \"red green blue\".toSlice.take 3 == \"red\".toSlice* \"red green blue\".toSlice.take 1 == \"r\".toSlice* \"red green blue\".toSlice.take 0 == \"\".toSlice* \"red green blue\".toSlice.take 100 == \"red green blue\".toSlice\n\nCreates a new slice that contains the last n characters (Unicode code points) of s.If n is greater than the amount of characters in s, returns s.Examples:* \"red green blue\".toSlice.takeEnd 4 == \"blue\".toSlice* \"red green blue\".toSlice.takeEnd 1 == \"e\".toSlice* \"red green blue\".toSlice.takeEnd 0 == \"\".toSlice* \"red green blue\".toSlice.takeEnd 100 == \"red green blue\".toSlice\n\nCreates a new slice that contains the suffix prefix of s for which pat matched\n(potentially repeatedly).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.takeEndWhile Char.isLower == \"blue\".toSlice* \"red green blue\".toSlice.takeEndWhile 'e' == \"e\".toSlice* \"red green blue\".toSlice.takeEndWhile (fun (_ : Char) => true) == \"red green blue\".toSlice\n\nCreates a new slice that contains the longest prefix of s for which pat matched\n(potentially repeatedly).This function is generic over all currently supported patterns.Examples:* \"red green blue\".toSlice.takeWhile Char.isLower == \"red\".toSlice* \"red green blue\".toSlice.takeWhile 'r' == \"r\".toSlice* \"red red green blue\".toSlice.takeWhile \"red \" == \"red red \".toSlice* \"red green blue\".toSlice.takeWhile (fun (_ : Char) => true) == \"red green blue\".toSlice\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference\u0009Boundaries","header":"19.8.4.12.1.3.1. Adjustment","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Boundaries--Adjustment"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Documentation":{"contents":"* #7947 adds some docstrings to clarify the functions of\nLean.mkFreshId, Lean.Core.mkFreshUserName,\nLean.Elab.Term.mkFreshBinderName, and\nLean.Meta.mkFreshBinderNameForTactic.* #8018 adjusts the RArray docstring to the new reality from #8014.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Documentation","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Documentation"}});