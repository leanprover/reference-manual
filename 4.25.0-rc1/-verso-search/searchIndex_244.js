window.docContents[244].resolve({"/Basic-Propositions/Propositional-Equality/#propositional-equality":{"contents":"Propositional equality is the operator that allows the equality of two terms to be stated as a proposition.\nDefinitional equality is checked automatically where necessary.\nAs a result, its expressive power is limited in order to keep the algorithm that checks it fast and understandable.\nPropositional equality, on the other hand, must be explicitly proved and explicitly used—Lean checks the validity of the proofs, rather than determining whether the statement is true.\nIn exchange, it is much more expressive: many terms are propositionally equal without being definitionally equal.\n\nPropositional equality is defined as an inductive type.\nIts sole constructor Eq.refl requires that both of the equated values be the same; this is implicitly an appeal to definitional equality.\nPropositional equality can also be thought of as the least reflexive relation modulo definitional equality.\nIn addition to Eq.refl, equality proofs are generated by the propext and Quot.sound axioms.\n\nThe equality relation. It has one introduction rule, Eq.refl.\nWe use a = b as notation for Eq a b.\nA fundamental property of equality is that it is an equivalence relation.variable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given h1 : a = b and h2 : p a, we can construct a proof for p b using substitution: Eq.subst h1 h2.\nExample:example (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\nThe triangle in the second presentation is a macro built on top of Eq.subst and Eq.symm, and you can enter it by typing \\t.\nFor more information: EqualityConventions for notations in identifiers:* The recommended spelling of = in identifiers is eq.Eq.refl a : a = a is reflexivity, the unique constructor of the\nequality type. See also rfl, which is usually used instead.\n\nPropositional EqualityPropositional equality is typically denoted by the infix = operator.\n\nrfl : a = a is the unique constructor of the equality type. This is the\nsame as Eq.refl except that it takes a implicitly instead of explicitly.This is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is a = a, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, 2 + 2 = 4 is proven in\nLean by rfl, because both sides are the same up to definitional equality.\n\nEquality is symmetric: if a = b then b = a.Because this is in the Eq namespace, if you have a variable h : a = b,\nh.symm can be used as shorthand for Eq.symm h as a proof of b = a.For more information: Equality\n\nEquality is transitive: if a = b and b = c then a = c.Because this is in the Eq namespace, if you have variables or expressions\nh₁ : a = b and h₂ : b = c, you can use h₁.trans h₂ : a = c as shorthand\nfor Eq.trans h₁ h₂.For more information: Equality\n\nThe substitution principle for equality. If a = b  and P a holds,\nthen P b also holds. We conventionally use the name motive for P here,\nso that you can specify it explicitly using e.g.\nEq.subst (motive := fun x => x < 5) if it is not otherwise inferred correctly.This theorem is the underlying mechanism behind the rw tactic, which is\nessentially a fancy algorithm for finding good motive arguments to usefully\napply this theorem to replace occurrences of a with b in the goal or\nhypotheses.For more information: Equality\n\nCast across a type equality. If h : α = β is an equality of types, and\na : α, then a : β will usually not typecheck directly, but this function\nwill allow you to work around this and embed a in type β as cast h a : β.It is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.For more information: Equality\n\nCongruence in both function and argument. If f₁ = f₂ and a₁ = a₂ then\nf₁ a₁ = f₂ a₂. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.For more information: Equality\n\nCongruence in the function part of an application: If f = g then f a = g a.\n\nCongruence in the function argument: if a₁ = a₂ then f a₁ = f a₂ for\nany (nondependent) function f. This is more powerful than it might look at first, because\nyou can also use a lambda expression for f to prove that\n<something containing a₁> = <something containing a₂>. This function is used\ninternally by tactics like congr and simp to apply equalities inside\nsubterms.For more information: Equality\n\nIf h : α = β is a proof of type equality, then h.mp : α → β is the induced\n\"cast\" operation, mapping elements of α to elements of β.You can prove theorems about the resulting element by induction on h, since\nrfl.mp is definitionally the identity function.\n\nIf h : α = β is a proof of type equality, then h.mpr : β → α is the induced\n\"cast\" operation in the reverse direction, mapping elements of β to elements of α.You can prove theorems about the resulting element by induction on h, since\nrfl.mpr is definitionally the identity function.\n\nCastingWhen a term's type includes one side of an equality as a sub-term, it can be rewritten using the ▸ operator.\nIf the both sides of the equality occur in the term's type, then the left side is rewritten to the right.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Propositions","header":"18.4. Propositional Equality","id":"/Basic-Propositions/Propositional-Equality/#propositional-equality"},"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Iterators":{"contents":"Creates an iterator at the beginning of an array.\n\nIterator over the bytes (UInt8) of a ByteArray.Typically created by arr.iter, where arr is a ByteArray.An iterator is valid if the position i is valid for the array arr, meaning 0 ≤ i ≤ arr.sizeMost operations on iterators return arbitrary values if the iterator is not valid. The functions in\nthe ByteArray.Iterator API should rule out the creation of invalid iterators, with two exceptions:* Iterator.next iter is invalid if iter is already at the end of the array (iter.atEnd is\ntrue)* Iterator.forward iter n/Iterator.nextn iter n is invalid if n is strictly greater than the\nnumber of remaining bytes.The array the iterator is for.The current position.This position is not necessarily valid for the array, for instance if one keeps calling\nIterator.next when Iterator.atEnd is true. If the position is not valid, then the\ncurrent byte is (default : UInt8).\n\nThe current position.This position is not necessarily valid for the array, for instance if one keeps calling\nIterator.next when Iterator.atEnd is true. If the position is not valid, then the\ncurrent byte is (default : UInt8).\n\nTrue if the iterator is past the array's last byte.\n\nTrue if the iterator is valid; that is, it is not past the array's last byte.\n\nTrue if the position is not zero.\n\nThe byte at the current position.On an invalid position, returns (default : UInt8).\n\nThe byte at the current position. -\n\nMoves the iterator's position forward by one byte, unconditionally.It is only valid to call this function if the iterator is not at the end of the array, i.e.\nIterator.atEnd is false; otherwise, the resulting iterator will be invalid.\n\nMoves the iterator's position forward by one byte. -\n\nMoves the iterator's position several bytes forward.The resulting iterator is only valid if the number of bytes to skip is less than or equal to\nthe number of bytes left in the iterator.\n\nMoves the iterator's position several bytes forward.The resulting iterator is only valid if the number of bytes to skip is less than or equal to\nthe number of bytes left in the iterator.\n\nDecreases the iterator's position.If the position is zero, this function is the identity.\n\nMoves the iterator's position several bytes back.If asked to go back more bytes than available, stops at the beginning of the array.\n\nThe number of bytes remaining in the iterator.\n\nMoves the iterator's position to the end of the array.Given i : ByteArray.Iterator, note that i.toEnd.atEnd is always true.\n\n","context":"Lean Reference\u0009Basic Types\u0009Byte Arrays\u0009API Reference","header":"19.17.1.7. Iterators","id":"/Basic-Types/Byte-Arrays/#The-Lean-Language-Reference--Basic-Types--Byte-Arrays--API-Reference--Iterators"},"/Basic-Types/Characters/#char-api-classes":{"contents":"Returns true if the character is an ASCII letter.The ASCII letters are the following: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.\n\nReturns true if the character is an ASCII letter or digit.The ASCII letters are the following: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.\nThe ASCII digits are the following: 0123456789.\n\nReturns true if the character is an ASCII digit.The ASCII digits are the following: 0123456789.\n\nReturns true if the character is a lowercase ASCII letter.The lowercase ASCII letters are the following: abcdefghijklmnopqrstuvwxyz.\n\nReturns true if the character is a uppercase ASCII letter.The uppercase ASCII letters are the following: ABCDEFGHIJKLMNOPQRSTUVWXYZ.\n\nReturns true if the character is a space (' ', U+0020), a tab ('\\t', U+0009), a carriage\nreturn ('\\r', U+000D), or a newline ('\\n', U+000A).\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters\u0009API Reference","header":"19.7.4.2. Character Classes","id":"/Basic-Types/Characters/#char-api-classes"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Local-Caches":{"contents":"cache get and cache put are used to interact with remote cache servers.\nThese commands are experimental, and are only useful if the local cache is enabled.\n\nBoth commands can be configured to use a cache scope, which is a server-specific identifier for a set of artifacts for a package.\nOn Reservoir, scopes are currently identical with GitHub repositories, but may include toolchain and platform information in the future.\nOther remote artifact caches may use any scope scheme that they want.\nCache scopes are specified using the --scope option.\nCache scopes are not identical to the scopes used to require packages from Reservoir.\n\n\n\n\n\nDownloads artifacts for packages in the workspace from a remote cache service to the local Lake artifact cache.\nThe remote cache service used can be configured using LAKE_CACHE_ARTIFACT_ENDPOINT and LAKE_CACHE_REVISION_ENDPOINT.\nIf neither of these are set, Lake will use Reservoir instead.If an input-to-outputs mappings file, a remote-scope, or a github-repo is provided, Lake will download artifacts for the root package.\nOtherwise, it will download artifacts for each package in the root's dependency tree in order (using Reservoir).\nNon-Reservoir dependencies will be skipped.For Reservoir, setting --repo will make Lake lookup artifacts for the root package by a repository name, rather than the package's.\nThis can be used to download artifacts for a fork of the Reservoir package (if such artifacts are available).\nThe --platform and --toolchain options can be used to download artifacts for a different platform/toolchain configuration than Lake detects.\nFor a custom endpoint, the full prefix Lake uses can be set via --scope.If --rev is not set, Lake uses the package's current revision to look up artifacts.\nLake will download the artifacts for the most recent commit with available mappings.\nIt will backtrack up to --max-revs, which defaults to 100.\nIf set to 0, Lake will search the repository's whole history, or as far back as Git will allow.While downloading, Lake will continue on when a download for an artifact fails or if the download process for a whole package fails.\nHowever, it will report this and exit with a nonzero status code in such cases.\n\n\n\nUploads the input-to-outputs mappings contained in the specified file along with the corresponding output artifacts to a remote cache.\nThe remote cache service used can be configured using LAKE_CACHE_KEY, LAKE_CACHE_ARTIFACT_ENDPOINT and LAKE_CACHE_REVISION_ENDPOINT.Files are uploaded using the AWS Signature Version 4 authentication protocol via curl. Thus, the service should generally be an S3-compatible bucket.Since Lake does not currently use cryptographically secure hashes for\nartifacts and outputs, uploads to the cache are prefixed with a scope to avoid\nclashes. This scoped is configured with the following options:* --scope=<remote-scope>* Sets a fixed scope\n* --repo=<github-repo>* Uses the repository + toolchain & platform\n* --toolchain=<name>* With --repo, sets the toolchain\n* --platform=<target-triple>* With --repo, sets the platformAt least one of --scope or --repo must be set.\nIf --repo is used, Lake will produce a scope by augmenting the repository with toolchain and platform information as it deems necessary.\nIf --scope is set, Lake will use the specified scope verbatim.Artifacts are uploaded to the artifact endpoint with a file name derived from their Lake content hash (and prefixed by the repository or scope).\nThe mappings file is uploaded to the revision endpoint with a file name derived from the package's current Git revision (and prefixed by the full scope).\nAs such, the command will warn if the the work tree currently has changes.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","header":"22.1.2.10. Local Caches","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Local-Caches"},"/Coercions/Implementation-Details/#coercion-unfold-impl":{"contents":"The coercion insertion mechanism unfolds applications of coercions, which allows them to control the specific shape of the resulting term.\nThis is important both to ensure readable proof goals and to control evaluation of the coerced term in compiled code.\nUnfolding coercions is controlled by the coe_decl attribute, which is applied to each coercion method (e.g. Coe.coe).\nThis attribute should be considered part of the internals of the coercion mechanism, rather than part of the public coercion API.\n\n","context":"Lean Reference\u0009Coercions\u0009Implementation Details","header":"12.5.1. Unfolding Coercions","id":"/Coercions/Implementation-Details/#coercion-unfold-impl"},"/Definitions/Headers-and-Signatures/#The-Lean-Language-Reference--Definitions--Headers-and-Signatures--Declaration-Names":{"contents":"Most headers begin with a declaration name, which is followed by the signature proper: its parameters and the resulting type.\nA declaration name is a name that may optionally include universe parameters.\n\nDeclaration NamesDeclaration names without universe parameters consist of an identifier:Declaration names with universe parameters consist of an identifier followed by a period and one or more universe parameter names in braces:These universe parameter names are binding occurrences.\n\nExamples do not include declaration names, and names are optional for instance declarations.\n\n","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","header":"7.2.1. Declaration Names","id":"/Definitions/Headers-and-Signatures/#The-Lean-Language-Reference--Definitions--Headers-and-Signatures--Declaration-Names"},"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-formal-statement":{"contents":"To formalize the statement in Lean, we use an inductive type IfExpr:\n\n/--\nAn if-expression is either boolean literal, a\nnumbered variable, or an if-then-else expression\nwhere each subexpression is an if-expression.\n-/\ninductive IfExpr\n  | lit : Bool → IfExpr\n  | var : Nat → IfExpr\n  | ite : IfExpr → IfExpr → IfExpr → IfExpr\nderiving DecidableEq\n\n\nand define some inductive predicates and an eval function, so we can state the four desired properties:\n\nnamespace IfExpr\n\n/--\nAn if-expression has a \"nested if\" if it contains\nan if-then-else where the \"if\" is itself an if-then-else.\n-/\ndef hasNestedIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (ite _ _ _) _ _ => true\n  | ite _ t e => t.hasNestedIf || e.hasNestedIf\n\n/--\nAn if-expression has a \"constant if\" if it contains\nan if-then-else where the \"if\" is itself a literal.\n-/\ndef hasConstantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (lit _) _ _ => true\n  | ite i t e =>\n    i.hasConstantIf || t.hasConstantIf || e.hasConstantIf\n\n/--\nAn if-expression has a \"redundant if\" if\nit contains an if-then-else where\nthe \"then\" and \"else\" clauses are identical.\n-/\ndef hasRedundantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite i t e => t == e || i.hasRedundantIf ||\n      t.hasRedundantIf || e.hasRedundantIf\n\n/--\nAll the variables appearing in an if-expressions,\nread left to right, without removing duplicates.\n-/\ndef vars : IfExpr → List Nat\n  | lit _ => []\n  | var i => [i]\n  | ite i t e => i.vars ++ t.vars ++ e.vars\n\n/--\nA helper function to specify that two lists are disjoint.\n-/\ndef _root_.List.disjoint {α} [DecidableEq α] :\n    List α → List α → Bool\n  | [], _ => true\n  | x::xs, ys => x ∉ ys && xs.disjoint ys\n\n/--\nAn if expression evaluates each variable at most once if\nfor each if-then-else the variables in the \"if\" clause\nare disjoint from the variables in the \"then\" clause\nand the variables in the \"if\" clause\nare disjoint from the variables in the \"else\" clause.\n-/\ndef disjoint : IfExpr → Bool\n  | lit _ => true\n  | var _ => true\n  | ite i t e =>\n      i.vars.disjoint t.vars && i.vars.disjoint e.vars &&\n        i.disjoint && t.disjoint && e.disjoint\n\n/--\nAn if expression is \"normalized\" if it has\nno nested, constant, or redundant ifs,\nand it evaluates each variable at most once.\n-/\ndef normalized (e : IfExpr) : Bool :=\n  !e.hasNestedIf && !e.hasConstantIf &&\n    !e.hasRedundantIf && e.disjoint\n\n/--\nThe evaluation of an if expression\nat some assignment of variables.\n-/\ndef eval (f : Nat → Bool) : IfExpr → Bool\n  | lit b => b\n  | var i => f i\n  | ite i t e => bif i.eval f then t.eval f else e.eval f\n\nend IfExpr\n\n\nUsing these we can state the problem. The challenge is to inhabit the following type (and to do so nicely!):\n\ndef IfNormalization : Type :=\n  { Z : IfExpr → IfExpr // ∀ e, (Z e).normalized ∧ (Z e).eval = e.eval }\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if - then - else  Normalization","header":"17.10.2.2. The formal statement","id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-formal-statement"},"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Library":{"contents":"* #5222 reduces allocations in Json.compress.* #5231 upstreams Zero and NeZero* #5292 refactors Lean.Elab.Deriving.FromToJson (@arthur-adjedj)* #5415 implements Repr Empty (@TomasPuverle)* #5421 implements To/FromJSON Empty (@TomasPuverle)* Logic* #5263 allows simplifying dite_not/decide_not with only Decidable (¬p).* #5268 fixes binders on ite_eq_left_iff* #5284 turns off Inhabited (Sum α β) instances* #5355 adds simp lemmas for LawfulBEq* #5374 add Nonempty instances for products, allowing more partial functions to elaborate successfully* #5447 updates Pi instance names* #5454 makes some instance arguments implicit* #5456 adds heq_comm* #5529 moves @[simp] from exists_prop' to exists_prop* Bool* #5228 fills gaps in Bool lemmas* #5332 adds notation ^^ for Bool.xor* #5351 removes _root_.and (and or/not/xor) and instead exports/uses Bool.and (etc.).* BitVec* #5240 removes BitVec simps with complicated RHS* #5247 BitVec.getElem_zeroExtend* #5248 simp lemmas for BitVec, improving confluence* #5249 removes @[simp] from some BitVec lemmas* #5252 changes BitVec.intMin/Max from abbrev to def* #5278 adds BitVec.getElem_truncate (@tobiasgrosser)* #5281 adds udiv/umod bitblasting for bv_decide (@bollu)* #5297 BitVec unsigned order theoretic results* #5313 adds more basic BitVec ordering theory for UInt* #5314 adds toNat_sub_of_le (@bollu)* #5357 adds BitVec.truncate lemmas* #5358 introduces BitVec.setWidth to unify zeroExtend and truncate (@tobiasgrosser)* #5361 some BitVec GetElem lemmas* #5385 adds BitVec.ofBool_[and|or|xor]_ofBool theorems (@tobiasgrosser)* #5404 more of BitVec.getElem_* (@tobiasgrosser)* #5410 BitVec analogues of Nat.{mul_two, two_mul, mul_succ, succ_mul} (@bollu)* #5411 BitVec.toNat_{add,sub,mul_of_lt} for BitVector non-overflow reasoning (@bollu)* #5413 adds _self, _zero, and _allOnes for BitVec.[and|or|xor] (@tobiasgrosser)* #5416 adds LawCommIdentity + IdempotentOp for BitVec.[and|or|xor] (@tobiasgrosser)* #5418 decidable quantifers for BitVec* #5450 adds BitVec.toInt_[intMin|neg|neg_of_ne_intMin] (@tobiasgrosser)* #5459 missing BitVec lemmas* #5469 adds BitVec.[not_not, allOnes_shiftLeft_or_shiftLeft, allOnes_shiftLeft_and_shiftLeft] (@luisacicolini)* #5478 adds BitVec.(shiftLeft_add_distrib, shiftLeft_ushiftRight) (@luisacicolini)* #5487 adds sdiv_eq, smod_eq to allow sdiv/smod bitblasting (@bollu)* #5491 adds BitVec.toNat_[abs|sdiv|smod] (@tobiasgrosser)* #5492 BitVec.(not_sshiftRight, not_sshiftRight_not, getMsb_not, msb_not) (@luisacicolini)* #5499 BitVec.Lemmas - drop non-terminal simps (@tobiasgrosser)* #5505 unsimps BitVec.divRec_succ'* #5508 adds BitVec.getElem_[add|add_add_bool|mul|rotateLeft|rotateRight… (@tobiasgrosser)* #5554 adds Bitvec.[add, sub, mul]_eq_xor and width_one_cases (@luisacicolini)* List* #5242 improve naming for List.mergeSort lemmas* #5302 provide mergeSort comparator autoParam* #5373 fix name of List.length_mergeSort* #5377 upstream map_mergeSort* #5378 modify signature of lemmas about mergeSort* #5245 avoid importing List.Basic without List.Impl* #5260 review of List API* #5264 review of List API* #5269 remove HashMap's duplicated Pairwise and Sublist* #5271 remove @[simp] from List.head_mem and similar* #5273 lemmas about List.attach* #5275 reverse direction of List.tail_map* #5277 more List.attach lemmas* #5285 List.count lemmas* #5287 use boolean predicates in List.filter* #5289 List.mem_ite_nil_left and analogues* #5293 cleanup of List.findIdx / List.take lemmas* #5294 switch primes on List.getElem_take* #5300 more List.findIdx theorems* #5310 fix List.all/any lemmas* #5311 fix List.countP lemmas* #5316 List.tail lemma* #5331 fix implicitness of List.getElem_mem* #5350 List.replicate lemmas* #5352 List.attachWith lemmas* #5353 List.head_mem_head?* #5360 lemmas about List.tail* #5391 review of List.erase / List.find lemmas* #5392 List.fold / attach lemmas* #5393 List.fold relators* #5394 lemmas about List.maximum?* #5403 theorems about List.toArray* #5405 reverse direction of List.set_map* #5448 add lemmas about List.IsPrefix (@Command-Master)* #5460 missing List.set_replicate_self* #5518 rename List.maximum? to max?* #5519 upstream List.fold lemmas* #5520 restore @[simp] on List.getElem_mem etc.* #5521 List simp fixes* #5550 List.unattach and simp lemmas* #5594 induction-friendly List.min?_cons* Array* #5246 cleanup imports of Array.Lemmas* #5255 split Init.Data.Array.Lemmas for better bootstrapping* #5288 rename Array.data to Array.toList* #5303 cleanup of List.getElem_append variants* #5304 Array.not_mem_empty* #5400 reorganization in Array/Basic* #5420 make Array functions either semireducible or use structural recursion* #5422 refactor DecidableEq (Array α)* #5452 refactor of Array* #5458 cleanup of Array docstrings after refactor* #5461 restore @[simp] on Array.swapAt!_def* #5465 improve Array GetElem lemmas* #5466 Array.foldX lemmas* #5472 @[simp] lemmas about List.toArray* #5485 reverse simp direction for toArray_concat* #5514 Array.eraseReps* #5515 upstream Array.qsortOrd* #5516 upstream Subarray.empty* #5526 fix name of Array.length_toList* #5527 reduce use of deprecated lemmas in Array* #5534 cleanup of Array GetElem lemmas* #5536 fix Array.modify lemmas* #5551 upstream Array.flatten lemmas* #5552 switch obvious cases of array \"bang\"[]! indexing to rely on hypothesis (@TomasPuverle)* #5577 add missing simp to Array.size_feraseIdx* #5586 Array/Option.unattach* Option* #5272 remove @[simp] from Option.pmap/pbind and add simp lemmas* #5307 restoring Option simp confluence* #5354 remove @[simp] from Option.bind_map* #5532 Option.attach* #5539 fix explicitness of Option.mem_toList* Nat* #5241 add @[simp] to Nat.add_eq_zero_iff* #5261 Nat bitwise lemmas* #5262 Nat.testBit_add_one should not be a global simp lemma* #5267 protect some Nat bitwise theorems* #5305 rename Nat bitwise lemmas* #5306 add Nat.self_sub_mod lemma* #5503 restore @[simp] to upstreamed Nat.lt_off_iff* Int* #5301 rename Int.div/mod to Int.tdiv/tmod* #5320 add ediv_nonneg_of_nonpos_of_nonpos to DivModLemmas (@sakehl)* Fin* #5250 missing lemma about Fin.ofNat'* #5356 Fin.ofNat' uses NeZero* #5379 remove some @[simp]s from Fin lemmas* #5380 missing Fin @[simp] lemmas* HashMap* #5244 (DHashMap|HashMap|HashSet).(getKey?|getKey|getKey!|getKeyD)* #5362 remove the last use of Lean.(HashSet|HashMap)* #5369 HashSet.ofArray* #5370 HashSet.partition* #5581 Singleton/Insert/Union instances for HashMap/Set* #5582 HashSet.all/any* #5590 adding Insert/Singleton/Union instances for HashMap/Set.Raw* #5591 HashSet.Raw.all/any* Monads* #5463 upstream some monad lemmas* #5464 adjust simp attributes on monad lemmas* #5522 more monadic simp lemmas* Simp lemma cleanup* #5251 remove redundant simp annotations* #5253 remove Int simp lemmas that can't fire* #5254 variables appearing on both sides of an iff should be implicit* #5381 cleaning up redundant simp lemmas\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.13.0 (2024-11-01)","header":"Library","id":"/releases/v4.13.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___13___0-_LPAR_2024-11-01_RPAR_--Library"}});