window.docContents[237].resolve({"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans":{"contents":"The Boolean values, true and false.Logically speaking, this is equivalent to Prop (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile Bool corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.The Boolean value false, not to be confused with the proposition False.The Boolean value true, not to be confused with the proposition True.\n\nThe constructors Bool.true and Bool.false are exported from the Bool namespace, so they can be written true and false.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.11. Booleans","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering--Partitioning":{"contents":"Extracts the first n elements of xs, or the whole list if n is greater than xs.length.O(min n |xs|).Examples:* [a, b, c, d, e].take 0 = []* [a, b, c, d, e].take 3 = [a, b, c]* [a, b, c, d, e].take 6 = [a, b, c, d, e]\n\nExtracts the first n elements of xs, or the whole list if n is greater than xs.length.O(min n |xs|). This is a tail-recursive version of List.take, used at runtime.Examples:* [a, b, c, d, e].takeTR 0 = []* [a, b, c, d, e].takeTR 3 = [a, b, c]* [a, b, c, d, e].takeTR 6 = [a, b, c, d, e]\n\nReturns the longest initial segment of xs for which p returns true.O(|xs|).Examples:* [7, 6, 4, 8].takeWhile (· > 5) = [7, 6]* [7, 6, 6, 5].takeWhile (· > 5) = [7, 6, 6]* [7, 6, 6, 8].takeWhile (· > 5) = [7, 6, 6, 8]\n\nReturns the longest initial segment of xs for which p returns true.O(|xs|). This is a tail-recursive version of List.take, used at runtime.Examples:* [7, 6, 4, 8].takeWhileTR (· > 5) = [7, 6]* [7, 6, 6, 5].takeWhileTR (· > 5) = [7, 6, 6]* [7, 6, 6, 8].takeWhileTR (· > 5) = [7, 6, 6, 8]\n\nRemoves the first n elements of the list xs. Returns the empty list if n is greater than the\nlength of the list.O(min n |xs|).Examples:* [0, 1, 2, 3, 4].drop 0 = [0, 1, 2, 3, 4]* [0, 1, 2, 3, 4].drop 3 = [3, 4]* [0, 1, 2, 3, 4].drop 6 = []\n\nRemoves the longest prefix of a list for which p returns true.Elements are removed from the list until one is encountered for which p returns false. This\nelement and the remainder of the list are returned.O(|l|).Examples:* [1, 3, 2, 4, 2, 7, 4].dropWhile (· < 4) = [4, 2, 7, 4]* [8, 3, 2, 4, 2, 7, 4].dropWhile (· < 4) = [8, 3, 2, 4, 2, 7, 4]* [8, 3, 2, 4, 2, 7, 4].dropWhile (· < 100) = []\n\nRemoves the last element of the list, if one exists.Examples:* [].dropLast = []* [\"tea\"].dropLast = []* [\"tea\", \"coffee\", \"juice\"].dropLast = [\"tea\", \"coffee\"]\n\nRemoves the last element of the list, if one exists.This is a tail-recursive version of List.dropLast, used at runtime.Examples:* [].dropLastTR = []* [\"tea\"].dropLastTR = []* [\"tea\", \"coffee\", \"juice\"].dropLastTR = [\"tea\", \"coffee\"]\n\nSplits a list at an index, resulting in the first n elements of l paired with the remaining\nelements.If n is greater than the length of l, then the resulting pair consists of l and the empty\nlist. List.splitAt is equivalent to a combination of List.take and List.drop, but it is more\nefficient.Examples:* [\"red\", \"green\", \"blue\"].splitAt 2 = ([\"red\", \"green\"], [\"blue\"])* [\"red\", \"green\", \"blue\"].splitAt 3 = ([\"red\", \"green\", \"blue], [])* [\"red\", \"green\", \"blue\"].splitAt 4 = ([\"red\", \"green\", \"blue], [])\n\nSplits a list into the the longest initial segment for which p returns true, paired with the\nremainder of the list.O(|l|).Examples:* [6, 8, 9, 5, 2, 9].span (· > 5) = ([6, 8, 9], [5, 2, 9])* [6, 8, 9, 5, 2, 9].span (· > 10) = ([], [6, 8, 9, 5, 2, 9])* [6, 8, 9, 5, 2, 9].span (· > 0) = ([6, 8, 9, 5, 2, 9], [])\n\nSplits a list into the longest segments in which each pair of adjacent elements are related by R.O(|l|).Examples:* [1, 1, 2, 2, 2, 3, 2].splitBy (· == ·) = [[1, 1], [2, 2, 2], [3], [2]]* [1, 2, 5, 4, 5, 1, 4].splitBy (· < ·) = [[1, 2, 5], [4, 5], [1, 4]]* [1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ => true) = [[1, 2, 5, 4, 5, 1, 4]]* [1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ => false) = [[1], [2], [5], [4], [5], [1], [4]]\n\nReturns a pair of lists that together contain all the elements of as. The first list contains\nthose elements for which p returns true, and the second contains those for which p returns\nfalse.O(|l|). as.partition p is equivalent to (as.filter p, as.filter (not ∘ p)), but it is slightly\nmore efficient since it only has to do one pass over the list.Examples:* [1, 2, 5, 2, 7, 7].partition (· > 2) = ([5, 7, 7], [1, 2, 2])* [1, 2, 5, 2, 7, 7].partition (fun _ => false) = ([], [1, 2, 5, 2, 7, 7])* [1, 2, 5, 2, 7, 7].partition (fun _ => true) = ([1, 2, 5, 2, 7, 7], [])\n\nReturns a pair of lists that together contain all the elements of as. The first list contains\nthose elements for which the monadic predicate p returns true, and the second contains those for\nwhich p returns false. The list's elements are examined in order, from left to right.This is a monadic version of List.partition.Example:def posOrNeg (x : Int) : Except String Bool :=\n  if x > 0 then pure true\n  else if x < 0 then pure false\n  else throw \"Zero is not positive or negative\"\n#eval [-1, 2, 3].partitionM posOrNeg\nExcept.ok ([2, 3], [-1])\n#eval [0, 2, 3].partitionM posOrNeg\nExcept.error \"Zero is not positive or negative\"\n\n\nApplies a function that returns a disjoint union to each element of a list, collecting the Sum.inl\nand Sum.inr results into separate lists.Examples:* [0, 1, 2, 3].partitionMap (fun x => if x % 2 = 0 then .inl x else .inr x) = ([0, 2], [1, 3])* [0, 1, 2, 3].partitionMap (fun x => if x = 0 then .inl x else .inr x) = ([0], [1, 2, 3])\n\nGroups the elements of a list xs according to the function key, returning a hash map in which\neach group is associated with its key. Groups preserve the relative order of elements in xs.Example:#eval [0, 1, 2, 3, 4, 5, 6].groupByKey (· % 2)\nStd.HashMap.ofList [(0, [0, 2, 4, 6]), (1, [1, 3, 5])]\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference\u0009Filtering","header":"19.15.3.12.1. Partitioning","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering--Partitioning"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries":{"contents":"Returns true if there is a mapping for the given key a or a key that is equal to a according\nto the comparator cmp. There is also a Prop-valued version\nof this: a ∈ t is equivalent to t.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for equality checks, while for tree maps, both use the given comparator cmp.\n\nGiven a proof that a mapping for the given key is present, retrieves the mapping for the given key.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, panicking if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning none if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nTries to retrieve the mapping for the given key, returning fallback if no such mapping is present.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nRetrieves the key from the mapping that matches a. Ensures that such a mapping exists by\nrequiring a proof of a ∈ m. The result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if a mapping for the given key exists and returns the key if it does, otherwise fallback.\nIf a mapping exists the result is guaranteed to be pointer equal to the key in the map.\n\nReturns a list of all keys present in the tree map in ascending  order.\n\nReturns an array of all keys present in the tree map in ascending  order.\n\nReturns a list of all values present in the tree map in ascending  order.\n\nReturns an array of all values present in the tree map in ascending  order.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps","header":"19.18.8.3. Queries","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries"},"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Transformation":{"contents":"Transforms a pair by applying functions to both elements.Examples:* (1, 2).map (· + 1) (· * 3) = (2, 6)* (1, 2).map toString (· * 3) = (\"1\", 6)\n\nSwaps the elements in a pair.Examples:* (1, 2).swap = (2, 1)* (\"orange\", -87).swap = (-87, \"orange\")\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples\u0009Ordered Pairs\u0009API Reference","header":"19.13.1.1.1. Transformation","id":"/Basic-Types/Tuples/#The-Lean-Language-Reference--Basic-Types--Tuples--Ordered-Pairs--API-Reference--Transformation"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Packaging-and-Distribution--Cached-Cloud-Builds":{"contents":"These commands are still experimental.\nThey are likely change in future versions of Lake based on user feedback.\nPackages that use Reservoir cloud build archives should enable the platformIndependent setting.\n\n\n\nPacks the root package's build directory into a gzipped tar archive using tar.\nIf a path for the archive is not specified, the archive in the package's Lake directory (.lake) and named according to its buildArchive setting.\nThis command does not build any artifacts: it only archives what is present.\nUsers should ensure that the desired artifacts are present before running this command.\n\n\n\nUnpacks the contents of the gzipped tar archive archive.tgz into the root package's build directory.\nIf archive.tgz is not specified, the package's buildArchive setting is used to determine a filename, and the file is expected in package's Lake directory (.lake).\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface\u0009Packaging and Distribution","header":"22.1.2.9.1. Cached Cloud Builds","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Packaging-and-Distribution--Cached-Cloud-Builds"},"/Definitions/Recursive-Definitions/#structural-recursion":{"contents":"Structurally recursive functions are those in which each recursive call is on a structurally smaller term than the argument.\nThe same parameter must decrease in all recursive calls; this parameter is called the decreasing parameter.\nStructural recursion is stronger than the primitive recursion that recursors provide, because the recursive call can use more deeply nested sub-terms of the argument, rather than only an immediate sub-term.\nThe constructions used to implement structural recursion are, however, implemented using the recursor; these helper constructions are described in the section on inductive types.\n\nThe rules that govern structural recursion are fundamentally syntactic in nature.\nThere are many recursive definitions that exhibit structurally recursive computational behavior, but which are not accepted by these rules; this is a fundamental consequence of the analysis being fully automatic.\nWell-founded recursion provides a semantic approach to demonstrating termination that can be used in situations where a recursive function is not structurally recursive, but it can also be used when a function that computes according to structural recursion doesn't satisfy the syntactic requirements.\n\n\n\nStructural Recursion vs SubtractionThe function countdown is structurally recursive.\nThe parameter n was matched against the pattern n' + 1, which means that n' is a direct subterm of n in the second branch of the pattern match:def countdown (n : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n' + 1 => n' :: countdown n'\nReplacing pattern matching with an equivalent Boolean test and subtraction results in an error:def countdown' (n : Nat) : List Nat :=\n  if n == 0 then []\n  else\n    let n' := n - 1\n    n' :: countdown' n'\nfail to show termination for\n  countdown'\nwith errors\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    countdown' n'\n\n\nfailed to prove termination, possible solutions:\n  - Use `have`-expressions to prove the remaining goals\n  - Use `termination_by` to specify a different well-founded relation\n  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\nn : Nat\nh✝ : ¬(n == 0) = true\nn' : Nat := n - 1\n⊢ n - 1 < n\nThis is because there was no pattern matching on the parameter n.\nWhile this function indeed terminates, the argument that it does so is based on properties of if, the equality test, and subtraction, rather than being a generic feature of Nat being an inductive type.\nThese arguments are expressed using well-founded recursion, and a slight change to the function definition allows Lean's automatic support for well-founded recursion to construct an alternative termination proof.\nThis version branches on the decidability of propositional equality for Nat rather than the result of a Boolean equality test:def countdown' (n : Nat) : List Nat :=\n  if n = 0 then []\n  else\n    let n' := n - 1\n    n' :: countdown' n'\nHere, Lean's automation automatically constructs a termination proof from facts about propositional equality and subtraction.\nIt uses well-founded recursion rather than structural recursion behind the scenes.\n\n\n\nStructural recursion may be used explicitly or automatically.\nWith explicit structural recursion, the function definition declares which parameter is the decreasing parameter.\nIf no termination strategy is explicitly declared, Lean performs a search for a decreasing parameter as well as a decreasing measure for use with well-founded recursion.\nExplicitly annotating structural recursion has the following benefits:\n\n* It can speed up elaboration, because no search occurs.* It documents the termination argument for readers.* In situations where structural recursion is explicitly desired, it prevents the accidental use of well-founded recursion.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.2. Structural Recursion","id":"/Definitions/Recursive-Definitions/#structural-recursion"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-sequencing":{"contents":"In addition to running tactics one after the other, each being used to solve the main goal, the tactic language supports sequencing tactics according to the way in which goals are produced.\nThe <;> tactic combinator allows a tactic to be applied to every subgoal produced by some other tactic.\nIf no new goals are produced, then the second tactic is not run.\n\ntac <;> tac' runs tac on the main goal and tac' on each produced goal,\nconcatenating all goals produced by tac'.If the tactic fails on any of the subgoals, then the whole <;> tactic fails.\n\nSubgoal SequencingIn this proof state:x : Nat\nh : x = 1 ∨ x = 2\n⊢ x < 3\nthe tactic cases h yields the following two goals:case inl\nx : Nat\nh✝ : x = 1\n⊢ x < 3\n\ncase inr\nx : Nat\nh✝ : x = 2\n⊢ x < 3\nRunning cases h ; simp [*] causes simp to solve the first goal, leaving the second behind:case inr\nx : Nat\nh✝ : x = 2\n⊢ x < 3\nReplacing the ; with <;> and running cases h <;> simp [*] solves both of the new goals with simp:\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures\u0009Goal Selection","header":"13.3.1.3.1. Sequencing","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-sequencing"},"/The-Module-System/Common-Errors-and-Patterns/#The-Lean-Language-Reference--The-Module-System--Common-Errors-and-Patterns":{"contents":"The following list contains common errors one might encounter when using the module system and especially porting existing files to the module system.\n\n Unknown constant\n\nCheck whether you might be trying to access a private definition in the public scope.\n  If so, you might want to make the current declaration private as well or otherwise enter the private scope such as through private on a field or by for a proof.\n  TODO: improve error message.If the message is prefixed with (interpreter), this suggests a missing meta import.\n  The new import should be placed in the file defining the metaprogram depending on the missing constant, which is not necessarily the file triggering the error.\n  Note that the language server always does meta imports for the benefit of #eval etc., so the error might only occur in a cmdline build.\n  TODO: better, static meta checking.\n\n Definitional equality errors, especially after porting\n\nYou are likely missing an expose attribute on a definition or alternatively, if imported, an import all.\n  Prefer the former if anyone outside your library might feasible require the same access.\n  #reduce and/or trace.Meta.isDefEq can help with finding the blocking definition.\n  You might also see this as a kernel error when a tactic directly emits proof terms referencing specific declarations without going through the elaborator, such as for proof by reflection.\n  In this case, there is no readily available trace for debugging; consider using @[expose] sections generously on the closure of relevant modules.\n\n\n\n\n\n","context":"Lean Reference\u0009The Module System","header":"Common Errors and Patterns","id":"/The-Module-System/Common-Errors-and-Patterns/#The-Lean-Language-Reference--The-Module-System--Common-Errors-and-Patterns"}});