window.docContents[0].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Properties":{"contents":"Returns the number of mappings present in the map.\n\nReturns true if the tree map contains no mappings.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"19.18.9.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Properties"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Library":{"contents":"* #6177 implements BitVec.*_fill.* #6211 verifies the insertMany method on HashMaps for the special\ncase of inserting lists.* #6346 completes the toNat/Int/Fin family for shiftLeft.* #6347 adds BitVec.toNat_rotateLeft and BitVec.toNat_rotateLeft.* #6402 adds a toFin and msb lemma for unsigned bitvector division.\nWe don't have toInt_udiv, since the only truly general statement we\ncan make does no better than unfolding the definition, and it's not\nuncontroversially clear how to unfold toInt (see\ntoInt_eq_msb_cond/toInt_eq_toNat_cond/toInt_eq_toNat_bmod for a\nfew options currently provided). Instead, we do have toInt_udiv_of_msb\nthat's able to provide a more meaningful rewrite given an extra\nside-condition (that x.msb = false).* #6404 adds a toFin and msb lemma for unsigned bitvector modulus.\nSimilar to #6402, we don't provide a general toInt_umod lemmas, but\ninstead choose to provide more specialized rewrites, with extra\nside-conditions.* #6431 fixes the Repr instance of the Timestamp type and changes\nthe PlainTime type so that it always represents a clock time that may\nbe a leap second.* #6476 defines reverse for bitvectors and implements a first subset\nof theorems (getLsbD_reverse, getMsbD_reverse, reverse_append, reverse_replicate, reverse_cast, msb_reverse). We also include some\nnecessary related theorems (cons_append, cons_append_append, append_assoc, replicate_append_self, replicate_succ') and deprecate\ntheoremsreplicate_zero_eq and replicate_succ_eq.* #6494 proves the basic theorems about the functions Int.bdiv and\nInt.bmod.* #6507 adds the subtraction equivalents for Int.emod_add_emod ((a % n + b) % n = (a + b) % n) and Int.add_emod_emod ((a + b % n) % n = (a + b) % n). These are marked @[simp] like their addition equivalents.* #6524 upstreams some remaining List.Perm lemmas from Batteries.* #6546 continues aligning Array and Vector lemmas with List,\nworking on fold and map operations.* #6563 implements Std.Net.Addr which contains structures around IP\nand socket addresses.* #6573 replaces the existing implementations of (D)HashMap.alter and\n(D)HashMap.modify with primitive, more efficient ones and in\nparticular provides proofs that they yield well-formed hash maps (WF\ntypeclass).* #6586 continues aligning List/Array/Vector lemmas, finishing up\nlemmas about map.* #6587 adds decidable instances for the LE and LT instances for the\nOffset types defined in Std.Time.* #6589 continues aligning List/Array lemmas, finishing filter and\nfilterMap.* #6591 adds less-than and less-than-or-equal-to relations to UInt32,\nconsistent with the other UIntN types.* #6612 adds lemmas about Array.append, improving alignment with the\nList API.* #6617 completes alignment of List/Array/Vector append lemmas.* #6620 adds lemmas about HashMap.alter and .modify. These lemmas\ndescribe the interaction of alter and modify with the read methods of\nthe HashMap. The additions affect the HashMap, the DHashMap and their\nrespective raw versions. Moreover, the raw versions of alter and modify\nare defined.* #6625 adds lemmas describing the behavior of UIntX.toBitVec on\nUIntX operations.* #6630 adds theorems Nat.[shiftLeft_or_distrib,\nshiftLeft_xor_distrib, shiftLeft_and_distrib, testBit_mul_two_pow,\nbitwise_mul_two_pow, shiftLeft_bitwise_distrib], to prove\nNat.shiftLeft_or_distrib by emulating the proof strategy of\nshiftRight_and_distrib.* #6640 completes aligning List/Array/Vector lemmas about\nflatten. Vector.flatten was previously missing, and has been added\n(for rectangular sizes only). A small number of missing Option lemmas\nwere also need to get the proofs to go through.* #6660 defines Vector.flatMap, changes the order of arguments in\nList.flatMap for consistency, and aligns the lemmas for\nList/Array/Vector flatMap.* #6661 adds array indexing lemmas for Vector.flatMap. (These were not\navailable for List and Array due to variable lengths.)* #6667 aligns List.replicate/Array.mkArray/Vector.mkVector\nlemmas.* #6668 fixes negative timestamps and PlainDateTimes before 1970.* #6674 adds theorems BitVec.[getMsbD_mul, getElem_udiv, getLsbD_udiv, getMsbD_udiv]* #6695 aligns List/Array/Vector.reverse lemmas.* #6697 changes the arguments of List/Array.mapFinIdx from (f : Fin as.size → α → β) to (f : (i : Nat) → α → (h : i < as.size) → β), in\nline with the API design elsewhere for List/Array.* #6701 completes aligning mapIdx and mapFinIdx across\nList/Array/Vector.* #6707 completes aligning lemmas for List / Array / Vector about\nfoldl, foldr, and their monadic versions.* #6708 deprecates List.iota, which we make no essential use of. iota n can be replaced with (range' 1 n).reverse. The verification lemmas\nfor range' already have better coverage than those for iota.\nAny downstream projects using it (I am not aware of any) are encouraged\nto adopt it.* #6712 aligns List/Array/Vector theorems for countP and\ncount.* #6723 completes the alignment of\n{List/Array/Vector}.{attach,attachWith,pmap} lemmas. I had to fill in a\nnumber of gaps in the List API.* #6728 removes theorems Nat.mul_one to simplify a rewrite in the\nproof of BitVec.getMsbD_rotateLeft_of_lt* #6742 adds the lemmas that show what happens when multiplying by\ntwoPow to an arbitrary term, as well to another twoPow.* #6743 adds rewrites that normalizes left shifts by extracting bits and\nconcatenating zeroes. If the shift amount is larger than the bit-width,\nthen the resulting bitvector is zero.* #6747 adds the ability to push BitVec.extractLsb and\nBitVec.extractLsb' with bitwise operations. This is useful for\nconstant-folding extracts.* #6767 adds lemmas to rewrite\nBitVec.shiftLeft,shiftRight,sshiftRight' by a BitVec.ofNat into a\nshift-by-natural number. This will be used to canonicalize shifts by\nconstant bitvectors into shift by constant numbers, which have further\nrewrites on them if the number is a power of two.* #6799 adds a number of simple comparison lemmas to the top/bottom\nelement for BitVec. Then they are applied to teach bv_normalize that\n(a<1) = (a==0) and to remove an intermediate proof that is no longer\nnecessary along the way.* #6800 uniformizes the naming of enum/enumFrom (on List) and\nzipWithIndex (on Array on Vector), replacing all with zipIdx. At\nthe same time, we generalize to add an optional Nat parameter for the\ninitial value of the index (which previously existed, only for List,\nas the separate function enumFrom).* #6808 adds simp lemmas replacing BitVec.setWidth' with setWidth,\nand conditionally simplifying setWidth v (setWidth w v).* #6818 adds a BitVec lemma that (x >> x) = 0 and plumbs it through to\nbv_normalize. I also move some theorems I found useful to the top of the\nushiftRight section.* #6821 adds basic lemmas about Ordering, describing the interaction\nof isLT/isLE/isGE/isGT, swap and the constructors.\nAdditionally, it refactors the instance derivation code such that a\nLawfulBEq Ordering instance is also derived automatically.* #6826 adds injectivity theorems for inductives that did not get them\nautomatically (because they are defined too early) but also not yet\nmanuall later.* #6828 adds add/sub injectivity lemmas for BitVec, and then adds\nspecialized forms with additional symmetries for the bv_normalize\nnormal form.* #6831 completes the alignment of List/Array/Vector lemmas about\nisEqv and ==.* #6833 makes the signatures of find functions across\nList/Array/Vector consistent. Verification lemmas will follow in\nsubsequent PRs.* #6835 fills some gaps in the Vector API, adding mapM, zip, and\nForIn' and ToStream instances.* #6838 completes aligning the (limited) verification API for\nList/Array/Vector.ofFn.* #6840 completes the alignment of\nList/Array/Vector.zip/zipWith/zipWithAll/unzip lemmas.* #6845 adds missing monadic higher order functions on\nList/Array/Vector. Only the most basic verification lemmas\n(relating the operations on the three container types) are provided for\nnow.* #6848 adds simp lemmas proving x + y = x ↔ x = 0 for BitVec, along\nwith symmetries, and then adds these to the bv_normalize simpset.* #6860 makes take/drop/extract available for each of\nList/Array/Vector. The simp normal forms differ, however: in\nList, we simplify extract to take+drop, while in Array and\nVector we simplify take and drop to extract. We also provide\nArray/Vector.shrink, which simplifies to take, but is implemented by\nrepeatedly popping. Verification lemmas for Array/Vector.extract to\nfollow in a subsequent PR.* #6862 defines Cooper resolution with a divisibility constraint as\nformulated in\n\"Cutting to the Chase: Solving Linear Integer Arithmetic\" by Dejan\nJovanović and Leonardo de Moura,\nDOI 10.1007/s10817-013-9281-x.* #6863 allows fixing regressions in mathlib introduced in\nnightly-2024-02-25 by allowing the use of x * y in match patterns.\nThere are currently 11 instances in mathlib explicitly flagging the lack\nof this match pattern.* #6864 adds lemmas relating the operations on\nfindIdx?/findFinIdx?/idxOf?/findIdxOf?/eraseP/erase on List and on\nArray. It's preliminary to aligning the verification lemmas for\nfind... and erase....* #6868 completes the alignment across List/Array/Vector of lemmas\nabout the eraseP/erase/eraseIdx operations.* #6872 adds lemmas for xor injectivity and when and/or/xor equal\nallOnes or zero. Then I plumb support for the new lemmas through to\nbv_normalize.* #6875 adds a lemma relating msb and getMsbD, and three lemmas\nregarding getElem and shiftConcat. These lemmas were needed in\nBatteries#1078\nand the request to upstream was made in the review of that PR.* #6878 completes alignments of List/Array/Vector lemmas about\nrange, range', and zipIdx.* #6883 completes the alignment of lemmas about monadic functions on\nList/Array/Vector. Amongst other changes, we change the simp normal\nform from List.forM to ForM.forM, and correct the definition of\nList.flatMapM, which previously was returning results in the incorrect\norder. There remain many gaps in the verification lemmas for monadic\nfunctions; this PR only makes the lemmas uniform across\nList/Array/Vector.* #6890 teaches bv_normalize to replace subtractions on one side of an\nequality with an addition on the other side, this re-write eliminates a\nnot + addition in the normalized form so it is easier on the solver.* #6912 aligns current coverage of find-type theorems across\nList/Array/Vector. There are still quite a few holes in this API,\nwhich will be filled later.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Library","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Library"}});