window.docContents[112].resolve({"/Basic-Types/Tuples/#pairs":{"contents":"\n\nThe type α × β, which is a notation for Prod α β, contains ordered pairs in which the first item is an α and the second is a β.\nThese pairs are written in parentheses, separated by commas.\nLarger tuples are represented as nested tuples, so α × β × γ is equivalent to α × (β × γ) and (x, y, z) is equivalent to (x, (y, z)).\n\nProduct TypesThe product Prod α β is written α × β.\n\nPairs\n\nThe product type, usually written α × β. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an α and the second element is a\nβ.Products nest to the right, so (x, y, z) : α × β × γ is equivalent to (x, (y, z)) : α × (β × γ).Conventions for notations in identifiers:* The recommended spelling of × in identifiers is Prod.Constructs a pair. This is usually written (x, y) instead of Prod.mk x y.Conventions for notations in identifiers:* The recommended spelling of (a, b) in identifiers is mk.The first element of a pair.The second element of a pair.\n\n\n\nThere are also the variants α ×' β (which is notation for PProd α β) and MProd, which differ with respect to universe levels: like PSum, PProd allows either α or β to be a proposition, while MProd requires that both be types at the same universe level.\nGenerally speaking, PProd is primarily used in the implementation of proof automation and the elaborator, as it tends to give rise to universe level unification problems that can't be solved.\nMProd, on the other hand, can simplify universe level issues in certain advanced use cases.\n\n\n\nProducts of Arbitrary SortsThe product PProd α β, in which both types could be propositions, is written α × β.\n\nA product type in which the types may be propositions, usually written α ×' β.This type is primarily used internally and as an implementation detail of proof automation. It is\nrarely useful in hand-written code.Conventions for notations in identifiers:* The recommended spelling of ×' in identifiers is PProd.The first element of a pair.The second element of a pair.\n\nA product type in which both α and β are in the same universe.It is called MProd is because it is the universe-monomorphic product type.The first element of a pair.The second element of a pair.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples","header":"19.13.1. Ordered Pairs","id":"/Basic-Types/Tuples/#pairs"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-dir":{"contents":"By default, Elan stores installed toolchains in .elan/toolchains in the user's home directory, and its proxies are kept in .elan/bin, which is added to the path when Elan is installed.\nThe environment variable ELAN_HOME can be used to change this location.\nIt should be set both prior to installing Elan and in all sessions that use Lean in order to ensure that Elan's files are found.\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan","header":"22.2.2. Toolchain Locations","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-dir"},"/Tactic-Proofs/Tactic-Reference/#tactic-reducibility":{"contents":"with_reducible tacs executes tacs using the reducible transparency setting.\nIn this setting only definitions tagged as [reducible] are unfolded.\n\nwith_reducible_and_instances tacs executes tacs using the .instances transparency setting.\nIn this setting only definitions tagged as [reducible] or type class instances are unfolded.\n\nwith_unfolding_all tacs executes tacs using the .all transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.18. Controlling Reduction","id":"/Tactic-Proofs/Tactic-Reference/#tactic-reducibility"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-elim":{"contents":"Elimination tactics use recursors and the automatically-derived casesOn helper to implement induction and case splitting.\nThe subgoals that result from these tactics are determined by the types of the minor premises of the eliminators, and using different eliminators with the using option results in different subgoals.\n\nChoosing EliminatorsWhen attempting to prove that ∀(i : Fin (n + 1)), 0 + i = i, after introducing the hypotheses the tactic induction i results in:case mk\nn val✝ : Nat\nisLt✝ : val✝ < n + 1\n⊢ 0 + ⟨val✝, isLt✝⟩ = ⟨val✝, isLt✝⟩\nThis is because Fin is a structure with a single non-recursive constructor.\nIts recursor has a single minor premise for this constructor:Fin.rec.{u} {n : Nat} {motive : Fin n → Sort u}\n  (mk : (val : Nat) →\n    (isLt : val < n) →\n    motive ⟨val, isLt⟩)\n  (t : Fin n) : motive t\nUsing the tactic induction i using Fin.induction instead results in:case zero\nn : Nat\n⊢ 0 + 0 = 0\n\ncase succ\nn : Nat\ni✝ : Fin n\na✝ : 0 + i✝.castSucc = i✝.castSucc\n⊢ 0 + i✝.succ = i✝.succ\nFin.induction is an alternative eliminator that implements induction on the underlying Nat:Fin.induction.{u} {n : Nat}\n  {motive : Fin (n + 1) → Sort u}\n  (zero : motive 0)\n  (succ : (i : Fin n) →\n    motive i.castSucc →\n    motive i.succ)\n  (i : Fin (n + 1)) : motive i\n\n\nCustom eliminators can be registered using the induction_eliminator and cases_eliminator attributes.\nThe eliminator is registered for its explicit targets (i.e. those that are explicit, rather than implicit, parameters to the eliminator function) and will be applied when induction or cases is used on targets of those types.\nWhen present, custom eliminators take precedence over recursors.\nSetting tactic.customEliminators to false disables the use of custom eliminators.\n\nCustom EliminatorsThe induction_eliminator attribute registers an eliminator for use by the induction tactic.The induction_eliminator attribute registers an eliminator for use by the cases tactic.\n\nAssuming x is a variable in the local context with an inductive type,\ncases x splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on x,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\ncases detects unreachable cases and closes them automatically.For example, given n : Nat and a goal with a hypothesis h : P n and target Q n,\ncases n produces one goal with hypothesis h : P 0 and target Q 0,\nand one goal with hypothesis h : P (Nat.succ a) and target Q (Nat.succ a).\nHere the name a is chosen automatically and is not accessible.\nYou can use with to provide the variables names for each constructor.* cases e, where e is an expression instead of a variable, generalizes e in the goal,\nand then cases on the resulting variable.* Given as : List α, cases as with | nil => tac₁ | cons a as' => tac₂,\nuses tactic tac₁ for the nil case, and tac₂ for the cons case,\nand a and as' are used as names for the new variables introduced.* cases h : e, where e is a variable or an expression,\nperforms cases on e as above, but also adds a hypothesis h : e = ... to each hypothesis,\nwhere ... is the constructor instance for that particular case.\n\nrcases is a tactic that will perform cases recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like h1 : a ∧ b ∧ c ∨ d or\nh2 : ∃ x y, trans_rel R x y. Usual usage might be rcases h1 with ⟨ha, hb, hc⟩ | hd or\nrcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩ for these examples.Each element of an rcases pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of rcases and represent individual elements destructured from\nthe input expression). An rcases pattern has the following grammar:* A name like x, which names the active hypothesis as x.* A blank _, which does nothing (letting the automatic naming system used by cases name the\nhypothesis).* A hyphen -, which clears the active hypothesis and any dependents.* The keyword rfl, which expects the hypothesis to be h : a = b, and calls subst on the\nhypothesis (which has the effect of replacing b with a everywhere or vice versa).* A type ascription p : ty, which sets the type of the hypothesis to ty and then matches it\nagainst p. (Of course, ty must unify with the actual type of h for this to work.)* A tuple pattern ⟨p1, p2, p3⟩, which matches a constructor with many arguments, or a series\nof nested conjunctions or existentials. For example if the active hypothesis is a ∧ b ∧ c,\nthen the conjunction will be destructured, and p1 will be matched against a, p2 against b\nand so on.* A @ before a tuple pattern as in @⟨p1, p2, p3⟩ will bind all arguments in the constructor,\nwhile leaving the @ off will only use the patterns on the explicit arguments.* An alternation pattern p1 | p2 | p3, which matches an inductive type with multiple constructors,\nor a nested disjunction like a ∨ b ∨ c.A pattern like ⟨a, b, c⟩ | ⟨d, e⟩ will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as a,b,c and the\nfirst two of the second constructor d,e. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as ⟨⟨a⟩, b | c⟩ | d then these will cause more case splits as necessary.\nIf there are too many arguments, such as ⟨a, b, c⟩ for splitting on\n∃ x, ∃ y, p x, then it will be treated as ⟨a, ⟨b, c⟩⟩, splitting the last\nparameter as necessary.rcases also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor quot.mk.rcases h : e with PAT will do the same as rcases e with PAT with the exception that an\nassumption h : e = PAT will be added to the context.\n\nThe fun_cases tactic is a convenience wrapper of the cases tactic when using a functional\ncases principle.The tactic invocationfun_cases f x ... y ...`\nis equivalent tocases y, ... using f.fun_cases_unfolding x ...\nwhere the arguments of f are used as arguments to f.fun_cases_unfolding or targets of the case\nanalysis, as appropriate.The formfun_cases f\n(with no arguments to f) searches the goal for a unique eligible application of f, and uses\nthese arguments. An application of f is eligible if it is saturated and the arguments that will\nbecome targets are free variables.The form fun_cases f x y with | case1 => tac₁ | case2 x' ih => tac₂ works like with cases.Under set_option tactic.fun_induction.unfolding true (the default), fun_induction uses the\nf.fun_cases_unfolding theorem, which will try to automatically unfold the call to f in\nthe goal. With set_option tactic.fun_induction.unfolding false, it uses f.fun_cases instead.\n\nAssuming x is a variable in the local context with an inductive type,\ninduction x applies induction on x to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on x,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.For example, given n : Nat and a goal with a hypothesis h : P n and target Q n,\ninduction n produces one goal with hypothesis h : P 0 and target Q 0,\nand one goal with hypotheses h : P (Nat.succ a) and ih₁ : P a → Q a and target Q (Nat.succ a).\nHere the names a and ih₁ are chosen automatically and are not accessible.\nYou can use with to provide the variables names for each constructor.* induction e, where e is an expression instead of a variable,\ngeneralizes e in the goal, and then performs induction on the resulting variable.* induction e using r allows the user to specify the principle of induction that should be used.\nHere r should be a term whose result type must be of the form C t,\nwhere C is a bound variable and t is a (possibly empty) sequence of bound variables* induction e generalizing z₁ ... zₙ, where z₁ ... zₙ are variables in the local context,\ngeneralizes over z₁ ... zₙ before applying the induction but then introduces them in each goal.\nIn other words, the net effect is that each inductive hypothesis is generalized.* Given x : Nat, induction x with | zero => tac₁ | succ x' ih => tac₂\nuses tactic tac₁ for the zero case, and tac₂ for the succ case.\n\nThe fun_induction tactic is a convenience wrapper around the induction tactic to use the the\nfunctional induction principle.The tactic invocationfun_induction f x₁ ... xₙ y₁ ... yₘ\nwhere f is a function defined by non-mutual structural or well-founded recursion, is equivalent toinduction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ\nwhere the arguments of f are used as arguments to f.induct_unfolding or targets of the\ninduction, as appropriate.The formfun_induction f\n(with no arguments to f) searches the goal for a unique eligible application of f, and uses\nthese arguments. An application of f is eligible if it is saturated and the arguments that will\nbecome targets are free variables.The forms fun_induction f x y generalizing z₁ ... zₙ and\nfun_induction f x y with | case1 => tac₁ | case2 x' ih => tac₂ work like with induction.Under set_option tactic.fun_induction.unfolding true (the default), fun_induction uses the\nf.induct_unfolding induction principle, which will try to automatically unfold the call to f in\nthe goal. With set_option tactic.fun_induction.unfolding false, it uses f.induct instead.\n\nThe tactic nofun is shorthand for exact nofun: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n\nThe tactic nomatch h is shorthand for exact nomatch h.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Inductive Types","header":"13.5.14.2. Elimination","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-elim"},"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Language-features___-tactics___-and-metaprograms":{"contents":"* Functional induction principles.\n#3432, #3620,\n#3754, #3762,\n#3738, #3776,\n#3898.Derived from the definition of a (possibly mutually) recursive function,\na functional induction principle is created that is tailored to proofs about that function.For example from:def ackermann : Nat → Nat → Nat\n  | 0, m => m + 1\n  | n+1, 0 => ackermann n 1\n  | n+1, m+1 => ackermann n (ackermann (n + 1) m)\nwe getackermann.induct (motive : Nat → Nat → Prop) (case1 : ∀ (m : Nat), motive 0 m)\n  (case2 : ∀ (n : Nat), motive n 1 → motive (Nat.succ n) 0)\n  (case3 : ∀ (n m : Nat), motive (n + 1) m → motive n (ackermann (n + 1) m) → motive (Nat.succ n) (Nat.succ m))\n  (x x : Nat) : motive x x\nIt can be used in the induction tactic using the using syntax:induction n, m using ackermann.induct\n* The termination checker now recognizes more recursion patterns without an\nexplicit termination_by. In particular the idiom of counting up to an upper\nbound, as indef Array.sum (arr : Array Nat) (i acc : Nat) : Nat :=\n  if _ : i < arr.size then\n    Array.sum arr (i+1) (acc + arr[i])\n  else\n    acc\nis recognized without having to say termination_by arr.size - i.* #3630 makes termination_by? not use sizeOf when not needed* #3652 improves the termination_by syntax.* #3658 changes how termination arguments are elaborated.* #3665 refactors GuessLex to allow inferring more complex termination arguments* #3666 infers termination arguments such as xs.size - i* #3629,\n#3655,\n#3747:\nAdds @[induction_eliminator] and @[cases_eliminator] attributes to be able to define custom eliminators\nfor the induction and cases tactics, replacing the @[eliminator] attribute.\nGives custom eliminators for Nat so that induction and cases put goal states into terms of 0 and n + 1\nrather than Nat.zero and Nat.succ n.\nAdded option tactic.customEliminators to control whether to use custom eliminators.\nAdded a hack for rcases/rintro/obtain to use the custom eliminator for Nat.* Shorter instances names. There is a new algorithm for generating names for anonymous instances.\nAcross Std and Mathlib, the median ratio between lengths of new names and of old names is about 72%.\nWith the old algorithm, the longest name was 1660 characters, and now the longest name is 202 characters.\nThe new algorithm's 95th percentile name length is 67 characters, versus 278 for the old algorithm.\nWhile the new algorithm produces names that are 1.2% less unique,\nit avoids cross-project collisions by adding a module-based suffix\nwhen it does not refer to declarations from the same \"project\" (modules that share the same root).\n#3089\nand #3934.* 8d2adf\nImporting two different files containing proofs of the same theorem is no longer considered an error.\nThis feature is particularly useful for theorems that are automatically generated on demand (e.g., equational theorems).* 84b091\nLean now generates an error if the type of a theorem is not a proposition.* Definition transparency. 47a343. @[reducible], @[semireducible], and @[irreducible] are now scoped and able to be set for imported declarations.* simp/dsimp* #3607 enables kernel projection reduction in dsimp* b24fbf\nand acdb00:\ndsimproc command\nto define defeq-preserving simplification procedures.* #3624 makes dsimp normalize raw nat literals as OfNat.ofNat applications.* #3628 makes simp correctly handle OfScientific.ofScientific literals.* #3654 makes dsimp? report used simprocs.* dee074 fixes equation theorem\nhandling in simp for non-recursive definitions.* #3819 improved performance when simp encounters a loop.* #3821 fixes discharger/cache interaction.* #3824 keeps simp from breaking Char literals.* #3838 allows Nat instances matching to be more lenient.* #3870 documentation for simp configuration options.* #3972 fixes simp caching.* #4044 improves cache behavior for \"well-behaved\" dischargers.* omega* #3639, #3766,\n#3853, #3875:\nintroduces a term canonicalizer.* #3736 improves handling of positivity for the modulo operator for Int.* #3828 makes it work as a simp discharger.* #3847 adds helpful error messages.* rfl* #3671, #3708: upstreams the @[refl] attribute and the rfl tactic.* #3751 makes apply_rfl not operate on Eq itself.* #4067 improves error message when there are no goals.* #3719 upstreams the rw? tactic, with fixes and improvements in\n#3783, #3794,\n#3911.* conv* #3659 adds a conv version of the calc tactic.* #3763 makes conv clean up using try with_reducible rfl instead of try rfl.* #guard_msgs* #3617 introduces whitespace protection using the ⏎ character.* #3883:\nThe #guard_msgs command now has options to change whitespace normalization and sensitivity to message ordering.\nFor example, #guard_msgs (whitespace := lax) in cmd collapses whitespace before checking messages,\nand #guard_msgs (ordering := sorted) in cmd sorts the messages in lexicographic order before checking.* #3931 adds an unused variables ignore function for #guard_msgs.* #3912 adds a diff between the expected and actual outputs. This feature is currently\ndisabled by default, but can be enabled with set_option guard_msgs.diff true.\nDepending on user feedback, this option may default to true in a future version of Lean.* do notation* #3820 makes it an error to lift (<- ...) out of a pure if ... then ... else ...* Lazy discrimination trees* #3610 fixes a name collision for LazyDiscrTree that could lead to cache poisoning.* #3677 simplifies and fixes LazyDiscrTree handling for exact?/apply?.* #3685 moves general exact?/apply? functionality into LazyDiscrTree.* #3769 has lemma selection improvements for rw? and LazyDiscrTree.* #3818 improves ordering of matches.* #3590 adds inductive.autoPromoteIndices option to be able to disable auto promotion of indices in the inductive command.* Miscellaneous bug fixes and improvements* #3606 preserves cache and dischargeDepth fields in Lean.Meta.Simp.Result.mkEqSymm.* #3633 makes elabTermEnsuringType respect errToSorry, improving error recovery of the have tactic.* #3647 enables noncomputable unsafe definitions, for deferring implementations until later.* #3672 adjust namespaces of tactics.* #3725 fixes Ord derive handler for indexed inductive types with unused alternatives.* #3893 improves performance of derived Ord instances.* #3771 changes error reporting for failing tactic macros. Improves rfl error message.* #3745 fixes elaboration of generalized field notation if the object of the notation is an optional parameter.* #3799 makes commands such as universe, variable, namespace, etc. require that their argument appear in a later column.\nCommands that can optionally parse an ident or parse any number of idents generally should require\nthat the ident use colGt. This keeps typos in commands from being interpreted as identifiers.* #3815 lets the split tactic be used for writing code.* #3822 adds missing info in induction tactic for with clauses of the form | cstr a b c => ?_.* #3806 fixes withSetOptionIn combinator.* #3844 removes unused trace.Elab.syntax option.* #3896 improves hover and go-to-def for attribute command.* #3989 makes linter options more discoverable.* #3916 fixes go-to-def for syntax defined with @[builtin_term_parser].* #3962 fixes how solveByElim handles symm lemmas, making exact?/apply? usable again.* #3968 improves the @[deprecated] attribute, adding (since := \"<date>\") field.* #3768 makes #print command show structure fields.* #3974 makes exact?% behave like by exact? rather than by apply?.* #3994 makes elaboration of he ▸ h notation more predictable.* #3991 adjusts transparency for decreasing_trivial macros.* #4092 improves performance of binop% and binrel% expression tree elaborators.* Docs: #3748, #3796,\n#3800, #3874,\n#3863, #3862,\n#3891, #3873,\n#3908, #3872.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.8.0 (2024-06-05)","header":"Language features, tactics, and metaprograms","id":"/releases/v4.8.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___8___0-_LPAR_2024-06-05_RPAR_--Language-features___-tactics___-and-metaprograms"}});