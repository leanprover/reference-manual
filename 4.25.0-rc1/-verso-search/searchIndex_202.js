window.docContents[202].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Iteration":{"contents":"Constructs a bitvector by iteratively computing a state for each bit using the function f,\nstarting with the initial state s. At each step, the prior state and the current bit index are\npassed to f, and it produces a bit along with the next state value. These bits are assembled into\nthe final bitvector.It produces a sequence of state values [s_0, s_1 .. s_w] and a bitvector v where f i s_i = (s_{i+1}, b_i) and b_i is bit ith least-significant bit in v (e.g., getLsb v i = b_i).The theorem iunfoldr_replace allows uses of BitVec.iunfoldr to be replaced with declarative\nspecifications that are easier to reason about.\n\nGiven a function state that provides the correct state for every potential iteration count and a\nfunction that computes these states from the correct initial state, the result of applying\nBitVec.iunfoldr f to the initial state is the state corresponding to the bitvector's width paired\nwith the bitvector that consists of each computed bit.This theorem can be used to prove properties of functions that are defined using BitVec.iunfoldr.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"19.5.5.9. Iteration","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Iteration"},"/Basic-Types/Strings/#string-api-substring":{"contents":"Converts a String into a Substring that denotes the entire string.\n\nConverts a String into a Substring that denotes the entire string.This is a version of String.toSubstring that doesn't have an @[inline] annotation.\n\nA region or slice of some underlying string.A substring contains an string together with the start and end byte positions of a region of\ninterest. Actually extracting a substring requires copying and memory allocation, while many\nsubstrings of the same underlying string may exist with very little overhead, and they are more\nconvenient than tracking the bounds by hand.Using its constructor explicitly, it is possible to construct a Substring in which one or both of\nthe positions is invalid for the string. Many operations will return unexpected or confusing results\nif the start and stop positions are not valid. For this reason, Substring will be deprecated in\nfavor of String.Slice, which always represents a valid substring.The underlying string.The byte position of the start of the string slice.The byte position of the end of the string slice.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.11. Substrings","id":"/Basic-Types/Strings/#string-api-substring"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Sequencing-Tasks":{"contents":"These operators create new tasks from old ones.\nWhen possible, it's good to use Task.map or Task.bind instead of manually calling Task.get in a new task because they don't temporarily increase the size of the thread pool.\n\nmap f x maps function f over the task x: that is, it constructs\n(and immediately launches) a new task which will wait for the value of x to\nbe available and then calls f on the result.prio, if provided, is the priority of the task.\nIf sync is set to true, f is executed on the current thread if x has already finished and\notherwise on the thread that x finished on. prio is ignored in this case. This should only be\ndone when executing f is cheap and non-blocking.\n\nbind x f does a monad \"bind\" operation on the task x with function f:\nthat is, it constructs (and immediately launches) a new task which will wait\nfor the value of x to be available and then calls f on the result,\nresulting in a new task which is then run for a result.prio, if provided, is the priority of the task.\nIf sync is set to true, f is executed on the current thread if x has already finished and\notherwise on the thread that x finished on. prio is ignored in this case. This should only be\ndone when executing f is cheap and non-blocking.\n\nCreates a task that, when all tasks have finished, computes the result of f applied to their\nresults.\n\nCreates a new task that waits for t to complete and then runs the BaseIO action f on its\nresult. This new task has priority prio.Running the resulting BaseIO action causes the task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped.\n\nCreates a new task that waits for t to complete and then runs the IO action f on its result.\nThis new task has priority prio.Running the resulting BaseIO action causes the task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped. Because EIO ε actions\nmay throw an exception of type ε, the result of the task is an Except ε α.\n\nCreates a new task that waits for t to complete and then runs the IO action f on its result.\nThis new task has priority prio.Running the resulting BaseIO action causes the task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped. Because IO actions\nmay throw an exception of type IO.Error, the result of the task is an Except IO.Error α.\n\nCreates a new task that waits for all the tasks in the list tasks to complete, and then runs the\nIO action f on their results. This new task has priority prio.Running the resulting BaseIO action causes the task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped.\n\nCreates a new task that waits for all the tasks in the list tasks to complete, and then runs the\nEIO ε action f on their results. This new task has priority prio.Running the resulting BaseIO action causes the task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped.\n\nIO specialization of EIO.mapTasks.\n\nCreates a new task that waits for t to complete, runs the IO action f on its result, and then\ncontinues as the resulting task. This new task has priority prio.Running the resulting BaseIO action causes this new task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped.\n\nCreates a new task that waits for t to complete, runs the EIO ε action f on its result, and\nthen continues as the resulting task. This new task has priority prio.Running the resulting BaseIO action causes this new task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped. Because EIO ε actions\nmay throw an exception of type ε, the result of the task is an Except ε α.\n\nCreates a new task that waits for t to complete, runs the IO action f on its result, and then\ncontinues as the resulting task. This new task has priority prio.Running the resulting BaseIO action causes this new task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped. Because IO actions\nmay throw an exception of type IO.Error, the result of the task is an Except IO.Error α.\n\nCreates a new task that waits for t to complete and then runs the IO action f on its result.\nThis new task has priority prio.This is a version of BaseIO.mapTask that ignores the result value.Running the resulting BaseIO action causes the task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped.\n\nCreates a new task that waits for t to complete and then runs the EIO ε action f on its result.\nThis new task has priority prio.This is a version of EIO.mapTask that ignores the result value.Running the resulting EIO ε action causes the task to be started eagerly. Unlike pure tasks\ncreated by Task.spawn, tasks created by this function will run even if the last reference to the\ntask is dropped. The act should explicitly check for cancellation via IO.checkCanceled if it\nshould be terminated or otherwise react to the last reference being dropped.\n\nCreates a new task that waits for t to complete and then runs the IO action f on its result.\nThis new task has priority prio.This is a version of IO.mapTask that ignores the result value.Running the resulting IO action causes the task to be started eagerly. Unlike pure tasks created\nby Task.spawn, tasks created by this function will run even if the last reference to the task is\ndropped. The act should explicitly check for cancellation via IO.checkCanceled if it should be\nterminated or otherwise react to the last reference being dropped.\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads","header":"15.11.3. Sequencing Tasks","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Sequencing-Tasks"},"/Source-Files-and-Modules/#commands":{"contents":"Commands are top-level statements in Lean.\nSome examples are inductive type declarations, theorems, function definitions, namespace modifiers like open or variable, and interactive queries such as #check.\nThe syntax of commands is user-extensible, and commands may even add new syntax that is used to parse subsequent commands.\nSpecific Lean commands are documented in the corresponding chapters of this manual, rather than being listed here.\n\n\n\n","context":"Lean Reference\u0009Source Files and Modules\u0009Structure","header":"5.3.2. Commands","id":"/Source-Files-and-Modules/#commands"},"/releases/v4.7.0/#release-v4___7___0":{"contents":"* simp and rw now use instance arguments found by unification,\nrather than always resynthesizing. For backwards compatibility, the original behaviour is\navailable via set_option tactic.skipAssignedInstances false.\n#3507 and\n#3509.* When the pp.proofs is false, now omitted proofs use ⋯ rather than _,\nwhich gives a more helpful error message when copied from the Infoview.\nThe pp.proofs.threshold option lets small proofs always be pretty printed.\n#3241.* pp.proofs.withType is now set to false by default to reduce noise in the info view.* The pretty printer for applications now handles the case of over-application itself when applying app unexpanders.\nIn particular, the | `($_ $a $b $xs*) => `(($a + $b) $xs*) case of an app_unexpander is no longer necessary.\n#3495.* New simp (and dsimp) configuration option: zetaDelta. It is false by default.\nThe zeta option is still true by default, but their meaning has changed.* When zeta := true, simp and dsimp reduce terms of the form\nlet x := val; e[x] into e[val].* When zetaDelta := true, simp and dsimp will expand let-variables in\nthe context. For example, suppose the context contains x := val. Then,\nany occurrence of x is replaced with val.See issue #2682 for additional details. Here are some examples:example (h : z = 9) : let x := 5; let y := 4; x + y = z := by\n  intro x\n  simp\n  /-\n  New goal:\n  h : z = 9; x := 5 |- x + 4 = z\n  -/\n  rw [h]\n\nexample (h : z = 9) : let x := 5; let y := 4; x + y = z := by\n  intro x\n  -- Using both `zeta` and `zetaDelta`.\n  simp (config := { zetaDelta := true })\n  /-\n  New goal:\n  h : z = 9; x := 5 |- 9 = z\n  -/\n  rw [h]\n\nexample (h : z = 9) : let x := 5; let y := 4; x + y = z := by\n  intro x\n  simp [x] -- asks `simp` to unfold `x`\n  /-\n  New goal:\n  h : z = 9; x := 5 |- 9 = z\n  -/\n  rw [h]\n\nexample (h : z = 9) : let x := 5; let y := 4; x + y = z := by\n  intro x\n  simp (config := { zetaDelta := true, zeta := false })\n  /-\n  New goal:\n  h : z = 9; x := 5 |- let y := 4; 5 + y = z\n  -/\n  rw [h]\n* When adding new local theorems to simp, the system assumes that the function application arguments\nhave been annotated with no_index. This modification, which addresses issue #2670,\nrestores the Lean 3 behavior that users expect. With this modification, the following examples are now operational:example {α β : Type} {f : α × β → β → β} (h : ∀ p : α × β, f p p.2 = p.2)\n  (a : α) (b : β) : f (a, b) b = b := by\n  simp [h]\n\nexample {α β : Type} {f : α × β → β → β}\n  (a : α) (b : β) (h : f (a,b) (a,b).2 = (a,b).2) : f (a, b) b = b := by\n  simp [h]\nIn both cases, h is applicable because simp does not index f-arguments anymore when adding h to the simp-set.\nIt's important to note, however, that global theorems continue to be indexed in the usual manner.* Improved the error messages produced by the decide tactic. #3422* Improved auto-completion performance. #3460* Improved initial language server startup performance. #3552* Changed call hierarchy to sort entries and strip private header from names displayed in the call hierarchy. #3482* There is now a low-level error recovery combinator in the parsing framework, primarily intended for DSLs. #3413* You can now write termination_by? after a declaration to see the automatically inferred\ntermination argument, and turn it into a termination_by … clause using the “Try this” widget or a code action. #3514* A large fraction of Std has been moved into the Lean repository.\nThis was motivated by:1. Making universally useful tactics such as ext, by_cases, change at,\nnorm_cast, rcases, simpa, simp?, omega, and exact?\navailable to all users of Lean, without imports.2. Minimizing the syntactic changes between plain Lean and Lean with import Std.3. Simplifying the development process for the basic data types\nNat, Int, Fin (and variants such as UInt64), List, Array,\nand BitVec as we begin making the APIs and simp normal forms for these types\nmore complete and consistent.4. Laying the groundwork for the Std roadmap, as a library focused on\nessential datatypes not provided by the core language (e.g. RBMap)\nand utilities such as basic IO.\nWhile we have achieved most of our initial aims in v4.7.0-rc1,\nsome upstreaming will continue over the coming months.* The / and % notations in Int now use Int.ediv and Int.emod\n(i.e. the rounding conventions have changed).\nPreviously Std overrode these notations, so this is no change for users of Std.\nThere is now kernel support for these functions.\n#3376.* omega, our integer linear arithmetic tactic, is now available in the core language.* It is supplemented by a preprocessing tactic bv_omega which can solve goals about BitVec\nwhich naturally translate into linear arithmetic problems.\n#3435.* omega now has support for Fin #3427,\nthe <<< operator #3433.* During the port omega was modified to no longer identify atoms up to definitional equality\n(so in particular it can no longer prove id x ≤ x). #3525.\nThis may cause some regressions.\nWe plan to provide a general purpose preprocessing tactic later, or an omega! mode.* omega is now invoked in Lean's automation for termination proofs\n#3503 as well as in\narray indexing proofs #3515.\nThis automation will be substantially revised in the medium term,\nand while omega does help automate some proofs, we plan to make this much more robust.* The library search tactics exact? and apply? that were originally in\nMathlib are now available in Lean itself.  These use the implementation using\nlazy discrimination trees from Std, and thus do not require a disk cache but\nhave a slightly longer startup time.  The order used for selection lemmas has\nchanged as well to favor goals purely based on how many terms in the head\npattern match the current goal.* The solve_by_elim tactic has been ported from Std to Lean so that library\nsearch can use it.* New #check_tactic and #check_simp commands have been added.  These are\nuseful for checking tactics (particularly simp) behave as expected in test\nsuites.* Previously, app unexpanders would only be applied to entire applications. However, some notations produce\nfunctions, and these functions can be given additional arguments. The solution so far has been to write app unexpanders so that they can take an arbitrary number of additional arguments. However this leads to misleading hover information in the Infoview. For example, while HAdd.hAdd f g 1 pretty prints as (f + g) 1, hovering over f + g shows f. There is no way to fix the situation from within an app unexpander; the expression position for HAdd.hAdd f g is absent, and app unexpanders cannot register TermInfo.This commit changes the app delaborator to try running app unexpanders on every prefix of an application, from longest to shortest prefix. For efficiency, it is careful to only try this when app delaborators do in fact exist for the head constant, and it also ensures arguments are only delaborated once. Then, in (f + g) 1, the f + g gets TermInfo registered for that subexpression, making it properly hoverable.#3375\n\nBreaking changes:\n\n* Lean.withTraceNode and variants got a stronger MonadAlwaysExcept assumption to\nfix trace trees not being built on elaboration runtime exceptions. Instances for most elaboration\nmonads built on EIO Exception should be synthesized automatically.* The match ... with. and fun. notations previously in Std have been replaced by\nnomatch ... and nofun. #3279 and #3286\n\nOther improvements:\n\n* several bug fixes for simp:* we should not crash when simp loops #3269* simp gets stuck on autoParam #3315* simp fails when custom discharger makes no progress #3317* simp fails to discharge autoParam premises even when it can reduce them to True #3314* simp? suggests generated equations lemma names, fixes #3547 #3573* fixes for match expressions:* fix regression with builtin literals #3521* accept match when patterns cover all cases of a BitVec finite type #3538* fix matching Int literals #3504* patterns containing int values and constructors #3496* improve termination_by error messages #3255* fix rename_i in macros, fixes #3553 #3581* fix excessive resource usage in generalize, fixes #3524 #3575* an equation lemma with autoParam arguments fails to rewrite, fixing #2243 #3316* add_decl_doc should check that declarations are local #3311* instantiate the types of inductives with the right parameters, closing #3242 #3246* New simprocs for many basic types. #3407\n\nLake fixes:\n\n* Warn on fetch cloud release failure #3401* Cloud release trace & lake build :release errors #3248\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.7.0 (2024-04-03)","id":"/releases/v4.7.0/#release-v4___7___0"}});