window.docContents[252].resolve({"/Functors___-Monads-and--do--Notation/Syntax/#do-control-structures":{"contents":"There are do items that correspond to most of Lean's term-level control structures.\nWhen they occur as a step in a do block, they are interpreted as do items rather than terms.\nEach branch of the control structures is a sequence of do items, rather than a term, and some of them are more syntactically flexible than their corresponding terms.\n\nConditionalsIn a do block, if statements may omit their else branch.\nOmitting an else branch is equivalent to using pure () as the contents of the branch.\n\nSyntactically, the then branch cannot be omitted.\nFor these cases, unless only executes its body when the condition is false.\nThe do in unless is part of its syntax and does not induce a nested do block.\n\nReverse Conditionals\n\nWhen match is used in a do block, each branch is considered to be part of the same block.\nOtherwise, it is equivalent to the match term.\n\nPattern Matching\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.4. Control Structures","id":"/Functors___-Monads-and--do--Notation/Syntax/#do-control-structures"},"/IO/Processes/#The-Lean-Language-Reference--IO--Processes--Running-Processes":{"contents":"There are three primary ways to run other programs from Lean:\n\n1. IO.Process.run synchronously executes another program, returning its standard output as a string. It throws an error if the process exits with an error code other than 0.2. IO.Process.output synchronously executes another program with an empty standard input, capturing its standard output, standard error, and exit code. No error is thrown if the process terminates unsuccessfully.3. IO.Process.spawn starts another program asynchronously and returns a data structure that can be used to access the process's standard input, output, and error streams.\n\nRuns a process to completion, blocking until it terminates.\nThe child process is run with a null standard input or the specified input if provided,\nIf the child process terminates successfully with exit code 0, its standard output is returned.\nAn exception is thrown if it terminates with any other exit code.The specifications of standard input, output, and error handles in args are ignored.\n\nRunning a ProgramWhen run, this program concatenates its own source code with itself twice using the Unix tool cat.-- Main.lean begins here\ndef main : IO Unit := do\n  let src2 ← IO.Process.run {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  IO.println src2\n-- Main.lean ends here\nIts output is:-- Main.lean begins here\ndef main : IO Unit := do\n  let src2 ← IO.Process.run {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  IO.println src2\n-- Main.lean ends here\n-- Main.lean begins here\ndef main : IO Unit := do\n  let src2 ← IO.Process.run {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  IO.println src2\n-- Main.lean ends here\n\n\nRunning a Program on a FileThis program uses the Unix utility grep as a filter to find four-digit palindromes.\nIt creates a file that contains all numbers from 0 through 9999, and then invokes grep on it, reading the result from its standard output.def main : IO Unit := do\n  -- Feed the input to the subprocess\n  IO.FS.withFile \"numbers.txt\" .write fun h =>\n    for i in [0:10000] do\n      h.putStrLn (toString i)\n\n  let palindromes ← IO.Process.run {\n    cmd := \"grep\",\n    args := #[r#\"^\\([0-9]\\)\\([0-9]\\)\\2\\1$\"#, \"numbers.txt\"]\n  }\n\n  let count := palindromes.trim.splitOn \"\\n\" |>.length\n\n  IO.println s!\"There are {count} four-digit palindromes.\"\nIts output is:There are 90 four-digit palindromes.\n\n\nRuns a process to completion and captures its output and exit code.\nThe child process is run with a null standard input or the specified input if provided,\nand the current process blocks until it has run to completion.The specifications of standard input, output, and error handles in args are ignored.\n\nChecking Exit CodesWhen run, this program first invokes cat on a nonexistent file and displays the resulting error code.\nIt then concatenates its own source code with itself twice using the Unix tool cat.-- Main.lean begins here\ndef main : IO UInt32 := do\n  let src1 ← IO.Process.output {cmd := \"cat\", args := #[\"Nonexistent.lean\"]}\n  IO.println s!\"Exit code from failed process: {src1.exitCode}\"\n\n  let src2 ← IO.Process.output {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  if src2.exitCode == 0 then\n    IO.println src2.stdout\n  else\n    IO.eprintln \"Concatenation failed\"\n    return 1\n\n  return 0\n-- Main.lean ends here\nIts output is:Exit code from failed process: 1\n-- Main.lean begins here\ndef main : IO UInt32 := do\n  let src1 ← IO.Process.output {cmd := \"cat\", args := #[\"Nonexistent.lean\"]}\n  IO.println s!\"Exit code from failed process: {src1.exitCode}\"\n\n  let src2 ← IO.Process.output {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  if src2.exitCode == 0 then\n    IO.println src2.stdout\n  else\n    IO.eprintln \"Concatenation failed\"\n    return 1\n\n  return 0\n-- Main.lean ends here\n-- Main.lean begins here\ndef main : IO UInt32 := do\n  let src1 ← IO.Process.output {cmd := \"cat\", args := #[\"Nonexistent.lean\"]}\n  IO.println s!\"Exit code from failed process: {src1.exitCode}\"\n\n  let src2 ← IO.Process.output {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  if src2.exitCode == 0 then\n    IO.println src2.stdout\n  else\n    IO.eprintln \"Concatenation failed\"\n    return 1\n\n  return 0\n-- Main.lean ends here\n\n\n\nStarts a child process with the provided configuration. The child process is spawned using operating\nsystem primitives, and it can be written in any language.The child process runs in parallel with the parent.If the child process's standard input is a pipe, use IO.Process.Child.takeStdin to make it\npossible to close the child's standard input before the process terminates, which provides the child with an end-of-file marker.\n\nAsynchronous SubprocessesThis program uses the Unix utility grep as a filter to find four-digit palindromes.\nIt feeds all numbers from 0 through 9999 to the grep process and then reads its result.\nThis code is only correct when grep is sufficiently fast and when the output pipe is large enough to contain all 90 four-digit palindromes.def main : IO Unit := do\n  let grep ← IO.Process.spawn {\n    cmd := \"grep\",\n    args := #[r#\"^\\([0-9]\\)\\([0-9]\\)\\2\\1$\"#],\n    stdin := .piped,\n    stdout := .piped,\n    stderr := .null\n  }\n\n  -- Feed the input to the subprocess\n  for i in [0:10000] do\n    grep.stdin.putStrLn (toString i)\n\n  -- Consume its output, after waiting 100ms for grep to process the data.\n  IO.sleep 100\n  let count := (← grep.stdout.readToEnd).trim.splitOn \"\\n\" |>.length\n\n  IO.println s!\"There are {count} four-digit palindromes.\"\nIts output is:There are 90 four-digit palindromes.\n\n\nConfiguration for a child process to be spawned.Use IO.Process.spawn to start the child process. IO.Process.output and IO.Process.run can be\nused when the child process should be run to completion, with its output and/or error code captured.Command name.Arguments for the command.The child process's working directory. Inherited from the parent current process if none.Add or remove environment variables for the child process.The child process inherits the parent's environment, as modified by env. Keys in the array are\nthe names of environment variables. A none, causes the entry to be removed from the environment,\nand some sets the variable to the new value, adding it if necessary. Variables are processed from left to right.Inherit environment variables from the spawning process.Starts the child process in a new session and process group using setsid. Currently a no-op on\nnon-POSIX platforms.\n\nConfiguration for the standard input, output, and error handles of a child process.Configuration for the process' stdin handle.Configuration for the process' stdout handle.Configuration for the process' stderr handle.\n\nWhether the standard input, output, and error handles of a child process should be attached to\npipes, inherited from the parent, or null.If the stream is a pipe, then the parent process can use it to communicate with the child.The stream should be attached to a pipe.The stream should be inherited from the parent process.The stream should be empty.\n\nThe type of handles that can be used to communicate with a child process on its standard input,\noutput, or error streams.For IO.Process.Stdio.piped, this type is IO.FS.Handle. Otherwise, it is Unit, because no\ncommunication is possible.\n\nA child process that was spawned with configuration cfg.The configuration determines whether the child process's standard input, standard output, and\nstandard error are IO.FS.Handles or Unit.The child process's standard input handle, if it was configured as IO.Process.Stdio.piped, or\n() otherwise.The child process's standard output handle, if it was configured as IO.Process.Stdio.piped, or\n() otherwise.The child process's standard error handle, if it was configured as IO.Process.Stdio.piped, or\n() otherwise.\n\nBlocks until the child process has exited and return its exit code.\n\nChecks whether the child has exited. Returns none if the process has not exited, or its exit code\nif it has.\n\nTerminates the child process using the SIGTERM signal or a platform analogue.If the process was started using SpawnArgs.setsid, terminates the entire process group instead.\n\nExtracts the stdin field from a Child object, allowing the handle to be closed while maintaining\na reference to the child process.File handles are closed when the last reference to them is dropped. Closing the child's standard\ninput causes an end-of-file marker. Because the Child object has a reference to the standard\ninput, this operation is necessary in order to close the stream while the process is running (e.g.\nto extract its exit code after calling Child.wait). Many processes do not terminate until their\nstandard input is exhausted.\n\nClosing a Subprocess's Standard InputThis program uses the Unix utility grep as a filter to find four-digit palindromes, ensuring that the subprocess terminates successfully.\nIt feeds all numbers from 0 through 9999 to the grep process, then closes the process's standard input, which causes it to terminate.\nAfter checking grep's exit code, the program extracts its result.def main : IO UInt32 := do\n  let grep ← do\n    let (stdin, child) ← (← IO.Process.spawn {\n      cmd := \"grep\",\n      args := #[r#\"^\\([0-9]\\)\\([0-9]\\)\\2\\1$\"#],\n      stdin := .piped,\n      stdout := .piped,\n      stderr := .null\n    }).takeStdin\n\n    -- Feed the input to the subprocess\n    for i in [0:10000] do\n      stdin.putStrLn (toString i)\n\n    -- Return the child without its stdin handle.\n    -- This closes the handle, because there are\n    -- no more references to it.\n    pure child\n\n  -- Wait for grep to terminate\n  if (← grep.wait) != 0 then\n    IO.eprintln s!\"grep terminated unsuccessfully\"\n    return 1\n\n  -- Consume its output\n  let count := (← grep.stdout.readToEnd).trim.splitOn \"\\n\" |>.length\n\n  IO.println s!\"There are {count} four-digit palindromes.\"\n  return 0\nIts output is:There are 90 four-digit palindromes.\n\n\nThe result of running a process to completion.The process's exit code.Everything that was written to the process's standard output.Everything that was written to the process's standard error.\n\n","context":"Lean Reference\u0009IO\u0009Processes","header":"15.9.2. Running Processes","id":"/IO/Processes/#The-Lean-Language-Reference--IO--Processes--Running-Processes"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Library":{"contents":"* #7858 implements the fast circuit for overflow detection in unsigned\nmultiplication used by Bitwuzla and proposed in:\nhttps://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=987767* #9127 makes saveModuleData throw an IO.Error instead of panicking,\nif given something that cannot be serialized. This doesn't really matter\nfor saving modules, but is handy when writing tools to save auxiliary\ndate in olean files via Batteries' pickle.* #9560 fixes the forIn function, that previously caused the resulting\nPromise to be dropped without a value when an exception was thrown\ninside of it. It also corrects the parameter order of the background\nfunction.* #9599 adds the type Std.Internal.Parsec.Error, which contains the\nconstructors .eof (useful for checking if parsing failed due to not\nhaving enough input and then retrying when more input arrives that is\nuseful in the HTTP server) and .other, which describes other errors.\nIt also adds documentation to many functions, along with some new\nfunctions to the ByteArray Parsec, such as peekWhen?, octDigit,\ntakeWhile, takeUntil, skipWhile, and skipUntil.* #9632 adds lemmas for the TreeMap operations filter, map and\nfilterMap. These lemmas existed already for hash maps and are simply\nported over from there.* #9685 verifies toArray and related functions for hashmaps.* #9797 provides the means to quickly provide all the order instances\nassociated with some high-level order structure (preorder, partial\norder, linear preorder, linear order). This can be done via the factory\nfunctions PreorderPackage.ofLE, PartialOrderPackage.ofLE,\nLinearPreorderPackage.ofLE and LinearOrderPackage.ofLE.* #9908 makes IsPreorder, IsPartialOrder, IsLinearPreorder and\nIsLinearOrder extend BEq and Ord as appropriate, adds the\nLawfulOrderBEq and LawfulOrderOrd typeclasses relating BEq and\nOrd to LE, and adds many lemmas and instances.* #9916 provides factories that derive order typeclasses in bulk, given\nan Ord instance. If present, existing instances are preferred over\nthose derived from Ord. It is possible to specify any instance\nmanually if desired.* #9924 fixes examples in the documentation for PostCond.* #9931 implements Std.Do.Triple.mp, enabling users to compose two\nspecifications for the same program.* #9949 allows most of the List.lookup lemmas to be used when\nLawfulBEq α is not available.* #9957 upstreams the definition of Rat from Batteries, for use in our\nplanned interval arithmetic tactic.* #9967 removes local Triple notation from SpecLemmas.lean to work\naround a bug that breaks the stage2 build.* #9979 replaces Std.Internal.Rat with the new public Rat upstreamed\nfrom Batteries.* #9987 improves the tactic for proving that elements of a Nat-based\nPRange are in-bounds by relying on the omega tactic.* #9993 defines the dyadic rationals, showing they are an ordered ring\nembedding into the rationals. We will use this for future interval\narithmetic tactics.* #9999 reduces the number of Nat.Bitwise grind annotations we have\nthe deal with distributivity. The new smaller set encourages grind to\nrewrite into DNF. The old behaviour just resulted in saturating up to\nthe instantiation limits.* #10000 removes a grind annotation that fired on all Option.maps,\ncausing an avalanche of instantiations.* #10005 shortens the work necessary to make a type compatible with the\npolymorphic range notation. In the concrete case of Nat, it reduces\nthe required lines of code from 150 to 70.* #10015 exposes the bodies of Name.append, Name.appendCore, and\nName.hasMacroScopes. This enables proof by reflection of the\nconcatenation of name literals when using the module system.* #10018 derives BEq and Hashable for Lean.Import. Lake already did\nthis later, but it now done when defining Import.* #10019 adds @[expose] to Lean.ParserState.setPos. This makes it\npossible to prove in-boundedness for a state produced by setPos for\nfunctions like next' and get' without needing to import all.* #10024 adds useful declarations to the LawfulOrderMin/Max and\nLawfulOrderLeftLeaningMin/Max API. In particular, it introduces\n.leftLeaningOfLE factories for Min and Max. It also renames\nLawfulOrderMin/Max.of_le to .of_le_min_iffand.of_max_le_iff` and\nintroduces a second variant with different arguments.* #10045 implements the necessary typeclasses so that range notation\nworks for integers. For example, ((-2)...3).toList = [-2, -1, 0, 1, 2] : List Int.* #10049 adds some background material needed for introducing the dyadic\nrationals in #9993.* #10050 fixes some naming issues in Data/Rat/Lemmas, and upstreams the\neliminator numDenCasesOn and its relatives.* #10059 improves the names of definitions and lemmas in the polymorphic\nrange API. It also introduces a recommended spelling. For example, a\nleft-closed, right-open range is spelled Rco in analogy with Mathlib's\nIco intervals.* #10075 contains lemmas about Int (minor amendments for BitVec and\nNat) that are being used in preparing the dyadics. This is all work of\n@Rob23oba, which I'm pulling out of #9993 early to keep that one\nmanageable.* #10077 upstreams lemmas about Rat from Mathlib.Data.Rat.Defs and\nMathlib.Algebra.Order.Ring.Unbundled.Rat, specifically enough to get\nLean.Grind.Field Rat and Lean.Grind.OrderedRing Rat. In addition to\nthe lemmas, instances for Inv Rat, Pow Rat Nat and Pow Rat Int\nhave been upstreamed.* #10107 adds the Lean.Grind.AddCommGroup instance for Rat.* #10138 adds lemmas about the Dyadic.roundUp and Dyadic.roundDown\noperations.* #10159 adds nodup_keys lemmas as corollaries of existing\ndistinct_keys to all Map variants.* #10162 removes grind → annotations that fire too often, unhelpfully.\nIt would be nice for grind to instantiate these lemmas, but only if\nthey already see xs ++ ys and #[] in the same equivalence class, not\njust as soon as it sees xs ++ ys.* #10163 removes some (hopefully) unnecessary grind annotations that\ncause instantiation explosions.* #10173 removes the extends Monad from MonadAwait and MonadAsync\nto avoid underdetermined instances.* #10182 adds lemmas about Nat.fold and Nat.foldRev on sums, to match\nthe existing theorems about dfold and dfoldRev.* #10194 adds the inverse of a dyadic rational, at a given precision, and\ncharacterising lemmas. Also cleans up various parts of the Int.DivMod\nand Rat APIs, and proves some characterising lemmas about\nRat.toDyadic.* #10216 fixes #10193.* #10224 generalizes the monadic operations for HashMap, TreeMap, and\nHashSet to work for m : Type u → Type v.* #10227 adds @[grind] annotations (nearly all @[grind =] annotations\nparallel to existing @[simp]s) for ReaderT, StateT, ExceptT.* #10244 adds more lemmas about the toList and toArray functions on\nranges and iterators. It also renames Array.mem_toArray into\nList.mem_toArray.* #10247 adds missing the lemmas ofList_eq_insertMany_empty,\nget?_eq_some_iff, getElem?_eq_some_iff and getKey?_eq_some_iff to\nall container types.* #10250 fixes a bug in the LinearOrderPackage.ofOrd factory. If there\nis a LawfulEqOrd instance available, it should automatically use it\ninstead of requiring the user to provide the eq_of_compare argument to\nthe factory. The PR also solves a hygiene-related problem making the\nfactories fail when Std is not open.* #10303 adds range support toBitVec and the UInt* types. This means\nthat it is now possible to write, for example, for i in (1 : UInt8)...5 do, in order to loop over the values 1, 2, 3 and 4 of type UInt8.* #10341 moves the definitions and basic facts about Function.Injective\nand Function.Surjective up from Mathlib. We can do a better job of\narguing via injectivity in grind if these are available.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)","header":"Library","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Library"}});