window.docContents[160].resolve({"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Case-Conversion":{"contents":"Converts a lowercase ASCII letter to the corresponding uppercase letter. Letters outside the ASCII\nalphabet are returned unchanged.The lowercase ASCII letters are the following: abcdefghijklmnopqrstuvwxyz.\n\nConverts an uppercase ASCII letter to the corresponding lowercase letter. Letters outside the ASCII\nalphabet are returned unchanged.The uppercase ASCII letters are the following: ABCDEFGHIJKLMNOPQRSTUVWXYZ.\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters\u0009API Reference","header":"19.7.4.3. Case Conversion","id":"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Case-Conversion"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Custom-Facets":{"contents":"Custom facets allow additional artifacts to be incrementally built from a module, library, or package.\n\nCustom Package FacetsPackage facets allow the production of an artifact or set of artifacts from a whole package.\nThe Lake API makes it possible to query a package for its libraries; thus, one common use for a package facet is to build a given facet of each library.Define a new package facet. Has one form:package_facet «facet-name» (pkg : Package) : α :=\n  /- build term of type `FetchM (Job α)` -/\nThe pkg parameter (and its type specifier) is optional.\n\nCustom Library FacetsLibrary facets allow the production of an artifact or set of artifacts from a library.\nThe Lake API makes it possible to query a library for its modules; thus, one common use for a library facet is to build a given facet of each module.Define a new library facet. Has one form:library_facet «facet-name» (lib : LeanLib) : α :=\n  /- build term of type `FetchM (Job α)` -/\nThe lib parameter (and its type specifier) is optional.\n\nCustom Module FacetsModule facets allow the production of an artifact or set of artifacts from a module, typically by invoking a command-line tool.Define a new module facet. Has one form:module_facet «facet-name» (mod : Module) : α :=\n  /- build term of type `FetchM (Job α)` -/\nThe mod parameter (and its type specifier) is optional.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format\u0009Targets","header":"22.1.3.2.4.5. Custom Facets","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Custom-Facets"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Combined-Error-and-State-Monads--State-Rollback":{"contents":"Composing StateT and ExceptT in different orders causes exceptions to interact differently with state.\nIn one ordering, state changes are rolled back when exceptions are caught; in the other, they persist.\nThe latter option matches the semantics of most imperative programming languages, but the former is very useful for search-based problems.\nOften, some but not all state should be rolled back; this can be achieved by “sandwiching” ExceptT between two separate uses of StateT.\n\nTo avoid yet another layer of indirection via the use of StateT σ (EStateM ε σ') α, EStateM offers the EStateM.Backtrackable type class.\nThis class specifies some part of the state that can be saved and restored.\nEStateM then arranges for the saving and restoring to take place around error handling.\n\nException handlers in EStateM save some part of the state, determined by δ, and restore it if an\nexception is caught. By default, δ is Unit, and no information is saved.Extracts the information in the state that should be rolled back if an exception is handled.Updates the current state with the saved information that should be rolled back. This updated\nstate becomes the current state when an exception is handled.\n\nThere is a universally-applicable instance of Backtrackable that neither saves nor restores anything.\nBecause instance synthesis chooses the most recent instance first, the universal instance is used only if no other instance has been defined.\n\nA fallback Backtrackable instance that saves no information from a state. This allows every type\nto be used as a state in EStateM, with no rollback.Because this is the first declared instance of Backtrackable _ σ, it will be picked only if there\nare no other Backtrackable _ σ instances registered.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Combined Error and State Monads","header":"14.5.8.1. State Rollback","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Combined-Error-and-State-Monads--State-Rollback"},"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Lake":{"contents":"* #4735 improves a number of elements related to Git checkouts, cloud releases,\nand related error handling.* On error, Lake now prints all top-level logs. Top-level logs are those produced by Lake outside of the job monitor (e.g., when cloning dependencies).* When fetching a remote for a dependency, Lake now forcibly fetches tags. This prevents potential errors caused by a repository recreating tags already fetched.* Git error handling is now more informative.* The builtin package facets release, optRelease, extraDep are now captions in the same manner as other facets.* afterReleaseSync and afterReleaseAsync now fetch optRelease rather than release.* Added support for optional jobs, whose failure does not cause the whole build to failure. Now optRelease is such a job.* #4608 adds draft CI workflow when creating new projects.* #4847 adds CLI options to control log levels. The --log-level=<lv> controls the minimum log level Lake should output. For instance, --log-level=error will only print errors (not warnings or info). Also, adds an analogous --fail-level option to control the minimum log level for build failures. The existing --iofail and --wfail options are respectively equivalent to --fail-level=info and --fail-level=warning.* Docs: #4853\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.11.0 (2024-09-02)","header":"Lake","id":"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Lake"},"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Lean-internals":{"contents":"* Elaboration* #4596 enforces isDefEqStuckEx at unstuckMVar procedure, causing isDefEq to throw a stuck defeq exception if the metavariable was created in a previous level. This results in some better error messages, and it helps rw succeed in synthesizing instances (see issue #2736).* #4713 fixes deprecation warnings when there are overloaded symbols.* elab_as_elim algorithm:* #4722 adds check that inferred motive is type-correct.* #4800 elaborates arguments for parameters appearing in the types of targets.* #4817 makes the algorithm correctly handle eliminators with explicit motive arguments.* #4792 adds term elaborator for Lean.Parser.Term.namedPattern (e.g. n@(n' + 1)) to report errors when used in non-pattern-matching contexts.* #4818 makes anonymous dot notation work when the expected type is a pi-type-valued type synonym.* Typeclass inference* #4646 improves synthAppInstances, the function responsible for synthesizing instances for the rw and apply tactics. Adds a synthesis loop to handle functions whose instances need to be synthesized in a complex order.* Inductive types* #4684 (backported as 98ee78) refactors InductiveVal to have a numNested : Nat field instead of isNested : Bool. This modifies the kernel.* Definitions* #4776 improves performance of Replacement.apply.* #4712 fixes .eq_def theorem generation with messy universes.* #4841 improves success of finding T.below x hypothesis when transforming match statements for IndPredBelow.* Diagnostics and profiling* #4611 makes kernel diagnostics appear when diagnostics is enabled even if it is the only section.* #4753 adds missing profileitM functions.* #4754 adds Lean.Expr.numObjs to compute the number of allocated sub-expressions in a given expression, primarily for diagnosing performance issues.* #4769 adds missing withTraceNodes to improve trace.profiler output.* #4781 and #4882 make the \"use set_option diagnostics true\" message be conditional on current setting of diagnostics.* Performance* #4767, #4775, and #4887 add ShareCommon.shareCommon' for sharing common terms. In an example with 16 million subterms, it is 20 times faster than the old shareCommon procedure.* #4779 ensures Expr.replaceExpr preserves DAG structure in Exprs.* #4783 documents performance issue in Expr.replaceExpr.* #4794, #4797, #4798 make for_each use precise cache.* #4795 makes Expr.find? and Expr.findExt? use the kernel implementations.* #4799 makes Expr.replace use the kernel implementation.* #4871 makes Expr.foldConsts use a precise cache.* #4890 makes expr_eq_fn use a precise cache.* Utilities* #4453 upstreams ToExpr FilePath and compile_time_search_path%.* Module system* #4652 fixes handling of const2ModIdx in finalizeImport, making it prefer the original module for a declaration when a declaration is re-declared.* Kernel* #4637 adds a check to prevent large Nat exponentiations from evaluating. Elaborator reduction is controlled by the option exponentiation.threshold.* #4683 updates comments in kernel/declaration.h, making sure they reflect the current Lean 4 types.* #4796 improves performance by using replace with a precise cache.* #4700 improves performance by fixing the implementation of move constructors and move assignment operators. Expression copying was taking 10% of total runtime in some workloads. See issue #4698.* #4702 improves performance in replace_rec_fn::apply by avoiding expression copies. These copies represented about 13% of time spent in save_result in some workloads. See the same issue.* Other fixes or improvements* #4590 fixes a typo in some constants and trace.profiler.useHeartbeats.* #4617 add 'since' dates to deprecated attributes.* #4625 improves the robustness of the constructor-as-variable test.* #4740 extends test with nice example reported on Zulip.* #4766 moves Syntax.hasIdent to be available earlier and shakes dependencies.* #4881 splits out Lean.Language.Lean.Types.* #4893 adds LEAN_EXPORT for sharecommon functions.* Typos: #4635, #4719, af40e6* Docs: #4748 (Command.Scope)\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.11.0 (2024-09-02)","header":"Lean internals","id":"/releases/v4.11.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___11___0-_LPAR_2024-09-02_RPAR_--Lean-internals"},"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Lake":{"contents":"* #5715 changes lake new math to use autoImplicit false (@eric-wieser).* #5688 makes Lake not create core aliases in the Lake namespace.* #5924 adds a text option for buildFile* utilities.* #5789 makes lake init not git init when inside git work tree (@haoxins).* #5684 has Lake update a package's lean-toolchain file on lake update if it finds the package's direct dependencies use a newer compatible toolchain. To skip this step, use the --keep-toolchain CLI option. (See breaking changes.)* #6218 makes Lake no longer automatically fetch GitHub cloud releases if the package build directory is already present (mirroring the behavior of the Reservoir cache). This prevents the cache from clobbering existing prebuilt artifacts. Users can still manually fetch the cache and clobber the build directory by running lake build <pkg>:release.* #6231 improves the errors Lake produces when it fails to fetch a dependency from Reservoir. If the package is not indexed, it will produce a suggestion about how to require it from GitHub.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.14.0 (2024-12-02)","header":"Lake","id":"/releases/v4.14.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___14___0-_LPAR_2024-12-02_RPAR_--Lake"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--finally-section":{"contents":"#8723 implements a finally section following a (potentially empty)\nwhere block. where ... finally opens a tactic sequence block in\nwhich the goals are the unassigned metavariables from the definition\nbody and its auxiliary definitions that arise from use of let rec and\nwhere.\nThis can be useful for discharging multiple proof obligations in the definition body\nby a single invocation of a tactic such as all_goals:\n\nexample (i j : Nat) (xs : Array Nat) (hi : i < xs.size) (hj: j < xs.size) :=\n  match i with\n  | 0 => x\n  | _ => xs[i]'?_ + xs[j]'?_\nwhere x := 13\nfinally all_goals assumption\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"finally section","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--finally-section"}});