window.docContents[34].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-Characters":{"contents":"The Char type is a wrapper around UInt32 that requires a proof that the wrapped integer represents a Unicode code point.\nThis predicate is part of the UInt32 API.\n\nA UInt32 denotes a valid Unicode code point if it is less than 0x110000 and it is also not a\nsurrogate code point (the range 0xd800 to 0xdfff inclusive).\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","header":"19.4.4.3.7. To Characters","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-Characters"},"/Basic-Types/Natural-Numbers/#nat-api-gcd-lcm":{"contents":"Computes the greatest common divisor of two natural numbers. The GCD of two natural numbers is the\nlargest natural number that evenly divides both.In particular, the GCD of a number and 0 is the number itself.This reference implementation via the Euclidean algorithm is overridden in both the kernel and the\ncompiler to efficiently evaluate using arbitrary-precision arithmetic. The definition provided here\nis the logical model.Examples:* Nat.gcd 10 15 = 5* Nat.gcd 0 5 = 5* Nat.gcd 7 0 = 7\n\nThe least common multiple of m and n is the smallest natural number that's evenly divisible by\nboth m and n. Returns 0 if either m or n is 0.Examples:* Nat.lcm 9 6 = 18* Nat.lcm 9 3 = 9* Nat.lcm 0 3 = 0* Nat.lcm 3 0 = 0\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"19.1.4.3. GCD and LCM","id":"/Basic-Types/Natural-Numbers/#nat-api-gcd-lcm"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-ext":{"contents":"Applies extensionality lemmas that are registered with the @[ext] attribute.* ext pat* applies extensionality theorems as much as possible,\nusing the patterns pat* to introduce the variables in extensionality theorems using rintro.\nFor example, the patterns are used to name the variables introduced by lemmas such as funext.* Without patterns,ext applies extensionality lemmas as much\nas possible but introduces anonymous hypotheses whenever needed.* ext pat* : n applies ext theorems only up to depth n.The ext1 pat* tactic is like ext pat* except that it only applies a single extensionality theorem.Unused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n\next1 pat* is like ext pat* except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.The pat* patterns are processed using the rintro tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the intros tactic.\n\nApply a single extensionality theorem to the current goal.\n\nApply function extensionality and introduce new hypotheses.\nThe tactic funext will keep applying the funext lemma until the goal target is not reducible to  |-  ((fun x => ...) = (fun x => ...))\nThe variant funext h₁ ... hₙ applies funext n times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the intro tactic. Example, given a goal  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\nfunext (a, b) applies funext once and performs pattern matching on the newly introduced pair.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.10. Extensionality","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-ext"},"/The-Type-System/Inductive-Types/#subsingleton-elimination":{"contents":"Proofs in Lean are computationally irrelevant.\nIn other words, having been provided with some proof of a proposition, it should be impossible for a program to check which proof it has received.\nThis is reflected in the types of recursors for inductively defined propositions or predicates.\nFor these types, if there's more than one potential proof of the theorem then the motive may only return another Prop.\nIf the type is structured such that there's only at most one proof anyway, then the motive may return a type in any universe.\nA proposition that has at most one inhabitant is called a subsingleton.\nRather than obligating users to prove that there's only one possible proof, a conservative syntactic approximation is used to check whether a proposition is a subsingleton.\nPropositions that fulfill both of the following requirements are considered to be subsingletons:\n\n* There is at most one constructor.* Each of the constructor's parameter types is either a Prop, a parameter, or an index.\n\nTrue is a subsingletonTrue is a subsingleton because it has one constructor, and this constructor has no parameters.\nIts recursor has the following signature:True.rec.{u} {motive : True → Sort u}\n  (intro : motive True.intro)\n  (t : True) : motive t\n\n\nFalse is a subsingletonFalse is a subsingleton because it has no constructors.\nIts recursor has the following signature:False.rec.{u} (motive : False → Sort u) (t : False) : motive t\nNote that the motive is an explicit parameter.\nThis is because it is not mentioned in any further parameters' types, so it could not be solved by unification.\n\nAnd is a subsingletonAnd is a subsingleton because it has one constructor, and both of the constructor's parameters' types are propositions.\nIts recursor has the following signature:And.rec.{u} {a b : Prop} {motive : a ∧ b → Sort u}\n  (intro : (left : a) → (right : b) → motive (And.intro left right))\n  (t : a ∧ b) : motive t\n\n\nOr is not a subsingletonOr is not a subsingleton because it has more than one constructor.\nIts recursor has the following signature:Or.rec {a b : Prop} {motive : a ∨ b → Prop}\n  (inl : ∀ (h : a), motive (.inl h))\n  (inr : ∀ (h : b), motive (.inr h))\n  (t : a ∨ b) : motive t\nThe motive's type indicates that Or.rec can only be used to produce proofs.\nA proof of a disjunction can be used to prove something else, but there's no way for a program to inspect which of the two disjuncts was true and used for the proof.\n\nEq is a subsingletonEq is a subsingleton because it has just one constructor, Eq.refl.\nThis constructor instantiates Eq's index with a parameter value, so all arguments are parameters:Eq.refl.{u} {α : Sort u} (x : α) : Eq x x\nIts recursor has the following signature:Eq.rec.{u, v} {α : Sort v} {x : α}\n  {motive : (y : α) → x = y → Sort u}\n  (refl : motive x (.refl x))\n  {y : α} (t : x = y) : motive y t\nThis means that proofs of equality can be used to rewrite the types of non-propositions.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Recursors\u0009Recursor Types","header":"4.4.3.1.1.1. Subsingleton Elimination","id":"/The-Type-System/Inductive-Types/#subsingleton-elimination"},"/releases/v4.12.0/#release-v4___12___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.12.0 (2024-10-01)","id":"/releases/v4.12.0/#release-v4___12___0"},"/releases/v4.21.0/#release-v4___21___0":{"contents":"For this release, 295 changes landed. In addition to the 100 feature additions and 83 fixes listed below there were 2 refactoring changes, 4 documentation improvements, 6 performance improvements, 2 improvements to the test suite and 98 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.21.0 (2025-06-30)","id":"/releases/v4.21.0/#release-v4___21___0"}});