window.docContents[24].resolve({"/Basic-Types/Lazy-Computations/#Thunk-api":{"contents":"Gets the thunk's value. If the value is cached, it is returned in constant time; if not, it is\ncomputed.Computed values are cached, so the value is not recomputed.\n\nConstructs a new thunk that forces x and then applies x to the result. Upon forcing, the result\nof f is cached and the reference to the thunk x is dropped.\n\nStores an already-computed value in a thunk.Because the value has already been computed, there is no laziness.\n\nConstructs a new thunk that applies f to the result of x when forced.\n\n","context":"Lean Reference\u0009Basic Types\u0009Lazy Computations","header":"19.20.4. API Reference","id":"/Basic-Types/Lazy-Computations/#Thunk-api"},"/Definitions/Recursive-Definitions/#partial-fixpoint":{"contents":"All definitions are fundamentally equations: the new constant being defined is equal to the right-hand side of the definition.\nFor functions defined by structural recursion, this equation holds definitionally, and there is a unique value returned by application of the function.\nFor functions defined by well-founded recursion, the equation may hold only propositionally, but all type-correct applications of the function to arguments are equal to the respective values prescribed by the definition.\nIn both cases, the fact that the function terminates for all inputs means that the value computed by applying the function is always uniquely determined.\n\nIn some cases where a function does not terminate for all arguments, the equation may not uniquely determine the function's return value for each input, but there are nonetheless functions for which the defining equation holds.\nIn these cases, a definition as a partial fixpoint may still be possible.\nAny function that satisfies the defining equation can be used to demonstrate that the equation does not create a logical contradiction, and the equation can then be proven as a theorem about this function.\nAs with the other strategies for defining recursive functions, compiled code uses the function as it was originally written; like definitions in terms of eliminators or recursion over accessibility proofs, the function used to define the partial fixpoint is used only to justify the function's equations in Lean's logic for purposes of mathematical reasoning.\n\nThe term partial fixpoint is specific to Lean.\nFunctions declared partial do not require termination proofs, so long as the type of their return values is inhabited, but they are completely opaque from the perspective of Lean's logic.\nPartial fixpoints, on the other hand, can be rewritten using their defining equations while writing proofs.\nLogically speaking, partial fixpoints are total functions that don't reduce definitionally when applied, but for which equational rewrite rule are provided.\nThey are partial in the sense that the defining equation does not necessarily specify a value for all possible arguments.\n\nWhile partial fixpoints do allow functions to be defined that cannot be expressed using structural or well-founded recursion, the technique is also useful in other cases.\nEven in cases where the defining equation fully describes the function's behavior and a termination proof using well-founded recursion would be possible, it may simply be more convenient to define the function as a partial fixpoint to avoid a having to write a termination proof.\n\nDefining recursive functions as partial fixpoints only occurs when explicitly requested by annotating the definition with partial_fixpoint.\n\nThere are two classes of functions that can be defined as partial fixpoints:* Tail-recursive functions whose return type is inhabited type* Functions that return values in a suitable monad, such as the Option monadBoth classes are backed by the same theory and construction: least fixpoints of monotone equations in chain-complete partial orders.\n\nJust as with structural and well-founded recursion, Lean allows mutually recursive functions to be defined as partial fixpoints.\nTo use this feature, every function definition in a mutual block must be annotated with the partial_fixpoint modifier.\n\n\n\nDefinition by Partial FixpointThe following function finds the least natural number for which the predicate p holds.\nIf p never holds, then this equation does not specify the behavior: the function find could return 42 or any other Nat in that case and still satisfy the equation.def find (p : Nat â†’ Bool) (i : Nat := 0) : Nat :=\n  if p i then\n    i\n  else\n    find p (i + 1)\npartial_fixpoint\nThe elaborator can prove that functions satisfying the equation exist.\nWithin Lean's logic, find is defined to be an arbitrary such function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.4. Partial Fixpoint Recursion","id":"/Definitions/Recursive-Definitions/#partial-fixpoint"}});