window.docContents[142].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Array-Data":{"contents":"The underlying array.\n\nThe starting index of the region of interest (inclusive).\n\nThe ending index of the region of interest (exclusive).\n\nThe starting index is no later than the ending index.The ending index is exclusive. If the starting and ending indices are equal, then the subarray is\nempty.\n\nThe stopping index is no later than the end of the array.The ending index is exclusive. If it is equal to the size of the array, then the last element of\nthe array is in the subarray.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","header":"19.16.5.1. Array Data","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Array-Data"},"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Comparisons--Inequalities":{"contents":"The decision procedures for inequalities are opaque constants in the logic.\nThey can only be used via the Lean.ofReduceBool axiom, e.g. via the native_decide tactic.\n\nNon-strict inequality of floating-point numbers. Typically used via the ≤ operator.\n\nNon-strict inequality of floating-point numbers. Typically used via the ≤ operator.\n\nStrict inequality of floating-point numbers. Typically used via the < operator.\n\nStrict inequality of floating-point numbers. Typically used via the < operator.\n\nCompares two floating point numbers for non-strict inequality.This function does not reduce in the kernel. It is compiled to the C inequality operator.\n\nCompares two floating point numbers for non-strict inequality.This function does not reduce in the kernel. It is compiled to the C inequality operator.\n\nCompares two floating point numbers for strict inequality.This function does not reduce in the kernel. It is compiled to the C inequality operator.\n\nCompares two floating point numbers for strict inequality.This function does not reduce in the kernel. It is compiled to the C inequality operator.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Comparisons","header":"19.6.2.4.1. Inequalities","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Comparisons--Inequalities"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--Logical-Model":{"contents":"A string is a sequence of Unicode scalar values.At runtime, strings are represented by dynamic arrays\nof bytes using the UTF-8 encoding. Both the size in bytes (String.utf8ByteSize) and in characters\n(String.length) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.The bytes of the UTF-8 encoding of the string. Since strings have a special representation in\nthe runtime, this function actually takes linear time and space at runtime. For efficient access\nto the string's bytes, use String.utf8ByteSize and String.getUTF8Byte.The bytes of the string form valid UTF-8.\n\nThe logical model of strings in Lean is a structure that contains two fields:* String.bytes is a ByteArray, which contains the UTF-8 encoding of the string.* String.isValidUTF8 is a proof that the bytes are in fact a valid UTF-8 encoding of a string.This model allows operations on byte arrays to be used to specify and prove properties about string operations at a low level while still building on the theory of byte arrays.\nAt the same time, it is close enough to the real run-time representation to avoid impedance mismatches between the logical model and the operations that make sense in the run-time representation.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings","header":"19.8.1. Logical Model","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--Logical-Model"},"/Basic-Types/Strings/#string-api-fold":{"contents":"Applies the function f to every character in a string, returning a string that contains the\nresulting characters.Examples:* \"abc123\".map Char.toUpper = \"ABC123\"* \"\".map Char.toUpper = \"\"\n\nFolds a function over a string from the left, accumulating a value starting with init. The\naccumulated value is combined with each character in order, using f.Examples:* \"coffee tea water\".foldl (fun n c => if c.isWhitespace then n + 1 else n) 0 = 2* \"coffee tea and water\".foldl (fun n c => if c.isWhitespace then n + 1 else n) 0 = 3* \"coffee tea water\".foldl (·.push ·) \"\" = \"coffee tea water\"\n\nFolds a function over a string from the right, accumulating a value starting with init. The\naccumulated value is combined with each character in reverse order, using f.Examples:* \"coffee tea water\".foldr (fun c n => if c.isWhitespace then n + 1 else n) 0 = 2* \"coffee tea and water\".foldr (fun c n => if c.isWhitespace then n + 1 else n) 0 = 3* \"coffee tea water\".foldr (fun c s => c.push s) \"\" = \"retaw dna aet eeffoc\"\n\nChecks whether the Boolean predicate p returns true for every character in a string.Short-circuits at the first character for which p returns false.Examples:* \"brown\".all (·.isLetter) = true* \"brown and orange\".all (·.isLetter) = false* \"\".all (fun _ => false) = true\n\nChecks whether there is a character in a string for which the Boolean predicate p returns true.Short-circuits at the first character for which p returns true.Examples:* \"brown\".any (·.isLetter) = true* \"brown\".any (·.isWhitespace) = false* \"brown and orange\".any (·.isLetter) = true* \"\".any (fun _ => false) = false\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.7. Folds and Aggregation","id":"/Basic-Types/Strings/#string-api-fold"},"/IO/Mutable-References/#mutable-st-references":{"contents":"Mutable references are often useful in contexts where arbitrary side effects are undesired.\nThey can give a significant speedup when Lean is unable to optimize pure operations into mutation, and some algorithms are more easily expressed using mutable references than with state monads.\nAdditionally, it has a property that other side effects do not have: if all of the mutable references used by a piece of code are created during its execution, and no mutable references from the code escape to other code, then the result of evaluation is deterministic.\n\nThe ST monad is a restricted version of IO in which mutable state is the only side effect, and mutable references cannot escape.ST was first described by .\nST takes a type parameter that is never used to classify any terms.\nThe runST function, which allow escape from ST, requires that the ST action that is passed to it can instantiate this type parameter with any type.\nThis unknown type does not exist except as a parameter to a function, which means that values whose types are “marked” by it cannot escape its scope.\n\nA restricted version of IO in which mutable state is the only side effect.It is possible to run ST computations in a non-monadic context using runST.\n\nRuns an ST computation, in which mutable state via ST.Ref is the only side effect.\n\nAs with IO and EIO, there is also a variation of ST that takes a custom error type as a parameter.\nHere, ST is analogous to BaseIO rather than IO, because ST cannot result in errors being thrown.\n\nA restricted version of IO in which mutable state and exceptions are the only side effects.It is possible to run EST computations in a non-monadic context using runEST.\n\nRuns an EST computation, in which mutable state and exceptions are the only side effects.\n\nMutable reference cells that contain values of type α. These cells can read from and mutated in\nthe ST σ monad.\n\nCreates a new mutable reference that contains the provided value a.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO\u0009Mutable References","header":"15.4.1. State Transformers","id":"/IO/Mutable-References/#mutable-st-references"},"/Run-Time-Code/Foreign-Function-Interface/#ffi-initialization":{"contents":"When including Lean code in a larger program, modules must be initialized before accessing any of their declarations.\nModule initialization entails:\n\n* initialization of all “constant definitions” (nullary functions), including closed terms lifted out of other functions,* execution of all code marked with the init attribute, and* execution of all code marked with the builtin_init attribute, if the builtin parameter of the module initializer has been set.\n\nThe module initializer is automatically run with the builtin flag for executables compiled from Lean code and for “plugins” loaded with lean --plugin.\nFor all other modules imported by lean, the initializer is run without builtin.\nIn other words, init functions are run if and only if their module is imported, regardless of whether they have native code available, while builtin_init functions are only run for native executable or plugins, regardless of whether their module is imported.\nThe Lean compiler uses built-in initializers for purposes such as registering basic parsers that should be available even without importing their module, which is necessary for bootstrapping.\n\nThe initializer for module A.B is called initialize_A_B and will automatically initialize any imported modules.\nModule initializers are idempotent when run with the same builtin flag, but not thread-safe.\nTogether with initialization of the Lean runtime, code like the following should be run exactly once before accessing any Lean declarations:\n\nvoid lean_initialize_runtime_module();\nvoid lean_initialize();\nlean_object * initialize_A_B(uint8_t builtin, lean_object *);\nlean_object * initialize_C(uint8_t builtin, lean_object *);\n...\n\nlean_initialize_runtime_module();\n// Necessary (and replaces `lean_initialize_runtime_module`) for code that\n// (indirectly) accesses the `Lean` package:\n//lean_initialize();\n\nlean_object * res;\n// use same default as for Lean executables\nuint8_t builtin = 1;\nres = initialize_A_B(builtin, lean_io_mk_world());\nif (lean_io_result_is_ok(res)) {\n    lean_dec_ref(res);\n} else {\n    lean_io_result_show_error(res);\n    lean_dec(res);\n    // do not access Lean declarations if initialization failed\n    return ...;\n}\nres = initialize_C(builtin, lean_io_mk_world());\nif (lean_io_result_is_ok(res)) {\n...\n\n// Necessary for code that (indirectly) uses `Task`\n//lean_init_task_manager();\nlean_io_mark_end_initialization();\n\n\nIn addition, any other thread not spawned by the Lean runtime itself must be initialized for Lean use by calling\n\nvoid lean_initialize_thread();\n\n\nand should be finalized in order to free all thread-local resources by calling\n\nvoid lean_finalize_thread();\n\n\n","context":"Lean Reference\u0009Run-Time Code\u0009Foreign Function Interface","header":"21.4.2. Initialization","id":"/Run-Time-Code/Foreign-Function-Interface/#ffi-initialization"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language":{"contents":"A tactic script consists of a sequence of tactics, separated either by semicolons or newlines.\nWhen separated by newlines, tactics must be indented to the same level.\nExplicit curly braces and semicolons may be used instead of indentation.\nTactic sequences may be grouped by parentheses.\nThis allows a sequence of tactics to be used in a position where a single tactic would otherwise be grammatically expected.\n\nGenerally, execution proceeds from top to bottom, with each tactic running in the proof state left behind by the prior tactic.\nThe tactic language contains a number of control structures that can modify this flow.\n\nEach tactic is a syntax extension in the tactic category.\nThis means that tactics are free to define their own concrete syntax and parsing rules.\nHowever, with a few exceptions, the majority of tactics can be identified by a leading keyword; the exceptions are typically frequently-used built-in control structures such as <;>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs","header":"13.3. The Tactic Language","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Ordering--Instance-Construction":{"contents":"Constructs the lexicographic order on products α × β from orders for α and β.\n\nConstructs an Ord instance from two existing instances by combining them lexicographically.The resulting instance compares elements first by ord₁ and then, if this returns Ordering.eq, by\nord₂.The function compareLex can be used to perform this comparison without constructing an\nintermediate Ord instance. Ordering.then can be used to lexicographically combine the results of\ncomparisons.\n\nConstructs an Ord instance that compares values according to the results of f.In particular, ord.on f compares x and y by comparing f x and f y according to ord.The function compareOn can be used to perform this comparison without constructing an intermediate\nOrd instance.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes\u0009Ordering","header":"11.5.2.1. Instance Construction","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Ordering--Instance-Construction"}});