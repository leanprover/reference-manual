window.docContents[176].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Element-Predicates":{"contents":"Checks whether a is an element of as, using == to compare elements.Array.elem is a synonym that takes the element before the array.Examples:* #[1, 4, 2, 3, 3, 7].contains 3 = true* Array.contains #[1, 4, 2, 3, 3, 7] 5 = false\n\nChecks whether a is an element of as, using == to compare elements.Array.contains is a synonym that takes the array before the element.For verification purposes, Array.elem is simplified to Array.contains.Example:* Array.elem 3 #[1, 4, 2, 3, 3, 7] = true* Array.elem 5 #[1, 4, 2, 3, 3, 7] = false\n\nReturns the first element of the array for which the predicate p returns true, or none if no\nsuch element is found.Examples:* #[7, 6, 5, 8, 1, 2, 6].find? (· < 5) = some 1* #[7, 6, 5, 8, 1, 2, 6].find? (· < 1) = none\n\nReturns the last element of the array for which the predicate p returns true, or none if no\nsuch element is found.Examples:* #[7, 6, 5, 8, 1, 2, 6].findRev? (· < 5) = some 2* #[7, 6, 5, 8, 1, 2, 6].findRev? (· < 1) = none\n\nReturns the index of the first element for which p returns true, or the size of the array if\nthere is no such element.Examples:* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 5) = 4* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 1) = 7\n\nReturns the index of the first element for which p returns true, or none if there is no such\nelement.Examples:* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 5) = some 4* #[7, 6, 5, 8, 1, 2, 6].findIdx (· < 1) = none\n\nFinds the index of the first element of an array for which the monadic predicate p returns true.\nElements are examined in order from left to right, and the search is terminated when an element that\nsatisfies p is found. If no such element exists in the array, then none is returned.\n\nReturns the index of the first element for which p returns true, or none if there is no such\nelement. The index is returned as a Fin, which guarantees that it is in bounds.Examples:* #[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· < 5) = some (4 : Fin 7)* #[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· < 1) = none\n\nReturns the first element of the array for which the monadic predicate p returns true, or none\nif no such element is found. Elements of the array are checked in order.The monad m is restricted to Type → Type to avoid needing to use ULift Bool in p's type.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 6\nAlmost! 5\nsome 1\n\n\nReturns the last element of the array for which the monadic predicate p returns true, or none\nif no such element is found. Elements of the array are checked in reverse, from right to left..The monad m is restricted to Type → Type to avoid needing to use ULift Bool in p's type.Example:#eval #[7, 5, 8, 1, 2, 6, 5, 8].findRevM? fun i => do\n  if i < 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\nAlmost! 5\nAlmost! 6\nsome 2\n\n\nReturns the first non-none result of applying the function f to each element of the\narray, in order. Returns none if f returns none for all elements.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findSome? fun i =>\n  if i < 5 then\n    some (i * 10)\n  else\n    none\nsome 10\n\n\nReturns the first non-none result of applying the function f to each element of the\narray, in order. Panics if f returns none for all elements.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findSome? fun i =>\n  if i < 5 then\n    some (i * 10)\n  else\n    none\nsome 10\n\n\nReturns the first non-none result of applying the monadic function f to each element of the\narray, in order. Returns none if f returns none for all elements.Example:#eval #[7, 6, 5, 8, 1, 2, 6].findSomeM? fun i => do\n  if i < 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\nAlmost! 6\nAlmost! 5\nsome 10\n\n\nReturns the first non-none result of applying f to each element of the array in reverse order,\nfrom right to left. Returns none if f returns none for all elements of the array.Examples:* #[7, 6, 5, 8, 1, 2, 6].findSome? (fun x => if x < 5 then some (10 * x) else none) = some 10* #[7, 6, 5, 8, 1, 2, 6].findSome? (fun x => if x < 1 then some (10 * x) else none) = none\n\nReturns the first non-none result of applying the monadic function f to each element of the\narray in reverse order, from right to left. Once a non-none result is found, no further elements\nare checked. Returns none if f returns none for all elements of the array.Examples:#eval #[1, 2, 0, -4, 1].findSomeRevM? (m := Except String) fun x => do\n  if x = 0 then throw \"Zero!\"\n  else if x < 0 then return (some x)\n  else return none\nExcept.ok (some (-4))\n#eval #[1, 2, 0, 4, 1].findSomeRevM? (m := Except String) fun x => do\n  if x = 0 then throw \"Zero!\"\n  else if x < 0 then return (some x)\n  else return none\nExcept.error \"Zero!\"\n\n\nReturns true if p returns true for every element of as.Short-circuits upon encountering the first false.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.Examples:* #[a, b, c].all p = (p a && (p b && p c))* #[2, 4, 6].all (· % 2 = 0) = true* #[2, 4, 5, 6].all (· % 2 = 0) = false\n\nReturns true if the monadic predicate p returns true for every element of as.Short-circuits upon encountering the first false. The elements in as are examined in order from\nleft to right.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.\n\nReturns true if p returns true for any element of as.Short-circuits upon encountering the first true.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.Examples:* #[2, 4, 6].any (· % 2 = 0) = true* #[2, 4, 6].any (· % 2 = 1) = false* #[2, 4, 5, 6].any (· % 2 = 0) = true* #[2, 4, 5, 6].any (· % 2 = 1) = true\n\nReturns true if the monadic predicate p returns true for any element of as.Short-circuits upon encountering the first true. The elements in as are examined in order from\nleft to right.The optional parameters start and stop control the region of the array to be checked. Only the\nelements with indices from start (inclusive) to stop (exclusive) are checked. By default, the\nentire array is checked.\n\nReturns true if no two elements of as are equal according to the == operator.Examples:* #[\"red\", \"green\", \"blue\"].allDiff = true* #[\"red\", \"green\", \"red\"].allDiff = false* (#[] : Array Nat).allDiff = true\n\nReturns true if as and bs have the same length and they are pairwise related by eqv.Short-circuits at the first non-related pair of elements.Examples:* #[1, 2, 3].isEqv #[2, 3, 4] (· < ·) = true* #[1, 2, 3].isEqv #[2, 2, 4] (· < ·) = false* #[1, 2, 3].isEqv #[2, 3] (· < ·) = false\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.12. Element Predicates","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Element-Predicates"},"/Basic-Types/Characters/#char-model":{"contents":"From the perspective of Lean's logic, characters consist of a 32-bit unsigned integer paired with a proof that it is a valid Unicode scalar value.\n\nCharacters are Unicode scalar values.The underlying Unicode scalar value as a UInt32.The value must be a legal scalar value.\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters","header":"19.7.1. Logical Model","id":"/Basic-Types/Characters/#char-model"},"/The-Simplifier/Simplification-vs-Rewriting/#simp-vs-rw":{"contents":"Both simp and rw/rewrite use equational lemmas to replace parts of terms with equivalent alternatives.\nTheir intended uses and their rewriting strategies differ, however.\nTactics in the simp family are primarily used to reformulate a problem in a standardized way, making it more amenable to both human understanding and further automation.\nIn particular, simplification should never render an otherwise-provable goal impossible.\nTactics in the rw family are primarily used to apply hand-selected transformations that do not always preserve provability nor place terms in standardized forms.\nThese different emphases are reflected in the differences of behavior between the two families of tactics.\n\nThe simp tactics primarily rewrite from the inside out.\nThe smallest possible expressions are simplified first so that they can unlock further simplification opportunities for the surrounding expressions.\nThe rw tactics select the leftmost outermost subterm that matches the pattern, rewriting it a single time.\nBoth tactics allow their strategy to be overridden: when adding a lemma to a simp set, the ↓ modifier causes it to be applied prior to the simplification of subterms, and the occs field of rw's configuration parameter allows a different occurrence to be selected, either via a whitelist or a blacklist.\n\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.7. Simplification vs Rewriting","id":"/The-Simplifier/Simplification-vs-Rewriting/#simp-vs-rw"}});