window.docContents[144].resolve({"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Conversions":{"contents":"Creates a string that contains the characters in a list, in order.Examples:* ['L', '∃', '∀', 'N'].asString = \"L∃∀N\"* [].asString = \"\"* ['a', 'a', 'a'].asString = \"aaa\"\n\nConverts a List α into an Array α.O(|xs|). At runtime, this operation is implemented by List.toArrayImpl and takes time linear in\nthe length of the list. List.toArray should be used instead of Array.mk.Examples:* [1, 2, 3].toArray = #[1, 2, 3]* [\"monday\", \"wednesday\", friday\"].toArray = #[\"monday\", \"wednesday\", friday\"].\n\nConverts a List α into an Array α by repeatedly pushing elements from the list onto an empty\narray. O(|xs|).Use List.toArray instead of calling this function directly. At runtime, this operation implements\nboth List.toArray and Array.mk.\n\nConverts a list of bytes into a ByteArray.\n\nConverts a list of floats into a FloatArray.\n\nConverts a list into a string, using ToString.toString to convert its elements.The resulting string resembles list literal syntax, with the elements separated by \", \" and\nenclosed in square brackets.The resulting string may not be valid Lean syntax, because there's no such expectation for\nToString instances.Examples:* [1, 2, 3].toString = \"[1, 2, 3]\"* [\"cat\", \"dog\"].toString = \"[cat, dog]\"* [\"cat\", \"dog\", \"\"].toString = \"[cat, dog, ]\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.7. Conversions","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Conversions"},"/Basic-Types/Strings/#string-api-meta":{"contents":"Converts a string to the Lean compiler's representation of names. The resulting name is\nhierarchical, and the string is split at the dots ('.').\"a.b\".toName is the name a.b, not «a.b». For the latter, use Name.mkSimple.\n\nConverts a string to its corresponding Lean string literal syntax. Double quotes are added to each\nend, and internal characters are escaped as needed.Examples:* \"abc\".quote = \"\\\"abc\\\"\"* \"\\\"\".quote = \"\\\"\\\\\\\"\\\"\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.13. Metaprogramming","id":"/Basic-Types/Strings/#string-api-meta"},"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch--Examples":{"contents":"Vector length index as a parameterinductive Vec (α : Type) (n : Nat) : Type where\n  | nil  : Vec α 0\n  | cons : α → Vec α n → Vec α (n + 1)\n<invalid output>inductive Vec (α : Type) : Nat → Type where\n  | nil  : Vec α 0\n  | cons : α → Vec α n → Vec α (n + 1)\nThe length argument n of the Vec type constructor is declared as a parameter, but other values\nfor this argument appear in the nil and cons constructors (namely, 0 and n + 1). An error\ntherefore appears at the first occurrence of such an argument. To correct this, n cannot be a\nparameter of the inductive declaration and must instead be an index, as in the corrected example. On\nthe other hand, α remains unchanged throughout all occurrences of Vec in the declaration and so\nis a valid parameter.\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.inductiveParamMismatch","header":"Examples","id":"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch--Examples"},"/IO/System-and-Platform-Information/#platform-info":{"contents":"The word size of the current platform, which may be 64 or 32 bits.\n\nThe LLVM target triple of the current platform. Empty if missing when Lean was compiled.\n\nIs the current platform Windows?\n\nIs the current platform macOS?\n\nIs the current platform Emscripten?\n\n","context":"Lean Reference\u0009IO","header":"15.6. System and Platform Information","id":"/IO/System-and-Platform-Information/#platform-info"},"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#grind-ring":{"contents":"The ring solver in grind is inspired by Gröbner basis computation procedures and term rewriting completion.\nIt views multivariate polynomials as rewriting rules.\nFor example, the polynomial equality x * y + x - 2 = 0 is treated as a rewriting rule x * y ↦ -x + 2.\nIt uses superposition to ensure the rewriting system is confluent.\n\nThe following examples demonstrate goals that can be decided by the ring solver.\nIn these examples, the Lean and Lean.Grind namespaces are open:\n\nopen Lean Grind\n\n\nCommutative Ringsexample [CommRing α] (x : α) : (x + 1) * (x - 1) = x ^ 2 - 1 := by\n  grind\n\n\nRing CharacteristicsThe solver “knows” that 16*16 = 0 because the ring characteristic (that is, the minimum number of copies of the multiplicative identity that sum to the additive identity) is 256, which is provided by the IsCharP instance.example [CommRing α] [IsCharP α 256] (x : α) :\n    (x + 16)*(x - 16) = x^2 := by\n  grind\n\n\nStandard Library TypesTypes in the standard library are supported by the solver out of the box.\nUInt8 is a commutative ring with characteristic 256, and thus has instances of CommRing UInt8 and IsCharP UInt8 256.example (x : UInt8) : (x + 16) * (x - 16) = x ^ 2 := by\n  grind\n\n\nMore Commutative Ring ProofsThe axioms of a commutative ring are sufficient to prove these statements.example [CommRing α] (a b c : α) :\n    a + b + c = 3 →\n    a ^ 2 + b ^ 2 + c ^ 2 = 5 →\n    a ^ 3 + b ^ 3 + c ^ 3 = 7 →\n    a ^ 4 + b ^ 4 = 9 - c ^ 4 := by\n  grind\nexample [CommRing α] (x y : α) :\n    x ^ 2 * y = 1 →\n    x * y ^ 2 = y →\n    y * x = 1 := by\n  grind\n\n\nCharacteristic Zeroring proves that a + 1 = 2 + a is unsatisfiable because the characteristic is known to be 0.example [CommRing α] [IsCharP α 0] (a : α) :\n    a + 1 = 2 + a → False := by\n  grind\n\n\nInferred CharacteristicEven when the characteristic is not initially known, when grind discovers that n = 0 for some numeral n, it makes inferences about the characteristic:example [CommRing α] (a b c : α)\n    (h₁ : a + 6 = a) (h₂ : c = c + 9) (h : b + 3*c = 0) :\n    27*a + b = 0 := by\n  grind\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.8. Algebraic Solver (Commutative Rings, Fields)","id":"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#grind-ring"}});