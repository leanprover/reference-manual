window.docContents[2].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Boundaries":{"contents":"Constructs a valid position on s from a position and a proof that it is valid.\n\nConstructs a valid position s from a position, panicking if the position is not valid.\n\nConstructs a valid position on s from a position, returning none if the position is not valid.\n\nThe start position of s, as an s.Pos.\n\nThe past-the-end position of s, as an s.Pos.\n\nThe end position of a slice, as a Pos.Raw.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.3. Boundaries","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Boundaries"},"/Basic-Types/Sum-Types/#sum-types":{"contents":"Sum types represent a choice between two types: an element of the sum is an element of one of the other types, paired with an indication of which type it came from.\nSums are also known as disjoint unions, discriminated unions, or tagged unions.\nThe constructors of a sum are also called injections; mathematically, they can be considered as injective functions from each summand to the sum.\n\nThere are two varieties of the sum type:* Sum is polymorphic over all Type universes, and is never a proposition.* PSum is allows the summands to be propositions or types. Unlike Or, the PSum of two propositions is still a type, and non-propositional code can check which injection was used to construct a given value.Manually-written Lean code almost always uses only Sum, while PSum is used as part of the implementation of proof automation.\nThis is because it imposes problematic constraints that universe level unification cannot solve.\nIn particular, this type is in the universe Sort (max 1 u v), which can cause problems for universe level unification because the equation max 1 u v = ?u + 1 has no solution in level arithmetic.\nPSum is usually only used in automation that constructs sums of arbitrary types.\n\nThe disjoint union of types α and β, ordinarily written α ⊕ β.An element of α ⊕ β is either an a : α wrapped in Sum.inl or a b : β wrapped in Sum.inr.\nα ⊕ β is not equivalent to the set-theoretic union of α and β because its values include an\nindication of which of the two types was chosen. The union of a singleton set with itself contains\none element, while Unit ⊕ Unit contains distinct values inl () and inr ().Left injection into the sum type α ⊕ β.Right injection into the sum type α ⊕ β.\n\nThe disjoint union of arbitrary sorts α β, or α ⊕' β.It differs from α ⊕ β in that it allows α and β to have arbitrary sorts Sort u and Sort v,\ninstead of restricting them to Type u and Type v. This means that it can be used in situations\nwhere one side is a proposition, like True ⊕' Nat. However, the resulting universe level\nconstraints are often more difficult to solve than those that result from Sum.Left injection into the sum type α ⊕' β.Right injection into the sum type α ⊕' β.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.14. Sum Types","id":"/Basic-Types/Sum-Types/#sum-types"},"/The--grind--tactic/Linear-Arithmetic-Solver/#grind-linarith-classes":{"contents":"To add support for a new type to linarith, the first step is to implement IntModule if possible, or NatModule otherwise.\nEvery Ring is already an IntModule, and every Semiring is already a NatModule, so implementing one of those instances is also sufficient.\nNext, one of the order classes (Std.IsPreorder, Std.IsPartialOrder, or Std.IsLinearOrder) should be implemented.\nTypically an IsPreorder instance is enough when the context already includes a contradiction, but an IsLinearOrder instance is required in order to prove linear inequality goals.\nAdditional features are enabled by implementing OrderedAdd, which expresses that the additive structure in a module is compatible with the order, and OrderedRing, which improves support for constants.\n\nA module over the natural numbers, i.e. a type with zero, addition, and scalar multiplication by natural numbers,\nsatisfying appropriate compatibilities.Equivalently, an additive commutative monoid.Use IntModule if the type has negation.Scalar multiplication by natural numbers.Scalar multiplication by zero is zero.Scalar multiplication by a successor.\n\nA module over the integers, i.e. a type with zero, addition, negation, subtraction, and scalar multiplication by integers,\nsatisfying appropriate compatibilities.Equivalently, an additive commutative group.Scalar multiplication by natural numbers.Scalar multiplication by integers.Scalar multiplication by zero is zero.Scalar multiplication by one is the identity.Scalar multiplication is distributive over addition in the integers.Scalar multiplication by natural numbers is consistent with scalar multiplication by integers.\n\nAddition is compatible with a preorder if a ≤ b ↔ a + c ≤ b + c.a + c ≤ b + c iff a ≤ b.\n\nA ring which is also equipped with a preorder is considered a strict ordered ring if addition, negation,\nand multiplication are compatible with the preorder, and 0 < 1.In a strict ordered semiring, we have 0 < 1.In a strict ordered semiring, we can multiply an inequality a < b on the left\nby a positive element 0 < c to obtain c * a < c * b.In a strict ordered semiring, we can multiply an inequality a < b on the right\nby a positive element 0 < c to obtain a * c < b * c.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Arithmetic Solver","header":"17.9.1. Supporting  linarith","id":"/The--grind--tactic/Linear-Arithmetic-Solver/#grind-linarith-classes"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Library":{"contents":"* #5498 makes BitVec.getElem the simp normal form in case a proof is\navailable and changes ext to return x[i] + a hypothesis that proves\nthat we are in-bounds. This aligns BitVec further with the API\nconventions of the Lean standard datatypes.* #6326 adds BitVec.(getMsbD, msb)_replicate, replicate_one theorems,\ncorrects a non-terminal simp in BitVec.getLsbD_replicate and\nsimplifies the proof of BitVec.getElem_replicate using the cases\ntactic.* #6628 adds SMT-LIB operators to detect overflow\nBitVec.(uadd_overflow, sadd_overflow), according to the definitions\nhere,\nand the theorems proving equivalence of such definitions with the\nBitVec library functions (uaddOverflow_eq, saddOverflow_eq).\nSupport theorems for these proofs are BitVec.toNat_mod_cancel_of_lt, BitVec.toInt_lt, BitVec.le_toInt, Int.bmod_neg_iff. The PR also\nincludes a set of tests.* #6792 adds theorems BitVec.(getMsbD, msb)_(extractLsb', extractLsb), getMsbD_extractLsb'_eq_getLsbD.* #6795 adds theorems BitVec.(getElem_umod_of_lt, getElem_umod, getLsbD_umod, getMsbD_umod). For the defiition of these theorems we\nrely on divRec, excluding the case where d=0#w, which is treated\nseparately because there is no infrastructure to reason about this case\nwithin divRec. In particular, our implementation follows the mathlib\nstandard where division by 0 yields\n0,\nwhile in SMTLIB this yields\nallOnes.* #6830 improves some files separation and standardize error messages in\nUV modules* #6850 adds some lemmas about the new tree map. These lemmas are about\nthe interactions of empty, isEmpty, insert, contains. Some\nlemmas about the interaction of contains with the others will follow\nin a later PR.* #6866 adds missing Hashable instances for PUnit and PEmpty.* #6914 introduces ordered map data structures, namely DTreeMap,\nTreeMap, TreeSet and their .Raw variants, into the standard\nlibrary. There are still some operations missing that the hash map has.\nAs of now, the operations are unverified, but the corresponding lemmas\nwill follow in subsequent PRs. While the tree map has already been\noptimized, more micro-optimization will follow as soon as the new code\ngenerator is ready.* #6922 adds LawfulBEq instances for Array and Vector.* #6948 completes the alignment of List/Array/Vectors lemmas for\ninsertIdx.* #6954 verifies the toListfunction for hash maps and dependent hash\nmaps.* #6958 improves the Promise API by considering how dropped promises\ncan lead to never-finished tasks.* #6966 adds an internal-use-only strict linter for the variable names\nof List/Array/Vector variables, and begins cleaning up.* #6982 improves some lemmas about monads and monadic operations on\nArray/Vector, using @Rob23oa's work in\nhttps://github.com/leanprover-community/batteries/pull/1109, and\nadding/generalizing some additional lemmas.* #7013 makes improvements to the simp set for List/Array/Vector/Option\nto improve confluence, in preparation for simp_lc.* #7017 renames the simp set boolToPropSimps to bool_to_prop and\nbv_toNat to bitvec_to_nat. I'll be adding more similarly named simp\nsets.* #7034 adds wf_preprocess theorems for\n{List,Array}.{foldlM,foldrM,mapM,filterMapM,flatMapM}* #7036 adds some deprecated function aliases to the tree map in order\nto ease the transition from the RBMap to the tree map.* #7046 renames UIntX.mk to UIntX.ofBitVec and adds deprecations.* #7048 adds the functions IntX.ofBitVec.* #7050 renames the functions UIntX.val to UIntX.toFin.* #7051 implements the methods insertMany, ofList, ofArray,\nfoldr and foldrM on the tree map.* #7056 adds the UIntX.ofFin conversion functions.* #7057 adds the function UIntX.ofNatLT. This is supposed to be a\nreplacement for UIntX.ofNatCore and UIntX.ofNat', but for\nbootstrapping reasons we need this function to exist in stage0 before we\ncan proceed with the renaming and deprecations, so this PR just adds the\nfunction.* #7059 moves away from using List.get / List.get? / List.get! and\nArray.get!, in favour of using the GetElem mediated getters. In\nparticular it deprecates List.get?, List.get! and Array.get?. Also\nadds Array.back, taking a proof, matching List.getLast.* #7062 introduces the functions UIntX.toIntX as the public API to\nobtain the IntX that is 2's complement equivalent to a given UIntX.* #7063 adds ISize.toInt8, ISize.toInt16, Int8.toISize,\nInt16.toISize.* #7064 renames BitVec.ofNatLt to BitVec.ofNatLT and sets up\ndeprecations for the old name.* #7066 renames IntX.toNat to IntX.toNatClampNeg (to reduce\nsurprises) and sets up a deprecation.* #7068 is a follow-up to #7057 and adds a builtin dsimproc for\nUIntX.ofNatLT which it turns out we need in stage0 before we can get\nthe deprecation of UIntX.ofNatCore in favor of UIntX.ofNatLT off the\nground.* #7070 implements the methods min, max, minKey, maxKey,\natIndex, getEntryLE, getKeyLE and consorts on the tree map.* #7071 unifies the existing functions UIntX.ofNatCore and\nUIntX.ofNat' under a new name, UIntX.ofNatLT.* #7079 introduces Fin.toNat as an alias for Fin.val. We add this\nfunction for discoverability and consistency reasons. The normal form\nfor proofs remains Fin.val, and there is a simp lemma rewriting\nFin.toNat to Fin.val.* #7080 adds the functions UIntX.ofNatTruncate (the version for\nUInt32 already exists).* #7081 adds functions IntX.ofIntLE, IntX.ofIntTruncate, which are\nanalogous to the unsigned counterparts UIntX.ofNatLT and\nUInt.ofNatTruncate.* #7083 adds (value-based, not bitfield-based) conversion functions\nbetween Float/Float32 and IntX/UIntX.* #7105 completes aligning Array/Vector.extract lemmas with the lemmas\nfor List.take and List.drop.* #7106 completes the alignment of List/Array/Vector.finRange lemmas.* #7109 implements the getThenInsertIfNew? and partition functions\non the tree map.* #7114 implements the methods values and valuesArray on the tree\nmap.* #7116 implements the getKey functions on the tree map. It also fixes\nthe naming of the entryAtIdx function on the tree set, which should\nhave been called atIdx.* #7118 implements the functions modify and alter on the tree map.* #7128 adds Repr and Hashable instances for IntX.* #7131 adds IntX.abs functions. These are specified by BitVec.abs,\nso they map IntX.minValue to IntX.minValue, similar to Rust's\ni8::abs. In the future we might also have versions which take values\nin UIntX and/or Nat.* #7137 verifies the various fold and for variants for hashmaps.* #7151 fixes a memory leak in IO.FS.createTempFile* #7158 strengthens Int.tdiv_eq_ediv, by dropping an unnecessary\nhypothesis, in preparation for further work on ediv/tdiv/fdiv\nlemmas.* #7161 adds all missing tree map lemmas about the interactions of the\nfunctions empty, isEmpty, contains, size, insert(IfNew) and\nerase.* #7162 splits Int.DivModLemmas into a Bootstrap and Lemmas file,\nwhere it is possible to use omega in Lemmas.* #7163 gives an unconditional theorem expressing Int.tdiv in terms of\nInt.ediv, not just for non-negative arguments.* #7165 provides tree map lemmas about the interaction of\ncontainsThenInsert(IfNew) with contains and insert(IfNew).* #7167 provides tree map lemmas for the interaction of get? with the\nother operations for which lemmas already exist.* #7174 adds the first batch of lemmas about iterated conversions\nbetween finite types starting with something of type UIntX.* #7199 adds theorems comparing Int.ediv with tdiv and fdiv, for\nall signs of arguments. (Previously we just had the statements about the\ncases in which they agree.)* #7201 adds Array/Vector.left/rightpad. These will not receive any\nverification theorems; simp just unfolds them to an ++ operation.* #7205 completes alignment of\nList.getLast/List.getLast!/List.getLast? lemmas with the\ncorresponding lemmas for Array and Vector.* #7206 adds theorem BitVec.toFin_abs, completing the API for\nBitVec.*_abs.* #7207 provides lemmas for the tree map functions get, get! and\ngetD in relation to the other operations for which lemmas already\nexist.* #7208 aligns lemmas for List.dropLast / Array.pop / Vector.pop.* #7210 adds the remaining lemmas about iterated conversions between\nfinite types starting with something of type UIntX.* #7214 adds a ForIn instance for the PersistentHashSet type.* #7221 provides lemmas about the tree map functions getKey?,\ngetKey, getKey!, getKeyD and insertIfNew and their interaction\nwith other functions for which lemmas already exist.* #7222 removes the simp attribute from ReflCmp.compare_self because\nit matches arbitrary function applications. Instead, a new simp lemma\nReflOrd.compare_self is introduced, which only matches applications of\ncompare.* #7229 provides lemmas for the tree map function getThenInsertIfNew?.* #7235 adds Array.replace and Vector.replace, proves the\ncorrespondences with List.replace, and reproduces the basic API. In\norder to do so, it fills in some gaps in the List.findX APIs.* #7237 provides proofs that the raw tree map operations are well-formed\nand refactors the file structure of the tree map, introducing new\nmodules Std.{DTreeMap,TreeMap,TreeSet}.Raw and splittting\nAdditionalOperations into separate files for bundled and raw types.* #7245 adds missing @[specialize] annotations to the alter and\nmodify functions in Std.Data.DHashMap.Internal.AssocList, which are\nused by the corresponding hash map functions.* #7249 completes alignment of theorems about\nList/Array/Vector.any/all.* #7255 fixes the definition of Min (Option α). This is a breaking\nchange. This treats none as the least element,\nso min none x = min x none = none for all x : Option α. Prior to\nnightly-2025-02-27, we instead had min none (some x) = min (some x) none = some x. Also adds basic lemmas relating min, max, ≤ and\n< on Option.* #7259 contains theorems about IntX that are required for bv_decide\nand the IntX simprocs.* #7260 provides lemmas about the tree map functions keys and toList\nand their interactions with other functions for which lemmas already\nexist. Moreover, a bug in foldr (calling foldlM instead of foldrM)\nis fixed.* #7266 begins the alignment of Int.ediv/fdiv/tdiv theorems.* #7268 implements Lean.ToExpr for finite signed integers.* #7271 changes the order of arguments of the folding function expected\nby the tree map's foldr and foldrM functions so that they are\nconsistent with the API of List.* #7273 fixes the statement of a UIntX conversion lemma.* #7277 fixes a bug in Float32.ofInt, which previously returned a\nFloat(64).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Library","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Library"}});