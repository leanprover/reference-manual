window.docContents[143].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Conversions":{"contents":"Checks whether the slice can be interpreted as the decimal representation of a natural number.A slice can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.Use toNat? or\ntoNat! to convert such a slice to a natural number.Examples:* \"\".toSlice.isNat = false* \"0\".toSlice.isNat = true* \"5\".toSlice.isNat = true* \"05\".toSlice.isNat = true* \"587\".toSlice.isNat = true* \"-587\".toSlice.isNat = false* \" 5\".toSlice.isNat = false* \"2+3\".toSlice.isNat = false* \"0xff\".toSlice.isNat = false\n\nInterprets a slice as the decimal representation of a natural number, returning it. Panics if the\nslice does not contain a decimal natural number.A slice can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.Use isNat to check whether toNat! would return a value. toNat? is a safer\nalternative that returns none instead of panicking when the string is not a natural number.Examples:* \"0\".toSlice.toNat! = 0* \"5\".toSlice.toNat! = 5* \"587\".toSlice.toNat! = 587\n\nInterprets a slice as the decimal representation of a natural number, returning it. Returns\nnone if the slice does not contain a decimal natural number.A slice can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.Use isNat to check whether toNat? would return some.\ntoNat! is an alternative that panics instead of\nreturning none when the slice is not a natural number.Examples:* \"\".toSlice.toNat? = none* \"0\".toSlice.toNat? = some 0* \"5\".toSlice.toNat? = some 5* \"587\".toSlice.toNat? = some 587* \"-587\".toSlice.toNat? = none* \" 5\".toSlice.toNat? = none* \"2+3\".toSlice.toNat? = none* \"0xff\".toSlice.toNat? = none\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.10. Conversions","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Conversions"},"/Notations-and-Macros/Defining-New-Syntax/#syntax-rules":{"contents":"Each syntax category is associated with a set of syntax rules, which correspond to productions in a context-free grammar.\nSyntax rules can be defined using the syntax command.\n\nSyntax Rules\n\nAs with operator and notation declarations, the contents of the documentation comments are shown to users while they interact with the new syntax.\nAttributes may be added to invoke compile-time metaprograms on the resulting definition.\n\nSyntax rules interact with section scopes in the same manner as attributes, operators, and notations.\nBy default, syntax rules are available to the parser in any module that transitively imports the one in which they are established, but they may be declared scoped or local to restrict their availability either to contexts in which the current namespace has been opened or to the current section scope, respectively.\n\nWhen multiple syntax rules for a category can match the current input, the local longest-match rule is used to select one of them.\nLike notations and operators, if there is a tie for the longest match then the declared priorities are used to determine which parse result applies.\nIf this still does not resolve the ambiguity, then all the results that tied are saved.\nThe elaborator is expected to attempt all of them, succeeding when exactly one can be elaborated.\n\nThe syntax rule's precedence, written immediately after the syntax keyword, restricts the parser to use this new syntax only when the precedence context is at least the provided value.\n\nJust as with operators and notations, syntax rules may be manually provided with a name; if they are not, an otherwise-unused name is generated.\nWhether provided or generated, this name is used as the syntax kind in the resulting node.\n\nThe body of a syntax declaration is even more flexible than that of a notation.\nString literals specify atoms to match.\nSubterms may be drawn from any syntax category, rather than just terms, and they may be optional or repeated, with or without interleaved comma separators.\nIdentifiers in syntax rules indicate syntax categories, rather than naming subterms as they do in notations.\n\nFinally, the syntax rule specifies which syntax category it extends.\nIt is an error to declare a syntax rule in a nonexistent category.\n\n\n\nSyntax SpecifiersThe syntactic category stx is the grammar of specifiers that may occur in the body of a syntax command.String literals are parsed as atoms (including both keywords such as if, #eval, or where):Leading and trailing spaces in the strings do not affect parsing, but they cause Lean to insert spaces in the corresponding position when displaying the syntax in proof states and error messages.\nOrdinarily, valid identifiers occurring as atoms in syntax rules become reserved keywords.\nPreceding a string literal with an ampersand (&) suppresses this behavior:Identifiers specify the syntactic category expected in a given position, and may optionally provide a precedence:The * modifier is the Kleene star, matching zero or more repetitions of the preceding syntax.\nIt can also be written using many.The + modifier matches one or more repetitions of the preceding syntax.\nIt can also be written using many1.The ? modifier makes a subterm optional, and matches zero or one, but not more, repetitions of the preceding syntax.\nIt can also be written as optional.The ,* modifier matches zero or more repetitions of the preceding syntax with interleaved commas.\nIt can also be written using sepBy.The ,+ modifier matches one or more repetitions of the preceding syntax with interleaved commas.\nIt can also be written using sepBy1.The ,*,? modifier matches zero or more repetitions of the preceding syntax with interleaved commas, allowing an optional trailing comma after the final repetition.\nIt can also be written using sepBy with the allowTrailingSep modifier.The ,+,? modifier matches one or more repetitions of the preceding syntax with interleaved commas, allowing an optional trailing comma after the final repetition.\nIt can also be written using sepBy1 with the allowTrailingSep modifier.The <|> operator, which can be written orelse, matches either syntax.\nHowever, if the first branch consumes any tokens, then it is committed to, and failures will not be backtracked:The ! operator matches the complement of its argument.\nIf its argument fails, then it succeeds, resetting the parsing state.Syntax specifiers may be grouped using parentheses.Repetitions may be defined using many and many1.\nThe latter requires at least one instance of the repeated syntax.Repetitions with separators may be defined using sepBy and sepBy1, which respectively match zero or more occurrences and one or more occurrences, separated by some other syntax.\nThey come in three varieties:* The two-parameter version uses the atom provided in the string literal to parse the separators, and does not allow trailing separators.* The three-parameter version uses the third parameter to parse the separators, using the atom for pretty-printing.* The four-parameter version optionally allows the separator to occur an extra time at the end of the sequence.\n    The fourth argument must always literally be the keyword allowTrailingSep.\n\nParsing Matched Parentheses and BracketsA language that consists of matched parentheses and brackets can be defined using syntax rules.\nThe first step is to declare a new syntax category:declare_syntax_cat balanced\nNext, rules can be added for parentheses and square brackets.\nTo rule out empty strings, the base cases consist of empty pairs.syntax \"(\" \")\" : balanced\nsyntax \"[\" \"]\" : balanced\nsyntax \"(\" balanced \")\" : balanced\nsyntax \"[\" balanced \"]\" : balanced\nsyntax balanced balanced : balanced\nIn order to invoke Lean's parser on these rules, there must also be an embedding from the new syntax category into one that may already be parsed:syntax (name := termBalanced) \"balanced \" balanced : term\nThese terms cannot be elaborated, but reaching an elaboration error indicates that parsing succeeded:/--\nerror: elaboration function for `termBalanced` has not been implemented\n  balanced ()\n-/\n#guard_msgs in\nexample := balanced ()\n\n/--\nerror: elaboration function for `termBalanced` has not been implemented\n  balanced []\n-/\n#guard_msgs in\nexample := balanced []\n\n/--\nerror: elaboration function for `termBalanced` has not been implemented\n  balanced [[]()([])]\n-/\n#guard_msgs in\nexample := balanced [[] () ([])]\nSimilarly, parsing fails when they are mismatched:example := balanced [() (]]\n<example>:1:25-1:26: unexpected token ']'; expected ')' or balanced\n\n\nParsing Comma-Separated RepetitionsA variant of list literals that requires double square brackets and allows a trailing comma can be added with the following syntax:syntax \"[[\" term,*,? \"]]\" : term\nAdding a macro that describes how to translate it into an ordinary list literal allows it to be used in tests.macro_rules\n  | `(term|[[$e:term,*]]) => `([$e,*])\n#eval [[\"Dandelion\", \"Thistle\",]]\n[\"Dandelion\", \"Thistle\"]\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.11. Syntax Rules","id":"/Notations-and-Macros/Defining-New-Syntax/#syntax-rules"},"/Notations-and-Macros/Extending-Lean___s-Output/#Unexpanders":{"contents":"Just as macros are registered in a table that maps syntax kinds to macro implementations, unexpanders are registered in a table that maps the names of constants to unexpander implementations.\nBefore Lean displays syntax to users, it attempts to rewrite each application of a constant in the syntax according to this table.\nOccurrences of the context that are not applications are treated as applications with zero arguments.\n\nUnexpansion proceeds from the inside out.\nThe unexpander is passed the syntax of the application, with implicit arguments hidden, after the arguments have been unexpanded.\nIf the option pp.explicit is true or pp.notation is false, then unexpanders are not used.\n\nAn unexpander has type Lean.PrettyPrinter.Unexpander, which is an abbreviation for Syntax ‚Üí Lean.PrettyPrinter.UnexpandM Syntax.\nIn the remainder of this section, the names Unexpander and UnexpandM are used unqualified.\nUnexpandM is a monad that supports quotation and failure via its MonadQuotation and MonadExcept Unit instances.An unexpander should either return unexpanded syntax or fail using throw ().\nIf the unexpander succeeds, then the resulting syntax is unexpanded again; if it fails, then the next unexpander is tried.\nWhen no unexpander succeeds for the syntax, its child nodes are unexpanded until all opportunities for unexpansion are exhausted.Function that tries to reverse macro expansions as a post-processing step of delaboration.\nWhile less general than an arbitrary delaborator, it can be declared without importing Lean.\nUsed by the [app_unexpander] attribute.The unexpander monad, essentially Syntax ‚Üí Option Œ±. The Syntax is the ref,\nand it has the possibility of failure without an error message.An unexpander for a constant is registered by applying the app_unexpander attribute.\nCustom operators and notations automatically create unexpanders for the syntax that they introduce.Unexpander RegistrationRegisters an unexpander of type Unexpander for applications of a constant.Custom Unit TypeA type equivalent to Unit, but with its own notation, can be defined as a zero-field structure and a macro:structure Solo where\n  mk ::\n\nsyntax \"‚Äπ\" \"‚Ä∫\" : term\n\nmacro_rules\n  | `(term|‚Äπ‚Ä∫) => ``(Solo.mk)\nWhile the new notation can be used to write theorem statements, it does not appear in proof states.\nFor example, when proving that all values of type Solo are equal to ‚Äπ‚Ä∫, the initial proof state is:v : Solo\n‚ä¢ v = { }This proof state shows the constructor using structure instance syntax.\nAn unexpander can be used to override this choice.\nBecause Solo.mk cannot be applied to any arguments, the unexpander is free to ignore the syntax, which will always be `(Solo.mk).@[app_unexpander Solo.mk]\ndef unexpandSolo : Lean.PrettyPrinter.Unexpander\n  | _ => `(‚Äπ‚Ä∫)\nWith this unexpander, the initial state of the proof now renders with the correct syntax:v : Solo\n‚ä¢ v = ‚Äπ‚Ä∫Unexpansion and ArgumentsA ListCursor represents a position in a List.\nListCursor.before contains the reversed list of elements prior to the position, and ListCursor.after contains the elements after the position.structure ListCursor (Œ±) where\n  before : List Œ±\n  after : List Œ±\nderiving Repr\nList cursors can be moved to the left or to the right:def ListCursor.left : ListCursor Œ± ‚Üí Option (ListCursor Œ±)\n  | ‚ü®[], _‚ü© => none\n  | ‚ü®l :: ls, rs‚ü© => some ‚ü®ls, l :: rs‚ü©\n\ndef ListCursor.right : ListCursor Œ± ‚Üí Option (ListCursor Œ±)\n  | ‚ü®_, []‚ü© => none\n  | ‚ü®ls, r :: rs‚ü© => some ‚ü®r :: ls, rs‚ü©\nThey can also be moved all the way to the left or all the way to the right:def ListCursor.rewind : ListCursor Œ± ‚Üí ListCursor Œ±\n  | xs@‚ü®[], _‚ü© => xs\n  | ‚ü®l :: ls, rs‚ü© => rewind ‚ü®ls, l :: rs‚ü©\ntermination_by xs => xs.before\n\ndef ListCursor.fastForward : ListCursor Œ± ‚Üí ListCursor Œ±\n  | xs@‚ü®_, []‚ü© => xs\n  | ‚ü®ls, r :: rs‚ü© => fastForward ‚ü®r :: ls, rs‚ü©\ntermination_by xs => xs.after\nHowever, the need to reverse the list of previous elements can make list cursors difficult to understand.\nA cursor can be given a notation in which a flag (üö©) marks the cursor's location in a list:syntax \"[\" term,* \" üö© \" term,* \"]\": term\nmacro_rules\n  | `([$ls,* üö© $rs,*]) =>\n    ``(ListCursor.mk [$[$((ls : Array Lean.Term).reverse)],*] [$rs,*])\nIn the macro, the sequences of elements have type Syntax.TSepArray `term \",\".\nThe type annotation as Array Lean.Term causes a coercion to fire so that Array.reverse can be applied, and a similar coercion reinserts the separating commas.\nThese coercions are described in the section on typed syntax.While the syntax works, it is not used in Lean's output:#check [1, 2, 3 üö© 4, 5]\n{ before := [3, 2, 1], after := [4, 5] } : ListCursor Nat\nAn unexpander solves this problem.\nThe unexpander relies on the built-in unexpanders for list literals already having rewritten the two lists:@[app_unexpander ListCursor.mk]\ndef unexpandListCursor : Lean.PrettyPrinter.Unexpander\n  | `($_ [$ls,*] [$rs,*]) =>\n    `([$((ls : Array Lean.Term).reverse),* üö© $(rs),*])\n  | _ => throw ()\n#check [1, 2, 3 üö© 4, 5]\n[1, 2, 3 üö© 4, 5] : ListCursor Nat\n#reduce [1, 2, 3 üö© 4, 5].right\nsome [1, 2, 3, 4 üö© 5]\n#reduce [1, 2, 3 üö© 4, 5].left >>= (¬∑.left)\nsome [1 üö© 2, 3, 4, 5]\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Extending Lean's Output","header":"20.7.1. Unexpanders","id":"/Notations-and-Macros/Extending-Lean___s-Output/#Unexpanders"},"/Run-Time-Code/Reference-Counting/#reference-counting":{"contents":"Lean uses reference counting for memory management.\nEach allocated object maintains a count of how many other objects refer to it.\nWhen a new reference is added, the count is incremented, and when a reference is dropped, the count is decremented.\nWhen a reference count reaches zero, the object is no longer reachable and can play no part in the further execution of the program.\nIt is deallocated and all of its references to other objects are dropped, which may trigger further deallocations.\n\nReference counting provides a number of benefits: Re-Use of Memory\n\nIf an object's reference count drops to zero just as another of the same size is to be allocated, then the original object's memory can be safely re-used for the new object.\n    As a result, many common data-structure traversals (such as List.map) do not need to allocate memory when there is exactly one reference to the data structure to be traversed.\n\n Opportunistic In-Place Updates\n\nPrimitive types, such as strings and arrays, may provide operations that copy shared data but modify unshared data in-place.\n    As long as they hold the only reference to the value being modified, many operations on these primitive types will modify it rather than copy it.\n    This can lead to substantial performance benefits.\n    Carefully-written Array code avoids the performance overhead of immutable data structures while maintaining the ease of reasoning provided by pure functions.\n\n Predictability\n\nReference counts are decremented at predictable times.\n    As a result, reference-counted objects can be used to manage other resources, such as file handles.\n    In Lean, a Handle does not need to be explicitly closed because it is closed immediately when it is no longer accessible.\n\n Simpler FFI\n\nObjects managed with reference counting don't need to be relocated as part of reclaiming unused memory.\n    This greatly simplifies interaction with code written in other languages, such as C.\n\n\n\nThe traditional drawbacks of reference counting include the performance overhead due to updating reference counts along with the inability to recognize and deallocate cyclic data.\nThe former drawback is minimized by an analysis based on borrowing that allows many reference count updates to be elided.\nNevertheless, multi-threaded code requires that reference count updates are synchronized between threads, which also imposes a substantial overhead.\nTo reduce this overhead, Lean values are partitioned into those which are reachable from multiple threads and those which are not.\nSingle-threaded reference counts can be updated much faster than multi-threaded reference counts, and many values are accessed only on a single thread.\nTogether, these techniques greatly reduce the performance overhead of reference counting.\nBecause the verifiable fragment of Lean cannot create cyclic data, the Lean runtime does not have a technique to detect it.\n provide more details on the implementation of reference counting in Lean.\n\n\n\n\n\n","context":"Lean Reference\u0009Run-Time Code","header":"21.2. Reference Counting","id":"/Run-Time-Code/Reference-Counting/#reference-counting"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-run-time":{"contents":"Mutual inductive types are represented identically to non-mutual inductive types in compiled code and in the runtime.\nThe restrictions on mutual inductive types exist to ensure Lean's consistency as a logic, and do not impact compiled code.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","header":"4.4.5.3. Run-Time Representation","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-run-time"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Breaking-Changes":{"contents":"* #7474 updates rw?, show_term, and other tactic-suggesting tactics\nto suggest expose_names when necessary and validate tactics prior to\nsuggesting them, as exact? already did, and it also ensures all such\ntactics produce hover info in the messages showing tactic suggestions.This introduces a breaking change in the TryThis API: the type? parameter\nof addRewriteSuggestion is now an LOption, not an Option, to obviate the need\nfor a hack we previously used to indicate that a rewrite closed the goal.* #7789 fixes lean potentially changing or interpreting arguments\nafter --run.Breaking change: The Lean file to run must now be passed directly\nafter --run, which accidentally was not enforced before.* #7813 fixes an issue where let n : Nat := sorry in the Infoview\npretty prints as n : ‚Ñï := sorry `¬´Foo:17:17¬ª. This was caused by\ntop-level expressions being pretty printed with the same rules as\nInfoview hovers. Closes #6715. Refactors Lean.Widget.ppExprTagged; now\nit takes a delaborator, and downstream users should configure their own\npretty printer option overrides if necessary if they used the explicit\nargument (see Lean.Widget.makePopup.ppExprForPopup for an example).\nBreaking change: ppExprTagged does not set pp.proofs on the root\nexpression.* #7855 moves ReflBEq to Init.Core and changes LawfulBEq to extend\nReflBEq.Breaking changes:* The refl field of ReflBEq has been renamed to rfl to match\nLawfulBEq* LawfulBEq extends ReflBEq, so in particular LawfulBEq.rfl is no\nlonger valid* #7873 fixes a number of bugs related to the handling of the source\nsearch path in the language server, where deleting files could cause\nseveral features to stop functioning and both untitled files and files\nthat don't exist on disc could have conflicting module names.See the PR description for the details on changes in URI <-> module name conversion.Breaking changes:* Server.documentUriFromModule has been renamed to\nServer.documentUriFromModule? and doesn't take a SearchPath argument\nanymore, as the SearchPath is now computed from the LEAN_SRC_PATH\nenvironment variable. It has also been moved from Lean.Server.GoTo to\nLean.Server.Utils.* Server.moduleFromDocumentUri does not take a SearchPath argument\nanymore and won't return an Option anymore. It has also been moved\nfrom Lean.Server.GoTo to Lean.Server.Utils.* The System.SearchPath.searchModuleNameOfUri function has been\nremoved. It is recommended to use Server.moduleFromDocumentUri\ninstead.* The initSrcSearchPath function has been renamed to\ngetSrcSearchPath and has been moved from Lean.Util.Paths to\nLean.Util.Path. It also doesn't need to take a pkgSearchPath\nargument anymore.* #7967 adds a bootstrap option to Lake which is used to identify the\ncore Lean package. This enables Lake to use the current stage's include\ndirectory rather than the Lean toolchains when compiling Lean with Lean\nin core.Breaking change: The Lean library directory is no longer part of\ngetLeanLinkSharedFlags. FFI users should provide this option\nseparately when linking to Lean (e.g.. via s!\"-L{(‚ÜêgetLeanLibDir).toString}\").\nSee the FFI example for a demonstration.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)\u0009Highlights","header":"Breaking Changes","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Highlights--Breaking-Changes"}});