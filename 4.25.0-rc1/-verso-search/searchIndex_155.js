window.docContents[155].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From--Int":{"contents":"Converts a word-sized signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts an 8-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 16-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 32-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 64-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts an arbitrary-precision integer to a word-sized signed integer, wrapping around on over- or\nunderflow.This function is overridden at runtime with an efficient implementation.\n\nConverts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int8.ofInt 48 = 48* Int8.ofInt (-115) = -115* Int8.ofInt (-129) = 127* Int8.ofInt (128) = -128\n\nConverts an arbitrary-precision integer to a 16-bit signed integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int16.ofInt 48 = 48* Int16.ofInt (-129) = -129* Int16.ofInt (128) = 128* Int16.ofInt 70000 = 4464* Int16.ofInt (-40000) = 25536\n\nConverts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int32.ofInt 48 = 48* Int32.ofInt (-129) = -129* Int32.ofInt 70000 = 70000* Int32.ofInt (-40000) = -40000* Int32.ofInt 2147483648 = -2147483648* Int32.ofInt (-2147483649) = 2147483647\n\nConverts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int64.ofInt 48 = 48* Int64.ofInt (-40_000) = -40_000* Int64.ofInt 2_147_483_648 = 2_147_483_648* Int64.ofInt (-2_147_483_649) = -2_147_483_649* Int64.ofInt 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808* Int64.ofInt (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807\n\nConstructs an ISize from an Int, clamping if the value is too small or too large.\n\nConstructs an Int8 from an Int, clamping if the value is too small or too large.\n\nConstructs an Int16 from an Int, clamping if the value is too small or too large.\n\nConstructs an Int32 from an Int, clamping if the value is too small or too large.\n\nConstructs an Int64 from an Int, clamping if the value is too small or too large.\n\nConstructs an ISize from an Int that is known to be in bounds.\n\nConstructs an Int8 from an Int that is known to be in bounds.\n\nConstructs an Int16 from an Int that is known to be in bounds.\n\nConstructs an Int32 from an Int that is known to be in bounds.\n\nConstructs an Int64 from an Int that is known to be in bounds.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","header":"19.4.4.3.1. To and From  Int","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From--Int"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering":{"contents":"Returns the list of elements in l for which p returns true.O(|l|).Examples:* [1, 2, 5, 2, 7, 7].filter (· > 2) = [5, 7, 7]* [1, 2, 5, 2, 7, 7].filter (fun _ => false) = []* [1, 2, 5, 2, 7, 7].filter (fun _ => true) = [1, 2, 5, 2, 7, 7]\n\nReturns the list of elements in l for which p returns true.O(|l|). This is a tail-recursive version of List.filter, used at runtime.Examples:* [1, 2, 5, 2, 7, 7].filterTR (· > 2)  = [5, 7, 7]* [1, 2, 5, 2, 7, 7].filterTR (fun _ => false) = []* [1, 2, 5, 2, 7, 7].filterTR (fun _ => true) = * [1, 2, 5, 2, 7, 7]\n\nApplies the monadic predicate p to every element in the list, in order from left to right, and\nreturns the list of elements for which p returns true.O(|l|).Example:#eval [1, 2, 5, 2, 7, 7].filterM fun x => do\n  IO.println s!\"Checking {x}\"\n  return x < 3\nChecking 1\nChecking 2\nChecking 5\nChecking 2\nChecking 7\nChecking 7\n[1, 2, 2]\n\n\nApplies the monadic predicate p on every element in the list in reverse order, from right to left,\nand returns those elements for which p returns true. The elements of the returned list are in\nthe same order as in the input list.Example:#eval [1, 2, 5, 2, 7, 7].filterRevM fun x => do\n  IO.println s!\"Checking {x}\"\n  return x < 3\nChecking 7\nChecking 7\nChecking 2\nChecking 5\nChecking 2\nChecking 1\n[1, 2, 2]\n\n\nApplies a function that returns an Option to each element of a list, collecting the non-none\nvalues.O(|l|).Example:#eval [1, 2, 5, 2, 7, 7].filterMap fun x =>\n  if x > 2 then some (2 * x) else none\n[10, 14, 14]\n\n\nApplies a function that returns an Option to each element of a list, collecting the non-none\nvalues.O(|l|). This is a tail-recursive version of List.filterMap, used at runtime.Example:#eval [1, 2, 5, 2, 7, 7].filterMapTR fun x =>\n  if x > 2 then some (2 * x) else none\n[10, 14, 14]\n\n\nApplies a monadic function that returns an Option to each element of a list, collecting the\nnon-none values.O(|l|).Example:#eval [1, 2, 5, 2, 7, 7].filterMapM fun x => do\n  IO.println s!\"Examining {x}\"\n  if x > 2 then return some (2 * x)\n  else return none\nExamining 1\nExamining 2\nExamining 5\nExamining 2\nExamining 7\nExamining 7\n[10, 14, 14]\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.12. Filtering","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering"},"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts":{"contents":"\n\nMonad lifting is not always sufficient to combine monads.\nMany operations provided by monads are higher order, taking an action in the same monad as a parameter.\nEven if these operations are lifted to some more powerful monad, their arguments are still restricted to the original monad.\n\nThere are two type classes that support this kind of “reverse lifting”: MonadFunctor and MonadControl.\nAn instance of MonadFunctor m n explains how to interpret a fully-polymorphic function in m into n.\nThis polymorphic function must work for all types α: it has type {α : Type u} → m α → m α.\nSuch a function can be thought of as one that may have effects, but can't do so based on specific values that are provided.\nAn instance of MonadControl m n explains how to interpret an arbitrary action from m into n, while at the same time providing a “reverse interpreter” that allows the m action to run n actions.\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Lifting Monads","header":"14.2.1. Reversing Lifts","id":"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts"},"/The--grind--tactic/#grind-tactic":{"contents":"\n\nThe grind tactic uses techniques inspired by modern SMT solvers to automatically construct proofs.\nIt produces proofs by incrementally collecting sets of facts, deriving new facts from the existing ones using a set of cooperating techniques.\nBehind the scenes, all proofs are by contradiction, so there is no operational distinction between the expected conclusion and the premises; grind always attempts to derive a contradiction.\n\nPicture a virtual whiteboard.\nEvery time grind discovers a new equality, inequality, or Boolean literal it writes that fact on the board, merges equivalent terms into buckets, and invites each engine to read from—and add back to—the shared whiteboard.\nIn particular, because all true propositions are equal to True and all false propositions are equal to False, grind tracks a set of known facts as part of tracking equivalence classes.\n\nThe cooperating engines are:* congruence closure,* constraint propagation,* E‑matching,* guided case analysis, and* a suite of satellite theory solvers, including both linear integer arithmetic and commutative rings.Like other tactics, grind produces ordinary Lean proof terms for every fact it adds.\nLean’s standard library is already annotated with @[grind] attributes, so common lemmas are discovered automatically.\n\ngrind is not designed for goals whose search space explodes combinatorially—think large‑n pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards, or a 200‑variable Sudoku encoded as Boolean constraints.\nSuch encodings require thousands (or millions) of case‑splits that overwhelm grind’s branching search.\nFor bit‑level or pure Boolean combinatorial problems, use bv_decide.  The bv_decide tactic calls a state‑of‑the‑art SAT solver (e.g. CaDiCaL or Kissat) and then returns a compact, machine‑checkable certificate.\nAll heavy search happens outside Lean; the certificate is replayed and verified inside Lean, so trust is preserved (verification time scales with certificate size).\n\n\n\nCongruence ClosureThis proof succeeds instantly using congruence closure, which discovers sets of equal terms.example (a b c : Nat) (h₁ : a = b) (h₂ : b = c) :\n    a = c := by\n  grind\n\n\nAlgebraic ReasoningThis proof uses grind's commutative ring solver.example [CommRing α] [NoNatZeroDivisors α] (a b c : α) :\n    a + b + c = 3 →\n    a ^ 2 + b ^ 2 + c ^ 2 = 5 →\n    a ^ 3 + b ^ 3 + c ^ 3 = 7 →\n    a ^ 4 + b ^ 4 = 9 - c ^ 4 := by\n  grind\n\n\nFinite-Field ReasoningArithmetic operations on Fin overflow, wrapping around to 0 when the result would be outside the bound.\ngrind can use this fact to prove theorems such as this:example (x y : Fin 11) :\n    x ^ 2 * y = 1 →\n    x * y ^ 2 = y →\n    y * x = 1 := by\n  grind\n\n\nLinear Integer Arithmetic with Case Analysisexample (x y : Int) :\n    27 ≤ 11 * x + 13 * y →\n    11 * x + 13 * y ≤ 45 →\n    -10 ≤ 7 * x - 9 * y →\n    7 * x - 9 * y ≤ 4 →\n    False := by\n  grind\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"17. The  grind  tactic","id":"/The--grind--tactic/#grind-tactic"},"/The--grind--tactic/E___matching/#e-matching":{"contents":"E-matching is procedure for efficiently instantiating quantified theorem statements with ground terms that is widely employed in SMT solvers, used by grind to instantiate theorems efficiently.\nIt is especially effective when combined with congruence closure, enabling grind to discover non-obvious consequences of equalities and annotated theorems automatically.\n\nE-matching adds new facts to the metaphorical whiteboard, based on an index of theorems.\nWhen the whiteboard contains terms that match the index, the E-matching engine instantiates the corresponding theorems, and the resulting terms can feed further rounds of congruence closure, constraint propagation, and theory-specific solvers.\nEach fact added to the whiteboard by E-matching is referred to as an instance.\nAnnotating theorems for E-matching, thus adding them to the index, is essential for enabling grind to make effective use of a library.\n\nIn addition to user-specified theorems, grind uses automatically generated equations for match-expressions as E-matching theorems.\nBehind the scenes, the elaborator generates auxiliary functions that implement pattern matches, along with equational theorems that specify their behavior.\nUsing these equations with E-matching enables grind to reduce these instances of pattern matching.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.6. E‑matching","id":"/The--grind--tactic/E___matching/#e-matching"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Server":{"contents":"* #7665 and #8180 add\nsupport for code actions that resolve 'Unknown identifier' errors by either importing the missing declaration or by\nchanging the identifier to one from the environment.* #8091 improves the performance of the workspace symbol request.* #8242 fixes the 'goals accomplished' diagnostics. They were\naccidentally broken in #7902.* #8350 changes namespace completion to use the same algorithm as\ndeclaration identifier completion, which makes it use the short name\n(last name component) for completions instead of the full name, avoiding\nnamespace duplications.* #8362 fixes a bug where the Unknown identifier code actions wouldn't\nwork correctly for some Unknown identifier error spans and adjusts\nseveral Unknown identifier spans to actually end on the identifier in\nquestion.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Server","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Server"}});