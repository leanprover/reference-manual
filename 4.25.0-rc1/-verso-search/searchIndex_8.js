window.docContents[8].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Creation":{"contents":"Creates a new empty tree map. It is also possible and recommended to\nuse the empty collection notations ∅ and {} to create an empty tree map. simp replaces\nempty with ∅.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","header":"19.18.9.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Creation"},"/Interacting-with-Lean/#hash-eval":{"contents":"The #eval command is used to run code as a program.\nIn particular, it is capable of executing IO actions, it uses a call-by-value evaluation strategy, partial functions are executed, and both types and proofs are erased.\nUse #reduce to instead reduce terms using the reduction rules that are part of definitional equality.\n\nEvaluating Terms#eval e evaluates the expression e by compiling and evaluating it.* The command attempts to use ToExpr, Repr, or ToString instances to print the result.* If e is a monadic value of type m ty, then the command tries to adapt the monad m\nto one of the monads that #eval supports, which include IO, CoreM, MetaM, TermElabM, and CommandElabM.\nUsers can define MonadEval instances to extend the list of supported monads.The #eval command gracefully degrades in capability depending on what is imported.\nImporting the Lean.Elab.Command module provides full capabilities.Due to unsoundness, #eval refuses to evaluate expressions that depend on sorry, even indirectly,\nsince the presence of sorry can lead to runtime instability and crashes.\nThis check can be overridden with the #eval! e command.Options:* If eval.pp is true (default: true) then tries to use ToExpr instances to make use of the\nusual pretty printer. Otherwise, only tries using Repr and ToString instances.* If eval.type is true (default: false) then pretty prints the type of the evaluated value.* If eval.derive.repr is true (default: true) then attempts to auto-derive a Repr instance\nwhen there is no other way to print the result.See also: #reduce e for evaluation by term reduction.\n\n#eval always elaborates and compiles the provided term.\nIt then checks whether the term transitively depends on any uses of sorry, in which case evaluation is terminated unless the command was invoked as #eval!.\nThis is because compiled code may rely on compile-time invariants (such as array lookups being in-bounds) that are ensured by proofs of suitable statements, and running code that contains incomplete proofs (or uses of sorry that “prove” incorrect statements) can cause Lean itself to crash.\n\n\n\nThe way the code is run depends on its type:* If the type is in the IO monad, then it is executed in a context where standard output and standard error are captured and redirected to the Lean message log.\n   If the returned value's type is not Unit, then it is displayed as if it were the result of a non-monadic expression.* If the type is in one of the internal Lean metaprogramming monads (CommandElabM, TermElabM, MetaM, or CoreM), then it is run in the current context.\n    For example, the environment will contain the definitions that are in scope where #eval is invoked.\n    As with IO, the resulting value is displayed as if it were the result of a non-monadic expression.\n    When Lean is running under Lake, its working directory (and thus the working directory for IO actions) is the current workspace.* If the type is in some other monad m, and there is a MonadLiftT m CommandElabM or MonadEvalT m CommandElabM instance, then MonadLiftT.monadLift or MonadEvalT.monadEval is used to transform the monad into one that may be run with #eval, after which it is run as usual.* If the term's type is not in any of the supported monads, then it is treated as a pure value.\n  The compiled code is run, and the result is displayed.Auxiliary definitions or other environment modifications that result from elaborating the term in #eval are discarded.\nIf the term is an action in a metaprogramming monad, then changes made to the environment by running the monadic action are preserved.\n\n\n\nResults are displayed using a ToExpr, ToString, or Repr instance, if they exist.\nIf not, and eval.derive.repr is true, Lean attempts to derive a suitable Repr instance.\nIt is an error if no suitable instance can be found or derived.\nSetting eval.pp to false disables the use of ToExpr instances by #eval.\n\nDisplaying Output#eval cannot display functions:#eval fun x => x + 1\ncould not synthesize a `ToExpr`, `Repr`, or `ToString` instance for type\n  Nat → Nat\nIt is capable of deriving instances to display output that has no ToString or Repr instance:inductive Quadrant where\n  | nw | sw | se | ne\n\n#eval Quadrant.nw\nQuadrant.nw\nThe derived instance is not saved.\nDisabling eval.derive.repr causes #eval to fail:set_option eval.derive.repr false\n#eval Quadrant.nw\ncould not synthesize a `ToExpr`, `Repr`, or `ToString` instance for type\n  Quadrant\n\n\n('#eval' command) enables using 'ToExpr' instances to pretty print the result, otherwise uses 'Repr' or 'ToString' instances\n\n('#eval' command) enables pretty printing the type of the result\n\n('#eval' command) enables auto-deriving 'Repr' instances as a fallback\n\nMonads can be given the ability to execute in #eval by defining a suitable MonadLiftMonadLift is described in the section on lifting monads. or MonadEval instance.\nJust as MonadLiftT is the transitive closure of MonadLift instances, MonadEvalT is the transitive closure of MonadEval instances.\nAs with MonadLiftT users should not define additional instances of MonadEvalT directly.\n\nTypeclass used for adapting monads. This is similar to MonadLift, but instances are allowed to\nmake use of default state for the purpose of synthesizing such an instance, if necessary.\nEvery MonadLift instance gives a MonadEval instance.The purpose of this class is for the #eval command,\nwhich looks for a MonadEval m CommandElabM or MonadEval m IO instance.Evaluates a value from monad m into monad n.\n\nThe transitive closure of MonadEval.Evaluates a value from monad m into monad n.\n\n","context":"Lean Reference\u0009Interacting with Lean","header":"3.1. Evaluating Terms","id":"/Interacting-with-Lean/#hash-eval"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-change":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.4. Changing the Goal","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-change"},"/The-Type-System/Inductive-Types/#well-formed-inductives":{"contents":"Inductive type declarations are subject to a number of well-formedness requirements.\nThese requirements ensure that Lean remains consistent as a logic when it is extended with the inductive type's new rules.\nThey are conservative: there exist potential inductive types that do not undermine consistency, but that these requirements nonetheless reject.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model","header":"4.4.3.2. Well-Formedness Requirements","id":"/The-Type-System/Inductive-Types/#well-formed-inductives"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Boolean-Equality-Tests":{"contents":"The Boolean equality operator == is overloaded by defining instances of BEq.\nThe companion class Hashable specifies a hashing procedure for a type.\nWhen a type has both BEq and Hashable instances, then the hashes computed should respect the BEq instance: two values equated by BEq.beq should always have the same hash.\n\nBEq α is a typeclass for supplying a boolean-valued equality relation on\nα, notated as a == b. Unlike DecidableEq α (which uses a = b), this\nis Bool valued instead of Prop valued, and it also does not have any\naxioms like being reflexive or agreeing with =. It is mainly intended for\nprogramming applications. See LawfulBEq for a version that requires that\n== and = coincide.Typically we prefer to put the \"more variable\" term on the left,\nand the \"more constant\" term on the right.Boolean equality, notated as a == b.Conventions for notations in identifiers:* The recommended spelling of == in identifiers is beq.\n\nTypes that can be hashed into a UInt64.Hashes a value into a UInt64.\n\nAn opaque hash mixing operation, used to implement hashing for products.\n\nA Boolean equality test coincides with propositional equality.In other words:* a == b implies a = b.* a == a is true.If a == b evaluates to true, then a and b are equal in the logic.\n\nReflBEq α says that the BEq implementation is reflexive.== is reflexive, that is, (a == a) = true.\n\nEquivBEq says that the BEq implementation is an equivalence relation.\n\nThe BEq α and Hashable α instances on α are compatible. This means that that a == b implies\nhash a = hash b.This is automatic if the BEq instance is lawful.If a == b, then hash a = hash b.\n\nA lawful hash function respects its Boolean equality test.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.1. Boolean Equality Tests","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Boolean-Equality-Tests"}});