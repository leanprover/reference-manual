window.docContents[174].resolve({"/Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation":{"contents":"Roughly speaking, Lean's processing of a source file can be divided into the following stages:\n\n Parsing\n\nThe parser transforms sequences of characters into syntax trees of type Syntax.\n  Lean's parser is extensible, so the Syntax type is very general.\n\n Macro Expansion\n\nMacros are transformations that replace syntactic sugar with more basic syntax.\n  Both the input and output of macro expansion have type Syntax.\n\n Elaboration\n\nElaboration is the process of transforming Lean's user-facing syntax into its core type theory.\n  This core theory is much simpler, enabling the trusted kernel to be very small.\n  Elaboration additionally produces metadata, such as proof states or the types of expressions, used for Lean's interactive features, storing them in a side table.\n\n Kernel Checking\n\nLean's trusted kernel checks the output of the elaborator to ensure that it follows the rules of the type theory.\n\n Compilation\n\nThe compiler transforms elaborated Lean code into executables that can be run.\n\n\n\nThe Lean Pipeline \n\nIn reality, the stages described above do not strictly occur one after the other.\nLean parses a single command (top-level declaration), elaborates it, and performs any necessary kernel checks.\nMacro expansion is part of elaboration; before translating a piece of syntax, the elaborator first expands any macros present at the outermost layer.\nMacro syntax may remain at deeper layers, but it will be expanded when the elaborator reaches those layers.\nThere are multiple kinds of elaboration: command elaboration implements the effects of each top-level command (e.g. declaring inductive types, saving definitions, evaluating expressions), while term elaboration is responsible for constructing the terms that occur in many commands (e.g. types in signatures, the right-hand sides of definitions, or expressions to be evaluated).\nTactic execution is a specialization of term elaboration.\n\nWhen a command is elaborated, the state of Lean changes.\nNew definitions or types may have been saved for future use, the syntax may be extended, or the set of names that can be referred to without explicit qualification may have changed.\nThe next command is parsed and elaborated in this updated state, and itself updates the state for subsequent commands.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"2. Elaboration and Compilation","id":"/Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation"},"/The-Type-System/Quotients/#equivalence-relations":{"contents":"An equivalence relation is a relation that is reflexive, symmetric, and transitive.\n\nEquivalence RelationsEquivalence according to some canonical equivalence relation for a type is written using ≈, which is overloaded using the type class HasEquiv.\n\nHasEquiv α is the typeclass which supports the notation x ≈ y where x y : α.x ≈ y says that x and y are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent.Conventions for notations in identifiers:* The recommended spelling of ≈ in identifiers is equiv.\n\n\n\nThe fact that a relation r is actually an equivalence relation is stated Equivalence r.\n\nAn equivalence relation r : α → α → Prop is a relation that is* reflexive: r x x,* symmetric: r x y implies r y x, and* transitive: r x y and r y z implies r x z.Equality is an equivalence relation, and equivalence relations share many of the properties of\nequality.An equivalence relation is reflexive: r x xAn equivalence relation is symmetric: r x y implies r y xAn equivalence relation is transitive: r x y and r y z implies r x z\n\n\n\nEvery Setoid instance leads to a corresponding HasEquiv instance.\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Quotients","header":"4.5.3. Equivalence Relations","id":"/The-Type-System/Quotients/#equivalence-relations"}});