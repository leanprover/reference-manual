window.docContents[229].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","header":"19.4.4. API Reference","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.\nIf the returned Bool is true, then the returned map is unaltered. If the Bool is false,\nthen the returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nErases multiple mappings from the tree map by iterating over the given collection and calling\nerase.\n\nRemoves all mappings of the map for which the given function returns false.\n\nUpdates the values of the map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.Uses the LawfulEqCmp instance to cast the retrieved value to the correct type.\n\nInserts multiple mappings into the tree map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for TreeMap, DTreeMap, TreeMap.Raw and DTreeMap.Raw.\nThe insertMany function on TreeSet and TreeSet.Raw behaves differently: it will prefer the first\nappearance.\n\nInserts multiple elements into the tree map by iterating over the given collection and calling\ninsertIfNew. If the same key appears multiple times, the first occurrence takes precedence.\n\nReturns a map that contains all mappings of t₁ and t₂. In case that both maps contain the\nsame key k with respect to cmp, the provided function is used to determine the new value from\nthe respective values in t₁ and t₂.This function ensures that t₁ is used linearly. It also uses the individual values in t₁\nlinearly if the merge function uses the second argument (i.e. the first of type β a) linearly.\nHence, as long as t₁ is unshared, the performance characteristics follow the following imperative\ndescription: Iterate over all mappings in t₂, inserting them into t₁ if t₁ does not contain a\nconflicting mapping yet. If t₁ does contain a conflicting mapping, use the given merge function to\nmerge the mapping in t₂ into the mapping in t₁. Then return t₁.Hence, the runtime of this method scales logarithmically in the size of t₁ and linearly in the size of\nt₂ as long as t₁ is unshared.\n\nPartitions a tree map into two tree maps based on a predicate.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps","header":"19.18.8.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Modification"},"/Elaboration-and-Compilation/#initialization":{"contents":"Before starting up, the elaborator must be correctly initialized.\nLean itself contains initialization code that must be run in order to correctly construct the compiler's initial state; this code is run before loading any modules and before the elaborator is invoked.\nFurthermore, each dependency may itself contribute initialization code, e.g. to set up environment extensions.\nInternally, each environment extension is assigned a unique index into an array, and this array's size is equal to the number of registered environment extensions, so the number of extensions must be known in order to correctly allocate an environment.\n\nAfter running Lean's own builtin initializers, the module's header is parsed and the dependencies' .olean files are loaded into memory.\nA “pre-environment” is constructed that contains the union of the dependencies' environments.\nNext, all initialization code specified by the dependencies is executed in the interpreter.\nAt this point, the number of environment extensions is known, so the pre-environment can be reallocated into an environment structure with a correctly-sized extensions array.\n\nInitialization BlocksAn initialize block adds code to the module's initializers.\nThe contents of an initialize block are treated as the contents of a do block in the IO monad.Sometimes, initialization only needs to extend internal data structures by side effects.\nIn that case the contents are expected to have type IO Unit:Initialization may also be used to construct values that contain references to internal state, such as attributes that are backed by an environment extension.\nIn this form of initialize, initialization should return the specified type in the IO monad.\n\nCompiler-Internal InitializersLean's internals also define code that must run during initialization.\nHowever, because Lean is a bootstrapping compiler, special care must be taken with initializers defined as part of Lean itself, and Lean's own initializers must run prior to importing or loading any modules.\nThese initializers are specified using builtin_initialize, which should not be used outside the compiler's implementation.\n\n","context":"Lean Reference\u0009Elaboration and Compilation","header":"2.5. Initialization","id":"/Elaboration-and-Compilation/#initialization"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks":{"contents":"Pure tasks should typically be created with Task.spawn, as Task.pure is a task that's already been resolved with the provided value.\nImpure tasks are created by one of the asTask actions.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads","header":"15.11.1. Creating Tasks","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks"},"/Run-Time-Code/Multi-Threaded-Execution/#The-Lean-Language-Reference--Run-Time-Code--Multi-Threaded-Execution":{"contents":"Lean includes primitives for parallel and concurrent programs, described using tasks.\nThe Lean runtime system includes a task manager that assigns hardware resources to tasks.\nAlong with the API for defining tasks, this is described in detail in the section on multi-threaded programs.\n\n","context":"Lean Reference\u0009Run-Time Code","header":"21.3. Multi-Threaded Execution","id":"/Run-Time-Code/Multi-Threaded-Execution/#The-Lean-Language-Reference--Run-Time-Code--Multi-Threaded-Execution"},"/The--grind--tactic/Minimizing--grind--calls/#The-Lean-Language-Reference--The--grind--tactic--Minimizing--grind--calls":{"contents":"The grind only [...] tactic invokes grind with a limited set of theorems, which can improve performance.\nCalls to grind only can be conveniently constructed using grind?, which automatically records the theorems used by grind and suggests a suitable grind only.\n\nThese theorems will typically include a symbol prefix such as =, ←, or →, indicating the\npattern that triggered the instantiation. See the section on E-matching for details.\nSome theorems may be labelled with a usr prefix, which indicates that a custom pattern was used.\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.2. Minimizing  grind  calls","id":"/The--grind--tactic/Minimizing--grind--calls/#The-Lean-Language-Reference--The--grind--tactic--Minimizing--grind--calls"},"/The-Module-System/The--meta--Phase/#The-Lean-Language-Reference--The-Module-System--The--meta--Phase":{"contents":"When it comes to actual code execution, there is no point to a definition without a body.\nThus, in order to eagerly know what definitions might be executed at compile time and so need to be available including their bodies (in some executable shape), any definition used as an entry point to compile-time execution has to be tagged with the new meta modifier.\nThis is automatically done in built-in metaprogramming syntax such as syntax, macro, and elab but may need to be done explicitly when manually applying metaprogramming attributes such as @[app_delab].\n\nA meta definition may access (and thus invoke) any meta or non-meta definition of the current module.\nFor accessing imported definitions, the definition must either have been marked as meta when it was declared or the import must be marked as such (meta import when the accessing definition is in the private scope and public meta import otherwise).\n\nmodule\n\nmeta import Std.Data.HashMap\n\nlocal elab \"my_elab\" : command => do\n  let m : Std.HashMap := {}\n  ...\n\n\n","context":"Lean Reference\u0009The Module System","header":"The  meta  Phase","id":"/The-Module-System/The--meta--Phase/#The-Lean-Language-Reference--The-Module-System--The--meta--Phase"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Append":{"contents":"The notation typeclass for heterogeneous append.\nThis enables the notation a ++ b : γ where a : α, b : β.a ++ b is the result of concatenation of a and b, usually read \"append\".\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of ++ in identifiers is append.\n\nThe homogeneous version of HAppend: a ++ b : α where a b : α.a ++ b is the result of concatenation of a and b. See HAppend.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.8. Append","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Append"}});