window.docContents[246].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Characters":{"contents":"Returns the first character in s. If s is empty, returns (default : Char).Examples:* \"abc\".toSlice.front = 'a'* \"\".toSlice.front = (default : Char)\n\nReturns the first character in s. If s is empty, none.Examples:* \"abc\".toSlice.front? = some 'a'* \"\".toSlice.front? = none\n\nReturns the last character in s. If s is empty, returns (default : Char).Examples:* \"abc\".toSlice.back = 'c'* \"\".toSlice.back = (default : Char)\n\nReturns the last character in s. If s is empty, returns none.Examples:* \"abc\".toSlice.back? = some 'c'* \"\".toSlice.back? = none\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.4. Characters","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Characters"},"/Terms/Function-Application/#generalized-field-notation":{"contents":"The section on structure fields describes the notation for projecting a field from a term whose type is a structure.\nGeneralized field notation consists of a term followed by a dot (.) and an identifier, not separated by spaces.\n\nField Notation\n\nIf a term's type is a constant applied to zero or more arguments, then field notation can be used to apply a function to it, regardless of whether the term is a structure or type class instance that has fields.\nThe use of field notation to apply other functions is called generalized field notation.\n\nThe identifier after the dot is looked up in the namespace of the term's type, which is the constant's name.\nIf the type is not an application of a constant (e.g., a function, a metavariable, or a universe) then it doesn't have a namespace and generalized field notation cannot be used.\nIf the field is not found, but the constant can be unfolded to yield a further type which is a constant or application of a constant, then the process is repeated with the new constant.\n\nWhen a function is found, the term before the dot becomes an argument to the function.\nSpecifically, it becomes the first explicit argument that would not be a type error.\nAside from that, the application is elaborated as usual.\n\nGeneralized Field NotationThe type Username is a constant, so functions in the Username namespace can be applied to terms with type Username with generalized field notation.def Username := String\nOne such function is Username.validate, which checks that a username contains no leading whitespace and that only a small set of acceptable characters are used.\nIn its definition, generalized field notation is used to call the functions String.isPrefixOf, String.any, Char.isAlpha, and Char.isDigit.\nIn the case of String.isPrefixOf, which takes two String arguments, \" \" is used as the first  because it's the term before the dot.\nString.any can be called on name using generalized field notation even though it has type Username because Username.any is not defined and Username unfolds to String.def Username.validate (name : Username) : Except String Unit := do\n  if \" \".isPrefixOf name then\n    throw \"Unexpected leading whitespace\"\n  if name.any notOk then\n    throw \"Unexpected character\"\n  return ()\nwhere\n  notOk (c : Char) : Bool :=\n    !c.isAlpha &&\n    !c.isDigit &&\n    !c ∈ ['_', ' ']\n\ndef root : Username := \"root\"\nHowever, Username.validate can't be called on \"root\" using field notation, because String does not unfold to Username.#eval \"root\".validate\nInvalid field `validate`: The environment does not contain `String.validate`\n  \"root\"\nhas type\n  String\nroot, on the other hand, has type Username:#eval root.validate\nExcept.ok ()\n\n\n(pretty printer) use field notation when pretty printing, including for structure projections, unless '@[pp_nodot]' is applied\n\nControlling Field NotationThe pp_nodot attribute causes Lean's pretty printer to not use field notation when printing a function.\n\nTurning Off Field NotationNat.half is printed using field notation by default.def Nat.half : Nat → Nat\n  | 0 | 1 => 0\n  | n + 2 => n.half + 1\n#check Nat.half Nat.zero\nNat.zero.half : Nat\nAdding pp_nodot to Nat.half causes ordinary function application syntax to be used instead when displaying the term.attribute [pp_nodot] Nat.half\n\n#check Nat.half Nat.zero\nNat.half Nat.zero : Nat\n\n\n","context":"Lean Reference\u0009Terms\u0009Function Application","header":"10.4.1. Generalized Field Notation","id":"/Terms/Function-Application/#generalized-field-notation"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Library":{"contents":"* #4560 splits GetElem class into GetElem and GetElem?.\nThis enables removing Decidable instance arguments from GetElem.getElem? and GetElem.getElem!, improving their rewritability.\nSee the docstrings for these classes for more information.* Array* #4389 makes Array.toArrayAux_eq be a simp lemma.* #4399 improves robustness of the proof for Array.reverse_data.* List* #4469 and #4475 improve the organization of the List API.* #4470 improves the List.set and List.concat API.* #4472 upstreams lemmas about List.filter from Batteries.* #4473 adjusts @[simp] attributes.* #4488 makes List.getElem?_eq_getElem be a simp lemma.* #4487 adds missing List.replicate API.* #4521 adds lemmas about List.map.* #4500 changes List.length_cons to use as.length + 1 instead of as.length.succ.* #4524 fixes the statement of List.filter_congr.* #4525 changes binder explicitness in List.bind_map.* #4550 adds maximum?_eq_some_iff' and minimum?_eq_some_iff?.* #4400 switches the normal forms for indexing List and Array to xs[n] and xs[n]?.* HashMap* #4372 fixes linearity in HashMap.insert and HashMap.erase, leading to a 40% speedup in a replace-heavy workload.* Option* #4403 generalizes type of Option.forM from Unit to PUnit.* #4504 remove simp attribute from Option.elim and instead adds it to individual reduction lemmas, making unfolding less aggressive.* Nat* #4242 adds missing theorems for n + 1 and n - 1 normal forms.* #4486 makes Nat.min_assoc be a simp lemma.* #4522 moves @[simp] from Nat.pred_le to Nat.sub_one_le.* #4532 changes various Nat.succ n to n + 1.* Int* #3850 adds complete div/mod simprocs for Int.* String/Char* #4357 make the byte size interface be Nat-valued with functions Char.utf8Size and String.utf8ByteSize.* #4438 upstreams Char.ext from Batteries and adds some Char documentation to the manual.* Fin* #4421 adjusts Fin.sub to be more performant in definitional equality checks.* Prod* #4526 adds missing Prod.map lemmas.* #4533 fixes binder explicitness in lemmas.* BitVec* #4428 adds missing simproc for BitVec equality.* #4417 adds BitVec.twoPow and lemmas, toward bitblasting multiplication for LeanSAT.* Std library* #4499 introduces Std, a library situated between Init and Lean, providing functionality not in the prelude both to Lean's implementation and to external users.* Other fixes or improvements* #3056 standardizes on using (· == a) over (a == ·).* #4502 fixes errors reported by running the library through the the Batteries linters.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"Library","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Library"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Library":{"contents":"* #6081 adds an inheritEnv field to IO.Process.SpawnArgs. If\nfalse, the spawned process does not inherit its parent's environment.* #7108 proves List.head_of_mem_head? and the analogous\nList.getLast_of_mem_getLast?.* #7400 adds lemmas for the filter, map and filterMap functions of\nthe hash map.* #7659 adds SMT-LIB operators to detect overflow\nBitVec.(umul_overflow, smul_overflow), according to the definitions\nhere,\nand the theorems proving equivalence of such definitions with the\nBitVec library functions (umulOverflow_eq, smulOverflow_eq).\nSupport theorems for these proofs are BitVec.toInt_one_of_lt, BitVec.toInt_mul_toInt_lt, BitVec.le_toInt_mul_toInt, BitVec.toNat_mul_toNat_lt, BitVec.two_pow_le_toInt_mul_toInt_iff, BitVec.toInt_mul_toInt_lt_neg_two_pow_iff and Int.neg_mul_le_mul, Int.bmod_eq_self_of_le_mul_two, Int.mul_le_mul_of_natAbs_le, Int.mul_le_mul_of_le_of_le_of_nonneg_of_nonpos, Int.pow_lt_pow. The PR\nalso includes a set of tests.* #7671 contains the theorem proving that signed division x.toInt /\ny.toInt only overflows when x = intMin w and y = allOnes w (for 0 < w).\nTo show that this is the only case in which overflow happens, we refer\nto overflow for negation\n(BitVec.sdivOverflow_eq_negOverflow_of_neg_one): in fact,\nx.toInt/(allOnes w).toInt = - x.toInt, i.e., the overflow conditions\nare the same as negOverflow for x, and then reason about the signs\nof the operands with the respective theorems.\nThese BitVec theorems themselves rely on numerous Int.ediv_* theorems,\nthat carefully set the bounds of signed division for integers.* #7761 implements the core theorem for the Bitwuzla rewrites\nNORM_BV_NOT_OR_SHL\nand\nBV_ADD_SHL,\nwhich convert the mixed-boolean-arithmetic expression into a purely\narithmetic expression:theorem add_shiftLeft_eq_or_shiftLeft {x y : BitVec w} :\n    x + (y <<< x) =  x ||| (y <<< x)\n* #7770 adds a shared mutex (or read-write lock) as Std.SharedMutex.* #7774 adds Option.pfilter, a variant of Option.filter and several\nlemmas for it and other Option functions. These lemmas are split off\nfrom #7400.* #7791 adds lemmas about Nat.lcm.* #7802 adds Int.gcd and Int.lcm variants of all Nat.gcd and\nNat.lcm lemmas.* #7818 deprecates Option.merge and Option.liftOrGet in favor of\nOption.zipWith.* #7819 extends Std.Channel to provide a full sync and async API, as\nwell as unbounded, zero sized and bounded channels.* #7835 adds BitVec.[toInt_append|toFin_append].* #7847 removes @[simp] from all deprecated theorems. simp will\nstill use such lemmas, without any warning message.* #7851 partially reverts #7818, because the function called\nOption.zipWith in that PR does not actually correspond to\nList.zipWith. We choose Option.merge as the name instead.* #7855 moves ReflBEq to Init.Core and changes LawfulBEq to extend\nReflBEq.* #7856 changes definitions and theorems not to use the membership\ninstance on Option unless the theorem is specifically about the\nmembership instance.* #7869 fixes a regression introduced in #7445 where the new\nArray.emptyWithCapacity was accidentally not tagged with the correct\nfunction to actually allocate the capacity.* #7871 generalizes the typeclass assumptions on monadic Option\nfunctions.* #7879 adds Int.toNat_emod, analogous to Int.toNat_add/mul.* #7880 adds the functions UIntX.ofInt, and basic lemmas.* #7886 adds UIntX.pow and Pow UIntX Nat instances, and similarly\nfor signed fixed-width integers. These are currently only the naive\nimplementation, and will need to be subsequently replaced via\n@[extern] with fast implementations (tracked at #7887).* #7888 adds Fin.ofNat'_mul and Fin.mul_ofNat', parallel to the\nexisting lemmas about add.* #7889 adds Int.toNat_sub'' a variant of Int.toNat_sub taking\ninequality hypotheses, rather than expecting the arguments to be casts\nof natural numbers. This is parallel to the existing toNat_add and\ntoNat_mul.* #7890 adds missing lemmas about Int.bmod, parallel to lemmas about\nthe other mod variants.* #7891 adds the rfl simp lemma Int.cast x = x for x : Int.* #7893 adds BitVec.pow and Pow (BitVec w) Nat. The implementation\nis the naive one, and should later be replaced by an @[extern]. This\nis tracked at https://github.com/leanprover/lean4/issues/7887.* #7897 cleans up the Option development, upstreaming some results\nfrom mathlib in the process.* #7899 shuffles some results about integers around to make sure that\nall material that currently exists about Int.bmod is located in\nDivMod/Lemmas.lean and not downstream of that.* #7901 adds instance [Pure f] : Inhabited (OptionT f α), so that\nInhabited (OptionT Id Empty) synthesizes.* #7912 adds List.Perm.take/drop, and Array.Perm.extract,\nrestricting permutations to sublist / subarrays when they are constant\nelsewhere.* #7913 adds some missing List/Array/Vector lemmas about\nisSome_idxOf?, isSome_finIdxOf?, isSome_findFinIdx?, isSome_findIdx?and the correspondingisNone` versions.* #7933 adds lemmas about Int.bmod to achieve parity between\nInt.bmod and Int.emod/Int.fmod/Int.tmod. Furthermore, it adds\nmissing lemmas for emod/fmod/tmod and performs cleanup on names\nand statements for all four operations, also with a view towards\nincreasing consistency with the corresponding Nat.mod lemmas.* #7938 adds lemmas about List/Array/Vector.countP/count interacting\nwith replace. (Specializing to _self and _ne lemmas doesn't seem\nuseful, as there will still be an if on the RHS.)* #7939 adds Array.count_erase and specializations.* #7953 generalizes some typeclass hypotheses in the List.Perm API\n(away from DecidableEq), and reproduces List.Perm.mem_iff for\nArray, and fixes a mistake in the statement of Array.Perm.extract.* #7971 upstreams much of the material from Mathlib/Data/Nat/Init.lean\nand Mathlib/Data/Nat/Basic.lean.* #7983 upstreams many of the results from Mathlib/Data/Int/Init.lean.* #7994 reproduces the Array.Perm API for Vector. Both are still\nsignificantly less developed than the API for List.Perm.* #7999 replaces Array.Perm and Vector.Perm with one-field\nstructures. This avoids dot notation for List to work like e.g.\nh.cons 3 where h is an Array.Perm.* #8000 deprecates some Int.ofNat_* lemmas in favor of\nInt.natCast_*.* #8004 adds extensional hash maps and hash sets under the names\nStd.ExtDHashMap, Std.ExtHashMap and Std.ExtHashSet. Extensional\nhash maps work like regular hash maps, except that they have\nextensionality lemmas which make them easier to use in proofs. This\nhowever makes it also impossible to regularly iterate over its entries.* #8030 adds some missing lemmas about\nList/Array/Vector.findIdx?/findFinIdx?/findSome?/idxOf?.* #8044 introduces the modules Std.Data.DTreeMap.Raw,\nStd.Data.TreeMap.Raw and Std.Data.TreeSet.Raw and imports them into\nStd.Data. All modules related to the raw tree maps are imported into\nthese new modules so that they are now a transitive dependency of Std.* #8067 fixes the behavior of Substring.isNat to disallow empty\nstrings.* #8078 is a follow up to #8055 and implements a Selector for async\nTCP in order to allow IO multiplexing using TCP sockets.* #8080 fixes Json.parse to handle surrogate pairs correctly.* #8085 moves the coercion α → Option α to the new file\nInit.Data.Option.Coe. This file may not be imported anywhere in Init\nor Std.* #8089 adds optimized division functions for Int and Nat when the\narguments are known to be divisible (such as when normalizing\nrationals). These are backed by the gmp functions mpz_divexact and\nmpz_divexact_ui. See also leanprover-community/batteries#1202.* #8136 adds an initial set of @[grind] annotations for\nList/Array/Vector, enough to set up some regression tests using\ngrind in proofs about List. More annotations to follow.* #8139 is a follow up to #8055 and implements a Selector for async\nUDP in order to allow IO multiplexing using UDP sockets.* #8144 changes the predicate for Option.guard to be p : α → Bool\ninstead of p : α → Prop. This brings it in line with other comparable\nfunctions like Option.filter.* #8147 adds List.findRev? and List.findSomeRev?, for parity with\nthe existing Array API, and simp lemmas converting these into existing\noperations.* #8148 generalises List.eraseDups to allow for an arbitrary\ncomparison relation. Further, it proves eraseDups_append : (as ++ bs).eraseDups = as.eraseDups ++ (bs.removeAll as).eraseDups.* #8150 is a follow up to #8055 and implements a Selector for\nStd.Channel in order to allow\nmultiplexing using channels.* #8154 adds unconditional lemmas for\nHashMap.getElem?_insertMany_list, alongside the existing ones that\nhave quite strong preconditions. Also for TreeMap (and\ndependent/extensional variants).* #8175 adds simp/grind lemmas about List/Array/Vector.contains.\nIn the presence of LawfulBEq these effectively already held, via\nsimplifying contains to mem, but now these also fire without\nLawfulBEq.* #8184 adds the insertMany_append lemma for all map variants.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Library","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Library"}});