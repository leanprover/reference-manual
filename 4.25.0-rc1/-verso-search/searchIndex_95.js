window.docContents[95].resolve({"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Comparisons":{"contents":"One character is less than or equal to another if its code point is less than or equal to the\nother's.\n\nOne character is less than another if its code point is strictly less than the other's.\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters\u0009API Reference","header":"19.7.4.4. Comparisons","id":"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Comparisons"},"/Basic-Types/Strings/#string-iterators":{"contents":"Fundamentally, a String.Iterator is a pair of a string and a valid position in the string.\nIterators provide functions for getting the current character (curr), replacing the current character (setCurr), checking whether the iterator can move to the left or the right (hasPrev and hasNext, respectively), and moving the iterator (prev and next, respectively).\nClients are responsible for checking whether they've reached the beginning or end of the string; otherwise, the iterator ensures that its position always points at a character.\n\nAn iterator over the characters (Unicode code points) in a String. Typically created by\nString.iter.String iterators pair a string with a valid byte index. This allows efficient character-by-character\nprocessing of strings while avoiding the need to manually ensure that byte indices are used with the\ncorrect strings.An iterator is valid if the position i is valid for the string s, meaning 0 ≤ i ≤ s.endPos\nand i lies on a UTF8 byte boundary. If i = s.endPos, the iterator is at the end of the string.Most operations on iterators return unspecified values if the iterator is not valid. The functions\nin the String.Iterator API rule out the creation of invalid iterators, with two exceptions:* Iterator.next iter is invalid if iter is already at the end of the string (iter.atEnd is\ntrue), and* Iterator.forward iter n/Iterator.nextn iter n is invalid if n is strictly greater than the\nnumber of remaining characters.The string being iterated over.The current UTF-8 byte position in the string s.This position is not guaranteed to be valid for the string. If the position is not valid, then the\ncurrent character is (default : Char), similar to String.get on an invalid position.\n\nCreates an iterator at the beginning of the string.\n\nCreates an iterator at the beginning of the string.\n\nGets the character at the iterator's current position.A run-time bounds check is performed. Use String.Iterator.curr' to avoid redundant bounds checks.If the position is invalid, returns (default : Char).\n\nGets the character at the iterator's current position.The proof of it.hasNext ensures that there is, in fact, a character at the current position. This\nfunction is faster that String.Iterator.curr due to avoiding a run-time bounds check.\n\nChecks whether the iterator is at or before the string's last character.\n\nMoves the iterator's position forward by one character, unconditionally.It is only valid to call this function if the iterator is not at the end of the string (i.e.\nif Iterator.atEnd is false); otherwise, the resulting iterator will be invalid.\n\nMoves the iterator's position forward by one character, unconditionally.The proof of it.hasNext ensures that there is, in fact, a position that's one character forwards.\nThis function is faster that String.Iterator.next due to avoiding a run-time bounds check.\n\nMoves the iterator's position forward by the specified number of characters.The resulting iterator is only valid if the number of characters to skip is less than or equal\nto the number of characters left in the iterator.\n\nMoves the iterator's position forward by the specified number of characters.The resulting iterator is only valid if the number of characters to skip is less than or equal\nto the number of characters left in the iterator.\n\nChecks whether the iterator is after the beginning of the string.\n\nMoves the iterator's position backward by one character, unconditionally.The position is not changed if the iterator is at the beginning of the string.\n\nMoves the iterator's position back by the specified number of characters, stopping at the beginning\nof the string.\n\nChecks whether the iterator is past its string's last character.\n\nMoves the iterator's position to the end of the string, just past the last character.\n\nReplaces the current character in the string.Does nothing if the iterator is at the end of the string. If both the replacement character and the\nreplaced character are 7-bit ASCII characters and the string is not shared, then it is updated\nin-place and not copied.\n\nMoves the iterator forward until the Boolean predicate p returns true for the iterator's current\ncharacter or until the end of the string is reached. Does nothing if the current character already\nsatisfies p.\n\nIterates over a string, updating a state at each character using the provided function f, until\nf returns none. Begins with the state init. Returns the state and character for which f\nreturns none.\n\nExtracts the substring between the positions of two iterators. The first iterator's position is the\nstart of the substring, and the second iterator's position is the end.Returns the empty string if the iterators are for different strings, or if the position of the first\niterator is past the position of the second iterator.\n\nThe remaining characters in an iterator, as a string.\n\nThe number of UTF-8 bytes remaining in the iterator.\n\nThe current UTF-8 byte position in the string s.This position is not guaranteed to be valid for the string. If the position is not valid, then the\ncurrent character is (default : Char), similar to String.get on an invalid position.\n\nThe string being iterated over.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.10. Iterators","id":"/Basic-Types/Strings/#string-iterators"},"/Build-Tools-and-Distribution/Lake/#lake-cache-remote":{"contents":"Build products can be retrieved from remote cache servers and placed into the local cache.\nThis makes it possible to completely avoid local builds.\nThe cache get command is used to download artifacts into the local cache.\n\nCompared to GitHub release builds, the remote artifact cache is much more fine-grained.\nIt tracks build products at the level of individual source files, .olean files, and object code, rather than at the level of entire packages.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology\u0009Artifact Caches","header":"22.1.1.6.1. Remote Artifact Caches","id":"/Build-Tools-and-Distribution/Lake/#lake-cache-remote"},"/Type-Classes/Class-Declarations/#class":{"contents":"Type classes are declared with the class keyword.\n\nType Class DeclarationsDeclares a new type class.\n\n\n\nThe class declaration creates a new single-constructor inductive type, just as if the structure command had been used instead.\nIn fact, the results of the class and structure commands are almost identical, and features such as default values may be used the same way in both.\nPlease refer to the documentation for structures for more information about default values, inheritance, and other features of structures.\nThe differences between structure and class declarations are:\n\n Methods instead of fields\n\nInstead of creating field projections that take a value of the structure type as an explicit parameter, methods are created. Each method takes the corresponding instance as an instance-implicit parameter.\n\n Instance-implicit parent classes\n\nThe constructor of a class that extends other classes takes its class parents' instances as instance-implicit parameters, rather than explicit parameters.\n  When instances of this class are defined, instance synthesis is used to find the values of inherited fields.\n  Parents that are not classes are still explicit parameters to the underlying constructor.\n\n Parent projections via instance synthesis\n\nStructure field projections make use of inheritance information to project parent structure fields from child structure values.\n  Classes instead use instance synthesis: given a child class instance, synthesis will construct the parent; thus, methods are not added to child classes in the same way that projections are added to child structures.\n\n Registered as class\n\nThe resulting inductive type is registered as a type class, for which instances may be defined and that may be used as the type of instance-implicit arguments.\n\n Out and semi-out parameters are considered\n\nThe outParam and semiOutParam gadgets have no meaning in structure definitions, but they are used in class definitions to control instance search.\n\n\n\nWhile deriving clauses are allowed for class definitions to maintain the parallel between class and structure elaboration, they are not frequently used and should be considered an advanced feature.\n\nNo Instances of Non-ClassesLean rejects instance-implicit parameters of types that are not classes:def f [n : Nat] : n = n := rfl\ninvalid binder annotation, type is not a class instance\n  Nat\n\nNote: Use the command `set_option checkBinderAnnotations false` to disable the check\n\n\nClass vs Structure ConstructorsA very small algebraic hierarchy can be represented either as structures (S.Magma, S.Semigroup, and S.Monoid below), a mix of structures and classes (C1.Monoid), or only using classes (C2.Magma, C2.Semigroup, and C2.Monoid):namespace S\nstructure Magma (α : Type u) where\n  op : α → α → α\n\nstructure Semigroup (α : Type u) extends Magma α where\n  op_assoc : ∀ x y z, op (op x y) z = op x (op y z)\n\nstructure Monoid (α : Type u) extends Semigroup α where\n  ident : α\n  ident_left : ∀ x, op ident x = x\n  ident_right : ∀ x, op x ident = x\nend S\n\nnamespace C1\nclass Monoid (α : Type u) extends S.Semigroup α where\n  ident : α\n  ident_left : ∀ x, op ident x = x\n  ident_right : ∀ x, op x ident = x\nend C1\n\nnamespace C2\nclass Magma (α : Type u) where\n  op : α → α → α\n\nclass Semigroup (α : Type u) extends Magma α where\n  op_assoc : ∀ x y z, op (op x y) z = op x (op y z)\n\nclass Monoid (α : Type u) extends Semigroup α where\n  ident : α\n  ident_left : ∀ x, op ident x = x\n  ident_right : ∀ x, op x ident = x\nend C2\nS.Monoid.mk and C1.Monoid.mk have identical signatures, because the parent of the class C1.Monoid is not itself a class:S.Monoid.mk.{u} {α : Type u}\n  (toSemigroup : S.Semigroup α)\n  (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x)\n  (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  S.Monoid α\nC1.Monoid.mk.{u} {α : Type u}\n  (toSemigroup : S.Semigroup α)\n  (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x)\n  (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  C1.Monoid α\nSimilarly, because neither S.Magma nor C2.Magma inherits from another structure or class, their constructors are identical:S.Magma.mk.{u} {α : Type u} (op : α → α → α) : S.Magma α\nC2.Magma.mk.{u} {α : Type u} (op : α → α → α) : C2.Magma α\nS.Semigroup.mk, however, takes its parent as an ordinary parameter, while C2.Semigroup.mk takes its parent as an instance implicit parameter:S.Semigroup.mk.{u} {α : Type u}\n  (toMagma : S.Magma α)\n  (op_assoc : ∀ (x y z : α),\n    toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)) :\n  S.Semigroup α\nC2.Semigroup.mk.{u} {α : Type u} [toMagma : C2.Magma α]\n  (op_assoc : ∀ (x y z : α),\n    toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)) :\n  C2.Semigroup α\nFinally, C2.Monoid.mk takes its semigroup parent as an instance implicit parameter.\nThe references to op become references to the method C2.Magma.op, relying on instance synthesis to recover the implementation from the C2.Semigroup instance-implicit parameter via its parent projection:C2.Monoid.mk.{u} {α : Type u}\n  [toSemigroup : C2.Semigroup α]\n  (ident : α)\n  (ident_left : ∀ (x : α), C2.Magma.op ident x = x)\n  (ident_right : ∀ (x : α), C2.Magma.op x ident = x) :\n  C2.Monoid α\n\n\nParameters to type classes may be marked with gadgets, which are special versions of the identity function that cause the elaborator to treat a value differently.\nGadgets never change the meaning of a term, but they may cause it to be treated differently in elaboration-time search procedures.\nThe gadgets outParam and semiOutParam affect instance synthesis, so they are documented in that section.\n\nWhether a type is a class or not has no effect on definitional equality.\nTwo instances of the same class with the same parameters are not necessarily identical and may in fact be very different.\n\nInstances are Not UniqueThis implementation of binary heap insertion is buggy:structure Heap (α : Type u) where\n  contents : Array α\nderiving Repr\n\ndef Heap.bubbleUp [Ord α] (i : Nat) (xs : Heap α) : Heap α :=\n  if h : i = 0 then xs\n  else if h : i ≥ xs.contents.size then xs\n  else\n    let j := i / 2\n    if Ord.compare xs.contents[i] xs.contents[j] == .lt then\n      Heap.bubbleUp j { xs with contents := xs.contents.swap i j }\n    else xs\n\ndef Heap.insert [Ord α] (x : α) (xs : Heap α) : Heap α :=\n  let i := xs.contents.size\n  {xs with contents := xs.contents.push x}.bubbleUp i\nThe problem is that a heap constructed with one Ord instance may later be used with another, leading to the breaking of the heap invariant.One way to correct this is to make the heap type depend on the selected Ord instance:structure Heap' (α : Type u) [Ord α] where\n  contents : Array α\n\ndef Heap'.bubbleUp [inst : Ord α]\n    (i : Nat) (xs : @Heap' α inst) :\n    @Heap' α inst :=\n  if h : i = 0 then xs\n  else if h : i ≥ xs.contents.size then xs\n  else\n    let j := i / 2\n    if inst.compare xs.contents[i] xs.contents[j] == .lt then\n      Heap'.bubbleUp j {xs with contents := xs.contents.swap i j}\n    else xs\n\ndef Heap'.insert [Ord α] (x : α) (xs : Heap' α) : Heap' α :=\n  let i := xs.contents.size\n  {xs with contents := xs.contents.push x}.bubbleUp i\nIn the improved definitions, Heap'.bubbleUp is needlessly explicit; the instance does not need to be explicitly named here because Lean would select the indicated instances nonetheless, but it does bring the correctness invariant front and center for readers.\n\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"11.1. Class Declarations","id":"/Type-Classes/Class-Declarations/#class"},"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Compiler":{"contents":"* #8211 adds support for generating IR from the LCNF representation of\nthe new compiler.* #8236 fixes an issue where the combination of extern_lib and\nprecompileModules would lead to \"symbol not found\" errors.* #8268 optimizes lean_nat_shiftr for scalar operands. The new compiler\nconverts Nat divisions into right shifts, so this now shows up as hot in\nsome profiles.* #8308 makes the new compiler's specialization pass compute closures\nthe same way as the old compiler, in particular when it comes to\nvariables captured by lambdas.* #8367 adds a new structProjCases pass to the new compiler, analogous\nto the struct_cases_on pass in the old compiler, which converts all\nprojections from structs into cases expressions. When lowered to IR,\nthis causes all of the projections from a single structure to be grouped\ntogether, which is an invariant relied upon by the IR RC passes (at\nleast for linearity, if not general correctness).* #8409 adds support to LCNF for native UInt8/UInt16/UInt32/UInt64\nliterals.* #8456 adds support for primitive USize literals in LCNF.* #8458 adds closed term extraction to the new compiler, closely\nfollowing the approach in the old compiler. In the future, we will\nexplore some ideas to improve upon this approach.* #8462 enables the LCNF extractClosed pass by default.* #8468 switches the LCNF baseExt/monoExt environment extensions to use\na custom environment extension that uses a PersistentHashMap. The\noptimizer relies upon the ability to update a decl multiple times, which\ndoes not work with SimplePersistentEnvExtension.* #8502 changes the new compiler to use the kernel environment to find\ndefinitions, which causes compilation to be skipped when the decl had a\nkernel error (e.g. due to an unresolved metavariable). This matches the\nbehavior of the old compiler.* #8521 makes LCNF.toMono recursively process jmp args.* #8523 moves the new compiler's noncomputable check into toMono,\nmatching the recent change in the old compiler. This is mildly more\ncomplicated because we can't throw an error at the mere use of a\nconstant, we need to check for a later relevant use. This is still a bit\nmore conservative than it could theoretically be around join points and\nlocal functions, but it's hard to imagine that mattering in practice\n(and we can easily enable it if it does).* #8535 extracts more Nats (and their downstream users) in extractClosed\nby fixing a silly oversight in the logic.* #8540 changes the LCNF specialize pass to allow ground variables to\ndepend on local fun decls (with no non-ground free variables). This\nenables specialization of Monad instances that depend on local lambdas.* #8559 fixes an adversarial soundness attack described in #8554. The\nattack exploits the fact that assert! no longer aborts execution, and\nthat users can redirect error messages.\nAnother PR will implement the same fix for Expr.Data.* #8560 is similar to #8559 but for Expr.mkData. This vulnerability\nhas not been exploited yet, but adversarial users may find a way.* #8561 increases maxHeartbeats in the isDefEqProjIssue test, because\nwhen running under the new compiler the run_meta call includes the\nallocations of the compiler itself. With the old compiler, many of the\ncorresponding allocations were internal to C++ code and would not\nincrease the heartbeat count.* #8565 makes the LCNF specialization pass only treat type/instance\nparams as ground vars. The current policy was too liberal and would\nresult on computations being floated into specialized loops.* #8566 changes the LCNF constant folding pass to not convert Nat\nmultiplication to a left shift by a power of 2. The fast path test for\nthis is sufficiently complex that it's simpler to just use the fast path\nfor multiplication.* #8575 makes LCNF's simpAppApp? bail out on trivial aliases as\nintended. It seems that there was a typo in the original logic, and this\nPR also extends it to include aliases of global constants rather than\njust local vars.* #8582 fixes an accidental dropping of state in Param.toMono. When this\ncode was originally written, there was no other state besides\ntypeParams.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.21.0 (2025-06-30)","header":"Compiler","id":"/releases/v4.21.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___21___0-_LPAR_2025-06-30_RPAR_--Compiler"}});