window.docContents[88].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Iteration":{"contents":"Combine all the values that can be represented by Fin n with an initial value, starting at n - 1\nand nesting to the right.Example:* Fin.foldr 3 (·.val + ·) (0 : Nat) = (0 : Fin 3).val + ((1 : Fin 3).val + ((2 : Fin 3).val + 0))\n\nFolds a monadic function over Fin n from right to left, starting with n-1.It is the sequence of steps:Fin.foldrM n f xₙ = do\n  let xₙ₋₁ ← f (n-1) xₙ\n  let xₙ₋₂ ← f (n-2) xₙ₋₁\n  ...\n  let x₀ ← f 0 x₁\n  pure x₀\n\n\nCombine all the values that can be represented by Fin n with an initial value, starting at 0 and\nnesting to the left.Example:* Fin.foldl 3 (· + ·.val) (0 : Nat) = ((0 + (0 : Fin 3).val) + (1 : Fin 3).val) + (2 : Fin 3).val\n\nFolds a monadic function over all the values in Fin n from left to right, starting with 0.It is the sequence of steps:Fin.foldlM n f x₀ = do\n  let x₁ ← f x₀ 0\n  let x₂ ← f x₁ 1\n  ...\n  let xₙ ← f xₙ₋₁ (n-1)\n  pure xₙ\n\n\nApplies an index-dependent function to all the values less than the given bound n, starting at\n0 with an accumulator.Concretely, Fin.hIterate P init f is equal to  init |> f 0 |> f 1 |> ... |> f (n-1)\nTheorems about Fin.hIterate can be proven using the general theorem Fin.hIterate_elim or other more\nspecialized theorems.Fin.hIterateFrom is a variant that takes a custom starting value instead of 0.\n\nApplies an index-dependent function f to all of the values in [i:n], starting at i with an\ninitial accumulator a.Concretely, Fin.hIterateFrom P f i a is equal to  a |> f i |> f (i + 1) |> ... |> f (n - 1)\nTheorems about Fin.hIterateFrom can be proven using the general theorem Fin.hIterateFrom_elim or\nother more specialized theorems.Fin.hIterate is a variant that always starts at 0.\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"19.3.3.5. Iteration","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Iteration"},"/Basic-Types/Natural-Numbers/#nat-api-induction":{"contents":"Strong induction on the natural numbers.The induction hypothesis is that all numbers less than a given number satisfy the motive, which\nshould be demonstrated for the given number.\n\nCase analysis based on strong induction for the natural numbers.\n\nAn induction principle customized for reasoning about the recursion pattern of natural number\ndivision by iterated subtraction.\n\nAn induction principle for the natural numbers with two cases:* n = 0, and the motive is satisfied for 0* n > 0, and the motive should be satisfied for n on the assumption that it is satisfied for\nn / 2.\n\nAn induction principle customized for reasoning about the recursion pattern of Nat.mod.\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Elimination","header":"19.1.4.8.1. Alternative Induction Principles","id":"/Basic-Types/Natural-Numbers/#nat-api-induction"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-assumption-management":{"contents":"Larger proofs can benefit from management of proof states, removing irrelevant assumptions and making their names easier to understand.\nAlong with these operators, rename_i allows inaccessible assumptions to be renamed, and intro, intros and rintro convert goals that are implications or universal quantification into goals with additional assumptions.\n\nrename t => x renames the most recent hypothesis whose type matches t\n(which may contain placeholders) to x, or fails if no such hypothesis could be found.\n\nrevert x... is the inverse of intro x...: it moves the given hypotheses\ninto the main goal's target type.\n\nclear x... removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","header":"13.3.3. Assumption Management","id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-assumption-management"},"/releases/v4.0.0-m4/#release-v4___0___0-m4":{"contents":"This is the fourth milestone release of Lean 4. It contains many improvements and many new features.\nWe had more than 600 commits since the last milestone.\n\nContributors:\n\n$ git shortlog -s -n v4.0.0-m3..v4.0.0-m4\n   501  Leonardo de Moura\n    65  Sebastian Ullrich\n    11  Daniel Fabian\n    10  larsk21\n     5  Gabriel Ebner\n     2  E.W.Ayers\n     2  Jonathan Coates\n     2  Joscha\n     2  Mario Carneiro\n     2  ammkrn\n     1  Chris Lovett\n     1  François G. Dorais\n     1  Jakob von Raumer\n     1  Lars\n     1  Patrick Stevens\n     1  Wojciech Nawrocki\n     1  Xubai Wang\n     1  casavaca\n     1  zygi\n\n\n* simp now takes user-defined simp-attributes. You can define a new simp attribute by creating a file (e.g., MySimp.lean) containingimport Lean\nopen Lean.Meta\n\ninitialize my_ext : SimpExtension ← registerSimpAttr `my_simp \"my own simp attribute\"\nIf you don't need to access my_ext, you can also use the macroimport Lean\n\nregister_simp_attr my_simp \"my own simp attribute\"\nRecall that the new simp attribute is not active in the Lean file where it was defined.\nHere is a small example using the new feature.import MySimp\n\ndef f (x : Nat) := x + 2\ndef g (x : Nat) := x + 1\n\n@[my_simp] theorem f_eq : f x = x + 2 := rfl\n@[my_simp] theorem g_eq : g x = x + 1 := rfl\n\nexample : f x + g x = 2*x + 3 := by\n  simp_arith [my_simp]\n* Extend match syntax: multiple left-hand-sides in a single alternative. Example:def fib : Nat → Nat\n| 0 | 1 => 1\n| n+2 => fib n + fib (n+1)\nThis feature was discussed at issue 371. It was implemented as a macro expansion. Thus, the following is accepted.inductive StrOrNum where\n  | S (s : String)\n  | I (i : Int)\n\ndef StrOrNum.asString (x : StrOrNum) :=\n  match x with\n  | I a | S a => toString a\n* Improve #eval command. Now, when it fails to synthesize a Lean.MetaEval instance for the result type, it reduces the type and tries again. The following example now works without additional annotationsdef Foo := List Nat\n\ndef test (x : Nat) : Foo :=\n  [x, x+1, x+2]\n\n#eval test 4\n* rw tactic can now apply auto-generated equation theorems for a given definition. Example:example (a : Nat) (h : n = 1) : [a].length = n := by\n  rw [List.length]\n  trace_state -- .. |- [].length + 1 = n\n  rw [List.length]\n  trace_state -- .. |- 0 + 1 = n\n  rw [h]\n* Fuzzy matching for auto completion* Extend dot-notation x.field for arrow types. If type of x is an arrow, we look up for Function.field.\nFor example, given f : Nat → Nat and g : Nat → Nat, f.comp g is now notation for Function.comp f g.* The new .<identifier> notation is now also accepted where a function type is expected.example (xs : List Nat) : List Nat := .map .succ xs\nexample (xs : List α) : Std.RBTree α ord := xs.foldl .insert ∅\n* Add code folding support to the language server.* Support notation let <pattern> := <expr> | <else-case> in do blocks.* Remove support for \"auto\" pure. In the Zulip thread, the consensus seemed to be that \"auto\" pure is more confusing than it's worth.* Remove restriction in congr theorems that all function arguments on the left-hand-side must be free variables. For example, the following theorem is now a valid congr theorem.@[congr]\ntheorem dep_congr [DecidableEq ι] {p : ι → Set α} [∀ i, Inhabited (p i)] :\n                  ∀ {i j} (h : i = j) (x : p i) (y : α) (hx : x = y), Pi.single (f := (p ·)) i x = Pi.single (f := (p ·)) j ⟨y, hx ▸ h ▸ x.2⟩ :=\n* Partially applied congruence theorems.* Improve elaboration postponement heuristic when expected type is a metavariable. Lean now reduces the expected type before performing the test.* Remove deprecated leanpkg in favor of Lake now bundled with Lean.* Various improvements to go-to-definition & find-all-references accuracy.* Auto generated congruence lemmas with support for casts on proofs and Decidable instances (see wishlist).* Rename option autoBoundImplicitLocal => autoImplicit.* Relax auto-implicit restrictions. The command set_option relaxedAutoImplicit false disables the relaxations.* contradiction tactic now closes the goal if there is a False.elim application in the target.* Renamed tatic byCases => by_cases (motivation: enforcing naming convention).* Local instances occurring in patterns are now considered by the type class resolution procedure. Example:def concat : List ((α : Type) × ToString α × α) → String\n  | [] => \"\"\n  | ⟨_, _, a⟩ :: as => toString a ++ concat as\n* Notation for providing the motive for match expressions has changed.\nbefore:match x, rfl : (y : Nat) → x = y → Nat with\n| 0,   h => ...\n| x+1, h => ...\nnow:match (motive := (y : Nat) → x = y → Nat) x, rfl with\n| 0,   h => ...\n| x+1, h => ...\nWith this change, the notation for giving names to equality proofs in match-expressions is not whitespace sensitive anymore. That is,\nwe can now writematch h : sort.swap a b with\n| (r₁, r₂) => ... -- `h : sort.swap a b = (r₁, r₂)`\n* (generalizing := true) is the default behavior for match expressions even if the expected type is not a proposition. In the following example, we used to have to include (generalizing := true) manually.inductive Fam : Type → Type 1 where\n  | any : Fam α\n  | nat : Nat → Fam Nat\n\nexample (a : α) (x : Fam α) : α :=\n  match x with\n  | Fam.any   => a\n  | Fam.nat n => n\n* We now use PSum (instead of Sum) when compiling mutually recursive definitions using well-founded recursion.* Better support for parametric well-founded relations. See issue #1017. This change affects the low-level termination_by' hint because the fixed prefix of the function parameters in not \"packed\" anymore when constructing the well-founded relation type. For example, in the following definition, as is part of the fixed prefix, and is not packed anymore. In previous versions, the termination_by' term would be written as measure fun ⟨as, i, _⟩ => as.size - idef sum (as : Array Nat) (i : Nat) (s : Nat) : Nat :=\n  if h : i < as.size then\n    sum as (i+1) (s + as.get ⟨i, h⟩)\n  else\n    s\ntermination_by' measure fun ⟨i, _⟩ => as.size - i\n* Add while <cond> do <do-block>, repeat <do-block>, and repeat <do-block> until <cond> macros for do-block. These macros are based on partial definitions, and consequently are useful only for writing programs we don't want to prove anything about.* Add arith option to Simp.Config, the macro simp_arith expands to simp (config := { arith := true }). Only Nat and linear arithmetic is currently supported. Example:example : 0 < 1 + x ∧ x + y + 2 ≥ y + 1 := by\n  simp_arith\n* Add fail <string>? tactic that always fail.* Add support for acyclicity at dependent elimination. See issue #1022.* Add trace <string> tactic for debugging purposes.* Add nontrivial SizeOf instance for types Unit → α, and add support for them in the auto-generated SizeOf instances for user-defined inductive types. For example, given the inductive datatypeinductive LazyList (α : Type u) where\n  | nil                               : LazyList α\n  | cons (hd : α) (tl : LazyList α)   : LazyList α\n  | delayed (t : Thunk (LazyList α))  : LazyList α\nwe now have sizeOf (LazyList.delayed t) = 1 + sizeOf t instead of sizeOf (LazyList.delayed t) = 2.* Add support for guessing (very) simple well-founded relations when proving termination. For example, the following function does not require a termination_by annotation anymore.def Array.insertAtAux (i : Nat) (as : Array α) (j : Nat) : Array α :=\n  if h : i < j then\n    let as := as.swap! (j-1) j;\n    insertAtAux i as (j-1)\n  else\n    as\n* Add support for for h : x in xs do ... notation where h : x ∈ xs. This is mainly useful for showing termination.* Auto implicit behavior changed for inductive families. An auto implicit argument occurring in inductive family index is also treated as an index (IF it is not fixed, see next item). For exampleinductive HasType : Index n → Vector Ty n → Ty → Type where\nis now interpreted asinductive HasType : {n : Nat} → Index n → Vector Ty n → Ty → Type where\n* To make the previous feature more convenient to use, we promote a fixed prefix of inductive family indices to parameters. For example, the following declaration is now accepted by Leaninductive Lst : Type u → Type u\n  | nil  : Lst α\n  | cons : α → Lst α → Lst α\nand α in Lst α is a parameter. The actual number of parameters can be inspected using the command #print Lst. This feature also makes sure we still accept the declarationinductive Sublist : List α → List α → Prop\n  | slnil : Sublist [] []\n  | cons l₁ l₂ a : Sublist l₁ l₂ → Sublist l₁ (a :: l₂)\n  | cons2 l₁ l₂ a : Sublist l₁ l₂ → Sublist (a :: l₁) (a :: l₂)\n* Added auto implicit \"chaining\". Unassigned metavariables occurring in the auto implicit types now become new auto implicit locals. Consider the following example:inductive HasType : Fin n → Vector Ty n → Ty → Type where\n  | stop : HasType 0 (ty :: ctx) ty\n  | pop  : HasType k ctx ty → HasType k.succ (u :: ctx) ty\nctx is an auto implicit local in the two constructors, and it has type ctx : Vector Ty ?m. Without auto implicit \"chaining\", the metavariable ?m will remain unassigned. The new feature creates yet another implicit local n : Nat and assigns n to ?m. So, the declaration above is shorthand forinductive HasType : {n : Nat} → Fin n → Vector Ty n → Ty → Type where\n  | stop : {ty : Ty} → {n : Nat} → {ctx : Vector Ty n} → HasType 0 (ty :: ctx) ty\n  | pop  : {n : Nat} → {k : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType k ctx ty → HasType k.succ (u :: ctx) ty\n* Eliminate auxiliary type annotations (e.g, autoParam and optParam) from recursor minor premises and projection declarations. Consider the following examplestructure A :=\n  x : Nat\n  h : x = 1 := by trivial\n\nexample (a : A) : a.x = 1 := by\n  have aux := a.h\n  -- `aux` has now type `a.x = 1` instead of `autoParam (a.x = 1) auto✝`\n  exact aux\n\nexample (a : A) : a.x = 1 := by\n  cases a with\n  | mk x h =>\n    -- `h` has now type `x = 1` instead of `autoParam (x = 1) auto✝`\n    assumption\n* We now accept overloaded notation in patterns, but we require the set of pattern variables in each alternative to be the same. Example:inductive Vector (α : Type u) : Nat → Type u\n  | nil : Vector α 0\n  | cons : α → Vector α n → Vector α (n+1)\n\ninfix:67 \" :: \" => Vector.cons -- Overloading the `::` notation\n\ndef head1 (x : List α) (h : x ≠ []) : α :=\n  match x with\n  | a :: as => a -- `::` is `List.cons` here\n\ndef head2 (x : Vector α (n+1)) : α :=\n  match x with\n  | a :: as => a -- `::` is `Vector.cons` here\n* New notation .<identifier> based on Swift. The namespace is inferred from the expected type. See issue #944. Examples:def f (x : Nat) : Except String Nat :=\n  if x > 0 then\n    .ok x\n  else\n    .error \"x is zero\"\n\nnamespace Lean.Elab\nopen Lsp\n\ndef identOf : Info → Option (RefIdent × Bool)\n  | .ofTermInfo ti => match ti.expr with\n    | .const n .. => some (.const n, ti.isBinder)\n    | .fvar id .. => some (.fvar id, ti.isBinder)\n    | _ => none\n  | .ofFieldInfo fi => some (.const fi.projName, false)\n  | _ => none\n\ndef isImplicit (bi : BinderInfo) : Bool :=\n  bi matches .implicit\n\nend Lean.Elab\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.0.0-m4 (2022-03-27)","id":"/releases/v4.0.0-m4/#release-v4___0___0-m4"}});