window.docContents[194].resolve({"/The-Type-System/Inductive-Types/#mutual-inductive-types-positivity":{"contents":"Each inductive type that is defined in the mutual group may occur only strictly positively in the types of the parameters of the constructors of all the types in the group.\nIn other words, in the type of each parameter to each constructor in all the types of the group, none of the type constructors in the group occur to the left of any arrows, and none of them occur in argument positions unless they are an argument to an inductive type's type constructor.\n\nMutual strict positivityIn the following mutual group, Tm occurs in a negative position in the argument to Binding.scope:mutual\n  inductive Tm where\n    | app : Tm → Tm → Tm\n    | lam : Binding → Tm\n  inductive Binding where\n    | scope : (Tm → Tm) → Binding\nend\nBecause Tm is part of the same mutual group, it must occur only strictly positively in the arguments to the constructors of Binding.\nIt occurs, however, negatively:(kernel) arg #1 of 'Binding.scope' has a non positive occurrence of the datatypes being declared\n\n\nNested positionsThe definitions of LocatedStx and Stx satisfy the positivity condition because the recursive occurrences are not to the left of any arrows and, when they are arguments, they are arguments to inductive type constructors.mutual\n  inductive LocatedStx where\n    | mk (line col : Nat) (val : Stx)\n  inductive Stx where\n    | atom (str : String)\n    | node (kind : String) (args : List LocatedStx)\nend\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types\u0009Requirements","header":"4.4.5.1.4. Positivity","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-positivity"},"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Language-features___-tactics___-and-metaprograms":{"contents":"* split tactic:* #4401 improves the strategy split uses to generalize discriminants of matches and adds trace.split.failure trace class for diagnosing issues.* rw tactic:* #4385 prevents the tactic from claiming pre-existing goals are new subgoals.* dac1da adds configuration for ordering new goals, like for apply.* simp tactic:* #4430 adds dsimprocs for if expressions (ite and dite).* #4434 improves heuristics for unfolding. Equational lemmas now have priorities where more-specific equationals lemmas are tried first before a possible catch-all.* #4481 fixes an issue where function-valued OfNat numeric literals would become denormalized.* #4467 fixes an issue where dsimp theorems might not apply to literals.* #4484 fixes the source position for the warning for deprecated simp arguments.* #4258 adds docstrings for dsimp configuration.* #4567 improves the accuracy of used simp lemmas reported by simp?.* fb9727 adds (but does not implement) the simp configuration option implicitDefEqProofs, which will enable including rfl-theorems in proof terms.* omega tactic:* #4360 makes the tactic generate error messages lazily, improving its performance when used in tactic combinators.* bv_omega tactic:* #4579 works around changes to the definition of Fin.sub in this release.* #4490 sets up groundwork for a tactic index in generated documentation, as there was in Lean 3. See PR description for details.* Commands* #4370 makes the variable command fully elaborate binders during validation, fixing an issue where some errors would be reported only at the next declaration.* #4408 fixes a discrepancy in universe parameter order between theorem and def declarations.* #4493 and\n#4482 fix a discrepancy in the elaborators for theorem, def, and example,\nmaking Prop-valued examples and other definition commands elaborate like theorems.* 8f023b, 3c4d6b and 0783d0 change the #reduce command to be able to control what gets reduced.\nFor example, #reduce (proofs := true) (types := false) e reduces both proofs and types in the expression e.\nBy default, neither proofs or types are reduced.* #4489 fixes an elaboration bug in #check_tactic.* #4505 adds support for open _root_.<namespace>.* Options* #4576 adds the debug.byAsSorry option. Setting set_option debug.byAsSorry true causes all by ... terms to elaborate as sorry.* 7b56eb and d8e719 add the debug.skipKernelTC option. Setting set_option debug.skipKernelTC true turns off kernel typechecking. This is meant for temporarily working around kernel performance issues, and it compromises soundness since buggy tactics may produce invalid proofs, which will not be caught if this option is set to true.* #4301\nadds a linter to flag situations where a local variable's name is one of\nthe argumentless constructors of its type. This can arise when a user either\ndoesn't open a namespace or doesn't add a dot or leading qualifier, as\nin the following:inductive Tree (α : Type) where\n  | leaf\n  | branch (left : Tree α) (val : α) (right : Tree α)\n\ndef depth : Tree α → Nat\n  | leaf => 0\nWith this linter, the leaf pattern is highlighted as a local\nvariable whose name overlaps with the constructor Tree.leaf.The linter can be disabled with set_option linter.constructorNameAsVariable false.Additionally, the error message that occurs when a name in a pattern that takes arguments isn't valid now suggests similar names that would be valid. This means that the following definition:def length (list : List α) : Nat :=\n  match list with\n  | nil => 0\n  | cons x xs => length xs + 1\nnow results in the following warning:warning: Local variable 'nil' resembles constructor 'List.nil' - write '.nil' (with a dot) or 'List.nil' to use the constructor.\nnote: this linter can be disabled with `set_option linter.constructorNameAsVariable false`\nand error:invalid pattern, constructor or constant marked with '[match_pattern]' expected\n\nSuggestion: 'List.cons' is similar\n* Metaprogramming* #4454 adds public Name.isInternalDetail function for filtering declarations using naming conventions for internal names.* Other fixes or improvements* #4416 sorts the output of #print axioms for determinism.* #4528 fixes error message range for the cdot focusing tactic.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.10.0 (2024-07-31)","header":"Language features, tactics, and metaprograms","id":"/releases/v4.10.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___10___0-_LPAR_2024-07-31_RPAR_--Language-features___-tactics___-and-metaprograms"},"/releases/v4.3.0/#release-v4___3___0":{"contents":"* simp [f] does not unfold partial applications of f anymore. See issue #2042.\nTo fix proofs affected by this change, use unfold f or simp (config := { unfoldPartialApp := true }) [f].* By default, simp will no longer try to use Decidable instances to rewrite terms. In particular, not all decidable goals will be closed by simp, and the decide tactic may be useful in such cases. The decide simp configuration option can be used to locally restore the old simp behavior, as in simp (config := {decide := true}); this includes using Decidable instances to verify side goals such as numeric inequalities.* Many bug fixes:* Add left/right actions to term tree coercion elaborator and make `^`` a right action* Fix for #2775, don't catch max recursion depth errors* Reduction of Decidable instances very slow when using cases tactic* simp not rewriting in binder* simp unfolding let even with zeta := false option* simp (with beta/zeta disabled) and discrimination trees* unknown free variable introduced by rw ... at h* dsimp doesn't use rfl theorems which consist of an unapplied constant* dsimp does not close reflexive equality goals if they are wrapped in metadata* rw [h] uses h from the environment in preference to h from the local context* missing withAssignableSyntheticOpaque for assumption tactic* ignoring default value for field warning* Cancel outstanding tasks on document edit in the language server.* Remove unnecessary % operations in Fin.mod and Fin.div* Avoid DecidableEq in Array.mem* Ensure USize.size unifies with ?m + 1* Improve compatibility with emacs eglot client\n\nLake:\n\n* Sensible defaults for lake new MyProject math* Changed postUpdate? configuration option to a post_update declaration. See the post_update syntax docstring for more information on the new syntax.* A manifest is automatically created on workspace load if one does not exists..* The := syntax for configuration declarations (i.e., package, lean_lib, and lean_exe) has been deprecated. For example, package foo := {...} is deprecated.* support for overriding package URLs via LAKE_PKG_URL_MAP* Moved the default build directory (e.g., build), default packages directory (e.g., lake-packages), and the compiled configuration (e.g., lakefile.olean) into a new dedicated directory for Lake outputs, .lake. The cloud release build archives are also stored here, fixing #2713.* Update manifest format to version 7 (see lean4#2801 for details on the changes).* Deprecate the manifestFile field of a package configuration.* There is now a more rigorous check on lakefile.olean compatibility (see #2842 for more details).\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.3.0 (2023-11-30)","id":"/releases/v4.3.0/#release-v4___3___0"}});