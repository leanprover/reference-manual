window.docContents[58].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Creation":{"contents":"Creates a new empty hash set. The optional parameter capacity can be supplied to presize the\nset so that it can hold the given number of elements without reallocating. It is also possible to\nuse the empty collection notations ∅ and {} to create an empty hash set with the default\ncapacity.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"19.18.6.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Creation"},"/Coercions/Coercing-Between-Types/#nat-api-cast":{"contents":"The type classes NatCast and IntCast are special cases of Coe that are used to define a coercion from Nat or Int to some other type that is in some sense canonical.\nThey exist to enable better integration with large libraries of mathematics, such as Mathlib, that make heavy use of coercions to map from the natural numbers or integers to other structures (typically rings).\nIdeally, the coercion of a natural number or integer into these structures is a simp normal form, because it is a convenient way to denote them.\n\nWhen the coercion application is expected to be the simp normal form for a type, it is important that all such coercions are definitionally equal in practice.\nOtherwise, the simp normal form would need to choose a single chained coercion path, but lemmas could accidentally be stated using a different path.\nBecause simp's internal index is based on the underlying structure of the term, rather than its presentation in the surface syntax, these differences would cause the lemmas to not be applied where expected.\nNatCast and IntCast instances, on the other hand, should be defined such that they are always definitionally equal, avoiding the problem.\nThe Lean standard library's instances are arranged such that NatCast or IntCast instances are chosen preferentially over chains of coercion instances during coercion insertion.\nThey can also be used as CoeOut instances, allowing a graceful fallback to coercion chaining when needed.\n\nThe canonical homomorphism Nat → R. In most use cases, the target type will have a (semi)ring\nstructure, and this homomorphism should be a (semi)ring homomorphism.NatCast and IntCast exist to allow different libraries with their own types that can be notated\nas natural numbers to have consistent simp normal forms without needing to create coercion\nsimplification sets that are aware of all combinations. Libraries should make it easy to work with\nNatCast where possible. For instance, in Mathlib there will be such a homomorphism (and thus a\nNatCast R instance) whenever R is an additive monoid with a 1.The prototypical example is Int.ofNat.The canonical map Nat → R.\n\nThe canonical homomorphism Nat → R. In most use cases, the target type will have a (semi)ring\nstructure, and this homomorphism should be a (semi)ring homomorphism.NatCast and IntCast exist to allow different libraries with their own types that can be notated\nas natural numbers to have consistent simp normal forms without needing to create coercion\nsimplification sets that are aware of all combinations. Libraries should make it easy to work with\nNatCast where possible. For instance, in Mathlib there will be such a homomorphism (and thus a\nNatCast R instance) whenever R is an additive monoid with a 1.The prototypical example is Int.ofNat.\n\nThe canonical homomorphism Int → R. In most use cases, the target type will have a ring structure,\nand this homomorphism should be a ring homomorphism.IntCast and NatCast exist to allow different libraries with their own types that can be notated\nas natural numbers to have consistent simp normal forms without needing to create coercion\nsimplification sets that are aware of all combinations. Libraries should make it easy to work with\nIntCast where possible. For instance, in Mathlib there will be such a homomorphism (and thus an\nIntCast R instance) whenever R is an additive group with a 1.The canonical map Int → R.\n\nThe canonical homomorphism Int → R. In most use cases, the target type will have a ring structure,\nand this homomorphism should be a ring homomorphism.IntCast and NatCast exist to allow different libraries with their own types that can be notated\nas natural numbers to have consistent simp normal forms without needing to create coercion\nsimplification sets that are aware of all combinations. Libraries should make it easy to work with\nIntCast where possible. For instance, in Mathlib there will be such a homomorphism (and thus an\nIntCast R instance) whenever R is an additive group with a 1.\n\n","context":"Lean Reference\u0009Coercions\u0009Coercing Between Types","header":"12.2.2. Coercions from Natural Numbers and Integers","id":"/Coercions/Coercing-Between-Types/#nat-api-cast"},"/Notations-and-Macros/Elaborators/#The-Lean-Language-Reference--Notations-and-Macros--Elaborators--Term-Elaborators":{"contents":"A term elaborator has type TermElab, which is an abbreviation for Syntax → Option Expr → TermElabM Expr.\nThe optional Expr parameter is the type expected for the term being elaborated, which is none if no type is yet known.\nLike command elaborators, term elaborators may be implicitly defined using elab_rules, or explicitly by defining a function and applying the term_elab attribute.Avoiding a TypeThis examples demonstrates an elaborator for syntax that is the opposite of a type ascription.\nThe provided term may have any type other than the one indicated, and metavariables are solved pessimistically.\nIn this example, elabType invokes the term elaborator and then ensures that the resulting term is a type.\nMeta.inferType infers a type for a term, and Meta.isDefEq attempts to make two terms definitionally equal by unification, returning true if it succeeds.syntax (name := notType) \"(\" term  \" !: \" term \")\" : term\n\n@[term_elab notType]\ndef elabNotType : TermElab := fun stx _ => do\n  let `(($tm:term !: $ty:term)) := stx\n    | throwUnsupportedSyntax\n  let unexpected ← elabType ty\n  let e ← elabTerm tm none\n  let eTy ← Meta.inferType e\n  if (← Meta.isDefEq eTy unexpected) then\n    throwErrorAt tm m!\"Got unwanted type {eTy}\"\n  else pure e\nIf the type position does not contain a type, then elabType throws an error:#eval ([1, 2, 3] !: \"not a type\")\ntype expected, got\n  (\"not a type\" : String)\nIf the term's type is definitely not equal to the provided type, then elaboration succeeds:#eval ([1, 2, 3] !: String)\n[1, 2, 3]\nIf the types match, an error is thrown:#eval (5 !: Nat)\nGot unwanted type Nat\nThe type equality check may fill in missing information, so sorry (which may have any type) is also rejected:#eval (sorry !: String)\nGot unwanted type String\nUsing Any Local VariableTerm elaborators have access to the expected type and to the local context.\nThis can be used to create a term analogue of the assumption tactic.The first step is to access the local context using getLocalHyps.\nIt returns the context with the outermost bindings on the left, so it is traversed in reverse order.\nFor each local assumption, a type is inferred with Meta.inferType.\nIf it can be equal to the expected type, then the assumption is returned; if no assumption is suitable, then an error is produced.syntax \"anything!\" : term\n\nelab_rules <= expected\n  | `(anything!) => do\n    let hyps ← getLocalHyps\n    for h in hyps.reverse do\n      let t ← Meta.inferType h\n      if (← Meta.isDefEq t expected) then return h\n\n    throwError m!\"No assumption in {hyps} has type {expected}\"\nThe new syntax finds the function's bound variable:#eval (fun (n : Nat) => 2 + anything!) 5\n7\nIt chooses the most recent suitable variable, as desired:#eval\n  let x := \"x\"\n  let y := \"y\"\n  \"It was \" ++ y\n\"It was y\"\nWhen no assumption is suitable, it returns an error that describes the attempt:#eval\n  let x := Nat.zero\n  let y := \"hello\"\n  fun (f : Nat → Nat) =>\n    (anything! : Int → Int)\nNo assumption in [x, y, f] has type Int → Int\nBecause it uses unification, the natural number literal is chosen here, because numeric literals may have any type with an OfNat instance.\nUnfortunately, there is no OfNat instance for functions, so instance synthesis later fails.#eval\n  let x := 5\n  let y := \"hello\"\n  (anything! : Int → Int)\nfailed to synthesize\n  OfNat (Int → Int) 5\nnumerals are polymorphic in Lean, but the numeral `5` cannot be used in a context where the expected type is\n  Int → Int\ndue to the absence of the instance above\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Elaborators","header":"20.6.2. Term Elaborators","id":"/Notations-and-Macros/Elaborators/#The-Lean-Language-Reference--Notations-and-Macros--Elaborators--Term-Elaborators"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights":{"contents":"Lean v4.19.0 introduces a number of features, bug fixes, performance gains, library developments,\nalong with quality-of-life improvements across documentation, the language server, and Lake.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)","header":"Highlights","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Highlights"}});