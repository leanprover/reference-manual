window.docContents[79].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers","header":"19.3.3. API Reference","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference"},"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Reasoning":{"contents":"Proves a statement by induction on the underlying Nat value in a Fin (n + 1).For the induction:* zero is the base case, demonstrating motive 0.* succ is the inductive step, assuming the motive for i : Fin n (lifted to Fin (n + 1) with\nFin.castSucc) and demonstrating it for i.succ.Fin.inductionOn is a version of this induction principle that takes the Fin as its first\nparameter, Fin.cases is the corresponding case analysis operator, and Fin.reverseInduction is a\nversion that starts at the greatest value instead of 0.\n\nProves a statement by induction on the underlying Nat value in a Fin (n + 1).For the induction:* zero is the base case, demonstrating motive 0.* succ is the inductive step, assuming the motive for i : Fin n (lifted to Fin (n + 1) with\nFin.castSucc) and demonstrating it for i.succ.Fin.induction is a version of this induction principle that takes the Fin as its last\nparameter.\n\nProves a statement by reverse induction on the underlying Nat value in a Fin (n + 1).For the induction:* last is the base case, demonstrating motive (Fin.last n).* cast is the inductive step, assuming the motive for (j : Fin n).succ and demonstrating it for\nthe predecessor j.castSucc.Fin.induction is the non-reverse induction principle.\n\nProves a statement by cases on the underlying Nat value in a Fin (n + 1).The two cases are:* zero, used when the value is of the form (0 : Fin (n + 1))* succ, used when the value is of the form (j : Fin n).succThe corresponding induction principle is Fin.induction.\n\nProves a statement by cases on the underlying Nat value in a Fin (n + 1), checking whether the\nvalue is the greatest representable or a predecessor of some other.The two cases are:* last, used when the value is Fin.last n* cast, used when the value is of the form (j : Fin n).succThe corresponding induction principle is Fin.reverseInduction.\n\nA case analysis operator for i : Fin (m + n) that separately handles the cases where i < m and\nwhere m ≤ i < m + n.The first case, where i < m, is handled by left. In this case, i can be represented as\nFin.castAdd n (j : Fin m).The second case, where m ≤ i < m + n, is handled by right. In this case, i can be represented\nas Fin.natAdd m (j : Fin n).\n\nAn induction principle for Fin that considers a given i : Fin n as given by a sequence of i\napplications of Fin.succ.The cases in the induction are:* zero demonstrates the motive for (0 : Fin (n + 1)) for all bounds n* succ demonstrates the motive for Fin.succ applied to an arbitrary Fin for an arbitrary\nbound nUnlike Fin.induction, the motive quantifies over the bound, and the bound varies at each inductive\nstep. Fin.succRecOn is a version of this induction principle that takes the Fin argument first.\n\nAn induction principle for Fin that considers a given i : Fin n as given by a sequence of i\napplications of Fin.succ.The cases in the induction are:* zero demonstrates the motive for (0 : Fin (n + 1)) for all bounds n* succ demonstrates the motive for Fin.succ applied to an arbitrary Fin for an arbitrary\nbound nUnlike Fin.induction, the motive quantifies over the bound, and the bound varies at each inductive\nstep. Fin.succRec is a version of this induction principle that takes the Fin argument last.\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"19.3.3.6. Reasoning","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Reasoning"},"/The-Type-System/Inductive-Types/#inductive-type-universe-levels":{"contents":"Type constructors of inductive types must either inhabit a universe or a function type whose return type is a universe.\nEach constructor must inhabit a function type that returns a saturated application of the inductive type.\nIf the inductive type's universe is Prop, then there are no further restrictions on universes, because Prop is impredicative.\nIf the universe is not Prop, then the following must hold for each parameter to the constructor:\n\n* If the constructor's parameter is a parameter (in the sense of parameters vs indices) of the inductive type, then this parameter's type may be no larger than the type constructor's universe.* All other constructor parameters must be smaller than the type constructor's universe.\n\nUniverses, constructors, and parametersEither is in the greater of its arguments' universes, because both are parameters to the inductive type:inductive Either (α : Type u) (β : Type v) : Type (max u v) where\n  | inl : α → Either α β\n  | inr : β → Either α β\nCanRepr is in a larger universe than the constructor parameter α, because α is not one of the inductive type's parameters:inductive CanRepr : Type (u + 1) where\n  | mk : (α : Type u) → [Repr α] → CanRepr\nConstructorless inductive types may be in universes smaller than their parameters:inductive Spurious (α : Type 5) : Type 0 where\nIt would, however, be impossible to add a constructor to Spurious without changing its levels.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Well-Formedness Requirements","header":"4.4.3.2.1. Universe Levels","id":"/The-Type-System/Inductive-Types/#inductive-type-universe-levels"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Language":{"contents":"* #5145 splits the environment used by the kernel from that used by the\nelaborator, providing the foundation for tracking of asynchronously\nelaborated declarations, which will exist as a concept only in the\nlatter.* #6261 adds foo.fun_cases, an automatically generated theorem that\nsplits the goal according to the branching structure of foo, much like\nthe Functional Induction Principle, but for all functions (not just\nrecursive ones), and without providing inductive hypotheses.* #6355 adds the ability to define possibly non-terminating functions\nand still be able to reason about them equationally, as long as they are\ntail-recursive or monadic.* #6368 implements executing kernel checking in parallel to elaboration,\nwhich is a prerequisite for parallelizing elaboration itself.* #6427 adds the Lean CLI option --src-deps which parallels --deps.\nIt parses the Lean code's header and prints out the paths to the\n(transitively) imported modules' source files (deduced from\nLEAN_SRC_PATH).* #6486 modifies the induction/cases syntax so that the with\nclause does not need to be followed by any alternatives. This improves\nfriendliness of these tactics, since this lets them surface the names of\nthe missing alternatives:example (n : Nat) : True := by\n  induction n with\n/-            ~~~~\nalternative 'zero' has not been provided\nalternative 'succ' has not been provided\n-/\n* #6505 implements a basic async framework as well as asynchronously\nrunning timers using libuv.* #6516 enhances the cases tactic used in the grind tactic and\nensures that it can be applied to arbitrary expressions.* #6521 adds support for activating relevant match-equations as\nE-matching theorems. It uses the match-equation lhs as the pattern.* #6528 adds a missing propagation rule to the (WIP) grind tactic.* #6529 adds support for let-declarations to the (WIP) grind tactic.* #6530 fixes nondeterministic failures in the (WIP) grind tactic.* #6531 fixes the support for let_fun in grind.* #6533 adds support to E-matching offset patterns. For example, we want\nto be able to E-match the pattern f (#0 + 1) with term f (a + 2).* #6534 ensures that users can utilize projections in E-matching\npatterns within the grind tactic.* #6536 fixes different thresholds for controlling E-matching in the\ngrind tactic.* #6538 ensures patterns provided by users are normalized. See new test\nto understand why this is needed.* #6539 introduces the [grind_eq] attribute, designed to annotate\nequational theorems and functions for heuristic instantiations in the\ngrind tactic.\nWhen applied to an equational theorem, the [grind_eq] attribute\ninstructs the grind tactic to automatically use the annotated theorem\nto instantiate patterns during proof search. If applied to a function,\nit marks all equational theorems associated with that function.* #6543 adds additional tests for grind, demonstrating that we can\nautomate some manual proofs from Mathlib's basic category theory\nlibrary, with less reliance on Mathlib's @[reassoc] trick.* #6545 introduces the parametric attribute [grind] for annotating\ntheorems and definitions. It also replaces [grind_eq] with [grind =]. For definitions, [grind] is equivalent to [grind =].* #6556 adds propagators for implication to the grind tactic. It also\ndisables the normalization rule: (p → q) = (¬ p ∨ q)* #6559 adds a basic case-splitting strategy for the grind tactic. We\nstill need to add support for user customization.* #6565 fixes the location of the error emitted when the rintro and\nintro tactics cannot introduce the requested number of binders.* #6566 adds support for erasing the [grind] attribute used to mark\ntheorems for heuristic instantiation in the grind tactic.* #6567 adds support for erasing the [grind] attribute used to mark\ntheorems for heuristic instantiation in the grind tactic.* #6568 adds basic support for cast-like operators to the grind tactic.\nExample:example (α : Type) (β : Type) (a₁ a₂ : α) (b₁ b₂ : β)\n        (h₁ : α = β)\n        (h₂ : h₁ ▸ a₁ = b₁)\n        (h₃ : a₁ = a₂)\n        (h₄ : b₁ = b₂)\n        : HEq a₂ b₂ := by\n  grind\n* #6569 adds support for case splitting on match-expressions in\ngrind.\nWe still need to add support for resolving the antecedents of\nmatch-conditional equations.* #6575 ensures tactics are evaluated incrementally in the body of\nclassical.* #6578 fixes and improves the propagator for forall-expressions in the\ngrind tactic.* #6581 adds the following configuration options to Grind.Config:\nsplitIte, splitMatch, and splitIndPred.* #6582 adds support for creating local E-matching theorems for\nuniversal propositions known to be true. It allows grind to\nautomatically solve examples such as:* #6584 adds helper theorems to implement offset constraints in grind.* #6585 fixes a bug in the grind canonicalizer.* #6588 improves the grind canonicalizer diagnostics.* #6593 adds support for the simp? and dsimp? tactics in conversion\nmode.* #6595 improves the theorems used to justify the steps performed by the\ninequality offset module. See new test for examples of how they are\ngoing to be used.* #6600 removes functions from compiling decls from Environment, and\nmoves all users to functions on CoreM. This is required for supporting\nthe new code generator, since its implementation uses CoreM.* #6602 allows the dot ident notation to resolve to the current\ndefinition, or to any of the other definitions in the same mutual block.\nExisting code that uses dot ident notation may need to have nonrec\nadded if the ident has the same name as the definition.* #6603 implements support for offset constraints in the grind tactic.\nSeveral features are still missing, such as constraint propagation and\nsupport for offset equalities, but grind can already solve examples\nlike the following:* #6606 fixes a bug in the pattern selection in the grind.* #6607 adds support for case-splitting on <-> (and @Eq Prop) in the\ngrind tactic.* #6608 fixes a bug in the simp_arith tactic. See new test.* #6609 improves the case-split heuristic used in grind, prioritizing\ncase-splits with fewer cases.* #6610 fixes a bug in the grind core module responsible for merging\nequivalence classes and propagating constraints.* #6611 fixes one of the sanity check tests used in grind.* #6613 improves the case split heuristic used in the grind tactic,\nensuring it now avoids unnecessary case-splits on Iff.* #6614 improves the usability of the [grind =] attribute by\nautomatically handling\nforbidden pattern symbols. For example, consider the following theorem\ntagged with this attribute:getLast?_eq_some_iff {xs : List α} {a : α} : xs.getLast? = some a ↔ ∃ ys, xs = ys ++ [a]\nHere, the selected pattern is xs.getLast? = some a, but Eq is a\nforbidden pattern symbol.\nInstead of producing an error, this function converts the pattern into a\nmulti-pattern,\nallowing the attribute to be used conveniently.* #6615 adds two auxiliary functions mkEqTrueCore and mkOfEqTrueCore\nthat avoid redundant proof terms in proofs produced by grind.* #6618 implements exhaustive offset constraint propagation in the\ngrind tactic. This enhancement minimizes the number of case splits\nperformed by grind. For instance, it can solve the following example\nwithout performing any case splits:* #6633 improves the failure message produced by the grind tactic. We\nnow include information about asserted facts, propositions that are\nknown to be true and false, and equivalence classes.* #6636 implements model construction for offset constraints in the\ngrind tactic.* #6639 puts the bv_normalize simp set into simp_nf and splits up the\nbv_normalize implementation across multiple files in preparation for\nupcoming changes.* #6641 implements several optimisation tricks from Bitwuzla's\npreprocessing passes into the Lean equivalent in bv_decide. Note that\nthese changes are mostly geared towards large proof states as for\nexample seen in SMT-Lib.* #6645 implements support for offset equality constraints in the\ngrind tactic and exhaustive equality propagation for them. The grind\ntactic can now solve problems such as the following:* #6648 adds support for numerals, lower & upper bounds to the offset\nconstraint module in the grind tactic. grind can now solve examples\nsuch as:example (f : Nat → Nat) :\n        f 2 = a →\n        b ≤ 1 → b ≥ 1 →\n        c = b + 1 →\n        f c = a := by\n  grind\nIn the example above, the literal 2 and the lower&upper bounds, b ≤ 1 and b ≥ 1, are now processed by offset constraint module.* #6649 fixes a bug in the term canonicalizer used in the grind\ntactic.* #6652 adds the int_toBitVec simp set to convert UIntX and later IntX\npropositions to BitVec ones. This will be used as a preprocessor for bv_decide to provide UIntX/IntX bv_decide support.* #6653 improves the E-matching pattern selection heuristics in the\ngrind tactic. They now take into account type predicates and\ntransformers.* #6654 improves the support for partial applications in the E-matching\nprocedure used in grind.* #6656 improves the diagnostic information provided in grind failure\nstates. We now include the list of issues found during the search, and\nall search thresholds that have been reached. also improves its\nformatting.* #6657 improves the grind search procedure, and adds the new\nconfiguration option: failures.* #6658 ensures that grind avoids case-splitting on terms congruent to\nthose that have already been case-split.* #6659 fixes a bug in the grind term preprocessor. It was abstracting\nnested proofs before reducible constants were unfolded.* #6662 improves the canonicalizer used in the grind tactic and the\ndiagnostics it produces. It also adds a new configuration option,\ncanonHeartbeats, to address (some of) the issues. Here is an example\nillustrating the new diagnostics, where we intentionally create a\nproblem by using a very small number of heartbeats.* #6663 implements a basic equality resolution procedure for the grind\ntactic.* #6669 adds a workaround for the discrepancy between Terminal/Emacs and\nVS Code when displaying info trees.* #6675 adds simp-like parameters to grind, and grind only similar\nto simp only.* #6679 changes the identifier parser to allow for the ⱼ unicode\ncharacter which was forgotten as it lives by itself in a codeblock with\ncoptic characters.* #6682 adds support for extensionality theorems (using the [ext]\nattribute) to the grind tactic. Users can disable this functionality\nusing grind -ext . Below are examples that demonstrate problems now\nsolvable by grind.* #6685 fixes the issue that #check_failure's output is warning* #6686 fixes parameter processing, initialization, and attribute\nhandling issues in the grind tactic.* #6691 introduces the central API for making parallel changes to the\nenvironment* #6692 removes the [grind_norm] attribute. The normalization theorems\nused by grind are now fixed and cannot be modified by users. We use\nnormalization theorems to ensure the built-in procedures receive term\nwish expected \"shapes\". We use it for types that have built-in support\nin grind. Users could misuse this feature as a simplification rule. For\nexample, consider the following example:* #6700 adds support for beta reduction in the grind tactic. grind\ncan now solve goals such asexample (f : Nat → Nat) : f = (fun x : Nat => x + 5) → f 2 > 5 := by\n  grind\n* #6702 adds support for equality backward reasoning to grind. We can\nillustrate the new feature with the following example. Suppose we have a\ntheorem:theorem inv_eq {a b : α} (w : a * b = 1) : inv a = b\nand we want to instantiate the theorem whenever we are tying to prove\ninv t = s for some terms t and s\nThe attribute [grind ←] is not applicable in this case because, by\ndefault, = is not eligible for E-matching. The new attribute [grind ←=] instructs grind to use the equality and consider disequalities in\nthe grind proof state as candidates for E-matching.* #6705 adds the attributes [grind cases] and [grind cases eager]\nfor controlling case splitting in grind. They will replace the\n[grind_cases] and the configuration option splitIndPred.* #6711 adds support for UIntX and USize in bv_decide by adding a\npreprocessor that turns them into BitVec of their corresponding size.* #6717 introduces a new feature that allows users to specify which\ninductive datatypes the grind tactic should perform case splits on.\nThe configuration option splitIndPred is now set to false by\ndefault. The attribute [grind cases] is used to mark inductive\ndatatypes and predicates that grind may case split on during the\nsearch. Additionally, the attribute [grind cases eager] can be used to\nmark datatypes and predicates for case splitting both during\npre-processing and the search.* #6718 adds BitVec lemmas required to cancel multiplicative negatives,\nand plumb support through to bv_normalize to make use of this result in\nthe normalized twos-complement form.* #6719 fixes a bug in the equational theorem generator for\nmatch-expressions. See new test for an example.* #6724 adds support for bv_decide to automatically split up\nnon-recursive structures that contain information about supported types.\nIt can be controlled using the new structures field in the bv_decide\nconfig.* #6733 adds better support for overlapping match patterns in grind.\ngrind can now solve examples such asinductive S where\n  | mk1 (n : Nat)\n  | mk2 (n : Nat) (s : S)\n  | mk3 (n : Bool)\n  | mk4 (s1 s2 : S)\n\ndef f (x y : S) :=\n  match x, y with\n  | .mk1 _, _ => 2\n  | _, .mk2 1 (.mk4 _ _) => 3\n  | .mk3 _, _ => 4\n  | _, _ => 5\n\nexample : b = .mk2 y1 y2 → y1 = 2 → a = .mk4 y3 y4 → f a b = 5 := by\n  unfold f\n  grind (splits := 0)\n* #6735 adds support for case splitting on match-expressions with\noverlapping patterns to the grind tactic. grind can now solve\nexamples such as:inductive S where\n  | mk1 (n : Nat)\n  | mk2 (n : Nat) (s : S)\n  | mk3 (n : Bool)\n  | mk4 (s1 s2 : S)\n\ndef g (x y : S) :=\n  match x, y with\n  | .mk1 a, _ => a + 2\n  | _, .mk2 1 (.mk4 _ _) => 3\n  | .mk3 _, .mk4 _ _ => 4\n  | _, _ => 5\n\nexample : g a b > 1 := by\n  grind [g.eq_def]\n* #6736 ensures the canonicalizer used in grind does not waste time\nchecking whether terms with different types are definitionally equal.* #6737 ensures that the branches of an if-then-else term are\ninternalized only after establishing the truth value of the condition.\nThis change makes its behavior consistent with the match-expression\nand dependent if-then-else behavior in grind.\nThis feature is particularly important for recursive functions defined\nby well-founded recursion and if-then-else. Without lazy\nif-then-else branch internalization, the equation theorem for the\nrecursive function would unfold until reaching the generation depth\nthreshold, and before performing any case analysis. See new tests for an\nexample.* #6739 adds a fast path for bitblasting multiplication with constants\nin bv_decide.* #6740 extends bv_decide's structure reasoning support for also\nreasoning about equalities of supported structures.* #6745 supports rewriting ushiftRight in terms of extractLsb'. This\nis the companion PR to #6743 which adds the similar lemmas about\nshiftLeft.* #6746 ensures that conditional equation theorems for function\ndefinitions are handled correctly in grind. We use the same\ninfrastructure built for match-expression equations. Recall that in\nboth cases, these theorems are conditional when there are overlapping\npatterns.* #6748 fixes a few bugs in the grind tactic: missing issues, bad\nerror messages, incorrect threshold in the canonicalizer, and bug in the\nground pattern internalizer.* #6750 adds support for fixing type mismatches using cast while\ninstantiating quantifiers in the E-matching module used by the grind\ntactic.* #6754 adds the +zetaUnused option.* #6755 implements the zetaUnused simp and reduction option (added in\n#6754).* #6761 fixes issues in grind when processing match-expressions with\nindexed families.* #6773 fixes a typo that prevented Nat.reduceAnd from working\ncorrectly.* #6777 fixes a bug in the internalization of offset terms in the\ngrind tactic. For example, grind was failing to solve the following\nexample because of this bug.example (f : Nat → Nat) : f (a + 1) = 1 → a = 0 → f 1 = 1 := by\n  grind\n* #6778 fixes the assignment produced by grind to satisfy the offset\nconstraints in a goal.* #6779 improves the support for match-expressions in the grind\ntactic.* #6781 fixes the support for case splitting on data in the grind\ntactic. The following example works now:inductive C where\n  | a | b | c\n\ndef f : C → Nat\n  | .a => 2\n  | .b => 3\n  | .c => 4\n\nexample : f x > 1 := by\n  grind [\n      f, -- instructs `grind` to use `f`-equation theorems,\n      C -- instructs `grind` to case-split on free variables of type `C`\n  ]\n* #6783 adds support for closing goals using match-expression\nconditions that are known to be true in the grind tactic state.\ngrind can now solve goals such as:def f : List Nat → List Nat → Nat\n  | _, 1 :: _ :: _ => 1\n  | _, _ :: _ => 2\n  | _, _  => 0\n\nexample : z = a :: as → y = z → f x y > 0\n* #6785 adds infrastructure for the grind? tactic. It also adds the\nnew modifier usr which allows users to write grind only [use thmName] to instruct grind to only use theorem thmName, but using\nthe patterns specified with the command grind_pattern.* #6788 teaches bv_normalize that !(x < x) and !(x < 0).* #6790 fixes an issue with the generation of equational theorems from\npartial_fixpoint when case-splitting is necessary. Fixes #6786.* #6791 fixes #6789 by ensuring metadata generated for inaccessible\nvariables in pattern-matches is consumed in casesOnStuckLHS\naccordingly.* #6801 fixes a bug in the exhaustive offset constraint propagation\nmodule used in grind.* #6810 implements a basic grind? tactic companion for grind. We\nwill add more bells and whistles later.* #6822 adds a few builtin case-splits for grind. They are similar to\nbuiltin simp theorems. They reduce the noise in the tactics produced\nby grind?.* #6824 introduces the auxiliary command %reset_grind_attrs for\ndebugging purposes. It is particularly useful for writing self-contained\ntests.* #6834 adds \"performance\" counters (e.g., number of instances per\ntheorem) to grind. The counters are always reported on failures, and\non successes when set_option diagnostics true.* #6839 ensures grind can use constructors and axioms for heuristic\ninstantiation based on E-matching. It also allows patterns without\npattern variables for theorems such as theorem evenz : Even 0.* #6851 makes bv_normalize rewrite shifts by BitVec constants to\nshifts by Nat constants. This is part of the greater effort in\nproviding good support for constant shift simplification in\nbv_normalize.* #6852 allows environment extensions to opt into access modes that do\nnot block on the entire environment up to this point as a necessary\nprerequisite for parallel proof elaboration.* #6854 adds a convenience for inductive predicates in grind. Now,\ngive an inductive predicate C, grind [C] marks C terms as\ncase-split candidates and C constructors as E-matching theorems.\nHere is an example:example {B S T s t} (hcond : B s) : (ifThenElse B S T, s) ==> t → (S, s) ==> t := by\n  grind [BigStep]\nUsers can still use grind [cases BigStep] to only mark C as a case\nsplit candidate.* #6858 adds new propagation rules for decide and equality in grind.\nIt also adds new tests and cleans old ones* #6861 adds propagation rules for Bool.and, Bool.or, and Bool.not\nto the grind tactic.* #6870 adds two new normalization steps in grind that reduces a != b and a == b to decide (¬ a = b) and decide (a = b),\nrespectively.* #6879 fixes a bug in mkMatchCondProf? used by the grind tactic.\nThis bug was introducing a failure in the test grind_constProp.lean.* #6880 improves the E-matching pattern selection heuristic used in\ngrind.* #6881 improves the grind error message by including a trace of the\nterms on which grind applied cases-like operations.* #6882 ensures grind auxiliary gadgets are \"hidden\" in error and\ndiagnostic messages.* #6888 adds the [grind intro] attribute. It instructs grind to mark\nthe introduction rules of an inductive predicate as E-matching theorems.* #6889 inlines a few functions in the bv_decide circuit cache.* #6892 fixes a bug in the pattern selection heuristic used in grind.\nIt was unfolding definitions/abstractions that were not supposed to be\nunfolded. See grind_constProp.lean for examples affected by this bug.* #6895 fixes a few grind issues exposed by the grind_constProp.lean\ntest.* Support for equational theorem hypotheses created before invoking\ngrind. Example: applying an induction principle.s* Support of Unit-like types.* Missing recursion depth checks.* #6897 adds the new attributes [grind =>] and [grind <=] for\ncontrolling pattern selection and minimizing the number of places where\nwe have to use verbose grind_pattern command. It also fixes a bug in\nthe new pattern selection procedure, and improves the automatic pattern\nselection for local lemmas.* #6904 adds the grind configuration option verbose. For example,\ngrind -verbose disables all diagnostics. We are going to use this flag\nto implement try?.* #6905 adds the try? tactic; see above\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Language","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Language"}});