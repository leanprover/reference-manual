window.docContents[133].resolve({"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Comparisons":{"contents":"Checks whether two lists have the same length and their elements are pairwise BEq. Normally used\nvia the == operator.\n\nReturns true if as and bs have the same length and they are pairwise related by eqv.O(min |as| |bs|). Short-circuits at the first non-related pair of elements.Examples:* [1, 2, 3].isEqv [2, 3, 4] (· < ·) = true* [1, 2, 3].isEqv [2, 2, 4] (· < ·) = false* [1, 2, 3].isEqv [2, 3] (· < ·) = false\n\nReturns true if l₁ and l₂ are permutations of each other. O(|l₁| * |l₂|).The relation List.Perm is a logical characterization of permutations. When the BEq α instance\ncorresponds to DecidableEq α, isPerm l₁ l₂ ↔ l₁ ~ l₂ (use the theorem isPerm_iff).\n\nChecks whether the first list is a prefix of the second.The relation List.IsPrefixOf expresses this property with respect to logical equality.Examples:* [1, 2].isPrefixOf [1, 2, 3] = true* [1, 2].isPrefixOf [1, 2] = true* [1, 2].isPrefixOf [1] = false* [1, 2].isPrefixOf [1, 1, 2, 3] = false\n\nIf the first list is a prefix of the second, returns the result of dropping the prefix.In other words, isPrefixOf? l₁ l₂ returns some t when l₂ == l₁ ++ t.Examples:* [1, 2].isPrefixOf? [1, 2, 3] = some [3]* [1, 2].isPrefixOf? [1, 2] = some []* [1, 2].isPrefixOf? [1] = none* [1, 2].isPrefixOf? [1, 1, 2, 3] = none\n\nTrue if the first list is a potentially non-contiguous sub-sequence of the second list, comparing\nelements with the == operator.The relation List.Sublist is a logical characterization of this property.Examples:* [1, 3].isSublist [0, 1, 2, 3, 4] = true* [1, 3].isSublist [0, 1, 2, 4] = false\n\nChecks whether the first list is a suffix of the second.The relation List.IsSuffixOf expresses this property with respect to logical equality.Examples:* [2, 3].isSuffixOf [1, 2, 3] = true* [2, 3].isSuffixOf [1, 2, 3, 4] = false* [2, 3].isSuffixOf [1, 2] = false* [2, 3].isSuffixOf [1, 1, 2, 3] = true\n\nIf the first list is a suffix of the second, returns the result of dropping the suffix from the\nsecond.In other words, isSuffixOf? l₁ l₂ returns some t when l₂ == t ++ l₁.Examples:* [2, 3].isSuffixOf? [1, 2, 3] = some [1]* [2, 3].isSuffixOf? [1, 2, 3, 4] = none* [2, 3].isSuffixOf? [1, 2] = none* [2, 3].isSuffixOf? [1, 1, 2, 3] = some [1, 1]\n\nNon-strict ordering of lists with respect to a strict ordering of their elements.as ≤ bs if ¬ bs < as.This relation can be treated as a lexicographic order if the underlying LT α instance is\nwell-behaved. In particular, it should be irreflexive, asymmetric, and antisymmetric. These\nrequirements are precisely formulated in List.cons_le_cons_iff. If these hold, then as ≤ bs if\nand only if:* as is empty, or* both as and bs are non-empty, and the head of as is less than the head of bs, or* both as and bs are non-empty, their heads are equal, and the tail of as is less than or\nequal to the tail of bs.\n\nLexicographic ordering of lists with respect to an ordering on their elements.as < bs if* as is empty and bs is non-empty, or* both as and bs are non-empty, and the head of as is less than the head of bs, or* both as and bs are non-empty, their heads are equal, and the tail of as is less than the\ntail of bs.\n\nCompares lists lexicographically with respect to a comparison on their elements.The lexicographic order with respect to lt is:* [].lex (b :: bs) is true* as.lex [] = false is false* (a :: as).lex (b :: bs) is true if lt a b or a == b and lex lt as bs is true.\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","header":"19.15.3.14. Comparisons","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Comparisons"},"/Basic-Types/Natural-Numbers/#peano-axioms":{"contents":"The Peano axioms are a consequence of this definition.\nThe induction principle generated for Nat is the one demanded by the axiom of induction:\n\nNat.rec.{u} {motive : Nat → Sort u}\n  (zero : motive zero)\n  (succ : (n : Nat) → motive n → motive n.succ)\n  (t : Nat) :\n  motive t\n\n\nThis induction principle also implements primitive recursion.\nThe injectivity of Nat.succ and the disjointness of Nat.succ and Nat.zero are consequences of the induction principle, using a construction typically called “no confusion”:\n\ndef NoConfusion : Nat → Nat → Prop\n  | 0, 0 => True\n  | 0, _ + 1 | _ + 1, 0 => False\n  | n + 1, k + 1 => n = k\n\ntheorem noConfusionDiagonal (n : Nat) :\n    NoConfusion n n :=\n  Nat.rec True.intro (fun _ _ => rfl) n\n\ntheorem noConfusion (n k : Nat) (eq : n = k) :\n    NoConfusion n k :=\n  eq ▸ noConfusionDiagonal n\n\ntheorem succ_injective : n + 1 = k + 1 → n = k :=\n  noConfusion (n + 1) (k + 1)\n\ntheorem succ_not_zero : ¬n + 1 = 0 :=\n  noConfusion (n + 1) 0\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009Logical Model","header":"19.1.1.1. Peano Axioms","id":"/Basic-Types/Natural-Numbers/#peano-axioms"},"/Build-Tools-and-Distribution/Lake/#lake":{"contents":"Lake is the standard Lean build tool.\nIt is responsible for:\n\n* Configuring builds and building Lean code* Fetching and building external dependencies* Integrating with Reservoir, the Lean package server* Running tests, linters, and other development workflows\n\nLake is extensible.\nIt provides a rich API that can be used to define incremental build tasks for software artifacts that are not written in Lean, to automate administrative tasks, and to integrate with external workflows.\nFor build configurations that do not need these features, Lake provides a declarative configuration language that can be written either in TOML or as a Lean file.\n\nThis section describes Lake's command-line interface, configuration files, and internal API.\nAll three share a set of concepts and terminology.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools","header":"22.1. Lake","id":"/Build-Tools-and-Distribution/Lake/#lake"},"/The-Module-System/Visibility/#The-Lean-Language-Reference--The-Module-System--Visibility--Import-Visibility":{"contents":"The basic form public import M makes the public scope of M available in the public scope of the current module. The private scope of M is discarded.\nWithout public, the public scope of M is instead imported into the private scope.\nThe import thus is irrelevant to downstream modules and ignored by them.\n\nimport all M behaves like import M but additionally imports the private scope of M into the private scope of the current module.\nThis is only allowed if M and the current module have the same module name root, as its main purpose is to allow for separating definitions and proofs into separate modules for internal organization of a library.\n\n-- Module M.Defs\nmodule\n\npublic def f : Nat := 0\n\n\n-- Module M.Lemmas\nmodule\n\nimport all M.Defs\n\npublic theorem f_eq_zero : f = 0 :=\n  -- may access body of `f` imported into the private scope\n  rfl\n\n\nNote that the imported private scope includes private imports of M, including nested import alls that then are interpreted likewise.\nThat is, the set of private scopes accessible to the current module is the transitive closure of import all declarations.\n\nThe module system's import all is more powerful than import without the module system.\nIt makes imported private definitions accessible directly by name, as if they were defined in the current module.\nThus another use case of import all is to make declarations available that need to be used in multiple modules but should not leak outside the current library.\n\npublic import all M behaves like public import M followed by import all M, i.e. the all modifier becomes irrelevant for downstream modules.\n\n","context":"Lean Reference\u0009The Module System\u0009Visibility","header":"Import Visibility","id":"/The-Module-System/Visibility/#The-Lean-Language-Reference--The-Module-System--Visibility--Import-Visibility"},"/The-Simplifier/#the-simplifier":{"contents":"The simplifier is one of the most-used features of Lean.\nIt performs inside-out rewriting of terms based on a database of simplification rules.\nThe simplifier is highly configurable, and a number of tactics use it in different ways.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"16. The Simplifier","id":"/The-Simplifier/#the-simplifier"},"/The-Type-System/Functions/#totality":{"contents":"Functions can be defined recursively using def.\nFrom the perspective of Lean's logic, all functions are total, meaning that they map each element of the domain to an element of the codomain in finite time.Some programming language communities use the term total in a different sense, where functions are considered total if they do not crash due to unhandled cases but non-termination is ignored.\nThe values of total functions are defined for all type-correct arguments, and they cannot fail to terminate or crash due to a missing case in a pattern match.\n\nWhile the logical model of Lean considers all functions to be total, Lean is also a practical programming language that provides certain \"escape hatches\".\nFunctions that have not been proven to terminate can still be used in Lean's logic as long as their codomain is proven nonempty.\nThese functions are treated as uninterpreted functions by Lean's logic, and their computational behavior is ignored.\nIn compiled code, these functions are treated just like any others.\nOther functions may be marked unsafe; these functions are not available to Lean's logic at all.\nThe section on partial and unsafe function definitions contains more detail on programming with recursive functions.\n\nSimilarly, operations that should fail at runtime in compiled code, such as out-of-bounds access to an array, can only be used when the resulting type is known to be inhabited.\nThese operations result in an arbitrarily chosen inhabitant of the type in Lean's logic (specifically, the one specified in the type's Inhabited instance).\n\nPanicThe function thirdChar extracts the third element of an array, or panics if the array has two or fewer elements:def thirdChar (xs : Array Char) : Char := xs[2]!\nThe (nonexistent) third elements of #['!'] and #['-', 'x'] are equal, because they result in the same arbitrarily-chosen character:example : thirdChar #['!'] = thirdChar #['-', 'x'] := rfl\nIndeed, both are equal to 'A', which happens to be the default fallback for Char:example : thirdChar #['!'] = 'A' := rfl\nexample : thirdChar #['-', 'x'] = 'A' := rfl\n\n\n","context":"Lean Reference\u0009Type System\u0009Functions","header":"4.1.4. Totality and Termination","id":"/The-Type-System/Functions/#totality"},"/The-Type-System/Inductive-Types/#example-inductive-types":{"contents":"A constructorless typeVacant is an empty inductive type, equivalent to Lean's Empty type:inductive Vacant : Type where\nEmpty inductive types are not useless; they can be used to indicate unreachable code.\n\nA constructorless propositionNo is a false proposition, equivalent to Lean's False:inductive No : Prop where\n\n\nA unit typeSolo is equivalent to Lean's Unit type:inductive Solo where\n  | solo\nIt is an example of an inductive type in which the signatures have been omitted for both the type constructor and the constructor.\nLean assigns Solo to Type:#check Solo\nSolo : Type\nThe constructor is named Solo.solo, because constructor names are the type constructor's namespace.\nBecause Solo expects no arguments, the signature inferred for Solo.solo is:#check Solo.solo\nSolo.solo : Solo\n\n\nA true propositionYes is equivalent to Lean's True proposition:inductive Yes : Prop where\n  | intro\nUnlike One, the new inductive type Yes is specified to be in the Prop universe.#check Yes\nYes : Prop\nThe signature inferred for Yes.intro is:#check Yes.intro\nYes.intro : Yes\n\n\nA type with parameter and indexAn EvenOddList α b is a list where α is the type of the data stored in the list and b is true when there are an even number of entries:inductive EvenOddList (α : Type u) : Bool → Type u where\n  | nil : EvenOddList α true\n  | cons : α → EvenOddList α isEven → EvenOddList α (not isEven)\nThis example is well typed because there are two entries in the list:example : EvenOddList String true :=\n  .cons \"a\" (.cons \"b\" .nil)\nThis example is not well typed because there are three entries in the list:example : EvenOddList String true :=\n  .cons \"a\" (.cons \"b\" (.cons \"c\" .nil))\nType mismatch\n  EvenOddList.cons \"a\" (EvenOddList.cons \"b\" (EvenOddList.cons \"c\" EvenOddList.nil))\nhas type\n  EvenOddList String !!!true\nbut is expected to have type\n  EvenOddList String true\nIn this declaration, α is a parameter, because it is used consistently in all occurrences of EvenOddList.\nb is an index, because different Bool values are used for it at different occurrences.\n\nParameters before and after the colonIn this example, both parameters are specified before the colon in Either's signature.inductive Either (α : Type u) (β : Type v) : Type (max u v) where\n  | left : α → Either α β\n  | right : β → Either α β\nIn this version, there are two types named α that might not be identical:inductive Either' (α : Type u) (β : Type v) : Type (max u v) where\n  | left : {α : Type u} → {β : Type v} → α → Either' α β\n  | right : β → Either' α β\nMismatched inductive type parameter in\n  Either' α β\nThe provided argument\n  α\nis not definitionally equal to the expected parameter\n  α✝\n\nNote: The value of parameter `α✝` must be fixed throughout the inductive declaration. Consider making this parameter an index if it must vary.\nPlacing the parameters after the colon results in parameters that can be instantiated by the constructors:inductive Either'' : Type u → Type v → Type (max u v + 1) where\n  | left : {α : Type u} → {β : Type v} → α → Either'' α β\n  | right : β → Either'' α β\nA larger universe is required for this type because constructor parameters must be in universes that are smaller than the inductive type's universe.\nEither''.right's type parameter is discovered via Lean's ordinary rules for automatic implicit parameters.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","header":"4.4.1.2. Example Inductive Types","id":"/The-Type-System/Inductive-Types/#example-inductive-types"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Library-updates":{"contents":"The Lean 4 library saw many changes that improve arithmetic reasoning, enhance data structure APIs,\nand refine library organization. Key changes include better support for bitwise operations, shifts,\nand conversions, expanded lemmas for Array, Vector, and List, and improved ordering definitions.\nSome modules have been reorganized for clarity, and internal refinements ensure greater consistency and correctness.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)\u0009Highlights","header":"Library updates","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Highlights--Library-updates"},"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Documentation":{"contents":"* #6549 fixes #6548.* #6638 correct the docstring of theorem Bitvec.toNat_add_of_lt* #6643 changes the macOS docs to indicate that Lean now requires\npkgconf to build.* #6646 changes the ubuntu docs to indicate that Lean now requires\npkgconf to build.* #6738 updates our lexical structure documentation to mention the newly\nsupported ⱼ which lives in a separate unicode block and is thus not\ncaptured by the current ranges.* #6885 fixes the name of the truncating integer division function in\nthe HDiv.hDiv docstring (which is shown when hovering over /). It\nwas changed from Int.div to Int.tdiv in #5301.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.17.0 (2025-03-03)","header":"Documentation","id":"/releases/v4.17.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___17___0-_LPAR_2025-03-03_RPAR_--Documentation"}});