window.docContents[104].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From-Bitvectors":{"contents":"Obtain the BitVec that contains the 2's complement representation of the ISize.\n\nObtains the ISize whose 2's complement representation is the given BitVec.\n\nObtain the BitVec that contains the 2's complement representation of the Int8.\n\nObtains the Int8 whose 2's complement representation is the given BitVec 8.\n\nObtain the BitVec that contains the 2's complement representation of the Int16.\n\nObtains the Int16 whose 2's complement representation is the given BitVec 16.\n\nObtain the BitVec that contains the 2's complement representation of the Int32.\n\nObtains the Int32 whose 2's complement representation is the given BitVec 32.\n\nObtain the BitVec that contains the 2's complement representation of the Int64.\n\nObtains the Int64 whose 2's complement representation is the given BitVec 64.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","header":"19.4.4.3.5. To and From Bitvectors","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From-Bitvectors"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Compiler":{"contents":"* #6928 makes extern decls evaluate as ⊤ rather than the default value\nof ⊥ in the LCNF elimDeadBranches analysis.* #6930 changes the name generation of specialized LCNF decls so they\ndon't strip macro scopes. This avoids name collisions for\nspecializations created in distinct macro scopes. Since the normal\nName.append function checks for the presence of macro scopes, we need to\nuse appendCore.* #6976 extends the behavior of the sync flag for Task.map/bind etc.\nto encompass synchronous execution even when they first have to wait on\ncompletion of the first task, drastically lowering the overhead of such\ntasks. Thus the flag is now equivalent to e.g. .NET's\nTaskContinuationOptions.ExecuteSynchronously.* #7037 relaxes the minimum required glibc version for Lean and Lean\nexecutables to 2.26 on x86-64 Linux* #7041 marks several LCNF-specific environment extensions as having an\nasyncMode of .sync rather than the default of .mainOnly, so they work\ncorrectly even in async contexts.* #7086 makes the arity reduction pass in the new code generator match\nthe old one when it comes to the behavior of decls with no used\nparameters. This is important, because otherwise we might create a\ntop-level decl with no params that contains unreachable code, which\nwould get evaluated unconditionally during initialization. This actually\nhappens when initializing Init.Core built with the new code generator.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Compiler","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Compiler"}});