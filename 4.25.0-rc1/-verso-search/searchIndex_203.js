window.docContents[203].resolve({"/Basic-Types/Natural-Numbers/#nat-syntax":{"contents":"Natural number literals are overridden using the OfNat type class, which is described in the section on literal syntax.\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers","header":"19.1.3. Syntax","id":"/Basic-Types/Natural-Numbers/#nat-syntax"},"/Terms/Numeric-Literals/#nat-literals":{"contents":"\n\nNatural numbers can be specified in several forms:\n\n* A sequence of digits 0 through 9 is a decimal literal* 0b or 0B followed by a sequence of one or more 0s and 1s is a binary literal* 0o or 0O followed by a sequence of one or more digits 0 through 7 is an octal literal* 0x or 0X followed by a sequence of one or more hex digits (0 through 9 and A through F, case-insensitive) is a hexadecimal literal\n\nAll numeric literals can also contain internal underscores, except for between the first two characters in a binary, octal, or hexadecimal literal.\nThese are intended to help groups of digits in natural ways, for instance 1_000_000 or 0x_c0de_cafe.\n(While it is possible to write the number 123 as 1_2__3, this is not recommended.)\n\nWhen Lean encounters a natural number literal n, it interprets it via the overloaded method OfNat.ofNat n.\nA default instance of OfNat Nat n ensures that the type Nat can be inferred when no other type information is present.\n\nThe class OfNat α n powers the numeric literal parser. If you write\n37 : α, Lean will attempt to synthesize OfNat α 37, and will generate\nthe term (OfNat.ofNat 37 : α).There is a bit of infinite regress here since the desugaring apparently\nstill contains a literal 37 in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro nat_lit 37. Raw number literals are always of type Nat.\nSo it would be more correct to say that Lean looks for an instance of\nOfNat α (nat_lit 37), and it generates the term (OfNat.ofNat (nat_lit 37) : α).The OfNat.ofNat function is automatically inserted by the parser when\nthe user writes a numeric literal like 1 : α. Implementations of this\ntypeclass can therefore customize the behavior of n : α based on n and\nα.\n\n\n\nCustom Natural Number LiteralsThe structure NatInterval represents an interval of natural numbers.structure NatInterval where\n  low : Nat\n  high : Nat\n  low_le_high : low ≤ high\n\ninstance : Add NatInterval where\n  add\n    | ⟨lo1, hi1, le1⟩, ⟨lo2, hi2, le2⟩ => ⟨lo1 + lo2, hi1 + hi2, by omega⟩\nAn OfNat instance allows natural number literals to be used to represent intervals:instance : OfNat NatInterval n where\n  ofNat := ⟨n, n, by omega⟩\n#eval (8 : NatInterval)\n{ low := 8, high := 8, low_le_high := _ }\n#eval (0b111 : NatInterval)\n{ low := 7, high := 7, low_le_high := _ }\n\n\nThere are no separate integer literals.\nTerms such as -5 consist of a prefix negation (which can be overloaded via the Neg type class) applied to a natural number literal.\n\n","context":"Lean Reference\u0009Terms\u0009Numeric Literals","header":"10.5.1. Natural Numbers","id":"/Terms/Numeric-Literals/#nat-literals"}});