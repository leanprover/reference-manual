window.docContents[231].resolve({"/Basic-Propositions/Truth/#true-false":{"contents":"Fundamentally, there are only two propositions in Lean: True and False.\nThe axiom of propositional extensionality (propext) allows propositions to be considered equal when they are logically equivalent, and every true proposition is logically equivalent to True.\nSimilarly, every false proposition is logically equivalent to False.\n\nTrue is an inductively defined proposition with a single constructor that takes no parameters.\nIt is always possible to prove True.\nFalse, on the other hand, is an inductively defined proposition with no constructors.\nProving it requires finding an inconsistency in the current context.\n\nBoth True and False are subsingletons; this means that they can be used to compute inhabitants of non-propositional types.\nFor True, this amounts to ignoring the proof, which is not informative.\nFor False, this amounts to a demonstration that the current code is unreachable and does not need to be completed.\n\nTrue is a proposition and has only an introduction rule, True.intro : True.\nIn other words, True is simply true, and has a canonical proof, True.intro\nFor more information: Propositional LogicTrue is true, and True.intro (or more commonly, trivial)\nis the proof.\n\nFalse is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. False elimination rule, False.rec,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: Propositional Logic\n\nFalse.elim : False → C says that from False, any desired proposition\nC holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.The target type is actually C : Sort u which means it works for both\npropositions and types. When executed, this acts like an \"unreachable\"\ninstruction: it is undefined behavior to run, but it will probably print\n\"unreachable code\". (You would need to construct a proof of false to run it\nanyway, which you can only do using sorry or unsound axioms.)\n\nDead Code and Subsingleton EliminationThe fourth branch in the definition of f is unreachable, so no concrete String value needs to be provided:def f (n : Nat) : String :=\n  if h1 : n < 11 then\n    \"Small\"\n  else if h2 : n > 13 then\n    \"Large\"\n  else if h3 : n % 2 = 1 then\n    \"Odd\"\n  else if h4 : n ≠ 12 then\n    False.elim (by omega)\n  else \"Twelve\"\nIn this example, False.elim indicates to Lean that the current local context is logically inconsistent: proving False suffices to abandon the branch.Similarly, the definition of g appears to have the potential to be non-terminating.\nHowever, the recursive call occurs on an unreachable path through the program.\nThe proof automation used for producing termination proofs can detect that the local assumptions are inconsistent.def g (n : Nat) : String :=\n  if n < 11 then\n    \"Small\"\n  else if n > 13 then\n    \"Large\"\n  else if n % 2 = 1 then\n    \"Odd\"\n  else if n ≠ 12 then\n    g (n + 1)\n  else \"Twelve\"\ntermination_by n\n\n\n","context":"Lean Reference\u0009Basic Propositions","header":"18.1. Truth","id":"/Basic-Propositions/Truth/#true-false"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Manipulation":{"contents":"Splits a slice at each subslice that matches the pattern pat.The subslices that matched the pattern are not included in any of the resulting subslices. If\nmultiple subslices in a row match the pattern, the resulting list will contain empty strings.This function is generic over all currently supported patterns.Examples:* (\"coffee tea water\".toSlice.split Char.isWhitespace).allowNontermination.toList == [\"coffee\".toSlice, \"tea\".toSlice, \"water\".toSlice]* (\"coffee tea water\".toSlice.split ' ').allowNontermination.toList == [\"coffee\".toSlice, \"tea\".toSlice, \"water\".toSlice]* (\"coffee tea water\".toSlice.split \" tea \").allowNontermination.toList == [\"coffee\".toSlice, \"water\".toSlice]* (\"ababababa\".toSlice.split \"aba\").allowNontermination.toList == [\"coffee\".toSlice, \"water\".toSlice]* (\"baaab\".toSlice.split \"aa\").allowNontermination.toList == [\"b\".toSlice, \"ab\".toSlice]\n\nSplits a slice at each subslice that matches the pattern pat. Unlike split the\nmatched subslices are included at the end of each subslice.This function is generic over all currently supported patterns.Examples:* (\"coffee tea water\".toSlice.splitInclusive Char.isWhitespace).allowNontermination.toList == [\"coffee \".toSlice, \"tea \".toSlice, \"water\".toSlice]* (\"coffee tea water\".toSlice.splitInclusive ' ').allowNontermination.toList == [\"coffee \".toSlice, \"tea \".toSlice, \"water\".toSlice]* (\"coffee tea water\".toSlice.splitInclusive \" tea \").allowNontermination.toList == [\"coffee tea \".toSlice, \"water\".toSlice]* (\"baaab\".toSlice.splitInclusive \"aa\").allowNontermination.toList == [\"baa\".toSlice, \"ab\".toSlice]\n\nCreates an iterator over all lines in s with the line ending characters \\r\\n or \\n being\nstripped.Examples:* \"foo\\r\\nbar\\n\\nbaz\\n\".toSlice.lines.allowNontermination.toList  == [\"foo\".toSlice, \"bar\".toSlice, \"\".toSlice, \"baz\".toSlice]* \"foo\\r\\nbar\\n\\nbaz\".toSlice.lines.allowNontermination.toList  == [\"foo\".toSlice, \"bar\".toSlice, \"\".toSlice, \"baz\".toSlice]* \"foo\\r\\nbar\\n\\nbaz\\r\".toSlice.lines.allowNontermination.toList  == [\"foo\".toSlice, \"bar\".toSlice, \"\".toSlice, \"baz\\r\".toSlice]\n\nGiven a slice and a valid position within the slice, obtain a new slice on the same underlying\nstring by replacing the end of the slice with the given position.\n\nRemoves leading and trailing whitespace from a slice.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".toSlice.trimAscii == \"abc\".toSlice* \"   abc\".toSlice.trimAscii == \"abc\".toSlice* \"abc \\t  \".toSlice.trimAscii == \"abc\".toSlice* \"  abc   \".toSlice.trimAscii == \"abc\".toSlice* \"abc\\ndef\\n\".toSlice.trimAscii == \"abc\\ndef\".toSlice\n\nRemoves trailing whitespace from a slice by moving its start position to the first non-whitespace\ncharacter, or to its end position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".toSlice.trimAsciiEnd == \"abc\".toSlice* \"   abc\".toSlice.trimAsciiEnd == \"   abc\".toSlice* \"abc \\t  \".toSlice.trimAsciiEnd == \"abc\".toSlice* \"  abc   \".toSlice.trimAsciiEnd == \"  abc\".toSlice* \"abc\\ndef\\n\".toSlice.trimAsciiEnd == \"abc\\ndef\".toSlice\n\nRemoves leading whitespace from a slice by moving its start position to the first non-whitespace\ncharacter, or to its end position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".toSlice.trimAsciiStart == \"abc\".toSlice* \"   abc\".toSlice.trimAsciiStart == \"abc\".toSlice* \"abc \\t  \".toSlice.trimAsciiStart == \"abc \\t  \".toSlice* \"  abc   \".toSlice.trimAsciiStart == \"abc   \".toSlice* \"abc\\ndef\\n\".toSlice.trimAsciiStart == \"abc\\ndef\\n\".toSlice\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.8. Manipulation","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Manipulation"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-goals":{"contents":"Given a main goal ctx ⊢ t, suffices h : t' from e replaces the main goal with ctx ⊢ t',\ne must have type t in the context ctx, h : t'.The variant suffices h : t' by tac is a shorthand for suffices h : t' from by tac.\nIf h : is omitted, the name this is used.\n\n* change tgt' will change the goal from tgt to tgt',\nassuming these are definitionally equal.* change t' at h will change hypothesis h : t to have type t', assuming\nassuming t and t' are definitionally equal.\n\n* change a with b will change occurrences of a to b in the goal,\nassuming a and b are definitionally equal.* change a with b at h similarly changes a to b in the type of hypothesis h.\n\n* generalize ([h :] e = x),+ replaces all occurrences es in the main goal\nwith a fresh hypothesis xs. If h is given, h : e = x is introduced as well.* generalize e = x at h₁ ... hₙ also generalizes occurrences of e\ninside h₁, ..., hₙ.* generalize e = x at * will generalize occurrences of e everywhere.\n\nThe tactic specialize h a₁ ... aₙ works on local hypothesis h.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments a₁ ... aₙ.\nThe tactic adds a new hypothesis with the same name h := h a₁ ... aₙ\nand tries to clear the previous one.\n\nThe obtain tactic is a combination of have and rcases. See rcases for\na description of supported patterns.obtain ⟨patt⟩ : type := proof\nis equivalent tohave h : type := proof\nrcases h with ⟨patt⟩\nIf ⟨patt⟩ is omitted, rcases will try to infer the pattern.If type is omitted, := proof is required.\n\nshow t finds the first goal whose target unifies with t. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of t.\n\nshow_term tac runs tac, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" (prefixed by expose_names if necessary)\nif there are remaining subgoals.(For some tactics, the printed term will not be human readable.)\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.8. Goal Management","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-goals"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-nav":{"contents":"Traverses into the left subterm of a binary operator.In general, for an n-ary operator, it traverses into the second to last argument.\nIt is a synonym for arg -2.\n\nTraverses into the right subterm of a binary operator.In general, for an n-ary operator, it traverses into the last argument.\nIt is a synonym for arg -1.\n\nTraverses into the function of a (unary) function application.\nFor example, | f a b turns into | f a. (Use arg 0 to traverse into f.)\n\nPerforms one step of \"congruence\", which takes a term and produces\nsubgoals for all the function arguments. For example, if the target is f x y then\ncongr produces two subgoals, one for x and one for y.\n\n* arg i traverses into the i'th argument of the target. For example if the\ntarget is f a b c d then arg 1 traverses to a and arg 3 traverses to c.\nThe index may be negative; arg -1 traverses into the last argument,\narg -2 into the second-to-last argument, and so on.* arg @i is the same as arg i but it counts all arguments instead of just the\nexplicit arguments.* arg 0 traverses into the function. If the target is f a b c d, arg 0 traverses into f.\n\nArguments to enter\n\nenter [arg, ...] is a compact way to describe a path to a subterm.\nIt is a shorthand for other conv tactics as follows:* enter [i] is equivalent to arg i.* enter [@i] is equivalent to arg @i.* enter [x] (where x is an identifier) is equivalent to ext x.* enter [in e] (where e is a term) is equivalent to pattern e.\nOccurrences can be specified with enter [in (occs := ...) e].\nFor example, given the target f (g a (fun x => x b)), enter [1, 2, x, 1]\nwill traverse to the subterm b.\n\n* pattern pat traverses to the first subterm of the target that matches pat.* pattern (occs := *) pat traverses to every subterm of the target that matches pat\nwhich is not contained in another match of pat. It generates one subgoal for each matching\nsubterm.* pattern (occs := 1 2 4) pat matches occurrences 1, 2, 4 of pat and produces three subgoals.\nOccurrences are numbered left to right from the outside in.Note that skipping an occurrence of pat will traverse inside that subexpression, which means\nit may find more matches and this can affect the numbering of subsequent pattern matches.\nFor example, if we are searching for f _ in f (f a) = f b:* occs := 1 2 (and occs := *) returns | f (f a) and | f b* occs := 2 returns | f a* occs := 2 3 returns | f a and | f b* occs := 1 3 is an error, because after skipping f b there is no third match.\n\next x traverses into a binder (a fun x => e or ∀ x, e expression)\nto target e, introducing name x in the process.\n\nargs traverses into all arguments. Synonym for congr.\n\nleft traverses into the left argument. Synonym for lhs.\n\nright traverses into the right argument. Synonym for rhs.\n\nintro traverses into binders. Synonym for ext.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.3. Navigation","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-nav"},"/The--grind--tactic/Linear-Arithmetic-Solver/#grind-linarith":{"contents":"The grind tactic includes a linear arithmetic solver for arbitrary types, called linarith, that is used for types not supported by cutsat.\nLike the ring solver, it can be used with any type that has instances of certain type classes.\nIt self-configures depending on the availability of these type classes, so it is not necessary to provide all of them to use the solver; however, its capabilities are increased by the availability of more instances.\nThis solver is useful for reasoning about the real numbers, ordered vector spaces, and other types that can't be embedded into Int.\n\nThe core functionality of linarith is a model-based solver for linear inequalities with integer coefficients.\nIt can be disabled using the option grind -linarith.\n\nGoals Decided by linarithAll of these examples rely on instances of the following ordering notation and linarith classes:variable [LE α] [LT α] [Std.LawfulOrderLT α]  [Std.IsLinearOrder α]\nvariable [IntModule α] [OrderedAdd α]\nInteger modules (IntModule) are types with zero, addition, negation, subtraction, and scalar multiplication by integers that satisfy the expected properties of these operations.\nLinear orders (Std.IsLinearOrder) are orders in which any pair of elements is ordered, and OrderedAdd states that adding a constant to both sides preserves orderings.example {a b : α} : 2 • a + b ≥ b + a + a := by grind\n\nexample {a b : α} (h : a ≤ b) : 3 • a + b ≤ 4 • b := by grind\n\nexample {a b c : α} :\n    a = b + c →\n    2 • b ≤ c →\n    2 • a ≤ 3 • c := by\n  grind\n\nexample {a b c d e : α} :\n    2 • a + b ≥ 0 →\n    b ≥ 0 → c ≥ 0 → d ≥ 0 → e ≥ 0 →\n    a ≥ 3 • c → c ≥ 6 • e → d - 5 • e ≥ 0 →\n    a + b + 3 • c + d + 2 • e < 0 →\n    False := by\n  grind\n\n\nCommutative Ring Goals Decided by linarithFor types that are commmutative rings (that is, types in which the multiplication operator is commutative) with CommRing instances, linarith has more capabilities.variable [LE R] [LT R] [Std.IsLinearOrder R] [Std.LawfulOrderLT R]\nvariable [CommRing R] [OrderedRing R]\nThe CommRing R instance allows linarith to perform basic normalization, such as identifying linear atoms a * b and b * a, and to account for scalar multiplication on both sides.\nThe OrderedRing R instance allows the solver to support constants, because it has access to the fact that (0 : R) < 1.example (a b : R) (h : a * b ≤ 1) : b * 3 • a + 1 ≤ 4 := by grind\n\nexample (a b c d e f : R) :\n    2 • a + b ≥ 1 →\n    b ≥ 0 → c ≥ 0 → d ≥ 0 → e • f ≥ 0 →\n    a ≥ 3 • c →\n    c ≥ 6 • e • f → d - f * e * 5 ≥ 0 →\n    a + b + 3 • c + d + 2 • e • f < 0 →\n    False := by\n  grind\n\n\n\n\n\n\n","context":"Lean Reference\u0009The  grind  tactic","header":"17.9. Linear Arithmetic Solver","id":"/The--grind--tactic/Linear-Arithmetic-Solver/#grind-linarith"},"/The-Type-System/Inductive-Types/#structure-inheritance":{"contents":"Structures may be declared as extending other structures using the optional extends clause.\nThe resulting structure type has all of the fields of all of the parent structure types.\nIf the parent structure types have overlapping field names, then all overlapping field names must have the same type.\n\nThe resulting structure has a field resolution order that affects the values of fields.\nWhen possible, this resolution order is the C3 linearization of the structure's parents.\nEssentially, the field resolution order should be a total ordering of the entire set of parents such that every extends list is in order.\nWhen there is no C3 linearization, a heuristic is used to find an order nonetheless.\nEvery structure type is first in its own field resolution order.\n\nThe field resolution order is used to compute the default values of optional fields.\nWhen the value of a field is not specified, the first default value defined in the resolution order is used.\nReferences to fields in the default value use the field resolution order as well; this means that child structures that override default fields of parent constructors may also change the computed default values of parent fields.\nBecause the child structure is the first element of its own resolution order, default values in the child structure take precedence over default values from the parent structures.\n\n\n\nWhen the new structure extends existing structures, the new structure's constructor takes the existing structure's information as additional arguments.\nTypically, this is in the form of a constructor parameter for each parent structure type.\nThis parent value contains all of the parent's fields.\nIf the parents' fields overlap, however, then the subset of non-overlapping fields from one or more of the parents is included instead of an entire value of the parent structure to prevent duplicating field information.\n\nThere is no subtyping relation between a parent structure type and its children.\nEven if structure B extends structure A, a function expecting an A will not accept a B.\nHowever, conversion functions are generated that convert a structure into each of its parents.\nThese conversion functions are called parent projections.\nParent projections are in the child structure's namespace, and their name is the parent structure's name preceded by to.\n\nStructure type inheritance with overlapping fieldsIn this example, a Textbook is a Book that is also an AcademicWork:structure Book where\n  title : String\n  author : String\n\nstructure AcademicWork where\n  author : String\n  discipline : String\n\nstructure Textbook extends Book, AcademicWork\n\n#check Textbook.toBook\nBecause the field author occurs in both Book and AcademicWork, the constructor Textbook.mk does not take both parents as arguments.\nIts signature is:Textbook.mk (toBook : Book) (discipline : String) : Textbook\nThe conversion functions are:Textbook.toBook (self : Textbook) : Book\nTextbook.toAcademicWork (self : Textbook) : AcademicWork\nThe latter combines the author field of the included Book with the unbundled Discipline field, and is equivalent to:def toAcademicWork (self : Textbook) : AcademicWork :=\n  let .mk book discipline := self\n  let .mk _title author := book\n  .mk author discipline\n\n\nThe resulting structure's projections can be used as if its fields are simply the union of the parents' fields.\nThe Lean elaborator automatically generates an appropriate projection when fields are used.\nLikewise, the field-based initialization and structure update notations hide the details of the encoding of inheritance.\nThe encoding is, however, visible when using the constructor's name, when using anonymous constructor syntax, or when referring to fields by their index rather than their name.\n\nField Indices and Structure Inheritancestructure Pair (α : Type u) where\n  fst : α\n  snd : α\nderiving Repr\n\nstructure Triple (α : Type u) extends Pair α where\n  thd : α\nderiving Repr\n\ndef coords : Triple Nat := {fst := 17, snd := 2, thd := 95}\nEvaluating the first field index of coords yields the underlying Pair, rather than the contents of the field fst:#eval coords.1\n{ fst := 17, snd := 2 }\nThe elaborator translates coords.fst into coords.toPair.fst.\n\nNo structure subtypingGiven these definitions of even numbers, even prime numbers, and a concrete even prime:structure EvenNumber where\n  val : Nat\n  isEven : 2 ∣ val := by decide\n\nstructure EvenPrime extends EvenNumber where\n  notOne : val ≠ 1 := by decide\n  isPrime : ∀ n, n ≤ val → n ∣ val  → n = 1 ∨ n = val\n\ndef two : EvenPrime where\n  val := 2\n  isPrime := by\n    intros\n    repeat' (cases ‹Nat.le _ _›)\n    all_goals omega\n\ndef printEven (num : EvenNumber) : IO Unit :=\n  IO.print num.val\nit is a type error to apply printEven directly to two:#check printEven two\nApplication type mismatch: The argument\n  two\nhas type\n  EvenPrime\nbut is expected to have type\n  EvenNumber\nin the application\n  printEven two\nbecause values of type EvenPrime are not also values of type EvenNumber.\n\n\n\nThe #print command displays the most important information about structure types, including the parent projections, all the fields with their default values, the constructor, and the field resolution order.\nWhen working with deep hierarchies that contain inheritance diamonds, this information can be very useful.\n\n#print and Structure TypesThis collection of structure types models a variety of bicycles, both electric and non-electric and both ordinary-sized and large family bicycles.\nThe final structure type, ElectricFamilyBike, contains a diamond in its inheritance graph, because both FamilyBike and ElectricBike extend Bicycle.structure Vehicle where\n  wheels : Nat\n\nstructure Bicycle extends Vehicle where\n  wheels := 2\n\nstructure ElectricVehicle extends Vehicle where\n  batteries : Nat := 1\n\nstructure FamilyBike extends Bicycle where\n  wheels := 3\n\nstructure ElectricBike extends Bicycle, ElectricVehicle\n\nstructure ElectricFamilyBike\n    extends FamilyBike, ElectricBike where\n  batteries := 2\nThe #print command displays the important information about each structure type:#print ElectricBike\nstructure ElectricBike : Type\nnumber of parameters: 0\nparents:\n  ElectricBike.toBicycle : Bicycle\n  ElectricBike.toElectricVehicle : ElectricVehicle\nfields:\n  Vehicle.wheels : Nat :=\n    2\n  ElectricVehicle.batteries : Nat :=\n    1\nconstructor:\n  ElectricBike.mk (toBicycle : Bicycle) (batteries : Nat) : ElectricBike\nfield notation resolution order:\n  ElectricBike, Bicycle, ElectricVehicle, Vehicle\nAn ElectricFamilyBike has three wheels by default because FamilyBike precedes Bicycle in its resolution order:#print ElectricFamilyBike\nstructure ElectricFamilyBike : Type\nnumber of parameters: 0\nparents:\n  ElectricFamilyBike.toFamilyBike : FamilyBike\n  ElectricFamilyBike.toElectricBike : ElectricBike\nfields:\n  Vehicle.wheels : Nat :=\n    3\n  ElectricVehicle.batteries : Nat :=\n    2\nconstructor:\n  ElectricFamilyBike.mk (toFamilyBike : FamilyBike) (batteries : Nat) : ElectricFamilyBike\nfield notation resolution order:\n  ElectricFamilyBike, FamilyBike, ElectricBike, Bicycle, ElectricVehicle, Vehicle\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Structure Declarations","header":"4.4.2.4. Structure Inheritance","id":"/The-Type-System/Inductive-Types/#structure-inheritance"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Arithmetic-and-Bitwise-Operators":{"contents":"A type with a zero element.The zero element of the type.\n\nA type-class version of n ≠ 0.The proposition that n is not zero.\n\nThe notation typeclass for heterogeneous addition.\nThis enables the notation a + b : γ where a : α, b : β.a + b computes the sum of a and b.\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of + in identifiers is add.\n\nThe homogeneous version of HAdd: a + b : α where a b : α.a + b computes the sum of a and b. See HAdd.\n\nThe notation typeclass for heterogeneous subtraction.\nThis enables the notation a - b : γ where a : α, b : β.a - b computes the difference of a and b.\nThe meaning of this notation is type-dependent.* For natural numbers, this operator saturates at 0: a - b = 0 when a ≤ b.Conventions for notations in identifiers:* The recommended spelling of - in identifiers is sub (when used as a binary operator).\n\nThe homogeneous version of HSub: a - b : α where a b : α.a - b computes the difference of a and b. See HSub.\n\nThe notation typeclass for heterogeneous multiplication.\nThis enables the notation a * b : γ where a : α, b : β.a * b computes the product of a and b.\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of * in identifiers is mul.\n\nTypeclass for types with a scalar multiplication operation, denoted • (\\bu)a • b computes the product of a and b. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions.\n\nThe homogeneous version of HMul: a * b : α where a b : α.a * b computes the product of a and b. See HMul.\n\nThe notation typeclass for heterogeneous division.\nThis enables the notation a / b : γ where a : α, b : β.a / b computes the result of dividing a by b.\nThe meaning of this notation is type-dependent.* For most types like Nat, Int, Rat, Real, a / 0 is defined to be 0.* For Nat, a / b rounds downwards.* For Int, a / b rounds downwards if b is positive or upwards if b is negative.\nIt is implemented as Int.ediv, the unique function satisfying\na % b + b * (a / b) = a and 0 ≤ a % b < natAbs b for b ≠ 0.\nOther rounding conventions are available using the functions\nInt.fdiv (floor rounding) and Int.tdiv (truncation rounding).* For Float, a / 0 follows the IEEE 754 semantics for division,\nusually resulting in inf or nan.Conventions for notations in identifiers:* The recommended spelling of / in identifiers is div.\n\nThe homogeneous version of HDiv: a / b : α where a b : α.a / b computes the result of dividing a by b. See HDiv.\n\nNotation typeclass for the ∣ operation (typed as \\|), which represents divisibility.Divisibility. a ∣ b (typed as \\|) means that there is some c such that b = a * c.Conventions for notations in identifiers:* The recommended spelling of ∣ in identifiers is dvd.\n\nThe notation typeclass for heterogeneous modulo / remainder.\nThis enables the notation a % b : γ where a : α, b : β.a % b computes the remainder upon dividing a by b.\nThe meaning of this notation is type-dependent.* For Nat and Int it satisfies a % b + b * (a / b) = a,\nand a % 0 is defined to be a.Conventions for notations in identifiers:* The recommended spelling of % in identifiers is mod.\n\nThe homogeneous version of HMod: a % b : α where a b : α.a % b computes the remainder upon dividing a by b. See HMod.\n\nThe notation typeclass for heterogeneous exponentiation.\nThis enables the notation a ^ b : γ where a : α, b : β.a ^ b computes a to the power of b.\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of ^ in identifiers is pow.\n\nThe homogeneous version of HPow: a ^ b : α where a : α, b : β.\n(The right argument is not the same as the left since we often want this even\nin the homogeneous case.)Types can choose to subscribe to particular defaulting behavior by providing\nan instance to either NatPow or HomogeneousPow:* NatPow is for types whose exponents is preferentially a Nat.* HomogeneousPow is for types whose base and exponent are preferentially the same.a ^ b computes a to the power of b. See HPow.\n\nThe homogeneous version of Pow where the exponent is a Nat.\nThe purpose of this class is that it provides a default Pow instance,\nwhich can be used to specialize the exponent to Nat during elaboration.For example, if x ^ 2 should preferentially elaborate with 2 : Nat then x's type should\nprovide an instance for this class.a ^ n computes a to the power of n where n : Nat. See Pow.\n\nThe completely homogeneous version of Pow where the exponent has the same type as the base.\nThe purpose of this class is that it provides a default Pow instance,\nwhich can be used to specialize the exponent to have the same type as the base's type during elaboration.\nThis is to say, a type should provide an instance for this class in case x ^ y should be elaborated\nwith both x and y having the same type.For example, the Float type provides an instance of this class, which causes expressions\nsuch as (2.2 ^ 2.2 : Float) to elaborate.a ^ b computes a to the power of b where a and b both have the same type.\n\nThe typeclass behind the notation a <<< b : γ where a : α, b : β.a <<< b computes a shifted to the left by b places.\nThe meaning of this notation is type-dependent.* On Nat, this is equivalent to a * 2 ^ b.* On UInt8 and other fixed width unsigned types, this is the same but\ntruncated to the bit width.Conventions for notations in identifiers:* The recommended spelling of <<< in identifiers is shiftLeft.\n\nThe homogeneous version of HShiftLeft: a <<< b : α where a b : α.The implementation of a <<< b : α. See HShiftLeft.\n\nThe typeclass behind the notation a >>> b : γ where a : α, b : β.a >>> b computes a shifted to the right by b places.\nThe meaning of this notation is type-dependent.* On Nat and fixed width unsigned types like UInt8,\nthis is equivalent to a / 2 ^ b.Conventions for notations in identifiers:* The recommended spelling of >>> in identifiers is shiftRight.\n\nThe homogeneous version of HShiftRight: a >>> b : α where a b : α.The implementation of a >>> b : α. See HShiftRight.\n\nThe notation typeclass for negation.\nThis enables the notation -a : α where a : α.-a computes the negative or opposite of a.\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of - in identifiers is neg (when used as a unary operator).\n\nThe typeclass behind the notation a &&& b : γ where a : α, b : β.a &&& b computes the bitwise AND of a and b.\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of &&& in identifiers is and.\n\nThe homogeneous version of HAnd: a &&& b : α where a b : α.\n(It is called AndOp because And is taken for the propositional connective.)The implementation of a &&& b : α. See HAnd.\n\nThe typeclass behind the notation a ||| b : γ where a : α, b : β.a ||| b computes the bitwise OR of a and b.\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of ||| in identifiers is or.\n\nThe homogeneous version of HOr: a ||| b : α where a b : α.\n(It is called OrOp because Or is taken for the propositional connective.)The implementation of a ||| b : α. See HOr.\n\nThe typeclass behind the notation a ^^^ b : γ where a : α, b : β.a ^^^ b computes the bitwise XOR of a and b.\nThe meaning of this notation is type-dependent.Conventions for notations in identifiers:* The recommended spelling of ^^^ in identifiers is xor.\n\nThe homogeneous version of HXor: a ^^^ b : α where a b : α.The implementation of a ^^^ b : α. See HXor.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.7. Arithmetic and Bitwise Operators","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Arithmetic-and-Bitwise-Operators"}});