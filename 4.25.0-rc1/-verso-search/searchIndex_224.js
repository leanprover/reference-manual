window.docContents[224].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Other-Strings":{"contents":"Constructs a valid position on t from a valid position on s and a proof that s = t.\n\nGiven a slice s and a position on s.copy, obtain the corresponding position on s.\n\nGiven a valid position in a string, obtain the corresponding position after setting a character on\nthat string, provided that the position was before the changed position.\n\nGiven a valid position in a string, obtain the corresponding position after modifying a character\nin that string, provided that the position was before the changed position.\n\nTurns a valid position on the string s into a valid position on the slice s.toSlice.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Positions","header":"19.8.4.4.5. Other Strings","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Positions--Other-Strings"},"/Definitions/Recursive-Definitions/#partial-fixpoint-theory":{"contents":"The construction builds on a variant of the Knaster–Tarski theorem: In a chain-complete partial order, every monotone function has a least fixed point.\n\nThe necessary theory is found in the Lean.Order namespace.\nThis is not meant to be a general purpose library of order theoretic results.\nInstead, the definitions and theorems in Lean.Order are only intended as implementation details of the partial_fixpoint feature, and they should be considered a private API that may change without notice.\n\nThe notion of a partial order, and that of a chain-complete partial order, are represented by the type classes Lean.Order.PartialOrder and Lean.Order.CCPO, respectively.\n\nA partial order is a reflexive, transitive and antisymmetric relation.This is intended to be used in the construction of partial_fixpoint, and not meant to be used otherwise.A “less-or-equal-to” or “approximates” relation.This is intended to be used in the construction of partial_fixpoint, and not meant to be used otherwise.The “less-or-equal-to” or “approximates” relation is reflexive.The “less-or-equal-to” or “approximates” relation is transitive.The “less-or-equal-to” or “approximates” relation is antisymmetric.\n\nA chain-complete partial order (CCPO) is a partial order where every chain has a least upper bound.This is intended to be used in the construction of partial_fixpoint, and not meant to be used\notherwise.The least upper bound of a chain.This is intended to be used in the construction of partial_fixpoint, and not meant to be used\notherwise.csup c is the least upper bound of the chain c when all elements x that are at\nleast as large as csup c are at least as large as all elements of c, and vice versa.\n\n\n\nA function is monotone if it preserves partial orders.\nThat is, if x ⊑ y then f x ⊑ f y.\nThe operator ⊑ represent Lean.Order.PartialOrder.rel.\n\nA function is monotone if it maps related elements to related elements.This is intended to be used in the construction of partial_fixpoint, and not meant to be used otherwise.\n\nThe fixpoint of a monotone function can be taken using fix, which indeed constructs a fixpoint, as shown by fix_eq,\n\nThe least fixpoint of a monotone function is the least upper bound of its transfinite iteration.The monotone f assumption is not strictly necessarily for the definition, but without this the\ndefinition is not very meaningful and it simplifies applying theorems like fix_eq if every use of\nfix already has the monotonicity requirement.This is intended to be used in the construction of partial_fixpoint, and not meant to be used otherwise.\n\nThe main fixpoint theorem for fixed points of monotone functions in chain-complete partial orders.This is intended to be used in the construction of partial_fixpoint, and not meant to be used otherwise.\n\nTo construct the partial fixpoint, Lean first synthesizes a suitable CCPO instance.* If the function's result type has a dedicated instance, like Option has with instCCPOOption, this is used together with the instance for the function type, instCCPOPi, to construct an instance for the whole function's type.* Otherwise, if the function's type can be shown to be inhabited by a witness w, then the instance FlatOrder.instCCPO for the wrapper type FlatOrder w is used. In this order, w is a least element and all other elements are incomparable.\n\nNext, the recursive calls in the right-hand side of the function definitions are abstracted; this turns into the argument f of fix. The monotonicity requirement is solved by the monotonicity tactic, which applies compositional monotonicity lemmas in a syntax-driven way.\n\n\n\nThe tactic solves goals of the form monotone (fun x => … x …) using the following steps:\n\n* Applying monotone_const when there is no dependency on x left.* Splitting on match expressions.* Splitting on if expressions.* Moving let expression to the context, if the value and type do not depend on x.* Zeta-reducing a let expression when value and type do depend on x.* Applying lemmas annotated with partial_fixpoint_monotone\n\n\n\nThe following monotonicity lemmas are registered, and should allow recursive calls under the given higher-order functions in the arguments indicated by · (but not the other arguments, shown as _).\n\n* Theorem* Pattern* monotone_allM* Array.allM · _ _ _* monotone_anyM* Array.anyM · _ _ _* monotone_anyM_loop* Array.anyM.loop · _ _ ⋯ _* monotone_array_filterMapM* Array.filterMapM · _* monotone_array_forM* Array.forM · _ _ _* monotone_array_forRevM* Array.forRevM · _ _ _* monotone_findIdxM?* Array.findIdxM? · _* monotone_findM?* Array.findM? · _* monotone_findRevM?* Array.findRevM? · _* monotone_findSomeM?* Array.findSomeM? · _* monotone_findSomeRevM?* Array.findSomeRevM? · _* monotone_flatMapM* Array.flatMapM · _* monotone_foldlM* Array.foldlM · _ _ _ _* monotone_foldlM_loop* Array.foldlM.loop · _ _ ⋯ _ _ _* monotone_foldrM* Array.foldrM · _ _ _ _* monotone_foldrM_fold* Array.foldrM.fold · _ _ _ ⋯ _* monotone_forIn* forIn _ _ ·* monotone_forIn'* forIn' _ _ ·* monotone_forIn'_loop* Array.forIn'.loop _ · _ ⋯ _* monotone_mapFinIdxM* _.mapFinIdxM ·* monotone_mapM* Array.mapM · _* monotone_modifyM* _.modifyM _ ·* monotone_map* _ <$> ·* monotone_allM* List.allM · _* monotone_anyM* List.anyM · _* monotone_filterAuxM* List.filterAuxM · _ _* monotone_filterM* List.filterM · _* monotone_filterRevM* List.filterRevM · _* monotone_findM?* List.findM? · _* monotone_findSomeM?* List.findSomeM? · _* monotone_foldlM* List.foldlM · _ _* monotone_foldrM* List.foldrM · _ _* monotone_forIn* forIn _ _ ·* monotone_forIn'* forIn' _ _ ·* monotone_forIn'_loop* List.forIn'.loop _ · _ _ ⋯* monotone_forM* _.forM ·* monotone_mapM* List.mapM · _* monotone_bindM* Option.bindM · _* monotone_elimM* Option.elimM · · ·* monotone_getDM* _.getDM ·* monotone_mapM* Option.mapM · _* monotone_fst* ·.fst* monotone_mk* ⟨·, ·⟩* monotone_snd* ·.snd* monotone_seq* · <*> ·* monotone_seqLeft* · <* ·* monotone_seqRight* · *> ·* coind_impl* · → ·* coind_monotone_and* · ∧ ·* coind_monotone_exists* Exists ·* coind_monotone_forall* ∀ (y : _), _ _ _* coind_monotone_or* · ∨ ·* coind_not* ¬·* implication_order_monotone_and* · ∧ ·* implication_order_monotone_exists* Exists ·* implication_order_monotone_forall* ∀ (y : _), _ _ _* implication_order_monotone_or* · ∨ ·* ind_impl* · → ·* ind_not* ¬·* monotone_bind* · >>= ·* monotone_dite* dite _ · ·* monotone_exceptTRun* ·.run* monotone_ite* if _ then · else ·* monotone_optionTRun* ·.run* monotone_readerTRun* ·.run _* monotone_stateRefT'Run* ·.run _* monotone_stateTRun* ·.run _\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.5. Theory and Construction","id":"/Definitions/Recursive-Definitions/#partial-fixpoint-theory"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-cases":{"contents":"The split tactic is useful for breaking nested if-then-else and match expressions into separate cases.\nFor a match expression with n cases, the split tactic generates at most n subgoals.For example, given n : Nat, and a target if n = 0 then Q else R, split will generate\none goal with hypothesis n = 0 and target Q, and a second goal with hypothesis\n¬n = 0 and target R.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed using the case or next tactics.* split will split the goal (target).* split at h will split the hypothesis h.\n\nby_cases (h :)? p splits the main goal into two cases, assuming h : p in the first branch, and h : ¬ p in the second branch.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.16. Case Analysis","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-cases"},"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Explicit-Motives":{"contents":"Pattern matching is not a built-in primitive of Lean.\nInstead, it is translated to applications of recursors via auxiliary matching functions.\nBoth require a motive that explains the relationship between the discriminant and the resulting type.\nGenerally, the match elaborator is capable of synthesizing an appropriate motive, and the refinement of types that occurs during pattern matching is a result of the motive that was selected.\nIn some specialized circumstances, a different motive may be needed and may be provided explicitly using the (motive := …) syntax of match.\nThis motive should be a function type that expects at least as many parameters as there are discriminants.\nThe type that results from applying a function with this type to the discriminants in order is the type of the entire match term, and the type that results from applying a function with this type to all patterns in each alternative is the type of that alternative's right-hand side.\n\nMatching with an Explicit MotiveAn explicit motive can be used to provide type information that is otherwise unavailable from the surrounding context.\nAttempting to match on a number and a proof that it is in fact 5 is an error, because there's no reason to connect the number to the proof:#eval\n  match 5, rfl with\n  | 5, rfl => \"ok\"\nInvalid match expression: This pattern contains metavariables:\n  Eq.refl ?m.76\nAn explicit motive explains the relationship between the discriminants:#eval\n  match (motive := (n : Nat) → n = 5 → String) 5, rfl with\n  | 5, rfl => \"ok\"\n\"ok\"\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching\u0009Types","header":"10.8.1.2. Explicit Motives","id":"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types--Explicit-Motives"},"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Nonlinear-Constraints":{"contents":"The solver currently does support nonlinear constraints, and treats nonlinear terms such as x * x as variables.\n\nNonlinear Termscutsat fails to prove this theorem:example (x : Int) : x * x ≥ 0 := by\n  grind\n`grind` failed\ncase grind\nx : Int\nh : x * x + 1 ≤ 0\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n  [cutsat] Assignment satisfying linear constraints\nFrom the perspective of cutsat, it is equivalent to:example {y : Int} (x : Int) : y ≥ 0 := by\n  grind\n`grind` failed\ncase grind\nx : Int\nh : x * x + 1 ≤ 0\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n  [cutsat] Assignment satisfying linear constraints\nThis can be seen by setting the option trace.grind.cutsat.assert to true, which traces all constraints processed by cutsat.example (x : Int) : x*x ≥ 0 := by\n  set_option trace.grind.cutsat.assert true in\n  grind\n[grind.cutsat.assert] -1*「x ^ 2 + 1」 + 「x ^ 2」 + 1 = 0\n[grind.cutsat.assert] 「x ^ 2」 + 1 ≤ 0\nThe term x ^ 2 is “quoted” in 「x ^ 2」 + 1 ≤ 0 to indicate that x ^ 2 is treated as a variable.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.2. Nonlinear Constraints","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Nonlinear-Constraints"}});