window.docContents[53].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion":{"contents":"Transforms a list of mappings into a tree map.\n\nTransforms the tree map into a list of mappings in ascending order.\n\nTransforms a list of mappings into a tree map.\n\nTransforms the tree map into a list of mappings in ascending order.\n\nTransforms an array of keys into a tree map.\n\nTransforms a list of keys into a tree map.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps","header":"19.18.8.6. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion"},"/Basic-Types/Natural-Numbers/#nat-model":{"contents":"The natural numbers, starting at zero.This type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\nGMP); at runtime, Nat values that are sufficiently small are unboxed.Zero, the smallest natural number.Using Nat.zero explicitly should usually be avoided in favor of the literal 0, which is the\nsimp normal form.The successor of a natural number n.Using Nat.succ n should usually be avoided in favor of n + 1, which is the simp normal\nform.\n\nProofs by InductionThe natural numbers are an inductive type, so the induction tactic can be used to prove universally-quantified statements.\nA proof by induction requires a base case and an induction step.\nThe base case is a proof that the statement is true for 0.\nThe induction step is a proof that the truth of the statement for some arbitrary number i implies its truth for i + 1.This proof uses the lemma Nat.succ_lt_succ in its induction step.example (n : Nat) : n < n + 1 := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < i + 1\n    show i + 1 < i + 1 + 1\n    exact Nat.succ_lt_succ ih\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers","header":"19.1.1. Logical Model","id":"/Basic-Types/Natural-Numbers/#nat-model"},"/Basic-Types/Strings/#String":{"contents":"Strings represent Unicode text.\nStrings are specially supported by Lean:\n\n* They have a logical model that specifies their behavior in terms of ByteArrays that contain UTF-8 scalar values.* In compiled code, they have a run-time representation that additionally includes a cached length, measured as the number of scalar values.\n   The Lean runtime provides optimized implementations of string operations.* There is string literal syntax for writing strings.\n\nUTF-8 is a variable-width encoding.\nA character may be encoded as a one, two, three, or four byte code unit.\nThe fact that strings are UTF-8-encoded byte arrays is visible in the API:\n\n* There is no operation to project a particular character out of the string, as this would be a performance trap. Use an iterator in a loop instead of a Nat.* Strings are indexed by String.ValidPos, which internally records byte counts rather than character counts, and thus takes constant time.\n   String.ValidPos includes a proof that the byte count in fact points at the beginning of a UTF-8 code unit.\n   Aside from 0, these should not be constructed directly, but rather updated using String.next and String.prev.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.8. Strings","id":"/Basic-Types/Strings/#String"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Dependencies":{"contents":"Dependencies are specified using the require declaration.\n\nRequiring PackagesThe @ clause specifies a package version, which is used when requiring a package from Reservoir.\nThe version may either be a string that specifies the version declared in the package's version field, or a specific Git revision.\nGit revisions may be branch names, tag names, or commit hashes.The optional Lake.DSL.fromClause specifies a package source other than Reservoir, which may be either a Git repository or a local path.The with clause specifies a NameMap String of Lake options that will be used to configure the dependency.\nThis is equivalent to passing -K options to build when building the dependency on the command line.\n\nPackage SourcesSpecifies a specific source from which to draw the package dependency.\nDependencies that are downloaded from a remote source will be placed\ninto the workspace's packagesDir.Path Dependenciesfrom <path>\nLake loads the package located a fixed path relative to the\nrequiring package's directory.Git Dependenciesfrom git <url> [@ <rev>] [/ <subDir>]\nLake clones the Git repository available at the specified fixed Git url,\nand checks out the specified revision rev. The revision can be a commit hash,\nbranch, or tag. If none is provided, Lake defaults to master. After checkout,\nLake loads the package located in subDir (or the repository root if no\nsubdirectory is specified).\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"22.1.3.2.3. Dependencies","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Dependencies"},"/Build-Tools-and-Distribution/Lake/#lake-github":{"contents":"Lake supports uploading and downloading build artifacts (i.e., the archived build directory) to/from the GitHub releases of packages.\nThis enables end users to fetch pre-built artifacts from the cloud without needed to rebuild the package from source themselves.\nThe LAKE_NO_CACHE environment variable can be used to disable this feature.\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","header":"22.1.1.5. GitHub Release Builds","id":"/Build-Tools-and-Distribution/Lake/#lake-github"},"/IO/Logical-Model/#io-monad":{"contents":"There are two monads that are typically used for programs that interact with the real world:\n\n* Actions in IO may throw exceptions of type IO.Error or modify the world.* Actions in BaseIO can't throw exceptions, but they can modify the world.\n\nThe distinction makes it possible to tell whether exceptions are possible by looking at an action's type signature.\nBaseIO actions are automatically promoted to IO as necessary.\n\nA monad that supports arbitrary side effects and throwing exceptions of type IO.Error.\n\nAn IO monad that cannot throw exceptions.\n\nBoth IO and BaseIO are instances of EIO, in which the type of errors is a parameter.\nIO is defined as EIO IO.Error, while BaseIO is defined as EIO Empty.\nIn some circumstances, such as bindings to non-Lean libraries, it can be convenient to use EIO with a custom error type, which ensures that errors are handled at the boundaries between these and other IO actions.\n\n\n\nA monad that can have side effects on the external world or throw exceptions of type ε.BaseIO is a version of this monad that cannot throw exceptions. IO sets the exception type to\nIO.Error.\n\nCreates an IO action that will invoke fn if and when it is executed, returning the result.\n\nRuns a BaseIO action, which cannot throw an exception, as an IO action.This function is usually used implicitly via automatic monadic\nlifting rather than being called explicitly.\n\nRuns a BaseIO action, which cannot throw an exception, in any other EIO monad.This function is usually used implicitly via automatic monadic\nlifting rather being than called explicitly.\n\nConverts an EIO ε action that might throw an exception of type ε into an exception-free BaseIO\naction that returns an Except value.\n\nConverts an EIO ε action into an IO action by translating any exceptions that it throws into\nIO.Errors using f.\n\nConverts an EIO ε action that might throw an exception of type ε into an exception-free IO\naction that returns an Except value.\n\nRuns an IO action in some other EIO monad, using f to translate IO exceptions.\n\n","context":"Lean Reference\u0009IO\u0009Logical Model","header":"15.1.1. The  IO ,  EIO  and  BaseIO  Monads","id":"/IO/Logical-Model/#io-monad"},"/The-Type-System/Inductive-Types/#inductive-types-trivial-wrappers":{"contents":"If an inductive type has exactly one constructor, and that constructor has exactly one run-time relevant parameter, then the inductive type is represented identically to its parameter.\n\nZero-Overhead SubtypesThe structure Subtype bundles an element of some type with a proof that it satisfies a predicate.\nIts constructor takes four arguments, but three of them are irrelevant:Subtype.mk.{u} {α : Sort u} {p : α → Prop}\n  (val : α) (property : p val) : Subtype p\nThus, subtypes impose no runtime overhead in compiled code, and are represented identically to the type of the val field.\n\nSigned IntegersThe signed integer types Int8, ..., Int64, ISize are structures with a single field that wraps the corresponding unsigned integer type.\nThey are represented by the unsigned C types uint8_t, ..., uint64_t, size_t, respectively, because they have a trivial structure.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation","header":"4.4.4.3. Trivial Wrappers","id":"/The-Type-System/Inductive-Types/#inductive-types-trivial-wrappers"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Highlights","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights"}});