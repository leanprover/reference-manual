window.docContents[97].resolve({"/Basic-Propositions/Logical-Connectives/#The-Lean-Language-Reference--Basic-Propositions--Logical-Connectives":{"contents":"Conjunction is implemented as the inductively defined proposition And.\nThe constructor And.intro represents the introduction rule for conjunction: to prove a conjunction, it suffices to prove both conjuncts.\nSimilarly, And.elim represents the elimination rule: given a proof of a conjunction and a proof of some other statement that assumes both conjuncts, the other statement can be proven.\nBecause And is a subsingleton, And.elim can also be used as part of computing data.\nHowever, it should not be confused with PProd: using non-computable reasoning principles such as the Axiom of Choice to define data (including Prod) causes Lean to be unable to compile and run the resulting program, while using them in a proof of a proposition causes no such issue.\n\nIn a tactic proof, conjunctions can be proved using And.intro explicitly via apply, but constructor is more common.\nWhen multiple conjunctions are nested in a proof goal, and_intros can be used to apply And.intro in each relevant location.\nAssumptions of conjunctions in the context can be simplified using cases, pattern matching with let or Lean.Parser.Tactic.match, or rcases.\n\nAnd a b, or a ∧ b, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if ha : a and hb : b then\n⟨ha, hb⟩ : a ∧ b, and if h : a ∧ b then h.left : a and h.right : b.Conventions for notations in identifiers:* The recommended spelling of ∧ in identifiers is and.* The recommended spelling of /\\ in identifiers is and (prefer ∧ over /\\).And.intro : a → b → a ∧ b is the constructor for the And operation.Extract the left conjunct from a conjunction. h : a ∧ b then\nh.left, also notated as h.1, is a proof of a.Extract the right conjunct from a conjunction. h : a ∧ b then\nh.right, also notated as h.2, is a proof of b.\n\nNon-dependent eliminator for And.\n\nDisjunction implemented as the inductively defined proposition Or.\nIt has two constructors, one for each introduction rule: a proof of either disjunct is sufficient to prove the disjunction.\nWhile the definition of Or is similar to that of Sum, it is quite different in practice.\nBecause Sum is a type, it is possible to check which constructor was used to create any given value.\nOr, on the other hand, forms propositions: terms that prove a disjunction cannot be interrogated to check which disjunct was true.\nIn other words, because Or is not a subsingleton, its proofs cannot be used as part of a computation.\n\nIn a tactic proof, disjunctions can be proved using either constructor (Or.inl or Or.inr) explicitly via apply.\nAssumptions of disjunctions in the context can be simplified using cases, pattern matching with Lean.Parser.Tactic.match, or rcases.\n\nOr a b, or a ∨ b, is the disjunction of propositions. There are two\nconstructors for Or, called Or.inl : a → a ∨ b and Or.inr : b → a ∨ b,\nand you can use match or cases to destruct an Or assumption into the\ntwo cases.Conventions for notations in identifiers:* The recommended spelling of ∨ in identifiers is or.* The recommended spelling of \\/ in identifiers is or (prefer ∨ over \\/).Or.inl is \"left injection\" into an Or. If h : a then Or.inl h : a ∨ b.Or.inr is \"right injection\" into an Or. If h : b then Or.inr h : a ∨ b.\n\nWhen either disjunct is decidable, it becomes possible to use Or to compute data.\nThis is because the decision procedure's result provides a suitable branch condition.\n\nConstruct a non-Prop by cases on an Or, when the left conjunct is decidable.\n\nConstruct a non-Prop by cases on an Or, when the right conjunct is decidable.\n\n\n\nRather than encoding negation as an inductive type, ¬P is defined to mean P → False.\nIn other words, to prove a negation, it suffices to assume the negated statement and derive a contradiction.\nThis also means that False can be derived immediately from a proof of a proposition and its negation, and then used to prove any proposition or inhabit any type.\n\n\n\nNot p, or ¬p, is the negation of p. It is defined to be p → False,\nso if your goal is ¬p you can use intro h to turn the goal into\nh : p ⊢ False, and if you have hn : ¬p and h : p then hn h : False\nand (hn h).elim will prove anything.\nFor more information: Propositional LogicConventions for notations in identifiers:* The recommended spelling of ¬ in identifiers is not.\n\nAnything follows from two contradictory hypotheses. Example:example (hp : p) (hnp : ¬p) : q := absurd hp hnp\nFor more information: Propositional Logic\n\nEx falso for negation: from ¬a and a anything follows. This is the same as absurd with\nthe arguments flipped, but it is in the Not namespace so that projection notation can be used.\n\n\n\nImplication is represented using function types in the universe of propositions.\nTo prove A → B, it is enough to prove B after assuming A.\nThis corresponds to the typing rule for fun.\nSimilarly, the typing rule for function application corresponds to modus ponens: given a proof of A → B and a proof of A, B can be proved.\n\nTruth-Functional ImplicationThe representation of implication as functions in the universe of propositions is equivalent to the traditional definition in which A → B is defined as (¬A) ∨ B.\nThis can be proved using propositional extensionality and the law of the excluded middle:theorem truth_functional_imp {A B : Prop} :\n    ((¬ A) ∨ B) = (A → B) := by\n  apply propext\n  constructor\n  . rintro (h | h) a <;> trivial\n  . intro h\n    by_cases A\n    . apply Or.inr; solve_by_elim\n    . apply Or.inl; trivial\n\n\n\n\nLogical equivalence, or “if and only if”, is represented using a structure that is equivalent to the conjunction of both directions of the implication.\n\nIf and only if, or logical bi-implication. a ↔ b means that a implies b and vice versa.\nBy propext, this implies that a and b are equal and hence any expression involving a\nis equivalent to the corresponding expression with b instead.Conventions for notations in identifiers:* The recommended spelling of ↔ in identifiers is iff.* The recommended spelling of <-> in identifiers is iff (prefer ↔ over <->).If a → b and b → a then a and b are equivalent.Modus ponens for if and only if. If a ↔ b and a, then b.Modus ponens for if and only if, reversed. If a ↔ b and b, then a.\n\nNon-dependent eliminator for Iff.\n\nPropositional ConnectivesThe logical connectives other than implication are typically referred to using dedicated syntax, rather than via their defined names:\n\n","context":"Lean Reference\u0009Basic Propositions","header":"18.2. Logical Connectives","id":"/Basic-Propositions/Logical-Connectives/#The-Lean-Language-Reference--Basic-Propositions--Logical-Connectives"},"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References":{"contents":"While ordinary state monads encode stateful computations with tuples that track the contents of the state along with the computation's value, Lean's runtime system also provides mutable references that are always backed by mutable memory cells.\nMutable references have a type IO.Ref that indicates that a cell is mutable, and reads and writes must be explicit.\nIO.Ref is implemented using ST.Ref, so the entire ST.Ref API may also be used with IO.Ref.\n\nMutable reference cells that contain values of type α. These cells can read from and mutated in\nthe IO monad.\n\nCreates a new mutable reference cell that contains a.\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.4. Mutable References","id":"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References"},"/Notations-and-Macros/Elaborators/#The-Lean-Language-Reference--Notations-and-Macros--Elaborators--Command-Elaborators":{"contents":"A command elaborator has type CommandElab, which is an abbreviation for Syntax → CommandElabM Unit.\nCommand elaborators may be implicitly defined using elab_rules, or explicitly by defining a function and applying the command_elab attribute.Querying the EnvironmentA command elaborator can be used to query the environment to discover how many constants have a given name.\nThis example uses getEnv from the MonadEnv class to get the current environment.\nEnvironment.constants yields a mapping from names to information about them (e.g. their type and whether they are a definition, inductive type declaration, etc).\nlogInfoAt allows informational output to be associated with syntax from the original program, and a token antiquotation is used to implement the Lean convention that output from interactive commands is associated with their keyword.syntax \"#count_constants \" ident : command\n\nelab_rules : command\n  | `(#count_constants%$tok $x) => do\n    let pattern := x.getId\n    let env ← getEnv\n    let mut count := 0\n    for (y, _) in env.constants do\n      if pattern.isSuffixOf y then\n        count := count + 1\n    logInfoAt tok m!\"Found {count} instances of '{pattern}'\"\ndef interestingName := 55\ndef NS.interestingName := \"Another one\"\n\n#count_constants interestingName\nFound 2 instances of 'interestingName'\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Elaborators","header":"20.6.1. Command Elaborators","id":"/Notations-and-Macros/Elaborators/#The-Lean-Language-Reference--Notations-and-Macros--Elaborators--Command-Elaborators"},"/Terms/Pattern-Matching/#match_pattern-functions":{"contents":"\n\nIn patterns, defined constants with the match_pattern attribute are unfolded and normalized rather than rejected.\nThis allows a more convenient syntax to be used for many patterns.\nIn the standard library, Nat.add, HAdd.hAdd, Add.add, and Neg.neg all have this attribute, which allows patterns like n + 1 instead of Nat.succ n.\nSimilarly, Unit and Unit.unit are definitions that set the respective universe parameters of PUnit and PUnit.unit to 0; the match_pattern attribute on Unit.unit allows it to be used in patterns, where it expands to PUnit.unit.{0}.\n\nAttribute for Match PatternsThe match_pattern attribute indicates that a definition should be unfolded, rather than rejected, in a pattern.\n\nMatch Patterns Follow ReductionThe following function can't be compiled:def nonzero (n : Nat) : Bool :=\n  match n with\n  | 0 => false\n  | 1 + k => true\nThe error message on the pattern 1 + _ is:Invalid pattern(s): `k` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching:\n  .(Nat.add 1 k)\nThis is because Nat.add is defined by recursion on its second parameter, equivalently to:def add : Nat → Nat → Nat\n  | a, Nat.zero   => a\n  | a, Nat.succ b => Nat.succ (Nat.add a b)\nNo ι-reduction is possible, because the value being matched is a variable, not a constructor.\n1 + k gets stuck as Nat.add 1 k, which is not a valid pattern.In the case of k + 1, that is, Nat.add k (.succ .zero), the second pattern matches, so it reduces to Nat.succ (Nat.add k .zero).\nThe second pattern now matches, yielding Nat.succ k, which is a valid pattern.\n\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching","header":"10.8.2. Custom Pattern Functions","id":"/Terms/Pattern-Matching/#match_pattern-functions"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Compiler":{"contents":"* #5840 changes lean_sharecommon_{eq,hash} to only consider the\nsalient bytes of an object, and not any bytes of any\nunspecified/uninitialized unused capacity.* #6087 fixes a bug in the constant folding for the Nat.ble and\nNat.blt function in the old code generator, leading to a\nmiscompilation.* #6143 should make lean better-behaved around sanitizers, per\nhttps://github.com/google/sanitizers/issues/1688.\nAs far as I can tell,\nhttps://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn#algorithm\nreplaces local variables with heap allocations, and so taking the\naddress of a local is not effective at producing a monotonic measure of\nstack usage.* #6209 documents under which conditions Runtime.markPersistent is\nunsafe and adjusts the elaborator accordingly* #6257 harden markPersistent uses\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Compiler","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Compiler"}});