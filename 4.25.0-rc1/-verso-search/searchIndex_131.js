window.docContents[131].resolve({"/Axioms/#axioms":{"contents":"Axioms are postulated constants.\nWhile the axiom's type must itself be a type (that is, it must have type Sort u), there are no further requirements.\nAxioms do not reduce to other terms.\n\nAxioms can be used to experiment with the consequences of an idea before investing the time required to construct a model or prove a theorem.\nThey can also be used to adopt reasoning principles that can't otherwise be accessed in Lean's type theory; Lean itself provides three such axioms that are known to be consistent.\nHowever, axioms should be used with caution: axioms that are inconsistent with one another, or just false, undermine the very foundations of proofs.\nLean automatically tracks the axioms that each proof depends on so that they can be audited.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"8. Axioms","id":"/Axioms/#axioms"},"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Size":{"contents":"Computes the size of the subarray.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","header":"19.16.5.2. Size","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Size"},"/Basic-Types/Maps-and-Sets/#DTreeMap":{"contents":"The declarations in this section should be imported using import Std.DTreeMap.\n\nDependent tree maps.A tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one entry\nwith key either a or b in a tree map. Looking up either a or b always yields the same entry,\nif any is present. The get operations of the dependent tree map additionally require a\nLawfulEqCmp instance to ensure that cmp a b = .eq always implies a = b, so that their\nrespective value types are equal.To avoid expensive copies, users should make sure that the tree map is used linearly.Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.For use in proofs, the type Std.ExtDTreeMap of extensional dependent tree maps should be\npreferred. This type comes with several extensionality lemmas and provides the same functions but\nrequires a TransCmp instance to work with.These tree maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.DTreeMap.Raw and\nStd.DTreeMap.Raw.WF unbundle the invariant from the tree map. When in doubt, prefer\nDTreeMap over DTreeMap.Raw.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.18.9. Dependent Tree-Based Maps","id":"/Basic-Types/Maps-and-Sets/#DTreeMap"},"/Basic-Types/Strings/#string-api-lookup":{"contents":"Creates a new string that contains the first n characters (Unicode code points) of s.If n is greater than s.length, returns s.Examples:* \"red green blue\".take 3 = \"red\"* \"red green blue\".take 1 = \"r\"* \"red green blue\".take 0 = \"\"* \"red green blue\".take 100 = \"red green blue\"\n\nCreates a new string that contains the longest prefix of s in which p returns true for all\ncharacters.Examples:* \"red green blue\".takeWhile (·.isLetter) = \"red\"* \"red green blue\".takeWhile (· == 'r') = \"r\"* \"red green blue\".takeWhile (· != 'n') = \"red gree\"* \"red green blue\".takeWhile (fun _ => true) = \"red green blue\"\n\nCreates a new string that contains the last n characters (Unicode code points) of s.If n is greater than s.length, returns s.Examples:* \"red green blue\".takeRight 4 = \"blue\"* \"red green blue\".takeRight 1 = \"e\"* \"red green blue\".takeRight 0 = \"\"* \"red green blue\".takeRight 100 = \"red green blue\"\n\nCreates a new string that contains the longest suffix of s in which p returns true for all\ncharacters.Examples:* \"red green blue\".takeRightWhile (·.isLetter) = \"blue\"* \"red green blue\".takeRightWhile (· == 'e') = \"e\"* \"red green blue\".takeRightWhile (· != 'n') = \" blue\"* \"red green blue\".takeRightWhile (fun _ => true) = \"red green blue\"\n\nRemoves the specified number of characters (Unicode code points) from the start of the string.If n is greater than s.length, returns \"\".Examples:* \"red green blue\".drop 4 = \"green blue\"* \"red green blue\".drop 10 = \"blue\"* \"red green blue\".drop 50 = \"\"\n\nCreates a new string by removing the longest prefix from s in which p returns true for all\ncharacters.Examples:* \"red green blue\".dropWhile (·.isLetter) = \" green blue\"* \"red green blue\".dropWhile (· == 'r') = \"ed green blue\"* \"red green blue\".dropWhile (· != 'n') = \"n blue\"* \"red green blue\".dropWhile (fun _ => true) = \"\"\n\nRemoves the specified number of characters (Unicode code points) from the end of the string.If n is greater than s.length, returns \"\".Examples:* \"red green blue\".dropRight 5 = \"red green\"* \"red green blue\".dropRight 11 = \"red\"* \"red green blue\".dropRight 50 = \"\"\n\nCreates a new string by removing the longest suffix from s in which p returns true for all\ncharacters.Examples:* \"red green blue\".dropRightWhile (·.isLetter) = \"red green \"* \"red green blue\".dropRightWhile (· == 'e') = \"red green blu\"* \"red green blue\".dropRightWhile (· != 'n') = \"red green\"* \"red green blue\".dropRightWhile (fun _ => true) = \"\"\n\nIf pre is a prefix of s, returns the remainder. Returns none otherwise.The string pre is a prefix of s if there exists a t : String such that s = pre ++ t. If so,\nthe result is some t.Use String.stripPrefix to return the string unchanged when pre is not a prefix.Examples:* \"red green blue\".dropPrefix? \"red \" = some \"green blue\"* \"red green blue\".dropPrefix? \"reed \" = none* \"red green blue\".dropPrefix? \"\" = some \"red green blue\"\n\nIf pre is a prefix of s, returns the remainder. Returns s unmodified otherwise.The string pre is a prefix of s if there exists a t : String such that s = pre ++ t. If so,\nthe result is t. Otherwise, it is s.Use String.dropPrefix? to return none when pre is not a prefix.Examples:* \"red green blue\".stripPrefix \"red \" = \"green blue\"* \"red green blue\".stripPrefix \"reed \" = \"red green blue\"* \"red green blue\".stripPrefix \"\" = \"red green blue\"\n\nIf suff is a suffix of s, returns the remainder. Returns none otherwise.The string suff is a suffix of s if there exists a t : String such that s = t ++ suff. If so,\nthe result is some t.Use String.stripSuffix to return the string unchanged when suff is not a suffix.Examples:* \"red green blue\".dropSuffix? \" blue\" = some \"red green\"* \"red green blue\".dropSuffix? \" blu \" = none* \"red green blue\".dropSuffix? \"\" = some \"red green blue\"\n\nIf suff is a suffix of s, returns the remainder. Returns s unmodified otherwise.The string suff is a suffix of s if there exists a t : String such that s = t ++ suff. If so,\nthe result is t. Otherwise, it is s.Use String.dropSuffix? to return none when suff is not a suffix.Examples:* \"red green blue\".stripSuffix \" blue\" = \"red green\"* \"red green blue\".stripSuffix \" blu \" = \"red green blue\"* \"red green blue\".stripSuffix \"\" = \"red green blue\"\n\nRemoves leading and trailing whitespace from a string.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trim = \"abc\"* \"   abc\".trim = \"abc\"* \"abc \\t  \".trim = \"abc\"* \"  abc   \".trim = \"abc\"* \"abc\\ndef\\n\".trim = \"abc\\ndef\"\n\nRemoves leading whitespace from a string.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trimLeft = \"abc\"* \"   abc\".trimLeft = \"   abc\"* \"abc \\t  \".trimLeft = \"abc \\t  \"* \"  abc   \".trimLeft = \"abc   \"* \"abc\\ndef\\n\".trimLeft = \"abc\\ndef\\n\"\n\nRemoves trailing whitespace from a string.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trimRight = \"abc\"* \"   abc\".trimRight = \"   abc\"* \"abc \\t  \".trimRight = \"abc\"* \"  abc   \".trimRight = \"  abc\"* \"abc\\ndef\\n\".trimRight = \"abc\\ndef\"\n\nConsistently de-indents the lines in a string, removing the same amount of leading whitespace from\neach line such that the least-indented line has no leading whitespace.The number of leading whitespace characters to remove from each line is determined by counting the\nnumber of leading space (' ') and tab ('\\t') characters on lines after the first line that also\ncontain non-whitespace characters. No distinction is made between tab and space characters; both\ncount equally.The least number of leading whitespace characters found is then removed from the beginning of each\nline. The first line's leading whitespace is not counted when determining how far to de-indent the\nstring, but leading whitespace is removed from it.Examples:* \"Here:\\n  fun x =>\\n    x + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n  x + 1\"* \"Here:\\n\\t\\tfun x =>\\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n \\tx + 1\"* \"Here:\\n\\t\\tfun x =>\\n \\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n\\n \\tx + 1\"\n\nReturns the first character in s. If s = \"\", returns (default : Char).Examples:* \"abc\".front = 'a'* \"\".front = (default : Char)\n\nReturns the last character in s. If s = \"\", returns (default : Char).Examples:* \"abc\".back = 'c'* \"\".back = (default : Char)\n\nReturns the position of the first occurrence of a character, c, in a string s. If s does not\ncontain c, returns s.endPos.Examples:* \"abcba\".posOf 'a' = ⟨0⟩* \"abcba\".posOf 'z' = ⟨5⟩* \"L∃∀N\".posOf '∀' = ⟨4⟩\n\nReturns the position of the last occurrence of a character, c, in a string s. If s does not\ncontain c, returns none.Examples:* \"abcabc\".revPosOf 'a' = some ⟨3⟩* \"abcabc\".revPosOf 'z' = none* \"L∃∀N\".revPosOf '∀' = some ⟨4⟩\n\nChecks whether a string contains the specified character.Examples:* \"green\".contains 'e' = true* \"green\".contains 'x' = false* \"\".contains 'x' = false\n\nReturns the character index that corresponds to the provided position (i.e. UTF-8 byte index) in a\nstring.If the position is at the end of the string, then the string's length in characters is returned. If\nthe position is invalid due to pointing at the middle of a UTF-8 byte sequence, then the character\nindex of the next character after the position is returned.Examples:* \"L∃∀N\".offsetOfPos ⟨0⟩ = 0* \"L∃∀N\".offsetOfPos ⟨1⟩ = 1* \"L∃∀N\".offsetOfPos ⟨2⟩ = 2* \"L∃∀N\".offsetOfPos ⟨4⟩ = 2* \"L∃∀N\".offsetOfPos ⟨5⟩ = 3* \"L∃∀N\".offsetOfPos ⟨50⟩ = 4\n\nIn the string s, replaces all occurrences of pattern with replacement.Examples:* \"red green blue\".replace \"e\" \"\" = \"rd grn blu\"* \"red green blue\".replace \"ee\" \"E\" = \"red grEn blue\"* \"red green blue\".replace \"e\" \"E\" = \"rEd grEEn bluE\"\n\nReturns the position of the beginning of the line that contains the position pos.Lines are ended by '\\n', and the returned position is either 0 : String.Pos or immediately after\na '\\n' character.\n\nFinds the position of the first character in a string for which the Boolean predicate p returns\ntrue. If there is no such character in the string, then the end position of the string is\nreturned.Examples:* \"coffee tea water\".find (·.isWhitespace) = ⟨6⟩* \"tea\".find (· == 'X') = ⟨3⟩* \"\".find (· == 'X') = ⟨0⟩\n\nFinds the position of the last character in a string for which the Boolean predicate p returns\ntrue. If there is no such character in the string, then none is returned.Examples:* \"coffee tea water\".revFind (·.isWhitespace) = some ⟨10⟩* \"tea\".revFind (· == 'X') = none* \"\".revFind (· == 'X') = none\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.6. Lookups and Modifications","id":"/Basic-Types/Strings/#string-api-lookup"}});