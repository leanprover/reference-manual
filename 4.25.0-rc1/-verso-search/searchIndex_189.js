window.docContents[189].resolve({"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Conversion":{"contents":"Converts an optional value to an array with zero or one element.Examples:* (some \"value\").toArray = #[\"value\"]* none.toArray = #[]\n\nConverts an optional value to a list with zero or one element.Examples:* (some \"value\").toList = [\"value\"]* none.toList = []\n\nReturns a representation of an optional value that should be able to be parsed as an equivalent\noptional value.This function is typically accessed through the Repr (Option Œ±) instance.\n\nFormats an optional value, with no expectation that the Lean parser should be able to parse the\nresult.This function is usually accessed through the ToFormat (Option Œ±) instance.\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.3. Conversion","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Conversion"},"/Build-Tools-and-Distribution/Lake/#lake-vocab":{"contents":"A package is the basic unit of Lean code distribution.\nA single package may contain multiple libraries or executable programs.\nA package consist of a directory that contains a package configuration file together with source code.\nPackages may require other packages, in which case those packages' code (more specifically, their targets) are made available.\nThe direct dependencies of a package are those that it requires, and the transitive dependencies are the direct dependencies of a package together with their transitive dependencies.\nPackages may either be obtained from Reservoir, the Lean package repository, or from a manually-specified location.\nGit dependencies are specified by a Git repository URL along with a revision (branch, tag, or hash) and must be cloned locally prior to build, while local path dependencies are specified by a path relative to the package's directory.\n\nA workspace is a directory on disk that contains a working copy of a package's source code and the source code of all transitive dependencies that are not specified as local paths.\nThe package for which the workspace was created is the root package.\nThe workspace also contains any built artifacts for the package, enabling incremental builds.\nDependencies and artifacts do not need to be present for a directory to be considered a workspace; commands such as update and build produce them if they are missing.\nLake is typically used in a workspace.init and new, which create workspaces, are exceptions.\nWorkspaces typically have the following layout:* lean-toolchain - The toolchain file.* lakefile.toml or lakefile.lean - The package configuration file for the root package.* lake-manifest.json - The root package's manifest.* .lake/ - Intermediate state managed by Lake, such as built artifacts and dependency source code.* .lake/lakefile.olean - The root package's configuration, cached.* .lake/packages/ - The workspace's package directory, which contains copies of all non-local transitive dependencies of the root package, with their built artifacts in their own .lake directories.* .lake/build/ - The build directory, which contains built artifacts for the root package:* .lake/build/bin - The package's binary directory, which contains built executables.* .lake/build/lib - The package's library directory, which contains built libraries and .olean files.* .lake/build/ir - The package's intermediate result directory, which contains generated intermediate artifacts, primarily C code.\n\nWorkspace Layout \n\nA package configuration file specifies the dependencies, settings, and targets of a package.\nPackages can specify configuration options that apply to all their contained targets.\nThey can be written in two formats:* The TOML format (lakefile.toml) is used for fully declarative package configurations.* The Lean format (lakefile.lean) additionally supports the use of Lean code to configure the package in ways not supported by the declarative options.\n\nA manifest tracks the specific versions of other packages that are used in a package.\nTogether, a manifest and a package configuration file specify a unique set of transitive dependencies for the package.\nBefore building, Lake synchronizes the local copy of each dependency with the version specified in the manifest.\nIf no manifest is available, Lake fetches the latest matching versions of each dependency and creates a manifest.\nIt is an error if the package names listed in the manifest do not match those used by the package; the manifest must be updated using update prior to building.\nManifests should be considered part of the package's code and should normally be checked into source control.\n\nA target represents an output that can be requested by a user.\nA persistent build output, such as object code, an executable binary, or an .olean file, is called an artifact.\nIn the process of producing an artifact, Lake may need to produce further artifacts; for example, compiling a Lean program into an executable requires that it and its dependencies be compiled to object files, which are themselves produced from C source files, which result from elaborating Lean sourcefiles and producing .olean files.\nEach link in this chain is a target, and Lake arranges for each to be built in turn.\nAt the start of the chain are the initial targets:* Packages are units of Lean code that are distributed as a unit.* Libraries are collections of Lean modules, organized hierarchically under one or more module roots.* Executables consist of a single module that defines main.* External libraries are non-Lean static libraries that will be linked to the binaries of the package and its dependents, including both their shared libraries and executables.* Custom targets contain arbitrary code to run a build, written using Lake's internal API.In addition to their Lean code, packages, libraries, and executables contain configuration settings that affect subsequent build steps.\nPackages may specify a set of default targets.\nDefault targets are the initial targets in the package that are to be built in contexts where a package is specified but specific targets are not.\n\nThe log contains information produced during a build.\nLogs are saved so they can be replayed during incremental builds.\nMessages in the log have four levels, ordered by severity:1. Trace messages contain internal build details that are often specific to the machine on which the build is running, including the specific invocations of Lean and other tools that are passed to the shell.2. Informational messages contain general informational output that is not expected to indicate a problem with the code, such as the results of a #eval command.3. Warnings indicate potential problems, such as unused variable bindings.4. Errors explain why parsing and elaboration could not complete.By default, trace messages are hidden and the others are shown.\nThe threshold can be adjusted using the --log-level option, the --verbose flag, or the --quiet flag.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake","header":"22.1.1. Concepts and Terminology","id":"/Build-Tools-and-Distribution/Lake/#lake-vocab"},"/Introduction/#example-boxes":{"contents":"Illustrative examples are in callout boxes, as below:\n\nEven NumbersThis is an example of an example.One way to define even numbers is via an inductive predicate:inductive Even : Nat ‚Üí Prop where\n  | zero : Even 0\n  | plusTwo : Even n ‚Üí Even (n + 2)\n\n\n","context":"Lean Reference\u0009Introduction\u0009Typographical Conventions","header":"1.2.2. Examples","id":"/Introduction/#example-boxes"},"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Language-features___-tactics___-and-metaprograms":{"contents":"* bv_decide tactic. This release introduces a new tactic for proving goals involving BitVec and Bool. It reduces the goal to a SAT instance that is refuted by an external solver, and the resulting LRAT proof is checked in Lean. This is used to synthesize a proof of the goal by reflection. As this process uses verified algorithms, proofs generated by this tactic use Lean.ofReduceBool, so this tactic includes the Lean compiler as part of the trusted code base. The external solver CaDiCaL is included with Lean and does not need to be installed separately to make use of bv_decide.For example, we can use bv_decide to verify that a bit twiddling formula leaves at most one bit set:def popcount (x : BitVec 64) : BitVec 64 :=\n  let rec go (x pop : BitVec 64) : Nat ‚Üí BitVec 64\n    | 0 => pop\n    | n + 1 => go (x >>> 2) (pop + (x &&& 1)) n\n  go x 0 64\n\nexample (x : BitVec 64) : popcount ((x &&& (x - 1)) ^^^ x) ‚â§ 1 := by\n  simp only [popcount, popcount.go]\n  bv_decide\nWhen the external solver fails to refute the SAT instance generated by bv_decide, it can report a counterexample:/--\nerror: The prover found a counterexample, consider the following assignment:\nx = 0xffffffffffffffff#64\n-/\n#guard_msgs in\nexample (x : BitVec 64) : x < x + 1 := by\n  bv_decide\nSee Lean.Elab.Tactic.BVDecide for a more detailed overview, and look in tests/lean/run/bv_* for examples.#5013, #5074, #5100, #5113, #5137, #5203, #5212, #5220.* simp tactic* #4988 fixes a panic in the reducePow simproc.* #5071 exposes the index option to the dsimp tactic, introduced to simp in #4202.* #5159 fixes a panic at Fin.isValue simproc.* #5167 and #5175 rename the simpCtorEq simproc to reduceCtorEq and makes it optional. (See breaking changes.)* #5187 ensures reduceCtorEq is enabled in the norm_cast tactic.* #5073 modifies the simp debug trace messages to tag with \"dpre\" and \"dpost\" instead of \"pre\" and \"post\" when in definitional rewrite mode. #5054 explains the reduce steps for trace.Debug.Meta.Tactic.simp trace messages.* ext tactic* #4996 reduces default maximum iteration depth from 1000000 to 100.* induction tactic* #5117 fixes a bug where let bindings in minor premises wouldn't be counted correctly.* omega tactic* #5157 fixes a panic.* conv tactic* #5149 improves arg n to handle subsingleton instance arguments.* #5044 upstreams the #time command.* #5079 makes #check and #reduce typecheck the elaborated terms.* Incrementality* #4974 fixes regression where we would not interrupt elaboration of previous document versions.* #5004 fixes a performance regression.* #5001 disables incremental body elaboration in presence of where clauses in declarations.* #5018 enables infotrees on the command line for ilean generation.* #5040 and #5056 improve performance of info trees.* #5090 disables incrementality in the case .. | .. tactic.* #5312 fixes a bug where changing whitespace after the module header could break subsequent commands.* Definitions* #5016 and #5066 add clean_wf tactic to clean up tactic state in decreasing_by. This can be disabled with set_option debug.rawDecreasingByGoal false.* #5055 unifies equational theorems between structural and well-founded recursion.* #5041 allows mutually recursive functions to use different parameter names among the ‚Äúfixed parameter prefix‚Äù* #4154 and #5109 add fine-grained equational lemmas for non-recursive functions. See breaking changes.* #5129 unifies equation lemmas for recursive and non-recursive definitions. The backward.eqns.deepRecursiveSplit option can be set to false to get the old behavior. See breaking changes.* #5141 adds f.eq_unfold lemmas. Now Lean produces the following zoo of rewrite rules:Option.map.eq_1      : Option.map f none = none\nOption.map.eq_2      : Option.map f (some x) = some (f x)\nOption.map.eq_def    : Option.map f p = match o with | none => none | (some x) => some (f x)\nOption.map.eq_unfold : Option.map = fun f p => match o with | none => none | (some x) => some (f x)\nThe f.eq_unfold variant is especially useful to rewrite with rw under binders.* #5136 fixes bugs in recursion over predicates.* Variable inclusion* #5206 documents that include currently only applies to theorems.* Elaboration* #4926 fixes a bug where autoparam errors were associated to an incorrect source position.* #4833 fixes an issue where cdot anonymous functions (e.g. (¬∑ + ¬∑)) would not handle ambiguous notation correctly. Numbers the parameters, making this example expand as fun x1 x2 => x1 + x2 rather than fun x x_1 => x + x_1.* #5037 improves strength of the tactic that proves array indexing is in bounds.* #5119 fixes a bug in the tactic that proves indexing is in bounds where it could loop in the presence of mvars.* #5072 makes the structure type clickable in \"not a field of structure\" errors for structure instance notation.* #4717 fixes a bug where mutual inductive commands could create terms that the kernel rejects.* #5142 fixes a bug where variable could fail when mixing binder updates and declarations.* Other fixes or improvements* #5118 changes the definition of the syntheticHole parser so that hovering over _ in ?_ gives the docstring for synthetic holes.* #5173 uses the emoji variant selector for ‚úÖÔ∏è,‚ùåÔ∏è,üí•Ô∏è in messages, improving fonts selection.* #5183 fixes a bug in rename_i where implementation detail hypotheses could be renamed.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.12.0 (2024-10-01)","header":"Language features, tactics, and metaprograms","id":"/releases/v4.12.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___12___0-_LPAR_2024-10-01_RPAR_--Language-features___-tactics___-and-metaprograms"}});