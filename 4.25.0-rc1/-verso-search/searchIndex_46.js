window.docContents[46].resolve({"/Definitions/Recursive-Definitions/#recursive-definitions":{"contents":"Allowing arbitrary recursive function definitions would make Lean's logic inconsistent.\nGeneral recursion makes it possible to write circular proofs: \"proposition P is true because proposition P is true\".\nOutside of proofs, an infinite loop could be assigned the type Empty, which can be used with nomatch or Empty.rec to prove any theorem.\n\nBanning recursive function definitions outright would render Lean far less useful: inductive types are key to defining both predicates and data, and they have a recursive structure.\nFurthermore, most useful recursive functions do not threaten soundness, and infinite loops usually indicate mistakes in definitions rather than intentional behavior.\nInstead of banning recursive functions, Lean requires that each recursive function is defined safely.\nWhile elaborating recursive definitions, the Lean elaborator also produces a justification that the function being defined is safe.The section on the elaborator's output in the overview of elaboration contextualizes the elaboration of recursive definitions in the overall context of the elaborator.\n\nThere are five main kinds of recursive functions that can be defined:\n\n Structurally recursive functions\n\nStructurally recursive functions take an argument such that the function makes recursive calls only on strict sub-components of said argument.Strictly speaking, arguments whose types are indexed families are grouped together with their indices, with the whole collection considered as a unit.\n  The elaborator translates the recursion into uses of the argument's recursor.\n  Because every type-correct use of a recursor is guaranteed to avoid infinite regress, this translation is evidence that the function terminates.\n  Applications of functions defined via recursors are definitionally equal to the result of the recursion, and are typically relatively efficient inside the kernel.\n\n Recursion over well-founded relations\n\nMany functions are also difficult to convert to structural recursion; for instance, a function may terminate because the difference between an array index and the size of the array decreases as the index increases, but Nat.rec isn't applicable because the index that increases is the function's argument.\n  Here, there is a measure of termination that decreases at each recursive call, but the measure is not itself an argument to the function.\n  In these cases, well-founded recursion can be used to define the function.\n  Well-founded recursion is a technique for systematically transforming recursive functions with a decreasing measure into recursive functions over proofs that every sequence of reductions to the measure eventually terminates at a minimum.\n  Applications of functions defined via well-founded recursion are not necessarily definitionally equal to their return values, but this equality can be proved as a proposition.\n  Even when definitional equalities exist, these functions are frequently slow to compute with because they require reducing proof terms that are often very large.\n\n Recursive functions as partial fixpoints\n\nThe definition of a function can be understood as an equation that specifies its behavior.\n  In certain cases, the existence of a function that satisfies this specification can be proven even when the recursive function does not necessarily terminate for all inputs.\n  This strategy is even applicable in some cases where the function definition does not necessarily terminate for all inputs.\n  These partial functions emerge as fixed points of these equations are called partial fixpoints.In particular, any function whose return type is in certain monads (e.g. Option) can be defined using this strategy.\n  Lean generates additional partial correctness theorems for these monadic functions.\n  As with well-founded recursion, applications of functions defined as partial fixpoints are not definitionally equal to their return values, but Lean generates theorems that propositionally equate the function to its unfolding and to the reduction behavior specified in its definition.\n\n Partial functions with nonempty codomains\n\nFor many applications, it's not important to reason about the implementation of certain functions.\n  A recursive function might be used only as part of the implementation of proof automation steps, or it might be an ordinary program that will never be formally proved correct.\n  In these cases, the Lean kernel does not need either definitional or propositional equalities to hold for the definition; it suffices that soundness is maintained.\n  Functions marked partial are treated as opaque constants by the kernel and are neither unfolded nor reduced.\n  All that is required for soundness is that their return type is inhabited.\n  Partial functions may still be used in compiled code as usual, and they may appear in propositions and proofs; their equational theory in Lean's logic is simply very weak.\n\n Unsafe recursive definitions\n\nUnsafe definitions have none of the restrictions of partial definitions.\n  They may freely make use of general recursion, and they may use features of Lean that break assumptions about its equational theory, such as primitives for casting (unsafeCast), checking pointer equality (ptrAddrUnsafe), and observing reference counts (isExclusiveUnsafe).\n  However, any declaration that refers to an unsafe definition must itself be marked unsafe, making it clear when logical soundness is not guaranteed.\n  Unsafe operations can be used to replace the implementations of other functions with more efficient variants in compiled code, while the kernel still uses the original definition.\n  The replaced function may be opaque, which results in the function name having a trivial equational theory in the logic, or it may be an ordinary function, in which case the function is used in the logic.\n  Use this feature with care: logical soundness is not at risk, but the behavior of programs written in Lean may diverge from their verified logical models if the unsafe implementation is incorrect.\n\n\n\n\n\nAs described in the overview of the elaborator's output, elaboration of recursive functions proceeds in two phases:\n\n1. The definition is elaborated as if Lean's core type theory had recursive definitions.\n    Aside from using recursion, this provisional definition is fully elaborated.\n    The compiler generates code from these provisional definitions.2. A termination analysis attempts to use the four techniques to justify the function to Lean's kernel.\n    If the definition is marked unsafe or partial, then that technique is used.\n    If an explicit termination_by clause is present, then the indicated technique is the only one attempted.\n    If there is no such clause, then the elaborator performs a search, testing each parameter to the function as a candidate for structural recursion, and attempting to find a measure with a well-founded relation that decreases at each recursive call.\n\nThis section describes the rules that govern recursive functions.\nAfter a description of mutual recursion, each of the five kinds of recursive definitions is specified, along with the tradeoffs between reasoning power and flexibility that go along with each.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions","header":"7.6. Recursive Definitions","id":"/Definitions/Recursive-Definitions/#recursive-definitions"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations":{"contents":"One form of do item is a term.\n\nTerms in do-Notation\n\nA term followed by a sequence of items is translated to a use of bind; in particular, do e1; es is translated to e1 >>= fun () => do es.\n\n* do Item* Desugaring\n* do\ne1\nes\n* e1 >>= fun () => do es\n\n\n\n\nThe result of the term's computation may also be named, allowing it to be used in subsequent steps.\nThis is done using let.\n\n\n\nData Dependence in do-NotationThere are two forms of monadic let-binding in a do block.\nThe first binds an identifier to the result, with an optional type annotation:The second binds a pattern to the result.\nThe fallback clause, beginning with |, specifies the behavior when the pattern does not match the result.\n\nThis syntax is also translated to a use of bind.\ndo let x ← e1; es is translated to e1 >>= fun x => do es, and fallback clauses are translated to default pattern matches.\nlet may also be used with the standard definition syntax := instead of ←.\nThis indicates a pure, rather than monadic, definition:\n\nLocal Definitions in do-Notation\n\ndo let x := e; es is translated to let x := e; do es.\n\n* do Item* Desugaring\n* do\nlet x ← e1\nes\n* e1 >>= fun x =>\n  do es\n* do\nlet some x ← e1?\n  | fallback\nes\n* e1? >>= fun\n  | some x => do\n    es\n  | _ => fallback\n* do\nlet x := e\nes\n* let x := e\ndo es\n\n\n\n\nWithin a do block, ← may be used as a prefix operator.\nThe expression to which it is applied is replaced with a fresh variable, which is bound using bind just before the current step.\nThis allows monadic effects to be used in positions that otherwise might expect a pure value, while still maintaining the distinction between describing an effectful computation and actually executing its effects.\nMultiple occurrences of ← are processed from left to right, inside to outside.\n\nExample Nested Action Desugarings* Example do Item* Desugaring\n* do\nf (← e1) (← e2)\nes\n* do\nlet x ← e1\nlet y ← e2\nf x y\nes\n* do\nlet x := g (← h (← e1))\nes\n* do\nlet y ← e1\nlet z ← h y\nlet x := g z\nes\n\n\n\n\nIn addition to convenient support for sequential computations with data dependencies, do-notation also supports the local addition of a variety of effects, including early return, local mutable state, and loops with early termination.\nThese effects are implemented via transformations of the entire do block in a manner akin to monad transformers, rather than via a local desugaring.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.1. Sequential Computations","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations"},"/releases/v4.18.0/#release-v4___18___0":{"contents":"For this release, 344 changes landed. In addition to the 166 feature additions and 38 fixes listed below there were 13 refactoring changes, 10 documentation improvements, 3 performance improvements, 4 improvements to the test suite and 109 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.18.0 (2025-04-02)","id":"/releases/v4.18.0/#release-v4___18___0"},"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Pretty-Printing":{"contents":"* #8391 adds an unexpander for Vector.mk that unexpands Vector.mk #[...] _ to #v[...].-- previously:\n#check #v[1, 2, 3] -- { toArray := #[1, 2, 3], size_toArray := ⋯ } : Vector Nat 3\n-- now:\n#check #v[1, 2, 3] -- #v[1, 2, 3] : Vector Nat 3\n* #9475 fixes the way some syntaxes are pretty printed due to missing\nwhitespace advice.* #9494 fixes an issue that caused some error messages to attempt to\ndisplay hovers for nonexistent identifiers.* #9555 allows hints in message data to specify custom preview spans\nthat extend beyond the edit region specified by the code action.* #9778 modifies the pretty printing of anonymous metavariables to use\nthe index rather than the internal name. This leads to smaller numerical\nsuffixes in ?m.123 since the indices are numbered within a given\nmetavariable context rather than across an entire file, hence each\ncommand gets its own numbering. This does not yet affect pretty printing\nof universe level metavariables.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.23.0 (2025-09-15)","header":"Pretty Printing","id":"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Pretty-Printing"},"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc1-_LPAR_2025-10-20_RPAR_--Library":{"contents":"* #9258 adds support for signal handlers to the Lean standard library.* #9298 adds support the Count Trailing Zeros operation BitVec.ctz to\nthe bitvector library and to bv_decide, relying on the existing clz\ncircuit. We also build some theory around BitVec.ctz (analogous to the\ntheory existing for BitVec.clz) and introduce lemmas\nBitVec.[ctz_eq_reverse_clz, clz_eq_reverse_ctz, ctz_lt_iff_ne_zero, getLsbD_false_of_lt_ctz, getLsbD_true_ctz_of_ne_zero, two_pow_ctz_le_toNat_of_ne_zero, reverse_reverse_eq, reverse_eq_zero_iff].* #9932 adds LawfulMonad and WPMonad instances for Option and\nOptionT.* #10304 redefines String to be the type of byte arrays b for which\nb.IsValidUtf8.* #10319 \"monomorphizes\" the structure Std.PRange shape α, replacing it\nwith nine distinct structures Std.Rcc, Std.Rco, Std.Rci etc., one\nfor each possible shape of a range's bounds. This change was necessary\nbecause the shape polymorphism is detrimental to attempts of automation.* #10366 refactors the Async module to use the Async type in all of the\nAsync files.* #10367 adds vectored write for TCP and UDP (that helps a lot with not\ncopying the arrays over and over) and fix a RC issue in TCP and UDP\ncancel functions with the line lean_dec((lean_object*)udp_socket); and\na similar one that tries to decrement the object inside of the socket.* #10368 adds Notify that is a structure that is similar to CondVar\nbut it's used for concurrency. The main difference between\nStd.Sync.Notify and Std.Condvar is that depends on a Std.Mutex and\nblocks the entire thread that the Task is using while waiting.* #10369 adds a multi-consumer, multi-producer channel to Std.Sync.* #10370 adds async type classes for streams.* #10400 adds the StreamMap type that enables multiplexing in\nasynchronous streams.* #10407 adds @[method_specs_simp] in Init for type classes like\nHAppend.* #10457 introduces safe alternatives to String.Pos and Substring\nthat can only represent valid positions/slices.* #10487 adds vectored write and fix rc issues in tcp and udp cancel\nfunctions.* #10510 adds a Std.CancellationToken type* #10514 defines the new String.Slice API.* #10552 ensures that Substring.beq is reflexive, and in particular\nsatisfies the equivalence ss1 == ss2 <-> ss1.toString = ss2.toString.* #10611 adds adds union operation on DHashMap/HashMap/HashSet and\ntheir raw variants and provides lemmas about union operations.* #10618 removes superfluous Monad instances from the spec lemmas of\nthe MonadExceptOf lifting framework.* #10624 renames String.Pos to String.Pos.Raw.* #10627 adds lemmas forall_fin_zero and exists_fin_zero. It also\nmarks lemmas forall_fin_zero, forall_fin_one, forall_fin_two,\nexists_fin_zero, exists_fin_one, exists_fin_two with simp\nattribute.* #10630 aims to fix the Timer API selector to make it finish as soon as\npossible when unregistered. This change makes the Selectable.one\nfunction drop the selectables array as soon as possible, so when\ncombined with finalizers that have some effects like the TCP socket\nfinalizer, it runs it as soon as possible.* #10631 exposes the definitions about Int*. The main reason is that\nthe SInt simprocs require many of them to be exposed. Furthermore,\ndecide now works with Int* operations. This fixes #10631.* #10633 provides range support for the signed finite number types\nInt{8,16,32,64} and ISize. The proof obligations are handled by\nreducing all of them to proofs about an internal UpwardEnumerable\ninstance for BitVec interpreted as signed numbers.* #10634 defines ByteArray.validateUTF8, uses it to show that\nByteArray.IsValidUtf8 is decidable and redefines String.fromUTF8 and\nfriends to use it.* #10636 renames String.getUtf8Byte to String.getUTF8Byte in order to\nadhere to the standard library naming convention.* #10642 introduces List.Cursor.pos as an abbreviation for\nprefix.length.* #10645 renames Stream to Std.Stream so that the name becomes\navailable to mathlib after a deprecation cycle.* #10649 renames Nat.and_distrib_right to Nat.and_or_distrib_right.\nThis is to make the name consistent with other theorems in the same file\n(e.g. Nat.and_or_distrib_left).* #10653 adds equational lemmas about (filter-)mapping and then folding\niterators.* #10667 adds more selectors for TCP and Signals.* #10676 adds the IO.FS.hardLink function, which can be used to create\nhard links.* #10685 introduces LT and LE instances on String.ValidPos and\nString.Slice.Pos.* #10686 introduces any, anyM, all and allM for pure and monadic\niterators. It also provides lemmas about them.* #10713 enforces rules around arithmetic of String.Pos.Raw.* #10728 introduces the flatMap iterator combinator. It also adds\nlemmas relating flatMap to toList and toArray.* #10735 moves many operations involving String.Pos.Raw to a the\nString.Pos.Raw namespace with the eventual aim of freeing up the\nString namespace to contain operations using String.ValidPos (to be\nrenamed to String.Pos) instead.* #10761 provides iterators on hash maps.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.25.0-rc1 (2025-10-20)","header":"Library","id":"/releases/v4.25.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___25___0-rc1-_LPAR_2025-10-20_RPAR_--Library"}});