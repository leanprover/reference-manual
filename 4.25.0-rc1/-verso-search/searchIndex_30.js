window.docContents[30].resolve({"/Coercions/Coercing-to-Sorts/#sort-coercion":{"contents":"The Lean elaborator expects types in certain positions without necessarily being able to determine the type's universe ahead of time.\nFor example, the term following the colon in a definition header might be a proposition or a type.\nThe ordinary coercion mechanism is not applicable because it requires a specific expected type, and there's no way to express that the expected type could be any universe in the Coe class.\n\nWhen a term is elaborated in a position where a proposition or type is expected, but the inferred type of the elaborated term is not a proposition or type, Lean  attempts to recover from the error by synthesizing an instance of CoeSort.\nIf the instance is found, and the resulting type is itself a type, then it the coercion is inserted and unfolded.\n\nNot every situation in which the elaborator expects a universe requires CoeSort.\nIn some cases, a particular universe is available as an expected type.\nIn these situations, ordinary coercion insertion using CoeT is used.\nInstances of CoeSort can be used to synthesize instances of CoeOut, so no separate instance is needed to support this use case.\nIn general, coercions to types should be implemented as CoeSort.\n\nCoeSort α β is a coercion to a sort. β must be a universe, and this is\ntriggered when a : α appears in a place where a type is expected, like\n(x : a) or a → a.\nCoeSort instances apply to CoeOut as well.Coerces a value of type α to β, which must be a universe.\n\nExplicit Coercion to SortsCoercions to sorts can be explicitly triggered using the ↥ prefix operator.\n\nSort CoercionsA monoid is a type equipped with an associative binary operation and an identity element.\nWhile monoid structure can be defined as a type class, it can also be defined as a structure that “bundles up” the structure with the type:structure Monoid where\n  Carrier : Type u\n  op : Carrier → Carrier → Carrier\n  id : Carrier\n  op_assoc :\n    ∀ (x y z : Carrier), op x (op y z) = op (op x y) z\n  id_op_identity : ∀ (x : Carrier), op id x = x\n  op_id_identity : ∀ (x : Carrier), op x id = x\nThe type Monoid does not indicate the carrier:def StringMonoid : Monoid where\n  Carrier := String\n  op := (· ++ ·)\n  id := \"\"\n  op_assoc := by intros; simp [String.append_assoc]\n  id_op_identity := by intros; simp\n  op_id_identity := by intros; simp\nHowever, a CoeSort instance can be implemented that applies the Monoid.Carrier projection when a monoid is used in a position where Lean would expect a type:instance : CoeSort Monoid (Type u) where\n  coe m := m.Carrier\n\nexample : StringMonoid := \"hello\"\n\n\nSort Coercions as Ordinary CoercionsThe inductive type NatOrBool represents the types Nat and Bool.\nThey can be coerced to the actual types Nat and Bool:inductive NatOrBool where\n  | nat | bool\n\n@[coe]\nabbrev NatOrBool.asType : NatOrBool → Type\n  | .nat => Nat\n  | .bool => Bool\n\ninstance : CoeSort NatOrBool Type where\n  coe := NatOrBool.asType\n\nopen NatOrBool\nThe CoeSort instance is used when nat occurs to the right of a colon:def x : nat := 5\nWhen an expected type is available, ordinary coercion insertion is used.\nIn this case, the CoeSort instance is used to synthesize a CoeOut NatOrBool Type instance, which chains with the Coe Type (Option Type) instance to recover from the type error.def y : Option Type := bool\n\n\n","context":"Lean Reference\u0009Coercions","header":"12.3. Coercing to Sorts","id":"/Coercions/Coercing-to-Sorts/#sort-coercion"},"/Run-Time-Code/#runtime":{"contents":"Compiled Lean code uses services provided by the Lean runtime.\nThe runtime contains efficient, low-level primitives that bridge the gap between the Lean language and the supported platforms.\nThese services include:\n\n Memory management\n\nLean does not require programmers to manually manage memory.\n    Space is allocated when needed to store a value, and values that can no longer be reached (and are thus irrelevant) are deallocated.\n    In particular, Lean uses reference counting, where each allocated object maintains a count of incoming references.\n    The compiler emits calls to memory management routines that allocate memory and modify reference counts, and these routines are provided by the runtime, along with the data structures that represent Lean values in compiled code.\n\n Multiple Threads\n\nThe Task API provides the ability to write parallel and concurrent code.\n    The runtime is responsible for scheduling Lean tasks across operating-system threads.\n\n Primitive operators\n\nMany built-in types, including Nat, Array, String, and fixed-width integers, have special representations for reasons of efficiency.\n    The runtime provides implementations of these types' primitive operators that take advantage of these optimized representations.\n\n\n\nThere are many primitive operators.\nThey are described in their respective sections under Basic Types.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"21. Run-Time Code","id":"/Run-Time-Code/#runtime"},"/The-Type-System/Universes/#level-expressions":{"contents":"Levels that occur in a definition are not restricted to just variables and addition of constants.\nMore complex relationships between universes can be defined using level expressions.\n\nLevel ::= 0 | 1 | 2 | ...  -- Concrete levels\n        | u, v             -- Variables\n        | Level + n        -- Addition of constants\n        | max Level Level  -- Least upper bound\n        | imax Level Level -- Impredicative LUB\n\n\nGiven an assignment of level variables to concrete numbers, evaluating these expressions follows the usual rules of arithmetic.\nThe imax operation is defined as follows:\n\n\\mathtt{imax}\\ u\\ v = \\begin{cases}0 & \\mathrm{when\\ }v = 0\\\\\\mathtt{max}\\ u\\ v&\\mathrm{otherwise}\\end{cases}\n\nimax is used to implement impredicative quantification for Prop.\nIn particular, if A : Sort u and B : Sort v, then (x : A) → B : Sort (imax u v).\nIf B : Prop, then the function type is itself a Prop; otherwise, the function type's level is the maximum of u and v.\n\n","context":"Lean Reference\u0009Type System\u0009Universes\u0009Polymorphism","header":"4.3.2.1. Level Expressions","id":"/The-Type-System/Universes/#level-expressions"},"/releases/v4.10.0/#release-v4___10___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.10.0 (2024-07-31)","id":"/releases/v4.10.0/#release-v4___10___0"}});