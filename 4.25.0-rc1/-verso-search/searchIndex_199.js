window.docContents[199].resolve({"/Basic-Types/Arrays/#array-ffi":{"contents":"The representation of arrays in C. See the description of run-time Arrays for more details.\n\nReturns true if o is an array, or false otherwise.\n\nPerforms a runtime check that o is indeed an array. If o is not an array, an assertion fails.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays","header":"19.16.6. FFI","id":"/Basic-Types/Arrays/#array-ffi"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--General-State-API":{"contents":"State monads provide a value of a given type (the state) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. ST.Ref σ), or in other ways.In this class, σ is an outParam, which means that it is inferred from m. MonadStateOf σ\nprovides the same operations, but allows σ to influence instance synthesis.The mutable state of a state monad is visible between multiple do-blocks or functions, unlike\nlocal mutable state in do-notation.Retrieves the current value of the monad's mutable state.Replaces the current value of the mutable state with a new one.Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.It is equivalent to do let (a, s) := f (← get); set s; pure a. However, using modifyGet may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n\nRetrieves the current value of the monad's mutable state.\n\nMutates the current state, replacing its value with the result of applying f to it.Use modifyThe to explicitly select a state type to modify.It is equivalent to do set (f (← get)). However, using modify may lead to higher performance\nbecause it doesn't add a new reference to the state value. Additional references can inhibit\nin-place updates of data.\n\nApplies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.It is equivalent to do let (a, s) := f (← get); set s; pure a. However, using modifyGet may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n\nReplaces the state with the result of applying f to it. Returns the old value of the state.It is equivalent to get <* modify f but may be more efficient.\n\nState monads provide a value of a given type (the state) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. ST.Ref σ), or in other ways.In this class, σ is a semiOutParam, which means that it can influence the choice of instance.\nMonadState σ provides the same operations, but requires that σ be inferable from m.The mutable state of a state monad is visible between multiple do-blocks or functions, unlike\nlocal mutable state in do-notation.Retrieves the current value of the monad's mutable state.Replaces the current value of the mutable state with a new one.Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.It is equivalent to do let (a, s) := f (← get); set s; pure a. However, using modifyGet may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n\nGets the current state that has the explicitly-provided type σ. When the current monad has\nmultiple state types available, this function selects one of them.\n\nMutates the current state that has the explicitly-provided type σ, replacing its value with the\nresult of applying f to it. When the current monad has multiple state types available, this\nfunction selects one of them.It is equivalent to do set (f (← get)). However, using modify may lead to higher performance\nbecause it doesn't add a new reference to the state value. Additional references can inhibit\nin-place updates of data.\n\nApplies a function to the current state that has the explicitly-provided type σ. The function both\ncomputes a new state and a value. The new state replaces the current state, and the value is\nreturned.It is equivalent to do let (a, s) := f (← getThe σ); set s; pure a. However, using modifyGetThe\nmay lead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009State","header":"14.5.4.1. General State API","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--General-State-API"},"/IO/Mutable-References/#ref-locks":{"contents":"Mutable references can be used as a locking mechanism.\nTaking the contents of the reference causes attempts to take it or to read from it to block until it is set again.\nThis is a low-level feature that can be used to implement other synchronization mechanisms; it's usually better to rely on higher-level abstractions when possible.\n\nReads the value of a mutable reference cell, removing it.This causes subsequent attempts to read from or take the reference cell to block until a new value\nis written using ST.Ref.set.\n\nReference Cells as LocksThis program launches 100 threads.\nEach thread simulates a purchase attempt: it generates a random price, and if the account balance is sufficient, it decrements it by the price.\nIf the balance is not sufficient, then it is not decremented.\nBecause each thread takes the balance cell prior to checking it and only returns it when it is finished, the cell acts as a lock.\nUnlike using ST.Ref.modify, which atomically modifies the contents of the cell using a pure function, other IO actions may occur in the critical section\nThis program's main function is marked unsafe because take itself is unsafe.unsafe def main : IO Unit := do\n  let balance ← IO.mkRef (100 : Int)\n  let validationUsed ← IO.mkRef false\n\n  let mut orders := #[]\n\n  IO.println \"Sending out orders...\"\n  for _ in [0:100] do\n    let o ← IO.asTask (prio := .dedicated) do\n      let cost ← IO.rand 1 100\n      IO.sleep (← IO.rand 10 100).toUInt32\n      let b ← balance.take\n      if cost ≤ b then\n        balance.set (b - cost)\n      else\n        balance.set b\n        validationUsed.set true\n    orders := orders.push o\n\n  -- Wait until all orders are completed\n  for o in orders do\n    match o.get with\n    | .ok () => pure ()\n    | .error e => throw e\n\n  if (← validationUsed.get) then\n    IO.println \"Validation prevented a negative balance.\"\n\n  if (← balance.get) < 0 then\n    IO.eprintln \"Final balance negative!\"\n  else\n    IO.println \"Final balance is zero or positive.\"\nThe program's output is:Sending out orders...\nValidation prevented a negative balance.\nFinal balance is zero or positive.\n\n\n","context":"Lean Reference\u0009IO\u0009Mutable References","header":"15.4.2. Concurrency","id":"/IO/Mutable-References/#ref-locks"},"/Interacting-with-Lean/#format-indent":{"contents":"These operators make it easier to achieve a consistent indentation style on top of Std.Format.nest.\n\nIncreases the indentation level by the default amount.\n\nThe default indentation level, which is two spaces.\n\nInsert a newline and then f, all nested by the default indent amount.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.4. Indentation","id":"/Interacting-with-Lean/#format-indent"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Ordering":{"contents":"There are two primary ways to order the values of a type:\n\n* The Ord type class provides a three-way comparison operator, compare, which can indicate that one value is less than, equal to, or greater than another. It returns an Ordering.* The LT and LE classes provide canonical Prop-valued ordering relations for a type that do not need to be decidable. These relations are used to overload the < and ≤ operators.\n\nOrd α provides a computable total order on α, in terms of the\ncompare : α → α → Ordering function.Typically instances will be transitive, reflexive, and antisymmetric,\nbut this is not enforced by the typeclass.There is a derive handler, so appending deriving Ord to an inductive type or structure\nwill attempt to create an Ord instance.Compare two elements in α using the comparator contained in an [Ord α] instance.\n\nThe compare method is exported, so no explicit Ord namespace is required to use it.\n\nCompares two values by comparing the results of applying a function.In particular, x is compared to y by comparing f x and f y.Examples:* compareOn (·.length) \"apple\" \"banana\" = .lt* compareOn (· % 3) 5 6 = .gt* compareOn (·.foldl max 0) [1, 2, 3] [3, 2, 1] = .eq\n\nInverts the order of an Ord instance.The result is an Ord α instance that returns Ordering.lt when ord would return Ordering.gt\nand that returns Ordering.gt when ord would return Ordering.lt.\n\nThe result of a comparison according to a total order.The relationship between the compared items may be:* Ordering.lt: less than* Ordering.eq: equal* Ordering.gt: greater thanLess than.Equal.Greater than.\n\nSwaps less-than and greater-than ordering results.Examples:* Ordering.lt.swap = Ordering.gt* Ordering.eq.swap = Ordering.eq* Ordering.gt.swap = Ordering.lt\n\nIf a and b are Ordering, then a.then b returns a unless it is .eq, in which case it\nreturns b. Additionally, it has “short-circuiting” behavior similar to boolean &&: if a is not\n.eq then the expression for b is not evaluated.This is a useful primitive for constructing lexicographic comparator functions. The deriving Ord\nsyntax on a structure uses the Ord instance to compare each field in order, combining the results\nequivalently to Ordering.then.Use compareLex to lexicographically combine two comparison functions.Examples:structure Person where\n  name : String\n  age : Nat\n\n-- Sort people first by name (in ascending order), and people with the same name by age (in\n-- descending order)\ninstance : Ord Person where\n  compare a b := (compare a.name b.name).then (compare b.age a.age)\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Dana\", 50⟩\nOrdering.gt\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Gert\", 50⟩\nOrdering.gt\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Gert\", 20⟩\nOrdering.lt\n\n\nChecks whether the ordering is lt.\n\nChecks whether the ordering is lt or eq.\n\nChecks whether the ordering is eq.\n\nChecks whether the ordering is not eq.\n\nChecks whether the ordering is gt or eq.\n\nChecks whether the ordering is gt.\n\nUses decidable less-than and equality relations to find an Ordering.In particular, if x < y then the result is Ordering.lt. If x = y then the result is\nOrdering.eq. Otherwise, it is Ordering.gt.compareOfLessAndBEq uses BEq instead of DecidableEq.\n\nUses a decidable less-than relation and Boolean equality to find an Ordering.In particular, if x < y then the result is Ordering.lt. If x == y then the result is\nOrdering.eq. Otherwise, it is Ordering.gt.compareOfLessAndEq uses DecidableEq instead of BEq.\n\nCompares a and b lexicographically by cmp₁ and cmp₂.a and b are first compared by cmp₁. If this returns Ordering.eq, a and b are compared\nby cmp₂ to break the tie.To lexicographically combine two Orderings, use Ordering.then.\n\nOrdering OperatorsThe less-than operator is overloaded in the LT class:The less-than-or-equal-to operator is overloaded in the LE class:The greater-than and greater-than-or-equal-to operators are the reverse of the less-than and less-than-or-equal-to operators, and cannot be independently overloaded:\n\nLT α is the typeclass which supports the notation x < y where x y : α.The less-than relation: x < yConventions for notations in identifiers:* The recommended spelling of < in identifiers is lt.\n\nLE α is the typeclass which supports the notation x ≤ y where x y : α.The less-equal relation: x ≤ yConventions for notations in identifiers:* The recommended spelling of ≤ in identifiers is le.* The recommended spelling of <= in identifiers is le (prefer ≤ over <=).\n\nAn Ord can be used to construct BEq, LT, and LE instances with the following helpers.\nThey are not automatically instances because many types are better served by custom relations.\n\nConstructs an LT instance from an Ord instance that asserts that the result of compare is\nOrdering.lt.\n\nConstructs an LT instance from an Ord instance that asserts that the result of compare\nsatisfies Ordering.isLE.\n\nConstructs a BEq instance from an Ord instance.\n\nConstructs an LE instance from an Ord instance.\n\nConstructs an LT instance from an Ord instance.\n\nUsing Ord Instances for LT and LE InstancesLean can automatically derive an Ord instance.\nIn this case, the Ord Vegetable instance compares vegetables lexicographically:structure Vegetable where\n  color : String\n  size : Fin 5\nderiving Ord\ndef broccoli : Vegetable where\n  color := \"green\"\n  size := 2\n\ndef sweetPotato : Vegetable where\n  color := \"orange\"\n  size := 3\nUsing the helpers ltOfOrd and leOfOrd, LT Vegetable and LE Vegetable instances can be defined.\nThese instances compare the vegetables using compare and logically assert that the result is as expected.instance : LT Vegetable := ltOfOrd\ninstance : LE Vegetable := leOfOrd\nThe resulting relations are decidable because equality is decidable for Ordering:#eval broccoli < sweetPotato\ntrue\n#eval broccoli ≤ sweetPotato\ntrue\n#eval broccoli < broccoli\nfalse\n#eval broccoli ≤ broccoli\ntrue\n\n\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.2. Ordering","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Ordering"}});