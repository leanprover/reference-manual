window.docContents[226].resolve({"/Basic-Types/Lazy-Computations/#Thunk-runtime":{"contents":"Memory layout of thunks \n\nThunks are one of the primitive object types supported by the Lean runtime.\nThe object header contains a specific tag that indicates that an object is a thunk.\n\nThunks have two fields:* m_value is a pointer to a saved value, which is a null pointer if the value has not yet been computed.* m_closure is a closure which is to be called when the value should be computed.The runtime system maintains the invariant that either the closure or the saved value is a null pointer.\nIf both are null pointers, then the thunk is being forced on another thread.\n\nWhen a thunk is forced, the runtime system first checks whether the saved value has already been computed, returning it if so.\nOtherwise, it attempts to acquire a lock on the closure by atomically swapping it with a null pointer.\nIf the lock is acquired, it is invoked to compute the value; the computed value is stored in the saved value field and the reference to the closure is dropped.\nIf not, then another thread is already computing the value; the system waits until it is computed.\n\n","context":"Lean Reference\u0009Basic Types\u0009Lazy Computations","header":"19.20.2. Runtime Representation","id":"/Basic-Types/Lazy-Computations/#Thunk-runtime"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Modification--Insertion":{"contents":"Inserts an element into a list without duplication.If the element is present in the list, the list is returned unmodified. Otherwise, the new element\nis inserted at the head of the list.Examples:* [1, 2, 3].insert 0 = [0, 1, 2, 3]* [1, 2, 3].insert 4 = [4, 1, 2, 3]* [1, 2, 3].insert 2 = [1, 2, 3]\n\nInserts an element into a list at the specified index. If the index is greater than the length of\nthe list, then the list is returned unmodified.In other words, the new element is inserted into the list l after the first i elements of l.Examples:* [\"tues\", \"thur\", \"sat\"].insertIdx 1 \"wed\" = [\"tues\", \"wed\", \"thur\", \"sat\"]* [\"tues\", \"thur\", \"sat\"].insertIdx 2 \"wed\" = [\"tues\", \"thur\", \"wed\", \"sat\"]* [\"tues\", \"thur\", \"sat\"].insertIdx 3 \"wed\" = [\"tues\", \"thur\", \"sat\", \"wed\"]* [\"tues\", \"thur\", \"sat\"].insertIdx 4 \"wed\" = [\"tues\", \"thur\", \"sat\"]\n\nInserts an element into a list at the specified index. If the index is greater than the length of\nthe list, then the list is returned unmodified.In other words, the new element is inserted into the list l after the first i elements of l.This is a tail-recursive version of List.insertIdx, used at runtime.Examples:* [\"tues\", \"thur\", \"sat\"].insertIdxTR 1 \"wed\" = [\"tues\", \"wed\", \"thur\", \"sat\"]* [\"tues\", \"thur\", \"sat\"].insertIdxTR 2 \"wed\" = [\"tues\", \"thur\", \"wed\", \"sat\"]* [\"tues\", \"thur\", \"sat\"].insertIdxTR 3 \"wed\" = [\"tues\", \"thur\", \"sat\", \"wed\"]* [\"tues\", \"thur\", \"sat\"].insertIdxTR 4 \"wed\" = [\"tues\", \"thur\", \"sat\"]\n\nAlternates the elements of l with sep.O(|l|).List.intercalate is a similar function that alternates a separator list with elements of a list of\nlists.Examples:* List.intersperse \"then\" [] = []* List.intersperse \"then\" [\"walk\"] = [\"walk\"]* List.intersperse \"then\" [\"walk\", \"run\"] = [\"walk\", \"then\", \"run\"]* List.intersperse \"then\" [\"walk\", \"run\", \"rest\"] = [\"walk\", \"then\", \"run\", \"then\", \"rest\"]\n\nAlternates the elements of l with sep.O(|l|).This is a tail-recursive version of List.intersperse, used at runtime.Examples:* List.intersperseTR \"then\" [] = []* List.intersperseTR \"then\" [\"walk\"] = [\"walk\"]* List.intersperseTR \"then\" [\"walk\", \"run\"] = [\"walk\", \"then\", \"run\"]* List.intersperseTR \"then\" [\"walk\", \"run\", \"rest\"] = [\"walk\", \"then\", \"run\", \"then\", \"rest\"]\n\nAlternates the lists in xs with the separator sep, appending them. The resulting list is\nflattened.O(|xs|).List.intersperse is a similar function that alternates a separator element with the elements of a\nlist.Examples:* List.intercalate sep [] = []* List.intercalate sep [a] = a* List.intercalate sep [a, b] = a ++ sep ++ b* List.intercalate sep [a, b, c] = a ++ sep ++ b ++ sep ++ c\n\nAlternates the lists in xs with the separator sep.This is a tail-recursive version of List.intercalate used at runtime.Examples:* List.intercalateTR sep [] = []* List.intercalateTR sep [a] = a* List.intercalateTR sep [a, b] = a ++ sep ++ b* List.intercalateTR sep [a, b, c] = a ++ sep ++ b ++ sep ++ c\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference\u0009Modification","header":"19.15.3.8.1. Insertion","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Modification--Insertion"},"/Basic-Types/Linked-Lists/#list-performance":{"contents":"The representation of lists is not overridden or modified by the compiler: they are linked lists, with a pointer indirection for each element.\nCalculating the length of a list requires a full traversal, and modifying an element in a list requires a traversal and reallocation of the prefix of the list that is prior to the element being modified.\nDue to Lean's reference-counting-based memory management, operations such as List.map that traverse a list, allocating a new List.cons constructor for each in the prior list, can re-use the original list's memory when there are no other references to it.\n\nBecause of the important role played by lists in specifications, most list functions are written as straightforwardly as possible using structural recursion.\nThis makes it easier to write proofs by induction, but it also means that these operations consume stack space proportional to the length of the list.\nThere are tail-recursive versions of many list functions that are equivalent to the non-tail-recursive versions, but more are difficult to use when reasoning.\nIn compiled code, the tail-recursive versions are automatically used instead of the non-tail-recursive versions.\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists","header":"19.15.2. Performance Notes","id":"/Basic-Types/Linked-Lists/#list-performance"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Conversion":{"contents":"Creates a hash set from a list of elements. Note that unlike repeatedly calling insert, if the\ncollection contains multiple elements that are equal (with regard to ==), then the last element\nin the collection will be present in the returned hash set.\n\nCreates a hash set from an array of elements. Note that unlike repeatedly calling insert, if the\ncollection contains multiple elements that are equal (with regard to ==), then the last element\nin the collection will be present in the returned hash set.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Sets","header":"19.18.7.5. Conversion","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Conversion"},"/Basic-Types/Strings/#string-literals":{"contents":"String literals begin and end with a double-quote character \". \nBetween these characters, they may contain any other character, including newlines, which are included literally (with the caveat that all newlines in a Lean source file are interpreted as '\\n', regardless of file encoding and platform).\nSpecial characters that cannot otherwise be written in string literals may be escaped with a backslash, so \"\\\"Quotes\\\"\" is a string literal that begins and ends with double quotes.\nThe following forms of escape sequences are accepted:\n\n \\r, \\n, \\t, \\\\, \\\", \\'\n\nThese escape sequences have the usual meaning, mapping to CR, LF, tab, backslash, double quote, and single quote, respectively.\n\n \\xNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the two-digit hexadecimal code.\n\n \\uNNNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the four-digit hexadecimal code.\n\n\n\nString literals may contain gaps.\nA gap is indicated by an escaped newline, with no intervening characters between the escaping backslash and the newline.\nIn this case, the string denoted by the literal is missing the newline and all leading whitespace from the next line.\nString gaps may not precede lines that contain only whitespace.\n\nHere, str1 and str2 are the same string:\n\ndef str1 := \"String with \\\n             a gap\"\ndef str2 := \"String with a gap\"\n\nexample : str1 = str2 := rfl\n\n\nIf the line following the gap is empty, the string is rejected:\n\ndef str3 := \"String with \\\n\n             a gap\"\n\n\nThe parser error is:\n\n<example>:2:0-3:0: unexpected additional newline in string gap\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009Syntax","header":"19.8.3.1. String Literals","id":"/Basic-Types/Strings/#string-literals"},"/Tactic-Proofs/Custom-Tactics/#tactic-macro-extension":{"contents":"Because macro expansion can fail,  multiple macros can match the same syntax, allowing backtracking.\nTactic macros take this further: even if a tactic macro expands successfully, if the expansion fails when interpreted, the tactic interpreter will attempt the next expansion.\nThis is used to make a number of Lean's built-in tactics extensible—new behavior can be added to a tactic by adding a macro_rules declaration.\n\nExtending trivialThe trivial, which is used by many other tactics to quickly dispatch subgoals that are not worth bothering the user with, is designed to be extended through new macro expansions.\nLean's default trivial can't solve IsEmpty [] goals:def IsEmpty (xs : List α) : Prop :=\n  ¬ xs ≠ []\n\nexample (α : Type u) : IsEmpty (α := α) [] := by trivial\nThe error message is an artifact of trivial trying assumption last.\nAdding another expansion allows trivial to take care of these goals:def emptyIsEmpty : IsEmpty (α := α) [] := by simp [IsEmpty]\n\nmacro_rules | `(tactic|trivial) => `(tactic|exact emptyIsEmpty)\n\nexample (α : Type u) : IsEmpty (α := α) [] := by\n  trivial\n\n\nExpansion BacktrackingMacro expansion can induce backtracking when the failure arises from any part of the expanded syntax.\nAn infix version of first can be defined by providing multiple expansions in separate macro_rules declarations:syntax tactic \"<|||>\" tactic : tactic\nmacro_rules\n  | `(tactic|$t1 <|||> $t2) => pure t1\nmacro_rules\n  | `(tactic|$t1 <|||> $t2) => pure t2\n\nexample : 2 = 2 := by\n  rfl <|||> apply And.intro\n\nexample : 2 = 2 := by\n  apply And.intro <|||> rfl\nMultiple macro_rules declarations are needed because each defines a pattern-matching function that will always take the first matching alternative.\nBacktracking is at the granularity of macro_rules declarations, not their individual cases.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Custom Tactics\u0009Tactic Macros","header":"13.8.1.1. Extensible Tactic Macros","id":"/Tactic-Proofs/Custom-Tactics/#tactic-macro-extension"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Polymorphic-ranges-and-slices":{"contents":"#8784 introduces new syntax for ranges:\n1...*, 1...=3, 1...<3, 1<...=2, *...=3..\n\n#8947 extends this syntax to slices, allowing expressions like xs[*...end].\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Polymorphic ranges and slices","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Polymorphic-ranges-and-slices"}});