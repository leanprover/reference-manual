window.docContents[211].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms":{"contents":"Computes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog.\n\nComputes the natural logarithm ln x of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlogf.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10.\n\nComputes the base-10 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog10f.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2.\n\nComputes the base-2 logarithm of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nlog2f.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"19.6.2.6. Logarithms","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Logarithms"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams":{"contents":"Lean provides a consistent filesystem API on all supported platforms.\nThese are the key concepts:\n\n Files\n\nFiles are an abstraction provided by operating systems that provide random access to persistently-stored data, organized hierarchically into directories.\n\n Directories\n\nDirectories, also known as folders, may contain files or other directories.\n  Fundamentally, a directory maps names to the files and/or directories that it contains.\n\n File Handles\n\nFile handles (Handle) are abstract references to files that have been opened for reading and/or writing.\n  A file handle maintains a mode that determines whether reading and/or writing are allowed, along with a cursor that points at a specific location in the file.\n  Reading from or writing to a file handle advances the cursor.\n  File handles may be buffered, which means that reading from a file handle may not return the current contents of the persistent data, and writing to a file handle may not modify them immediately.\n\n Paths\n\nFiles are primarily accessed via paths (System.FilePath).\n  A path is a sequence of directory names, potentially terminated by a file name.\n  They are represented by strings in which separator characters The current platform's separator characters are listed in System.FilePath.pathSeparators. delimit the names.The details of paths are platform-specific.\n  Absolute paths begin in a root directory; some operating systems have a single root, while others may have multiple root directories.\n  Relative paths do not begin in a root directory and require that some other directory be taken as a starting point.\n  In addition to directories, paths may contain the special directory names ., which refers to the directory in which it is found, and .., which refers to prior directory in the path.Filenames, and thus paths, may end in one or more extensions that identify the file's type.\n  Extensions are delimited by the character System.FilePath.extSeparator.\n  On some platforms, executable files have a special extension (System.FilePath.exeExtension).\n\n Streams\n\nStreams are a higher-level abstraction over files, both providing additional functionality and hiding some details of files.\n  While file handles are essentially a thin wrapper around the operating system's representation, streams are implemented in Lean as a structure called IO.FS.Stream.\n  Because streams are implemented in Lean, user code can create additional streams, which can be used seamlessly together with those provided in the standard library.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.5. Files, File Handles, and Streams","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams"},"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices":{"contents":"Type constructors may take two kinds of arguments: parameters  and indices.\nParameters must be used consistently in the entire definition; all occurrences of the type constructor in each constructor in the declaration must take precisely the same argument.\nIndices may vary among the occurrences of the type constructor.\nAll parameters must precede all indices in the type constructor's signature.\n\nParameters that occur prior to the colon (':') in the type constructor's signature are considered parameters to the entire inductive type declaration.\nThey are always parameters that must be uniform throughout the type's definition.\nGenerally speaking, parameters that occur after the colon are indices that may vary throughout the definition of the type.\nHowever, if the option inductive.autoPromoteIndices is true, then syntactic indices that could have been parameters are made into parameters.\nAn index could have been a parameter if all of its type dependencies are themselves parameters and it is used uniformly as an uninstantiated variable in all occurrences of the inductive type's type constructor in all constructors.\n\nPromote indices to parameters in inductive types whenever possible.\n\nIndices can be seen as defining a family of types.\nEach choice of indices selects a type from the family, which has its own set of available constructors.\nType constructors with indices are said to specify indexed families  of types.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","header":"4.4.1.1. Parameters and Indices","id":"/The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices"}});