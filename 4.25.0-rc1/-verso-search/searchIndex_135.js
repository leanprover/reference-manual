window.docContents[135].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Cosine":{"contents":"Computes the cosine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncos.\n\nComputes the cosine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncosf.\n\nComputes the hyperbolic cosine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncosh.\n\nComputes the hyperbolic cosine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ncoshf.\n\nComputes the arc cosine (inverse cosine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacos.\n\nComputes the arc cosine (inverse cosine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacosf.\n\nComputes the hyperbolic arc cosine (inverse cosine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacosh.\n\nComputes the hyperbolic arc cosine (inverse cosine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nacoshf.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Trigonometry","header":"19.6.2.9.2. Cosine","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Cosine"},"/The-Simplifier/Rewrite-Rules/#simp-rewrites":{"contents":"The simplifier has three kinds of rewrite rules:\n\n Declarations to unfold\n\nThe simplifier will only unfold reducible definitions by default.\n  However, a rewrite rule can be added for any semireducible or irreducible definition that causes the simplifier to unfold it as well.\n  When the simplifier is running in definitional mode (dsimp and its variants), definition unfolding only replaces the defined name with its value; otherwise, it also uses the equational lemmas produced by the equation compiler.\n\n Equational lemmas\n\nThe simplifier can treat equality proofs as rewrite rules, in which case the left side of the equality will be replaced with the right. These equational lemmas may have any number of parameters. The simplifier instantiates parameters to make the left side of the equality match the goal, and it performs a proof search to instantiate any additional parameters.\n\n Simplification procedures\n\nThe simplifier supports simplification procedures, known as simprocs, that use Lean metaprogramming to perform rewrites that can't be efficiently specified using equations. Lean includes simprocs for the most important operations on built-in types.\n\n\n\n\n\nDue to propositional extensionality, equational lemmas can rewrite propositions to simpler, logically equivalent propositions.\nWhen the simplifier rewrites a proof goal to True, it automatically closes it.\nAs a special case of equational lemmas, propositions other than equality can be tagged as rewrite rules\nThey are preprocessed into rules that rewrite the proposition to True.\n\nRewriting PropositionsWhen asked to simplify an equality of pairs:α β : Type\nw y : α\nx z : β\n⊢ (w, x) = (y, z)\nsimp yields a conjunction of equalities:α β : Type\nw y : α\nx z : β\n⊢ w = y ∧ x = z\nThe default simp set contains Prod.mk.injEq, which shows the equivalence of the two statements:Prod.mk.injEq.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) :\n  ∀ (fst_1 : α) (snd_1 : β),\n    ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 ∧ snd = snd_1)\n\n\nIn addition to rewrite rules, simp has a number of built-in reduction rules, controlled by the config parameter.\nEven when the simp set is empty, simp can replace let-bound variables with their values, reduce match expressions whose scrutinees are constructor applications, reduce structure projections applied to constructors, or apply lambdas to their arguments.\n\n","context":"Lean Reference\u0009The Simplifier","header":"16.2. Rewrite Rules","id":"/The-Simplifier/Rewrite-Rules/#simp-rewrites"},"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Documentation":{"contents":"* #6886 adds recommended spellings for many notations defined in Lean\ncore, using the recommended_spelling command from #6869.* #6950 adds a style guide and a naming convention for the standard\nlibrary.* #6962 improves the doc-string for List.toArray.* #6998 modifies the Prop docstring to point out that every\nproposition is propositionally equal to either True or False. This\nwill help point users toward seeing that Prop is like Bool.* #7026 clarifies the styling of do blocks, and enhanes the naming\nconventions with information about the ext and mono name components\nas well as advice about primed names and naming of simp sets.* #7111 extends the standard library style guide with guidance on\nuniverse variables, notations and Unicode usage, and structure\ndefinitions.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.18.0 (2025-04-02)","header":"Documentation","id":"/releases/v4.18.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___18___0-_LPAR_2025-04-02_RPAR_--Documentation"}});