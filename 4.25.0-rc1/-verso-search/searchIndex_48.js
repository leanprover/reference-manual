window.docContents[48].resolve({"/Basic-Types/Strings/#string-api-encoding":{"contents":"Accesses the indicated byte in the UTF-8 encoding of a string.At runtime, this function is implemented by efficient, constant-time code.\n\nThe number of bytes used by the string's UTF-8 encoding.At runtime, this function takes constant time because the byte length of strings is cached.\n\nReturns the sequence of bytes in a character's UTF-8 encoding.\n\nDecodes an array of bytes that encode a string as UTF-8 into\nthe corresponding string.\n\nDecodes an array of bytes that encode a string as UTF-8 into\nthe corresponding string, or returns none if the array is not a valid UTF-8 encoding of a string.\n\nDecodes an array of bytes that encode a string as UTF-8 into\nthe corresponding string, or panics if the array is not a valid UTF-8 encoding of a string.\n\nEncodes a string in UTF-8 as an array of bytes.\n\nReplaces each \\r\\n with \\n to normalize line endings, but does not validate that there are no\nisolated \\r characters.This is an optimized version of String.replace text \"\\r\\n\" \"\\n\".\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.14. Encodings","id":"/Basic-Types/Strings/#string-api-encoding"},"/Elaboration-and-Compilation/#macro-and-elab":{"contents":"Having parsed a command, the next step is to elaborate it.\nThe precise meaning of elaboration depends on what is being elaborated: elaborating a command effects a change in the state of Lean, while elaborating a term results in a term in Lean's core type theory.\nElaboration of both commands and terms may be recursive, both because of command combinators such as in and because terms may contain other terms.\n\nCommand and term elaboration have different capabilities.\nCommand elaboration may have side effects on an environment, and it has access to run arbitrary computations in IO.\nLean environments contain the usual mapping from names to definitions along with additional data defined in environment extensions, which are additional tables associated with an environment; environment extensions are used to track most other information about Lean code, including simp lemmas, custom pretty printers, and internals such as the compiler's intermediate representations.\nCommand elaboration also maintains a message log with the contents of the compiler's informational output, warnings, and errors, a set of info trees that associate metadata with the original syntax (used for interactive features such as displaying proof states, identifier completion, and showing documentation), accumulated debugging traces, the open section scopes, and some internal state related to macro expansion.\nTerm elaboration may modify all of these fields except the open scopes.\nAdditionally, it has access to all the machinery needed to create fully-explicit terms in the core language from Lean's terse, friendly syntax, including unification, type class instance synthesis, and type checking.\n\nThe first step in both term and command elaboration is macro expansion.\nThere is a table that maps syntax kinds to macro implementations; macro implementations are monadic functions that transform the macro syntax into new syntax.\nMacros are saved in the same table and execute in the same monad for terms, commands, tactics, and any other macro-extensible part of Lean.\nIf the syntax returned by the macro is itself a macro, then that syntax is again expanded—this process is repeated until either a syntax whose kind is not a macro is produced, or until a maximum number of iterations is reached, at which point Lean produces an error.\nTypical macros process some outer layer of their syntax, leaving some subterms untouched.\nThis means that even when macro expansion has been completed, there still may be macro invocations remaining in the syntax below the top level.\nNew macros may be added to the macro table.\nDefining new macros is described in detail in the section on macros.\n\nAfter macro expansion, both the term and command elaborators consult tables that map syntax kinds to elaboration procedures.\nTerm elaborators map syntax and an optional expected type to a core language expression using the very powerful monad mentioned above.\nCommand elaborators accept syntax and return no value, but may have monadic side effects on the global command state.\nWhile both term and command elaborators have access to IO, it's unusual that they perform side effects; exceptions include interactions with external tools or solvers.\n\nThe elaborator tables may be extended to enable the use of new syntax for both terms and commands by extending the tables.\nSee the section on elaborators for a description of how to add additional elaborators to Lean.\nWhen commands or terms contain further commands or terms, they recursively invoke the appropriate elaborator on the nested syntax.\nThis elaborator will then expand macros before invoking elaborators from the table.\nWhile macro expansion occurs prior to elaboration for a given “layer” of the syntax, macro expansion and elaboration are interleaved in general.\n\n\n\n","context":"Lean Reference\u0009Elaboration and Compilation","header":"2.2. Macro Expansion and Elaboration","id":"/Elaboration-and-Compilation/#macro-and-elab"},"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types":{"contents":"Each discriminant must be well typed.\nBecause patterns are a subset of terms, their types can also be checked.\nEach pattern that matches a given discriminant must have the same type as the corresponding discriminant.\n\nThe right-hand side of each match alternative should have the same type as the overall match term.\nTo support dependent types, matching a discriminant against a pattern refines the types that are expected within the scope of the pattern.\nIn both subsequent patterns in the same match alternative and the right-hand side's type, occurrences of the discriminant are replaced by the pattern that it was matched against.\n\nType RefinementThis indexed family describes mostly-balanced trees, with the depth encoded in the type.inductive BalancedTree (α : Type u) : Nat → Type u where\n  | empty : BalancedTree α 0\n  | branch\n    (left : BalancedTree α n)\n    (val : α)\n    (right : BalancedTree α n) :\n    BalancedTree α (n + 1)\n  | lbranch\n    (left : BalancedTree α (n + 1))\n    (val : α)\n    (right : BalancedTree α n) :\n    BalancedTree α (n + 2)\n  | rbranch\n    (left : BalancedTree α n)\n    (val : α)\n    (right : BalancedTree α (n + 1)) :\n    BalancedTree α (n + 2)\nTo begin the implementation of a function to construct a perfectly balanced tree with some initial element and a given depth, a hole can be used for the definition.def BalancedTree.filledWith (x : α) (depth : Nat) : BalancedTree α depth := _\nThe error message demonstrates that the tree should have the indicated depth.don't know how to synthesize placeholder\ncontext:\nα : Type u\nx : α\ndepth : Nat\n⊢ BalancedTree α depth\nMatching on the expected depth and inserting holes results in an error message for each hole.\nThese messages demonstrate that the expected type has been refined, with depth replaced by the matched values.def BalancedTree.filledWith\n    (x : α) (depth : Nat) :\n    BalancedTree α depth :=\n  match depth with\n  | 0 => _\n  | n + 1 => _\nThe first hole yields the following message:don't know how to synthesize placeholder\ncontext:\nα : Type u\nx : α\ndepth : Nat\n⊢ BalancedTree α 0\nThe second hole yields the following message:don't know how to synthesize placeholder\ncontext:\nα : Type u\nx : α\ndepth n : Nat\n⊢ BalancedTree α (n + 1)\nMatching on the depth of a tree and the tree itself leads to a refinement of the tree's type according to the depth's pattern.\nThis means that certain combinations are not well-typed, such as 0 and branch, because refining the second discriminant's type yields BalancedTree α 0 which does not match the constructor's type.def BalancedTree.isPerfectlyBalanced\n    (n : Nat) (t : BalancedTree α n) : Bool :=\n  match n, t with\n  | 0, .empty => true\n  | 0, .branch left val right =>\n    isPerfectlyBalanced left &&\n    isPerfectlyBalanced right\n  | _, _ => false\nType mismatch\n  left.branch val right\nhas type\n  BalancedTree ?m.54 (?m.51 + 1)\nbut is expected to have type\n  BalancedTree α 0\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching","header":"10.8.1. Types","id":"/Terms/Pattern-Matching/#The-Lean-Language-Reference--Terms--Pattern-Matching--Types"},"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Division-and-Modulus":{"contents":"The solver supports linear division and modulo operations.\n\nLinear Division and Modulo with cutsatexample (x y : Int) :\n    x = y / 2 →\n    y % 2 = 0 →\n    y - 2 * x = 0 := by\n  grind\n\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Integer Arithmetic","header":"17.7.3. Division and Modulus","id":"/The--grind--tactic/Linear-Integer-Arithmetic/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic--Division-and-Modulus"},"/The-Type-System/Inductive-Types/#inductive-declarations":{"contents":"Inductive Type DeclarationsDeclares a new inductive type.\nThe meaning of the declModifiers is as described in the section on declaration modifiers.\n\nAfter declaring an inductive type, its type constructor, constructors, and recursor are present in the environment.\nNew inductive types extend Lean's core logic—they are not encoded or represented by some other already-present data.\nInductive type declarations must satisfy a number of well-formedness requirements to ensure that the logic remains consistent.\n\nThe first line of the declaration, from inductive to where, specifies the new type constructor's name and type.\nIf a type signature for the type constructor is provided, then its result type must be a universe, but the parameters do not need to be types.\nIf no signature is provided, then Lean will attempt to infer a universe that's just big enough to contain the resulting type.\nIn some situations, this process may fail to find a minimal universe or fail to find one at all, necessitating an annotation.\n\nThe constructor specifications follow where.\nConstructors are not mandatory, as constructorless inductive types such as False and Empty are perfectly sensible.\nEach constructor specification begins with a vertical bar ('|', Unicode 'VERTICAL BAR' (U+007c)), declaration modifiers, and a name.\nThe name is a raw identifier.\nA declaration signature follows the name.\nThe signature may specify any parameters, modulo the well-formedness requirements for inductive type declarations, but the return type in the signature must be a saturated application of the type constructor of the inductive type being specified.\nIf no signature is provided, then the constructor's type is inferred by inserting sufficient implicit parameters to construct a well-formed return type.\n\nThe new inductive type's name is defined in the current namespace.\nEach constructor's name is in the inductive type's namespace.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.1. Inductive Type Declarations","id":"/The-Type-System/Inductive-Types/#inductive-declarations"},"/Type-Classes/Deriving-Instances/#deriving-handlers":{"contents":"Instance deriving uses a table of deriving handlers that maps type class names to metaprograms that derive instances for them.\nDeriving handlers may be added to the table using registerDerivingHandler, which should be called in an initialize block.\nEach deriving handler should have the type Array Name → CommandElabM Bool.\nWhen a user requests that an instance of a class be derived, its registered handlers are called one at a time.\nThey are provided with all of the names in the mutual block for which the instance is to be derived, and should either correctly derive an instance and return true or have no effect and return false.\nWhen a handler returns true, no further handlers are called.\n\nLean includes deriving handlers for the following classes:\n\n* BEq* DecidableEq* Hashable* Inhabited* LawfulBEq* Nonempty* Ord* ReflBEq* Repr* SizeOf* TypeName\n\nRegisters a deriving handler for a class. This function should be called in an initialize block.A DerivingHandler is called on the fully qualified names of all types it is running for. For\nexample, deriving instance Foo for Bar, Baz invokes fooHandler #[`Bar, `Baz].\n\nDeriving HandlersInstances of the IsEnum class demonstrate that a type is a finite enumeration by providing a bijection between the type and a suitably-sized Fin:class IsEnum (α : Type) where\n  size : Nat\n  toIdx : α → Fin size\n  fromIdx : Fin size → α\n  to_from_id : ∀ (i : Fin size), toIdx (fromIdx i) = i\n  from_to_id : ∀ (x : α), fromIdx (toIdx x) = x\nFor inductive types that are trivial enumerations, where no constructor expects any parameters, instances of this class are quite repetitive.\nThe instance for Bool is typical:instance : IsEnum Bool where\n  size := 2\n  toIdx\n    | false => 0\n    | true => 1\n  fromIdx\n    | 0 => false\n    | 1 => true\n  to_from_id\n    | 0 => rfl\n    | 1 => rfl\n  from_to_id\n    | false => rfl\n    | true => rfl\nThe deriving handler programmatically constructs each pattern case, by analogy to the IsEnum Bool implementation:open Lean Elab Parser Term Command\n\ndef deriveIsEnum (declNames : Array Name) : CommandElabM Bool := do\n  if h : declNames.size = 1 then\n    let env ← getEnv\n    if let some (.inductInfo ind) := env.find? declNames[0] then\n      let mut tos : Array (TSyntax ``matchAlt) := #[]\n      let mut froms := #[]\n      let mut to_froms := #[]\n      let mut from_tos := #[]\n      let mut i := 0\n\n      for ctorName in ind.ctors do\n        let c := mkIdent ctorName\n        let n := Syntax.mkNumLit (toString i)\n\n        tos      := tos.push      (← `(matchAltExpr| | $c => $n))\n        from_tos := from_tos.push (← `(matchAltExpr| | $c => rfl))\n        froms    := froms.push    (← `(matchAltExpr| | $n => $c))\n        to_froms := to_froms.push (← `(matchAltExpr| | $n => rfl))\n\n        i := i + 1\n\n      let cmd ← `(instance : IsEnum $(mkIdent declNames[0]) where\n                    size := $(quote ind.ctors.length)\n                    toIdx $tos:matchAlt*\n                    fromIdx $froms:matchAlt*\n                    to_from_id $to_froms:matchAlt*\n                    from_to_id $from_tos:matchAlt*)\n      elabCommand cmd\n\n      return true\n  return false\n\ninitialize\n  registerDerivingHandler ``IsEnum deriveIsEnum\n\n\n","context":"Lean Reference\u0009Type Classes\u0009Deriving Instances","header":"11.4.1. Deriving Handlers","id":"/Type-Classes/Deriving-Instances/#deriving-handlers"},"/releases/v4.19.0/#release-v4___19___0":{"contents":"For this release, 420 changes landed. In addition to the 164 feature additions and 78 fixes listed below there were 13 refactoring changes, 29 documentation improvements, 31 performance improvements, 9 improvements to the test suite and 94 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.19.0 (2025-05-01)","id":"/releases/v4.19.0/#release-v4___19___0"},"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Other":{"contents":"* #9106 fixes undefined symbol: lean::mpz::divexact(lean::mpz const&, lean::mpz const&) when building without LEAN_USE_GMP* #9114 further improves release automation, automatically incorporating\nmaterial from nightly-testing and bump/v4.X.0 branches in the bump\nPRs to downstream repositories.* #9659 fixes compatibility of the trace.profiler.output option with\nnewer versions of Firefox Profiler\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.23.0 (2025-09-15)","header":"Other","id":"/releases/v4.23.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___23___0-_LPAR_2025-09-15_RPAR_--Other"}});