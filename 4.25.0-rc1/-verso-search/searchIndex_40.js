window.docContents[40].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model":{"contents":"Fixed-width integers may be unsigned or signed.\nFurthermore, they are available in five sizes: 8, 16, 32, and 64 bits, along with the current architecture's word size.\nIn their logical models, the unsigned integers are structures that wrap a BitVec of the appropriate width.\nSigned integers wrap the corresponding unsigned integers, and use a twos-complement representation.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","header":"19.4.1. Logical Model","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model"},"/Basic-Types/Natural-Numbers/#nat-runtime":{"contents":"The representation suggested by the declaration of Nat would be horrendously inefficient, as it's essentially a linked list.\nThe length of the list would be the number.\nWith this representation, addition would take time linear in the size of one of the addends, and numbers would take at least as many machine words as their magnitude in memory.\nThus, natural numbers have special support in both the kernel and the compiler that avoids this overhead.\n\nIn the kernel, there are special Nat literal values that use a widely-trusted, efficient arbitrary-precision integer library (usually GMP).\nBasic functions such as addition are overridden by primitives that use this representation.\nBecause they are part of the kernel, if these primitives did not correspond to their definitions as Lean functions, it could undermine soundness.\n\nIn compiled code, sufficiently-small natural numbers are represented without pointer indirections: the lowest-order bit in an object pointer is used to indicate that the value is not, in fact, a pointer, and the remaining bits are used to store the number.\n31 bits are available on 32-bits architectures for pointer-free Nats, while 63 bits are available on 64-bit architectures.\nIn other words, natural numbers smaller than 2^{31} = 2,147,483,648 or 2^{63} = 9,223,372,036,854,775,808 do not require allocations.\nIf an natural number is too large for this representation, it is instead allocated as an ordinary Lean object that consists of an object header and an arbitrary-precision integer value.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers","header":"19.1.2. Run-Time Representation","id":"/Basic-Types/Natural-Numbers/#nat-runtime"},"/Build-Tools-and-Distribution/Lake/#lake-config":{"contents":"Lake offers two formats for package configuration files: TOML\n\nThe TOML configuration format is fully declarative.\n  Projects that don't include custom targets, facets, or scripts can use the TOML format.\n  Because TOML parsers are available for a wide variety of languages, using this format facilitates integration with tools that are not written in Lean.\n\n Lean\n\nThe Lean configuration format is more flexible and allows for custom targets, facets, and scripts.\n  It features an embedded domain-specific language for describing the declarative subset of configuration options that is available from the TOML format.\n  Additionally, the Lake API can be used to express build configurations that are outside of the possibilities of the declarative options.\n\nThe command translate-config can be used to automatically convert between the two formats.\n\nBoth formats are processed similarly by Lake, which extracts the package configuration from the configuration file in the form of internal structure types.\nWhen the package is configured, the resulting data structures are written to lakefile.olean in the build directory.\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake","header":"22.1.3. Configuration File Format","id":"/Build-Tools-and-Distribution/Lake/#lake-config"},"/Build-Tools-and-Distribution/Lake/#lake-facets":{"contents":"A facet describes the production of a target from another.\nConceptually, any target may have facets.\nHowever, executables, external libraries, and custom targets provide only a single implicit facet.\nPackages, libraries, and modules have multiple facets that can be requested by name when invoking build to select the corresponding target.\n\nWhen no facet is explicitly requested, but an initial target is designated, build produces the initial target's default facet.\nEach type of initial target has a corresponding default facet (e.g. producing an executable binary from an executable target or building a package's default targets); other facets may be explicitly requested in the package configuration or via Lake's command-line interface.\nLake's internal API may be used to write custom facets.\n\n\n\nThe facets available for packages are: extraDep\n\nThe default facets of the package's extra dependency targets, specified in the extraDepTargets field.\n\n deps\n\nThe package's direct dependencies.\n\n transDeps\n\nThe package's transitive dependencies, topologically sorted.\n\n optCache\n\nA package's optional cached build archive (e.g., from Reservoir or GitHub).\n  Will not cause the whole build to fail if the archive cannot be fetched.\n\n cache\n\nA package's cached build archive (e.g., from Reservoir or GitHub).\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n optBarrel\n\nA package's optional cached build archive (e.g., from Reservoir or GitHub).\n  Will not cause the whole build to fail if the archive cannot be fetched.\n\n barrel\n\nA package's cached build archive (e.g., from Reservoir or GitHub).\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n optRelease\n\nA package's optional build archive from a GitHub release.\n  Will not cause the whole build to fail if the release cannot be fetched.\n\n release\n\nA package's build archive from a GitHub release.\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n\n\n\n\nThe facets available for libraries are: leanArts\n\nThe artifacts that the Lean compiler produces for the library or executable (*.olean, *.ilean, and *.c files).\n\n static\n\nThe static library produced by the C compiler from the leanArts (that is, a *.a file).\n\n static.export\n\nThe static library produced by the C compiler from the leanArts (that is, a *.a file), with exported symbols.\n\n shared\n\nThe shared library produced by the C compiler from the leanArts (that is, a *.so, *.dll, or *.dylib file, depending on the platform).\n\n extraDep\n\nA Lean library's extraDepTargets and those of its package.\n\n\n\nExecutables have a single exe facet that consists of the executable binary.\n\n\n\nThe facets available for modules are: lean\n\nThe module's Lean source file.\n\n leanArts (default)\n\nThe module's Lean artifacts (*.olean, *.ilean, *.c files).\n\n deps\n\nThe module's dependencies (e.g., imports or shared libraries).\n\n olean\n\nThe module's .olean file. \n\n ilean\n\nThe module's .ilean file, which is metadata used by the Lean language server.\n\n header\n\nThe parsed module header of the module's source file.\n\n input\n\nThe module's processed Lean source file. Combines tracing the file with parsing its header.\n\n imports\n\nThe immediate imports of the Lean module, but not the full set of transitive imports. \n\n precompileImports\n\nThe transitive imports of the Lean module, compiled to object code.\n\n transImports\n\nThe transitive imports of the Lean module, as .olean files.\n\n allImports\n\nBoth the immediate and transitive imports of the Lean module.\n\n setup\n\nAll of a module's dependencies: transitive local imports and shared libraries to be loaded with --load-dynlib.\n  Returns the list of shared libraries to load along with their search path.\n\n ir\n\nThe .ir file produced by lean (with the experimental module system enabled).\n\n c\n\nThe C file produced by the Lean compiler.\n\n bc\n\nLLVM bitcode file, produced by the Lean compiler.\n\n c.o\n\nThe compiled object file, produced from the C file. On Windows, this is equivalent to .c.o.noexport, while it is equivalent to .c.o.export on other platforms.\n\n c.o.export\n\nThe compiled object file, produced from the C file, with Lean symbols exported.\n\n c.o.noexport\n\nThe compiled object file, produced from the C file, with Lean symbols exported.\n\n bc.o\n\nThe compiled object file, produced from the LLVM bitcode file.\n\n o\n\nThe compiled object file for the configured backend.\n\n dynlib\n\nA shared library (e.g., for the Lean option --load-dynlib).\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","header":"22.1.1.2. Facets","id":"/Build-Tools-and-Distribution/Lake/#lake-facets"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties":{"contents":"The IO monad has many, many effects, and is used for writing programs that need to interact with the world.\nIt is described in its own section.\nPrograms that use IO are essentially black boxes: they are typically not particularly amenable to verification.\n\nMany algorithms are easiest to express with a much smaller set of effects.\nThese effects can often be simulated; for example, mutable state can be simulated by passing around a tuple that contains both the program's value and the state.\nThese simulated effects are easier to reason formally about, because they are defined using ordinary code rather than new language primitives.\n\nThe standard library provides abstractions for working with commonly-used effects.\nMany frequently-used effects fall into a small number of categories:\n\n State monads have mutable state\n\nComputations that have access to some data that may be modified by other parts of the computation use mutable state.\n  State can be implemented in a variety of ways, described in the section on state monads and captured in the MonadState type class.\n\n Reader monads are parameterized computations\n\nComputations that can read the value of some parameter provided by a context exist in most programming languages, but many languages that feature state and exceptions as first-class features do not have built-in facilities for defining new parameterized computations.\n  Typically, these computations are provided with a parameter value when invoked, and sometimes they can locally override it.\n  Parameter values have dynamic extent: the value provided most recently in the call stack is the one that is used.\n  They can be simulated by passing a value unchanged through a sequence of function calls; however, this technique can make code harder to read and introduces a risk that the values may be passed incorrectly to further calls by mistake.\n  They can also be simulated using mutable state with a careful discipline surrounding the modification of the state.\n  Monads that maintain a parameter, potentially allowing it to be overridden in a section of the call stack, are called reader monads.\n  Reader monads are captured in the MonadReader type class.\n  Additionally, reader monads that allow the parameter value to be locally overridden are captured in the MonadWithReader type class.\n\n Exception monads have exceptions\n\nComputations that may terminate early with an exceptional value use exceptions.\n  They are typically modeled with a sum type that has a constructor for ordinary termination and a constructor for early termination with errors.\n  Exception monads are described in the section on exception monads, and captured in the MonadExcept type class.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation","header":"14.5. Varieties of Monads","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties"},"/Interacting-with-Lean/#repr-instance-howto":{"contents":"Lean can produce an appropriate Repr instance for most types automatically using instance deriving.\nIn some cases, however, it's necessary to write an instance by hand:\n\n\n\n\n\nWhen writing a custom Repr instance, please follow these conventions:\n\n Precedence\n\nCheck precedence, adding parentheses as needed, and pass the correct precedence to the reprPrec instances of embedded data.\n  Each instance is responsible for surrounding itself in parentheses if needed; instances should generally not parenthesize recursive calls to reprPrec.Function application has the maximum precedence, max_prec.\n  The helpers Repr.addAppParen and reprArg respectively insert parentheses around applications when needed and pass the appropriate precedence to function arguments.\n\n Fully-Qualified Names\n\nA Repr instance does have access to the set of open namespaces in a given position.\n  All names of constants in the environment should be fully qualified to remove ambiguity.\n\n Default Nesting\n\nNested data should be indented using nestD to ensure consistent indentation across instances.\n\n Grouping and Line Breaks\n\nThe output of every Repr instance that includes line breaks should be surrounded in a group.\n  Furthermore, if the resulting code contains notional expressions that are nested, a group should be inserted around each nested level.\n  Line breaks should usually be inserted in the following positions:* Between a constructor and each of its arguments* After :=* After ,* Between the opening and closing braces of structure instance notation and its contents* After, but not before, an infix operator\n\n Parentheses and Brackets\n\nParentheses and brackets should be inserted using Std.Format.bracket or its specializations Std.Format.paren for parentheses and Std.Format.sbracket for square brackets.\n  These operators align the contents of the parenthesized or bracketed expression in the same way that Lean's do.\n  Trailing parentheses and brackets should not be placed on their own line, but rather stay with their contents.\n\n\n\nAdds parentheses to f if the precedence prec from the context is at least that of function\napplication.Together with reprArg, this can be used to correctly parenthesize function application\nsyntax.\n\nTurns a into a Format using its Repr instance, with the precedence level set to that of\nfunction application.Together with Repr.addAppParen, this can be used to correctly parenthesize function application\nsyntax.\n\nInductive Types with ConstructorsThe inductive type N.NatOrInt can contain a Nat or an Int:namespace N\n\ninductive NatOrInt where\n  | nat : Nat → NatOrInt\n  | int : Int → NatOrInt\n\nThe Repr NatOrInt instance adheres to the conventions:* The right-hand side is a function application, so it uses Repr.addAppParen to add parentheses if necessary.* Parentheses are wrapped around the entire body with no additional lines.* The entire function application is grouped, and it is nested the default amount.* The function is separated from its parameters by a use of line; this newline will usually be a space because the Repr Nat and Repr Int instances are unlikely to produce long output.* Recursive calls to reprPrec pass max_prec because they are in function parameter positions, and function application has the highest precedence.instance : Repr NatOrInt where\n  reprPrec\n    | .nat n =>\n      Repr.addAppParen <|\n        .group <| .nestD <|\n          \"N.NatOrInt.nat\" ++ .line ++ reprPrec n max_prec\n    | .int i =>\n      Repr.addAppParen <|\n        .group <| .nestD <|\n          \"N.NatOrInt.int\" ++ .line ++ reprPrec i max_prec\n#eval IO.println (repr (NatOrInt.nat 5))\nN.NatOrInt.nat 5\n#eval IO.println (repr (NatOrInt.int 5))\nN.NatOrInt.int 5\n#eval IO.println (repr (NatOrInt.int (-5)))\nN.NatOrInt.int (-5)\n#eval IO.println (repr (some (NatOrInt.int (-5))))\nsome (N.NatOrInt.int (-5))\n#eval IO.println (repr <| (List.range 10).map (NatOrInt.nat))\n[N.NatOrInt.nat 0,\n N.NatOrInt.nat 1,\n N.NatOrInt.nat 2,\n N.NatOrInt.nat 3,\n N.NatOrInt.nat 4,\n N.NatOrInt.nat 5,\n N.NatOrInt.nat 6,\n N.NatOrInt.nat 7,\n N.NatOrInt.nat 8,\n N.NatOrInt.nat 9]\n#eval IO.println <|\n  Std.Format.pretty (width := 3) <|\n    repr <| (List.range 10).map NatOrInt.nat\n[N.NatOrInt.nat\n   0,\n N.NatOrInt.nat\n   1,\n N.NatOrInt.nat\n   2,\n N.NatOrInt.nat\n   3,\n N.NatOrInt.nat\n   4,\n N.NatOrInt.nat\n   5,\n N.NatOrInt.nat\n   6,\n N.NatOrInt.nat\n   7,\n N.NatOrInt.nat\n   8,\n N.NatOrInt.nat\n   9]\n\n\nInfix SyntaxThis example demonstrates the use of precedences to encode a left-associative pretty printer.\nThe type AddExpr represents expressions with constants and addition:inductive AddExpr where\n  | nat : Nat → AddExpr\n  | add : AddExpr → AddExpr → AddExpr\nThe OfNat and Add instances provide a more convenient syntax for AddExpr:instance : OfNat AddExpr n where\n  ofNat := .nat n\n\ninstance : Add AddExpr where\n  add := .add\nThe Repr AddExpr instance should insert only the necessary parentheses.\nLean's addition operator is left-associative, with precedence 65, so the recursive call to the left uses precedence 64 and the operator itself is parenthesized if the current context has precedence greater than or equal to 65:protected def AddExpr.reprPrec : AddExpr → Nat → Std.Format\n  | .nat n, p  =>\n    Repr.reprPrec n p\n  | .add e1 e2, p =>\n    let out : Std.Format :=\n      .nestD <| .group <|\n        AddExpr.reprPrec e1 64 ++ \" \" ++ \"+\" ++ .line ++\n        AddExpr.reprPrec e2 65\n    if p ≥ 65 then out.paren else out\n\ninstance : Repr AddExpr := ⟨AddExpr.reprPrec⟩\nRegardless of the input's parenthesization, this instance inserts only the necessary parentheses:#eval IO.println (repr (((2 + 3) + 4) : AddExpr))\n2 + 3 + 4\n#eval IO.println (repr ((2 + 3 + 4) : AddExpr))\n2 + 3 + 4\n#eval IO.println (repr ((2 + (3 + 4)) : AddExpr))\n2 + (3 + 4)\n#eval IO.println (repr ([2 + (3 + 4), (2 + 3) + 4] : List AddExpr))\n[2 + (3 + 4), 2 + 3 + 4]\nThe uses of group, nestD, and line in the implementation lead to the expected newlines and indentation in a narrow context:#eval ([2 + (3 + 4), (2 + 3) + 4] : List AddExpr)\n  |> repr\n  |>.pretty (width := 0)\n  |> IO.println\n[2 +\n   (3 +\n      4),\n 2 +\n     3 +\n   4]\n\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Repr","header":"3.7.2.1. How To Write a  Repr  Instance","id":"/Interacting-with-Lean/#repr-instance-howto"},"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Other":{"contents":"* #6137 adds support for displaying multiple threads in the trace\nprofiler output.* #6138 fixes trace.profiler.pp not using the term pretty printer.* #6259 ensures that nesting trace nodes are annotated with timing\ninformation iff trace.profiler is active.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.15.0 (2025-01-04)","header":"Other","id":"/releases/v4.15.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___15___0-_LPAR_2025-01-04_RPAR_--Other"},"/releases/v4.15.0/#release-v4___15___0":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.15.0 (2025-01-04)","id":"/releases/v4.15.0/#release-v4___15___0"},"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Pretty-Printing":{"contents":"* #5689 adjusts the way the pretty printer unresolves names. It used to\nmake use of all exports when pretty printing, but now it only uses\nexports that put names into parent namespaces (heuristic: these are\n\"API exports\" that are intended by the library author), rather than\n\"horizontal exports\" that put the names into an unrelated namespace,\nwhich the dot notation feature in #6189 now incentivizes.* #5757, aside from introducing labeled sorries, fixes the bug that the metadata attached to the pretty-printed representation of arguments with a borrow annotation (for example, the second argument of String.append), is inconsistent with the metadata attached to the regular arguments.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.16.0 (2025-02-03)","header":"Pretty Printing","id":"/releases/v4.16.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___16___0-_LPAR_2025-02-03_RPAR_--Pretty-Printing"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Simp":{"contents":"* Flagging unused simp arguments#8901 adds a linter (linter.unusedSimpArgs) that complains when a\nsimp argument (simp [foo]) is unused, with a clickable suggestion to remove it.\nHandles repeated simp calls correctly (e.g., inside all_goals), but skips macros.* Detection of possibly looping lemmas#8865 allows simp to recognize and warn about simp lemmas that are\nlikely looping in the current simp set. It does so automatically\nwhenever simplification fails with the dreaded “max recursion depth”\nerror, but it can be made to do it always with set_option linter.loopingSimpArgs true. This check is not on by default because it\nis somewhat costly, and can warn about simp calls that still happen to\nwork.* Faster simp via cache reuse#8880 makes simp consult\nits own cache more often, to avoid replicating work.* Explicit defeq attribute for dsimp#8419 introduces an explicit defeq attribute to mark theorems that\ncan be used by dsimp. The benefit of an explicit attribute over the\nprior logic of looking at the proof body is that we can reliably omit\ntheorem bodies across module boundaries. It also helps with intra-file\nparallelism.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Simp","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Simp"},"/releases/v4.24.0/#release-v4___24___0":{"contents":"For this release, 377 changes landed. In addition to the 105 feature additions and 75 fixes listed below there were 25 refactoring changes, 9 documentation improvements, 21 performance improvements, 4 improvements to the test suite and 138 other changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.24.0 (2025-10-14)","id":"/releases/v4.24.0/#release-v4___24___0"}});