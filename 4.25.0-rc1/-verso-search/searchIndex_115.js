window.docContents[115].resolve({"/Definitions/Recursive-Definitions/#partial-correctness-theorem":{"contents":"For every function defined as a partial fixpoint, Lean proves that the defining equation is satisfied.\nThis enables proofs by rewriting.\nHowever, these equational theorems are not sufficient for reasoning about the behavior of the function on arguments for which the function specification does not terminate.\nCode paths that lead to infinite recursion at runtime would end up as infinite chains of rewrites in a potential proof.\n\nPartial fixpoints in suitable monads, on the other hand, provide additional theorems that map the undefined values from non-termination to suitable values in the monad.\nIn the Option monad, then partial fixpoint equals Option.none on all function inputs for which the defining equation specifies non-termination.\nFrom this fact, Lean proves a partial correctness theorem for the function which allows facts to be concluded when the function's result is Option.some.\n\nPartial Correctness TheoremRecall List.findIndex from an earlier example:def List.findIndex (xs : List α) (p : α → Bool) : Option Nat :=\n  match xs with\n  | [] => none\n  | x::ys =>\n    if p x then\n      some 0\n    else\n      (· + 1) <$> List.findIndex ys p\npartial_fixpoint\nWith this function definition, Lean automatically proves the following partial correctness theorem:List.findIndex.partial_correctness.{u_1} {α : Type u_1}\n  (p : α → Bool)\n  (motive : List α → Nat → Prop)\n  (h :\n    ∀ (findIndex : List α → Option Nat),\n      (∀ (xs : List α) (r : Nat), findIndex xs = some r → motive xs r) →\n        ∀ (xs : List α) (r : Nat),\n          (match xs with\n              | [] => none\n              | x :: ys =>\n                if p x = true then some 0\n                else (fun x => x + 1) <$> findIndex ys) = some r →\n            motive xs r)\n  (xs : List α) (r : Nat) :\n  xs.findIndex p = some r →\n    motive xs r\nHere, the motive is a relation between the parameter and return types of List.findIndex, with the Option removed from the return type.\nIf, when given an arbitrary partial function with a signature that's compatible with List.findIndex, the following hold:* the motive is satisfied for all inputs for which the arbitrary function returns a value (rather than none),* taking one rewriting step with the defining equation, in which the recursive calls are replaced by the arbitrary function, also implies the satisfaction of the motivethen the motive is satsified for all inputs for which the List.findIndex returns some.The partial correctness theorem is a reasoning principle.\nIt can be used to prove that the resulting number is a valid index in the list and that the predicate holds for that index:theorem List.findIndex_implies_pred\n    (xs : List α) (p : α → Bool) :\n    xs.findIndex p = some i →\n    ∃x, xs[i]? = some x ∧ p x := by\n  apply List.findIndex.partial_correctness\n          (motive := fun xs i => ∃ x, xs[i]? = some x ∧ p x)\n  intro findIndex ih xs r hsome\n  split at hsome\n  next => contradiction\n  next x ys =>\n    split at hsome\n    next =>\n      have : r = 0 := by simp_all\n      simp_all\n    next =>\n      simp only [Option.map_eq_map, Option.map_eq_some'] at hsome\n      obtain ⟨r', hr, rfl⟩ := hsome\n      specialize ih _ _ hr\n      simpa\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.3. Partial Correctness Theorems","id":"/Definitions/Recursive-Definitions/#partial-correctness-theorem"}});