window.docContents[101].resolve({"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts--Monad-Functors":{"contents":"A way to interpret a fully-polymorphic function in m into n. Such a function can be thought of\nas one that may change the effects in m, but can't do so based on specific values that are\nprovided.Clients of MonadFunctor should typically use MonadFunctorT, which is the reflexive, transitive\nclosure of MonadFunctor. New instances should be defined for MonadFunctor.Lifts a fully-polymorphic transformation of m into n.\n\nA way to interpret a fully-polymorphic function in m into n. Such a function can be thought of\nas one that may change the effects in m, but can't do so based on specific values that are\nprovided.This is the reflexive, transitive closure of MonadFunctor. It automatically chains together\nMonadFunctor instances as needed. Clients of MonadFunctor should typically use MonadFunctorT,\nbut new instances should be defined for MonadFunctor.Lifts a fully-polymorphic transformation of m into n.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Lifting Monads\u0009Reversing Lifts","header":"14.2.1.1. Monad Functors","id":"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts--Monad-Functors"},"/Terms/Pattern-Matching/#pattern-fun":{"contents":"Pattern-Matching FunctionsFunctions may be specified via pattern matching by writing a sequence of patterns after fun, each preceded by a vertical bar (|).This desugars to a function that immediately pattern-matches on its arguments.\n\nPattern-Matching FunctionsisZero is defined using a pattern-matching function abstraction, while isZero' is defined using a pattern match expression:def isZero : Nat → Bool :=\n  fun\n    | 0 => true\n    | _ => false\n\ndef isZero' : Nat → Bool :=\n  fun n =>\n    match n with\n    | 0 => true\n    | _ => false\nBecause the former is syntactic sugar for the latter, they are definitionally equal:example : isZero = isZero' := rfl\nThe desugaring is visible in the output of #print:#print isZero\noutputsdef isZero : Nat → Bool :=\nfun x =>\n  match x with\n  | 0 => true\n  | x => false\nwhile#print isZero'\noutputsdef isZero' : Nat → Bool :=\nfun n =>\n  match n with\n  | 0 => true\n  | x => false\n\n\n","context":"Lean Reference\u0009Terms\u0009Pattern Matching","header":"10.8.3. Pattern Matching Functions","id":"/Terms/Pattern-Matching/#pattern-fun"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-same-parameters":{"contents":"All inductive types in the mutual group must have the same parameters.\nTheir indices may differ.\n\nDiffering numbers of parametersEven though Both and OneOf are not mutually recursive, they are declared in the same mutual block and must therefore have identical parameters:mutual\n  inductive Both (α : Type u) (β : Type v) where\n    | mk : α → β → Both α β\n  inductive Optional (α : Type u) where\n    | none\n    | some : α → Optional α\nend\nInvalid mutually inductive types: `Optional` has 1 parameter(s), but the preceding type `Both` has 2\n\nNote: All inductive types declared in the same `mutual` block must have the same parameters\n\n\nDiffering parameter typesEven though Many and OneOf are not mutually recursive, they are declared in the same mutual block and must therefore have identical parameters.\nThey both have exactly one parameter, but Many's parameter is not necessarily in the same universe as Optional's:mutual\n  inductive Many (α : Type) : Type u where\n    | nil : Many α\n    | cons : α → Many α → Many α\n  inductive Optional (α : Type u) where\n    | none\n    | some : α → Optional α\nend\nInvalid mutually inductive types: Parameter `α` has type\n  Type u\nof sort `Type (u + 1)` but is expected to have type\n  Type\nof sort `Type 1`\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types\u0009Requirements","header":"4.4.5.1.2. Parameters Must Match","id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-same-parameters"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Compiler":{"contents":"* #8594 removes incorrect optimizations for strictOr/strictAnd from the\nold compiler, along with deleting an incorrect test. In order to do\nthese optimizations correctly, nontermination analysis is required.\nArguably, the correct way to express these optimizations is by exposing\nthe implementation of strictOr/strictAnd to a nontermination-aware phase\nof the compiler, and then having them follow from more general\ntransformations.* #8595 wraps the invocation of the new compiler in withoutExporting.\nThis is not necessary for the old compiler because it uses more direct\naccess to the kernel environment.* #8602 adds support to the new compiler for Eq.recOn (which is\nsupported by the old compiler but missing a test).* #8604 adds support for the compiler.extract_closed option to the new\ncompiler, since this is used by the definition of unsafeBaseIO. We'll\nrevisit this once we switch to the new compiler and rethink its\nrelationship with IO.* #8614 implements constant folding for toNat in the new compiler,\nwhich improves parity with the old compiler.* #8616 adds constant folding for Nat.pow to the new compiler,\nfollowing the same limits as the old compiler.* #8618 implements LCNF constant folding for Nat.nextPowerOfTwo.* #8634 makes hasTrivialStructure? return false for types whose\nconstructors have types that are erased, e.g. if they construct a\nProp.* #8636 adds a function called lean_setup_libuv that initializes\nrequired LIBUV components. It needs to be outside of\nlean_initialize_runtime_module because it requires argv and argc\nto work correctly.* #8647 improves the precision of the new compiler's noncomputable\ncheck for projections. There is no test included because while this was\nreduced from Mathlib, the old compiler does not correctly handle the\nreduced test case. It's not entirely clear to me if the check is passing\nwith the old compiler for correct reasons. A test will be added to the\nnew compiler's branch.* #8675 increases the precision of the new compiler's non computable\ncheck, particularly around irrelevant uses of noncomputable defs in\napplications.* #8681 adds an optimization to the LCNF simp pass where the\ndiscriminant of a cases construct will only be mark used if it has a\nnon-default alternative.* #8683 adds an optimization to the LCNF simp pass where the\ndiscriminant of a single-alt cases is only marked as used if any param\nis used.* #8709 handles constants with erased types in toMonoType. It is much\nharder to write a test case for this than you would think, because most\nreferences to such types get replaced with lcErased earlier.* #8712 optimizes let decls of an erased type to an erased value.\nSpecialization can create local functions that produce a Prop, and\nthere's no point in keeping them around.* #8716 makes any type application of an erased term to be erased. This\ncomes up a bit more than one would expect in the implementation of Lean\nitself.* #8717 uses the fvar substitution mechanism to replace erased code.\nThis isn't entirely satisfactory, since LCNF's .return doesn't support\na general Arg (which has a .erased constructor), it only supports an\nFVarId. This is in contrast to the IR .ret, which does support a\ngeneral Arg.* #8729 changes LCNF's FVarSubst to use Arg rather than Expr. This\nenforces the requirements on substitutions, which match the requirements\non Arg.* #8752 fixes an issue where the extendJoinPointContext pass can lift\njoin points containing projections to the top level, as siblings of\ncases constructs matching on other projections of the same base value.\nThis prevents the structProjCases pass from projecting both at once,\nextending the lifetime of the parent value and breaking linearity at\nruntime.* #8754 changes the implementation of computed fields in the new\ncompiler, which should enable more optimizations (and remove a\nquestionable hack in toLCNF that was only suitable for bringup). We\nconvert casesOn to cases like we do for other inductive types, all\nconstructors get replaced by their real implementations late in the base\nphase, and then the cases expression is rewritten to use the real\nconstructors in toMono.* #8758 adds caching for the hasTrivialStructure? function for LCNF\ntypes. This is one of the hottest small functions in the new compiler,\nso adding a cache makes a lot of sense.* #8764 changes the LCNF pass pipeline so checks are no longer run by\ndefault after every pass, only after init, saveBase, toMono and\nsaveMono. This is a compile time improvement, and the utility of these\nchecks is decreased a bit after the decision to no longer attempt to\npreserve types throughout compilation. They have not been a significant\nway to discover issues during development of the new compiler.* #8802 fixes a bug in floatLetIn where if one decl (e.g. a join\npoint) is floated into a case arm and it uses another decl (e.g. another\njoin point) that does not have any other existing uses in that arm, then\nthe second decl does not get floated in despite this being perfectly\nlegal. This was causing artificial array linearity issues in\nLean.Elab.Tactic.BVDecide.LRAT.trim.useAnalysis.* #8816 adds constant folding for Char.ofNat in LCNF simp. This\nimplicitly relies on the representation of Char as UInt32 rather\nthan making a separate .char literal type, which seems reasonable as\nChar is erased by the trivial structure optimization in toMono.* #8822 adds a cache for constructor info in toIR. This is called for\nall constructors, projections, and cases alternatives, so it makes sense\nto cache.* #8825 improves IR generation for constructors of inductive types that\nare represented by scalars. Surprisingly, this isn't required for\ncorrectness, because the boxing pass will fix it up. The extra unbox\noperation it inserts shouldn't matter when compiling to native code,\nbecause it's trivial for a C compiler to optimize, but it does matter\nfor the interpreter.* #8831 caches the result of lowerEnumToScalarType, which is used\nheavily in LCNF to IR conversion.* #8885 removes an old workaround around non-implemented C++11 features\nin the thread finalization.* #8923 implements casesOn for Thunk and Task. Since these are\nbuiltin types, this needs to be special-cased in toMono.* #8952 fixes the handling of the never_extract attribute in the\ncompiler's CSE pass. There is an interesting debate to be had about\nexactly how hard the compiler should try to avoid duplicating anything\nthat transitively uses never_extract, but this is the simplest form\nand roughly matches the check in the old compiler (although due to\ndifferent handling of local function decls in the two compilers, the\nconsequences might be slightly different).* #8956 changes toLCNF to stop caching translations of expressions\nupon seeing an expression marked never_extract. This is more\ncoarse-grained than it needs to be, but it is difficult to do any\nbetter, as the new compiler's Expr cache is based on structural\nidentity (rather than the pointer identity of the old compiler).* #9003 implements the validity check for the type of main in the new\ncompiler. There were no tests for this, so it slipped under the radar.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Compiler","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Compiler"}});