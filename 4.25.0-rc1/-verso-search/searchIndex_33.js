window.docContents[33].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Iteration":{"contents":"Updates the values of the hash map by applying the given function to all mappings.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Dependent Hash Maps","header":"19.18.5.5. Iteration","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Iteration"},"/IO/Logical-Model/#The-Lean-Language-Reference--IO--Logical-Model":{"contents":"Conceptually, Lean distinguishes evaluation or reduction of terms from execution of side effects.\nTerm reduction is specified by rules such as β and δ, which may occur anywhere at any time.\nSide effects, which must be executed in the correct order, are abstractly described in Lean's logic.\nWhen programs are run, the Lean runtime system is responsible for actually carrying out the described effects.The type IO α is a description of a process that, by performing side effects, should either return a value of type α or throw an error.\nIt can be thought of as a state monad in which the state is the entire world.\nJust as a value of type StateM Nat Bool computes a Bool while having the ability to mutate a natural number, a value of type IO Bool computes a Bool while potentially changing the world.\nError handling is accomplished by layering an appropriate exception monad transformer on top of this.\n\nBecause the entire world can't be represented in memory, the actual implementation uses an abstract token that stands for its state.\nThe Lean runtime system is responsible for providing the initial token when the program is run, and each primitive action accepts a token that represents the world and returns another when finished.\nThis ensures that effects occur in the proper order, and it clearly separates the execution of side effects from the reduction semantics of Lean terms.\n\nNon-termination via general recursion is treated separately from the effects described by IO.\nPrograms that may not terminate due to infinite loops must be defined as partial functions.\nFrom the logical perspective, they are treated as arbitrary constants; IO is not needed.\n\nA very important property of IO is that there is no way for values to “escape”.\nWithout using one of a few clearly-marked unsafe operators, programs have no way to extract a pure Nat from an IO Nat.\nThis ensures that the correct ordering of side effects is preserved, and it ensures that programs that have side effects are clearly marked as such.\n\n\n\n\n\n","context":"Lean Reference\u0009IO","header":"15.1. Logical Model","id":"/IO/Logical-Model/#The-Lean-Language-Reference--IO--Logical-Model"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Inspecting-Syntax":{"contents":"\n\nThere are three primary ways to inspect Syntax values:\n\n The Repr Instance\n\nThe Repr Syntax instance produces a very detailed representation of syntax in terms of the constructors of the Syntax type.\n\n The ToString Instance\n\nThe ToString Syntax instance produces a compact view, representing certain syntax kinds with particular conventions that can make it easier to read at a glance.\n  This instance suppresses source position information.\n\n The Pretty Printer\n\nLean's pretty printer attempts to render the syntax as it would look in a source file, but fails if the nesting structure of the syntax doesn't match the expected shape.\n\n\n\nRepresenting Syntax as ConstructorsThe Repr instance's representation of syntax can be inspected by quoting it in the context of #eval, which can run actions in the command elaboration monad CommandElabM.\nTo reduce the size of the example output, the helper removeSourceInfo is used to remove source information prior to display.partial def removeSourceInfo : Syntax → Syntax\n  | .atom _ str => .atom .none str\n  | .ident _ str x pre => .ident .none str x pre\n  | .node _ k children => .node .none k (children.map removeSourceInfo)\n  | .missing => .missing\n#eval do\n  let stx ← `(2 + $(⟨.missing⟩))\n  logInfo (repr (removeSourceInfo stx.raw))\nLean.Syntax.node\n  (Lean.SourceInfo.none)\n  `«term_+_»\n  #[Lean.Syntax.node (Lean.SourceInfo.none) `num #[Lean.Syntax.atom (Lean.SourceInfo.none) \"2\"],\n    Lean.Syntax.atom (Lean.SourceInfo.none) \"+\", Lean.Syntax.missing]\nIn the second example, macro scopes inserted by quotation are visible on the call to List.length.#eval do\n  let stx ← `(List.length [\"Rose\", \"Daffodil\", \"Lily\"])\n  logInfo (repr (removeSourceInfo stx.raw))\nThe contents of the pre-resolved identifier List.length are visible here:Lean.Syntax.node\n  (Lean.SourceInfo.none)\n  `Lean.Parser.Term.app\n  #[Lean.Syntax.ident\n      (Lean.SourceInfo.none)\n      \"List.length\".toSubstring\n      (Lean.Name.mkNum `List.length._@.Manual.NotationsMacros.SyntaxDef._hyg 2)\n      [Lean.Syntax.Preresolved.decl `List.length [], Lean.Syntax.Preresolved.namespace `List.length],\n    Lean.Syntax.node\n      (Lean.SourceInfo.none)\n      `null\n      #[Lean.Syntax.node\n          (Lean.SourceInfo.none)\n          `«term[_]»\n          #[Lean.Syntax.atom (Lean.SourceInfo.none) \"[\",\n            Lean.Syntax.node\n              (Lean.SourceInfo.none)\n              `null\n              #[Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) \"\\\"Rose\\\"\"],\n                Lean.Syntax.atom (Lean.SourceInfo.none) \",\",\n                Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) \"\\\"Daffodil\\\"\"],\n                Lean.Syntax.atom (Lean.SourceInfo.none) \",\",\n                Lean.Syntax.node (Lean.SourceInfo.none) `str #[Lean.Syntax.atom (Lean.SourceInfo.none) \"\\\"Lily\\\"\"]],\n            Lean.Syntax.atom (Lean.SourceInfo.none) \"]\"]]]\n\n\nThe ToString instance represents the constructors of Syntax as follows:\n\n* The ident constructor is represented as the underlying name. Source information and pre-resolved names are not shown.* The atom constructor is represented as a string.* The missing constructor is represented by <missing>.* The representation of the node constructor depends on the kind.\n   If the kind is `null, then the node is represented by its child nodes order in square brackets.\n   Otherwise, the node is represented by its kind followed by its child nodes, both surrounded by parentheses.\n\nSyntax as StringsThe string representation of syntax can be inspected by quoting it in the context of #eval, which can run actions in the command elaboration monad CommandElabM.#eval do\n  let stx ← `(2 + $(⟨.missing⟩))\n  logInfo (toString stx)\n(«term_+_» (num \"2\") \"+\" <missing>)\nIn the second example, macro scopes inserted by quotation are visible on the call to List.length.#eval do\n  let stx ← `(List.length [\"Rose\", \"Daffodil\", \"Lily\"])\n  logInfo (toString stx)\n(Term.app\n `List.length._@.Manual.NotationsMacros.SyntaxDef._hyg.2\n [(«term[_]» \"[\" [(str \"\\\"Rose\\\"\") \",\" (str \"\\\"Daffodil\\\"\") \",\" (str \"\\\"Lily\\\"\")] \"]\")])\n\n\nPretty printing syntax is typically most useful when including it in a message to a user.\nNormally, Lean automatically invokes the pretty printer when necessary.\nHowever, ppTerm can be explicitly invoked if needed.\n\nPretty-Printed SyntaxThe string representation of syntax can be inspected by quoting it in the context of #eval, which can run actions in the command elaboration monad CommandElabM.\nBecause new syntax declarations also equip the pretty printer with instructions for displaying them, the pretty printer requires a configuration object.\nThis context can be constructed with a helper:def getPPContext : CommandElabM PPContext := do\n  return {\n    env := (← getEnv),\n    opts := (← getOptions),\n    currNamespace := (← getCurrNamespace),\n    openDecls := (← getOpenDecls)\n  }\n#eval show CommandElabM Unit from do\n  let stx ← `(2 + 5)\n  let fmt ← ppTerm (← getPPContext) stx\n  logInfo fmt\n2 + 5\nIn the second example, the macro scopes inserted on List.length by quotation cause it to be displayed with a dagger (✝).#eval do\n  let stx ← `(List.length [\"Rose\", \"Daffodil\", \"Lily\"])\n  let fmt ← ppTerm (← getPPContext) stx\n  logInfo fmt\nList.length✝ [\"Rose\", \"Daffodil\", \"Lily\"]\nPretty printing wraps lines and inserts indentation automatically.\nA coercion typically converts the pretty printer's output to the type expected by logInfo, using a default layout width.\nThe width can be controlled by explicitly calling pretty with a named argument.#eval do\n  let flowers := #[\"Rose\", \"Daffodil\", \"Lily\"]\n  let manyFlowers := flowers ++ flowers ++ flowers\n  let stx ← `(List.length [$(manyFlowers.map (quote (k := `term))),*])\n  let fmt ← ppTerm (← getPPContext) stx\n  logInfo (fmt.pretty (width := 40))\nList.length✝\n  [\"Rose\", \"Daffodil\", \"Lily\", \"Rose\",\n    \"Daffodil\", \"Lily\", \"Rose\",\n    \"Daffodil\", \"Lily\"]\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.6. Inspecting Syntax","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Inspecting-Syntax"},"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Data-Lookups":{"contents":"The classes GetElem and GetElem? implement lookup notation,\nspecifically xs[i], xs[i]?, xs[i]!, and xs[i]'p.Both classes are indexed by types coll, idx, and elem which are\nthe collection, the index, and the element types.\nA single collection may support lookups with multiple index\ntypes. The relation valid determines when the index is guaranteed to be\nvalid; lookups of valid indices are guaranteed not to fail.For example, an instance for arrays looks like\nGetElem (Array α) Nat α (fun xs i => i < xs.size). In other words, given an\narray xs and a natural number i, xs[i] will return an α when valid xs i\nholds, which is true when i is less than the size of the array. Array\nadditionally supports indexing with USize instead of Nat.\nIn either case, because the bounds are checked at compile time,\nno runtime check is required.Given xs[i] with xs : coll and i : idx, Lean looks for an instance of\nGetElem coll idx elem valid and uses this to infer the type of the return\nvalue elem and side condition valid required to ensure xs[i] yields\na valid value of type elem. The tactic get_elem_tactic is\ninvoked to prove validity automatically. The xs[i]'p notation uses the\nproof p to satisfy the validity condition.\nIf the proof p is long, it is often easier to place the\nproof in the context using have, because get_elem_tactic tries\nassumption.The proof side-condition valid xs i is automatically dispatched by the\nget_elem_tactic tactic; this tactic can be extended by adding more clauses to\nget_elem_tactic_extensible using macro_rules.xs[i]? and xs[i]! do not impose a proof obligation; the former returns\nan Option elem, with none signalling that the value isn't present, and\nthe latter returns elem but panics if the value isn't there, returning\ndefault : elem based on the Inhabited elem instance.\nThese are provided by the GetElem? class, for which there is a default instance\ngenerated from a GetElem class as long as valid xs i is always decidable.Important instances include:* arr[i] : α where arr : Array α and i : Nat or i : USize: does array\nindexing with no runtime bounds check and a proof side goal i < arr.size.* l[i] : α where l : List α and i : Nat: index into a list, with proof\nside goal i < l.length.The syntax arr[i] gets the i'th element of the collection arr. If there\nare proof side conditions to the application, they will be automatically\ninferred by the get_elem_tactic tactic.Conventions for notations in identifiers:* The recommended spelling of xs[i] in identifiers is getElem.* The recommended spelling of xs[i]'h in identifiers is getElem.\n\nThe classes GetElem and GetElem? implement lookup notation,\nspecifically xs[i], xs[i]?, xs[i]!, and xs[i]'p.Both classes are indexed by types coll, idx, and elem which are\nthe collection, the index, and the element types.\nA single collection may support lookups with multiple index\ntypes. The relation valid determines when the index is guaranteed to be\nvalid; lookups of valid indices are guaranteed not to fail.For example, an instance for arrays looks like\nGetElem (Array α) Nat α (fun xs i => i < xs.size). In other words, given an\narray xs and a natural number i, xs[i] will return an α when valid xs i\nholds, which is true when i is less than the size of the array. Array\nadditionally supports indexing with USize instead of Nat.\nIn either case, because the bounds are checked at compile time,\nno runtime check is required.Given xs[i] with xs : coll and i : idx, Lean looks for an instance of\nGetElem coll idx elem valid and uses this to infer the type of the return\nvalue elem and side condition valid required to ensure xs[i] yields\na valid value of type elem. The tactic get_elem_tactic is\ninvoked to prove validity automatically. The xs[i]'p notation uses the\nproof p to satisfy the validity condition.\nIf the proof p is long, it is often easier to place the\nproof in the context using have, because get_elem_tactic tries\nassumption.The proof side-condition valid xs i is automatically dispatched by the\nget_elem_tactic tactic; this tactic can be extended by adding more clauses to\nget_elem_tactic_extensible using macro_rules.xs[i]? and xs[i]! do not impose a proof obligation; the former returns\nan Option elem, with none signalling that the value isn't present, and\nthe latter returns elem but panics if the value isn't there, returning\ndefault : elem based on the Inhabited elem instance.\nThese are provided by the GetElem? class, for which there is a default instance\ngenerated from a GetElem class as long as valid xs i is always decidable.Important instances include:* arr[i] : α where arr : Array α and i : Nat or i : USize: does array\nindexing with no runtime bounds check and a proof side goal i < arr.size.* l[i] : α where l : List α and i : Nat: index into a list, with proof\nside goal i < l.length.The syntax arr[i]? gets the i'th element of the collection arr,\nif it is present (and wraps it in some), and otherwise returns none.Conventions for notations in identifiers:* The recommended spelling of xs[i]? in identifiers is getElem?.The syntax arr[i]! gets the i'th element of the collection arr,\nif it is present, and otherwise panics at runtime and returns the default term\nfrom Inhabited elem.Conventions for notations in identifiers:* The recommended spelling of xs[i]! in identifiers is getElem!.\n\nLawful GetElem? instances (which extend GetElem) are those for which the potentially-failing\nGetElem?.getElem? and GetElem?.getElem! operators succeed when the validity predicate is\nsatisfied, and fail when it is not.GetElem?.getElem? succeeds when the validity predicate is satisfied and fails otherwise.GetElem?.getElem! succeeds and fails when GetElem.getElem? succeeds and fails.\n\n","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","header":"11.5.9. Data Lookups","id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Data-Lookups"},"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Pretty-Printing":{"contents":"* #7805 modifies the pretty printing of raw natural number literals; now\nboth pp.explicit and pp.natLit enable the nat_lit prefix. An\neffect of this is that the hover on such a literal in the Infoview has\nthe nat_lit prefix.* #7812 modifies the pretty printing of pi types. Now ∀ will be\npreferred over → for propositions if the domain is not a proposition.\nFor example, ∀ (n : Nat), True pretty prints as ∀ (n : Nat), True\nrather than as Nat → True. There is also now an option pp.foralls\n(default true) that when false disables using ∀ at all, for\npedagogical purposes. also adjusts instance implicit binder\npretty printing — nondependent pi types won't show the instance binder\nname. Closes #1834.* #7813 fixes an issue where let n : Nat := sorry in the Infoview\npretty prints as n : ℕ := sorry `«Foo:17:17». This was caused by\ntop-level expressions being pretty printed with the same rules as\nInfoview hovers. Closes #6715. Refactors Lean.Widget.ppExprTagged; now\nit takes a delaborator, and downstream users should configure their own\npretty printer option overrides if necessary if they used the explicit\nargument (see Lean.Widget.makePopup.ppExprForPopup for an example).\nBreaking change: ppExprTagged does not set pp.proofs on the root\nexpression.* #7840 causes structure instance notation to be tagged with the\nconstructor when pp.tagAppFns is true. This will make docgen will have\n{ and } be links to the structure constructor.* #8022 fixes a bug where pretty printing is done in a context with\ncleared local instances. These were cleared since the local context is\nupdated during a name sanitization step, but preserving local instances\nis valid since the modification to the local context only affects user\nnames.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.20.0 (2025-06-02)","header":"Pretty Printing","id":"/releases/v4.20.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___20___0-_LPAR_2025-06-02_RPAR_--Pretty-Printing"}});