window.docContents[255].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Rounding":{"contents":"Rounds to the nearest integer, rounding away from zero at half-way points.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nround.\n\nRounds to the nearest integer, rounding away from zero at half-way points.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nroundf.\n\nComputes the floor of a floating-point number, which is the largest integer that's no larger\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nfloor.Examples:* Float.floor 1.5 = 1* Float.floor (-1.5) = (-2)\n\nComputes the floor of a floating-point number, which is the largest integer that's no larger\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nfloorf.Examples:* Float32.floor 1.5 = 1* Float32.floor (-1.5) = (-2)\n\nComputes the ceiling of a floating-point number, which is the smallest integer that's no smaller\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nceil.Examples:* Float.ceil 1.5 = 2* Float.ceil (-1.5) = (-1)\n\nComputes the ceiling of a floating-point number, which is the smallest integer that's no smaller\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nceilf.Examples:* Float32.ceil 1.5 = 2* Float32.ceil (-1.5) = (-1)\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","header":"19.6.2.8. Rounding","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Rounding"},"/IO/Logical-Model/#io-monad-errors":{"contents":"Error handling in the IO monad uses the same facilities as any other exception monad.\nIn particular, throwing and catching exceptions uses the methods of the MonadExceptOf type class.\nThe exceptions thrown in IO have the type IO.Error.\nThe constructors of this type represent the low-level errors that occur on most operating systems, such as files not existing.\nThe most-used constructor is userError, which covers all other cases and includes a string that describes the problem.\n\nExceptions that may be thrown in the IO monad.Many of the constructors of IO.Error correspond to POSIX error numbers. In these cases, the\ndocumentation string lists POSIX standard error macros that correspond to the error. This list is\nnot necessarily exhaustive, and these constructor includes a field for the underlying error number.The operation failed because a file already exists.This corresponds to POSIX errors EEXIST, EINPROGRESS, and EISCONN.Some error not covered by the other constructors of IO.Error occurred.This also includes POSIX error EFAULT.A necessary resource was busy.This corresponds to POSIX errors EADDRINUSE, EBUSY, EDEADLK, and ETXTBSY.A necessary resource is no longer available.This corresponds to POSIX errors ECONNRESET, EIDRM, ENETDOWN, ENETRESET, ENOLINK, and\nEPIPE.An operation was not supported.This corresponds to POSIX errors EADDRNOTAVAIL, EAFNOSUPPORT, ENODEV, ENOPROTOOPT\nENOSYS, EOPNOTSUPP, ERANGE, ESPIPE, and EXDEV.The operation failed due to a hardware problem, such as an I/O error.This corresponds to the POSIX error EIO.A constraint required by an operation was not satisfied (e.g. a directory was not empty).This corresponds to the POSIX error ENOTEMPTY.An inappropriate I/O control operation was attempted.This corresponds to the POSIX error ENOTTY.A protocol error occurred.This corresponds to the POSIX errors EPROTO, EPROTONOSUPPORT, and EPROTOTYPE.An operation timed out.This corresponds to the POSIX errors ETIME, and ETIMEDOUT.The operation was interrupted.This corresponds to the POSIX error EINTR.No such file or directory.This corresponds to the POSIX error ENOENT.An argument to an I/O operation was invalid.This corresponds to the POSIX errors ELOOP, ENAMETOOLONG, EDESTADDRREQ, EILSEQ, EINVAL, EDOM, EBADF\nENOEXEC, ENOSTR, ENOTCONN, and ENOTSOCK.An operation failed due to insufficient permissions.This corresponds to the POSIX errors EACCES, EROFS, ECONNABORTED, EFBIG, and EPERM.A resource was exhausted.This corresponds to the POSIX errors  EMFILE, ENFILE, ENOSPC, E2BIG, EAGAIN, EMLINK,\nEMSGSIZE, ENOBUFS, ENOLCK, ENOMEM, and ENOSR.An argument was the wrong type (e.g. a directory when a file was required).This corresponds to the POSIX errors EISDIR, EBADMSG, and ENOTDIR.A required resource does not exist.This corresponds to the POSIX errors ENXIO, EHOSTUNREACH, ENETUNREACH, ECHILD,\nECONNREFUSED, ENODATA, ENOMSG, and ESRCH.An unexpected end-of-file marker was encountered.Some other error occurred.\n\nConverts an IO.Error to a descriptive string.IO.Error.userError is converted to its embedded message. The other constructors are converted in a\nway that preserves structured information, such as error codes and filenames, that can help\ndiagnose the issue.\n\nConverts an Except ε action into an IO action.If the Except ε action throws an exception, then the exception type's ToString instance is used\nto convert it into an IO.Error, which is thrown. Otherwise, the value is returned.\n\nHandles any exception that might be thrown by an EIO ε action, transforming it into an\nexception-free BaseIO action.\n\nConstructs an IO.Error from a string.IO.Error is the type of exceptions thrown by the IO monad.\n\nThrowing and Catching ErrorsThis program repeatedly demands a password, using exceptions for control flow.\nThe syntax used for exceptions is available in all exception monads, not just IO.\nWhen an incorrect password is provided, an exception is thrown, which is caught by the loop that repeats the password check.\nA correct password allows control to proceed past the check, terminating the loop, and any other exceptions are re-thrown.def accessControl : IO Unit := do\n  IO.println \"What is the password?\"\n  let password ← (← IO.getStdin).getLine\n  if password.trim != \"secret\" then\n    throw (.userError \"Incorrect password\")\n  else return\n\ndef repeatAccessControl : IO Unit := do\n  repeat\n    try\n      accessControl\n      break\n    catch\n      | .userError \"Incorrect password\" =>\n        continue\n      | other =>\n        throw other\n\ndef main : IO Unit := do\n  repeatAccessControl\n  IO.println \"Access granted!\"\nWhen run with this input:publicinfo\nsecondtry\nsecret\nthe program emits:What is the password?\nWhat is the password?\nWhat is the password?\nAccess granted!\n\n\n","context":"Lean Reference\u0009IO\u0009Logical Model","header":"15.1.2. Errors and Error Handling in  IO","id":"/IO/Logical-Model/#io-monad-errors"},"/Notations-and-Macros/Notations/#notations":{"contents":"The term notation is used in two ways in Lean: it can refer to the general concept of concise ways of writing down ideas, and it is the name of a language feature that allows notations to be conveniently implemented with little code.\nLike custom operators, Lean notations allow the grammar of terms to be extended with new forms.\nHowever, notations are more general: the new syntax may freely intermix required keywords or operators with subterms, and they provide more precise control over precedence levels.\nNotations may also rearrange their parameters in the resulting subterms, while infix operators provide them to the function term in a fixed order.\nBecause notations may define operators that use a mix of prefix, infix, and postfix components, they can be called mixfix operators.\n\nNotation DeclarationsNotations are defined using the notation command.\n\nNotation ItemsThe body of a notation definition consists of a sequence of notation items, which may be either string literals or identifiers with optional precedences.\n\nAs with operator declarations, the contents of the documentation comments are shown to users while they interact with the new syntax.\nAdding the inherit_doc attribute causes the documentation comment of the function at the head of the term into which the notation expands to be copied to the new syntax.\nOther attributes may be added to invoke other compile-time metaprograms on the resulting definition.\n\nNotations interact with section scopes in the same manner as attributes and operators.\nBy default, notations are available in any module that transitively imports the one in which they are established, but they may be declared scoped or local to restrict their availability either to contexts in which the current namespace has been opened or to the current section scope, respectively.\n\nLike operators, the local longest-match rule is used while parsing notations.\nIf more than one notation ties for the longest match, the declared priorities are used to determine which parse result applies.\nIf this still does not resolve the ambiguity, then all are saved, and the elaborator is expected to attempt all of them, succeeding when exactly one can be elaborated.\n\nRather than a single operator with its fixity and token, the body of a notation declaration consists of a sequence of notation items, which may be either new atoms (including both keywords such as if, #eval, or where and symbols such as =>, +, ↗, ⟦, or ⋉) or positions for terms.\nJust as they do in operators, string literals identify the placement of atoms.\nLeading and trailing spaces in the strings do not affect parsing, but they cause Lean to insert spaces in the corresponding position when displaying the syntax in proof states and error messages.\nIdentifiers indicate positions where terms are expected, and name the corresponding term so it can be inserted in the notation's expansion.\n\nWhile custom operators have a single notion of precedence, there are many involved in a notation.\nThe notation itself has a precedence, as does each term to be parsed.\nThe notation's precedence determines which contexts it may be parsed in: the parser only attempts to parse productions whose precedence is at least as high as the current context.\nFor example, because multiplication has higher precedence than addition, the parser will attempt to parse an infix multiplication term while parsing the arguments to addition, but not vice versa.\nThe precedence of each term to be parsed determines which other productions may occur in them.\n\nIf no precedence is supplied for the notation itself, the default value depends on the form of the notation.\nIf the notation both begins and ends with an atom (represented by string literals), then the default precedence is max.\nThis applies both to notations that consist only of a single atom and to notations with multiple items, in which the first and last items are both atoms.\nOtherwise, the default precedence of the whole notation is lead.\nIf no precedence is provided for notation items that are terms, then they default to precedence min.\n\n\n\nAfter the required double arrow (=>), the notation is provided with an expansion.\nWhile operators are always expanded by applying their function to the operator's arguments in order, notations may place their term items in any position in the expansion.\nThe terms are referred to by name.\nTerm items may occur any number of times in the expansion.\nBecause notation expansion is a purely syntactic process that occurs prior to elaboration or code generation, duplicating terms in the expansion may lead to duplicated computation when the resulting term is evaluated, or even duplicated side effects when working in a monad.\n\nIgnored Terms in Notation ExpansionThis notation ignores its first parameter:notation (name := ignore) \"ignore \" _ign:arg e:arg => e\nThe term in the ignored position is discarded, and Lean never attempts to elaborate it, so terms that would otherwise result in errors can be used here:#eval ignore (2 + \"whatever\") 5\n5\nHowever, the ignored term must still be syntactically valid:#eval ignore (2 +) 5\n<example>:1:17-1:18: unexpected token ')'; expected term\n\n\nDuplicated Terms in Notation ExpansionThe dup! notation duplicates its sub-term.notation (name := dup) \"dup!\" t:arg => (t, t)\nBecause the term is duplicated, it can be elaborated separately with different types:def e : Nat × Int := dup! (2 + 2)\nPrinting the resulting definition demonstrates that the work of addition will be performed twice:#print e\ndef e : Nat × Int :=\n(2 + 2, 2 + 2)\n\n\nWhen the expansion consists of the application of a function defined in the global environment and each term in the notation occurs exactly once, an unexpander is generated.\nThe new notation will be displayed in proof states, error messages, and other output from Lean when matching function application terms otherwise would have been displayed.\nAs with custom operators, Lean does not track whether the notation was used in the original term; it is used at every opportunity in Lean's output.\n\n\n\n","context":"Lean Reference\u0009Notations and Macros","header":"20.3. Notations","id":"/Notations-and-Macros/Notations/#notations"},"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Finite-Types":{"contents":"* #7228 adds simprocs to reduce expressions involving IntX.* #7274 adds lemmas about iterated conversions between finite types,\nstarting with something of type IntX.* #7340 adds lemmas for iterated conversions between finite types which\nstart with Nat/Int/Fin/BitVec and then go through UIntX.* #7368 adds lemmas for iterated conversions between finite types,\nstarting with something of type Nat/Int/Fin/BitVec and going\nthrough IntX.* #7414 adds the remaining lemmas about iterated conversions of finite\ntype that go through signed or unsigned bounded integers.* #7484 adds some lemmas about operations defined on UIntX* #7487 adds the instance Neg UInt8.* #7592 adds theory about signed finite integers relating operations and\nconversion functions.* #7598 adds miscellaneous results about Nat and BitVec that will be\nrequired for IntX theory (#7592).* #7685 contains additional material about BitVec and Int spun off\nfrom #7592.* #7694 contains additional material on BitVec, Int and Nat, split\noff from #7592.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.19.0 (2025-05-01)\u0009Library","header":"Finite Types","id":"/releases/v4.19.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___19___0-_LPAR_2025-05-01_RPAR_--Library--Finite-Types"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Warnings-about-sorrys":{"contents":"#8662 adds a warn.sorry option (default true) that logs the\n\"declaration uses 'sorry'\" warning when declarations contain sorryAx.\nWhen false, the warning is not logged.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Warnings about sorrys","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Warnings-about-sorrys"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Library":{"contents":"* #8003 adds a new monadic interface for Async operations.* #8072 adds DNS functions to the standard library* #8109 adds system information functions to the standard library* #8178 provides a compact formula for the MSB of the sdiv. Most of the\nwork in the PR involves handling the corner cases of division\noverflowing (e.g. intMin / -1 = intMin)* #8203 adds trichotomy lemmas for unsigned and signed comparisons,\nstating that only one of three cases may happen: either x < y, x = y, or x > y (for both signed and unsigned comparsions). We use\nexplicit arguments so that users can write rcases slt_trichotomy x y with hlt | heq | hgt.* #8205 adds a simp lemma that simplifies T-division where the numerator\nis a Nat into an E-division:@[simp] theorem ofNat_tdiv_eq_ediv {a : Nat} {b : Int} : (a : Int).tdiv b = a / b :=\n   tdiv_eq_ediv_of_nonneg (by simp)\n* #8210 adds an equivalence relation to tree maps akin to the existing\none for hash maps. In order to get many congruence lemmas to eventually\nuse for defining functions on extensional tree maps, almost all of the\nremaining tree map functions have also been given lemmas to relate them\nto list functions, although these aren't currently used to prove lemmas\nother than congruence lemmas.* #8253 adds toInt_smod and auxilliary lemmas necessary for its proof\n(msb_intMin_umod_neg_of_msb_true,\nmsb_neg_umod_neg_of_msb_true_of_msb_true, toInt_dvd_toInt_iff,\ntoInt_dvd_toInt_iff_of_msb_true_msb_false,\ntoInt_dvd_toInt_iff_of_msb_false_msb_true,\nneg_toInt_neg_umod_eq_of_msb_true_msb_true, toNat_pos_of_ne_zero,\ntoInt_umod_neg_add, toInt_sub_neg_umod and\nBitVec.[lt_of_msb_false_of_msb_true, msb_umod_of_msb_false_of_ne_zero,\nneg_toInt_neg])* #8420 provides the iterator combinator drop that transforms any\niterator into one that drops the first n elements.* #8534 fixes IO.FS.realPath on windows to take symbolic links into\naccount.* #8545 provides the means to reason about \"equivalent\" iterators.\nSimply speaking, two iterators are equivalent if they behave the same as\nlong as consumers do not introspect their states.* #8546 adds a new BitVec.clz operation and a corresponding clz\ncircuit to bv_decide, allowing to bitblast the count leading zeroes\noperation. The AIG circuit is linear in the number of bits of the\noriginal expression, making the bitblasting convenient wrt. rewriting.\nclz is common in numerous compiler intrinsics (see\nhere)\nand architectures (see\nhere).* #8573 avoids the likely unexpected behavior of removeDirAll to\ndelete through symlinks and adds the new function\nIO.FS.symlinkMetadata.* #8585 makes the lemma BitVec.extractLsb'_append_eq_ite more usable\nby using the \"simple case\" more often, and uses this simplification to\nmake BitVec.extractLsb'_append_eq_of_add_lt stronger, renaming it to\nBitVec.extractLsb'_append_eq_of_add_le.* #8587 adjusts the grind annotation on\nStd.HashMap.map_fst_toList_eq_keys and variants, so grind can reason\nbidirectionally between m.keys and m.toList.* #8590 adds @[grind] to getElem?_pos and variants.* #8615 provides a special empty iterator type. Although its behavior\ncan be emulated with a list iterator (for example), having a special\ntype has the advantage of being easier to optimize for the compiler.* #8620 removes the NatCast (Fin n) global instance (both the direct\ninstance, and the indirect one via Lean.Grind.Semiring), as that\ninstance causes causes x < n (for x : Fin k, n : Nat) to be\nelaborated as x < ↑n rather than ↑x < n, which is undesirable. Note\nhowever that in Mathlib this happens anyway!* #8629 replaces special, more optimized IteratorLoop instances, for\nwhich no lawfulness proof has been made, with the verified default\nimplementation. The specialization of the loop/collect implementations\nis low priority, but having lawfulness instances for all iterators is\nimportant for verification.* #8631 generalizes Std.Sat.AIG. relabel(Nat)_unsat_iff to allow the\nAIG type to be empty. We generalize the proof, by showing that in the\ncase when α is empty, the environment doesn't matter, since all\nenvironments α → Bool are isomorphic.* #8640 adds BitVec.setWidth'_eq to bv_normalize such that\nbv_decide can reduce it and solve lemmas involving setWidth'_eq* #8669 makes unsafeBaseIO noinline. The new compiler is better at\noptimizing Result-like types, which can cause the final operation in\nan unsafeBaseIO block to be dropped, since unsafeBaseIO is\ndiscarding the state.* #8678 makes the LHS of isSome_finIdxOf? and isNone_finIdxOf? more\ngeneral.* #8703 corrects the IteratorLoop instance in DropWhile, which\npreviously triggered for arbitrary iterator types.* #8719 adds grind annotations for\nList/Array/Vector.eraseP/erase/eraseIdx. It also adds some missing\nlemmas.* #8721 adds the types Std.ExtDTreeMap, Std.ExtTreeMap and\nStd.ExtTreeSet of extensional tree maps and sets. These are very\nsimilar in construction to the existing extensional hash maps with one\nexception: extensional tree maps and sets provide all functions from\nregular tree maps and sets. This is possible because in contrast to hash\nmaps, tree maps are always ordered.* #8734 adds the missing instanceinstance decidableExistsFin (P : Fin n → Prop) [DecidablePred P] : Decidable (∃ i, P i)\n* #8740 introduces associativity rules and preservation of (umul, smul, uadd, sadd)Overflowflags.* #8741 adds annotations for\nList/Array/Vector.find?/findSome?/idxOf?/findIdx?.* #8742 fixes a bug where the single-quote character Char.ofNat 39\nwould delaborate as ''', which causes a parse error if pasted back in\nto the source code.* #8745 adds a logic of stateful predicates SPred to Std.Do in order\nto support reasoning about monadic programs. It comes with a dedicated\nproof mode the tactics of which are accessible by importing\nStd.Tactic.Do.* #8747 adds grind annotations for `List/Array/Vector.finRange`\ntheorems.* #8748 adds grind annotations for Array/Vector.mapIdx and mapFinIdx\ntheorems.* #8749 adds grind annotations for List/Array/Vector.ofFn theorems and\nadditional List.Impl find operations.* #8750 adds grind annotations for the\nList/Array/Vector.zipWith/zipWithAll/unzip functions.* #8765 adds grind annotations for List.Perm; involves a revision of\ngrind annotations for List.countP/count as well.* #8768 introduces a ForIn' instance and a size function for\niterators in a minimal fashion. The ForIn' instance is not marked as\nan instance because it is unclear which Membership relation is\nsufficiently useful. The ForIn' instance existing as a def and\ninducing the ForIn instance, it becomes possible to provide more\nspecialized ForIn' instances, with nice Membership relations, for\nvarious types of iterators. The size function has no lemmas yet.* #8784 introduces ranges that are polymorphic, in contrast to the\nexisting Std.Range which only supports natural numbers.* #8805 continues adding grind annotations for List/Array/Vector\nlemmas.* #8808 adds the missing le_of_add_left_le {n m k : Nat} (h : k + n ≤ m) : n ≤ m and le_add_left_of_le {n m k : Nat} (h : n ≤ m) : n ≤ k + m.* #8811 adds theorems BitVec.(toNat, toInt, toFin)_shiftLeftZeroExtend, completing the API for\nBitVec.shiftLeftZeroExtend.* #8826 corrects the definition of Lean.Grind.NatModule, which wasn't\npreviously useful.* #8827 renames BitVec.getLsb' to BitVec.getLsb, now that older\ndeprecated definition occupying that name has been removed. (Similarly\nfor BitVec.getMsb'.)* #8829 avoids importing all of BitVec.Lemmas and BitVec.BitBlast\ninto UInt.Lemmas. (They are still imported into SInt.Lemmas; this\nseems much harder to avoid.)* #8830 rearranges files under Init.Grind, moving out instances for\nconcrete algebraic types in Init.GrindInstances.* #8849 adds grind annotations for Sum.* #8850 adds grind annotations for Prod.* #8851 adds grind annotations for Function.curry/uncurry.* #8852 adds grind annotations for Nat.testBit and bitwise operations\non Nat.* #8853 adds grind annotations relating Nat.fold/foldRev/any/all and\nFin.foldl/foldr/foldlM/foldrM to the corresponding operations on\nList.finRange.* #8877 adds grind annotations for\nList/Array/Vector.attach/attachWith/pmap.* #8878 adds grind annotations for List/Array/Vector monadic functions.* #8886 adds IO.FS.Stream.readToEnd which parallels\nIO.FS.Handle.readToEnd along with its upstream definitions (i.e.,\nreadBinToEndInto and readBinToEnd). It also removes an unnecessary\npartial from IO.FS.Handle.readBinToEnd.* #8887 generalizes IO.FS.lines with IO.FS.Handle.lines and adds the\nparallel IO.FS.Stream.lines for streams.* #8897 simplifies some simp calls.* #8905 uses the linter from\nhttps://github.com/leanprover/lean4/pull/8901 to clean up simp\narguments.* #8920 uses the linter from #8901 to clean up more simp arguments,\ncompleting #8905.* #8928 adds a logic of stateful predicates SPred to Std.Do in order to\nsupport reasoning about monadic programs. It comes with a dedicated\nproof mode the tactics of which are accessible by importing\nStd.Tactic.Do.* #8941 adds BitVec.(getElem, getLsbD, getMsbD)_(smod, sdiv, srem)\ntheorems to complete the API for sdiv, srem, smod. Even though the\nrhs is not particularly succint (it's hard to find a meaning for what it\nmeans to have \"the n-th bit of the result of a signed division/modulo\noperation\"), these lemmas prevent the need to unfold of operations.* #8947 introduces polymorphic slices in their most basic form. They\ncome with a notation similar to the new range notation. Subarray is\nnow also a slice and can produce an iterator now. It is intended to\nmigrate more operations of Subarray to the Slice wrapper type to\nmake them available for slices of other types, too.* #8950 adds BitVec.toFin_(sdiv, smod, srem) and BitVec.toNat_srem.\nThe strategy for the rhs of the toFin_* lemmas is to consider what\nthe corresponding toNat_* theorems do and push the toFin closerto\nthe operands. For the rhs of BitVec.toNat_srem I used the same\nstrategy as BitVec.toNat_smod.* #8967 both adds initial @[grind] annotations for BitVec, and uses\ngrind to remove many proofs from BitVec/Lemmas.* #8974 adds BitVec.msb_(smod, srem).* #8977 adds a generic MonadLiftT Id m instance. We do not implement a\nMonadLift Id m instance because it would slow down instance resolution\nand because it would create more non-canonical instances. This change\nmakes it possible to iterate over a pure iterator, such as [1, 2, 3].iter, in arbitrary monads.* #8992 adds PULift, a more general form of ULift and PLift that\nsubsumes both.* #8995 introduces a Hoare logic for monadic programs in\nStd.Do.Triple, and assorted tactics:* mspec for applying Hoare triple specifications* mvcgen to turn a Hoare triple proof obligation ⦃P⦄ prog ⦃Q⦄ into\npure verification conditoins (i.e., without any traces of Hoare triples\nor weakest preconditions reminiscent of prog). The resulting\nverification conditions in the stateful logic of Std.Do.SPred can be\ndischarged manually with the tactics coming with its custom proof mode\nor with automation such as simp and grind.* #9027 provides an iterator combinator that lifts the emitted values\ninto a higher universe level via ULift. This combinator is then used\nto make the subarray iterators universe-polymorphic. Previously, they\nwere only available for Subarray α if α : Type.* #9030 fixes a couple of bootstrapping-related hiccups in the newly\nadded Std.Do module. More precisely,* #9038 adds test cases for the VC generator and implements a few small\nand tedious fixes to ensure they pass.* #9049 proves that the default toList, toListRev and toArray\nfunctions on slices can be described in terms of the slice iterator.\nRelying on new lemmas for the uLift and attachWith iterator\ncombinators, a more concrete description of said functions is given for\nSubarray.* #9054 corrects some inconsistencies in TreeMap/HashMap grind\nannotations, for isSome_get?_eq_contains and empty_eq_emptyc.* #9055 renames Array/Vector.extract_push to extract_push_of_le, and\nreplaces the lemma with one without a side condition.* #9058 provides a ToStream instance for slices so that they can be\nused in for i in xs, j in ys do notation.* #9075 adds BEq instances for ByteArray and FloatArray (also a\nDecidableEq instance for ByteArray).\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)","header":"Library","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Library"}});