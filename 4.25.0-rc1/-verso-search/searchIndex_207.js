window.docContents[207].resolve({"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Copying":{"contents":"Creates a String from a String.Slice by copying the bytes.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009String Slices\u0009API Reference","header":"19.8.4.12.1.1. Copying","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--String-Slices--API-Reference--Copying"},"/Basic-Types/The-Empty-Type/#The-Lean-Language-Reference--Basic-Types--The-Empty-Type--API-Reference":{"contents":"Empty.elim : Empty → C says that a value of any type can be constructed from\nEmpty. This can be thought of as a compiler-checked assertion that a code path is unreachable.\n\nPEmpty.elim : Empty → C says that a value of any type can be constructed from\nPEmpty. This can be thought of as a compiler-checked assertion that a code path is unreachable.\n\n","context":"Lean Reference\u0009Basic Types\u0009The Empty Type","header":"19.10.1. API Reference","id":"/Basic-Types/The-Empty-Type/#The-Lean-Language-Reference--Basic-Types--The-Empty-Type--API-Reference"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#reader-monad":{"contents":"Reader monads provide the ability to implicitly thread a value through a computation. The value can\nbe read, but not written. A MonadWithReader ρ instance additionally allows the value to be locally\noverridden for a sub-computation.In this class, ρ is an outParam, which means that it is inferred from m. MonadReaderOf ρ\nprovides the same operations, but allows ρ to influence instance synthesis.Retrieves the local value.Use readThe to explicitly specify a type when more than one value is available.\n\nReader monads provide the ability to implicitly thread a value through a computation. The value can\nbe read, but not written. A MonadWithReader ρ instance additionally allows the value to be locally\noverridden for a sub-computation.In this class, ρ is a semiOutParam, which means that it can influence the choice of instance.\nMonadReader ρ provides the same operations, but requires that ρ be inferable from m.Retrieves the local value.\n\nRetrieves the local value whose type is ρ.  This is useful when a monad supports reading more than\none type of value.Use read for a version that expects the type ρ to be inferred from m.\n\nA reader monad that additionally allows the value to be locally overridden.In this class, ρ is an outParam, which means that it is inferred from m. MonadWithReaderOf ρ\nprovides the same operations, but allows ρ to influence instance synthesis.Locally modifies the reader monad's value while running an action.During the inner action x, reading the value returns f applied to the original value. After\ncontrol returns from x, the reader monad's value is restored.\n\nA reader monad that additionally allows the value to be locally overridden.In this class, ρ is a semiOutParam, which means that it can influence the choice of instance.\nMonadWithReader ρ provides the same operations, but requires that ρ be inferable from m.Locally modifies the reader monad's value while running an action.During the inner action x, reading the value returns f applied to the original value. After\ncontrol returns from x, the reader monad's value is restored.\n\nLocally modifies the reader monad's value while running an action, with the reader monad's local\nvalue type specified explicitly. This is useful when a monad supports reading more than one type of\nvalue.During the inner action x, reading the value returns f applied to the original value. After\ncontrol returns from x, the reader monad's value is restored.Use withReader for a version that expects the local value's type to be inferred from m.\n\nAdds the ability to access a read-only value of type ρ to a monad. The value can be locally\noverridden by withReader, but it cannot be mutated.Actions in the resulting monad are functions that take the local value as a parameter, returning\nordinary actions in m.\n\nA monad with access to a read-only value of type ρ. The value can be locally overridden by\nwithReader, but it cannot be mutated.\n\nExecutes an action from a monad with a read-only value in the underlying monad m.\n\nRetrieves the reader monad's local value. Typically accessed via read, or via readThe when more\nthan one local value is available.\n\nModifies a reader monad's local value with f. The resulting computation applies f to the\nincoming local value and passes the result to the inner computation.\n\nReturns the provided value a, ignoring the reader monad's local value. Typically used via\nPure.pure.\n\nSequences two reader monad computations. Both are provided with the local value, and the second is\npassed the value of the first. Typically used via the >>= operator.\n\nRecovers from errors. The same local value is provided to both branches. Typically used via the\n<|> operator.\n\nFails with a recoverable error.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.5. Reader","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#reader-monad"},"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--___Morally-Canonical___-Instances":{"contents":"During instance synthesis, if a goal is fully known (that is, contains no metavariables) and search succeeds, no further instances will be attempted for that same goal.\nIn other words, when search succeeds for a goal in a way that can't be refuted by a subsequent increase in information, the goal will not be attempted again, even if there are other instances that could potentially have been used.\nThis optimization can prevent a failure in a later branch of an instance synthesis search from causing spurious backtracking that replaces a fast solution from an earlier branch with a slow exploration of a large state space.\n\nThe optimization relies on the assumption that instances are morally canonical.\nEven if there is more than one potential implementation of a given type class's overloaded operations, or more than one way to synthesize an instance due to diamonds, any discovered instance should be considered as good as any other.\nIn other words, there's no need to consider all potential instances so long as one of them has been guaranteed to work.\nThe optimization may be disabled with the backwards-compatibility option backward.synthInstance.canonInstances, which may be removed in a future version of Lean.\n\nCode that uses instance-implicit parameters should be prepared to consider all instances as equivalent.\nIn other words, it should be robust in the face of differences in synthesized instances.\nWhen the code relies on instances in fact being equivalent, it should either explicitly manipulate instances (e.g. via local definitions, by saving them in structure fields, or having a structure inherit from the appropriate class) or it should make this dependency explicit in the type, so that different choices of instance lead to incompatible types.\n\n","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","header":"11.3.7. “Morally Canonical” Instances","id":"/Type-Classes/Instance-Synthesis/#The-Lean-Language-Reference--Type-Classes--Instance-Synthesis--___Morally-Canonical___-Instances"}});