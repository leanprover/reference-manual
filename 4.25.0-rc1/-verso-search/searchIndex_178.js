window.docContents[178].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Syntax":{"contents":"There is an OfNat (BitVec w) n instance for all widths w and natural numbers n.\nNatural number literals, including those that use hexadecimal or binary notation, may be used to represent bitvectors in contexts where the expected type is known.\nWhen the expected type is not known, a dedicated syntax allows the width of the bitvector to be specified along with its value.\n\nNumeric Literals for BitvectorsThe following literals are all equivalent:example : BitVec 8 := 0xff\nexample : BitVec 8 := 255\nexample : BitVec 8 := 0b1111_1111\n\n\nFixed-Width Bitvector LiteralsThis notation pairs a numeric literal with a term that denotes its width.\nSpaces are forbidden around the #.\nLiterals that overflow the width of the bitvector are truncated.\n\nFixed-Width Bitvector LiteralsBitvectors may be represented by natural number literals, so (5 : BitVec 8) is a valid bitvector.\nAdditionally, a width may be specified directly in the literal:5#8\nSpaces are not allowed on either side of the #:5 #8\n<example>:1:2-1:3: expected end of input\n5# 8\n<example>:1:3-1:4: expected no space before\nA numeric literal is required to the left of the #:(3 + 2)#8\n<example>:1:7-1:8: expected end of input\nHowever, a term is allowed to the right of the #:5#(4 + 4)\nIf the literal is too large to fit in the specified number of bits, then it is truncated:#eval 7#2\n3#2\n\n\nBounded Bitvector LiteralsThis notation is available only when the BitVec namespace has been opened.\nRather than an explicit width, it expects a proof that the literal value is representable by a bitvector of the corresponding width.\n\nBounded Bitvector LiteralsThe bounded bitvector literal notation ensures that literals do not overflow the specified number of bits.\nThe notation is only available when the BitVec namespace has been opened.open BitVec\nLiterals that are in bounds require a proof to that effect:example : BitVec 8 := 1#'(by decide)\nLiterals that are not in bounds are not allowed:example : BitVec 8 := 256#'(by decide)\nTactic `decide` proved that the proposition\n  256 < 2 ^ 8\nis false\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors","header":"19.5.3. Syntax","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Syntax"},"/Definitions/Recursive-Definitions/#mutual-structural-recursion":{"contents":"Lean supports the definition of mutually recursive functions using structural recursion.\nMutual recursion may be introduced using a mutual block, but it also results from let rec expressions and where blocks.\nThe rules for mutual structural recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the elaboration steps for mutual groups.\nIf every function in the mutual group has a termination_by structural annotation indicating that function’s decreasing argument, then structural recursion is used to translate the definitions.\n\nThe requirements on the decreasing argument above are extended:\n\n* All the types of all the decreasing arguments must be from the same inductive type, or more generally from the same mutual group of inductive types.* The parameters of the decreasing parameter's types must be the same for all functions, and may depend only on the common fixed prefix of function arguments.\n\nThe functions do not have to be in a one-to-one correspondence to the mutual inductive types.\nMultiple functions can have a decreasing argument of the same type, and not all types that are mutually recursive with the decreasing argument need have a corresponding function.\n\nMutual Structural Recursion Over Non-Mutual TypesThe following example demonstrates mutual recursion over a non-mutual inductive data type:mutual\n  def even : Nat → Prop\n    | 0 => True\n    | n+1 => odd n\n  termination_by structural n => n\n\n  def odd : Nat → Prop\n    | 0 => False\n    | n+1 => even n\n  termination_by structural n => n\nend\n\n\nMutual Structural Recursion Over Mutual TypesThe following example demonstrates recursion over mutually inductive types.\nThe functions Exp.size and App.size are mutually recursive.mutual\n  inductive Exp where\n    | var : String → Exp\n    | app : App → Exp\n\n  inductive App where\n    | fn : String → App\n    | app : App → Exp → App\nend\n\nmutual\n  def Exp.size : Exp → Nat\n    | .var _ => 1\n    | .app a => a.size\n  termination_by structural e => e\n\n  def App.size : App → Nat\n    | .fn _ => 1\n    | .app a e => a.size + e.size + 1\n  termination_by structural a => a\nend\nThe definition of App.numArgs is structurally recursive over type App.\nIt demonstrates that not all inductive types in the mutual group need to be handled.def App.numArgs : App → Nat\n  | .fn _ => 0\n  | .app a _ => a.numArgs + 1\ntermination_by structural a => a\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Structural Recursion","header":"7.6.2.2. Mutual Structural Recursion","id":"/Definitions/Recursive-Definitions/#mutual-structural-recursion"},"/The-Type-System/Inductive-Types/#inductive-types-logical-model":{"contents":"\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.3. Logical Model","id":"/The-Type-System/Inductive-Types/#inductive-types-logical-model"}});