window.docContents[245].resolve({"/Build-Tools-and-Distribution/Lake/#lake-config-lean":{"contents":"The Lean format for Lake package configuration files provides a domain-specific language for the declarative features that are supported in the TOML format.\nAdditionally, it provides the ability to write Lean code to implement any necessary build logic that is not expressible declaratively.\n\nBecause the Lean format is a Lean source file, it can be edited using all the features of the Lean language server.\nAdditionally, Lean's metaprogramming framework allows elaboration-time side effects to be used to implement features such as configuration steps that are conditional on the current platform.\nHowever, a consequence of the Lean configuration format being a Lean file is that it is not feasible to process such files using tools that are not themselves written in Lean.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format","header":"22.1.3.2. Lean Format","id":"/Build-Tools-and-Distribution/Lake/#lake-config-lean"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#option-monad":{"contents":"Ordinarily, Option is thought of as data, similarly to a nullable type.\nIt can also be considered as a monad, and thus a way of performing computations.\nThe Option monad and its transformer OptionT can be understood as describing computations that may terminate early, discarding the results.\nCallers can check for early termination and invoke a fallback if desired using OrElse.orElse or by treating it as a MonadExcept Unit.\n\nAdds the ability to fail to a monad. Unlike ordinary exceptions, there is no way to signal why a\nfailure occurred.\n\nExecutes an action that might fail in the underlying monad m, returning none in case of failure.\n\nConverts a computation from the underlying monad into one that could fail, even though it does not.This function is typically implicitly accessed via a MonadLiftT instance as part of automatic\nlifting.\n\nConverts an action that returns an Option into one that might fail, with none indicating\nfailure.\n\nSucceeds with the provided value.\n\nSequences two potentially-failing actions. The second action is run only if the first succeeds.\n\nA recoverable failure.\n\nRecovers from failures. Typically used via the <|> operator.\n\nHandles failures by treating them as exceptions of type Unit.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.6. Option","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#option-monad"},"/Interacting-with-Lean/#format-join":{"contents":"The operators in this section are useful when there is some kind of repeated content, such as the elements of a list.\nThis is typically done by including line in their separator parameters, using a bracketing operator\n\nConcatenates a list of Formats with ++.\n\nIntercalates the given list with the given sep format.The list items are formatting using ToFormat.format.\n\nConcatenates the given list after prepending pre to each element.The list items are formatting using ToFormat.format.\n\nConcatenates the given list after appending the given suffix to each element.The list items are formatting using ToFormat.format.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.3. Sequences","id":"/Interacting-with-Lean/#format-join"},"/Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Exporting-Names":{"contents":"Exporting a name makes it available in the current namespace.\nUnlike a definition, this alias is completely transparent: uses are resolved directly to the original name.\nExporting a name to the root namespace makes it available without qualification; the Lean standard library does this for names such as the constructors of Option and key type class methods such as get.\n\nExporting NamesThe export command adds names from other namespaces to the current namespace, as if they had been declared in it.\nWhen the current namespace is opened, these exported names are also brought into scope.Internally, exported names are registered as aliases of their targets.\nFrom the perspective of the kernel, only the original name exists; the elaborator resolves aliases as part of resolving identifiers to names.\n\nExported NamesThe declaration of the inductive type Veg.Leafy establishes the constructors Veg.Leafy.spinach and Veg.Leafy.cabbage:namespace Veg\ninductive Leafy where\n  | spinach\n  | cabbage\nexport Leafy (spinach)\nend Veg\nexport Veg.Leafy (cabbage)\nThe first export command makes Veg.Leafy.spinach accessible as Veg.spinach because the current namespace is Veg.\nThe second makes Veg.Leafy.cabbage accessible as cabbage, because the current namespace is the root namespace.\n\n","context":"Lean Reference\u0009Namespaces and Sections\u0009Namespaces","header":"6.1.2. Exporting Names","id":"/Namespaces-and-Sections/#The-Lean-Language-Reference--Namespaces-and-Sections--Namespaces--Exporting-Names"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-intro":{"contents":"If the main goal's target type is an inductive type, constructor solves it with\nthe first matching constructor, or else fails.\n\nThe injection tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if c is a constructor of an inductive datatype, and if (c t₁)\nand (c t₂) are two terms that are equal then  t₁ and t₂ are equal too.\nIf q is a proof of a statement of conclusion t₁ = t₂, then injection applies\ninjectivity to derive the equality of all arguments of t₁ and t₂ placed in\nthe same positions. For example, from (a::b) = (c::d) we derive a=c and b=d.\nTo use this tactic t₁ and t₂ should be constructor applications of the same constructor.\nGiven h : a::b = c::d, the tactic injection h adds two new hypothesis with types\na = c and b = d to the main goal.\nThe tactic injection h with h₁ h₂ uses the names h₁ and h₂ to name the new hypotheses.\n\ninjections applies injection to all hypotheses recursively\n(since injection can produce new hypotheses). Useful for destructing nested\nconstructor equalities like (a::b::c) = (d::e::f).\n\nApplies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.example : True ∨ False := by\n  left\n  trivial\n\n\nApplies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.example {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Inductive Types","header":"13.5.14.1. Introduction","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-intro"},"/The-Type-System/Inductive-Types/#inductive-types-runtime-special-support":{"contents":"Not every inductive type is represented as indicated here—some inductive types have special support from the Lean compiler:\n\n* The representation of the fixed-width integer types UInt8, …, UInt64, Int8, …, Int64, and USize depends on the whether the code is compiled for a 32- or 64-bit architecture.\n  Their representation is described in a dedicated section.* Char is represented by uint32_t. Because Char values never require more than 21 bits, they are always unboxed.* Float is represented by a pointer to a Lean object that contains a double.* An enum inductive type of at least 2 and at most 2^{32} constructors, each of which has no parameters, is represented by the first type of uint8_t, uint16_t, uint32_t that is sufficient to assign a unique value to each constructor. For example, the type Bool is represented by uint8_t, with values 0 for false and 1 for true. * Decidable α is represented the same way as Bool * Nat and Int are represented by lean_object *.\n  Their representations are described in more detail in the section on natural numbers and the section on integers.\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation","header":"4.4.4.1. Exceptions","id":"/The-Type-System/Inductive-Types/#inductive-types-runtime-special-support"}});