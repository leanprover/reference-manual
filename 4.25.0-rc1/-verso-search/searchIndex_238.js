window.docContents[238].resolve({"/Basic-Types/Tuples/#tuples":{"contents":"The Lean standard library includes a variety of tuple-like types.\nIn practice, they differ in four ways:* whether the first projection is a type or a proposition* whether the second projection is a type or a proposition* whether the second projection's type depends on the first projection's value* whether the type as a whole is a proposition or type\n\n* Type* First Projection* Second Projection* Dependent?* Universe* Prod* Type u* Type v* ❌️* Type (max u v)* And* Prop* Prop* ❌️* Prop* Sigma* Type u* Type v* ✔* Type (max u v)* Subtype* Type u* Prop* ✔* Type u* Exists* Type u* Prop* ✔* Prop\n\nSome potential rows in this table do not exist in the library:* There is no dependent pair where the first projection is a proposition, because proof irrelevance renders this meaningless.* There is no non-dependent pair that combines a type with a proposition because the situation is rare in practice: grouping data with unrelated proofs is uncommon.\n\nThese differences lead to very different use cases.\nProd and its variants PProd and MProd simply group data together—they are products.\nBecause its second projection is dependent, Sigma has the character of a sum: for each element of the first projection's type, there may be a different type in the second projection.\nSubtype selects the values of a type that satisfy a predicate.\nEven though it syntactically resembles a pair, in practice it is treated as an actual subset.\nAnd is a logical connective, and Exists is a quantifier.\nThis chapter documents the tuple-like pairs, namely Prod and Sigma.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.13. Tuples","id":"/Basic-Types/Tuples/#tuples"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Combined-Error-and-State-Monads":{"contents":"\n\nThe EStateM monad has both exceptions and mutable state.\nEStateM ε σ α is logically equivalent to ExceptT ε (StateM σ) α.\nWhile ExceptT ε (StateM σ) evaluates to the type σ → Except ε α × σ, the type EStateM ε σ α evaluates to σ → EStateM.Result ε σ α.\nEStateM.Result is an inductive type that's very similar to Except, except both constructors have an additional field for the state.\nIn compiled code, this representation removes one level of indirection from each monadic bind.\n\n\n\nA combined state and exception monad in which exceptions do not automatically roll back the state.Instances of EStateM.Backtrackable provide a way to roll back some part of the state if needed.EStateM ε σ is equivalent to ExceptT ε (StateM σ), but it is more efficient.\n\nThe value returned from a combined state and exception monad in which exceptions do not\nautomatically roll back the state.Result ε σ α is equivalent to Except ε α × σ, but using a single combined inductive type yields\na more efficient data representation.A success value of type α and a new state σ.An exception of type ε and a new state σ.\n\nExecutes an EStateM action with the initial state s. The returned value includes the final state\nand indicates whether an exception was thrown or a value was returned.\n\nExecutes an EStateM with the initial state s for the returned value α, discarding the final\nstate. Returns none if an unhandled exception was thrown.\n\nTransforms exceptions with a function, doing nothing on successful results.\n\nConverts a state monad action into a state monad action with exceptions.The resulting action does not throw an exception.\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.8. Combined Error and State Monads","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Combined-Error-and-State-Monads"},"/Notations-and-Macros/Macros/#macro-hygiene":{"contents":"A macro is hygienic if its expansion cannot result in identifier capture.\nIdentifier capture is when an identifier ends up referring to a binding site other than that which is in scope where the identifier occurs in the source code.\nThere are two types of identifier capture:\n\n* If a macro's expansion introduces binders, then identifiers that are parameters to the macro may end up referring to the introduced binders if their names happen to match.* If a macro's expansion is intended to refer to a name, but the macro is used in a context that either locally binds this name or in which a new global name has been introduced, it may end up referring to the wrong name.\n\nThe first kind of variable capture can be avoided by ensuring that every binding introduced by a macro uses a freshly generated, globally-unique name, while the second can be avoided by always using fully-qualified names to refer to constants.\nThe fresh names must be generated again at each invocation of the macro to avoid variable capture in recursive macros.\nThese techniques are error-prone.\nVariable capture issues are difficult to test for because they rely on coincidences of name choices, and consistently applying these techniques results in noisy code.\n\nLean features automatic hygiene: in almost all cases, macros are automatically hygienic.\nCapture by introduced bindings is avoided by annotating identifiers introduced by a macro with macro scopes, which uniquely identify each invocation of macro expansion.\nIf the binding and the use of the identifier have the same macro scopes, then they were introduced by the same step of macro expansion and should refer to one another.\nSimilarly, uses of global names in code generated by a macro are not captured by local bindings in the context in which they are expanded because these use sites have macro scopes that are not present in the binding occurrence.\nCapture by newly-introduced global names is prevented by annotating potential global name references with the set of global names that match at quotation time in code produced in the macro's body.\nIdentifiers annotated with potential referents are called pre-resolved identifiers, and the Syntax.Preresolved field on the Syntax.ident constructor is used to store the potential referents.\nDuring elaboration, if an identifier has pre-resolved global names associated with it, then other global names are not considered as valid reference targets.\n\nThe introduction of macro scopes and pre-resolved identifiers to generated syntax occurs during quotation.\nMacros that construct syntax by other means than quotation should also ensure hygiene by some other means.\nFor more details on Lean's hygiene algorithm, please consult .\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Macros","header":"20.5.1. Hygiene","id":"/Notations-and-Macros/Macros/#macro-hygiene"},"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Refactor-of-have___let-semantics":{"contents":"TL;DR: nondependent let bindings are now transformed to have bindings for better performance.\nSyntax of have and let is unified, and new options are added.\n\n* #8373 enables transforming nondependent lets into haves\nso simp works better without zeta reduction. Disable with set_option cleanup.letToHave false.* #8804 implements first-class support for nondependent let expressions\nin the elaborator. This has been given full support throughout the metaprogramming interface and the\nelaborator.* #8914 modifies let and have term syntaxes to be consistent with\neach other. Adds configuration options; for example, have is\nequivalent to let +nondep, for nondependent lets. Other options\ninclude +usedOnly (for let_tmp), +zeta (for letI/haveI), and\n+postponeValue (for let_delayed). There is also let (eq := h) x := v; b\nfor introducing h : x = v when elaborating b. The eq option\nworks for pattern matching as well, for example let (eq := h) (x, y) := p; b.* #8935 adds the +generalize option to the let and have syntaxes.\nFor example, have +generalize n := a + b; body replaces all instances\nof a + b in the expected type with n when elaborating body. This\ncan be likened to a term version of the generalize tactic. One can\ncombine this with eq in have +generalize (eq := h) n := a + b; body\nas an analogue of generalize h : n = a + b.* #8954 adds a procedure that efficiently transforms let expressions\ninto have expressions (Meta.letToHave). This is exposed as the\nlet_to_have tactic.* #9086 deprecates let_fun syntax in favor of have and removes\nletFun support from WHNF and simp.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.22.0 (2025-08-14)\u0009Highlights","header":"Refactor of have/let semantics","id":"/releases/v4.22.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___22___0-_LPAR_2025-08-14_RPAR_--Highlights--Refactor-of-have___let-semantics"}});