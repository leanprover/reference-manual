window.docContents[218].resolve({"/Definitions/Recursive-Definitions/#wf-rel":{"contents":"A relation ≺ is a well-founded relation if there exists no infinitely descending chain\n\n x_0 ≻ x_1 ≻ \\cdots\n\nIn Lean, types that are equipped with a canonical well-founded relation are instances of the WellFoundedRelation type class.\n\nA type that has a standard well-founded relation.Instances are used to prove that functions terminate using well-founded recursion by showing that\nrecursive calls reduce some measure according to a well-founded relation. This relation can combine\nwell-founded relations on the recursive function's parameters.A well-founded relation on α.A proof that rel is, in fact, well-founded.\n\n\n\nThe most important instances are:\n\n* Nat, ordered by (· < ·).* Prod, ordered lexicographically: (a₁, b₁) ≺ (a₂, b₂) if and only if a₁ ≺ a₂ or a₁ = a₂ and b₁ ≺ b₂.* Every type that is an instance of the SizeOf type class, which provides a method SizeOf.sizeOf, has a well-founded relation.\n  For these types, x₁ ≺ x₂ if and only if sizeOf x₁ < sizeOf x₂. For inductive types, a SizeOf instance is automatically derived by Lean.\n\n\n\nNote that there exists a low-priority instance instSizeOfDefault that provides a SizeOf instance for any type, and always returns 0.\nThis instance cannot be used to prove that a function terminates using well-founded recursion because 0 < 0 is false.\n\n\n\nDefault Size InstanceFunction types in general do not have a well-founded relation that's useful for termination proofs.\nInstance synthesis thus selects instSizeOfDefault and the corresponding well-founded relation.\nIf the measure is a function, the default SizeOf instance is selected and the proof cannot succeed.def fooInst (b : Bool → Bool) : Unit := fooInst (b ∘ b)\ntermination_by b\ndecreasing_by\n  guard_target =\n    @sizeOf (Bool → Bool) (instSizeOfDefault _) (b ∘ b) < sizeOf b\n  simp only [sizeOf, default.sizeOf]\n  guard_target = 0 < 0\n  simp\n  guard_target = False\n  sorry\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","header":"7.6.3.1. Well-Founded Relations","id":"/Definitions/Recursive-Definitions/#wf-rel"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Token-and-Literal-Kinds":{"contents":"A number of named kinds are associated with the basic tokens produced by the parser.\nTypically, single-token syntax productions consist of a node that contains a single atom; the kind saved in the node allows the value to be recognized.\nAtoms for literals are not interpreted by the parser: string atoms include their leading and trailing double-quote characters along with any escape sequences contained within, and hexadecimal numerals are saved as a string that begins with \"0x\".\nHelpers such as Lean.TSyntax.getString are provided to perform this decoding on demand.\n\n\n\nThe pseudo-kind assigned to identifiers: `ident.The name `ident is not actually used as a kind for Syntax.node values. It is used by\nconvention as the kind of Syntax.ident values.\n\n`str is the node kind of string literals like \"foo\".\n\n`interpolatedStrKind is the node kind of an interpolated string literal like \"value = {x}\"\nin s!\"value = {x}\".\n\n`interpolatedStrLitKind is the node kind of interpolated string literal\nfragments like \"value = { and }\" in s!\"value = {x}\".\n\n`char is the node kind of character literals like 'A'.\n\n`num is the node kind of number literals like 42 and 0xa1\n\n`scientific is the node kind of floating point literals like 1.23e-3.\n\n`name is the node kind of name literals like `foo.\n\n`fieldIdx is the node kind of projection indices like the 2 in x.2.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.3. Token and Literal Kinds","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Token-and-Literal-Kinds"}});