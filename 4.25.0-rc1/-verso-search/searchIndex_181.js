window.docContents[181].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Sine":{"contents":"Computes the sine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsin.\n\nComputes the sine of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsinf.\n\nComputes the hyperbolic sine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsinh.\n\nComputes the hyperbolic sine of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nsinhf.\n\nComputes the arc sine (inverse sine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nasin.\n\nComputes the arc sine (inverse sine) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nasinf.\n\nComputes the hyperbolic arc sine (inverse sine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nasinh.\n\nComputes the hyperbolic arc sine (inverse sine) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nasinhf.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Trigonometry","header":"19.6.2.9.1. Sine","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Sine"},"/Basic-Types/Natural-Numbers/#nat-api-arithmetic":{"contents":"The predecessor of a natural number is one less than it. The predecessor of 0 is defined to be\n0.This definition is overridden in the compiler with an efficient implementation. This definition is\nthe logical model.\n\nAddition of natural numbers, typically used via the + operator.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nSubtraction of natural numbers, truncated at 0. Usually used via the - operator.If a result would be less than zero, then the result is zero.This definition is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.Examples:* 5 - 3 = 2* 8 - 2 = 6* 8 - 8 = 0* 8 - 20 = 0\n\nMultiplication of natural numbers, usually accessed via the * operator.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nDivision of natural numbers, discarding the remainder. Division by 0 returns 0. Usually accessed\nvia the / operator.This operation is sometimes called “floor division.”This function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.Examples:* 21 / 3 = 7* 21 / 5 = 4* 0 / 22 = 0* 5 / 0 = 0\n\nThe modulo operator, which computes the remainder when dividing one natural number by another.\nUsually accessed via the % operator. When the divisor is 0, the result is the dividend rather\nthan an error.Nat.mod is a wrapper around Nat.modCore that special-cases two situations, giving better\ndefinitional reductions:* Nat.mod 0 m should reduce to m, for all terms m : Nat.* Nat.mod n (m + n + 1) should reduce to n for concrete Nat literals n.These reductions help Fin n literals work well, because the OfNat instance for Fin uses\nNat.mod. In particular, (0 : Fin (n + 1)).val should reduce definitionally to 0. Nat.modCore\ncan handle all numbers, but its definitional reductions are not as convenient.This function is overridden at runtime with an efficient implementation. This definition is the\nlogical model.Examples:* 7 % 2 = 1* 9 % 3 = 0* 5 % 7 = 5* 5 % 0 = 5* show ∀ (n : Nat), 0 % n = 0 from fun _ => rfl* show ∀ (m : Nat), 5 % (m + 6) = 5 from fun _ => rfl\n\nThe modulo operator, which computes the remainder when dividing one natural number by another.\nUsually accessed via the % operator. When the divisor is 0, the result is the dividend rather\nthan an error.This is the core implementation of Nat.mod. It computes the correct result for any two closed\nnatural numbers, but it does not have some convenient definitional\nreductions when the Nats contain free variables. The wrapper\nNat.mod handles those cases specially and then calls Nat.modCore.This function is overridden at runtime with an efficient implementation. This definition is the\nlogical model.\n\nThe power operation on natural numbers, usually accessed via the ^ operator.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nBase-two logarithm of natural numbers. Returns ⌊max 0 (log₂ n)⌋.This function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.Examples:* Nat.log2 0 = 0* Nat.log2 1 = 0* Nat.log2 2 = 1* Nat.log2 4 = 2* Nat.log2 7 = 2* Nat.log2 8 = 3\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference","header":"19.1.4.1. Arithmetic","id":"/Basic-Types/Natural-Numbers/#nat-api-arithmetic"},"/Notations-and-Macros/Defining-New-Syntax/#syntax-ext":{"contents":"Lean's uniform representation of syntax is very general and flexible.\nThis means that extensions to Lean's parser do not require extensions to the representation of parsed syntax.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Notations and Macros","header":"20.4. Defining New Syntax","id":"/Notations-and-Macros/Defining-New-Syntax/#syntax-ext"},"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Breaking-changes":{"contents":"* #9749 refactors the Lake codebase to use the new module system\nthroughout. Every module in Lake is now a module.Breaking change: Since the module system encourages a private-by-default design,\nthe Lake API has switched from its previous public-by-default approach. As such,\nmany definitions that were previously public are now private. The newly private definitions\nare not expected to have had significant user use, nonetheless, important use cases could be missed.\nIf a key API is now inaccessible but seems like it should be public, users are encouraged\nto report this as an issue on GitHub.\n\n","context":"Lean Reference\u0009Release Notes\u0009Lean 4.24.0 (2025-10-14)\u0009Highlights","header":"Breaking changes","id":"/releases/v4.24.0/#The-Lean-Language-Reference--Release-Notes--Lean-4___24___0-_LPAR_2025-10-14_RPAR_--Highlights--Breaking-changes"}});